{"id": "aeb81443-73b1-40be-bc56-65d8f262536f", "solution": "import numpy as np\n\nclass AdaptiveHybridSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // dim)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.arange(self.population_size)\n                np.random.shuffle(idxs)\n                a, b, c = self.population[idxs[:3]]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def local_search(self, func):\n        step_size = 0.1\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                candidate = self.population[i] + step_size * np.random.uniform(-1, 1, self.dim)\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.local_search(func)\n        return self.best_solution", "name": "AdaptiveHybridSearch", "description": "Adaptive Hybrid Search (AHS) combining differential evolution and local search for efficient exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.17843834404005848, "feedback": "The algorithm AdaptiveHybridSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3814602594398083, 0.34810019632173184, 0.349418430138309, 0.4158178751713363, 0.4284127889329862, 0.4168595833964247, 0.4162078964891711, 0.3927179077087217, 0.37994583861349573, 0.13221248920562212, 0.13739267115981568, 0.12934268897477363, 0.12516698024466955, 0.13510177088171005, 0.13452680984185372, 0.14793664695652242, 0.1702894124183575, 0.1375421085504257, 0.06335432779277839, 0.07308120138803464, 0.07953162171779893, 0.08712210251449959, 0.09338238967344059, 0.08290058135240652, 0.080165940889107, 0.07306998135664289, 0.08774089546099817, 0.06370946622170215, 0.06570490419989217, 0.08681951052211734, 0.06397065171093985, 0.06946358191110591, 0.05998262011096234, 0.06588038749860337, 0.06428435064408022, 0.07243269802722585, 0.9707775153746421, 0.8359325537906778, 0.9444773572982152, 0.9243941789486397, 0.8420897140445864, 0.8840955702685567, 0.9510721274672278, 0.9240713707686502, 0.9474599807160157, 0.15982138754131847, 0.1649774486775203, 0.16169238180635348, 0.17006475743068972, 0.16959576846049718, 0.18713719829108988, 0.18480321720011184, 0.17703984006628126, 0.19465724146290608, 0.21585799604767097, 0.2205485812936484, 0.19718980933183472, 0.24576959423408284, 0.22925376975443246, 0.2187450088126388, 0.22502304756114777, 0.23257087515026797, 0.20976353281920168, 0.10133971949986231, 0.07908483516844589, 0.10545609781629262, 0.09826540673423623, 0.09815844001028451, 0.09947114551050729, 0.10298630963444866, 0.08275937646318088, 0.08317914166169527, 0.15781342353103844, 0.10290820987953264, 0.11895437429599354, 0.0888233860422244, 0.07945255142407914, 0.09638777142194033, 0.0598019710443366, 0.08061888318343224, 0.08967254569920802, 0.012305927158046459, 0.02007156748210359, 0.015055363987413917, 0.015404465031268355, 0.017072132867345657, 0.019434848317846032, 0.025258709321223205, 0.021581592239506286, 0.01713035655761619, 0.12285752891999524, 0.14154028696913634, 0.13318926020490018, 0.1203062845216516, 0.0966023127108816, 0.089037329149118, 0.1468841991804175, 0.15728315368630286, 0.14529461864051196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019489605472992277, 0.0818887339068789, 0.07687184357806676, 0.067117458093367, 0.07712522047645876, 0.07290201429446497, 0.07729486940286678, 0.0723462203142774, 0.07921363694745798, 0.08491333957775737, 0.3107343953517767, 0.3388807451850011, 0.3329887655124979, 0.36698107805700575, 0.3433738760469194, 0.34680848799460695, 0.3187295879148252, 0.3409239306697379, 0.357607944685026, 0.07502551615304165, 0.0742878980458801, 0.0860586662321624, 0.06544608348567249, 0.07358145614031708, 0.07745083313965573, 0.07306034788250271, 0.06321877692972178, 0.07661979109569506, 0.16125106609237772, 0.1611529119951408, 0.14839147160754163, 0.16295000539854987, 0.1208690160616892, 0.12176246658083512, 0.1315416790241165, 0.11794731528450098, 0.13625577329558636, 0.2226605282922275, 0.1976733149773855, 0.21860452813900866, 0.18404031807299748, 0.19165559983456393, 0.20516097216507445, 0.21559258852216667, 0.23329670785252643, 0.2196818137402623, 0.16827264655998475, 0.14253626517338636, 0.15210628853447383, 0.14318963011043384, 0.1460968924997853, 0.14476363790544533, 0.151644716514569, 0.16025063856817778, 0.1684573341872878, 0.1836332917143696, 0.15302550532634684, 0.17310314877855126, 0.1634338588931623, 0.17085221371479087, 0.18018791215986363, 0.18596737223389426, 0.16097100386094387, 0.170514914189829, 0.15479110916184158, 0.1757420206881125, 0.15573953885978153, 0.16124565332076413, 0.16521743498840546, 0.1590755338551284, 0.15812301802201523, 0.1639506311636818, 0.16892011421929387, 0.152117460347598, 0.29634626122533936, 0.38390845412296803, 0.1680335519603433, 0.16710270262855753, 0.1721582417698142, 0.1334088424959895, 0.19100679331269943, 0.20588250881007375, 0.15851936117706011, 0.17321726133603244, 0.15493030447784262, 0.1935824714208344, 0.16429759466892302, 0.1504298640334113, 0.19188399805054712, 0.2438045960548032, 0.200246325157998, 0.17347493342602882, 0.17251902386202034, 0.20111792515523585, 0.1758239213146522, 0.16081264535484407, 0.17801674949271018, 0.17196625728942838, 0.18922624795733167, 0.16691339457126775, 0.055118477555898826, 0.06180166087455896, 0.05308143415156741, 0.06927150208395705, 0.06034428283748272, 0.06009779506828705, 0.06994922951095173, 0.053844553006914264, 0.06300924333815305]}, "mutation_prompt": null}
{"id": "2e86a8f9-fbf0-426d-8761-2019b556b6d2", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // dim)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def adaptive_mutation_factor(self):\n        return 0.5 + 0.3 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.arange(self.population_size)\n                np.random.shuffle(idxs)\n                a, b, c = self.population[idxs[:3]]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def heuristic_local_search(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = self.best_solution - self.population[i]\n                candidate = self.population[i] + step_size * np.random.uniform(-1, 1, self.dim) + 0.1 * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.heuristic_local_search(func)\n        return self.best_solution", "name": "EnhancedHybridAdaptiveSearch", "description": "Enhanced Hybrid Adaptive Search (EHAS) leveraging adaptive mutation and heuristic-driven local search for accelerated convergence and robustness.", "configspace": "", "generation": 1, "fitness": 0.21326194119300734, "feedback": "The algorithm EnhancedHybridAdaptiveSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "aeb81443-73b1-40be-bc56-65d8f262536f", "metadata": {"aucs": [0.4808389158981786, 0.5237519406048073, 0.5180138180137851, 0.4867120964469125, 0.49762611835550696, 0.5281021372127017, 0.5061840737043, 0.5010454561348907, 0.4861341552605859, 0.20673095711528333, 0.25088526624989393, 0.24163782674914114, 0.19008825955780972, 0.22909588126179192, 0.2537824923823696, 0.21114975276069692, 0.2316124753181552, 0.23157073642502468, 0.08638941133762779, 0.08891808202644769, 0.08671708220949237, 0.09736348882055756, 0.08418693376995157, 0.09310077667460426, 0.08368856469084207, 0.08415798612550973, 0.08541950776512708, 0.08231260873193202, 0.08538481548773957, 0.07689119224397167, 0.06760806689335763, 0.0739428910123594, 0.09236003592334097, 0.07186481186606741, 0.0693483842535948, 0.07520617877896218, 0.8750349230336262, 0.9468988209740513, 0.831949286418363, 0.7079727930262523, 0.8271695742669308, 0.9200717074678405, 0.9193220708485398, 0.9522389810249918, 0.9522105106544672, 0.22810778419843136, 0.21249518981826954, 0.19187913856823247, 0.21686593227737627, 0.19837777178227778, 0.22210343310429637, 0.2119074205339383, 0.23988769655827202, 0.21991457065554854, 0.45084278020378465, 0.35831531514319226, 0.3370442068085766, 0.5123733626829335, 0.46944875732080416, 0.4151844496703938, 0.3919224432937779, 0.4326178770825243, 0.25602607990711534, 0.12254681499270714, 0.15035147337210342, 0.1205366717134273, 0.1252038900077449, 0.13325139506260053, 0.1375179067099398, 0.1343759272288837, 0.1099139787813943, 0.14332534613974823, 0.09695262161567475, 0.09336680148751308, 0.1263284309991055, 0.12965160922919805, 0.1348774644422629, 0.13085624300271537, 0.1426434590591139, 0.10540706566922586, 0.12145651601574081, 0.0691709284167702, 0.08284443459363733, 0.07021792695638274, 0.07845636328130057, 0.08672693422780775, 0.06058542430857583, 0.05723618492338989, 0.05395818264365859, 0.06318985184813342, 0.16300214567295457, 0.2024581378397199, 0.18211073224063634, 0.15156991700013533, 0.17446006325137808, 0.16857980742351752, 0.18736996098048198, 0.15597065935388288, 0.2116668088301955, 0.0035306569023807466, 0.001234635995551403, 0.0069649485818976675, 0.0066040275405430116, 0.002401042032213585, 0.0247918329625314, 0.029494715991812748, 0.021979156340535377, 0.02286302847008792, 0.09767999872815525, 0.10838517668210879, 0.10576483303205897, 0.11032356917335895, 0.12089418157974796, 0.10666269028050623, 0.13505373304167256, 0.11693174457894984, 0.10957913937160557, 0.4131681716957444, 0.40438349244840144, 0.4203651849730903, 0.4214082195387314, 0.42261738471073085, 0.4299264146076789, 0.4322527353734351, 0.40371747840826133, 0.42095148819263184, 0.0943069659704121, 0.07781925420163172, 0.08553967830720743, 0.07867059049086289, 0.07787512672551622, 0.08860212355579078, 0.07463514221925327, 0.06805312818616716, 0.09993165156194395, 0.12235276482385904, 0.12386278226166636, 0.12786337938114045, 0.11838199582982611, 0.11985874837805677, 0.1440335572861191, 0.12989329276783668, 0.12435456151979685, 0.14906808750472134, 0.24347301191843407, 0.25498278460414103, 0.2462304666212941, 0.25227787122361034, 0.212411524066216, 0.25815681055795814, 0.2534155065962761, 0.27284659826144864, 0.2520399766443191, 0.18350656416405808, 0.18441178396629854, 0.18352831809873205, 0.16636893734067748, 0.16024713126245516, 0.20680133888565766, 0.1965822552623735, 0.19413234701062743, 0.19912550456040456, 0.1884083506705878, 0.18133223044035862, 0.1952584658662736, 0.16815180030527677, 0.17806495700243363, 0.18238794633159505, 0.17101021299224795, 0.1810345959344033, 0.1777805519550718, 0.1664310363080651, 0.16575688251417486, 0.1918141642933343, 0.16934658549958292, 0.17878744693952198, 0.1813768667716762, 0.16492873772301642, 0.16808499398210264, 0.1704969080043256, 0.33446941566296307, 0.14449130628865892, 0.164698931732983, 0.26164933542603874, 0.21924312165110948, 0.15185952226121024, 0.15260373884681444, 0.17871945536984457, 0.16312920157933586, 0.21124848968283505, 0.1918389802239675, 0.21420117805933026, 0.17718304448085487, 0.15310313080202054, 0.3350591891558923, 0.4598325039386073, 0.14689803746679375, 0.1949651609774542, 0.2020616499307757, 0.18816762601300208, 0.1750731115854407, 0.16350216219935587, 0.18479416010583583, 0.17903416086527923, 0.1891014937779223, 0.16788155369690172, 0.17843647933770335, 0.07036831753474748, 0.08111482347875076, 0.06523052295029697, 0.06919643030754574, 0.0659186351692912, 0.06354322122477063, 0.07125910372235611, 0.08002206104883802, 0.07251192963900044]}, "mutation_prompt": null}
{"id": "62ce67b2-3e09-4f1b-9ae0-3271af13122c", "solution": "import numpy as np\n\nclass StochasticGuidedSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def adaptive_mutation_factor(self):\n        return 0.4 + 0.4 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.arange(self.population_size)\n                np.random.shuffle(idxs)\n                a, b, c = self.population[idxs[:3]]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.06\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "StochasticGuidedSearch", "description": "Stochastic Guided Search (SGS) combines adaptive differential evolution with stochastic hill climbing to efficiently explore and exploit the search space.", "configspace": "", "generation": 2, "fitness": 0.21810895216642057, "feedback": "The algorithm StochasticGuidedSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "2e86a8f9-fbf0-426d-8761-2019b556b6d2", "metadata": {"aucs": [0.5486880367522122, 0.5500874671324321, 0.5258758164174591, 0.5466638316292052, 0.5575718555164759, 0.5640315420720936, 0.5688718630786345, 0.5542727090247135, 0.5390807052254325, 0.28230191992314135, 0.28310713879549854, 0.2500450896508679, 0.26451598511325813, 0.2776934440825418, 0.24337251727874332, 0.2538104234066072, 0.2587606867078357, 0.27670814324205495, 0.08715657164213719, 0.09440843990388625, 0.08899841348171267, 0.08264883418863433, 0.09181561448832543, 0.11069741574654413, 0.09686046841890661, 0.12103533080296269, 0.10827983993875656, 0.08315785579733437, 0.09106069863148714, 0.07825636137349234, 0.10207389092613917, 0.08945349129542368, 0.0758021743910654, 0.10452550223531543, 0.07658383242888778, 0.08479367467773957, 0.84633285516887, 0.82883064840599, 0.9207925539162084, 0.9040246640448505, 0.8906606787314318, 0.9032289342036164, 0.9106017142211739, 0.9309514832409931, 0.9093061920583232, 0.21224883170465758, 0.2311744837391081, 0.21829608725873018, 0.20990853310472202, 0.21421315594630985, 0.2225405654041499, 0.2118746090271847, 0.22902993983972797, 0.23172870401205425, 0.3215844354968964, 0.3117773812944974, 0.2635833569316084, 0.4238108718274912, 0.35808950103531256, 0.4665809989635278, 0.4015775061516115, 0.2892141486771359, 0.3378625219380761, 0.15462520160470672, 0.14426763482255023, 0.16365362675044892, 0.13618852714962648, 0.14788776852042151, 0.11869173672033173, 0.142075144702016, 0.13178313757878346, 0.16021267645023507, 0.10611912234724608, 0.09458514967411502, 0.13445548737646207, 0.14503049965490156, 0.16505949256011898, 0.13373439440154067, 0.13623513272302012, 0.16339572996082752, 0.12258428538685329, 0.061118036889054705, 0.06968345807907173, 0.04757914707511268, 0.035679431645807225, 0.04493084552462456, 0.06964422195919073, 0.08135464303902806, 0.04293448919402143, 0.06982055799455245, 0.18425361252613215, 0.18807632675119812, 0.1643904318243975, 0.14580586478211877, 0.15742845216129442, 0.1789458164450336, 0.18707969455638662, 0.23005691224259694, 0.17363048856788443, 0.0005841794031750114, 0.0009994169244664786, 0.013582581471, 0.004554991959976329, 0.011775631271805476, 0.011661888115389596, 0.03003919001861599, 0.025316723051763246, 0.016716735240677738, 0.10864044644186688, 0.10717539517326113, 0.10721621154978289, 0.10952494699690796, 0.13059314000079014, 0.10817435000075726, 0.11302849087249522, 0.12816461528150924, 0.10986090920628344, 0.43373066825874795, 0.38927915127224577, 0.42780987743761456, 0.4396377476601586, 0.44199430976512455, 0.4016254939637748, 0.4056011855848437, 0.4157072325367628, 0.42498168813293546, 0.08265473390130906, 0.07728426740094707, 0.09552985577281159, 0.08506328111096029, 0.07670528091378215, 0.08995061489826217, 0.08160091867004249, 0.08279366854284709, 0.07308471724260113, 0.13442372403394443, 0.1482638127198994, 0.1439667886969932, 0.12807475917247135, 0.14366530971009217, 0.14845294271125675, 0.1679682172203515, 0.1333097762946176, 0.13061649220933236, 0.2613124078101725, 0.2505705192340727, 0.2765966934693379, 0.2357264106934298, 0.2554457376337582, 0.2512547464610807, 0.2725481342411442, 0.2925122323631867, 0.29337775614563466, 0.19817186873554582, 0.19243254294408774, 0.18052046660977228, 0.18685086002293894, 0.18354245867008412, 0.18246832367715948, 0.19853268103229604, 0.20637211825760005, 0.20028577099947753, 0.1692305220471746, 0.17912528777930914, 0.17809245333007007, 0.1895750548669597, 0.16453600930241796, 0.20389315687514975, 0.16699327186861668, 0.1753888410961465, 0.1793590823490233, 0.16547831731453166, 0.1759152164565021, 0.17197789825363996, 0.17654473328560671, 0.16355746753131783, 0.17776661025641383, 0.17891109182241471, 0.17655802517944263, 0.17186699360235158, 0.17407373781983548, 0.16737325887829668, 0.1574839933984853, 0.25813516159502037, 0.18070973272168123, 0.43165823897263667, 0.15673795418577952, 0.1791837344658237, 0.1573311283659441, 0.40410743738116384, 0.18870467542083713, 0.24495915359540577, 0.19558416047316873, 0.168914301352053, 0.1581047608817513, 0.18936842661157294, 0.1948901837200545, 0.14471062710967542, 0.19224160476174068, 0.1760632799585412, 0.1694766154937386, 0.1752120332534619, 0.17598759832622324, 0.20709000206901107, 0.19205973326623293, 0.19686083381476616, 0.1871390802817089, 0.06109117642920969, 0.06920483427694635, 0.06607480422126977, 0.0625741432520599, 0.06898764973038396, 0.06597791234425898, 0.07384238490457062, 0.06882427305504313, 0.08022679912144015]}, "mutation_prompt": null}
{"id": "de3adf8a-f9fd-4118-b0cc-d9768ee814f6", "solution": "import numpy as np\n\nclass AdaptiveEvolutionaryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def adaptive_mutation_factor(self):\n        return 0.5 + 0.3 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.arange(self.population_size)\n                np.random.shuffle(idxs)\n                a, b, c = self.population[idxs[:3]]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.normal(0, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveEvolutionaryOptimization", "description": "Adaptive Evolutionary Optimization (AEO) leverages dynamic mutation and crossover strategies with focused local searches for enhanced exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.21326194119300734, "feedback": "The algorithm AdaptiveEvolutionaryOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "62ce67b2-3e09-4f1b-9ae0-3271af13122c", "metadata": {"aucs": [0.4808389158981786, 0.5237519406048073, 0.5180138180137851, 0.4867120964469125, 0.49762611835550696, 0.5281021372127017, 0.5061840737043, 0.5010454561348907, 0.4861341552605859, 0.20673095711528333, 0.25088526624989393, 0.24163782674914114, 0.19008825955780972, 0.22909588126179192, 0.2537824923823696, 0.21114975276069692, 0.2316124753181552, 0.23157073642502468, 0.08638941133762779, 0.08891808202644769, 0.08671708220949237, 0.09736348882055756, 0.08418693376995157, 0.09310077667460426, 0.08368856469084207, 0.08415798612550973, 0.08541950776512708, 0.08231260873193202, 0.08538481548773957, 0.07689119224397167, 0.06760806689335763, 0.0739428910123594, 0.09236003592334097, 0.07186481186606741, 0.0693483842535948, 0.07520617877896218, 0.8750349230336262, 0.9468988209740513, 0.831949286418363, 0.7079727930262523, 0.8271695742669308, 0.9200717074678405, 0.9193220708485398, 0.9522389810249918, 0.9522105106544672, 0.22810778419843136, 0.21249518981826954, 0.19187913856823247, 0.21686593227737627, 0.19837777178227778, 0.22210343310429637, 0.2119074205339383, 0.23988769655827202, 0.21991457065554854, 0.45084278020378465, 0.35831531514319226, 0.3370442068085766, 0.5123733626829335, 0.46944875732080416, 0.4151844496703938, 0.3919224432937779, 0.4326178770825243, 0.25602607990711534, 0.12254681499270714, 0.15035147337210342, 0.1205366717134273, 0.1252038900077449, 0.13325139506260053, 0.1375179067099398, 0.1343759272288837, 0.1099139787813943, 0.14332534613974823, 0.09695262161567475, 0.09336680148751308, 0.1263284309991055, 0.12965160922919805, 0.1348774644422629, 0.13085624300271537, 0.1426434590591139, 0.10540706566922586, 0.12145651601574081, 0.0691709284167702, 0.08284443459363733, 0.07021792695638274, 0.07845636328130057, 0.08672693422780775, 0.06058542430857583, 0.05723618492338989, 0.05395818264365859, 0.06318985184813342, 0.16300214567295457, 0.2024581378397199, 0.18211073224063634, 0.15156991700013533, 0.17446006325137808, 0.16857980742351752, 0.18736996098048198, 0.15597065935388288, 0.2116668088301955, 0.0035306569023807466, 0.001234635995551403, 0.0069649485818976675, 0.0066040275405430116, 0.002401042032213585, 0.0247918329625314, 0.029494715991812748, 0.021979156340535377, 0.02286302847008792, 0.09767999872815525, 0.10838517668210879, 0.10576483303205897, 0.11032356917335895, 0.12089418157974796, 0.10666269028050623, 0.13505373304167256, 0.11693174457894984, 0.10957913937160557, 0.4131681716957444, 0.40438349244840144, 0.4203651849730903, 0.4214082195387314, 0.42261738471073085, 0.4299264146076789, 0.4322527353734351, 0.40371747840826133, 0.42095148819263184, 0.0943069659704121, 0.07781925420163172, 0.08553967830720743, 0.07867059049086289, 0.07787512672551622, 0.08860212355579078, 0.07463514221925327, 0.06805312818616716, 0.09993165156194395, 0.12235276482385904, 0.12386278226166636, 0.12786337938114045, 0.11838199582982611, 0.11985874837805677, 0.1440335572861191, 0.12989329276783668, 0.12435456151979685, 0.14906808750472134, 0.24347301191843407, 0.25498278460414103, 0.2462304666212941, 0.25227787122361034, 0.212411524066216, 0.25815681055795814, 0.2534155065962761, 0.27284659826144864, 0.2520399766443191, 0.18350656416405808, 0.18441178396629854, 0.18352831809873205, 0.16636893734067748, 0.16024713126245516, 0.20680133888565766, 0.1965822552623735, 0.19413234701062743, 0.19912550456040456, 0.1884083506705878, 0.18133223044035862, 0.1952584658662736, 0.16815180030527677, 0.17806495700243363, 0.18238794633159505, 0.17101021299224795, 0.1810345959344033, 0.1777805519550718, 0.1664310363080651, 0.16575688251417486, 0.1918141642933343, 0.16934658549958292, 0.17878744693952198, 0.1813768667716762, 0.16492873772301642, 0.16808499398210264, 0.1704969080043256, 0.33446941566296307, 0.14449130628865892, 0.164698931732983, 0.26164933542603874, 0.21924312165110948, 0.15185952226121024, 0.15260373884681444, 0.17871945536984457, 0.16312920157933586, 0.21124848968283505, 0.1918389802239675, 0.21420117805933026, 0.17718304448085487, 0.15310313080202054, 0.3350591891558923, 0.4598325039386073, 0.14689803746679375, 0.1949651609774542, 0.2020616499307757, 0.18816762601300208, 0.1750731115854407, 0.16350216219935587, 0.18479416010583583, 0.17903416086527923, 0.1891014937779223, 0.16788155369690172, 0.17843647933770335, 0.07036831753474748, 0.08111482347875076, 0.06523052295029697, 0.06919643030754574, 0.0659186351692912, 0.06354322122477063, 0.07125910372235611, 0.08002206104883802, 0.07251192963900044]}, "mutation_prompt": null}
{"id": "315f871b-6897-45f2-bd9c-88f23b528954", "solution": "import numpy as np\n\nclass StochasticGuidedSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def adaptive_mutation_factor(self):\n        return 0.4 + 0.4 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.arange(self.population_size)\n                np.random.shuffle(idxs)\n                a, b, c = self.population[idxs[:3]]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.06\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "StochasticGuidedSearch", "description": "Stochastic Guided Search (SGS) combines adaptive differential evolution with stochastic hill climbing to efficiently explore and exploit the search space.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62ce67b2-3e09-4f1b-9ae0-3271af13122c", "metadata": {"aucs": [0.5486880367522122, 0.5500874671324321, 0.5258758164174591, 0.5466638316292052, 0.5575718555164759, 0.5640315420720936, 0.5688718630786345, 0.5542727090247135, 0.5390807052254325, 0.28230191992314135, 0.28310713879549854, 0.2500450896508679, 0.26451598511325813, 0.2776934440825418, 0.24337251727874332, 0.2538104234066072, 0.2587606867078357, 0.27670814324205495, 0.08715657164213719, 0.09440843990388625, 0.08899841348171267, 0.08264883418863433, 0.09181561448832543, 0.11069741574654413, 0.09686046841890661, 0.12103533080296269, 0.10827983993875656, 0.08315785579733437, 0.09106069863148714, 0.07825636137349234, 0.10207389092613917, 0.08945349129542368, 0.0758021743910654, 0.10452550223531543, 0.07658383242888778, 0.08479367467773957, 0.84633285516887, 0.82883064840599, 0.9207925539162084, 0.9040246640448505, 0.8906606787314318, 0.9032289342036164, 0.9106017142211739, 0.9309514832409931, 0.9093061920583232, 0.21224883170465758, 0.2311744837391081, 0.21829608725873018, 0.20990853310472202, 0.21421315594630985, 0.2225405654041499, 0.2118746090271847, 0.22902993983972797, 0.23172870401205425, 0.3215844354968964, 0.3117773812944974, 0.2635833569316084, 0.4238108718274912, 0.35808950103531256, 0.4665809989635278, 0.4015775061516115, 0.2892141486771359, 0.3378625219380761, 0.15462520160470672, 0.14426763482255023, 0.16365362675044892, 0.13618852714962648, 0.14788776852042151, 0.11869173672033173, 0.142075144702016, 0.13178313757878346, 0.16021267645023507, 0.10611912234724608, 0.09458514967411502, 0.13445548737646207, 0.14503049965490156, 0.16505949256011898, 0.13373439440154067, 0.13623513272302012, 0.16339572996082752, 0.12258428538685329, 0.061118036889054705, 0.06968345807907173, 0.04757914707511268, 0.035679431645807225, 0.04493084552462456, 0.06964422195919073, 0.08135464303902806, 0.04293448919402143, 0.06982055799455245, 0.18425361252613215, 0.18807632675119812, 0.1643904318243975, 0.14580586478211877, 0.15742845216129442, 0.1789458164450336, 0.18707969455638662, 0.23005691224259694, 0.17363048856788443, 0.0005841794031750114, 0.0009994169244664786, 0.013582581471, 0.004554991959976329, 0.011775631271805476, 0.011661888115389596, 0.03003919001861599, 0.025316723051763246, 0.016716735240677738, 0.10864044644186688, 0.10717539517326113, 0.10721621154978289, 0.10952494699690796, 0.13059314000079014, 0.10817435000075726, 0.11302849087249522, 0.12816461528150924, 0.10986090920628344, 0.43373066825874795, 0.38927915127224577, 0.42780987743761456, 0.4396377476601586, 0.44199430976512455, 0.4016254939637748, 0.4056011855848437, 0.4157072325367628, 0.42498168813293546, 0.08265473390130906, 0.07728426740094707, 0.09552985577281159, 0.08506328111096029, 0.07670528091378215, 0.08995061489826217, 0.08160091867004249, 0.08279366854284709, 0.07308471724260113, 0.13442372403394443, 0.1482638127198994, 0.1439667886969932, 0.12807475917247135, 0.14366530971009217, 0.14845294271125675, 0.1679682172203515, 0.1333097762946176, 0.13061649220933236, 0.2613124078101725, 0.2505705192340727, 0.2765966934693379, 0.2357264106934298, 0.2554457376337582, 0.2512547464610807, 0.2725481342411442, 0.2925122323631867, 0.29337775614563466, 0.19817186873554582, 0.19243254294408774, 0.18052046660977228, 0.18685086002293894, 0.18354245867008412, 0.18246832367715948, 0.19853268103229604, 0.20637211825760005, 0.20028577099947753, 0.1692305220471746, 0.17912528777930914, 0.17809245333007007, 0.1895750548669597, 0.16453600930241796, 0.20389315687514975, 0.16699327186861668, 0.1753888410961465, 0.1793590823490233, 0.16547831731453166, 0.1759152164565021, 0.17197789825363996, 0.17654473328560671, 0.16355746753131783, 0.17776661025641383, 0.17891109182241471, 0.17655802517944263, 0.17186699360235158, 0.17407373781983548, 0.16737325887829668, 0.1574839933984853, 0.25813516159502037, 0.18070973272168123, 0.43165823897263667, 0.15673795418577952, 0.1791837344658237, 0.1573311283659441, 0.40410743738116384, 0.18870467542083713, 0.24495915359540577, 0.19558416047316873, 0.168914301352053, 0.1581047608817513, 0.18936842661157294, 0.1948901837200545, 0.14471062710967542, 0.19224160476174068, 0.1760632799585412, 0.1694766154937386, 0.1752120332534619, 0.17598759832622324, 0.20709000206901107, 0.19205973326623293, 0.19686083381476616, 0.1871390802817089, 0.06109117642920969, 0.06920483427694635, 0.06607480422126977, 0.0625741432520599, 0.06898764973038396, 0.06597791234425898, 0.07384238490457062, 0.06882427305504313, 0.08022679912144015]}, "mutation_prompt": null}
{"id": "4d941f0e-ada0-4d48-a5e1-99366b1f7fa7", "solution": "import numpy as np\n\nclass AdaptiveMultiPhaseOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n        self.step_size_decay = 0.99\n\n    def adaptive_mutation_factor(self):\n        return 0.5 + 0.3 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.arange(self.population_size)\n                np.random.shuffle(idxs)\n                a, b, c = self.population[idxs[:3]]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def adaptive_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n                step_size *= self.step_size_decay\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.adaptive_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultiPhaseOptimization", "description": "Adaptive Multi-Phase Optimization (AMPO) integrates differential evolution with adaptive hill climbing and a dynamic mutation strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.21326194119300734, "feedback": "The algorithm AdaptiveMultiPhaseOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "62ce67b2-3e09-4f1b-9ae0-3271af13122c", "metadata": {"aucs": [0.4808389158981786, 0.5237519406048073, 0.5180138180137851, 0.4867120964469125, 0.49762611835550696, 0.5281021372127017, 0.5061840737043, 0.5010454561348907, 0.4861341552605859, 0.20673095711528333, 0.25088526624989393, 0.24163782674914114, 0.19008825955780972, 0.22909588126179192, 0.2537824923823696, 0.21114975276069692, 0.2316124753181552, 0.23157073642502468, 0.08638941133762779, 0.08891808202644769, 0.08671708220949237, 0.09736348882055756, 0.08418693376995157, 0.09310077667460426, 0.08368856469084207, 0.08415798612550973, 0.08541950776512708, 0.08231260873193202, 0.08538481548773957, 0.07689119224397167, 0.06760806689335763, 0.0739428910123594, 0.09236003592334097, 0.07186481186606741, 0.0693483842535948, 0.07520617877896218, 0.8750349230336262, 0.9468988209740513, 0.831949286418363, 0.7079727930262523, 0.8271695742669308, 0.9200717074678405, 0.9193220708485398, 0.9522389810249918, 0.9522105106544672, 0.22810778419843136, 0.21249518981826954, 0.19187913856823247, 0.21686593227737627, 0.19837777178227778, 0.22210343310429637, 0.2119074205339383, 0.23988769655827202, 0.21991457065554854, 0.45084278020378465, 0.35831531514319226, 0.3370442068085766, 0.5123733626829335, 0.46944875732080416, 0.4151844496703938, 0.3919224432937779, 0.4326178770825243, 0.25602607990711534, 0.12254681499270714, 0.15035147337210342, 0.1205366717134273, 0.1252038900077449, 0.13325139506260053, 0.1375179067099398, 0.1343759272288837, 0.1099139787813943, 0.14332534613974823, 0.09695262161567475, 0.09336680148751308, 0.1263284309991055, 0.12965160922919805, 0.1348774644422629, 0.13085624300271537, 0.1426434590591139, 0.10540706566922586, 0.12145651601574081, 0.0691709284167702, 0.08284443459363733, 0.07021792695638274, 0.07845636328130057, 0.08672693422780775, 0.06058542430857583, 0.05723618492338989, 0.05395818264365859, 0.06318985184813342, 0.16300214567295457, 0.2024581378397199, 0.18211073224063634, 0.15156991700013533, 0.17446006325137808, 0.16857980742351752, 0.18736996098048198, 0.15597065935388288, 0.2116668088301955, 0.0035306569023807466, 0.001234635995551403, 0.0069649485818976675, 0.0066040275405430116, 0.002401042032213585, 0.0247918329625314, 0.029494715991812748, 0.021979156340535377, 0.02286302847008792, 0.09767999872815525, 0.10838517668210879, 0.10576483303205897, 0.11032356917335895, 0.12089418157974796, 0.10666269028050623, 0.13505373304167256, 0.11693174457894984, 0.10957913937160557, 0.4131681716957444, 0.40438349244840144, 0.4203651849730903, 0.4214082195387314, 0.42261738471073085, 0.4299264146076789, 0.4322527353734351, 0.40371747840826133, 0.42095148819263184, 0.0943069659704121, 0.07781925420163172, 0.08553967830720743, 0.07867059049086289, 0.07787512672551622, 0.08860212355579078, 0.07463514221925327, 0.06805312818616716, 0.09993165156194395, 0.12235276482385904, 0.12386278226166636, 0.12786337938114045, 0.11838199582982611, 0.11985874837805677, 0.1440335572861191, 0.12989329276783668, 0.12435456151979685, 0.14906808750472134, 0.24347301191843407, 0.25498278460414103, 0.2462304666212941, 0.25227787122361034, 0.212411524066216, 0.25815681055795814, 0.2534155065962761, 0.27284659826144864, 0.2520399766443191, 0.18350656416405808, 0.18441178396629854, 0.18352831809873205, 0.16636893734067748, 0.16024713126245516, 0.20680133888565766, 0.1965822552623735, 0.19413234701062743, 0.19912550456040456, 0.1884083506705878, 0.18133223044035862, 0.1952584658662736, 0.16815180030527677, 0.17806495700243363, 0.18238794633159505, 0.17101021299224795, 0.1810345959344033, 0.1777805519550718, 0.1664310363080651, 0.16575688251417486, 0.1918141642933343, 0.16934658549958292, 0.17878744693952198, 0.1813768667716762, 0.16492873772301642, 0.16808499398210264, 0.1704969080043256, 0.33446941566296307, 0.14449130628865892, 0.164698931732983, 0.26164933542603874, 0.21924312165110948, 0.15185952226121024, 0.15260373884681444, 0.17871945536984457, 0.16312920157933586, 0.21124848968283505, 0.1918389802239675, 0.21420117805933026, 0.17718304448085487, 0.15310313080202054, 0.3350591891558923, 0.4598325039386073, 0.14689803746679375, 0.1949651609774542, 0.2020616499307757, 0.18816762601300208, 0.1750731115854407, 0.16350216219935587, 0.18479416010583583, 0.17903416086527923, 0.1891014937779223, 0.16788155369690172, 0.17843647933770335, 0.07036831753474748, 0.08111482347875076, 0.06523052295029697, 0.06919643030754574, 0.0659186351692912, 0.06354322122477063, 0.07125910372235611, 0.08002206104883802, 0.07251192963900044]}, "mutation_prompt": null}
{"id": "21cbf33b-b53d-453e-ba95-6876d7ed9751", "solution": "import numpy as np\n\nclass StochasticGuidedSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def adaptive_mutation_factor(self):\n        return 0.4 + 0.4 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // self.population_size):\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.arange(self.population_size)\n                np.random.shuffle(idxs)\n                a, b, c = self.population[idxs[:3]]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.06\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "StochasticGuidedSearch", "description": "Stochastic Guided Search (SGS) combines adaptive differential evolution with stochastic hill climbing to efficiently explore and exploit the search space.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "62ce67b2-3e09-4f1b-9ae0-3271af13122c", "metadata": {"aucs": [0.5486880367522122, 0.5500874671324321, 0.5258758164174591, 0.5466638316292052, 0.5575718555164759, 0.5640315420720936, 0.5688718630786345, 0.5542727090247135, 0.5390807052254325, 0.28230191992314135, 0.28310713879549854, 0.2500450896508679, 0.26451598511325813, 0.2776934440825418, 0.24337251727874332, 0.2538104234066072, 0.2587606867078357, 0.27670814324205495, 0.08715657164213719, 0.09440843990388625, 0.08899841348171267, 0.08264883418863433, 0.09181561448832543, 0.11069741574654413, 0.09686046841890661, 0.12103533080296269, 0.10827983993875656, 0.08315785579733437, 0.09106069863148714, 0.07825636137349234, 0.10207389092613917, 0.08945349129542368, 0.0758021743910654, 0.10452550223531543, 0.07658383242888778, 0.08479367467773957, 0.84633285516887, 0.82883064840599, 0.9207925539162084, 0.9040246640448505, 0.8906606787314318, 0.9032289342036164, 0.9106017142211739, 0.9309514832409931, 0.9093061920583232, 0.21224883170465758, 0.2311744837391081, 0.21829608725873018, 0.20990853310472202, 0.21421315594630985, 0.2225405654041499, 0.2118746090271847, 0.22902993983972797, 0.23172870401205425, 0.3215844354968964, 0.3117773812944974, 0.2635833569316084, 0.4238108718274912, 0.35808950103531256, 0.4665809989635278, 0.4015775061516115, 0.2892141486771359, 0.3378625219380761, 0.15462520160470672, 0.14426763482255023, 0.16365362675044892, 0.13618852714962648, 0.14788776852042151, 0.11869173672033173, 0.142075144702016, 0.13178313757878346, 0.16021267645023507, 0.10611912234724608, 0.09458514967411502, 0.13445548737646207, 0.14503049965490156, 0.16505949256011898, 0.13373439440154067, 0.13623513272302012, 0.16339572996082752, 0.12258428538685329, 0.061118036889054705, 0.06968345807907173, 0.04757914707511268, 0.035679431645807225, 0.04493084552462456, 0.06964422195919073, 0.08135464303902806, 0.04293448919402143, 0.06982055799455245, 0.18425361252613215, 0.18807632675119812, 0.1643904318243975, 0.14580586478211877, 0.15742845216129442, 0.1789458164450336, 0.18707969455638662, 0.23005691224259694, 0.17363048856788443, 0.0005841794031750114, 0.0009994169244664786, 0.013582581471, 0.004554991959976329, 0.011775631271805476, 0.011661888115389596, 0.03003919001861599, 0.025316723051763246, 0.016716735240677738, 0.10864044644186688, 0.10717539517326113, 0.10721621154978289, 0.10952494699690796, 0.13059314000079014, 0.10817435000075726, 0.11302849087249522, 0.12816461528150924, 0.10986090920628344, 0.43373066825874795, 0.38927915127224577, 0.42780987743761456, 0.4396377476601586, 0.44199430976512455, 0.4016254939637748, 0.4056011855848437, 0.4157072325367628, 0.42498168813293546, 0.08265473390130906, 0.07728426740094707, 0.09552985577281159, 0.08506328111096029, 0.07670528091378215, 0.08995061489826217, 0.08160091867004249, 0.08279366854284709, 0.07308471724260113, 0.13442372403394443, 0.1482638127198994, 0.1439667886969932, 0.12807475917247135, 0.14366530971009217, 0.14845294271125675, 0.1679682172203515, 0.1333097762946176, 0.13061649220933236, 0.2613124078101725, 0.2505705192340727, 0.2765966934693379, 0.2357264106934298, 0.2554457376337582, 0.2512547464610807, 0.2725481342411442, 0.2925122323631867, 0.29337775614563466, 0.19817186873554582, 0.19243254294408774, 0.18052046660977228, 0.18685086002293894, 0.18354245867008412, 0.18246832367715948, 0.19853268103229604, 0.20637211825760005, 0.20028577099947753, 0.1692305220471746, 0.17912528777930914, 0.17809245333007007, 0.1895750548669597, 0.16453600930241796, 0.20389315687514975, 0.16699327186861668, 0.1753888410961465, 0.1793590823490233, 0.16547831731453166, 0.1759152164565021, 0.17197789825363996, 0.17654473328560671, 0.16355746753131783, 0.17776661025641383, 0.17891109182241471, 0.17655802517944263, 0.17186699360235158, 0.17407373781983548, 0.16737325887829668, 0.1574839933984853, 0.25813516159502037, 0.18070973272168123, 0.43165823897263667, 0.15673795418577952, 0.1791837344658237, 0.1573311283659441, 0.40410743738116384, 0.18870467542083713, 0.24495915359540577, 0.19558416047316873, 0.168914301352053, 0.1581047608817513, 0.18936842661157294, 0.1948901837200545, 0.14471062710967542, 0.19224160476174068, 0.1760632799585412, 0.1694766154937386, 0.1752120332534619, 0.17598759832622324, 0.20709000206901107, 0.19205973326623293, 0.19686083381476616, 0.1871390802817089, 0.06109117642920969, 0.06920483427694635, 0.06607480422126977, 0.0625741432520599, 0.06898764973038396, 0.06597791234425898, 0.07384238490457062, 0.06882427305504313, 0.08022679912144015]}, "mutation_prompt": null}
{"id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 7, "fitness": 0.24841241588269725, "feedback": "The algorithm AdaptiveMultistageOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "62ce67b2-3e09-4f1b-9ae0-3271af13122c", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "031d876b-bc9b-4a70-b9ac-7ce17b9d249f", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (2 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_parameter(self):\n        return 0.4 + 0.4 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_parameter()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def adaptive_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.adaptive_hill_climbing(func)\n        return self.best_solution", "name": "EnhancedDynamicAdaptiveOptimizer", "description": "Enhanced Dynamic Adaptive Optimizer (EDAO) refines exploration-exploitation balance using dynamic parameter tuning and adaptive hill climbing for improved performance.", "configspace": "", "generation": 8, "fitness": 0.19953983207445786, "feedback": "The algorithm EnhancedDynamicAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.47892611195441015, 0.4367395775612537, 0.47834569374529834, 0.4809755589607123, 0.4723549681517285, 0.5230796480665285, 0.5004431305063377, 0.5317120929628771, 0.5010236921670265, 0.17482657435712812, 0.1859712675160965, 0.17520564897027813, 0.19213372439164922, 0.19867558934458573, 0.19850329785947307, 0.1899741268450179, 0.1865544433820221, 0.22809597061652065, 0.09263326982538933, 0.0844392923634466, 0.10534870344702518, 0.08570690457547903, 0.10056088677454755, 0.07436711241420513, 0.08457925325809335, 0.09424110390682239, 0.09679738150428185, 0.0831285250131445, 0.09076908258492589, 0.07553671406623308, 0.08436512152256548, 0.07005780052412325, 0.06933497527794841, 0.07705480421243704, 0.08303356079565549, 0.08253839341627123, 0.8655996315862209, 0.8210476472992069, 0.8132136699465922, 0.9119491960819561, 0.9366915499950093, 0.9189406119699142, 0.8490867173908714, 0.8279862136698128, 0.8654090601574883, 0.17398940111826866, 0.1948025024102057, 0.16318792120994496, 0.17482820832109724, 0.17392642725582297, 0.21623843625293615, 0.20921286390296123, 0.20068706927988722, 0.18832427856852973, 0.27099270973816925, 0.2858600140431352, 0.2803529780412476, 0.26103733575435084, 0.38646492784460795, 0.2849362060084606, 0.3126604824592073, 0.28026457784246916, 0.24686742589578847, 0.12074308128535394, 0.10738880388940253, 0.13696525828373507, 0.1230921057762665, 0.11736334563841178, 0.10953879153398671, 0.1389897719457145, 0.11628968242144633, 0.12806970278588647, 0.13523422404048446, 0.10367902870706291, 0.1283471055872042, 0.11125195243356378, 0.12780750936391727, 0.11878190146793399, 0.12061314697090197, 0.13507512911945918, 0.12077360067096543, 0.0366478819869539, 0.050513385451461, 0.037543454719371594, 0.019778191515885557, 0.01980527758265105, 0.0444603856655964, 0.0381374616970912, 0.029580200046119387, 0.04161902036793308, 0.11074239474175551, 0.14383107760292047, 0.12684225541676608, 0.14015248338518993, 0.15627931301375175, 0.14691880374812571, 0.1831518849738062, 0.1638957461319045, 0.19826526366119357, 9.999999999998899e-05, 0.0012584151002962285, 0.008928702574069192, 0.0024904189162707757, 0.00027425091864019535, 0.0010222806643787052, 0.00021395981256477903, 0.0007577457002923005, 0.004687261103590523, 0.09311959510836709, 0.09259865644133736, 0.09233369555598658, 0.08310936269981517, 0.10077002748399666, 0.11154353099865455, 0.08808947315267213, 0.09599183129623812, 0.09512962503385425, 0.37955060289667686, 0.3831495093056603, 0.4064923404726506, 0.3900066222583346, 0.3779174482000831, 0.3894457910860111, 0.39442232410729305, 0.3959410111728262, 0.43475624215318387, 0.0858171108814264, 0.08629751797264984, 0.0853808874957771, 0.07945110035439562, 0.0831965169890505, 0.07366727213970536, 0.0839651445195786, 0.09772307738980457, 0.08043813818341405, 0.15125570920553033, 0.1445407699920621, 0.14791646807956405, 0.13744130625332507, 0.12504933977345645, 0.1608176307409538, 0.1436368620914691, 0.12657316727297874, 0.10947326366520616, 0.2314897625675767, 0.23688762231313, 0.23191540709955283, 0.24582666272437514, 0.25118217017815836, 0.23042599257023544, 0.24966155492113917, 0.25409045870708313, 0.27036745644176885, 0.16983415684648173, 0.17085919395581017, 0.17256648242498873, 0.16924261139768748, 0.1603003709345323, 0.1607218047636053, 0.17911187570743858, 0.1849965915176649, 0.2013129870573772, 0.20070159489655837, 0.1834294851028958, 0.17582342595940625, 0.16878233468604464, 0.18354403204719238, 0.1798664682645138, 0.1764013996267142, 0.1663491743501767, 0.17243036954240398, 0.1685408546387207, 0.167583067292168, 0.16511697844429052, 0.16334436509932204, 0.170736058694548, 0.15806074446667717, 0.16673872880627405, 0.16715536090134742, 0.17356448933010493, 0.20198939857636233, 0.35054452667262226, 0.3162908056718944, 0.151780693068996, 0.16229310713820833, 0.13938316943995255, 0.1494745093369032, 0.1668178576924937, 0.14566690791489678, 0.2923251755701586, 0.18503319787438754, 0.32975336786160436, 0.2615451485316085, 0.2113470820823775, 0.14327178755441816, 0.19630575832457375, 0.19612059541499682, 0.25776460848718075, 0.20816323757770183, 0.17453752691498758, 0.17920761402275853, 0.18206783046751518, 0.19122575948363096, 0.17831379510739354, 0.17799043694960492, 0.16874004886379534, 0.17621264879235898, 0.0710320419900663, 0.06833037924093621, 0.06965904345201057, 0.06603115412487481, 0.07485344174225739, 0.06006757626628623, 0.07534318544632757, 0.08231393953122879, 0.06234157888759562]}, "mutation_prompt": null}
{"id": "b202f0ba-4e02-4dee-a3a6-f65a9bb3a800", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "78285ddc-325f-4116-bcbc-b18012f28ddf", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "42871917-768e-4abb-8b15-e45636858c2c", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "a4825295-46e1-4faa-8426-3623b8cfd315", "solution": "import numpy as np\n\nclass QuantumInspiredMultilevelOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def quantum_mutation_factor(self):\n        return 0.4 + 0.45 * np.sin(np.pi * np.random.rand())\n\n    def quantum_differential_evolution(self, func):\n        potential_field = np.zeros((self.population_size, self.dim))\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.quantum_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c) + np.random.randn(self.dim) * potential_field[i], self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                    potential_field[i] = np.exp(-trial_fitness)\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def quantum_stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.quantum_differential_evolution(func)\n        self.quantum_stochastic_hill_climbing(func)\n        return self.best_solution", "name": "QuantumInspiredMultilevelOptimizer", "description": "The Quantum-Inspired Multilevel Optimizer (QIMO) leverages quantum superposition principles to enhance exploration-exploitation balance through quantum potential fields and adaptive evolution strategies.", "configspace": "", "generation": 12, "fitness": 0.1912869540764481, "feedback": "The algorithm QuantumInspiredMultilevelOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.4656345615796583, 0.47850497545010184, 0.5078432090809297, 0.47023547084548367, 0.508135122195075, 0.5269476401772859, 0.2871238172885566, 0.31406667478892036, 0.3190387268297442, 0.18815306219601002, 0.18399584912229983, 0.14593035662541243, 0.1569701830356549, 0.15648105115709876, 0.1923725634909682, 0.17555503145707785, 0.14007414258313822, 0.17509849069456507, 0.07279177621495747, 0.07397228186293581, 0.08147744018836678, 0.08869003284212684, 0.07952984040284716, 0.0802116807814729, 0.10658992339614126, 0.087638513107266, 0.08694895856996121, 0.07320731238915901, 0.07993497861706023, 0.0638037462075084, 0.07811639553849148, 0.0925433187451854, 0.08240866726964557, 0.07437166823499441, 0.07361991330641104, 0.07235651546598454, 0.9355289518565649, 0.9414104039983153, 0.8893464790418236, 0.9223485192834475, 0.9060303832309042, 0.9652341226896614, 0.95949828395445, 0.9056971449196265, 0.8884768996572163, 0.19748451373604337, 0.18819112769775836, 0.19747556622751394, 0.20961556362618772, 0.1821604614502722, 0.18904579428700086, 0.16410281311334873, 0.1461466161382603, 0.17407439875056607, 0.23285618573988676, 0.2589530415279516, 0.3527734908867909, 0.26975208593235667, 0.2528323560331681, 0.2805617427375171, 0.282802593380135, 0.24781404131925633, 0.3112667183337159, 0.1452612384308768, 0.13982137639900216, 0.15145293801441762, 0.08411847922171833, 0.12274675474161467, 0.11325847012860091, 0.13317300329498416, 0.1218101732597705, 0.09873409253360155, 0.08436504124287802, 0.0624796538346134, 0.1461769323817882, 0.09912038675677981, 0.1323700798002927, 0.12736923623856744, 0.10986147513084821, 0.09754030308063988, 0.1400008117547732, 0.024190178587853772, 0.02055786113098379, 0.03776086876238738, 0.044887714589057714, 0.024136681075273003, 0.033015211195089766, 0.030289046073040615, 0.0133639047390669, 0.023169049311639545, 0.14515985961760092, 0.1441843419165152, 0.142192449305364, 0.09353990136014634, 0.12933839771887012, 0.1367305185720905, 0.12520357458442344, 0.12974781999561824, 0.15826558845136374, 0.016385151609281112, 0.0005747972836048776, 9.999999999998899e-05, 9.999999999998899e-05, 0.003749882381119618, 9.999999999998899e-05, 0.012722794691615524, 0.004174857770746665, 0.004876683803244464, 0.09080971931209003, 0.09037632877774138, 0.09090395712728916, 0.08638293112311801, 0.0966532139219205, 0.07804596025975752, 0.08321749761810493, 0.07382633929631066, 0.07397522502171217, 0.31174761631993053, 0.3037526161385309, 0.32145402594137407, 0.3161849100307793, 0.32700695267923885, 0.30662781994176824, 0.40727177776889023, 0.3922056751132741, 0.405009137783926, 0.08757754091556358, 0.07695616286843465, 0.0803905923083923, 0.08520513824236331, 0.08589655104563321, 0.07756472252052304, 0.06950365065542097, 0.08459571360379103, 0.07102496975227512, 0.10995436345073684, 0.14031868592710672, 0.15055818539649535, 0.13390822873358377, 0.13626070518358024, 0.12673585348421967, 0.12598354551768098, 0.12859856859067864, 0.1174687608370335, 0.19403034572921474, 0.20326920281476968, 0.21299696746480412, 0.22915810820681048, 0.23219913033611517, 0.21287225549887911, 0.24941877607836827, 0.24647262979978135, 0.2558884460185683, 0.16711646536002078, 0.1518179416984975, 0.189642363923905, 0.15759700488881645, 0.18143530430234023, 0.18048728338711384, 0.1743955662509592, 0.17775375642468227, 0.18816582381342462, 0.1551605883109063, 0.16576810911986217, 0.1722682183496509, 0.18857296334215412, 0.1752485209939254, 0.1736280284115328, 0.1968703110495008, 0.18059963963994374, 0.16238219135685594, 0.17460354370432374, 0.1590899515321269, 0.16813576899996918, 0.17908791154891646, 0.16744791492130262, 0.1703928689979648, 0.16211860500891395, 0.16579999349697683, 0.1720348050335988, 0.2901430190136983, 0.4466142158197869, 0.1435029590121072, 0.1744662970318872, 0.16073067989930712, 0.18841280693646367, 0.16062292083322938, 0.14735666848060902, 0.1610480590147756, 0.22098900522291864, 0.17768924248589102, 0.3296224395593307, 0.17659624263515272, 0.15907318682868987, 0.2821586431734575, 0.1790607058220367, 0.1972286764265505, 0.18603038423929308, 0.17636758851421164, 0.17479049739379682, 0.17816869087920828, 0.1633338640301587, 0.18682910318303525, 0.17560167107718094, 0.17017963883223386, 0.1968604280449695, 0.18587710438683136, 0.06609817084094649, 0.06447693405454047, 0.066250097607647, 0.0761868377191941, 0.06352151552946217, 0.06692950925254226, 0.062257699915853615, 0.06606235156916918, 0.058931504161862214]}, "mutation_prompt": null}
{"id": "cbc2c74d-59b6-4852-8a3d-c36a9ad7ab04", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "f182fa91-d9fc-4008-9cfa-17902e10ab5f", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "21907b72-bbfa-44f2-a3c8-dcf96c0f3ea6", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "441d514b-bd50-4a00-a4eb-fc8da7efa38a", "solution": "import numpy as np\n\nclass DynamicHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (3 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.4 + 0.6 * np.random.rand()\n\n    def enhanced_differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def adaptive_local_search(self, func):\n        step_size = 0.1\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.enhanced_differential_evolution(func)\n        self.adaptive_local_search(func)\n        return self.best_solution", "name": "DynamicHybridOptimizer", "description": "Dynamic Hybrid Optimization Algorithm (DHOA) refines adaptive search strategies by integrating dynamic local search and improved exploration techniques to balance exploitation and exploration effectively.", "configspace": "", "generation": 16, "fitness": 0.17760428191749636, "feedback": "The algorithm DynamicHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.41380035807013693, 0.3660832088891711, 0.41100248430332775, 0.45048631144023144, 0.43841178638944167, 0.45512858142413914, 0.4289264536299703, 0.419335841303788, 0.43341895300801425, 0.1478213281074655, 0.15380776904018745, 0.1564634384683563, 0.1528481450390634, 0.1513552179006148, 0.13806784850094422, 0.16167197718219728, 0.18347616150519097, 0.1571137506893896, 0.09035797458560413, 0.09112611719128383, 0.08575767513053068, 0.08760016138867155, 0.09124241184209692, 0.08966803038629334, 0.09217043727077567, 0.0895096158984201, 0.08864412317351578, 0.07425755519077071, 0.08075974054764679, 0.07098828205158791, 0.08005497465975242, 0.07200662176362749, 0.07810664888599472, 0.07849034950136324, 0.07310905729736927, 0.08420320432592432, 0.7906252498450979, 0.8765218691519258, 0.8996840515534797, 0.9663877229609554, 0.8965641001245975, 0.8745913496416152, 0.9043386513403562, 0.8706647372510637, 0.940405761605647, 0.15982444289140785, 0.17857142146280836, 0.15552643073155303, 0.16642236856263848, 0.14174132792578187, 0.17120557099054035, 0.1632426155254969, 0.19866109823021494, 0.16856603305242368, 0.2042461872714313, 0.22525263628899506, 0.18702463570696648, 0.24089784652814328, 0.24443939474238185, 0.23261714111070897, 0.21552719381710117, 0.2344438355966023, 0.20403455130779757, 0.08427347583288414, 0.09657754988710565, 0.09614037488736216, 0.10236097853342707, 0.1035766218067522, 0.11158478679586514, 0.11243966133389549, 0.12425018613169336, 0.11158927119396234, 0.08792697672938543, 0.08525030416038659, 0.06213190609939678, 0.10298872717710217, 0.10918107262404797, 0.10256353165643506, 0.09977236602356065, 0.0722858038096037, 0.09708031182277643, 0.0035855516726728265, 0.0070108462819532535, 0.00081328377046197, 0.0009501686075477078, 0.006845713556803301, 0.0008059810739480255, 0.0003728066081930548, 0.009475461780579453, 0.0006356862907627159, 0.09382649986024005, 0.08794053925074607, 0.08143569559487551, 0.14858944933937368, 0.11315108931219997, 0.09024076003155168, 0.12844018787557854, 0.09833565067926886, 0.09795281894742858, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06175867550389558, 0.0729510763405058, 0.06763345118511566, 0.06273141877623223, 0.06880397190854015, 0.07544467584744052, 0.054072076357671195, 0.0796142414020411, 0.08158315840693264, 0.3444951239346872, 0.3513984275928911, 0.3563129237100753, 0.3729669603191401, 0.3561926527434256, 0.3458663869885008, 0.3782208810118184, 0.34429261214587514, 0.36012147703257247, 0.06532701758421156, 0.07920090822558046, 0.06951218716222318, 0.08177105427774656, 0.07805898499274844, 0.07107256673334561, 0.07426487593489439, 0.06939065212030215, 0.07672031810682534, 0.13268951372406024, 0.1298367371061222, 0.1271106193371967, 0.1483534681064308, 0.13262157721065648, 0.14166502394968317, 0.12437935973998515, 0.13753889608889636, 0.11426293753589722, 0.22343836246864446, 0.2204021552785843, 0.21441608477568597, 0.1833083031045003, 0.21289951554370434, 0.19824408959942053, 0.24509461863816562, 0.24335505879540908, 0.23484959140100814, 0.17130483667361618, 0.15270288433720147, 0.14583814246984528, 0.17972611413481754, 0.1436091726991533, 0.14547198259842375, 0.1717177393240762, 0.1609306852065827, 0.17277594180981537, 0.17234573248852336, 0.17406604001780202, 0.18384654860367977, 0.1699775827937583, 0.16296313825822595, 0.15961687886014297, 0.16613360928403142, 0.1578158447806043, 0.17063754794978014, 0.1849184451800593, 0.16617072593943882, 0.16949609556156942, 0.19502023801092805, 0.18202783397264743, 0.16848924571910662, 0.17092029033884226, 0.16955785443903226, 0.1670634888629695, 0.14035510857294176, 0.18305025764971983, 0.2432301222425587, 0.15664970184122595, 0.16127132972193636, 0.15639773042742944, 0.13622723124217395, 0.1557366376200986, 0.13962536001280113, 0.16496444261904764, 0.17780806302904018, 0.173713812484106, 0.16746511882193915, 0.13734939322794493, 0.1611707448930314, 0.19570310547280156, 0.17462746713546917, 0.19562782565242653, 0.17175744788420033, 0.19108314812157168, 0.16755239196560667, 0.16680837581524754, 0.18773506039184895, 0.18196320503051733, 0.1706094407879476, 0.18445033671442468, 0.16984929634822532, 0.055380671379471225, 0.07560703283214776, 0.06982828347818582, 0.05723102584420536, 0.06335636577510873, 0.06188310121310947, 0.0679182921251128, 0.07323380954122971, 0.0633319289599884]}, "mutation_prompt": null}
{"id": "0162f5a6-18ff-4366-8e6a-3981ec6f1b6b", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "92d4ecc3-2ecc-432c-bfbe-8e62ec3c749b", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "7509f5f8-bfd5-471e-a48f-53875c494b24", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "48d287c2-0e6a-4cfc-b42b-a062beaa4eae", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "9eedbeba-275f-47e5-b58c-2d21c44bfdf1", "solution": "import numpy as np\n\nclass DynamicEnsembleOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (3 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n        self.step_size = 0.1\n\n    def adaptive_mutation_factor(self):\n        diversity = np.std(self.population, axis=0).mean()\n        return 0.4 + 0.3 * np.tanh(diversity)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + self.step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicEnsembleOptimizer", "description": "Dynamic Ensemble Optimizer (DEO) enhances search efficiency by adaptively combining differential evolution and stochastic hill climbing with fitness-aware parameter tuning.", "configspace": "", "generation": 21, "fitness": 0.2107426702150009, "feedback": "The algorithm DynamicEnsembleOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5475458024276756, 0.5704061743931819, 0.5763822649695036, 0.6246261127418482, 0.5888702765894932, 0.6479582405321092, 0.5636164735175282, 0.6084396749631293, 0.6510135340247389, 0.2555795699434865, 0.19727120392689468, 0.2918620919723407, 0.2220139327746542, 0.25051566612214116, 0.2527017842710404, 0.25130216906825664, 0.22988653939929826, 0.26711217027224565, 0.10897898238630277, 0.08724853844621161, 0.09695862523253418, 0.09215046025263307, 0.103494848424032, 0.0974086087426751, 0.09942981202103618, 0.09622034408802649, 0.1044087703539035, 0.07513235294909448, 0.0818128762149799, 0.08527561918449211, 0.08778998532029836, 0.07609602077712752, 0.0741945500339336, 0.09007242604521637, 0.0739542641462394, 0.08235955518847826, 0.8956368732577003, 0.7920933516936681, 0.9410092689975784, 0.8693384078389601, 0.8965178465820625, 0.9117186834526696, 0.8218296432856056, 0.9780986607349967, 0.8862994489839541, 0.20336976955168617, 0.1912279054099556, 0.1759773142975255, 0.22310728277167857, 0.2127812177926427, 0.20168811293954214, 0.2062237228695526, 0.24066439654989413, 0.2554069486408638, 0.2620080382851404, 0.2842862237221283, 0.23083002172148903, 0.26887575146892706, 0.5259095540680887, 0.2703899243543666, 0.2684991766865019, 0.27456378383603086, 0.27999457056709054, 0.11528869511587636, 0.12112985447933422, 0.10809807407201699, 0.13441208048966402, 0.13791399934111137, 0.1266205621724914, 0.12690358615660757, 0.11901156444995908, 0.125506867037681, 0.04294236167815324, 0.1440854517891017, 0.16850227049113276, 0.13664714305533876, 0.10932035807520879, 0.14215348876959977, 0.13708186635231412, 0.128867284050445, 0.13687573251193386, 0.018546373001894656, 0.038713576994439114, 0.05814391644736139, 0.00038801654884557113, 0.021748912767385775, 0.016786491016238303, 0.018029778796739948, 0.005096285292471858, 0.002264530782186247, 0.1486161907990634, 0.1270715185914325, 0.13054802189135095, 0.10102115760216634, 0.11995308120680781, 0.1317328918601708, 0.14418864137136167, 0.12906457895471335, 0.116860734747111, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029526697994126105, 0.03774708711319985, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004310185365652641, 0.10419151483542433, 0.08447319210376991, 0.0839006170768225, 0.10443137010557968, 0.09942182938150745, 0.10944854358198741, 0.0972461564758843, 0.11522527233298374, 0.11398030161058159, 0.4250833475864013, 0.4163511835751177, 0.4487532958034689, 0.45193977959548803, 0.4485316375214927, 0.4125661046251775, 0.4136013008253224, 0.44176021266090515, 0.42695758827333985, 0.09613631043207438, 0.11135821725323336, 0.09825773656722336, 0.0887253357886415, 0.07343939661400545, 0.09678344482232515, 0.09334311489994274, 0.08744893362218431, 0.09407433422367462, 0.15015878844730413, 0.20090218945912397, 0.16474822883552587, 0.1553309139005351, 0.143302982245342, 0.13717551630942293, 0.17291773711159275, 0.2137381198600905, 0.15626466070381628, 0.24196966419148047, 0.24636728175371647, 0.260073942924819, 0.23924776590285068, 0.233475595143393, 0.2317431623939622, 0.2663652778795572, 0.28041058584825607, 0.30949501955783654, 0.17134436665174635, 0.16896199381257904, 0.17825504455644148, 0.18101043209693812, 0.1682226452418446, 0.16701731114537977, 0.17239840348079682, 0.19409998413688923, 0.18110681113296112, 0.1863877782100758, 0.16900716889205236, 0.17185618453480966, 0.19459450885480423, 0.17489046015858567, 0.18331628985532022, 0.17372507306703866, 0.17915522928968075, 0.2004340260418498, 0.1892970655900592, 0.18212752442387659, 0.17620044141427338, 0.16311286600604413, 0.17251518673781574, 0.17083894509813746, 0.18141048507079982, 0.1755319373893568, 0.1771077409555113, 0.16547334221481236, 0.20139323633653772, 0.25339288960150974, 0.20959856074568906, 0.16815243886930997, 0.16952603511922903, 0.26115256042837887, 0.1896406005559852, 0.2676178669253608, 0.16830027907611222, 0.27609980869301953, 0.15753029605454472, 0.1727242344650023, 0.1392879373204532, 0.28506768942760086, 0.18982419150556185, 0.19894003710024033, 0.19797938755274636, 0.16536227394310954, 0.17320766003452204, 0.1855331399914255, 0.1908152801160773, 0.16852896985664556, 0.17628645423601175, 0.16238373427245767, 0.1764945024356228, 0.17998436917768412, 0.06333092746422897, 0.06666950858776599, 0.06455264712754583, 0.06738854407636807, 0.0642010324572615, 0.057530751378116474, 0.0710122578978506, 0.06509330337952723, 0.06454047819725162]}, "mutation_prompt": null}
{"id": "925f5b33-96c8-4739-ac21-4dec51487780", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "95c82f67-f4fe-4775-9efa-70868af46771", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "3f304cc1-1f92-434d-8ef4-ec0a0d6a924a", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "80738c96-1e52-454a-95e9-74e8769d39d2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_population()\n\n    def dynamic_population(self):\n        self.population_size = int(self.initial_population_size * (1 - self.evaluations / self.budget))\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def dynamic_mutation_factor(self):\n        return 0.4 + 0.4 * np.random.rand()\n\n    def differential_evolution(self, func):\n        while self.evaluations < self.budget and self.population_size > 0:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                new_population[i] = trial_vector if trial_fitness < func(self.population[i]) else self.population[i]\n            self.population = new_population\n            self.dynamic_population()\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        while self.evaluations < self.budget and self.population_size > 0:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n            step_size *= 0.95  # Reduce the step size adaptively\n            self.dynamic_population()\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "EnhancedAdaptiveMultistageOptimizer", "description": "Enhanced Adaptive Multistage Optimizer (EAMO) improves the adaptive strategy by introducing a dynamic population size and adaptive step size in hill climbing to better balance exploration and exploitation.", "configspace": "", "generation": 25, "fitness": 0.09071710311518359, "feedback": "The algorithm EnhancedAdaptiveMultistageOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.07.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.17448541904416703, 0.1812455309546389, 0.18635285408128444, 0.18520037723373406, 0.14986092673550033, 0.1617206145986364, 0.15585823189985804, 0.18026635045737371, 0.18940716074163222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04723200378499992, 0.03737577643500989, 0.036694657081230764, 0.05413832179609013, 0.046739614521732586, 0.05566007563869391, 0.03636464376752924, 0.04306683263046307, 0.05119303616717352, 0.017899096039033058, 0.031921305326900296, 0.023198392632200693, 0.02599443272987334, 0.030777070328246725, 0.0376654996824729, 0.04146208969213616, 0.025225982087530463, 0.03243538972663895, 0.10650367617599166, 0.15258908611210664, 0.10224215443493723, 0.11782550101889433, 0.09234247589444622, 0.12196973131701672, 0.11586684047396267, 0.10949675534615377, 0.10467102683348717, 0.09343550022259428, 0.06752129426639453, 0.09383674898584826, 0.07855861285243648, 0.10061752871495178, 0.08562126544041115, 0.05545858950086591, 0.060149902509579856, 0.08896248153876918, 0.11376456568646298, 0.10939373502459926, 0.11475058881864242, 0.12471126036569491, 0.12821145760392427, 0.1666560591262518, 0.11987206320739219, 0.11858230064698161, 0.10952841505351696, 0.027408515718504334, 9.999999999998899e-05, 0.0012808780441994072, 9.999999999998899e-05, 0.007575505388260018, 0.030253170949842922, 0.008482643546194213, 0.0069741411287157495, 0.01209070129557932, 0.002582229197298669, 9.999999999998899e-05, 0.012716332861298363, 0.0031345386701459033, 0.046470276825266055, 9.999999999998899e-05, 0.006421161662861552, 0.03443898952460167, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027461214247499255, 0.03477405741063122, 0.05565449084885299, 0.06535590192346208, 0.07022742008739058, 0.04957541413312161, 0.06885896662049473, 0.07210052834911562, 0.05113434274751394, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.21109247717276158, 0.19792189080832234, 0.1728587561645063, 0.20904356494141796, 0.19947684627488238, 0.1747260630887204, 0.17529001057516091, 0.18406267889953698, 0.21634505413347316, 0.05199472067258226, 0.03919799663836765, 0.04750753432469823, 0.04089282830403296, 0.047695774927794865, 0.03818042688593726, 0.046406842236137114, 0.05414129842663695, 0.05171398075347333, 0.15661118965920418, 0.15129973393650054, 0.15588095956335024, 0.13804924180633005, 0.14765422046866483, 0.139727828609162, 0.13998751444445312, 0.14681624410253702, 0.12554715478836875, 0.16480624666370602, 0.16246242221211726, 0.1675384421964109, 0.16751896104521924, 0.15758465625200568, 0.19074645731590056, 0.17261755784228627, 0.18438204677996783, 0.15199884056283264, 0.10918940486705542, 0.10416815153442571, 0.10463980308593823, 0.11059586339803296, 0.10754563625765456, 0.11193978975649843, 0.11711321061953495, 0.14676620507819715, 0.09292832004298546, 0.1463847827150272, 0.15700284793130215, 0.14147748702057927, 0.15070000496112246, 0.1545830303857132, 0.17041712685615873, 0.1858411494823905, 0.15957889919187496, 0.1467177478724545, 0.13175098840907062, 0.14850029377912777, 0.14701530505370297, 0.16302466361664314, 0.1400101769821529, 0.1325142528315748, 0.12922654737396677, 0.14256194465817662, 0.15417442897275646, 0.1796265994796995, 0.22999697372724526, 0.15923078090638643, 0.15513536016509932, 0.14663615393960738, 0.25648206515335126, 0.15203286074229239, 0.1591453966789651, 0.16972421244372604, 0.17043360467725066, 0.14703785464273822, 0.14692322720159845, 0.15468443044090308, 0.15139153958487328, 0.15217845415670894, 0.1664617017782104, 0.13344295067753664, 0.181563791463623, 0.18844555819517428, 0.19098892677609958, 0.17789735575109666, 0.19513447333335654, 0.17339215888412474, 0.19004196677466234, 0.1751449997293385, 0.197786209048743, 0.18128325108887933, 0.04870048249622305, 0.04799801234592582, 0.057395520271870226, 0.0468985561902211, 0.04581156373270456, 0.04540881444361389, 0.04752534044410317, 0.049978100205372744, 0.04513577492880938]}, "mutation_prompt": null}
{"id": "68ed2236-a20e-41ca-9f69-1ffa903644ef", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "779937e1-bde9-4b28-8de6-05f906099623", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "4ad7d8de-e9b9-4b4c-9a60-cbdf1bf77eed", "solution": "import numpy as np\n\nclass DynamicExplorationExploitationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (2 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.4 + 0.4 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def simulated_annealing(self, func):\n        temperature = 1.0\n        cooling_rate = 0.99\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                candidate = self.population[i] + np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < func(self.population[i]) or np.exp((func(self.population[i]) - candidate_fitness) / temperature) > np.random.rand():\n                    self.population[i] = candidate\n                    if candidate_fitness < self.best_fitness:\n                        self.best_fitness = candidate_fitness\n                        self.best_solution = candidate\n            temperature *= cooling_rate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.simulated_annealing(func)\n        return self.best_solution", "name": "DynamicExplorationExploitationOptimizer", "description": "Dynamic Exploration and Exploitation Optimizer (DEEO) adapts search strategies by adjusting mutation strategies and employing simulated annealing for enhanced convergence.", "configspace": "", "generation": 28, "fitness": 0.19195818645558074, "feedback": "The algorithm DynamicExplorationExploitationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.4969522339473844, 0.4661129504549977, 0.4617483112380498, 0.4765907329554774, 0.47221461357905725, 0.48594786427732717, 0.49629143026532196, 0.47495073603272997, 0.4973627788185959, 0.21144691971551044, 0.18736647565696252, 0.19338747724363725, 0.19198636982427575, 0.18598690678403362, 0.17437087031560639, 0.2225233959231132, 0.19474535298716478, 0.21886314890830993, 0.09940082359206481, 0.09177343774358049, 0.09410250616412419, 0.08780489722160145, 0.08482522069052012, 0.08163327713538016, 0.0926016369095638, 0.11975646493805447, 0.1072878200186469, 0.07120491928655848, 0.08689664753028159, 0.0792602673654792, 0.08732045344588113, 0.08158507797838122, 0.06812667870185396, 0.07618213519442274, 0.09164551403094923, 0.07965378938605827, 0.8140936483591804, 0.7527177481266503, 0.9201562347133874, 0.9665186728782051, 0.9406614416602553, 0.8947910556726133, 0.8620806178091267, 0.9265264136753997, 0.9298909192529233, 0.18487228330508365, 0.18685028729107145, 0.2072664967869392, 0.17896935604227515, 0.16222820953840678, 0.16551534928006328, 0.1996404414491697, 0.18367601315673276, 0.18674341467443356, 0.24704306536658982, 0.22151452248742287, 0.2474935699054519, 0.29187627629024127, 0.2700706647511213, 0.4003574470696657, 0.23543743802310357, 0.2512812074617101, 0.24621151331578361, 0.10682422010810655, 0.1046711627511866, 0.1251030419792114, 0.11014889988153098, 0.13035325535476006, 0.12829303081285015, 0.12029990687510417, 0.14048877322274733, 0.12283111490419796, 0.10323086251349434, 0.08904251597812674, 0.09098109025324352, 0.11399611173831758, 0.09487514094915728, 0.12437256425065057, 0.08407364008816298, 0.08524928768557671, 0.1047749237926957, 0.011914749940921343, 0.005189745351196873, 0.013265429581290844, 0.0034901401390255993, 0.019701021944233954, 0.005317418556712639, 0.006359651239273956, 0.0025032698137625875, 0.022370254090603114, 0.0934967004685302, 0.12719805805345108, 0.1225407545311511, 0.10039051737672822, 0.09040191195821667, 0.08247826024793281, 0.15232688938946615, 0.1135760102080885, 0.12693525302535258, 0.0117893716074563, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000769425237734489, 0.009297680760005478, 0.07078111784368524, 0.08098761470201243, 0.08252688517933915, 0.08555288631107638, 0.09006556846252045, 0.09305746746090082, 0.07765674295731839, 0.08588524113731733, 0.08772624245176741, 0.37043722296517445, 0.37845218160374694, 0.38161632758411923, 0.41209971564038606, 0.39110362870871507, 0.3974091974103314, 0.3823369423676818, 0.3715867591133428, 0.38915841724157607, 0.0879358153112687, 0.0776928302258264, 0.07978218727843611, 0.0778283803894505, 0.07808026380545074, 0.07461121110733471, 0.09299384372366115, 0.07392483313176146, 0.07386477814069226, 0.13431551795069208, 0.11932979067856309, 0.1418823907733684, 0.14221288741853333, 0.1218390633431512, 0.14880991457709936, 0.12557268033800795, 0.12913088108882298, 0.11301259628509452, 0.23433888192212404, 0.24209526538277137, 0.24775195358553592, 0.235091697330731, 0.22202080530403545, 0.23203511564857504, 0.24846702475714422, 0.25503518893480437, 0.244040274328847, 0.17256262418108503, 0.16024193920262075, 0.16356828252153754, 0.1769257352779645, 0.15095045197658385, 0.15556550512561718, 0.17143848513236792, 0.18046151372733743, 0.1797969383214506, 0.17338253605503795, 0.17195273073554562, 0.1782721209039222, 0.16727048288745372, 0.1730770526985299, 0.17523805827648942, 0.17205262584327952, 0.17426627642330206, 0.16959864658074453, 0.1712058062067643, 0.16702125027960302, 0.1694827123676771, 0.1751209480822743, 0.1729810635588106, 0.17028472261696348, 0.17286617260935122, 0.16600712185381794, 0.17474495882255103, 0.16763711566632178, 0.2586644364462749, 0.21385045954110393, 0.1400137490185871, 0.1435770150645892, 0.16045184026643933, 0.16207246109418516, 0.17365461668988103, 0.14592341324200675, 0.17989680698089783, 0.18345396397058988, 0.3274480387950075, 0.2637043694863178, 0.1593390181322607, 0.12958210582125596, 0.23798508964798448, 0.24245913935438967, 0.18674485280972108, 0.17567430557712593, 0.18234029006580643, 0.18905743720096746, 0.17170595418910584, 0.1767502310174276, 0.16982731400548834, 0.18062397963631482, 0.18752456356746572, 0.17775614361490844, 0.06862263820229852, 0.08991378091024449, 0.06012422870531087, 0.05901228258103197, 0.06767079831494904, 0.07051906689937837, 0.061341143030939405, 0.07319464453921065, 0.07046148488396242]}, "mutation_prompt": null}
{"id": "1554a798-671b-427c-86ba-7382e8ce50cd", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "45c53697-d160-44a2-a8ea-2fc4828847a3", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "091dc117-9367-4ce5-8171-71c03374ee72", "solution": "import numpy as np\n\nclass DynamicHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = min(30, self.budget // (3 * dim))\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n        self.harmony_memory_consideration_rate = 0.95\n        self.pitch_adjustment_rate = 0.1\n        self.adjustment_bandwidth = 0.01\n\n    def adaptive_parameters(self):\n        self.harmony_memory_consideration_rate = 0.8 + 0.15 * np.random.rand()\n        self.pitch_adjustment_rate = 0.05 + 0.1 * np.random.rand()\n        self.adjustment_bandwidth = 0.005 + 0.015 * np.random.rand()\n\n    def harmony_search(self, func):\n        for _ in range(self.budget // (2 * self.harmony_memory_size)):\n            if self.evaluations >= self.budget:\n                break\n            self.adaptive_parameters()\n            for i in range(self.harmony_memory_size):\n                if self.evaluations >= self.budget:\n                    return\n                new_harmony = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.harmony_memory_consideration_rate:\n                        new_harmony[j] = self.harmony_memory[np.random.randint(self.harmony_memory_size)][j]\n                        if np.random.rand() < self.pitch_adjustment_rate:\n                            new_harmony[j] += self.adjustment_bandwidth * (np.random.rand() - 0.5)\n                    else:\n                        new_harmony[j] = np.random.uniform(self.lower_bound, self.upper_bound)\n                new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n                new_fitness = func(new_harmony)\n                self.evaluations += 1\n                if new_fitness < self.best_fitness:\n                    self.best_fitness = new_fitness\n                    self.best_solution = new_harmony\n                worst_index = np.argmax([func(harmony) for harmony in self.harmony_memory])\n                if new_fitness < func(self.harmony_memory[worst_index]):\n                    self.harmony_memory[worst_index] = new_harmony\n\n    def __call__(self, func):\n        self.harmony_search(func)\n        return self.best_solution", "name": "DynamicHarmonySearchOptimizer", "description": "Dynamic Harmony Search Optimizer (DHSO) leverages adaptive harmony search principles with enhanced exploration and exploitation by dynamically adjusting harmony memory and pitch adjustment parameters.", "configspace": "", "generation": 31, "fitness": 0.07508812284399573, "feedback": "The algorithm DynamicHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.06.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.1765273755518958, 0.15031230403031692, 0.19117539441893172, 0.2151412284544022, 0.18773090874933818, 0.18511044645180175, 0.16060248037270553, 0.22004643320962247, 0.18554038283095897, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05302647939108829, 0.05532205743232521, 0.0535161990398636, 0.04463244640722552, 0.052740522162307624, 0.05408094413856401, 0.04899581454335, 0.04744792215829563, 0.03830148847885051, 0.03020081118277196, 0.04357886712680725, 0.05308591179595601, 0.04903665708101268, 0.038582506070202416, 0.0288269380066718, 0.02409462868537371, 0.05980346921503532, 0.04752091976022621, 0.09472391759302412, 0.08913938099221175, 0.08294158175198141, 0.10620846070759105, 0.07732274384233428, 0.08343280612671755, 0.09613445823989264, 0.09021442227920284, 0.11171589855066155, 0.06468430289206406, 0.019760870814805598, 0.025607343065252253, 0.054409823927848655, 0.028411114376332258, 0.03601210050559034, 0.059043597394856984, 0.05748749209731563, 0.04254299728208588, 0.12820887056610553, 0.06774671758963091, 0.10089991013532584, 0.12682090513982092, 0.1816538788150286, 0.1163783236080368, 0.09451178031140206, 0.11984751363876822, 0.07005487895357965, 0.0010017955175571913, 0.00013892656982494866, 0.016638655356974397, 0.0005449315779447739, 0.0014471923412252563, 9.999999999998899e-05, 0.0002555809917952345, 0.018412656143759865, 9.999999999998899e-05, 0.004257501619141624, 0.005024351773726843, 0.0028371204007328066, 0.005036879089965973, 0.024645833990027288, 0.05303094821977716, 0.004738630141868594, 0.003264266898564183, 0.001256162300164343, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029351070805642254, 0.0034330215452286206, 0.018253757054002562, 9.999999999998899e-05, 9.999999999998899e-05, 0.022734198488718715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007793997938589592, 9.999999999998899e-05, 0.00255807151874321, 0.001393888754065875, 9.999999999998899e-05, 0.0012433244552189082, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2033652288501302, 0.16412772471673265, 0.19526363256491341, 0.20779055256142276, 0.18496859868712023, 0.17939028040346872, 0.2299741052168287, 0.13947613378418777, 0.19880569609767595, 0.029197077686793138, 0.0354781272074397, 0.03417729595837349, 0.048066559014162125, 0.027881505120506467, 0.05334307010395045, 0.046267990008731275, 0.024561165288931264, 0.040284877881599845, 0.0850823247230923, 0.10914456930421879, 0.09140988918404769, 0.10324782746997485, 0.10851887610210431, 0.0692936936250731, 0.08931763416330885, 0.08721433027857783, 0.09343262229411042, 0.13230523402563155, 0.16128651732153854, 0.14593333402065967, 0.15621466769386116, 0.15561670557573593, 0.19381361425854526, 0.16733214623220538, 0.1853683748300563, 0.16037866286204294, 0.08491072683819434, 0.1318484620888557, 0.07892220708191966, 0.09081052596606787, 0.08670232654968368, 0.11714628193021748, 0.0875579145248766, 0.10430230408345631, 0.10647345255524032, 0.14387172748670907, 0.16244126966607253, 0.14543197175132994, 0.1368629378646503, 0.12536699089093295, 0.13324745972934615, 0.13343569722741833, 0.12329449946170079, 0.14594787357347905, 0.12615643479173888, 0.12486745034029167, 0.10374476770349705, 0.15376040204272323, 0.12936433189178675, 0.09731718383868793, 0.12378081432687216, 0.11868397895157756, 0.07176357954573576, 0.14890317661621633, 0.1012009907042366, 0.09545293542788491, 0.1732439256059224, 0.12193581872254633, 0.1396709058079585, 0.12265616330585616, 0.10601554612273989, 0.0911099165486956, 0.11039278336826641, 0.12386296842150146, 0.08513299461328183, 0.11430741976319259, 0.10401570153378548, 0.06835069654049841, 0.1233341900064433, 0.09661899550529995, 0.0651522602523944, 0.14447723791810918, 0.1402096138901523, 0.1494636637853537, 0.15870591806330359, 0.1527497295076733, 0.1511171360339746, 0.16265467380002085, 0.1522442635379473, 0.14800849345859546, 0.050331615239533445, 0.03574102006543722, 0.03476226115740688, 0.04629991772945996, 0.05151692600397351, 0.041008991374611115, 0.040528291673909145, 0.043040477370454355, 0.045382305568998915]}, "mutation_prompt": null}
{"id": "ab605ace-10a9-486b-8121-de6ca82d8b6a", "solution": "import numpy as np\n\nclass DynamicExplorationAndExploitationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (3 * dim))\n        self.initial_mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return self.initial_mutation_factor + 0.4 * np.random.rand()\n\n    def adaptive_crossover_rate(self):\n        return self.crossover_rate + 0.1 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.adaptive_crossover_rate()\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def probabilistic_hill_climbing(self, func):\n        step_size = 0.1\n        probability_threshold = 0.5\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                acceptance_probability = np.random.rand()\n                if candidate_fitness < self.best_fitness or acceptance_probability < probability_threshold:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.probabilistic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicExplorationAndExploitationOptimizer", "description": "Dynamic Exploration and Exploitation Optimizer (DEEO) integrates adaptive mutation and crossover strategies with a probabilistic hill climbing approach to optimize convergence.", "configspace": "", "generation": 32, "fitness": 0.1813843162355527, "feedback": "The algorithm DynamicExplorationAndExploitationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.40184072501203494, 0.3726587708009048, 0.35744208891713536, 0.37316408725873085, 0.3826220308242112, 0.3954792859390128, 0.3825391046522434, 0.40185485351256667, 0.39854908597662075, 0.11123849634001348, 0.10374598181997485, 0.09771884387281371, 0.11125904898548344, 0.11540404970269647, 0.09928935654051296, 0.11605037816292385, 0.1340788626769368, 0.10065195687442952, 0.0910882915295832, 0.08979387869827549, 0.09183140419549307, 0.08378643144430409, 0.09272968212032395, 0.09338911318444443, 0.07570813170208368, 0.08719399566081643, 0.08283728257058776, 0.06885402361172077, 0.06538125190050081, 0.06518939968063109, 0.0713794173566159, 0.07391267501040844, 0.06973700156461238, 0.07522600292015191, 0.07021947960158337, 0.07587783115793467, 0.8784066859101756, 0.8382581349960874, 0.8432391536840284, 0.8953660622519749, 0.7443214280069647, 0.82685932711354, 0.9004301576898579, 0.9308018407514798, 0.9045294899730556, 0.15389070387971915, 0.17947885427734123, 0.1865564071500857, 0.15845915972892655, 0.15831600503987098, 0.17742460662895887, 0.18251022864010136, 0.17954804771159705, 0.1721562759779527, 0.2708016790103035, 0.24347484905827343, 0.22328856126377217, 0.2796277945675818, 0.4592297930735626, 0.25641560962982346, 0.2569558457611183, 0.2664734216168325, 0.2676148640424669, 0.10072908516460355, 0.10491582804320754, 0.09123490717853089, 0.11728513254481676, 0.10777301552591656, 0.11720387819943667, 0.1003865297409664, 0.11054566101788987, 0.09864608105609518, 0.09387056493802592, 0.10065931829801988, 0.09289365968999264, 0.11015149675824065, 0.08686041314668258, 0.12314177320579689, 0.09530286894875739, 0.11913175262996556, 0.11348047731184996, 0.014620579743755635, 0.030636994150350483, 0.020368330525797118, 0.027331543501052824, 0.02787907298970005, 0.014038989528173285, 0.01993149657322979, 0.011117724541438445, 0.037217609862676526, 0.10369720024883222, 0.11242035066102163, 0.11425997013490363, 0.12335923696080275, 0.13804957971393872, 0.11122802684497368, 0.12760143022714365, 0.14234029160278772, 0.16499372743087093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007127927137110968, 9.999999999998899e-05, 9.999999999998899e-05, 0.06743748335258681, 0.07260266839745, 0.07757072936938347, 0.07080235267599944, 0.07600263895581172, 0.08094995861765497, 0.07132983183665531, 0.0705911161550119, 0.07337079420736614, 0.33807518692321237, 0.3640361934330163, 0.36416549464336057, 0.3480649412635979, 0.34506337921009755, 0.3402457849754609, 0.35076070422594197, 0.3237389716642859, 0.34264124187565503, 0.09120935641967665, 0.08769417284684478, 0.08191094951392897, 0.07513015948813795, 0.08456247298120267, 0.09739955014224067, 0.08965056438110408, 0.0824878975763822, 0.0923984813798937, 0.15375252608907963, 0.13628241823290044, 0.15670165681054204, 0.14802482876606193, 0.13692817050173467, 0.12995873526448687, 0.15671893542514792, 0.1957560635271569, 0.14322009801109048, 0.2272287674747797, 0.24125236938309313, 0.21515707246094307, 0.2167373180534431, 0.21825165587191653, 0.20883257137729638, 0.22786238159091576, 0.23832539774132122, 0.23469240231666777, 0.15933514244800184, 0.16015604166648734, 0.17462729017763645, 0.151674770332631, 0.15153232726234533, 0.15158342853153062, 0.176626170551336, 0.16264829833659955, 0.1760332217236279, 0.17413283160313697, 0.18280848792733317, 0.18530389349409238, 0.1756035728644425, 0.16979185611326897, 0.16535428887091763, 0.17562749458000837, 0.1799871199045452, 0.18802922749368678, 0.16785661500182636, 0.16779214933560704, 0.17779595751949762, 0.17123753905718098, 0.1741341472219503, 0.1768220810017478, 0.1678656584935101, 0.16360837213418677, 0.18154678124840862, 0.2195571829177564, 0.16946257134406317, 0.1436509611487643, 0.1779231139445746, 0.15277627154264772, 0.23128837433035332, 0.26480493058973964, 0.1631687475959589, 0.16143204195233285, 0.17951484449169386, 0.1791195551025203, 0.19950726086495363, 0.16703506870614004, 0.13673897977983507, 0.19052167295792777, 0.17011813086360694, 0.35821065201472235, 0.198888205879319, 0.18742624150853693, 0.17359662575477175, 0.17745809140985747, 0.16422388691710565, 0.20505411801068474, 0.18902339395398104, 0.17879234018286627, 0.17168233012929324, 0.17008532110400487, 0.07374488109637589, 0.06452586111175207, 0.06386972907895505, 0.0611247732489959, 0.06832263461002908, 0.06808562702033416, 0.06522786741700093, 0.07086767716571207, 0.05970131583401361]}, "mutation_prompt": null}
{"id": "ddf87ece-10a5-41dd-afdf-a77f8ac6f0d9", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "552fd91b-8654-4671-8b63-3cacc7d4df64", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "477e9491-3905-41fa-9640-467139b2198f", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "566e5aaf-d225-4431-802e-eb3e754ca3f4", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "c7585b0f-e3dd-4955-b128-ee46c902dc2e", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "53e6accc-0ee9-4230-afac-7cb137f048e0", "solution": "import numpy as np\n\nclass DynamicHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (2 * dim))\n        self.harmony_memory_consideration_rate = 0.9\n        self.adjustment_rate = 0.3\n        self.bandwidth = 0.05\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def adaptive_mutation_factor(self):\n        return 0.2 + 0.4 * np.random.rand()\n\n    def harmony_search(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                new_solution = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.harmony_memory_consideration_rate:\n                        new_solution[j] = self.population[np.random.randint(self.population_size), j]\n                        if np.random.rand() < self.adjustment_rate:\n                            new_solution[j] += self.bandwidth * np.random.uniform(-1, 1)\n                new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                new_fitness = func(new_solution)\n                self.evaluations += 1\n                if new_fitness < self.best_fitness:\n                    self.best_fitness = new_fitness\n                    self.best_solution = new_solution\n                if new_fitness < func(self.population[i]):\n                    self.population[i] = new_solution\n\n    def adaptive_differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.harmony_memory_consideration_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.03\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.harmony_search(func)\n        self.adaptive_differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicHarmonySearchOptimizer", "description": "Dynamic Harmony Search Optimizer (DHSO) integrates harmony search with adaptive differential evolution and stochastic hill climbing to balance exploration and exploitation tailored to problem landscapes.", "configspace": "", "generation": 38, "fitness": 0.16899997249011786, "feedback": "The algorithm DynamicHarmonySearchOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.12.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5626589259579734, 0.5182084163967071, 0.5419475297395389, 0.4387454198009052, 0.45678933174918646, 0.3361145003169357, 0.5598275527578052, 0.5139387220948868, 0.6022549052270942, 0.01216757651034095, 0.06892902206790352, 9.999999999998899e-05, 0.0019541095824704424, 0.010644249127048866, 0.0904965670919814, 0.09487197298455541, 0.127296708782082, 0.24180800898030586, 0.24392461005123345, 0.0931395231603146, 0.18248361487314235, 0.1303331314524363, 0.0957935271656779, 0.11439899927625086, 0.107696837542968, 0.13314452709291058, 0.09344709594436384, 0.10588570181826484, 0.07957188093792067, 0.1381481180232509, 0.13410378497349795, 0.1017856707896706, 0.10218738572701547, 0.1277968307586782, 0.08965720454226755, 0.12711724665190083, 0.1758441470722697, 0.4704372235821792, 0.3200148867817476, 0.15245071687061773, 0.7855368352307779, 0.17837803604455316, 0.16554516617747705, 0.46682630743103315, 0.20936945030757348, 0.07351611708605066, 0.09767847092720061, 0.11352409559670706, 0.11747572488920854, 0.07126057601826141, 0.04399374694276359, 0.14926730256962306, 0.09493464529482787, 0.1559609849754292, 0.18586151169646625, 0.16362756673204548, 0.12365244355235294, 0.26405425057345433, 0.28540196136507034, 0.1444856342544577, 0.0972715060787197, 0.2345048806867177, 0.1856928906701677, 0.1432884053881136, 0.09737083730466678, 0.10330661158142229, 0.12302868020348046, 0.08192459808109342, 0.12651005312428076, 0.11140233161678259, 0.13825230870838878, 0.11927249522775096, 0.11004508367678922, 0.08500644035036764, 0.1340102664031101, 0.12278055751046268, 0.24525487819349368, 0.1429933453257266, 0.11695868140976495, 0.11470720954001823, 0.11906308576909763, 0.01258552969608806, 0.023106867178437462, 0.0002961853507634782, 0.0013745345309255086, 0.01914341119565144, 0.02452381092608724, 0.03021486507455029, 0.0010929776078406617, 9.999999999998899e-05, 0.10083026156752772, 0.07038324617098934, 0.1080663746534547, 0.07335006865922167, 0.07870264141620298, 0.06783423309510384, 0.08679167403983179, 0.08672420314876639, 0.10656492273253493, 0.05745226480934251, 0.06694550741918137, 0.10773117642460273, 0.04031128909098258, 0.05936807992099036, 0.08459442059915179, 0.03363094765771335, 0.08978380029563993, 0.08413960091093775, 0.15687475731085976, 0.12815788076234746, 0.10961307933995235, 0.07758382803948605, 0.04074310947667348, 0.10009117476279028, 0.07725104395404836, 0.11601538558703672, 0.1171396122387458, 0.34571184404694044, 0.3614411528166406, 0.34112456228275156, 0.42689520533272485, 0.3743137718233057, 0.3869211713630838, 0.3920080541303551, 0.3780805573925844, 0.3784802183470559, 0.1063748600507981, 0.0778090137155314, 0.07802827712998173, 0.11285685536996204, 0.0687851205039145, 0.16542216597978954, 0.08986273700010605, 0.10404005530522753, 0.10932561092568316, 0.13737823768157853, 0.12723894352809162, 0.1255000494762245, 0.14258208524988636, 0.17276003560793507, 0.1421206931133222, 0.1390199434422943, 0.12807680145950984, 0.12924821272408282, 0.20457150970192484, 0.1974077216838127, 0.1874798489361843, 0.20014002247500973, 0.24174196933835723, 0.25791369724708324, 0.26941541759092336, 0.2610491520494457, 0.30614041259888614, 0.19225736012048367, 0.1601043441937522, 0.1718807733730935, 0.16319863576417304, 0.17597490142288663, 0.21808976257461765, 0.2626474904147367, 0.15300316235053124, 0.16835849074017728, 0.19777123863995727, 0.1906003692993563, 0.20877570624183928, 0.20098659715598455, 0.2030314962861277, 0.18978529522554022, 0.2132979787556566, 0.20091815941408386, 0.20524493124526466, 0.16778196623577846, 0.17119783531350563, 0.1790111166711813, 0.18287486692430432, 0.18424622575425642, 0.1802522795441539, 0.21793371852112065, 0.17790086063525545, 0.16637593830275876, 0.17100473355878676, 0.31124085059279294, 0.162544180565812, 0.1797429807170472, 0.19185874644392287, 0.18630817160365742, 0.15152964288755333, 0.16934324317279315, 0.1580330788638461, 0.2960588596562026, 0.1621277401080109, 0.36384586050074863, 0.1583315597988323, 0.18795534735018793, 0.13291489340089724, 0.18508351728340322, 0.48867474519069787, 0.20263280165854525, 0.18343953170563376, 0.1696755869776101, 0.18060513003612344, 0.17133619074850615, 0.1730016286491327, 0.1769843899725545, 0.17838843044514485, 0.17175939179220256, 0.1940793554728677, 0.08333705265328195, 0.0757791849854077, 0.07750690450822473, 0.08052308823775023, 0.07793124321088796, 0.0773041636032491, 0.08067729737121776, 0.06326641037694702, 0.078175710806895]}, "mutation_prompt": null}
{"id": "f3308154-4cdf-42a0-a420-fc9ed2deb5c5", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "fe6983d5-e754-41b2-91af-adf25052a80a", "solution": "import numpy as np\n\nclass DynamicHybridHeuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(40, self.budget // (2 * dim))\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n        self.restart_threshold = self.budget // 10\n\n    def dynamic_mutation_factor(self):\n        return 0.4 + 0.4 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.03\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def restart_population(self):\n        if self.evaluations < self.budget and self.evaluations % self.restart_threshold == 0:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_hill_climbing(func)\n            self.restart_population()\n        return self.best_solution", "name": "DynamicHybridHeuristicOptimizer", "description": "Dynamic Hybrid Heuristic Optimizer (DHHO) combines differential evolution with adaptive parameter tuning and stochastic hill climbing, integrating restart mechanisms to improve convergence.", "configspace": "", "generation": 40, "fitness": 0.2346920238157735, "feedback": "The algorithm DynamicHybridHeuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.623927827799144, 0.6045336311436995, 0.5993802832194846, 0.6397959423356494, 0.6327028028599153, 0.6450642583811599, 0.6169609464144576, 0.6342762957707764, 0.6071896581648366, 0.31795587029575656, 0.36653399027041345, 0.3311454317666389, 0.32951052671482206, 0.3713478170722201, 0.3641474608393178, 0.35006653496144946, 0.39332756536791924, 0.3615501387575517, 0.0948415087813903, 0.10958542288417916, 0.10611290062828482, 0.09805530040148058, 0.09077604007461271, 0.10835748651638533, 0.09393784522898985, 0.10655282129471111, 0.13361716986953998, 0.0884491426841778, 0.09429129522323187, 0.09173941897425253, 0.1013411874292155, 0.08441977193280925, 0.08600814105193932, 0.0854931093701925, 0.08461688988407656, 0.09155484603331465, 0.9731441112132363, 0.9022583530870706, 0.9037518441059227, 0.8434427284605984, 0.85468677300447, 0.8673352125044713, 0.9147607391130059, 0.9116382123838337, 0.9138702610532099, 0.25213109970827485, 0.2505049134863866, 0.25967137975976173, 0.2397854572254905, 0.24729022800262423, 0.24919752794130856, 0.24756092871389723, 0.2640829382100952, 0.23958416938102578, 0.4379374840349811, 0.4157883858266287, 0.42694482141680523, 0.4596450065633214, 0.4258307604041466, 0.40676131502273605, 0.5758275419286494, 0.4664411056959189, 0.5874170505016159, 0.1281159742239708, 0.1494566779703269, 0.15290818525754335, 0.12925757812795147, 0.13472540105711883, 0.17179001403998995, 0.15124926118267779, 0.11210723028959058, 0.1476969700696138, 0.14376124322386896, 0.12055867817503718, 0.12081293393560355, 0.14175353131287616, 0.14957677841614148, 0.13422229256157714, 0.13236985931123857, 0.14555499099770497, 0.15764838111638124, 0.04219570835642805, 0.046661633824108484, 0.06200027368953143, 0.041898337980607936, 0.04253647932246585, 0.036809663671500514, 0.03659078840991259, 0.061097193126966376, 0.051923937705457, 0.17710306270523601, 0.1826261437101444, 0.18725464493785526, 0.09314653341827706, 0.12046362080186301, 0.17615972539095148, 0.18520543829639113, 0.21953807772646217, 0.18538015484697867, 0.027008458172404826, 0.014021944080499504, 0.013409290576684718, 0.011922291482631575, 0.02002635620156057, 0.01048327112180103, 0.023459005658048815, 0.020252965398811607, 0.024963874246965, 0.10690286832481666, 0.1278273213984179, 0.11394985072702335, 0.13459172039797762, 0.12376780702187284, 0.12856950988150706, 0.09845269115307909, 0.1417490147077608, 0.11423313645437194, 0.4720190531610652, 0.4774983691052006, 0.4660641456370884, 0.47158693568358934, 0.4408723637948343, 0.450899227859613, 0.44102714040268765, 0.43923824129920086, 0.4636240890239409, 0.08135732057396594, 0.08997190192777926, 0.07796987471724193, 0.0874083587918063, 0.08224832795615089, 0.10888216629578729, 0.08148982108321012, 0.07988815422319528, 0.08766419758592692, 0.13633001664712685, 0.13381274578806934, 0.14182594692517336, 0.14023016690321455, 0.13312483655591711, 0.13075884116465442, 0.14979686844354712, 0.1344292681873538, 0.12852480050801263, 0.26945375393290694, 0.27451518218396165, 0.2627867502006387, 0.2689586680244923, 0.28433889614095365, 0.29473193821495836, 0.2855492344573245, 0.3039915229430449, 0.2784031763440299, 0.18667372930728499, 0.19217882461565405, 0.19473050204157194, 0.1855043500021165, 0.1884496960228953, 0.17928135916893428, 0.19818678305143245, 0.21034844855439083, 0.21745971503180495, 0.1866670764338323, 0.18040667914258102, 0.17883049869018142, 0.1680276187097508, 0.20756040383046614, 0.1892286412816584, 0.18723864737768015, 0.20947220088181862, 0.17239079239283017, 0.17230856295989982, 0.17397529451832727, 0.18073743891937089, 0.18283388257539956, 0.185935570452068, 0.17377800964401047, 0.1762112858563738, 0.1828384390977098, 0.18059213396237805, 0.16073602120137054, 0.15595064763696043, 0.24487748351233618, 0.5209041275629429, 0.27625269596776914, 0.17700217645033112, 0.17373369552341522, 0.15760956501699552, 0.1792808782226024, 0.2978035184823027, 0.19148712914996113, 0.20980618780353444, 0.2143583458918411, 0.16104214497545566, 0.18649242502270003, 0.20523085166215094, 0.1986222266936375, 0.2036237655300246, 0.19800923546503502, 0.17567456513490742, 0.18454704533850286, 0.19645456887313661, 0.18409983596286394, 0.1834671429476633, 0.17314666602886586, 0.1790544927910923, 0.17731757562800854, 0.07166081494711907, 0.07294697467340339, 0.062448673645152275, 0.06856222523725608, 0.07722459212482113, 0.06739500543678656, 0.07354653245421905, 0.06608860665737049, 0.0696934120003907]}, "mutation_prompt": null}
{"id": "6dc879c6-dd9e-45eb-ad5c-f1f8a893f288", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "20f7b3a0-a4bd-44be-b09b-4a9601eb11f4", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "ef3ef994-cb5d-4a7c-8f2d-b9939b8c0651", "solution": "import numpy as np\n\nclass DynamicHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.85  # Adjusted crossover rate for varied exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.4 * np.random.rand()  # Adjusted mutation range for diversity\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):  # Adjusted loop iterations\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def enhanced_local_search(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.normal(0, 1, self.dim)  # Using normal distribution for direction\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.enhanced_local_search(func)\n        return self.best_solution", "name": "DynamicHybridOptimizer", "description": "Dynamic Hybrid Optimizer (DHO) combines adaptive mutation and crossover strategies with enhanced local search to balance exploration and exploitation efficiently.", "configspace": "", "generation": 43, "fitness": 0.23477737419765532, "feedback": "The algorithm DynamicHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.6201781427084074, 0.528768603588261, 0.5897881558406357, 0.5244329837877397, 0.6120705134890392, 0.6512149383605095, 0.582894269133147, 0.5774209694658968, 0.559797433413204, 0.2395130938629194, 0.2281390882943749, 0.2881117308133092, 0.3045502428252779, 0.2872395316403491, 0.31646748411322645, 0.31819433424881016, 0.30295839414072356, 0.3446303299539465, 0.1072129161698736, 0.10357434642346486, 0.11220940572182903, 0.10935940649782372, 0.10564870822468597, 0.11514083045667789, 0.11276108323843148, 0.1010426959049271, 0.10730717464090522, 0.10298664408642, 0.09608351285067385, 0.11296009280297659, 0.09838925370306884, 0.08778591905158972, 0.09008889811976661, 0.10223528641776736, 0.08708919588375352, 0.10037288890934648, 0.915954961082541, 0.8402200321619495, 0.8732447335675382, 0.9237093591941676, 0.8819774695699549, 0.8446086390976915, 0.8296116690601336, 0.913787557751005, 0.8270494000223243, 0.21981236411024707, 0.26533420503155747, 0.22251334795157596, 0.23178621983862902, 0.22231507610489576, 0.25207474275183417, 0.2640682797881505, 0.2535784977122484, 0.25679391840139454, 0.45337488306916973, 0.5477214246172317, 0.359311964878553, 0.551157746190232, 0.5056043827506496, 0.515933447045214, 0.5255246043879302, 0.30689970264263344, 0.2946436940152124, 0.15356697585724688, 0.15798414238673397, 0.16121750008012825, 0.13859694466331585, 0.12888876365379343, 0.11007314705206717, 0.13907302486214723, 0.1527737914776537, 0.13560756401095386, 0.1395699679248653, 0.1013990730063632, 0.12447348456254514, 0.14451173554831187, 0.1605292442628885, 0.1616719437389671, 0.1643880086957804, 0.15928021230245792, 0.146821724110055, 0.06597456412696212, 0.06600849871743775, 0.032572314613177666, 0.060589884978941466, 0.07619909511008971, 0.03943674166906841, 0.10628520264129093, 0.050657033052052935, 0.042709667992515854, 0.17353174964475548, 0.1698598218135039, 0.1959143033850932, 0.16443646694483782, 0.14784843313006235, 0.15424208645298132, 0.21657789988667053, 0.18773404792621273, 0.22871308350572872, 0.029697671074263243, 0.03273246000581331, 0.03502406843416794, 0.010532124120686936, 0.009428193320168088, 0.05416028742847934, 0.020010222605374994, 9.999999999998899e-05, 0.00886316259329123, 0.0991334879462864, 0.1232541932148653, 0.13088645730385562, 0.11994107397507436, 0.1392649393768295, 0.12030300248119896, 0.11196806061874953, 0.14383390686165043, 0.1281327689025844, 0.42963325654705664, 0.44895038109608787, 0.44264660451717486, 0.4918109087067899, 0.48029074443556397, 0.4592745952879367, 0.43499848954585063, 0.42441502382164953, 0.43615678560179894, 0.09623226056366607, 0.09447374665694697, 0.10856679052108009, 0.09565682907166861, 0.1038504797955837, 0.09699296939414603, 0.08406633708496725, 0.10941061535882435, 0.09688587429330597, 0.13313049062036575, 0.12492561141940839, 0.15464880264446224, 0.1385136460183929, 0.13586094480112865, 0.1454893961608097, 0.15436566875378666, 0.13393340882415616, 0.13370233157323086, 0.27258223343114085, 0.3083801060040351, 0.26606358670454555, 0.28684977984943594, 0.26573935599103005, 0.28656388117287723, 0.2774756851502762, 0.2949123320058584, 0.2834619303200373, 0.19969836567979005, 0.22171938041079142, 0.19364099427191261, 0.20357339636923022, 0.18413127260127127, 0.2102003978170185, 0.21295331295070108, 0.21797506779782005, 0.20345224769200354, 0.20838399845977618, 0.19004229202692913, 0.19468209990551621, 0.19996164839502806, 0.17700241233230996, 0.192760821221877, 0.19268597820301292, 0.18287946353986195, 0.1890726866394965, 0.18195335779980115, 0.1849105566157505, 0.18692581367338013, 0.1984741146558946, 0.18828274783594845, 0.18755598179091781, 0.17616076167627837, 0.2029084308906095, 0.19140268527880955, 0.17162727467838612, 0.5678008836175362, 0.41377964637141307, 0.2324411407615551, 0.23795079081741766, 0.2890857900233754, 0.15773930901271982, 0.2819794694798238, 0.17248995775467846, 0.1544635474766366, 0.19984338222586506, 0.315231671572355, 0.15327350978873278, 0.188235373758183, 0.15499239650283636, 0.21320720188873732, 0.452422670190921, 0.14940992376504314, 0.1733753157933735, 0.18490456774147646, 0.17587803765822974, 0.17641269801690085, 0.1744120270638566, 0.1769098171861706, 0.1903210520599109, 0.17634182344846305, 0.18664398501789314, 0.07171019031454162, 0.07746154747213152, 0.07787644187220155, 0.07452183090573383, 0.09001894531826815, 0.06800431438020693, 0.07947036786591144, 0.07040103196584202, 0.0727576770199928]}, "mutation_prompt": null}
{"id": "e42c4ab0-8573-4674-9008-3ed8581587ad", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "e7dfb135-e535-4826-befa-3b4c8a04c643", "solution": "import numpy as np\n\nclass DynamicDifferentialEvolutionWithSwarmIntelligence:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (2 * dim))\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n        \n    def adaptive_mutation_factor(self):\n        diversity = np.std(self.population, axis=0).mean()\n        return 0.3 + 0.4 * diversity / (self.upper_bound - self.lower_bound)\n    \n    def differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def swarm_based_local_search(self, func):\n        step_size = 0.03\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.swarm_based_local_search(func)\n        return self.best_solution", "name": "DynamicDifferentialEvolutionWithSwarmIntelligence", "description": "Dynamic Differential Evolution with Adaptive Swarm Intelligence (DDASI) optimizes black-box functions by adapting both mutation strategies and local search intensities based on dynamic environmental feedback and diversity measures.", "configspace": "", "generation": 45, "fitness": 0.24014225680963305, "feedback": "The algorithm DynamicDifferentialEvolutionWithSwarmIntelligence got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.18.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.6339376309829574, 0.6330876466076865, 0.6047652793791329, 0.6222733972124999, 0.6280988882881187, 0.611444630390215, 0.5890194791836398, 0.6286564110404869, 0.6026169457868804, 0.29893000162557204, 0.3326656579978846, 0.26904711927055414, 0.3303125120725433, 0.3041895634226004, 0.300661898372086, 0.3115697074628184, 0.29153098601875416, 0.32528471369741396, 0.1093403594713771, 0.12205295894658208, 0.1139920829505805, 0.10930494239063193, 0.11037151484449936, 0.13266372845761631, 0.10503261786883666, 0.10981852543083914, 0.10102558292832398, 0.09374419354235763, 0.09054908717469967, 0.11602064221670261, 0.09994009266970028, 0.08938690925444603, 0.09087177815390302, 0.0913125551918984, 0.10413379384008081, 0.11181400917335671, 0.8806717358897126, 0.8060270240521052, 0.6836413359913769, 0.6794274136432641, 0.7716108282750727, 0.822318362248332, 0.7785692059853455, 0.8169351782949565, 0.6137437574131817, 0.18940820442771888, 0.23661383843610617, 0.1530993948005004, 0.15195675951644638, 0.19840942287622898, 0.16571425204714596, 0.2269690789494634, 0.15454766137628306, 0.12149833235523022, 0.6121906902652515, 0.5542489689056508, 0.61113447887527, 0.2568441122139804, 0.6068055632516836, 0.5162243697147493, 0.5703003235839326, 0.5481217971604339, 0.5831655609286222, 0.13456514174044154, 0.1098553070123659, 0.14218823234215872, 0.12457589367036093, 0.1349705605950483, 0.15634130414074188, 0.159390928192799, 0.20812762316342792, 0.1557781219495724, 0.12880158489653026, 0.12516399796404354, 0.12123283614222125, 0.17860004667419016, 0.1627884701177823, 0.13818962940677282, 0.15130387290796243, 0.13134450586327784, 0.16000705498274348, 0.08823448437807835, 0.07158066924981288, 0.07702146501666962, 0.09728621351802447, 0.08895347353808358, 0.04374956641639205, 0.06265413026960709, 0.06577994261941, 0.022296339129274978, 0.23094167338843086, 0.22499678842104487, 0.14624383087781312, 0.15098192561743995, 0.22215327111827854, 0.15880372538570942, 0.23846479850113933, 0.21817040575101898, 0.22367305440964946, 0.046294759592341195, 0.04671143793553345, 0.03910685785891144, 0.060004995467837774, 0.030960545103130843, 0.05794115858227211, 0.061794351394727665, 0.038696302030722496, 0.053332281485209965, 0.11421153832610476, 0.1507825115620961, 0.15804317950828894, 0.12349269569982135, 0.1454898169822223, 0.17447314491309485, 0.11688049826902591, 0.11377287332691921, 0.11650229951061375, 0.4654914444675471, 0.4875173392809973, 0.47323498061960667, 0.48141261744685493, 0.45658214429993726, 0.4365783622915659, 0.458430528792401, 0.4617423522266989, 0.4562493988887101, 0.10097991775406101, 0.10457271248396605, 0.09545077283871195, 0.10454219348807159, 0.10465885084437432, 0.09621266301904763, 0.10042381198537353, 0.09256016282564816, 0.10138657318554489, 0.14110573986383712, 0.13209465301300438, 0.16875975561099255, 0.15011102717798075, 0.11602628333473275, 0.13264432332318066, 0.13662935817623179, 0.12090921263784893, 0.16212317394887343, 0.30806348103050796, 0.2728369247926363, 0.30800448636830824, 0.2794768292288624, 0.3080838354164943, 0.30977122018032344, 0.31158513471647886, 0.3216127523446204, 0.31837557238002534, 0.22614894587686707, 0.22277347320536878, 0.23092548731263995, 0.23140867113122732, 0.23670623046419237, 0.22273818819610358, 0.2435482697141942, 0.26050280432497985, 0.2268203616102955, 0.20166667356879753, 0.20948906582623628, 0.20144432050756422, 0.1830071698469139, 0.18503910423483771, 0.19141914597667586, 0.1866184907270385, 0.17420635005550522, 0.1930733404486248, 0.1989954790848123, 0.18511246905422396, 0.18524966452437275, 0.18217674383082394, 0.21443568307234606, 0.1838784560283412, 0.18256676483107437, 0.18825545351931372, 0.17804974768987936, 0.17704703645582553, 0.17338536973128105, 0.4732619827631527, 0.36183190240454655, 0.40114988169942933, 0.29631315505939504, 0.2510700303150495, 0.19415615575262746, 0.2575966361719486, 0.43803729540610226, 0.27123744828730434, 0.19306508196506122, 0.18225905768324957, 0.19472396389324176, 0.206383699736159, 0.179414471055098, 0.24834178154312003, 0.1979365643212413, 0.18374912025332713, 0.18189075406669286, 0.18611253787679705, 0.1816083499979838, 0.18615419902826646, 0.17853371716392286, 0.17530934954842992, 0.19030425347807278, 0.1716809693580279, 0.08707366078449452, 0.08057501972694081, 0.07505053975128262, 0.0697607566291486, 0.07759070437695792, 0.07621871670941038, 0.07603610531973248, 0.07917535877804827, 0.08082708712854636]}, "mutation_prompt": null}
{"id": "24bcc66d-61a5-4b4f-b161-6c806b7fff35", "solution": "import numpy as np\n\nclass DynamicCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (2 * dim))\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.2 + 0.6 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.1\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def random_jumps(self, func):\n        jump_probability = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            if np.random.rand() < jump_probability:\n                idx = np.random.randint(self.population_size)\n                candidate = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[idx]):\n                    self.population[idx] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        self.random_jumps(func)\n        return self.best_solution", "name": "DynamicCooperativeOptimizer", "description": "Dynamic Cooperative Optimization (DCO) leverages adaptive differential evolution, stochastic hill climbing, and intermittent random jumps to enhance convergence by maintaining diversity and adapting to landscape changes.", "configspace": "", "generation": 46, "fitness": 0.21672070555319375, "feedback": "The algorithm DynamicCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5460466273111195, 0.5557929248541118, 0.5894270083484346, 0.5369669646366959, 0.5658369389329021, 0.5435626463980461, 0.5636798731039085, 0.5594033821891813, 0.5727591206917463, 0.268965509062681, 0.26360200255644584, 0.26792027858917433, 0.26755984057458204, 0.28107244200301484, 0.27092055339329557, 0.28371140221977276, 0.26343417073834663, 0.3152888048005852, 0.0945353632732906, 0.11884321985833846, 0.09465757558373067, 0.0893400977488007, 0.09693755350343458, 0.10128003330168811, 0.10406480848498034, 0.09364142292389366, 0.09965856877601686, 0.09027209220259325, 0.09955313874684402, 0.08324676961538702, 0.09420583414684403, 0.08761497653891914, 0.0939176772995366, 0.08826459975313106, 0.08736501722654266, 0.08515813861737409, 0.8775472185191815, 0.7524050413844809, 0.8898219478635859, 0.9351838669011363, 0.8819114331384456, 0.9433235654279342, 0.9341243941514674, 0.8984653937442113, 0.8974618791284494, 0.20550454384559802, 0.20548697569223262, 0.210452207041252, 0.1724768139622438, 0.19703804371246192, 0.1984593999730344, 0.2156462535890188, 0.1694367402387288, 0.202352250633839, 0.29178313666765787, 0.31095112879418885, 0.25575374457035105, 0.37109252894520073, 0.4082690883589337, 0.39170749123137805, 0.4052393588453218, 0.4064431974696988, 0.3415170998996646, 0.12160143995742778, 0.11436408314114832, 0.12596073866740676, 0.1409625048541806, 0.14077860055835845, 0.12918437809823258, 0.13997197189262844, 0.14372649810269145, 0.1408100216419227, 0.1197076500177, 0.10130770760122199, 0.12342142809899359, 0.12764489485135633, 0.12787122262362083, 0.16597516608367857, 0.14691660009066487, 0.13272370723177374, 0.13982578350036978, 0.027351186227998925, 0.02530709141680576, 0.02159603655114628, 0.015437280207601156, 0.0383080873313586, 0.02552666171289042, 0.03579793362028616, 0.01693026398143227, 0.027840532072409996, 0.13637028791572625, 0.12667836524991272, 0.13438207699959603, 0.10503974797604132, 0.16366197972138785, 0.12240877668717076, 0.1594407464791553, 0.1473156826099714, 0.14764743782155088, 9.999999999998899e-05, 0.0048678684469152245, 0.020662059099713748, 0.007407125797335157, 9.999999999998899e-05, 0.00832664018886442, 0.00965885171696701, 0.006238659308711814, 0.020100276482970858, 0.10986848399535887, 0.09790721290660787, 0.10631530068812112, 0.1035952147166549, 0.12480966686847073, 0.10970702478783301, 0.09918985546359638, 0.11555887177105528, 0.10670324263252118, 0.42597029083054205, 0.4097916702134655, 0.4435514930027473, 0.4143045211521701, 0.4188139463528522, 0.45274477234764177, 0.43678357455285943, 0.41197670052384294, 0.4458336072830712, 0.09621061601462011, 0.08537123439799266, 0.08672913261175985, 0.08201328959473975, 0.08968911785467337, 0.08483700519415072, 0.0694035893573588, 0.08512911312673932, 0.07887123166203347, 0.12304836332661506, 0.1401061892832004, 0.1535920038017946, 0.14867732284065782, 0.13725840480851725, 0.11359105304039863, 0.1420870593351896, 0.13718846585632904, 0.17022942098593397, 0.26127697748956147, 0.2617638768498932, 0.2681262414167569, 0.2819925524835283, 0.25673236556355294, 0.27023681066473537, 0.29139778643395475, 0.2805232985699013, 0.2758078265035432, 0.19249748234506237, 0.18931387882091266, 0.2095507738363539, 0.19432295357834217, 0.19111268161596062, 0.1876980975864, 0.20317068022062523, 0.21032840453619916, 0.19971701371054273, 0.17672565189851153, 0.1854500457849224, 0.1734650947766282, 0.185303308568879, 0.17851978414103653, 0.18025510774225262, 0.17781854519602291, 0.19649005109578643, 0.18105240414935098, 0.1750949717763659, 0.1682279180492915, 0.18060121340997393, 0.1823555936826482, 0.17393718983130857, 0.17461506985849196, 0.17618757638488514, 0.160845962976788, 0.17145439877648683, 0.21798124091294924, 0.3165582845077316, 0.3292727151010697, 0.29744795065285246, 0.25668030717830204, 0.1619383060530074, 0.16269381387687532, 0.19337970624484702, 0.22780290659760138, 0.1587353882715994, 0.2956891825717609, 0.2772713494718124, 0.1835223144211846, 0.1629759852270377, 0.15324389975487773, 0.19183229178602046, 0.2346717001700498, 0.3437773473323581, 0.19389913299185457, 0.18216944352184006, 0.16619804930802873, 0.17506206769084998, 0.18461113936147955, 0.17454768919349595, 0.18522292487470382, 0.17250154502587134, 0.1861804091950372, 0.06570415356432258, 0.07525667577260298, 0.07732386125406787, 0.07026186951520053, 0.07094908660583221, 0.0659408893600043, 0.06544965015810067, 0.06797126248195473, 0.05990203160270213]}, "mutation_prompt": null}
{"id": "d0253c56-a073-4287-971a-cf8e2c4daa99", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "a0d85702-00c8-472f-9e4a-060e09ef3e0f", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "b0eb1486-8294-454f-a06a-b7e5b0ab6f7b", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "287ad7b7-4ddc-4b48-88b5-14795fb1af46", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "8da9bf18-669b-4869-9b1c-9b2b2711832c", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (3 * dim))\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self):\n        return np.random.rand(self.dim) * 2 - 1\n\n    def quantum_entanglement(self, a, b):\n        return a * 0.5 + b * 0.5\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.1\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = self.quantum_superposition()\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def quantum_interference(self, func):\n        for _ in range(self.population_size // 2):\n            if self.evaluations >= self.budget:\n                break\n            idxs = np.random.choice(self.population_size, 2, replace=False)\n            a, b = self.population[idxs]\n            entangled_state = self.quantum_entanglement(a, b)\n            candidate_fitness = func(entangled_state)\n            self.evaluations += 1\n            if candidate_fitness < self.best_fitness:\n                self.best_fitness = candidate_fitness\n                self.best_solution = entangled_state\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        self.quantum_interference(func)\n        return self.best_solution", "name": "QuantumInspiredAdaptiveMultistageOptimizer", "description": "Quantum-Inspired Adaptive Multistage Optimizer (QIAMO) enhances exploration and exploitation using quantum-inspired superposition and entanglement principles alongside dynamic mutation and crossover strategies.", "configspace": "", "generation": 51, "fitness": 0.23371916728599443, "feedback": "The algorithm QuantumInspiredAdaptiveMultistageOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5849574595121972, 0.5604994206672067, 0.5543420343185558, 0.5724808561521997, 0.5756031527128641, 0.5771692232240726, 0.5958660164382367, 0.586407523721644, 0.5839808701392604, 0.2698268924283248, 0.2498447775879009, 0.24632524476514728, 0.3049009014407573, 0.31777487177180996, 0.2890889999750955, 0.2770893351678282, 0.2964686816047597, 0.35194936135217625, 0.09399777035053936, 0.10830866431162123, 0.09165603283383228, 0.09885080475403685, 0.11176014675969215, 0.12166111947264979, 0.11036674238055622, 0.09856553635246124, 0.10313618899249011, 0.09784169465784798, 0.09491155542124996, 0.10255061669940457, 0.0915461869857509, 0.10801788187982142, 0.08874627989477846, 0.0881821904581378, 0.08635606659009754, 0.08830131350607096, 0.8769959465230717, 0.8728578089412524, 0.9067438514335388, 0.8916779271759868, 0.820916439136652, 0.876678766536158, 0.8680877941814081, 0.9785547385643456, 0.8298854294300123, 0.25225841357725276, 0.21624957974837333, 0.24208271908033607, 0.2392148984260435, 0.21162741561146825, 0.22745580746046923, 0.2390090185184427, 0.20822362710329578, 0.24851603115483356, 0.3587325748855986, 0.5901112711905075, 0.28069597316509876, 0.29775640907766054, 0.5981040295778047, 0.6059451616809963, 0.5368074198720119, 0.40254261271696223, 0.5363853403093817, 0.15805298781487032, 0.12048540347883663, 0.13514017511271592, 0.14168333434009506, 0.16770239821157484, 0.13064383087003806, 0.15824722315594975, 0.1483532095811484, 0.17921674577196522, 0.11238003458407586, 0.13457835993070255, 0.15065362973754415, 0.1307930067891202, 0.13850201198067447, 0.1317143020323046, 0.13509970020388085, 0.13228828641542822, 0.1467848126079494, 0.0524400068128158, 0.0611656378605927, 0.07871387346913794, 0.04536679811523392, 0.05879895864657814, 0.07212865260389167, 0.04112280328832019, 0.09359345662274932, 0.058353481867135404, 0.19816852346879765, 0.20020697097883566, 0.21254221291488218, 0.17328130562571897, 0.14905407540335058, 0.15434256005511693, 0.19359634461497466, 0.18159632664931769, 0.1952550132816563, 9.999999999998899e-05, 0.009260639078963129, 9.999999999998899e-05, 0.043802634282559816, 0.005351919027934637, 0.0004925320731757887, 0.012186807579244285, 0.03490003588471169, 0.022871823876546515, 0.09380259087206722, 0.12337855483695204, 0.11772890026513905, 0.123444295456554, 0.1357904523792699, 0.12591139805244478, 0.10569623240068671, 0.12389129999136916, 0.1104088551026241, 0.45792520880774557, 0.4398633742845577, 0.44266605964218875, 0.4444046967473917, 0.45412016566003566, 0.44973574352603174, 0.4479008859360649, 0.43003440006272353, 0.47016384540181766, 0.09151874642257829, 0.0996113406855218, 0.08953688708703611, 0.10079494456883986, 0.0923465696611353, 0.09269749950665551, 0.08528026239567066, 0.11062125473813322, 0.09546634541870913, 0.13298559332507198, 0.1465637576060217, 0.1598762825496629, 0.18202879839438868, 0.16403779518508332, 0.15317044347863606, 0.13266617673680647, 0.13008592908289485, 0.12848050662044064, 0.26077358510101134, 0.274053442526906, 0.2942551373941835, 0.3002009312815639, 0.2659058102556684, 0.28429052241845343, 0.28975810084208875, 0.2999734505903727, 0.3021124216063622, 0.1964816061770307, 0.20122067821606748, 0.2012388213866413, 0.1987079079794939, 0.19262698003000778, 0.1929740146726584, 0.2051669908561493, 0.23065373866235217, 0.21106697954941323, 0.17597053486775982, 0.1911461494854365, 0.1818232639221119, 0.20507382022988307, 0.19317193642587005, 0.18003680341655237, 0.18511762300606183, 0.20531143789480655, 0.1842195944618824, 0.1892450661272329, 0.16971899163787152, 0.19634294751555603, 0.1752212292525126, 0.1799896021589622, 0.18629061439346395, 0.1799921807765542, 0.1725401534597093, 0.17854599065629684, 0.15668808200007422, 0.17275803728611372, 0.2136004827484962, 0.475772370688039, 0.18187783690026704, 0.3215979393670675, 0.15877403125440492, 0.17013746748100855, 0.3277371181646149, 0.46748690126402026, 0.20189703152980487, 0.19707999836086532, 0.40696651481677926, 0.16021093562216338, 0.15321135833734512, 0.19764076615111636, 0.22336564832482064, 0.19966850189983132, 0.18536799214443245, 0.17582398464713245, 0.19676293051547933, 0.19397081896157942, 0.17845455602524818, 0.1727877356391322, 0.1962690002352716, 0.20146507697510285, 0.18711643693977753, 0.07688199093092807, 0.07608950991071872, 0.09595540822300519, 0.06790839958503825, 0.07496310761573366, 0.07768919850568712, 0.08048466736666193, 0.07168231097620648, 0.07677856719577392]}, "mutation_prompt": null}
{"id": "a48ecbbc-e9aa-4a11-a6e2-9afe1542ca95", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "ff06688d-cb51-4215-bf10-9a8c8f1cc2de", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "00b6033f-6151-43b7-8b5b-e694b338ad9a", "solution": "import numpy as np\n\nclass DynamicAdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (3 * dim))\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self, diversity):\n        return 0.2 + 0.6 * np.exp(-diversity)\n\n    def calculate_diversity(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def adaptive_differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            diversity = self.calculate_diversity()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor(diversity)\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def adaptive_stochastic_hill_climbing(self, func):\n        step_size = 0.1\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n                    step_size *= 1.05\n                else:\n                    step_size *= 0.95\n\n    def __call__(self, func):\n        self.adaptive_differential_evolution(func)\n        self.adaptive_stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicAdaptiveMultistageOptimizer", "description": "The Dynamic Adaptive Multistage Optimizer (DAMO) intelligently adjusts search parameters in differential evolution and hill climbing stages, guided by fitness feedback and diversity, to enhance convergence speed and precision.", "configspace": "", "generation": 54, "fitness": 0.21856197784621442, "feedback": "The algorithm DynamicAdaptiveMultistageOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.4484341242867277, 0.44936855373442575, 0.47172593600557755, 0.45958851959664637, 0.4209419129035531, 0.4296208283589047, 0.4475241572445784, 0.45906777653788244, 0.4681187835685522, 0.20005293955635672, 0.21904030455396506, 0.21428280251697396, 0.16354069797598747, 0.21305211164694282, 0.2557363318708784, 0.2538768894511332, 0.19641186082470474, 0.19336886381135032, 0.11345064950912243, 0.09334422249006635, 0.10122179710831647, 0.1051840167563074, 0.10197051578803606, 0.1103702055350061, 0.09676144495970873, 0.10509554061323378, 0.09523669043352945, 0.10209728642933114, 0.09541410649695803, 0.0858152266575769, 0.0871689156823402, 0.08785037650886696, 0.08891126545798467, 0.09479671337821216, 0.09666906623927629, 0.09155890538337574, 0.8665116678248939, 0.8406134201339244, 0.9003615923954678, 0.7852479113755081, 0.7449427362042162, 0.8361622556727344, 0.8308377865608307, 0.8260835503735329, 0.7880822739092165, 0.23939402725780112, 0.19150725725495665, 0.20356338936567597, 0.20967633184877466, 0.18996018090163125, 0.18078531747091764, 0.21755442776213763, 0.169337195478946, 0.19616348121020677, 0.28150072416081906, 0.3110631581850626, 0.26373364471795846, 0.30533488634240025, 0.3152244558922974, 0.2752439785545354, 0.26016881682540893, 0.2971139977621683, 0.30258265044063715, 0.13973224854714006, 0.14329956751728912, 0.1206615129158658, 0.14125689052734236, 0.1295632721128288, 0.10638650796488203, 0.15663185777894706, 0.12724283249828272, 0.14964499343134885, 0.16116404019175712, 0.12427191328381393, 0.1396164189236273, 0.12830428346990352, 0.14132735133139118, 0.1519076686005485, 0.14509761036506608, 0.11069787292753386, 0.12991743194360117, 0.015571915365127698, 0.09297934371017524, 0.009073178051170916, 0.07327488560076267, 0.0857607853755038, 0.046334085482447884, 0.11952848113579384, 0.10003964406028121, 0.09791810029944137, 0.2124128199247579, 0.19553348290970662, 0.2212758574972956, 0.22943433950322112, 0.20382681202657638, 0.11741648439295715, 0.2334024885239948, 0.22770455622967734, 0.23178638608463098, 0.01993081989098988, 0.002349423371919346, 0.023541210145654468, 0.0529930502769006, 0.03244776058911136, 0.008355472456295643, 0.0017353069491947704, 0.02897819620701192, 0.0202395062636056, 0.09664839410182036, 0.11048826947503132, 0.10834565427754694, 0.10730036761635708, 0.09667470538596445, 0.10554063851195972, 0.10538402475471298, 0.09890813296980339, 0.11799546435940955, 0.38079791117552864, 0.41043873483340154, 0.3838918367026637, 0.39257633533164027, 0.39654047098409606, 0.385709601016067, 0.4052790817701548, 0.3819929245750584, 0.404564130040179, 0.08269421780436237, 0.09206316418623117, 0.09958883294143128, 0.08601871976974673, 0.07722419591197272, 0.0788789127814824, 0.07614935226544717, 0.10306952316037477, 0.0887149491265935, 0.1616380926255817, 0.14911922793782706, 0.1456866029998708, 0.14676963163313028, 0.12720883342237355, 0.13573232026188398, 0.2074755816144097, 0.15265204268940602, 0.14193288400892834, 0.25489220474270036, 0.2557011876566422, 0.27195657741495416, 0.2687670248515367, 0.25687458366044746, 0.26386390832605344, 0.2534017239749229, 0.2746565419602023, 0.2675932385795857, 0.20446785914050114, 0.20284398873114928, 0.20400098934230182, 0.21311895912712198, 0.19958480786546184, 0.19892797948456942, 0.20069870125775235, 0.21929297874713805, 0.22609336653886525, 0.20518991486280713, 0.19602580163253847, 0.20284006264707066, 0.19638863995826428, 0.20133835289872637, 0.22684188644479852, 0.2104920201006134, 0.19036070861737941, 0.19052922412941642, 0.17304692627593743, 0.17647831774110823, 0.21385380299700496, 0.18263452429538696, 0.18446510843152608, 0.18727604379679064, 0.17486898927811412, 0.18058748478439868, 0.1737717772950398, 0.18307358107174032, 0.17810314010609396, 0.5436947786326998, 0.5414859264416937, 0.3390214263457081, 0.5387457720504825, 0.32791645396905544, 0.33514409738627804, 0.33669554563646964, 0.4580694400374925, 0.38714392634157124, 0.19214989774717361, 0.16264554058022418, 0.1964041523808161, 0.1642237022653884, 0.29821243581293944, 0.19745477365805308, 0.4813517973044221, 0.1882188520078234, 0.16911545548237805, 0.17419687473116197, 0.18539280487274823, 0.17443796761632524, 0.17637179304184758, 0.17003914819967192, 0.17819436994061488, 0.19300577946325959, 0.08746113490598673, 0.07239360946355633, 0.07100811837043708, 0.07831798815773505, 0.07529589563232386, 0.0774105515633271, 0.08155830555628385, 0.07951960884288745, 0.07450247614394334]}, "mutation_prompt": null}
{"id": "63796df2-9c45-4fc0-9e39-9a0777009cee", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "97db143c-5517-4cfc-9fd9-4b3ea3f6dd57", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "c643275b-a290-43ee-8341-5c09da04b47b", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "c32bf19b-3990-4160-98f1-3fc60667ecec", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "62a3db1a-ad60-4e70-9ae8-e1e8f3bbc8cd", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "32d6dad9-643f-483e-bca7-c3804d73ea87", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "5124e39f-6503-4232-b743-bb243a333006", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "a31d98cc-de2f-4d21-a683-062d2fd9408e", "solution": "import numpy as np\n\nclass QuantumInspiredMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.2 + 0.6 * np.random.rand()\n\n    def quantum_superposition(self):\n        return np.random.choice([-1, 1], size=self.dim)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def quantum_hill_climbing(self, func):\n        step_size = 0.03\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = self.quantum_superposition()\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.quantum_hill_climbing(func)\n        return self.best_solution", "name": "QuantumInspiredMultistageOptimizer", "description": "Quantum-Inspired Multistage Optimizer (QIMO) integrates quantum-inspired superposition states with adaptive mutation and crossover strategies for enhanced global exploration and local exploitation.", "configspace": "", "generation": 62, "fitness": 0.23522759671003093, "feedback": "The algorithm QuantumInspiredMultistageOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.6069002487361228, 0.6738775740784906, 0.6410319838747147, 0.6116171172117748, 0.6429683774540444, 0.6296744100842304, 0.6485687409119638, 0.6328427115832793, 0.6178083169627857, 0.3647872814000399, 0.37918804235645776, 0.36614954516005915, 0.3591584781936905, 0.31603953603347956, 0.34128102091616097, 0.3193379505199938, 0.31638373282346377, 0.3484094718628259, 0.10521596110534104, 0.11212605013220323, 0.09958964569811646, 0.1043508152027538, 0.0933679535169486, 0.09967660278626722, 0.09676583132654704, 0.0999523808330639, 0.10386934401535708, 0.08883314839597645, 0.08727535495178496, 0.10341288876180665, 0.09341842493115271, 0.0986704825030843, 0.09894951112894046, 0.09438272461986108, 0.09660839608175198, 0.09452029765957337, 0.8854068946399067, 0.9296464411396232, 0.830466927503629, 0.8253147053103443, 0.8266283315220528, 0.89478478906237, 0.8179092808333325, 0.9707620669419199, 0.8013826304551577, 0.2487913666622581, 0.2529476973308262, 0.19914846585624335, 0.2437779304822899, 0.2294325304054814, 0.2493477267013855, 0.230791649870273, 0.25878466421903945, 0.23054899372125393, 0.38388039854919176, 0.4734930274730187, 0.30323326178336196, 0.41292337772001253, 0.4392549307906449, 0.42778284807942846, 0.4803632680049944, 0.4426528579030672, 0.45729333943045636, 0.1659421673470537, 0.13678472076514903, 0.14444304541239905, 0.12876959444447744, 0.14801313522754012, 0.20309786879515135, 0.12536872327545712, 0.15063650969041587, 0.1341422807220286, 0.14668828948447554, 0.14581600419745755, 0.15737466017545065, 0.15253609395396028, 0.16469881639705908, 0.12457014079940254, 0.16600922072981228, 0.11774008719918205, 0.12848198396718558, 0.09396079691526216, 0.03725330847314179, 0.05641827654671283, 0.041544901943264656, 0.0335648393388861, 0.03267374679180124, 0.05708402932420853, 0.06084172290017653, 0.03157354313984251, 0.15192341447563884, 0.13458248575276432, 0.19037504884706102, 0.15693279182067876, 0.14254235807384918, 0.1629019217250054, 0.20229561432647147, 0.17074512584841872, 0.16392009344251346, 0.010916052351982009, 0.01118807075082584, 0.004683293868554372, 0.02083202865981415, 0.03838180145169068, 0.03153334779293204, 0.019909597027148784, 0.046826301306854834, 0.021646280138245544, 0.1472664218757691, 0.0947592736077979, 0.11914596685731738, 0.16190355875196405, 0.13181540469772168, 0.13761664144088626, 0.11150167389209076, 0.14515411815423251, 0.12018670774657636, 0.4579069217805194, 0.4373750368216316, 0.46135941864339847, 0.4689657439844943, 0.44772051873370433, 0.44141680695656327, 0.4841129485361244, 0.42369661905593003, 0.4366084044409443, 0.07888083567405069, 0.08609692913343936, 0.08924685363794693, 0.11033587215128227, 0.08974827258559381, 0.09094283695697958, 0.07681985332539532, 0.09095609450751962, 0.07825636422386384, 0.12181332407226642, 0.13387551413229848, 0.13704843093758934, 0.13119708918925777, 0.12461347151816393, 0.14300542088212065, 0.14934851570737917, 0.15313222836876683, 0.12350847805701137, 0.2837481155233472, 0.2920052182786399, 0.29482574844012754, 0.28751650380839555, 0.29940769888574303, 0.2571052924522026, 0.30882847550267445, 0.3127071798456814, 0.28892493574313194, 0.20651366620861544, 0.1867344421862307, 0.20745343158601226, 0.20534841065238307, 0.2020877081697514, 0.18949217438890542, 0.2035939826272103, 0.21964077421706163, 0.2198725020869381, 0.19494179447220827, 0.1796847776363658, 0.1818343869124076, 0.1789789242230292, 0.19708342727908068, 0.18344633629805485, 0.19949768965729597, 0.2006206566677502, 0.19253735356942325, 0.18360130991748136, 0.1840720605160151, 0.18218114599645574, 0.17937315381295338, 0.1778537421938139, 0.17595870292889726, 0.17715542534543316, 0.18152010991582046, 0.1840806953290982, 0.17493047998899203, 0.49883282366003645, 0.35299087473762325, 0.25626872245351606, 0.16548536222729526, 0.1657700494358436, 0.21421236485179485, 0.16485079849755202, 0.3986848069429575, 0.1564982485341212, 0.20178709325874156, 0.1581590729225587, 0.15503346846812893, 0.19603965439224935, 0.15536498500773688, 0.5149449630464951, 0.31371488693382066, 0.1433470052092629, 0.18195488335467758, 0.18578690655822383, 0.17872249015681718, 0.18651571418703283, 0.182915552371412, 0.1721816783474195, 0.18259783255083095, 0.19399740466415283, 0.18306426924614183, 0.07194312850100815, 0.0674141584418465, 0.07314922237020038, 0.06442241473510146, 0.07110841664986578, 0.07249114233525766, 0.07327080184092882, 0.07400286287506863, 0.06721493347566687]}, "mutation_prompt": null}
{"id": "daa44b88-41ce-4c51-b48d-53ec6b539088", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "832c32ba-8d9a-4303-9063-9e71ee4acbbc", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "575c70b2-1f23-4b37-9218-0e022e6856e9", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (2 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.35 + 0.45 * np.random.rand()\n\n    def quantum_superposition(self):\n        alpha, beta = 0.5, 0.5\n        superposition = alpha * np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim)) + beta * self.population\n        return np.clip(superposition, self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.1\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            superposed_population = self.quantum_superposition()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = superposed_population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(superposed_population[i]):\n                    superposed_population[i] = candidate\n            self.population = superposed_population\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "QuantumInspiredAdaptiveOptimizer", "description": "Quantum-Inspired Adaptive Optimizer (QIAO) leverages quantum-inspired superposition for parallel solution exploration, dynamically tuning search parameters to enhance convergence.", "configspace": "", "generation": 65, "fitness": 0.19375818425223734, "feedback": "The algorithm QuantumInspiredAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.4644937652820814, 0.4668722284808309, 0.44678936107791856, 0.47526814086159275, 0.48121853821683247, 0.49567878848850244, 0.4877338019869305, 0.4607212466698336, 0.4644650766923343, 0.1560045175998117, 0.20973211987086982, 0.1794099906655212, 0.16806712103858845, 0.1876601555241333, 0.2087818396286235, 0.18544840444944433, 0.20406292261119185, 0.19691728366747407, 0.09123376872813882, 0.10024588895516595, 0.08486443922236508, 0.09399821487014592, 0.08821397898205319, 0.08140319081379499, 0.0942458258273855, 0.10506371014296056, 0.09278741351104436, 0.06961260396227642, 0.08491940502445072, 0.08532453610080304, 0.07844739972731352, 0.08354626263313092, 0.07599896073967649, 0.06560327521455134, 0.08988367667928521, 0.09115437533049475, 0.8894116352489502, 0.7889212873951841, 0.8301668279519292, 0.8993223048342055, 0.9365543940841379, 0.8769900172100067, 0.8647547961223105, 0.8219861353620969, 0.8264850746039568, 0.1594623743253618, 0.17648439438231656, 0.13702650360767588, 0.17528827903264588, 0.17715089487849456, 0.18149401532724185, 0.18000427620165194, 0.157551248615174, 0.19773290270775046, 0.2477794016606465, 0.23884180685332934, 0.2883342165197488, 0.27642679838067274, 0.2864014746852207, 0.2429633671296264, 0.2689224596390769, 0.2605373923424513, 0.2685275375082644, 0.13141169672142983, 0.11689973829952394, 0.14140890640293524, 0.1084390114445245, 0.12159093134237486, 0.11912020859227324, 0.15884174221058966, 0.12025768471866705, 0.1389196443953048, 0.10169189960494918, 0.104276879155496, 0.11969680016200457, 0.12413417431015061, 0.1134339357865507, 0.14323525244115076, 0.10746177727485773, 0.1255839856619697, 0.1257905878847212, 0.0031204586911204313, 0.033861929278304004, 0.05309341287601399, 0.02676644460630684, 0.008054647050883434, 0.01963330062024693, 0.01824438711219989, 0.0064789730450786065, 0.015588931095289027, 0.14348037211476328, 0.12986229268801963, 0.13206943725194775, 0.1126323741870685, 0.0978918286253534, 0.1309166305412387, 0.14925090658030749, 0.1774370305682409, 0.1599528308002014, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0779557245975302, 0.09304438397242809, 0.0711829084293848, 0.09025107977767222, 0.09255969849889822, 0.10240206592989909, 0.09523634865427144, 0.08627936790086166, 0.09145389750930644, 0.36718619059096314, 0.3810795219835692, 0.4237563935718316, 0.3565302639477309, 0.3756937775638636, 0.4118437697166939, 0.3992698641551148, 0.390513958959816, 0.37745685310501076, 0.0810686393178619, 0.08147374182788558, 0.07925621524396542, 0.07838888706827296, 0.06339293939621171, 0.08646061553277995, 0.07069429297851093, 0.07264905204433125, 0.07562212475524499, 0.12616657352214877, 0.1493711164188617, 0.15119832145252532, 0.137466371910538, 0.1410248221308671, 0.127664978773387, 0.12592575865104771, 0.13107978049942426, 0.14005060688922988, 0.250070575997687, 0.24019382393875588, 0.24878504456070072, 0.24788298127445396, 0.26421411522520855, 0.23107932674543086, 0.2525207220856762, 0.2818718786306206, 0.23765511117602045, 0.17437382293462755, 0.17335017559783938, 0.1634088018536013, 0.19438335173151067, 0.17701506309289394, 0.1744621539057264, 0.18117702342682707, 0.19469521371841125, 0.18992209149574202, 0.1726976921101716, 0.17580447355883955, 0.18830092662225306, 0.18062330642380675, 0.17331416266809951, 0.20742164461008838, 0.1724397660748911, 0.17406210148385648, 0.16937984599966516, 0.1709196649273661, 0.16443520884191054, 0.172387733246389, 0.16433588242983477, 0.16165194575347086, 0.17569006265066167, 0.16814299427723434, 0.17361579256112236, 0.18290446721416043, 0.2174765716062682, 0.3632698615632085, 0.2241052336807533, 0.1636985112911976, 0.18954219759666158, 0.25666074560649854, 0.15196031318289382, 0.16237156542375486, 0.1599437192724512, 0.29510321910205906, 0.18861940614734496, 0.16481769023865822, 0.16071080615473088, 0.15254406788805686, 0.14994375820593742, 0.19370821753225087, 0.19040564907723712, 0.19634474220212406, 0.16725399244000783, 0.16952749324125926, 0.18697450801420923, 0.1777597657015112, 0.1819362456638015, 0.1938259889807168, 0.17600687193618048, 0.18922190990194554, 0.18463935518007146, 0.06553946634715102, 0.06858105933748082, 0.06837905402594024, 0.06353801911106405, 0.07577427127944758, 0.07142669045685346, 0.06160619883439977, 0.082593922922783, 0.06529176318313057]}, "mutation_prompt": null}
{"id": "f25dea06-eff8-4e73-9979-8d64c8f489a6", "solution": "import numpy as np\n\nclass SynergisticAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (3 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def annealed_mutation_factor(self):\n        return 0.4 + 0.3 * np.random.rand() * (1 - self.evaluations / self.budget)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.annealed_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def adaptive_hill_climbing(self, func):\n        step_size = 0.1 * (1 - self.evaluations / self.budget)\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.adaptive_hill_climbing(func)\n        return self.best_solution", "name": "SynergisticAdaptiveOptimizer", "description": "Synergistic Adaptive Optimizer (SAO) leverages a dynamic balance of differential evolution and adaptive hill climbing with annealed mutation to efficiently explore and exploit diverse solution landscapes.", "configspace": "", "generation": 66, "fitness": 0.20740822723373165, "feedback": "The algorithm SynergisticAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.4664310961542586, 0.5094266572058033, 0.4725749863304196, 0.5007156204864351, 0.5082732144709875, 0.5289958657279226, 0.5012966315919725, 0.46776380276709895, 0.5064065599026553, 0.2104320794415997, 0.2173307072162851, 0.21566151719982474, 0.19499440033315085, 0.20314873305878278, 0.20971701375263818, 0.22180825345540156, 0.21992326997267253, 0.22815880632146146, 0.11114488583779314, 0.1032531891211631, 0.09548231380711403, 0.10055994318142925, 0.10007855957015799, 0.09004192310235593, 0.10874569067912054, 0.0964362318918971, 0.1054056185261667, 0.08453910902452078, 0.09438020685048853, 0.0844597663506984, 0.08409279426331473, 0.09689510635148868, 0.07962596196475857, 0.09064863127985723, 0.0821314851708741, 0.08283525985654339, 0.8680629118231286, 0.7129713909960222, 0.8080539831879016, 0.911057880280925, 0.9100104145597447, 0.9179485555224033, 0.7331847027942915, 0.8168035134194527, 0.8346795215425916, 0.18770080585126347, 0.20191912339631068, 0.18357749931264566, 0.23155205403966506, 0.20608074338420834, 0.21923281171832132, 0.21025742665854175, 0.21621375801447396, 0.21560331810839695, 0.27813018409672907, 0.2624889338274956, 0.2731844722033514, 0.5171814833621111, 0.3895918104413787, 0.2780647810206821, 0.29488465203921554, 0.2986614527924557, 0.44106280790373, 0.14288952067561345, 0.0998496937436475, 0.15363474738884486, 0.12591098148936275, 0.13850073860869838, 0.1414447835966548, 0.14114043337471727, 0.13436366369266273, 0.16181189701841703, 0.08154466009162042, 0.12175476439359278, 0.15214418181337364, 0.11628560051974768, 0.11788076121561686, 0.13803854248432346, 0.1376051879120177, 0.14026317173640002, 0.14086671840313847, 0.06399210709043424, 0.043635227358726825, 0.02691589330191213, 0.044156510927335746, 0.04553241417895404, 0.024689520863330094, 0.04013262730374667, 0.06603066920719702, 0.03816458899451136, 0.18657376885659038, 0.13545272648850026, 0.12274810448800066, 0.1427832564544126, 0.15480757244774013, 0.15161723502501334, 0.2274440712357575, 0.18404790444111974, 0.16627770636887818, 0.0018860149623660671, 0.006809971200771758, 9.999999999998899e-05, 9.999999999998899e-05, 0.00017243065197236618, 0.0005107624175294534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0861512264898805, 0.10811366545273815, 0.0963812024599654, 0.1060923046954736, 0.10064050248618928, 0.13087351392357105, 0.09657654172622698, 0.09822476417652792, 0.10807860459527496, 0.40512615925838513, 0.4014743175704326, 0.40314820453868105, 0.4071715687464291, 0.3843723986902676, 0.3971367201676972, 0.40115478115830416, 0.3995988424713619, 0.4217562875218942, 0.10595814133970871, 0.09777867977027077, 0.09193745159151168, 0.08545209290166389, 0.08523926391029157, 0.09137213686887702, 0.08446511958849823, 0.10536700586261216, 0.09506884413863426, 0.1427476476045525, 0.15236951088503503, 0.14149350038659048, 0.14902285031138696, 0.1329855179102205, 0.1349479063871566, 0.14803700974032685, 0.1464123790028008, 0.13624814295274335, 0.262489932623564, 0.25324317642655025, 0.2637988681641825, 0.24012157203732953, 0.23916473588766107, 0.25298354576674453, 0.2458943973325246, 0.2715438725134891, 0.26956446403502354, 0.18858661969929758, 0.19237447706519084, 0.19382017376605742, 0.16210790388307283, 0.17925120218124868, 0.19677745872857055, 0.18376526772845214, 0.2218040904145886, 0.21436371988598268, 0.20049528654258197, 0.17272972957988508, 0.18535901618297224, 0.18472113095108145, 0.17704630394409526, 0.19218646840661435, 0.19335098957554375, 0.17706952629371864, 0.1862904128747931, 0.19040822220774611, 0.1704393836980076, 0.17847007274884363, 0.1753269184777715, 0.18394160560850803, 0.17578377064219552, 0.17217323071285262, 0.18299387402636258, 0.21477002953341318, 0.30923867489401125, 0.5018952148264331, 0.19692409024668156, 0.21346164069229634, 0.1687302320920404, 0.18129729870476796, 0.15913264876291489, 0.1725551875772231, 0.22617657403751834, 0.1898486836683011, 0.17426096295067606, 0.19010805392431207, 0.1534036914841601, 0.15009738335701894, 0.18890598455926744, 0.20118690405924589, 0.1977185527142329, 0.1935118827230533, 0.1831768150929719, 0.18520828571925618, 0.1709305550190231, 0.17304267323148448, 0.1630088276032997, 0.18349209131070188, 0.19234620094143862, 0.170730191300407, 0.1853524840664782, 0.07657675437597933, 0.07557375782014275, 0.0698877967377104, 0.07023215923968018, 0.06969407569618002, 0.07270308987085505, 0.06768750021182346, 0.07364928997959996, 0.07145659862635623]}, "mutation_prompt": null}
{"id": "481a5d19-b841-464f-872a-66ab2974c31a", "solution": "import numpy as np\n\nclass QuantumInspiredMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n        self.quantum_probability = 0.3\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def quantum_superposition(self):\n        return np.random.choice([-1, 1], self.dim)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def quantum_annealing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = self.quantum_superposition()\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.quantum_annealing(func)\n        return self.best_solution", "name": "QuantumInspiredMultistageOptimizer", "description": "Quantum-Inspired Multistage Optimizer (QIMO) leverages quantum-inspired superposition and entanglement mechanisms to enhance exploration and exploitation in optimizing diverse functions.", "configspace": "", "generation": 67, "fitness": 0.24841241588269725, "feedback": "The algorithm QuantumInspiredMultistageOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "210589ed-a64a-4497-8df1-f10b8570756d", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "e38b959f-2a7d-4fde-bfa5-1ecfd8fed015", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "4f21837f-9318-4bb5-8717-cbc374b04dc8", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "23ea41b6-ee43-4c7c-89ae-dba8f27ad047", "solution": "import numpy as np\n\nclass HybridEvaluationEfficientOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor_range = (0.4, 0.9)\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n        self.learning_rate = 0.1\n\n    def adaptive_mutation_factor(self):\n        return self.mutation_factor_range[0] + (self.mutation_factor_range[1] - self.mutation_factor_range[0]) * np.random.rand()\n\n    def enhanced_differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                    self.learning_rate = max(0.01, self.learning_rate * 0.95)\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def adaptive_hill_climbing(self, func):\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + self.learning_rate * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                    self.learning_rate = max(0.01, self.learning_rate * 0.95)\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.enhanced_differential_evolution(func)\n        self.adaptive_hill_climbing(func)\n        return self.best_solution", "name": "HybridEvaluationEfficientOptimizer", "description": "Hybrid Evaluation-Efficient Optimizer (HEEO) balances exploration and exploitation by adapting differential mutation, incorporating adaptive learning rates, and using a diversity-aware selection mechanism.", "configspace": "", "generation": 71, "fitness": 0.19773454903677315, "feedback": "The algorithm HybridEvaluationEfficientOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.4997004190110731, 0.46301816954255415, 0.4787228173082715, 0.48327115602232507, 0.48419808329563785, 0.48769899913273695, 0.4762167677391608, 0.4712091810706621, 0.4852089500685657, 0.18680074790459544, 0.2081563277772378, 0.17559292411264904, 0.19789703200624975, 0.1956532958472007, 0.17933777088345249, 0.18692566558423718, 0.20884941604453366, 0.20343625685717692, 0.11444052536137772, 0.12005248718457895, 0.10970627544457967, 0.12719493136879123, 0.10957847992916736, 0.0997968608580364, 0.1026113952110832, 0.09582873159818395, 0.10334408269447881, 0.08056438399445542, 0.0912162810408248, 0.09229651968327413, 0.09147343659562068, 0.0866456510761483, 0.0896846707530744, 0.09387154216317062, 0.08696198849992653, 0.09732586574351632, 0.9176871841017679, 0.922916623820107, 0.8386921247314788, 0.8785604448755626, 0.902065253298497, 0.920309271150717, 0.9508374982140789, 0.8449924881106883, 0.8605857016015532, 0.1857875435988613, 0.20134132491302237, 0.15914837084434563, 0.19089917258960765, 0.1863529989581858, 0.18343967622756796, 0.19107184213380835, 0.1840883497701965, 0.22138040741601284, 0.22807553106244727, 0.2633724478913497, 0.20986094283739398, 0.2537516022528139, 0.2318167713833681, 0.22831358811591695, 0.2449593356181301, 0.26934308687601516, 0.25153044569820693, 0.1313460357935644, 0.1107953127215966, 0.11727499008202591, 0.12238742513173007, 0.15769138040369413, 0.11351693633903381, 0.11126871184515386, 0.12724872743225313, 0.12981099713218447, 0.11364257323584848, 0.10544394858387818, 0.09795736286740264, 0.11748599593552411, 0.14927299404891348, 0.12267753684852523, 0.11787849445134602, 0.11999544381385241, 0.10979332890392235, 0.029720377255626595, 0.003962707095826357, 0.013303506663616238, 0.021669945222557496, 0.0028361836384978023, 0.01359364864763668, 0.030392825637627352, 0.0210956807069812, 0.02357203497553617, 0.1285311165067634, 0.07839891063557658, 0.08387746798437423, 0.08909048423257282, 0.10738185818235002, 0.08391173821567843, 0.15062450089280988, 0.12465279814635555, 0.1282140061833701, 0.0035156151929768287, 0.026888041466869628, 0.008042492628517861, 0.0034060695106340466, 0.012152118104895582, 0.0044339986573435075, 0.023193571043055417, 9.999999999998899e-05, 0.01224381810947106, 0.08606407027833607, 0.0855096500055812, 0.09146288665411861, 0.09212070783557225, 0.0763830469505894, 0.10106506791421321, 0.10503151842014413, 0.08409134552930642, 0.09332515095055183, 0.41664454930625483, 0.3795849381477596, 0.3780812900873207, 0.40840382118629426, 0.40394108598112566, 0.39747213253555425, 0.3957367961177398, 0.36883759276310035, 0.40638470719557207, 0.08730848762857746, 0.09175426537765596, 0.1041345687422861, 0.08324458686273739, 0.08449973393572252, 0.08501886647539902, 0.0884897962917428, 0.0819548244599766, 0.08813500681116826, 0.20581416707930278, 0.14434884611731946, 0.14049471126302582, 0.14061576136464504, 0.1879422562926717, 0.1447546429308113, 0.1425879167130073, 0.18015048061021066, 0.17634093116713123, 0.2314995878109266, 0.2566565731696743, 0.2551357390805006, 0.2366045592022048, 0.216479267799228, 0.23923930888896594, 0.26322773067385663, 0.2833542308379795, 0.270506645093605, 0.17811042288617862, 0.17135530047069658, 0.17955502893018582, 0.1749801541993815, 0.1704112752991307, 0.16477652720655056, 0.15770617109541596, 0.20412907168303984, 0.193094244631001, 0.19223165269099163, 0.1758602322469316, 0.19143801981123687, 0.18133622470298538, 0.18012079456675778, 0.19058070958821594, 0.18030044232361575, 0.2258233053368437, 0.19291127511091477, 0.18425615120719474, 0.1928064640623064, 0.18598424885909093, 0.19398999957664842, 0.19849154048809337, 0.17803194293698799, 0.1853519272636499, 0.16816493746692684, 0.1761412001281587, 0.2799977301418214, 0.2013871466360042, 0.1490748654427414, 0.1528263491909011, 0.16277597655295173, 0.24987113377475145, 0.14191757346687717, 0.25326959194566256, 0.13965899297510675, 0.17949053567669448, 0.189622848924206, 0.23416206076745738, 0.14139028011404697, 0.18926513441442416, 0.1465785613827686, 0.21544654024475118, 0.1876287469691984, 0.23225973120576848, 0.17442425506089188, 0.17232382484647746, 0.20174489558205, 0.178196645643668, 0.17370774928418808, 0.17346349535146932, 0.17656446304649343, 0.16080286058759352, 0.17130950020547153, 0.0795009719212243, 0.06993461032472748, 0.07175709045161127, 0.08050473996095864, 0.07078667230127811, 0.06496578628301652, 0.06672339500019953, 0.07064487233490058, 0.06834802001376883]}, "mutation_prompt": null}
{"id": "f57b28d4-1bad-44d1-a874-74e081eec71b", "solution": "import numpy as np\n\nclass EvolutionaryAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def adaptive_mutation_factor(self):\n        return 0.2 + 0.6 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def adaptive_hill_climbing(self, func):\n        step_size = 0.1\n        for _ in range(self.population_size // 2):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.adaptive_hill_climbing(func)\n        return self.best_solution", "name": "EvolutionaryAdaptiveHybridOptimizer", "description": "The Evolutionary Adaptive Hybrid Optimizer (EAHO) leverages adaptive mutation, crossover, and local search strategies with dynamic parameter adjustments to balance exploration and exploitation across diverse problem landscapes.", "configspace": "", "generation": 72, "fitness": 0.22346963089071797, "feedback": "The algorithm EvolutionaryAdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5547890941873577, 0.6358983964022735, 0.6224607094045108, 0.5784997802539331, 0.59433366413103, 0.595795460338868, 0.6131524503440409, 0.5856374650018525, 0.5603378624719968, 0.29417284843990854, 0.32751895900334116, 0.302625759406872, 0.2827906288138369, 0.2655039932331723, 0.27961878208118385, 0.24326418549395612, 0.25188529785954883, 0.28860792304120886, 0.10946823398821248, 0.11076644923121748, 0.10592994652035781, 0.10623929180323266, 0.09627347505346695, 0.10643214096039588, 0.10568788202681811, 0.10574519533026017, 0.11710442567314672, 0.08735702782611476, 0.08576010967881198, 0.10529180208900835, 0.09687746542938058, 0.10338125686591759, 0.09947321173277801, 0.09895177036397729, 0.09907421719606535, 0.09860683457757147, 0.8854068946399067, 0.9296464411396232, 0.830466927503629, 0.8253147053103443, 0.8266283315220528, 0.89478478906237, 0.8179092808333325, 0.9707620669419199, 0.8013826304551577, 0.22250788275872824, 0.24402291974296297, 0.19755983547035605, 0.24003806199886168, 0.21581672406821195, 0.23952758074582403, 0.21219299096695687, 0.238622668823676, 0.24411647824449179, 0.2814908760023489, 0.4545614378966707, 0.44407639462864723, 0.30124936035045335, 0.49809561921008483, 0.4406520173909888, 0.3119732852298098, 0.2735401684461839, 0.29384868949677756, 0.15825673312502908, 0.13303293556255735, 0.1377187932736884, 0.1241435849016953, 0.14408590112898978, 0.1785814128340999, 0.12192446770617149, 0.1470921573067091, 0.12929473336359965, 0.13952543598960732, 0.1393736776610347, 0.14998545492907212, 0.1480003531725822, 0.15587084302759335, 0.11844576275279994, 0.16120921942532673, 0.11270779407046883, 0.12306050243057065, 0.052769265311305436, 0.006695801628504472, 0.02375131143119691, 0.030035502247489188, 0.033561526226452365, 0.013689679356848283, 0.0357048708714669, 0.038293114702625086, 0.010989554101594301, 0.13846741469279766, 0.1333340729030964, 0.1676327169677938, 0.143290202203323, 0.12243993118202667, 0.14838735036442607, 0.164932515487905, 0.16068130947971626, 0.15109904009651742, 0.0, 0.0009463687903343843, 0.0, 0.007500832216008502, 0.0, 0.0, 0.009778910532136975, 0.02284673069635701, 0.0, 0.13288147487971202, 0.08026649778063144, 0.10951204032610318, 0.15474091358997832, 0.11576792633471755, 0.11462407374522299, 0.09636783710265262, 0.1204166343741756, 0.09918434491368444, 0.43038361209834164, 0.41139308297699206, 0.44090422805988594, 0.4415196668097049, 0.43135767963386684, 0.42832621721974384, 0.46100844496149884, 0.40050538692360127, 0.4213208587620816, 0.09909453863469242, 0.09693685060161539, 0.09919960145923212, 0.1126789428747832, 0.10290801870857236, 0.10438410807325094, 0.0924352767285116, 0.09693172943466288, 0.09121707668186518, 0.134637912624736, 0.16295647447035222, 0.15954071674402126, 0.13798402982761349, 0.1485168964937419, 0.1651331520871936, 0.156014248002589, 0.16367406206610935, 0.13834824721994665, 0.2708371268312525, 0.27563218788724675, 0.2790427054379665, 0.2725169998987036, 0.2822079396485171, 0.24847468764273584, 0.2899663730931322, 0.29707811679146556, 0.2678621752312127, 0.2020006308033736, 0.17894722015316944, 0.2090465260918034, 0.1972594341801197, 0.19435694408314808, 0.18267511676456238, 0.1947006064146085, 0.2121920528227239, 0.21190984550723568, 0.1948619890873371, 0.17960505168806506, 0.1777151042353602, 0.17889837938495745, 0.19700440642330996, 0.18912184750418093, 0.19941952752704206, 0.2005436067287838, 0.1982105191246284, 0.18392387720099235, 0.18776024299878324, 0.1874395942047553, 0.1859570701129195, 0.1881565926973766, 0.1830665665306871, 0.1790171938077949, 0.18672399138159612, 0.19095115888998992, 0.1748197359267467, 0.4405400209584488, 0.3354261747664794, 0.23955769535683624, 0.18304795211091418, 0.16969155190036034, 0.19671949343910655, 0.17504693554688255, 0.3521597272157707, 0.15641406365995658, 0.2017064302495568, 0.16011302991190246, 0.15495037841734915, 0.19596087549019048, 0.15528203152661102, 0.456490790802103, 0.2964449746654123, 0.14326112641445743, 0.17642103216274752, 0.18285214134628147, 0.1786414055381852, 0.18643437538523144, 0.18486427312863518, 0.17207604630699913, 0.1825181418478652, 0.19391713687597156, 0.18295099139101856, 0.07165721689199722, 0.06838352801154002, 0.07410970207744705, 0.06510205379669676, 0.07245196913899121, 0.07239920102563124, 0.07317894012918913, 0.07391145974765134, 0.0711346179087744]}, "mutation_prompt": null}
{"id": "362538f5-c5a3-4e82-b89a-f0fdf1b663f2", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "ffe2fc63-7eb3-45e3-9132-44422541e112", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "99100be4-222e-4f38-89a7-274fb15f5d04", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "d65ca23a-8780-464f-b64c-ddea4c842b65", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "b94520ce-804d-402e-8ac7-a0bba1a8e33c", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (2 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.rotation_factor = np.pi / 6\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def quantum_rotation_gate(self, vector):\n        theta = np.random.uniform(-self.rotation_factor, self.rotation_factor, self.dim)\n        rotation_matrix = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\n        return np.dot(rotation_matrix, vector)\n\n    def dynamic_mutation_factor(self):\n        return 0.4 + 0.4 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                mutant_vector = self.quantum_rotation_gate(mutant_vector)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.07\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "QuantumInspiredAdaptiveMultistageOptimizer", "description": "Quantum-inspired Adaptive Multistage Optimizer (QAMO) incorporates a quantum-inspired rotation gate mechanism to enhance exploration and prevent premature convergence by dynamically adjusting parameters and leveraging quantum principles.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (5,) (2,2) (5,) ').", "error": "ValueError('operands could not be broadcast together with shapes (5,) (2,2) (5,) ')", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {}, "mutation_prompt": null}
{"id": "d29e9b2a-dab3-4554-9a96-4db556ebcd8d", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "5b87d39d-9b08-498c-aaf9-685dbb0f6b8f", "solution": "import numpy as np\n\nclass HybridAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (2 * dim))\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n        self.success_rate = 0.2\n\n    def dynamic_mutation_factor(self):\n        return 0.4 + 0.4 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n                    self.success_rate += 0.05\n                else:\n                    self.success_rate -= 0.05\n                self.success_rate = np.clip(self.success_rate, 0.1, 0.9)\n\n    def adaptive_local_search(self, func):\n        step_size = 0.1 * self.success_rate\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.adaptive_local_search(func)\n        return self.best_solution", "name": "HybridAdaptiveOptimizer", "description": "The Hybrid Adaptive Optimization (HAO) algorithm synergizes differential evolution and adaptive local search by dynamically tuning parameters and using success-history-based adaptation to balance exploration and exploitation.", "configspace": "", "generation": 79, "fitness": 0.1948545590298801, "feedback": "The algorithm HybridAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.4594718107867968, 0.42175147377565503, 0.44223669594256987, 0.4708839799775637, 0.4615899890269719, 0.49090203986244074, 0.4548873644978224, 0.48536541258323196, 0.47997159641129494, 0.13917308029149666, 0.15704876704009163, 0.142031670864053, 0.15123920404103608, 0.15564107053316378, 0.1579465494186576, 0.14643586593973645, 0.1593868823473389, 0.1847119302542335, 0.10115522227163332, 0.08818736653257842, 0.11215980921565427, 0.08784107003158548, 0.10446334317317796, 0.08014800337467187, 0.07765784074843762, 0.09526077561933122, 0.09081993037118807, 0.08221662608685654, 0.09242705014238295, 0.07979256908083043, 0.07941974706844634, 0.07668933851372728, 0.07177812127943617, 0.07995166318053104, 0.0841694452788222, 0.08497900099435651, 0.8655996315862209, 0.8210476472992069, 0.8132136699465922, 0.9119491960819561, 0.9366915499950093, 0.9189406119699142, 0.8490867173908714, 0.8279862136698128, 0.8654090601574883, 0.15843119606489764, 0.17485640199330887, 0.13815714184186056, 0.16165542480005057, 0.16601025802962377, 0.21952952081645194, 0.198868226342778, 0.18697012283013992, 0.17299879898250148, 0.2594518414932593, 0.2547548184556896, 0.2553286178758264, 0.25570248425847875, 0.3319702595651248, 0.25884854846219263, 0.24998436818867187, 0.23815462120472597, 0.253308278450568, 0.1135329390299945, 0.10882363221163904, 0.13566978088215131, 0.11962162423412903, 0.12335733943309224, 0.11011534637366349, 0.13757244074761243, 0.11003566333088732, 0.1239779419749577, 0.14131208146579843, 0.10245378424198204, 0.12196130794593352, 0.10854123626767764, 0.12399845061198289, 0.11472264399465126, 0.11185093658996281, 0.12653659659031213, 0.11799079708673232, 0.02813922906100197, 0.05495139689358641, 0.023325332208104177, 0.02167249477424138, 0.03659560212388091, 0.028872134362498914, 0.04077478371807863, 0.01772015335968735, 0.03497808551886561, 0.09984023607697035, 0.13514715496686935, 0.13537543282478615, 0.13974699520497125, 0.15495074199359515, 0.12559392974301042, 0.16835759645693726, 0.15607088539016167, 0.19826526366119357, 0.006760420429476444, 0.0033337392786554343, 0.022656181206700654, 0.008749610830793841, 0.0050994153346703985, 0.01350296385928218, 0.014190179994290508, 0.012764864911408269, 0.024972784819440874, 0.09300934820945572, 0.09023719192996482, 0.08405081443220319, 0.08892401421697627, 0.10518007853454914, 0.11931836970689325, 0.09356867558871784, 0.09459397032147443, 0.09967015967983228, 0.36045301568616106, 0.37851455169011905, 0.4051256234224525, 0.40134030331835824, 0.3811072122251967, 0.3808347976114106, 0.3862707261512055, 0.3720418983336464, 0.4372045880968429, 0.08807885340055333, 0.09241368081996171, 0.08740077814698799, 0.0830096033558777, 0.08543738051893668, 0.07360869299238382, 0.08466108268038386, 0.09671631538536918, 0.07839712164907908, 0.15883775177812165, 0.15172874246451573, 0.14796752173077132, 0.14818530767304017, 0.13053118770301475, 0.1651847312224285, 0.14841958003828115, 0.13158626731279632, 0.11035167307699467, 0.22348545218764726, 0.22874960441653436, 0.22975186540650094, 0.24426054075188974, 0.24742183373970728, 0.22477645053927153, 0.24781485193196529, 0.2516744840335845, 0.2661031987230338, 0.16456447843992028, 0.17010536688857902, 0.1717591628186501, 0.1675477441524208, 0.1644502226855613, 0.15483880997087474, 0.17066804341864994, 0.18386608839668273, 0.20001147977316402, 0.20070159489655837, 0.1911385899178476, 0.1947527634027122, 0.18117499905548085, 0.1814370858153722, 0.1872954003408298, 0.1764013996267142, 0.18449835010390125, 0.18252949814472308, 0.16933499036867927, 0.16596236499548722, 0.16642884290793736, 0.16291954732969438, 0.1703044173557462, 0.1598680902164018, 0.16808188008135405, 0.167205063243565, 0.1734287452729506, 0.17863273432007076, 0.32631117153236666, 0.2724134649646601, 0.1505726017213408, 0.16224561642498447, 0.1386232870590831, 0.14922616776580366, 0.16683083311746816, 0.14245294655951368, 0.26735275957156324, 0.18417234081815748, 0.32191687052213425, 0.2052619030198869, 0.21157796599912115, 0.14194719151861102, 0.19630542875181256, 0.1961176849955626, 0.23727634755137683, 0.20816323757770183, 0.18179140842475272, 0.18914366003449423, 0.18375859641280878, 0.19367299558548345, 0.1850453618449065, 0.18914013481194547, 0.17693043957226107, 0.18268348945989188, 0.08258046744687075, 0.06996630447228913, 0.07563948219370109, 0.07198687960809169, 0.07753040135216704, 0.06650707394373279, 0.07790014714673632, 0.08493457131873361, 0.0735181842511271]}, "mutation_prompt": null}
{"id": "2a43dab2-2373-42a9-b3a6-4a885d8382da", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "cc9c11da-bdd0-42f1-8f70-b326896688de", "solution": "import numpy as np\n\nclass QuantumInspiredOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.4 + 0.4 * np.random.rand()\n\n    def quantum_superposition(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def quantum_entanglement(self, func):\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            entangled_state = self.quantum_superposition()\n            entangled_fitness = func(entangled_state)\n            self.evaluations += 1\n            if entangled_fitness < self.best_fitness:\n                self.best_fitness = entangled_fitness\n                self.best_solution = entangled_state\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.quantum_entanglement(func)\n        return self.best_solution", "name": "QuantumInspiredOptimizer", "description": "QuantumInspiredOptimizer integrates quantum-inspired superposition and entanglement principles with dynamic mutation and crossover to enhance search exploration and convergence.", "configspace": "", "generation": 81, "fitness": 0.21810895216642057, "feedback": "The algorithm QuantumInspiredOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5486880367522122, 0.5500874671324321, 0.5258758164174591, 0.5466638316292052, 0.5575718555164759, 0.5640315420720936, 0.5688718630786345, 0.5542727090247135, 0.5390807052254325, 0.28230191992314135, 0.28310713879549854, 0.2500450896508679, 0.26451598511325813, 0.2776934440825418, 0.24337251727874332, 0.2538104234066072, 0.2587606867078357, 0.27670814324205495, 0.08715657164213719, 0.09440843990388625, 0.08899841348171267, 0.08264883418863433, 0.09181561448832543, 0.11069741574654413, 0.09686046841890661, 0.12103533080296269, 0.10827983993875656, 0.08315785579733437, 0.09106069863148714, 0.07825636137349234, 0.10207389092613917, 0.08945349129542368, 0.0758021743910654, 0.10452550223531543, 0.07658383242888778, 0.08479367467773957, 0.84633285516887, 0.82883064840599, 0.9207925539162084, 0.9040246640448505, 0.8906606787314318, 0.9032289342036164, 0.9106017142211739, 0.9309514832409931, 0.9093061920583232, 0.21224883170465758, 0.2311744837391081, 0.21829608725873018, 0.20990853310472202, 0.21421315594630985, 0.2225405654041499, 0.2118746090271847, 0.22902993983972797, 0.23172870401205425, 0.3215844354968964, 0.3117773812944974, 0.2635833569316084, 0.4238108718274912, 0.35808950103531256, 0.4665809989635278, 0.4015775061516115, 0.2892141486771359, 0.3378625219380761, 0.15462520160470672, 0.14426763482255023, 0.16365362675044892, 0.13618852714962648, 0.14788776852042151, 0.11869173672033173, 0.142075144702016, 0.13178313757878346, 0.16021267645023507, 0.10611912234724608, 0.09458514967411502, 0.13445548737646207, 0.14503049965490156, 0.16505949256011898, 0.13373439440154067, 0.13623513272302012, 0.16339572996082752, 0.12258428538685329, 0.061118036889054705, 0.06968345807907173, 0.04757914707511268, 0.035679431645807225, 0.04493084552462456, 0.06964422195919073, 0.08135464303902806, 0.04293448919402143, 0.06982055799455245, 0.18425361252613215, 0.18807632675119812, 0.1643904318243975, 0.14580586478211877, 0.15742845216129442, 0.1789458164450336, 0.18707969455638662, 0.23005691224259694, 0.17363048856788443, 0.0005841794031750114, 0.0009994169244664786, 0.013582581471, 0.004554991959976329, 0.011775631271805476, 0.011661888115389596, 0.03003919001861599, 0.025316723051763246, 0.016716735240677738, 0.10864044644186688, 0.10717539517326113, 0.10721621154978289, 0.10952494699690796, 0.13059314000079014, 0.10817435000075726, 0.11302849087249522, 0.12816461528150924, 0.10986090920628344, 0.43373066825874795, 0.38927915127224577, 0.42780987743761456, 0.4396377476601586, 0.44199430976512455, 0.4016254939637748, 0.4056011855848437, 0.4157072325367628, 0.42498168813293546, 0.08265473390130906, 0.07728426740094707, 0.09552985577281159, 0.08506328111096029, 0.07670528091378215, 0.08995061489826217, 0.08160091867004249, 0.08279366854284709, 0.07308471724260113, 0.13442372403394443, 0.1482638127198994, 0.1439667886969932, 0.12807475917247135, 0.14366530971009217, 0.14845294271125675, 0.1679682172203515, 0.1333097762946176, 0.13061649220933236, 0.2613124078101725, 0.2505705192340727, 0.2765966934693379, 0.2357264106934298, 0.2554457376337582, 0.2512547464610807, 0.2725481342411442, 0.2925122323631867, 0.29337775614563466, 0.19817186873554582, 0.19243254294408774, 0.18052046660977228, 0.18685086002293894, 0.18354245867008412, 0.18246832367715948, 0.19853268103229604, 0.20637211825760005, 0.20028577099947753, 0.1692305220471746, 0.17912528777930914, 0.17809245333007007, 0.1895750548669597, 0.16453600930241796, 0.20389315687514975, 0.16699327186861668, 0.1753888410961465, 0.1793590823490233, 0.16547831731453166, 0.1759152164565021, 0.17197789825363996, 0.17654473328560671, 0.16355746753131783, 0.17776661025641383, 0.17891109182241471, 0.17655802517944263, 0.17186699360235158, 0.17407373781983548, 0.16737325887829668, 0.1574839933984853, 0.25813516159502037, 0.18070973272168123, 0.43165823897263667, 0.15673795418577952, 0.1791837344658237, 0.1573311283659441, 0.40410743738116384, 0.18870467542083713, 0.24495915359540577, 0.19558416047316873, 0.168914301352053, 0.1581047608817513, 0.18936842661157294, 0.1948901837200545, 0.14471062710967542, 0.19224160476174068, 0.1760632799585412, 0.1694766154937386, 0.1752120332534619, 0.17598759832622324, 0.20709000206901107, 0.19205973326623293, 0.19686083381476616, 0.1871390802817089, 0.06109117642920969, 0.06920483427694635, 0.06607480422126977, 0.0625741432520599, 0.06898764973038396, 0.06597791234425898, 0.07384238490457062, 0.06882427305504313, 0.08022679912144015]}, "mutation_prompt": null}
{"id": "b0e969c0-8976-4713-aa96-25e4e793a8e4", "solution": "import numpy as np\n\nclass AdaptiveMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.5 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveMultistageOptimizer", "description": "Adaptive Multistage Optimizer (AMO) enhances exploration and exploitation by dynamically adjusting mutation, crossover, and hill climbing parameters based on the search progress and diversity.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5505803155455102, 0.5644001808739769, 0.5794311835289254, 0.595873053275825, 0.6360910794333026, 0.6087789595216148, 0.597388418924574, 0.5909121734968408, 0.5884547741146449, 0.34198534087177646, 0.29836302670118053, 0.29870743288636203, 0.3042039886163971, 0.3082111123023932, 0.31201343761483546, 0.31511449859873186, 0.34354074076868735, 0.33013613659862884, 0.08586978067689055, 0.09366092339937038, 0.090787389605402, 0.08884122382362147, 0.09684905278332223, 0.09762228925937455, 0.09158023380516711, 0.09205348420108295, 0.0951692853636088, 0.10109294694428628, 0.08221155615283826, 0.08816391545857172, 0.09200530684957853, 0.08402676276160348, 0.08649435336473976, 0.08728631682800858, 0.07946631568471707, 0.09265000207105545, 0.8047149773418101, 0.9538363860040002, 0.7712518847183698, 0.7009340546985985, 0.8329075066895537, 0.9461542926744718, 0.8933168271160989, 0.9154169732891558, 0.7280796363607145, 0.22703035421087048, 0.23093035655630867, 0.22434752401149194, 0.2684744576829955, 0.24244051754004237, 0.23809487405967944, 0.2486794343158364, 0.2769042232395673, 0.2526585464469485, 0.563503220661335, 0.5375338172006399, 0.5326837671442302, 0.5761872691820593, 0.5681634280717167, 0.5512074227908377, 0.6171001940489051, 0.4923297472653866, 0.5044279408033547, 0.15669891746315623, 0.17574904855363405, 0.15784122685917024, 0.11653355165877965, 0.16211781027570338, 0.15864543984730883, 0.13450881359590017, 0.18571819230775855, 0.12538550916059288, 0.17171971216595971, 0.10805251358461432, 0.13691381582312512, 0.1575174284174523, 0.168172905807912, 0.20427258550631344, 0.15660599974834588, 0.14854843663238648, 0.1231534035511328, 0.13566721064866594, 0.15316432154053672, 0.14995910535171264, 0.12034755810565478, 0.11378600142339002, 0.1281383103520145, 0.17269022665173983, 0.1395299670637884, 0.1168462889232671, 0.2644046144214601, 0.2722665785323757, 0.25137207990970567, 0.247326274399569, 0.2582847168615403, 0.2568836018594671, 0.2979203267797875, 0.26915270281863346, 0.2615104275312373, 0.028971177048420005, 0.04449610482471311, 0.025388420001152157, 0.03935052633486191, 0.01939176139508103, 0.04894952814224329, 0.015575738440286258, 0.028778768104776864, 0.02546426215361186, 0.143751406321464, 0.16019865187021276, 0.13816659565023093, 0.16592757259265434, 0.16704799853839636, 0.1642674234392334, 0.15802416119848783, 0.1677389796174379, 0.15927890076640927, 0.44664169518785257, 0.4622838332717055, 0.4588244913303733, 0.4491303642596268, 0.4847679647756604, 0.460094073125923, 0.499200491811276, 0.46852159882328415, 0.4944396608281941, 0.08754515425224851, 0.09894728346695192, 0.08405473670830466, 0.08878700250265392, 0.08169746425905944, 0.07565203386423314, 0.08122292210139315, 0.08125558471836469, 0.08764121751766629, 0.1532756190761393, 0.13536713472160844, 0.1522958119709812, 0.12283715786373817, 0.13367354751723637, 0.1277262588473126, 0.12191319378624776, 0.12074492579879448, 0.13087738986269837, 0.29804061735807363, 0.27541101749006525, 0.2683973007541236, 0.286622068346004, 0.26164831208694406, 0.27822420623467825, 0.29700779225058427, 0.30364708476136104, 0.28679256953945875, 0.20643010298889153, 0.2184648406731311, 0.20785639070460382, 0.2189891381294673, 0.20694427141103866, 0.20776605498891243, 0.2068999538695565, 0.23234701509377365, 0.21029986218427366, 0.17183642467259252, 0.1645584704061488, 0.1820809021107782, 0.19718136785078688, 0.16560792644843547, 0.19342392141223885, 0.18138970546238453, 0.1804455765881321, 0.17957690573637952, 0.1805578562772, 0.16779697659016346, 0.17904591909754541, 0.18936528360167948, 0.17489186068805884, 0.17128806642284433, 0.1887192031906676, 0.193473020908022, 0.1797424878103988, 0.21448066885914352, 0.373348396972788, 0.15495012328441338, 0.4982679537866407, 0.17146502984545242, 0.5210220318634856, 0.27791824844758783, 0.14411764020550688, 0.3057076320210921, 0.3116873053845801, 0.3458646340892505, 0.19023103756549575, 0.2976278083260663, 0.18880667028587395, 0.25001996125239223, 0.33083271678898907, 0.19175431816816313, 0.20131136619555146, 0.18799826848199597, 0.18697844339909775, 0.18149458753449588, 0.17263860942642917, 0.1633912966695299, 0.17565429054131387, 0.17348984639253917, 0.18067089930354774, 0.189818176587079, 0.0681415351009036, 0.07557205404758516, 0.06698488786256018, 0.07639953040748171, 0.06266188359961455, 0.06881679137383923, 0.07484846138892154, 0.0683747048917609, 0.06404470651662175]}, "mutation_prompt": null}
{"id": "a770336a-f83a-4f53-93e5-d68b94297bf7", "solution": "import numpy as np\n\nclass HybridEvolutionaryPatternSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (2 * dim))\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def adaptive_mutation_factor(self):\n        return 0.2 + 0.6 * np.random.rand()\n\n    def differential_evolution(self, func):\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.adaptive_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def pattern_search(self, func):\n        step_size = 0.1\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.choice([-1, 1], self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.pattern_search(func)\n        return self.best_solution", "name": "HybridEvolutionaryPatternSearch", "description": "Hybrid Evolutionary Pattern Search (HEPS) integrates adaptive differential evolution and pattern search to efficiently balance exploration and exploitation in black box optimization.", "configspace": "", "generation": 83, "fitness": 0.23766075057309954, "feedback": "The algorithm HybridEvolutionaryPatternSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.18.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5678764329405785, 0.5639177078669131, 0.5815807995115052, 0.580864655275279, 0.620053469177547, 0.5974800296635225, 0.5631679204330237, 0.5535251666919148, 0.5947245586460095, 0.30831007440143365, 0.2575402602001603, 0.2638945485902412, 0.2587498794105503, 0.2903625610454693, 0.23497913553273053, 0.3070945453357955, 0.2578874420376511, 0.2787338097487414, 0.1010343043274412, 0.11222841046229914, 0.08907026666589901, 0.10103838754203787, 0.09497938491933489, 0.08882847062779442, 0.08533566476240051, 0.09002589591478516, 0.09503892671213743, 0.09884648585505817, 0.08095660687687123, 0.09223482965720453, 0.08761774578851345, 0.08691789202711697, 0.08191814394506813, 0.07673248061787652, 0.07635446047309125, 0.07975032550003203, 0.6357452053227004, 0.772892004665146, 0.81956287155005, 0.9037763180426819, 0.7726244713026418, 0.8337917984886266, 0.8894391140046098, 0.8901089330662502, 0.7645881519512465, 0.20716720617319284, 0.19707714622010009, 0.22167988298649555, 0.20370598798117057, 0.23949391365568362, 0.21226640112251793, 0.20944841625498, 0.2509332650064221, 0.25162804751322987, 0.4246569169001658, 0.491056743276141, 0.44498980710109215, 0.6320398301087926, 0.5223198714645333, 0.48187933863524635, 0.49572705812687623, 0.5661773672685384, 0.4834811027415782, 0.1572190317615083, 0.17946148360715142, 0.16636640734153774, 0.1618794200518492, 0.1833172172218971, 0.13501580603472008, 0.14219881241402232, 0.1351724202993312, 0.16203084890636477, 0.16032033807551638, 0.13603945400738082, 0.15076157735770612, 0.19212926245187356, 0.13961906722925055, 0.10577311515905552, 0.16164407701908345, 0.16175652372215465, 0.14690061501138774, 0.09716234054593242, 0.11308904880058779, 0.13271388320650057, 0.12062437059456932, 0.11291025337490423, 0.10542862089662708, 0.12757329552345054, 0.09566132626479573, 0.10847691184447061, 0.2003233818308845, 0.2304478624051408, 0.19966290175389645, 0.2419598996550295, 0.21101267853222538, 0.17471668544880392, 0.25660277402659826, 0.2886046876120135, 0.2659044761772519, 0.026478964203041855, 0.025979010521692936, 0.058458817043116174, 0.03910354745624012, 0.029344096046208468, 0.05200971669953958, 0.045349043369487085, 0.04807591094630281, 0.05087759770552891, 0.1255271794070295, 0.13338032097062802, 0.14127499842119706, 0.15419147150983425, 0.13444721522409686, 0.14571441850143396, 0.13892121038410787, 0.1311106597474876, 0.1398178778156567, 0.4755198834487755, 0.4614239460741971, 0.49311415505204337, 0.44420127773722984, 0.4561974285214909, 0.4588028924654811, 0.4538194335237612, 0.45908214342319, 0.469583918662955, 0.08317083825200111, 0.08196895642764412, 0.09496987280306568, 0.08728078729771882, 0.07477066214149053, 0.0788808712874316, 0.08204208912892541, 0.07089154639217288, 0.08895758253920072, 0.13453862388960336, 0.11530098945727385, 0.14243264373304154, 0.15094903987615438, 0.1276109580999386, 0.11963303110989387, 0.12792338368749556, 0.12332227850240707, 0.12673037010551358, 0.2689731293010674, 0.2671636478295938, 0.28292613770733954, 0.26835734827272273, 0.27536742494239197, 0.25600801480529667, 0.29942238365402707, 0.29504373026552266, 0.27571497240117737, 0.22219290284505644, 0.20408359346886107, 0.18059386390024268, 0.18800919574854646, 0.2020971095362245, 0.23381632713102274, 0.23674439283619664, 0.2421782329790172, 0.23032545702461682, 0.17086077953536294, 0.18431635088786258, 0.21847210146502527, 0.21523962220684056, 0.1817695314690786, 0.19945270272497606, 0.18148993700487126, 0.20256430812094273, 0.19901088257162636, 0.16672073145023825, 0.1730017090465812, 0.17021594152432207, 0.17672551124143832, 0.18007203482214829, 0.17547517670772883, 0.1663381550043056, 0.17495564380576756, 0.19247632471057163, 0.1611425327001038, 0.5979888126564834, 0.41234743975709554, 0.4017370862616404, 0.1775044815289497, 0.15324857634355826, 0.25452035892320246, 0.15961006882313544, 0.17200652189300836, 0.34558233626225654, 0.2889677849148148, 0.32501892452605974, 0.17993379010987576, 0.16869197835588512, 0.14317359159209841, 0.19578369806122298, 0.2717848161969285, 0.20079046170150316, 0.17579101571141797, 0.20482571745931077, 0.17434453070405653, 0.18731401892715172, 0.1889328954918561, 0.18201863988018485, 0.17744573036050804, 0.17383901498691812, 0.17757131774901713, 0.07130415376557997, 0.07099770000439876, 0.07126467713121709, 0.06919129130656676, 0.06443116780285929, 0.07645101249557351, 0.07342149702482981, 0.07345183148590462, 0.07254595605277703]}, "mutation_prompt": null}
{"id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 84, "fitness": 0.2651389230317806, "feedback": "The algorithm DynamicMultistageOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "a17c1413-7fc3-4d07-9fb4-d7cafaf786d3", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "04d76179-1d2e-42aa-8533-2817cd0960ca", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "ecbc0216-fbda-4317-a7eb-65b767433a5b", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "e4b4439c-83d0-42a1-b696-77fe9d3a41cf", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "2451a46d-fbe5-4acd-a5d2-12b5120d822a", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "a2b339c3-e93e-49b3-89cf-39544f67a429", "solution": "import numpy as np\n\nclass AdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(60, self.budget // (3 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.4 + 0.5 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(10, int(self.population_size * (0.7 + 0.5 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def strategic_hill_climbing(self, func):\n        step_size = 0.04\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.strategic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveEvolutionaryAlgorithm", "description": "Adaptive Evolutionary Algorithm (AEA) optimizes by integrating adaptive differential evolution with strategic hill climbing for robust convergence across diverse problems.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 62 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 62 is out of bounds for axis 0 with size 60')", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {}, "mutation_prompt": null}
{"id": "0e8242a0-73ad-4ab8-ae81-e992f1137318", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "b9c92a87-eee4-478f-aa74-8fd30a287e0d", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "2f574f63-56a1-4ef3-9773-4385819ab4ec", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "20ebf4ee-c77d-4f20-b9a7-1e06a21114f3", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "eacaf47c-4270-4772-81df-3669df812e36", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "65a0815f-cea3-4006-a8f4-1134efeac94a", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "4069ba9b-e9ed-4502-a640-65421c5c65c3", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "234a9a83-63a6-4553-a272-83d4347e0e2a", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (3 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def quantum_superposition(self):\n        return self.mutation_factor * np.random.randn(self.dim)\n\n    def adaptive_population_control(self):\n        return max(10, int(self.population_size * (0.75 + 0.5 * np.random.rand())))\n\n    def quantum_differential_evolution(self, func):\n        self.population_size = self.adaptive_population_control()\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_vector = np.clip(a + self.quantum_superposition() * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutation_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def adaptive_hill_climbing(self, func):\n        step_size = 0.1\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.quantum_differential_evolution(func)\n        self.adaptive_hill_climbing(func)\n        return self.best_solution", "name": "QuantumInspiredAdaptiveOptimizer", "description": "Quantum-Inspired Adaptive Optimizer (QIAO) utilizes quantum superposition concepts to maintain diverse population states, dynamically adjusting exploration and exploitation balance for enhanced performance.", "configspace": "", "generation": 97, "fitness": 0.21601622668877332, "feedback": "The algorithm QuantumInspiredAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5745706252852963, 0.6121926530176547, 0.606325588974117, 0.5359337454261366, 0.6572007777430133, 0.5726884202524045, 0.5197590521115243, 0.6312364178886696, 0.569334671589319, 0.26651533001352257, 0.3815227431513837, 0.3462856631199762, 0.2774837249216183, 0.3615022899781253, 0.32140646009830753, 0.23427700412337416, 0.3678427645234429, 0.361813502913649, 0.1125343065984924, 0.12087725487280698, 0.10489580159738432, 0.10472082529694271, 0.11720295571981987, 0.10935916109248633, 0.10761259032785164, 0.10876596072924671, 0.11270934114886277, 0.09891948892912772, 0.10593498228406184, 0.08589558461505398, 0.09401366983821846, 0.1054373969808654, 0.10164781791382016, 0.09920484739438651, 0.10363564716171736, 0.09089433134139469, 0.8830440788012568, 0.9311907342344041, 0.9457803495339187, 0.8840085447676722, 0.8948413354457283, 0.8953199265578677, 0.9106595367371385, 0.9332741937202853, 0.8681155004927872, 0.21028797739351424, 0.24389771267424387, 0.22035264266670185, 0.24455639260433404, 0.2553072702228073, 0.25596855973888855, 0.20004232032086988, 0.2620860035442002, 0.22386703551374276, 0.21872547615818172, 0.24033988833133468, 0.1909543654994893, 0.3684486556848602, 0.28441457366376877, 0.26789914230075995, 0.16980516915233967, 0.3911793941635979, 0.25210944442859196, 0.10329108741860293, 0.13726270073378277, 0.14125189897446067, 0.12306288107330543, 0.14003311501011262, 0.12962579941442798, 0.13449731759240946, 0.1422212634828871, 0.15465471505284345, 0.14024420354255673, 0.14037666545741756, 0.14177288550618483, 0.11626613129077323, 0.15863211470920646, 0.143877699224499, 0.10636092722954726, 0.14485415046882422, 0.13397898517773743, 9.999999999998899e-05, 0.0, 0.0, 9.999999999998899e-05, 0.01224406025834035, 0.0, 9.999999999998899e-05, 0.0, 0.0023091611889769492, 0.07496422465358299, 0.06857571247166439, 0.05824452467783581, 0.05671155258700111, 0.03315688322576793, 0.005937143838413594, 0.060069179749932644, 0.05146168834648157, 0.04419591902846731, 9.999999999998899e-05, 0.01803386630729842, 0.0, 9.999999999998899e-05, 0.014138664728611139, 0.0, 0.02167234614039848, 0.0, 0.0, 0.07916793096351815, 0.0744981835498546, 0.06806663238745314, 0.07510716507680704, 0.0925194621866634, 0.09178800784161067, 0.06037014158134757, 0.11412075361032226, 0.05414188532011199, 0.3796968773463857, 0.43081030261698516, 0.38311263257753847, 0.3978625523055117, 0.41065594766551416, 0.40925501341186077, 0.39891479276461683, 0.399476881129876, 0.40689446467627355, 0.09505965801324479, 0.09827030510487367, 0.08663049159777425, 0.08680238048935485, 0.11664060617120542, 0.10536026208211224, 0.08345300032774905, 0.10007409821179736, 0.09108893574978394, 0.1429917569236484, 0.13802969297267687, 0.13737236797887742, 0.16976110279896073, 0.17238072618763434, 0.15933991760797295, 0.16759623060135287, 0.15204683592705137, 0.12834345143052284, 0.2759470580496389, 0.2643319445973866, 0.25218773970513453, 0.25352893596438697, 0.305831392978699, 0.2706794441910041, 0.2865069843772716, 0.2921371671305161, 0.2771693404654635, 0.19396937851520657, 0.171655332192159, 0.19195168135957463, 0.16854174977715453, 0.20900997009811917, 0.20232777695761472, 0.19525552054037865, 0.231866527587553, 0.2118526535330998, 0.17192028490527322, 0.17854362671474677, 0.1748576596386534, 0.17793107516266282, 0.17908697824694486, 0.16523039891255553, 0.18623840935606195, 0.17444004301695126, 0.19868412179533135, 0.17657624993625975, 0.20486272972296493, 0.17971198328391003, 0.20472996984492675, 0.193160601773528, 0.18333458564632843, 0.177514463933785, 0.18575659515795517, 0.18430643564596316, 0.2947078373229258, 0.17548160694203563, 0.4310581522265612, 0.38754291724544365, 0.18269191775013383, 0.1768409601227342, 0.43349882550040386, 0.1651468378105566, 0.22877683686919403, 0.3111537889837248, 0.1983418181468829, 0.28042164383438417, 0.2354718531996859, 0.19462845764029768, 0.2130193505914625, 0.28939368613411265, 0.19955268853859043, 0.20341317096661204, 0.17538573832250892, 0.1777852080085771, 0.1920551554835157, 0.18485121097883395, 0.17579544137323266, 0.16718536855406108, 0.18399084548082278, 0.17863824915902282, 0.1787274999081383, 0.0785239078705503, 0.07240337388040352, 0.06923875393995327, 0.0798846065058989, 0.06001569108071758, 0.08234715959449401, 0.06479166562343275, 0.07098748190288284, 0.073307907488528]}, "mutation_prompt": null}
{"id": "c4e6f14e-08a0-49c1-92d9-b5f56af4bb56", "solution": "import numpy as np\n\nclass DynamicMultistageOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (2 * dim))\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.3 + 0.6 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(5, int(self.population_size * (0.8 + 0.4 * np.random.rand())))\n\n    def differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (2 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def stochastic_hill_climbing(self, func):\n        step_size = 0.05\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.differential_evolution(func)\n        self.stochastic_hill_climbing(func)\n        return self.best_solution", "name": "DynamicMultistageOptimizer", "description": "Dynamic Multistage Optimizer (DMO) leverages adaptive population strategies and fitness-guided parameter adjustments to enhance convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.5961915338186319, 0.628216449914902, 0.6260883495473397, 0.5853900005575121, 0.661909014405558, 0.6473453239526731, 0.6086613773631289, 0.7044019569669189, 0.6400836873140868, 0.3202672450229679, 0.3892443068984176, 0.3545068700098475, 0.28842481281624155, 0.4226088962045492, 0.32521048448637246, 0.35919002209654627, 0.3855124401025031, 0.32996984292469844, 0.08485249292247754, 0.09354285952456498, 0.0986023025760312, 0.09520643970568632, 0.10093620228564448, 0.08842891703544642, 0.09845868704949412, 0.10113443163958458, 0.08616549387496941, 0.08000274789038009, 0.09234363384227873, 0.07663829279979795, 0.11012976319826906, 0.08979155954825624, 0.09663559960716028, 0.0820077265347805, 0.08135738304784079, 0.07622865731512973, 0.8210526359195935, 0.9086238724590978, 0.9406335303098956, 0.8880251059082862, 0.955618683064237, 0.8528178440377384, 0.8582519607773973, 0.9357262986939635, 0.9521486095170606, 0.23447275925539368, 0.29178315234219665, 0.2540709385104306, 0.26195333158881695, 0.29393103144557686, 0.2398063747880872, 0.2750976263608108, 0.3076550116312502, 0.2736124003356766, 0.4681507146114231, 0.5597862900017013, 0.5601195512920653, 0.4685318234186634, 0.6046291628959207, 0.6050154175566009, 0.496416708380675, 0.5727384527023185, 0.511027551759748, 0.1847996426498404, 0.16365056375233822, 0.23279550337797839, 0.2132417302574473, 0.17594132319849465, 0.12218869932643195, 0.15090710683781672, 0.19681546541973638, 0.16639014819331444, 0.1409879312876957, 0.12001418735305391, 0.146584332462107, 0.1964788672813914, 0.16675726422934678, 0.1667866952769016, 0.15859115088568065, 0.20513935548365403, 0.1582835350904379, 0.12239019201167378, 0.1709328284488253, 0.12942601946172216, 0.11675465778083094, 0.12590523164672252, 0.13834848788663623, 0.14144275097381398, 0.14124314031027807, 0.12656555695451133, 0.20530460066869027, 0.29865538044117323, 0.2827632195179224, 0.22380925622482517, 0.25212139805657996, 0.2656142898284999, 0.3101115866136954, 0.27642696042372716, 0.2921066517953508, 0.04481590535197044, 0.03898918954011188, 0.05187872717140285, 0.04324043057975391, 0.06556636050016218, 0.038413490543904305, 0.04464375091011785, 0.06290096240950283, 0.08000383249853826, 0.16047216155474253, 0.18991845128241758, 0.17106590599052995, 0.15605840638896484, 0.18350060029708304, 0.19507361334231876, 0.13926658242012013, 0.17316205479839497, 0.1845264989171328, 0.4783053631848052, 0.5188020696535737, 0.504933250852593, 0.4411604844555571, 0.518126180772308, 0.5126105445002733, 0.4655571074033802, 0.5299046353774121, 0.49761037369159167, 0.09664301146218823, 0.09196229803089229, 0.09413284176581205, 0.07848211944516881, 0.08704771122038524, 0.08723859790316635, 0.10318456739807991, 0.0802361979930174, 0.08954830004253167, 0.15387969394203427, 0.13746998581599323, 0.1573695443761337, 0.12257780194082557, 0.11844906064465244, 0.157300151463994, 0.1283831388385157, 0.1280527216800007, 0.1701372876882018, 0.2841776093865629, 0.32249843989085936, 0.31348165348594736, 0.2926255927867645, 0.2899840246709965, 0.2677379484758725, 0.28366089307395814, 0.3209861049601148, 0.3239054562268512, 0.20473892724509613, 0.22149987558376127, 0.21924563016117038, 0.21145546063586407, 0.20569162847052325, 0.24233006379735866, 0.20320720858227748, 0.26272463104179056, 0.23264254311971966, 0.1841798466350839, 0.17484759474416167, 0.20702421743710164, 0.18839193171601332, 0.16915773003622048, 0.18254654874687604, 0.17048475559795284, 0.18223380296885616, 0.18508730024959463, 0.17172853202071459, 0.18170937498821016, 0.17405932465445728, 0.1852672323630722, 0.17425378164623584, 0.18450553159112548, 0.17025247286929968, 0.18216056234205158, 0.17788639941862205, 0.531107171747037, 0.5219786950735548, 0.14613479203224866, 0.46908094118844945, 0.4835685274944306, 0.4881898683003897, 0.39209210043091713, 0.39567231655748925, 0.44522730524904797, 0.5074588093208141, 0.16562141040007006, 0.1845376134615413, 0.17770083824957894, 0.19933320692844902, 0.2040033620026468, 0.1912002797705481, 0.20620603379168745, 0.2006052037857089, 0.18098045153416376, 0.17760688586451723, 0.19226078567086746, 0.18152884138088288, 0.17883538211179928, 0.17583321415349762, 0.1738642816677488, 0.19423094742836, 0.17327215167901577, 0.07119043758238186, 0.07036644057651031, 0.06856440914378947, 0.06487705346414663, 0.07995137783449957, 0.0669792779833086, 0.06576726090679696, 0.07450698841576142, 0.0650417582460926]}, "mutation_prompt": null}
{"id": "2627358b-c661-4f13-8ecc-464329e0e663", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(50, self.budget // (3 * dim))\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n    def dynamic_mutation_factor(self):\n        return 0.4 + 0.5 * np.random.rand()\n\n    def adaptive_population_size(self):\n        return max(7, int(self.population_size * (0.75 + 0.5 * np.random.rand())))\n\n    def improved_differential_evolution(self, func):\n        self.population_size = self.adaptive_population_size()\n        for _ in range(self.budget // (3 * self.population_size)):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutation_factor = self.dynamic_mutation_factor()\n                mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_vector\n                if trial_fitness < func(self.population[i]):\n                    self.population[i] = trial_vector\n\n    def enhanced_stochastic_hill_climbing(self, func):\n        step_size = 0.07\n        for _ in range(self.population_size):\n            if self.evaluations >= self.budget:\n                break\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    return\n                direction = np.random.uniform(-1, 1, self.dim)\n                candidate = self.population[i] + step_size * direction\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.evaluations += 1\n                if candidate_fitness < self.best_fitness:\n                    self.best_fitness = candidate_fitness\n                    self.best_solution = candidate\n                if candidate_fitness < func(self.population[i]):\n                    self.population[i] = candidate\n\n    def __call__(self, func):\n        self.improved_differential_evolution(func)\n        self.enhanced_stochastic_hill_climbing(func)\n        return self.best_solution", "name": "AdaptiveHybridOptimizer", "description": "The Adaptive Hybrid Optimizer (AHO) combines modified differential evolution with enhanced stochastic hill climbing, exploiting adaptive mutation and crossover for improved convergence.", "configspace": "", "generation": 99, "fitness": 0.22849258513096615, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "d259f332-d29e-43e4-8cd2-f38ef7c92b4a", "metadata": {"aucs": [0.4890023494103287, 0.5819634255612671, 0.5466618941204899, 0.5013297265899463, 0.5555654768590211, 0.5955100830367583, 0.4974514261441094, 0.5939594584253096, 0.612602257240768, 0.2122324415136222, 0.2996669841056042, 0.25932165500987614, 0.21115680963427408, 0.31847380470997866, 0.28805008848695746, 0.20592242372464176, 0.30077488791097007, 0.25191002507050575, 0.10677031383671332, 0.10803023210739338, 0.10265668239873249, 0.1153648666293926, 0.10178871545800505, 0.10801509162804446, 0.11705647091328775, 0.11265387310579444, 0.09962140158963118, 0.09245721901149084, 0.08980835079257399, 0.09017694509414254, 0.09375088995291991, 0.09528070344382289, 0.09158598928515926, 0.0783050581806719, 0.09661769995918945, 0.10401112100400878, 0.8790408159197246, 0.9391041256958493, 0.9782012859326819, 0.8811734612284026, 0.9806368624749647, 0.8829991693261164, 0.9068775750239009, 0.9770782243492865, 0.9365051951379031, 0.19981303830980301, 0.24458479270616418, 0.21523443952499943, 0.2055486159701373, 0.25367542891047556, 0.25616063523758814, 0.23970858435478737, 0.23625656655528016, 0.2573943729500717, 0.4136823533889846, 0.6101810961932279, 0.4654704523026557, 0.45562125294071887, 0.5739692403159021, 0.33321452195639056, 0.29906277816767, 0.38225181157843413, 0.519168211128427, 0.13069958827258066, 0.1586851838950628, 0.1218378395548827, 0.12604277100224903, 0.14526139312365993, 0.1508253691634578, 0.130810765807158, 0.15737968724077067, 0.13887056613639392, 0.12269907273733793, 0.13173869277151207, 0.08725174549967107, 0.1251687131152749, 0.1583162665942931, 0.1247630581506155, 0.11068320507160967, 0.14527105102326043, 0.15262508493984495, 0.024588787123341227, 0.05888368117279785, 0.0378734107825931, 0.02890657473919256, 0.03161831173036811, 0.05981767489090617, 0.07158669260282347, 0.057783903540398196, 0.05153502811875155, 0.12479948710547595, 0.19248782875447568, 0.1726970940341045, 0.1807033306999536, 0.16563347420972296, 0.13145591525218148, 0.16719609968994975, 0.18395059783138634, 0.1811423849067657, 9.999999999998899e-05, 0.043797909948617764, 0.0, 9.999999999998899e-05, 0.0019477740009855582, 0.011768369473062146, 0.01288687043111314, 0.002811515722661584, 0.05030290800908366, 0.09180517307007396, 0.12258439899180507, 0.1147114982307923, 0.0957640341911068, 0.14114337292048607, 0.10564889261557997, 0.09708909142502575, 0.13186645918035933, 0.10694918895793215, 0.39619719501384265, 0.4755814000244195, 0.4471591873533275, 0.40908533454546137, 0.42510995431597287, 0.41673452457150173, 0.38973068146308554, 0.4436873478280464, 0.42982160355795873, 0.09779787462864353, 0.09413679594201185, 0.10459214911636883, 0.09263763035938499, 0.07811520828973084, 0.09056503052839304, 0.10464509947601197, 0.09905578289378814, 0.0820700366906707, 0.14580043680323163, 0.15978149522477758, 0.13930900494828324, 0.14225966402436552, 0.14707757349533224, 0.1499584640051509, 0.1429197530225379, 0.1346985915267005, 0.15751010706498914, 0.24695452394829898, 0.2881228341928852, 0.2606603398702999, 0.24863503405661558, 0.2729889167441041, 0.26931277262712294, 0.28347408397367824, 0.3025243346985529, 0.26405967421628795, 0.17841779002895142, 0.19711664145629093, 0.18943334377241117, 0.2047832237902817, 0.19738426933148867, 0.1972269762101524, 0.183779912019428, 0.21879920871827385, 0.20851800539533782, 0.17187314370214846, 0.18396351534860556, 0.17704195437870673, 0.18385065991476135, 0.19555452817746521, 0.19944694891716885, 0.18355206498296106, 0.17051522062519853, 0.1907843813601101, 0.18284374540372406, 0.18208130102812692, 0.1876241174946346, 0.16837774909503223, 0.18193911822689457, 0.17334583035603157, 0.18248555041116898, 0.19034567077882436, 0.2065303236153988, 0.25264852178933384, 0.5082270443563239, 0.1780290080319914, 0.26652822674225407, 0.16988570477084375, 0.44360819399945806, 0.3775174864463756, 0.17111636015432885, 0.1999824609290658, 0.22355579330849829, 0.2338298776730744, 0.18706648211773125, 0.29596647776151885, 0.17833731353703441, 0.18011507858606235, 0.19940524366100654, 0.20414251436240705, 0.20755261510687328, 0.16870557556407106, 0.1875529522703251, 0.1875921018509692, 0.18164679676429307, 0.17455327644478968, 0.18193359116975805, 0.1692034100839901, 0.17163406403907722, 0.19698139088297162, 0.07538503039087097, 0.07051160953193591, 0.06985367388714125, 0.062140214938714244, 0.06432043124390652, 0.06056874976572657, 0.07764113870928302, 0.06555013988504654, 0.06973466397075878]}, "mutation_prompt": null}
