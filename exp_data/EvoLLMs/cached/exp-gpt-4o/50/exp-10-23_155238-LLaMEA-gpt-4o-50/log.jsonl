{"id": "05795560-7c87-4d41-8112-3f998167ad3f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.f = 0.5  # DE scaling factor\n        self.cr = 0.9  # DE crossover rate\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate and update personal and global bests\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions using PSO\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            for i in range(self.population_size):\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions[i])\n                )\n                self.positions[i] = np.clip(\n                    self.positions[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            # Apply DE mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.positions[a] + self.f * (self.positions[b] - self.positions[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.positions[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.positions[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Evolution for efficient exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.20354694919203317, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.428886255807143, 0.47753954739381965, 0.5223081081744936, 0.526932719609998, 0.5532532358531567, 0.18843202772452428, 0.5138969415514589, 0.5282745050879377, 0.18038350286166238, 9.999999999998899e-05, 0.24554994263229024, 9.999999999998899e-05, 0.020309877171007962, 0.19186989901421259, 0.1126635256357238, 9.999999999998899e-05, 0.042954731384070355, 0.20767285846714545, 0.10021423948147534, 0.11006792141358945, 0.12647656759806236, 0.10974689162329176, 0.11610020704862856, 0.12944765110926715, 0.09389015841510095, 0.1231330668476458, 0.07833121046897673, 0.04710801517996965, 0.046130786972953475, 0.09957768317727933, 0.10710585419977581, 0.11786580789017775, 0.10332656083657799, 0.09445834778579831, 0.10291628793368768, 0.09491371718420194, 0.9598403350453762, 0.9511607778436642, 0.9781931355685156, 0.9318952177906233, 0.9681206975806136, 0.9705289973361155, 0.9731886835683314, 0.9592076538473553, 0.9599583204005249, 0.2436648283527999, 0.11000129301967099, 9.999999999998899e-05, 0.13494248120529373, 0.14577532986688546, 0.14906006607432243, 0.08689431150566929, 0.08547651609917817, 0.30782228752124163, 0.45052695055682435, 0.35968800053591854, 0.16537004627969543, 0.2659928015303893, 0.26214166727890975, 0.19739813247520865, 0.1328351931634454, 0.6110391083359297, 0.19209945465975686, 0.059222828834526786, 0.1383658103242391, 0.07708758667346738, 0.09201741619532244, 0.17433868281047782, 0.10988689254873807, 0.10079548732280086, 0.1384944450422998, 0.14802699551094556, 0.13442191407244064, 0.1576450543279554, 9.999999999998899e-05, 0.1013094971464179, 0.16886016402579263, 0.1294229076602842, 0.1445325394350515, 0.09547605711900053, 0.09172348083659054, 9.999999999998899e-05, 0.05134482066393142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006747070526011756, 9.999999999998899e-05, 9.999999999998899e-05, 0.06755027459849594, 0.04877405507902821, 0.05735123997504088, 0.0413141390494105, 0.0033861863767464806, 0.02142111816100556, 0.02025234607273052, 0.07264541431349025, 0.06117760642220915, 9.999999999998899e-05, 0.03671221177879891, 0.01793913145667958, 0.013720034292930894, 0.0017122013072168318, 0.01806504041047896, 0.04704569648119428, 0.030573021411567036, 0.034397373227242345, 0.05403164611745903, 0.03277870546721695, 0.08054930306044827, 0.12553798216467804, 0.1090542254137068, 0.061242032771726906, 0.04846868194131493, 0.06872424895120699, 0.10478470115816874, 0.3974747919279984, 0.44445676061614336, 0.3919663450678258, 0.4220753150869744, 0.3912793153069388, 0.2052345013068252, 0.45623927949173326, 0.39220501570313815, 0.40045228822733225, 0.06587894641505354, 0.104493733382237, 0.12353952021949899, 0.12619306718215317, 0.13233707797085603, 0.09354711517873615, 0.10047578338387142, 0.08142418272106222, 0.13138499557024663, 0.17722404708381945, 0.22549466978917843, 0.20372218210503779, 0.19374035837238668, 0.38779569644490064, 0.1337216132272282, 0.26939796589440657, 0.14352827224627596, 0.17627400694390327, 0.28488430729852643, 0.1922050609852285, 0.28703801152776076, 0.27148516611316287, 0.2953477923004121, 0.19711346701971844, 0.3152938739147272, 0.34824827987527207, 0.3136032138080672, 0.19792211608388321, 0.16269060540351787, 0.202839956323562, 0.19160172668871145, 0.17569436135351002, 0.19482901650149076, 0.18435880560376505, 0.2262888806783233, 0.23001862046823063, 0.23978393776027562, 0.14926383571107904, 0.20034221291987064, 0.21116175733985543, 0.23292171915452287, 0.2055254032622864, 0.2023391493937926, 0.18570687761283755, 0.2170997478527148, 0.19560701992015683, 0.1798805190969659, 0.27756737712093704, 0.20528266860111932, 0.2996187226931002, 0.1797211591766178, 0.16640149683120253, 0.18890645832225506, 0.173141206942385, 0.6121924620188852, 0.1682321826406642, 0.10587617231707169, 0.47378814863808416, 0.19758336630889461, 0.16921865812944525, 0.14037603836125012, 0.16111009863579495, 0.6246350305003043, 0.40346336412438566, 0.1694886683344592, 0.07305937088983849, 0.19558094425194095, 0.16748117687904873, 0.1467217072988828, 0.19615760454618225, 0.19958478279091751, 0.5042354795874107, 0.18835135670728465, 0.16696816455410313, 0.1840991022877293, 0.18114446678660046, 0.21056732447653925, 0.1806329017034577, 0.18546407091571426, 0.19097100313663407, 0.18330882208620103, 0.07021554664497565, 0.08760784708593161, 0.08881202849425995, 0.09012420327970683, 0.08260024566339375, 0.07479011944520575, 0.08546150402257557, 0.07686557005152772, 0.08129090384441151]}, "mutation_prompt": null}
{"id": "8fd82272-50f5-4e00-874d-13a7e2c9e47b", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w = 0.9  # inertia weight\n        self.f = 0.8  # DE scaling factor\n        self.cr = 0.8  # DE crossover rate\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.5, self.population_size)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            # Evaluate and update personal and global bests\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            # Update velocities and positions using PSO with adaptive learning rate\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions[i])\n                ) * self.learning_rate[i]\n                self.positions[i] = np.clip(\n                    self.positions[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            # Apply DE mutation and crossover with adaptive scaling\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.positions[a] + self.f * self.learning_rate[i] * (self.positions[b] - self.positions[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.positions[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.positions[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with Adaptive Learning Rate for improved convergence and diversity.", "configspace": "", "generation": 1, "fitness": 0.2829796022647604, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "05795560-7c87-4d41-8112-3f998167ad3f", "metadata": {"aucs": [0.8817499967045188, 0.8862455699523001, 0.8804626903504429, 0.8692629254603081, 0.8925039888840673, 0.8861841114627832, 0.8592890284928778, 0.8684354769140751, 0.8768745085468942, 0.09239120376437027, 0.1914331197937833, 0.41719470657907554, 0.3760281184063521, 0.3433149294531864, 0.014439943280310619, 0.0748263222788722, 0.488692358597663, 0.058516026820193634, 0.10495259556546666, 0.12885557086743482, 0.11191843120181544, 0.09271876158373993, 0.10060690886494161, 0.09415203909656955, 0.0718896251024087, 0.7441644700526386, 0.132107519723075, 0.11064751922146554, 0.09249204492845298, 0.061400208312017424, 0.09535854096577023, 0.04795300689212467, 0.08731477267076937, 0.0956979349072552, 0.09442245744817446, 0.05555722126956841, 0.861751823286739, 0.8187611289731169, 0.9248894792130895, 0.838234398147909, 0.9262529798292063, 0.8872662007873784, 0.9367319378901925, 0.847116366737803, 0.8899182978502918, 0.22965084151350235, 0.19440671032423684, 0.12076750563989336, 0.30278784603094633, 0.15760781850355088, 0.21545466506054944, 0.4717918280080803, 0.18655143522244144, 0.3533386463839373, 0.3891085105565574, 0.9194915367556126, 0.3450135161387964, 0.21382942555553774, 0.3818904565625356, 0.14362037669022376, 0.16521545884222177, 0.39953227629102805, 0.35604401459538626, 0.3240310072546009, 0.05727457098920441, 0.15582087344411943, 0.13140736333240788, 0.13566511302189033, 0.26974682282543205, 0.3366309545435918, 0.17258568716979605, 0.12743026050017048, 0.14544247704859536, 0.1877885688104498, 0.12864454313839635, 0.13109897733265075, 0.15841843930178623, 0.13776866253563536, 0.1461117640761186, 0.1136163021682054, 0.13395740768322517, 9.999999999998899e-05, 0.08076171813389244, 0.0377993318774692, 9.999999999998899e-05, 0.16925407785316715, 9.999999999998899e-05, 9.999999999998899e-05, 0.014470405087283922, 9.999999999998899e-05, 0.10965126105147682, 0.04751849004323305, 0.14313000220308625, 0.07757214537948043, 0.046407360897214534, 0.03437585776455976, 0.06316479508590489, 0.09718923605296026, 0.1281327014901512, 0.17972155278585467, 0.1222138118854531, 0.1437834150889321, 0.13433197187237478, 0.23735456884740203, 0.19724030575425788, 0.2526417862155027, 0.14724244383301388, 0.2831932316374539, 0.14312889070436619, 0.23496471898139415, 0.12815081668002293, 0.13316969831788972, 0.05941910362776548, 0.06373365131393038, 0.0824134493809564, 0.14517332613472644, 0.12889101474824693, 0.5321830528858749, 0.525417840276546, 0.5659348457186211, 0.5803117613661084, 0.5891586756995119, 0.531618328039328, 0.541899990184487, 0.6166776193366685, 0.5651184643763909, 0.07021385640010136, 0.06928756775233302, 0.11011988042446896, 0.12335745900388795, 0.12979600817315318, 0.08518382676534997, 0.7590402328773762, 0.14430243635751416, 0.1141072825277164, 0.25655566207853775, 0.21144280866483878, 0.17716954509579186, 0.21269531230749517, 0.23070976904733242, 0.7735691443414037, 0.23018032915962516, 0.3084993190479669, 0.5325268087243802, 0.22888603326396517, 0.26330910336194313, 0.31827578489492425, 0.2560481990295964, 0.35192302880212567, 0.2893341234318153, 0.55687115870218, 0.318692085288413, 0.5204132050142445, 0.2533245881142464, 0.21039824890508696, 0.27627401154373254, 0.27120212547184197, 0.20838876281442464, 0.22066480090849117, 0.26092357753032824, 0.28273110252299605, 0.2650003415378448, 0.19893559148116957, 0.22670213785645787, 0.22204696159892678, 0.2400664534594107, 0.2379017041525575, 0.2139116780647018, 0.2214674724331368, 0.21032196155778216, 0.24533895088240842, 0.21062366183442527, 0.21083547694299232, 0.19380679053383454, 0.25332903308604504, 0.19263011099011051, 0.20877105674960916, 0.2500657602687971, 0.18647371582838346, 0.1839744552368372, 0.18691375211838723, 0.47108873286961106, 0.14764228633157472, 0.9072752675446203, 0.20068100386187326, 0.9236095973317405, 0.17651019766698484, 0.15068137846367957, 0.9066814471485992, 0.9117555276875215, 0.21210557328877222, 0.07347601698283746, 0.4125919998439034, 0.48198168362234994, 0.15206236097383008, 0.10456539762034334, 0.2560516985081477, 0.15461207852523717, 0.18763024575062603, 0.1895366389641585, 0.21727805765325492, 0.20370279009234815, 0.20337575594317625, 0.17379188185410144, 0.18215651852546666, 0.24665561070986064, 0.2001524980779934, 0.12304389441523833, 0.14475341002924702, 0.10398823158280956, 0.08313180456525149, 0.10302268469700215, 0.14490929170613986, 0.12463739937614882, 0.08330588619733759, 0.1140793362172473]}, "mutation_prompt": null}
{"id": "068c3147-504c-4cc5-bd17-331e924baa36", "solution": "import numpy as np\n\nclass AdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.f = 0.6\n        self.cr = 0.9\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.4, self.population_size)\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.8 * self.learning_rate[i] + 0.2 * np.random.rand()\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveDualPopulationPSO_DE", "description": "Adaptive Dual Population PSO-DE with Learning Rate and Memory for enhanced exploitation and exploration.", "configspace": "", "generation": 2, "fitness": 0.29025429318787715, "feedback": "The algorithm AdaptiveDualPopulationPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "8fd82272-50f5-4e00-874d-13a7e2c9e47b", "metadata": {"aucs": [0.7172783112882128, 0.8005173254138069, 0.8419238320105469, 0.7934131042324888, 0.8053440706043299, 0.8052018604621682, 0.8131443467289539, 0.6852814065244538, 0.7633599595347212, 0.5398555260316387, 9.999999999998899e-05, 0.029840761150403572, 0.5560996795991064, 0.44674755777613195, 0.6655669817661867, 0.46019642916736525, 0.4406894605807483, 0.3805693686396494, 0.15106329867698443, 0.14075634561835726, 0.12865704820922752, 0.140744114360146, 0.14749768661965967, 0.1350268205769415, 0.1187721177882699, 0.1769607064321983, 0.14038493390454865, 0.11159079037802055, 0.12597658792292732, 0.10857535476968894, 0.1309590110023513, 0.10684384452229534, 0.10102627990735613, 0.13624468807920365, 0.11426219637690105, 0.12623602004788825, 0.7761434343248741, 0.7263738726661731, 0.8204557392546254, 0.8590516219328831, 0.814391137101437, 0.7966039061889074, 0.690029808926361, 0.7849200335438947, 0.7956618410800244, 0.21945269520809751, 0.19093995239191663, 0.21876206757496053, 0.24685187189415747, 0.28955039869336385, 0.18409003675899915, 0.2595779375666175, 0.16641073793891226, 0.269857390417097, 0.3264850918911426, 0.34547919897193535, 0.214227304401574, 0.31819155638800056, 0.6450944015863356, 0.5047311157751238, 0.6369299977374961, 0.8055950521559293, 0.7532298469877291, 0.3718988222840327, 0.20607012475252784, 0.21308982778097074, 0.13176362941683506, 0.12094394764834238, 0.1390119063358195, 0.2481174510166848, 0.46899276415429236, 0.15068489754327496, 0.19313511606810851, 0.1411845868143753, 0.14960968766923088, 0.35901342758401966, 0.18518295537585405, 0.13935649163772923, 0.15595243470305742, 0.2457145641744769, 0.1304030209030056, 0.0010767780370090074, 0.032866235479313, 0.18586268074411405, 0.1124073297408682, 0.05285867974082159, 0.1933427734194958, 0.22767283545378236, 0.023810405969262316, 0.014372656764836012, 0.18704085838929818, 0.10039333001069595, 0.11633604527965924, 0.2522564011964339, 0.168997192976017, 0.17067266671612413, 0.25654935887187125, 0.14825706032215913, 0.20813916562979562, 0.15256935681070705, 0.11219229201815939, 0.25759399779037895, 0.11247651319527818, 0.19659464824367323, 0.17077130604322588, 0.16539333560999858, 0.21185774024763404, 0.1504038433829874, 0.2273195253391216, 0.2012974907749321, 0.24967377997506912, 0.22873155906738052, 0.13044679310024, 0.15793635665947436, 0.10625468372245728, 0.10064794598099125, 0.10765528359410892, 0.5701644192853659, 0.6123978461037856, 0.6022552781356649, 0.5235623994307104, 0.5320314681756232, 0.5671249673610208, 0.5549063242462009, 0.5918918040310328, 0.5613656586575042, 0.139147363449712, 0.1070980692722977, 0.09704118988934662, 0.11316440794618665, 0.12439728435178099, 0.11314342979385783, 0.14012134496459583, 0.12002501679880229, 0.15546120071050096, 0.20793421762149078, 0.16693604270993379, 0.17012990217872415, 0.21243768259623408, 0.19569687555963666, 0.15691523465698065, 0.2208237300098026, 0.1677030160440709, 0.19406007742559228, 0.3938517726615418, 0.3637565338927329, 0.3398113110420784, 0.37692380406181114, 0.38936024772274835, 0.36783927960468643, 0.4227812659426743, 0.3745378703207184, 0.4364480809807332, 0.28362755188298816, 0.29939846045769714, 0.25834346405998665, 0.19003411321351982, 0.29513009270042734, 0.3668036680608604, 0.28076059066603043, 0.30815915958109985, 0.32851851586626135, 0.2129932620516266, 0.22250869971777187, 0.3300973578226356, 0.21150597333827048, 0.2057171852680888, 0.21045592503752242, 0.20268786274781736, 0.22755609524787535, 0.2525574149052139, 0.19492449903545972, 0.2028082906227907, 0.19918579146807314, 0.20217381364517462, 0.21787034269169614, 0.22742582440726888, 0.20278833545033026, 0.20150475995456985, 0.20734535707788904, 0.1843817462729498, 0.7709369089345819, 0.18488892790423161, 0.7491604928892552, 0.1979623702741774, 0.19620942866627789, 0.8412397668935585, 0.21739814159719528, 0.6768391903539129, 0.27499436501716934, 0.20485905120904746, 0.63078074748776, 0.20535172799260304, 0.3092328927568746, 0.19856339905365827, 0.20613531070672242, 0.1646405658737654, 0.20798523522487722, 0.18282957220776552, 0.18304652820063716, 0.1965755906419312, 0.18487397495823776, 0.19180490995887334, 0.19318859711519287, 0.18409136026379536, 0.18334235307755442, 0.18891312565162632, 0.1000008042925814, 0.08642654199831179, 0.1279911289225285, 0.10490526245311271, 0.08991992412777439, 0.0959997767009918, 0.08105189476887242, 0.08746453858539083, 0.09616191271009555]}, "mutation_prompt": null}
{"id": "92f4ec0e-4bdb-4b30-b9c2-b17ea615ec77", "solution": "import numpy as np\n\nclass EnhancedDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.f = 0.8  # Slightly increased mutation factor\n        self.cr = 0.7  # Reduced crossover rate for diversity\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.4, self.population_size)\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                )\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            adaptive_cr = 0.6 + 0.4 * np.random.rand()  # Adaptive crossover rate\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < adaptive_cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedDualPopulationPSO_DE", "description": "Enhanced Dual Population PSO-DE with Adaptive F and CR for improved exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.24706482026500953, "feedback": "The algorithm EnhancedDualPopulationPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "068c3147-504c-4cc5-bd17-331e924baa36", "metadata": {"aucs": [0.6917127883426001, 0.4473164137610238, 0.6862401056084413, 0.677626821087607, 0.6234641283287272, 0.6565202408303641, 0.632186166306423, 0.6800937921543834, 0.49079828515503976, 0.28881127035457443, 0.2158326522233056, 0.03202990882189338, 0.12379188186138723, 0.3675388239918933, 0.1113395318748509, 0.03871879391307864, 0.17381263998264063, 0.24906892082637422, 0.17743920596224594, 0.30030577407762404, 0.13534613672496543, 0.2293488617537488, 0.1310786545231658, 0.24490307486843066, 0.14678130420525015, 0.24118558877571417, 0.18388934572346005, 0.12218582870326578, 0.10981279866646343, 0.11078965907701144, 0.18835804394516864, 0.13695553459159726, 0.14162166970072998, 0.12807945481125482, 0.14802615619406712, 0.10609610210798726, 0.9645900057312221, 0.9299630634149143, 0.9644684791828526, 0.9359375838689005, 0.9653634546195069, 0.9641262568366051, 0.9682573414117034, 0.968905355861762, 0.9547227613084399, 0.23489526236708658, 0.2359967313223268, 0.1714046932415424, 0.14247755505517834, 0.22704387538234294, 0.2044027984182455, 0.11158645786852028, 0.20843310964614492, 0.08397452275438477, 0.30348870826745067, 0.25987739051515235, 0.5325722148194729, 0.2415022168398271, 0.28531581859180033, 0.2071922041334221, 0.6432313098599969, 0.22831329228210517, 0.21240900845517918, 0.1340975351473942, 0.1356411917517475, 0.15861316113612467, 0.1261493081952687, 0.17993279158191167, 0.11390612596643479, 0.1410319225546125, 0.206692446912897, 0.12019216219560835, 0.11526071020149542, 0.12988941190937398, 0.16468269608459685, 0.14333439548858662, 0.13369605546595031, 0.13132285403749522, 0.148238819708164, 0.14900792393928042, 0.15795158149496769, 0.073727262811079, 0.12311473225303704, 9.999999999998899e-05, 9.999999999998899e-05, 0.00946780902099853, 0.06606011426452785, 0.06293824437348339, 0.012117900258480585, 0.14675308853623514, 0.19957787082623557, 0.21386166969753906, 0.13209305667743587, 0.08170773498846962, 0.2017789039410508, 0.07974743030710774, 0.19769060988812803, 0.110418902084919, 0.18538548487161866, 0.10463436183698172, 0.03740084240084307, 0.07252688497010273, 0.09042595529518516, 0.00463439700145174, 0.12493499478350334, 0.06126770810190374, 0.09689622720987678, 0.08654436697970536, 0.13397967320418924, 0.09913619250417682, 0.09126054588233368, 0.14113339858903806, 0.05536402752121017, 0.14537175267180136, 0.056054744893265895, 0.11222582133582215, 0.09506996495429376, 0.4581231954571994, 0.4917837675172837, 0.4573884672535473, 0.4572621610957974, 0.4943841726181728, 0.4301590027714436, 0.4565883850144483, 0.418806653555555, 0.4402455688019412, 0.11937084633642481, 0.13144779808044027, 0.13044208241806732, 0.11484391471262367, 0.11013606290482736, 0.1234500334518499, 0.11304389907459012, 0.11152784968825269, 0.0903225043177932, 0.2826726469146461, 0.2239010875063272, 0.17260856615091003, 0.17968894993434226, 0.2707350699843435, 0.15672384151267693, 0.1377921472595246, 0.21904119803471822, 0.15878354178708376, 0.3251397380719856, 0.2912731829674301, 0.28921238302129326, 0.27024312140740403, 0.3106105836682862, 0.3072259780905289, 0.3450565280163388, 0.32990874476403365, 0.37725726587087793, 0.2478551298472731, 0.26971463032052123, 0.2503067485579785, 0.22174950301813467, 0.19443869118809975, 0.24406780587450116, 0.20619408534660233, 0.1572632893545518, 0.27543514147923853, 0.19806949785085282, 0.1873673300502754, 0.21396038357370517, 0.20002848719512267, 0.20400250786200191, 0.20224675929321, 0.2047690164923307, 0.20823716305429485, 0.20712352305252524, 0.18294750686104755, 0.1933919502405722, 0.18390707707139853, 0.201339625068926, 0.1992946162360162, 0.22932632606855574, 0.2029419083785099, 0.2816476539769873, 0.18645790961772413, 0.2961641831561581, 0.623338583217393, 0.1818044977629314, 0.5242680920641292, 0.19468301610878047, 0.16748992858644252, 0.16215595286480478, 0.6814097782288212, 0.7446002769795135, 0.30512421716205174, 0.2072026224859862, 0.1952368941485868, 0.6104336327701191, 0.2998982831047121, 0.199995423082735, 0.2033510296366441, 0.15946234749389165, 0.1952908589208302, 0.1894978609456882, 0.18660532771972527, 0.18779397958186317, 0.1907434814934882, 0.20087800608092554, 0.19434355249264268, 0.186088262702524, 0.18930072281897437, 0.18386313161543733, 0.06634742718998499, 0.09160164916981939, 0.081072932849523, 0.10751395099344996, 0.07957171136732455, 0.07660253585667542, 0.07594713002307651, 0.07631133394720435, 0.08402175505445342]}, "mutation_prompt": null}
{"id": "5c5942f5-6ef0-41a6-ba31-b8b4cea3bd6a", "solution": "import numpy as np\n\nclass HybridEnhancedPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.5\n        self.f = 0.5\n        self.cr = 0.8\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.5, self.population_size)\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            current_diversity = np.std(self.positions_pso, axis=0).mean()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                if current_diversity < self.diversity_threshold:\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant = np.clip(\n                        self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                        self.lower_bound,\n                        self.upper_bound,\n                    )\n                    cross_points = np.random.rand(self.dim) < self.cr\n                    trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                    trial_score = func(trial)\n                    self.evaluations += 1\n                    if trial_score < self.memory_scores_de[i]:\n                        self.memory_positions_de[i] = trial\n                        self.memory_scores_de[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "HybridEnhancedPSO_DE", "description": "Hybrid Enhanced PSO-DE with Adaptive Memory and Noise Handling for Robust Optimization.", "configspace": "", "generation": 4, "fitness": 0.2572543488995831, "feedback": "The algorithm HybridEnhancedPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "068c3147-504c-4cc5-bd17-331e924baa36", "metadata": {"aucs": [0.7419636639815678, 0.691663832294577, 0.7341548940594138, 0.7451341830822663, 0.7053322617610097, 0.7356216011410253, 0.7961897701145897, 0.6105382489692459, 0.6584491586470491, 0.4804431515631774, 0.4055533674552192, 0.3949183474979534, 0.45582863615393476, 0.31443395587441336, 0.4365327502475661, 0.1465036052360258, 0.4219470230094534, 0.40695768942293564, 0.13845982325528217, 0.11063774713926688, 0.12805403573536756, 0.12832540330695041, 0.11736096321337941, 0.13288635749111255, 0.13745007291865063, 0.15519441046302107, 0.23530696229023484, 0.08984814763767368, 0.09816993952047615, 0.10442387825177724, 0.12339207979098643, 0.08615274987658872, 0.12210718118432307, 0.0970574554830469, 0.11049586221966567, 0.08625371104511281, 0.7227849321260169, 0.60267152865822, 0.7213549370111167, 0.7511341054473891, 0.7659650221103789, 0.737854027327733, 0.670437894471408, 0.7116829566006934, 0.8323444671025828, 0.23289006913657728, 0.19388140071357784, 0.1377966160287344, 0.3170702945510461, 0.16068662924613486, 0.14547022340764182, 0.16838250356123863, 0.153137303210378, 0.19158065800294555, 0.5882141093705099, 0.2784290232924512, 0.20858320473436798, 0.44524946946640087, 0.5602292445847278, 0.6099799789164277, 0.46862318595845176, 0.22186204981629554, 0.2044317074277595, 0.2888506789441312, 0.13635520795868672, 0.14499850851311857, 0.13654867614468835, 0.11176217900299124, 0.1834699765426807, 0.16810722295813652, 0.2029302979851101, 0.15721778266611341, 0.30074238177026313, 0.14257497552513432, 0.1355675943020206, 0.1397243137555343, 0.1614377941070918, 0.13280365095137836, 0.14658493586809163, 0.21984085877662374, 0.23511949160722756, 0.0046664444668206295, 0.04447093049489503, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00958898813091913, 0.026982088366474866, 0.003979333129107143, 0.040507716653026216, 0.14585492652446497, 0.05369395786688802, 0.08571731005101813, 0.07950094258856699, 0.0738235115687248, 0.023292084724046425, 0.10556857125203456, 0.09321370143840546, 0.05872020963461433, 0.2523605415668624, 0.13883717561263498, 0.2583344563867822, 0.029449562407563468, 0.37004255953426857, 0.2771123078110509, 0.10340391075900157, 0.024205307086526795, 0.11220748912248624, 0.20175925118941362, 0.19946006817671613, 0.19362385863949094, 0.13009510597070295, 0.16059020715442462, 0.16617765871548074, 0.10741759309234278, 0.1202170893466511, 0.09844581310907108, 0.48320372172477355, 0.5246866399224333, 0.4665787494047928, 0.4792154808176128, 0.4883765183390021, 0.5337867049192084, 0.5072292322675684, 0.5314128277274347, 0.4571881190039063, 0.10598809800268538, 0.06331392973629957, 0.1096454538066357, 0.124951889580173, 0.09842406726077102, 0.1128130562802504, 0.08737784458808584, 0.09514593979912367, 0.07976374949569365, 0.25490140855063603, 0.16692393671776373, 0.1800546519721482, 0.16342850699663136, 0.30288437080705954, 0.20714425145241544, 0.15310221967678805, 0.18423596340051296, 0.16216869445624305, 0.15968876193328774, 0.29025343989643837, 0.3079201931349569, 0.3527550438367192, 0.2969955440666897, 0.25611558649459254, 0.2601243144312052, 0.2814515874350154, 0.25557932120048543, 0.2233665757863682, 0.19034081588204999, 0.20731340019627753, 0.2636537141177737, 0.2121025943958028, 0.2531699641310089, 0.23198536263085934, 0.2889858136974178, 0.25413198483662724, 0.2298484590888945, 0.22155119578023186, 0.19720514463975347, 0.2069286639717367, 0.2159517017441258, 0.2668777941231095, 0.23010906070048165, 0.24138349308203044, 0.2856857333985413, 0.17237948986050322, 0.17618504946104985, 0.17803030868356795, 0.20042861476813334, 0.2048622362509237, 0.21979022392734748, 0.19089241021631842, 0.19922003012386102, 0.2057147742024512, 0.7843796996607204, 0.18840347878658015, 0.16872323040852555, 0.539381369549286, 0.20063821568704687, 0.19838244468190047, 0.15739729359137544, 0.15688789813074167, 0.7978523427973069, 0.3758584441336319, 0.4867476151051897, 0.24472319558429, 0.4439400162913256, 0.30471265199795694, 0.16030388032764764, 0.30003239353243016, 0.5500814006495065, 0.42776368153265976, 0.21122643327097257, 0.19869425821839415, 0.19577939601605399, 0.20590433560600918, 0.20997763171638795, 0.19811225952828393, 0.2184216227747322, 0.20075050687510054, 0.23236610225604037, 0.10953012998363088, 0.0765392632199271, 0.0886040190101427, 0.11169725237093331, 0.1025233626239842, 0.09927877482644887, 0.05355320238316763, 0.09227100082612227, 0.09784846595616459]}, "mutation_prompt": null}
{"id": "6b4a2010-bc99-46b6-a285-fc0cf53c9f6d", "solution": "import numpy as np\n\nclass HybridPSO_DE_AdaptiveMemory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.4\n        self.c2 = 1.6\n        self.w = 0.6\n        self.f = 0.8\n        self.cr = 0.85\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.5, self.population_size)\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE_AdaptiveMemory", "description": "Hybridized Particle Swarm Optimization and Differential Evolution with Adaptive Memory and Learning for robust search dynamics.", "configspace": "", "generation": 5, "fitness": 0.2120448345158452, "feedback": "The algorithm HybridPSO_DE_AdaptiveMemory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "068c3147-504c-4cc5-bd17-331e924baa36", "metadata": {"aucs": [0.41312693602972117, 0.5222908605099266, 0.6328633400937007, 0.4404869264122304, 0.4680176214057171, 0.48475532593009363, 0.5055459734224811, 0.4439655778909043, 0.4698652459718231, 0.19765991672475325, 0.19999185310417955, 0.16334193231105798, 0.226022644633876, 0.17139715452569104, 0.1913671929798566, 0.16647598583166434, 0.15571203117652055, 0.14937219090778708, 0.08769746268860945, 0.1051722633208787, 0.0895572434276024, 0.10782430589084746, 0.10764200426214898, 0.10655124276745631, 0.14389262187068852, 0.11525236757326185, 0.12832641329092642, 0.07828802050974204, 0.08202288404616631, 0.07513718616808673, 0.09515922943303035, 0.09204939655815181, 0.07976871894647264, 0.07910139986615128, 0.10157595636362671, 0.1011400100101284, 0.9144808387892943, 0.9041976062232979, 0.9171108043032743, 0.8655215480062487, 0.9398575743333213, 0.926402567994213, 0.8720484779759885, 0.9147188163009977, 0.8722630104596735, 0.1616631237581989, 0.17306409805706313, 0.1840005732912341, 0.19226047997474238, 0.18197828057725252, 0.16734305905376456, 0.19830266645484018, 0.17682319232632782, 0.16433702823519347, 0.2742461574897632, 0.36116308071046477, 0.23281949922024536, 0.31325054631335714, 0.2716531648146451, 0.2562827607466932, 0.23406638072578734, 0.253672841190002, 0.30680584461022986, 0.14999436972516056, 0.1316019151265656, 0.14232608765039312, 0.139142324531361, 0.12379413948704698, 0.12635671517115898, 0.19654297051470526, 0.25552043130850244, 0.10827210366233408, 0.13123880142934652, 0.18719974223821179, 0.07983954297712104, 0.11866522406197744, 0.1279972219051182, 0.24736002732679585, 0.13057698198440337, 0.15493284519421502, 0.09605541456960942, 0.00015861221376378687, 0.0016562366118443306, 0.03288743785751158, 0.03271726390380936, 9.999999999998899e-05, 0.006285003407279555, 0.01459667075937554, 0.0006467244905042913, 0.009561958922653657, 0.10574010435899905, 0.1476494256034826, 0.10964799861453989, 0.09939626378731992, 0.10944638860688083, 0.08973152668617801, 0.10552432422421754, 0.10618264759548601, 0.1441004270707994, 0.1003702373227554, 0.16905806931838419, 9.999999999998899e-05, 0.02771150935126465, 0.12688008190934819, 0.016977704032576035, 0.14044709400574196, 0.002503655151825823, 0.012456243280809964, 0.2169005123789437, 0.08576070740274555, 0.10457160794989451, 0.09429708027254002, 0.0945628304757331, 0.07924785764810038, 0.15648888909151848, 0.10939051709147174, 0.08043333431021982, 0.407383020069894, 0.424279719639469, 0.36317374299390126, 0.37320000580408264, 0.3637830239676624, 0.37869857577208754, 0.40493249977485235, 0.37810389178054116, 0.41489364100991977, 0.08993613550414681, 0.13947067130487012, 0.08253940929192338, 0.10692769836086413, 0.08194235427165042, 0.10626385074330169, 0.08285786927660066, 0.12025823342159314, 0.10853431950248904, 0.14204659308620193, 0.17560815745184466, 0.18244935680946717, 0.1526690804204074, 0.16445475987043268, 0.13818673213758526, 0.16576825680701057, 0.19259431225521517, 0.16461820366640967, 0.2535647915260332, 0.23704489063564216, 0.2691762943599869, 0.23278481595774136, 0.21012600969072381, 0.21793507149483593, 0.24272520393272223, 0.28866284643414253, 0.2490630123325832, 0.19697643450600855, 0.18310882580713683, 0.17918222828215347, 0.20045916887619986, 0.1978660303636196, 0.21713275486218486, 0.19791159640359668, 0.19839713289410688, 0.20152567693375478, 0.25153469373459203, 0.2134185120898281, 0.18401881702612688, 0.2153849946002162, 0.2090048441582527, 0.20747809828943264, 0.18944866953612804, 0.1949785560957913, 0.24317776352675236, 0.19467513198556308, 0.19193188317661602, 0.1750016754903687, 0.16765601625379745, 0.17310494331409065, 0.21191139930366476, 0.18114271269123716, 0.1864185892725796, 0.18192245691067865, 0.35779869916747975, 0.16684637162973104, 0.28272167927540803, 0.29541135182424305, 0.1967537324467027, 0.2516141552925325, 0.36190775565681166, 0.14325897073527316, 0.43314443577646955, 0.3418319483349359, 0.22785657074005194, 0.21714341734692588, 0.2490201284807566, 0.16610234557261117, 0.16963815823098016, 0.20076787516249728, 0.22095899101902017, 0.20015530033183182, 0.19939970369042959, 0.1881893810588845, 0.17938550014554244, 0.18770138376722156, 0.18655917987053194, 0.18067499232951123, 0.17670695162292394, 0.19674633909612105, 0.1866829325445788, 0.10449789277137367, 0.08908523170049465, 0.0762108806612829, 0.1038174783693081, 0.0961200636958498, 0.08658884611988282, 0.07918308017199283, 0.07592188793266319, 0.0834987217417632]}, "mutation_prompt": null}
{"id": "ab8430d6-66df-48cf-8697-11216b065410", "solution": "import numpy as np\n\nclass ImprovedDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.7  # Slightly increased for better personal best attraction\n        self.c2 = 1.3  # Slightly decreased for moderated global best attraction\n        self.w = 0.6  # Reduced inertia to enhance convergence\n        self.f = 0.7  # Increased mutation factor for exploration\n        self.cr = 0.85  # Slightly reduced crossover rate\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.5, self.population_size)  # Increased variability in learning rate\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Adjusted learning rate update\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "ImprovedDualPopulationPSO_DE", "description": "Improved Dual Population PSO-DE with adaptive learning rate, mutation strategy, and diversity preservation.", "configspace": "", "generation": 6, "fitness": 0.2800235347415448, "feedback": "The algorithm ImprovedDualPopulationPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "068c3147-504c-4cc5-bd17-331e924baa36", "metadata": {"aucs": [0.6846575026573216, 0.7085704548305172, 0.7476120996005864, 0.669082279333234, 0.6745494787152762, 0.6639418932297918, 0.6799284586868406, 0.7466262717024217, 0.7264080560580027, 0.38515591884810974, 0.38478990904153365, 0.4046406724352839, 0.4415712942272977, 0.4223835190324825, 0.4276435058564163, 0.4682254974318478, 0.43457732338326494, 0.5107905862652775, 0.11788061846855291, 0.12947575880332984, 0.1135819168817025, 0.13810921202937443, 0.13450402902813452, 0.1303964230326603, 0.11397439452347158, 0.13995483360964878, 0.11531813864769702, 0.10292020120138134, 0.12354345774079067, 0.0969125021628433, 0.10050973437586397, 0.09501163330842977, 0.10207104356739871, 0.1237099553376938, 0.11482141153685665, 0.08666216181931419, 0.8022537633247198, 0.7477360688917258, 0.6134996059086129, 0.7736154923631885, 0.858465170342685, 0.7437824343844526, 0.7404184315952401, 0.8092470447688573, 0.9056722176069523, 0.2441700266038187, 0.19553215053805073, 0.19436795406315222, 0.2202133449688649, 0.22180044559954737, 0.11294542731520907, 0.19476582029658096, 0.13966636427641332, 0.26227365511487866, 0.7368488275124183, 0.6412831548107789, 0.6119903407580125, 0.7188824581365644, 0.6625778770143476, 0.6303062143399221, 0.6607907345891655, 0.23032800468019077, 0.6015719420260486, 0.14031724559115355, 0.18238457020487975, 0.16545219928522126, 0.16479590702799618, 0.16893805679420693, 0.12021500692054654, 0.14690156313548997, 0.17192485513722566, 0.17732663360922685, 0.17981586873807753, 0.14032727543718015, 0.16566236470372042, 0.15520445778088166, 0.20350259561549222, 0.12582857045033546, 0.1672528474131788, 0.15925677622765833, 0.12685937073693898, 0.0831155398034793, 0.002139692486424094, 0.08331291062679225, 0.11723264948380674, 0.12141922199974309, 0.12360870683111103, 0.12396550593919053, 0.11825170160039777, 0.0404283729819539, 0.23521375019757873, 0.16958870240367396, 0.16827481864060012, 0.17153346822146354, 0.15101198733631138, 0.18731887111428913, 0.21367005706529074, 0.256209648571073, 0.21969169910621278, 0.041435070962683285, 0.1190249567043562, 0.11312013900847373, 0.1219990430127964, 0.2057200172492505, 0.18889089482879595, 0.11817569611773104, 0.11773701782453005, 0.0954193899204987, 0.18386184602742883, 0.152604268405529, 0.1811334085487767, 0.21854174994439035, 0.1557896039619091, 0.15842767166685245, 0.10714735007540876, 0.1729282899035799, 0.10404275282266595, 0.5294962000962177, 0.5457119150235494, 0.5355783006543181, 0.49917760382814147, 0.5071073804369791, 0.5177973515218929, 0.5011434347831862, 0.5680641051750448, 0.5254632305963554, 0.0929697520697007, 0.12471004230599225, 0.1164203683418864, 0.12965207102720488, 0.10393063264515601, 0.13142898936774472, 0.15989802680310772, 0.09547868062403664, 0.09493638207267008, 0.21871549596807427, 0.14991669626540338, 0.2319951611385529, 0.20053152431498789, 0.16474164115445034, 0.21650910854023842, 0.22050619375010405, 0.17975746993182695, 0.280112309210506, 0.3168419155987463, 0.31743710278124004, 0.3341955432226206, 0.3266647002745905, 0.36865246440142463, 0.34610445993419003, 0.35940317910092556, 0.3728953007304908, 0.3698660603757913, 0.2548286575401403, 0.3077189489892085, 0.25465547032328195, 0.24468403967710028, 0.29424883564255955, 0.2694106196552718, 0.2559233838633772, 0.2580818625936525, 0.2517592139270567, 0.22660840953066375, 0.2236951194098199, 0.21747244593190762, 0.2027962823185132, 0.21862881618755137, 0.20699410835294396, 0.2634706868800356, 0.21345012040351052, 0.20389174934011844, 0.17795582890014816, 0.1954916717018237, 0.19764382686714577, 0.22501156877442685, 0.18932575785622596, 0.18099126090039297, 0.1858951751523238, 0.20252979688147255, 0.1960983166277377, 0.4143412140257432, 0.7112460380379941, 0.1857374039454508, 0.7304992158969225, 0.3808342018634483, 0.16702635929718668, 0.7187269743631637, 0.16714224934242594, 0.17411077315438506, 0.4566527765547679, 0.20892293769050485, 0.31728340729690996, 0.5012854624224033, 0.19484548775801291, 0.32125519359023746, 0.16693753631969666, 0.2732206708481022, 0.4235328827896553, 0.19115042351613498, 0.18321965195947032, 0.18254734825589092, 0.18685659417767997, 0.21432451393080465, 0.1935409560707798, 0.17746246311559322, 0.1868050204151971, 0.19069431632362444, 0.10885334389298351, 0.09600954140982798, 0.10256340949948828, 0.09515466857067112, 0.0904878746132628, 0.09130927035352487, 0.09228531763726477, 0.08886283407880147, 0.08681264741440098]}, "mutation_prompt": null}
{"id": "254a9f24-df60-4a8e-af12-b81ef0635331", "solution": "import numpy as np\n\nclass AdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.f = 0.6\n        self.cr = 0.9\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.4, self.population_size)\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.8 * self.learning_rate[i] + 0.2 * np.random.rand()\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveDualPopulationPSO_DE", "description": "Adaptive Dual Population PSO-DE with Learning Rate and Memory for enhanced exploitation and exploration.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "068c3147-504c-4cc5-bd17-331e924baa36", "metadata": {"aucs": [0.7172783112882128, 0.8005173254138069, 0.8419238320105469, 0.7934131042324888, 0.8053440706043299, 0.8052018604621682, 0.8131443467289539, 0.6852814065244538, 0.7633599595347212, 0.5398555260316387, 9.999999999998899e-05, 0.029840761150403572, 0.5560996795991064, 0.44674755777613195, 0.6655669817661867, 0.46019642916736525, 0.4406894605807483, 0.3805693686396494, 0.15106329867698443, 0.14075634561835726, 0.12865704820922752, 0.140744114360146, 0.14749768661965967, 0.1350268205769415, 0.1187721177882699, 0.1769607064321983, 0.14038493390454865, 0.11159079037802055, 0.12597658792292732, 0.10857535476968894, 0.1309590110023513, 0.10684384452229534, 0.10102627990735613, 0.13624468807920365, 0.11426219637690105, 0.12623602004788825, 0.7761434343248741, 0.7263738726661731, 0.8204557392546254, 0.8590516219328831, 0.814391137101437, 0.7966039061889074, 0.690029808926361, 0.7849200335438947, 0.7956618410800244, 0.21945269520809751, 0.19093995239191663, 0.21876206757496053, 0.24685187189415747, 0.28955039869336385, 0.18409003675899915, 0.2595779375666175, 0.16641073793891226, 0.269857390417097, 0.3264850918911426, 0.34547919897193535, 0.214227304401574, 0.31819155638800056, 0.6450944015863356, 0.5047311157751238, 0.6369299977374961, 0.8055950521559293, 0.7532298469877291, 0.3718988222840327, 0.20607012475252784, 0.21308982778097074, 0.13176362941683506, 0.12094394764834238, 0.1390119063358195, 0.2481174510166848, 0.46899276415429236, 0.15068489754327496, 0.19313511606810851, 0.1411845868143753, 0.14960968766923088, 0.35901342758401966, 0.18518295537585405, 0.13935649163772923, 0.15595243470305742, 0.2457145641744769, 0.1304030209030056, 0.0010767780370090074, 0.032866235479313, 0.18586268074411405, 0.1124073297408682, 0.05285867974082159, 0.1933427734194958, 0.22767283545378236, 0.023810405969262316, 0.014372656764836012, 0.18704085838929818, 0.10039333001069595, 0.11633604527965924, 0.2522564011964339, 0.168997192976017, 0.17067266671612413, 0.25654935887187125, 0.14825706032215913, 0.20813916562979562, 0.15256935681070705, 0.11219229201815939, 0.25759399779037895, 0.11247651319527818, 0.19659464824367323, 0.17077130604322588, 0.16539333560999858, 0.21185774024763404, 0.1504038433829874, 0.2273195253391216, 0.2012974907749321, 0.24967377997506912, 0.22873155906738052, 0.13044679310024, 0.15793635665947436, 0.10625468372245728, 0.10064794598099125, 0.10765528359410892, 0.5701644192853659, 0.6123978461037856, 0.6022552781356649, 0.5235623994307104, 0.5320314681756232, 0.5671249673610208, 0.5549063242462009, 0.5918918040310328, 0.5613656586575042, 0.139147363449712, 0.1070980692722977, 0.09704118988934662, 0.11316440794618665, 0.12439728435178099, 0.11314342979385783, 0.14012134496459583, 0.12002501679880229, 0.15546120071050096, 0.20793421762149078, 0.16693604270993379, 0.17012990217872415, 0.21243768259623408, 0.19569687555963666, 0.15691523465698065, 0.2208237300098026, 0.1677030160440709, 0.19406007742559228, 0.3938517726615418, 0.3637565338927329, 0.3398113110420784, 0.37692380406181114, 0.38936024772274835, 0.36783927960468643, 0.4227812659426743, 0.3745378703207184, 0.4364480809807332, 0.28362755188298816, 0.29939846045769714, 0.25834346405998665, 0.19003411321351982, 0.29513009270042734, 0.3668036680608604, 0.28076059066603043, 0.30815915958109985, 0.32851851586626135, 0.2129932620516266, 0.22250869971777187, 0.3300973578226356, 0.21150597333827048, 0.2057171852680888, 0.21045592503752242, 0.20268786274781736, 0.22755609524787535, 0.2525574149052139, 0.19492449903545972, 0.2028082906227907, 0.19918579146807314, 0.20217381364517462, 0.21787034269169614, 0.22742582440726888, 0.20278833545033026, 0.20150475995456985, 0.20734535707788904, 0.1843817462729498, 0.7709369089345819, 0.18488892790423161, 0.7491604928892552, 0.1979623702741774, 0.19620942866627789, 0.8412397668935585, 0.21739814159719528, 0.6768391903539129, 0.27499436501716934, 0.20485905120904746, 0.63078074748776, 0.20535172799260304, 0.3092328927568746, 0.19856339905365827, 0.20613531070672242, 0.1646405658737654, 0.20798523522487722, 0.18282957220776552, 0.18304652820063716, 0.1965755906419312, 0.18487397495823776, 0.19180490995887334, 0.19318859711519287, 0.18409136026379536, 0.18334235307755442, 0.18891312565162632, 0.1000008042925814, 0.08642654199831179, 0.1279911289225285, 0.10490526245311271, 0.08991992412777439, 0.0959997767009918, 0.08105189476887242, 0.08746453858539083, 0.09616191271009555]}, "mutation_prompt": null}
{"id": "78f20bde-7466-4177-9db4-e24e46d8e4f0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 2.0  # Increased acceleration coefficient for cognitive component\n        self.c2 = 2.0  # Increased acceleration coefficient for social component\n        self.w = 0.5  # Reduced inertia weight for more convergence\n        self.f = 0.8  # Increased mutation factor for diversity\n        self.cr = 0.8  # Slightly reduced crossover rate for more DE exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.5, self.population_size)  # Adjusted learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Slower learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Learning Rate and Adaptive Parameter Control for balanced exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.29061899882532133, "feedback": "The algorithm EnhancedAdaptiveDualPopulationPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "068c3147-504c-4cc5-bd17-331e924baa36", "metadata": {"aucs": [0.7781264411701477, 0.6594710346474217, 0.692041589304407, 0.7000804180612588, 0.7755107220492174, 0.7113416529942512, 0.6769253283227588, 0.6794966354726382, 0.8550708213994894, 0.38354174621602677, 0.4296402499267298, 0.45339437428357265, 0.41649716403078796, 0.41700774355773806, 0.37314302314812764, 0.7210452451435263, 0.456390760701326, 0.40228992053211554, 0.13306547230206234, 0.1193751824168865, 0.13253391633480327, 0.14817472267086473, 0.2050188411917656, 0.14087481334590224, 0.22841417145896425, 0.1392768748540546, 0.1316358009840991, 0.10488766279388984, 0.12921400904557978, 0.10568504207254514, 0.10370655018907349, 0.12638707053354503, 0.11269882505706286, 0.10434879321619372, 0.10173917078036843, 0.10494497366395605, 0.797429920608915, 0.7820286294033736, 0.821841730232983, 0.7743403113850984, 0.7855626558746939, 0.8073864043314272, 0.841852844722025, 0.828877587906986, 0.8739377559387752, 0.3072047495789204, 0.2827155775027792, 0.22260776539631122, 0.21616582289263364, 0.27130563514862327, 0.2433391595437795, 0.27211237561942114, 0.26229619272776417, 0.23362794855496172, 0.5741693779838124, 0.47017082017814893, 0.440925545426301, 0.6226223562517037, 0.5517757929507401, 0.6162109193812983, 0.5443136408798961, 0.533309144566064, 0.5346730989183532, 0.22273251342131895, 0.1543851055709854, 0.16732994705246218, 0.13605535734392527, 0.1805735423222271, 0.14375984685458665, 0.15831637970695522, 0.28017003212945724, 0.160964931656842, 0.1678830217046836, 0.14732554153356037, 0.12630414562780368, 0.1639330658736391, 0.1675852829144293, 0.1621752643266411, 0.19953033098929762, 0.19447999060249987, 0.17568580063287864, 0.08968240369266656, 0.08403186509444882, 0.052495072870491044, 0.09086836285696376, 0.1077408291278954, 0.07933276615253382, 0.03774769903891484, 0.10412041731565769, 0.053132847546516815, 0.18833248440598227, 0.18294905210665235, 0.16578148108426427, 0.09717040833347879, 0.08520076169239421, 0.173565929594109, 0.19570040460728355, 0.20653890519764417, 0.19744278895448675, 0.2771243084984908, 0.14874061222204493, 0.030753677842778826, 0.13013182910281462, 0.1936112647402094, 0.18024514882169784, 0.152776094276878, 0.25604886812517813, 0.03925042190495609, 0.13085379366098693, 0.17410934808662315, 0.17102825541229905, 0.26008884589398806, 0.17797158274777525, 0.1673877925769962, 0.17409170018329678, 0.13104716509120662, 0.1412283579105913, 0.5324299559974128, 0.5417623823929947, 0.5359004392612996, 0.501972768564001, 0.49198723972344127, 0.4999485171874354, 0.5364757570360098, 0.5214888133026655, 0.5120472936576226, 0.10740727879350398, 0.1343558922856981, 0.10494809249047576, 0.09549738987589895, 0.1106743977122786, 0.1278961171204146, 0.1433255237737332, 0.13630215732938433, 0.10322939123801445, 0.1959709753714428, 0.2691284409798145, 0.2096062047117655, 0.19700700903934143, 0.23165055214647234, 0.17520792214478642, 0.21067960923585027, 0.17066680863470007, 0.21299539172652227, 0.3332208390113558, 0.31948096876667464, 0.3459860722082373, 0.33175545205315604, 0.36151875667039934, 0.32355270529879177, 0.35809983163032233, 0.334180973120908, 0.3237575521285362, 0.23011649046086613, 0.23348972896667064, 0.25769424249754336, 0.2587106142777116, 0.25215984871920416, 0.23424625057011494, 0.2384188835539528, 0.2515381978224911, 0.28846198524413, 0.22944956304259945, 0.2647110659316442, 0.21300501207230382, 0.22932285573480393, 0.21700345088663509, 0.2369935044262409, 0.25164039970910357, 0.21325065014189104, 0.28829343655396356, 0.20025091637007375, 0.19833485240951387, 0.19704466294198564, 0.18792983350343706, 0.1985498028170708, 0.22623797061947803, 0.17700213985280466, 0.19325155043300413, 0.24308971392059409, 0.8977046731002438, 0.45070703322613215, 0.6473175642993079, 0.75055626531592, 0.3736997845848208, 0.19712055474773793, 0.5846642328655968, 0.17627267898632837, 0.5975860998268197, 0.40692345627309257, 0.4704565916410901, 0.3869962465645903, 0.2658391345136789, 0.1735861018967627, 0.20396874510760354, 0.2605301065043708, 0.3297429064690848, 0.4195657297482013, 0.19908115643531932, 0.18352762980699255, 0.18650896760877955, 0.1972122863700313, 0.18029022062706357, 0.19405238960882265, 0.19405330774951357, 0.20124422612022286, 0.23901306109453113, 0.09571675490662801, 0.09849364802702998, 0.09582588056446695, 0.09447328341729322, 0.09792283185697837, 0.09419650813342684, 0.08163275044045126, 0.09817296022302657, 0.09342070669191704]}, "mutation_prompt": null}
{"id": "927ae4e3-c3c4-47c2-b51b-e211b99eda13", "solution": "import numpy as np\n\nclass HybridQuantumGradientPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 1.5  # Adjusted acceleration coefficient for social component\n        self.w = 0.4  # Further reduced inertia weight\n        self.f = 0.7  # Modified mutation factor\n        self.cr = 0.9  # Increased crossover rate for better exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Narrowed learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def quantum_inspired_update(self, position, best_position):\n        return 0.5 * (position + best_position) + np.random.uniform(-0.1, 0.1, self.dim)\n\n    def gradient_assist(self, func, position):\n        epsilon = 1e-8\n        gradient = np.zeros(self.dim)\n        for j in range(self.dim):\n            perturb = np.zeros(self.dim)\n            perturb[j] = epsilon\n            gradient[j] = (func(position + perturb) - func(position - perturb)) / (2 * epsilon)\n        return gradient\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.85 * self.learning_rate[i] + 0.15 * np.random.rand()  # Adaptation with memory\n                gradient = self.gradient_assist(func, self.positions_pso[i])\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                    - 0.01 * gradient  # Gradient influence\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.quantum_inspired_update(self.positions_pso[i] + self.velocities[i], self.global_best_position),\n                    self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "HybridQuantumGradientPSO_DE", "description": "Hybrid Quantum-Inspired Gradient-Assisted PSO-DE with Adaptive Memory and Dynamic Parameters for enhanced convergence and solution quality.", "configspace": "", "generation": 9, "fitness": 0.11100465562193877, "feedback": "The algorithm HybridQuantumGradientPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.09.", "error": "", "parent_id": "78f20bde-7466-4177-9db4-e24e46d8e4f0", "metadata": {"aucs": [0.2997768729820468, 0.3230536151182887, 0.3720751272129589, 0.20794174707060298, 0.1727789440461236, 0.20542604747907744, 0.1887716445173686, 0.21994994066192675, 0.17059979643158496, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08178405767601249, 0.0645414701428112, 0.05725065678797092, 0.07925736443427722, 0.0522260446805316, 0.0657041264387761, 0.07997884363816865, 0.11842228195477089, 0.07217372270207911, 0.05800510627800526, 0.055429646904198826, 0.042002532445548635, 0.07054415891079646, 0.06115247975369098, 0.03885435956933325, 0.05011809223750152, 0.06863424824269004, 0.05726345371450259, 0.0645473614476808, 0.08034261617002936, 0.11655346988399928, 0.08569899795592917, 0.07722515208961378, 0.09443880647657588, 0.08140655403115737, 0.07771196281416382, 0.08926005751085053, 0.06955676679720058, 0.0631492177674432, 0.01901977286120038, 0.08599270988862484, 0.13054944579375882, 0.04232119691157443, 0.04702520811127675, 0.042440011591307614, 0.07273497404413776, 0.16285679424527966, 0.21220184402522702, 0.1425382831667199, 0.16010890734633254, 0.14576445708070784, 0.13662444160835963, 0.1426272924037999, 0.17197095279453045, 0.13482440399492224, 0.017721420304261715, 0.030042445680264374, 0.0017435271474595115, 9.999999999998899e-05, 0.023928503859665384, 0.02015831211752861, 0.09552376356559522, 0.04054695351891047, 0.09963749664232235, 0.08713856549755494, 0.02403396329249885, 0.052790261849507414, 0.07290546213178128, 0.07716181546751288, 0.08812066085169168, 0.09553728253027971, 0.05143176456431198, 0.03842250796450131, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006973962033901215, 9.999999999998899e-05, 0.05022724264818501, 0.022456865452560093, 0.058872224629765824, 0.02783363185194687, 0.03867418384011523, 0.022883652483348338, 0.02429681269152062, 0.04729946491874215, 0.04399040984965108, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03637467428603791, 0.07188494340127238, 0.04227767590188303, 0.015605997559162144, 0.06630407977344022, 0.0678903632330381, 0.04816701211464336, 0.05578177236258797, 0.05095627416160042, 0.34093201672249485, 0.31328054363319324, 0.29468799969999704, 0.22336754013731752, 0.25000185640723704, 0.22295561158491972, 0.3589506679762541, 0.2525702493639449, 0.3315510085087995, 0.06035180898558734, 0.04426646661117917, 0.04805179001888593, 0.09123789949910355, 0.08130968621698298, 0.07372999392304702, 0.0622620917855633, 0.05936964396677691, 0.09747555448871803, 0.11613822519592265, 0.11806971329088478, 0.11842189604885467, 0.1376628278530545, 0.10852978091233834, 0.12788544015936076, 0.10291643681706686, 0.11411251702559655, 0.11168048677205622, 0.2206776719034147, 0.19395503481878773, 0.21834339123736568, 0.23057450240756083, 0.23131664666331975, 0.19281207588770843, 0.21802097000926446, 0.22963639034771255, 0.165209281682972, 0.1684635011914981, 0.16469518244740755, 0.16413464410770762, 0.1802466895833642, 0.1243880033797814, 0.1769960065718853, 0.17690976237454292, 0.13647495585079672, 0.14554153795543756, 0.1429391738043181, 0.14103060704411652, 0.1526243201751597, 0.13797648431195608, 0.1383665035114625, 0.1317679284458798, 0.14155320491858603, 0.1563911615938095, 0.14521094087764685, 0.15464425165944018, 0.1399358773126279, 0.15006975817480017, 0.1319086802601892, 0.15834066526577262, 0.1432726919300672, 0.14623780917744666, 0.13272750157292246, 0.1226405636460891, 0.22410594291656694, 0.1760279488296732, 0.1777380771713417, 0.3773176794171964, 0.18169823011008468, 0.17851027006361841, 0.1368707061209692, 0.26659385903749977, 0.5279252563572174, 0.32213855551818205, 0.19753029329917848, 0.18223252155996583, 0.15851351824400395, 0.137542099778744, 0.11954881622273839, 0.1658219880425773, 0.1657873755241006, 0.30161811886130363, 0.155154478635815, 0.17373716537563633, 0.16321931694516822, 0.16084132469795653, 0.16116655495716403, 0.16506625757626192, 0.16382544060403292, 0.16182614120129635, 0.17971891264322915, 0.04846270643555928, 0.049641412756169845, 0.06213637382617543, 0.06330792320894563, 0.05560935828777769, 0.06364363253027094, 0.05315697838056588, 0.06758984880190433, 0.06207241366883043]}, "mutation_prompt": null}
{"id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.5  # Adjusted acceleration coefficient for social component\n        self.w = 0.6  # Slightly increased inertia weight for better balance\n        self.f = 0.7  # Reduced mutation factor for controlled diversity\n        self.cr = 0.9  # Increased crossover rate for higher DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for finer control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.85 * self.learning_rate[i] + 0.15 * np.random.rand()  # Slightly faster learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Exploration and Adaptive Mutation for more efficient optimization across diverse problems.", "configspace": "", "generation": 10, "fitness": 0.31949915381346733, "feedback": "The algorithm EnhancedAdaptiveDualPopulationPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "78f20bde-7466-4177-9db4-e24e46d8e4f0", "metadata": {"aucs": [0.8525777030373791, 0.8516342117807258, 0.8454112583762484, 0.829800498231355, 0.8273379272538617, 0.8502415979032695, 0.8396695115252604, 0.7180401259661296, 0.8453029843456508, 0.421377285759136, 0.5372801402543462, 0.4407040333051703, 0.4737886227395577, 0.6559256873705004, 0.5350881673421242, 0.47374367263307426, 0.6261315808593853, 0.6336242509014283, 0.18225416860893806, 0.12405560243771652, 0.12240421895244347, 0.15341666132829346, 0.11394029189033028, 0.11482764537514101, 0.13116720474273713, 0.13078092319622314, 0.6630099728615091, 0.11711978260183564, 0.12237465181412532, 0.1085529482296328, 0.10676953741716111, 0.07937333271439728, 0.10582854159649047, 0.11027412624252608, 0.1158594023192947, 0.12514621982497887, 0.8063604102139781, 0.7856460381281206, 0.8111479480162114, 0.8387985070199409, 0.8331714799748353, 0.8641853988261313, 0.7971629777411295, 0.8926278265739103, 0.8265795636915176, 0.316737917511392, 0.2939033145401453, 0.1852791485932438, 0.22215747476543546, 0.3300228205920652, 0.21047775993719242, 0.3337476153649124, 0.2448397864605557, 0.3468727115764363, 0.6736072902656614, 0.701043042875904, 0.6473807340574171, 0.7506348989976774, 0.7602094961121924, 0.681014663957023, 0.6186969980060584, 0.6491888106093351, 0.7274334115488809, 0.15491843406658679, 0.18431979200858917, 0.1627812623082393, 0.17731648643985487, 0.24892600807027587, 0.1270966034898181, 0.21184704870728344, 0.4562388681919438, 0.15064812268674654, 0.23100511256937162, 0.16289534990952215, 0.12606789561986131, 0.21639850507523328, 0.14012499635144593, 0.19184465959523445, 0.20229587330447518, 0.19734037499096924, 0.29165620336433895, 0.21398297840068858, 0.019739492553785043, 0.044120787908873194, 0.10060979266099224, 0.17909102074480376, 0.20041106069861658, 0.21107424250139095, 0.11417360613530947, 0.05890066111567305, 0.14549424437395375, 0.15744230335420795, 0.15024890236679111, 0.13265767342187462, 0.20206276258278533, 0.26966564525885284, 0.3188451589272653, 0.16242154581783375, 0.33090449038754954, 0.1879911351362914, 0.13659632587015236, 0.13490893919103997, 0.13937323226204612, 0.15952571536981797, 0.1582367988252812, 0.16879322248438844, 0.15167585156137797, 0.1367309189969672, 0.22570055386644294, 0.2079132655267858, 0.2729814901218113, 0.248035527272909, 0.1588993812985049, 0.2078409413706479, 0.14972604759920727, 0.14802329828563088, 0.18198564651846671, 0.5383066334097246, 0.6445116643943949, 0.5631841336909126, 0.5120570780257188, 0.5725709592205108, 0.5732386930865558, 0.5641628997289507, 0.5731815754903058, 0.5444207485605908, 0.11563176199514658, 0.10748996525890031, 0.09641500006648052, 0.13198518573238338, 0.08704423660096894, 0.09982856184228062, 0.14970842309603505, 0.10304578064758696, 0.13106311502801604, 0.2646802639595649, 0.13163949229699867, 0.23873631355889258, 0.190422769294044, 0.2505470637128605, 0.17091006676404774, 0.1608920127101392, 0.18475316915187956, 0.23323144037548482, 0.3400241474829686, 0.35030498354817396, 0.35777028112279874, 0.36943258179981087, 0.33983180057387274, 0.33208090049879724, 0.3801033459493227, 0.379683924177425, 0.40018317345887844, 0.3080368275695067, 0.26183020002164326, 0.28846663100474146, 0.27066685557384107, 0.28549980799201524, 0.3038733424798039, 0.2981959017046111, 0.2441575445486288, 0.26113146865187886, 0.2026388371134632, 0.2228046813046305, 0.20966569491529397, 0.19872214562950397, 0.21279568311651254, 0.21322150674566243, 0.21396543244412358, 0.23216589986708513, 0.27030579774428853, 0.21436131033407402, 0.19410913442591105, 0.18710062450515608, 0.19969133764438574, 0.2051609606656435, 0.19572588326966178, 0.1835184908288624, 0.19184472296322042, 0.21214891791657242, 0.6816601443928618, 0.7918349731755097, 0.18779603411738055, 0.9033966563685292, 0.19782048200672553, 0.19699874355653013, 0.8657611366714177, 0.20510063596972128, 0.16500902827640984, 0.6815253542756817, 0.3618233707663435, 0.7199314260481589, 0.5821097132372577, 0.20057868765627918, 0.27917280388837484, 0.23491884892400872, 0.36539278065779834, 0.35541195715341467, 0.19706943596100623, 0.18869969040784385, 0.19614167282777495, 0.20038222034450848, 0.19605191202809857, 0.21763470126155238, 0.20523347134586056, 0.18697947220729239, 0.19759180145926503, 0.08166365202884385, 0.09043989993600265, 0.07735810880224692, 0.1159621139886935, 0.08602975393259837, 0.08930666872511006, 0.09840284798844945, 0.09678169339018516, 0.09469674742457901]}, "mutation_prompt": null}
{"id": "e5b0acce-3ffc-4524-9bfe-5d7857fd8aa4", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyPopulationOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Slightly reduced population size for efficiency\n        self.c1 = 1.4  # Fine-tuned cognitive component\n        self.c2 = 2.4  # Fine-tuned social component\n        self.w = 0.65  # Adjusted inertia weight for optimization balance\n        self.f = 0.8  # Adaptive mutation factor for DE\n        self.cr = 0.8  # Lower crossover rate for diversity\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Lower initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.02, 0.2, self.population_size)  # More restrained learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Modified learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveMultiStrategyPopulationOptimization", "description": "Adaptive Multi-Strategy Population Optimization (AMPO) with Dynamic Interaction and Learning Rate Adjustment for versatile performance across diverse black-box problems.", "configspace": "", "generation": 11, "fitness": 0.3044324685268509, "feedback": "The algorithm AdaptiveMultiStrategyPopulationOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.7983487611446087, 0.7126013858486651, 0.7774941285897253, 0.7966826338700189, 0.8324694260726766, 0.7943422693410017, 0.8425253518746997, 0.7497432030608384, 0.7200307624888698, 0.5576261060701755, 0.5243821943474565, 0.6147377748561997, 0.564398312053125, 0.5141686900145843, 0.6173943196482221, 0.5965644266078995, 0.6310463171902533, 0.6209990426257279, 0.13575057610714647, 0.15005058149288486, 0.13380074951748633, 0.1269506881721687, 0.5243668416603882, 0.11037373924511162, 0.15218605956224673, 0.14061277201233313, 0.14060239425578314, 0.12932894644517978, 0.11271441898104384, 0.11307090540601783, 0.13366402233820607, 0.13555567506761312, 0.10539961115933816, 0.11064656146535434, 0.106745397188304, 0.11994715613726259, 0.8679144572061133, 0.8207392653645722, 0.8504325982951965, 0.7501522049670423, 0.9038189430256933, 0.8488003264441091, 0.8164560932832156, 0.858714691084311, 0.8673085393513721, 0.35165465195740475, 0.3117305381673714, 0.1202114230735073, 0.34674337254815524, 0.21767157416044125, 0.31675113195007576, 0.29449477275585845, 0.2983172338921125, 0.3177667270765794, 0.5400134253720157, 0.6314095728151579, 0.6446259678010386, 0.7945445217409259, 0.33244974835369534, 0.5020305040076296, 0.7126789464961809, 0.24018011502022196, 0.7238318793827211, 0.28372837853534494, 0.2920127806007945, 0.19604636412977494, 0.23140227703241767, 0.18253975233394926, 0.34998517308562727, 0.16746802082116685, 0.26217435484004237, 0.1436152998913638, 0.22499461627533812, 0.23662732965952316, 0.18092893392982567, 0.20150991848043887, 0.16596731036573542, 0.16733279647706822, 0.19660148244977604, 0.1791341914375718, 0.186179466556316, 0.14794878540194112, 9.999999999998899e-05, 0.10895625897241157, 0.05832215151040021, 0.07412236648240211, 0.07691100865303468, 0.17631086147366914, 0.12148078314182964, 0.07768216865442368, 0.16225811367696474, 0.11962632936609063, 0.2313114402981895, 0.19291817715895632, 0.21903702626379395, 0.22222507845358608, 0.21754992427664777, 0.2598343965505676, 0.1508884401755558, 0.05568051696847032, 0.11176659493388708, 0.09536919946583677, 0.15445866697838317, 0.12195969117882344, 0.12017530621879813, 0.07978627758546686, 0.30433053129952425, 0.091966277398418, 0.16320547004866381, 0.1371676280984997, 0.16052398132653922, 0.1561379212128593, 0.16391323754099363, 0.19725544153541275, 0.17863550084610613, 0.14991149637472956, 0.1327697699917586, 0.5570893021742112, 0.5037678810440858, 0.494649669622099, 0.4930397828866193, 0.5161110867343854, 0.5243774581709618, 0.5706633465084441, 0.5493550794998213, 0.5424833969057832, 0.1287432503871918, 0.10675570825892633, 0.13393300810329833, 0.11949741354446763, 0.10801242583815907, 0.1443870955288612, 0.09515173098739127, 0.13265842477147638, 0.12387196348776142, 0.1984764151639815, 0.25047240083011446, 0.17038128394560026, 0.14801099306218424, 0.2536348388584837, 0.17778322128575164, 0.23124839973089273, 0.20521835532872723, 0.17358434056990568, 0.32544313566776817, 0.3562738322368497, 0.36090533623013066, 0.3606339932586434, 0.3693520686537769, 0.3553347318093597, 0.38585351703119375, 0.38543924676772656, 0.3497465398789874, 0.2851365005305525, 0.23795020119423194, 0.285993561989056, 0.26719183915693734, 0.28103664347145096, 0.2617314286844612, 0.23013442297615994, 0.30665422770069417, 0.2545252697045738, 0.24321686730434167, 0.2090086854984835, 0.2204260850839278, 0.25640125335038466, 0.2094245928810291, 0.23026177451618157, 0.2674352594577276, 0.2216530927414062, 0.21132503346984666, 0.19696967192410775, 0.21555591694757748, 0.2170556627954512, 0.21180384386649376, 0.22604387913494783, 0.21907342533808638, 0.18628016839297867, 0.21552097273772375, 0.21023829319053344, 0.5340532993616047, 0.18652449786191505, 0.16970020170492373, 0.462046048306053, 0.19838811215301044, 0.6526473533308974, 0.20244355235697997, 0.19306372126382754, 0.44707063075320097, 0.6582226914776605, 0.5667123019883127, 0.3802620976910085, 0.5543980612160542, 0.1839950391969405, 0.16582536983236174, 0.2696695531254949, 0.1646660694376726, 0.48033664884414495, 0.21004052626945502, 0.17612285705742192, 0.22741793612298944, 0.23459533667413945, 0.18939828337272724, 0.1784622773792678, 0.1810253579872495, 0.21543833118445566, 0.20522029756073246, 0.08828060441740093, 0.09379433992373631, 0.13533727900964165, 0.1055820365839274, 0.09464181479381184, 0.10400156609479616, 0.11101861308568728, 0.10256502277613366, 0.08454552887374289]}, "mutation_prompt": null}
{"id": "76c6f962-1a3c-41de-a322-694b30a9adf2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.5  # Adjusted acceleration coefficient for social component\n        self.w = 0.6  # Slightly increased inertia weight for better balance\n        self.f = 0.7  # Reduced mutation factor for controlled diversity\n        self.cr = 0.9  # Increased crossover rate for higher DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for finer control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.85 * self.learning_rate[i] + 0.15 * np.random.rand()  # Slightly faster learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Exploration and Adaptive Mutation for more efficient optimization across diverse problems.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8525777030373791, 0.8516342117807258, 0.8454112583762484, 0.829800498231355, 0.8273379272538617, 0.8502415979032695, 0.8396695115252604, 0.7180401259661296, 0.8453029843456508, 0.421377285759136, 0.5372801402543462, 0.4407040333051703, 0.4737886227395577, 0.6559256873705004, 0.5350881673421242, 0.47374367263307426, 0.6261315808593853, 0.6336242509014283, 0.18225416860893806, 0.12405560243771652, 0.12240421895244347, 0.15341666132829346, 0.11394029189033028, 0.11482764537514101, 0.13116720474273713, 0.13078092319622314, 0.6630099728615091, 0.11711978260183564, 0.12237465181412532, 0.1085529482296328, 0.10676953741716111, 0.07937333271439728, 0.10582854159649047, 0.11027412624252608, 0.1158594023192947, 0.12514621982497887, 0.8063604102139781, 0.7856460381281206, 0.8111479480162114, 0.8387985070199409, 0.8331714799748353, 0.8641853988261313, 0.7971629777411295, 0.8926278265739103, 0.8265795636915176, 0.316737917511392, 0.2939033145401453, 0.1852791485932438, 0.22215747476543546, 0.3300228205920652, 0.21047775993719242, 0.3337476153649124, 0.2448397864605557, 0.3468727115764363, 0.6736072902656614, 0.701043042875904, 0.6473807340574171, 0.7506348989976774, 0.7602094961121924, 0.681014663957023, 0.6186969980060584, 0.6491888106093351, 0.7274334115488809, 0.15491843406658679, 0.18431979200858917, 0.1627812623082393, 0.17731648643985487, 0.24892600807027587, 0.1270966034898181, 0.21184704870728344, 0.4562388681919438, 0.15064812268674654, 0.23100511256937162, 0.16289534990952215, 0.12606789561986131, 0.21639850507523328, 0.14012499635144593, 0.19184465959523445, 0.20229587330447518, 0.19734037499096924, 0.29165620336433895, 0.21398297840068858, 0.019739492553785043, 0.044120787908873194, 0.10060979266099224, 0.17909102074480376, 0.20041106069861658, 0.21107424250139095, 0.11417360613530947, 0.05890066111567305, 0.14549424437395375, 0.15744230335420795, 0.15024890236679111, 0.13265767342187462, 0.20206276258278533, 0.26966564525885284, 0.3188451589272653, 0.16242154581783375, 0.33090449038754954, 0.1879911351362914, 0.13659632587015236, 0.13490893919103997, 0.13937323226204612, 0.15952571536981797, 0.1582367988252812, 0.16879322248438844, 0.15167585156137797, 0.1367309189969672, 0.22570055386644294, 0.2079132655267858, 0.2729814901218113, 0.248035527272909, 0.1588993812985049, 0.2078409413706479, 0.14972604759920727, 0.14802329828563088, 0.18198564651846671, 0.5383066334097246, 0.6445116643943949, 0.5631841336909126, 0.5120570780257188, 0.5725709592205108, 0.5732386930865558, 0.5641628997289507, 0.5731815754903058, 0.5444207485605908, 0.11563176199514658, 0.10748996525890031, 0.09641500006648052, 0.13198518573238338, 0.08704423660096894, 0.09982856184228062, 0.14970842309603505, 0.10304578064758696, 0.13106311502801604, 0.2646802639595649, 0.13163949229699867, 0.23873631355889258, 0.190422769294044, 0.2505470637128605, 0.17091006676404774, 0.1608920127101392, 0.18475316915187956, 0.23323144037548482, 0.3400241474829686, 0.35030498354817396, 0.35777028112279874, 0.36943258179981087, 0.33983180057387274, 0.33208090049879724, 0.3801033459493227, 0.379683924177425, 0.40018317345887844, 0.3080368275695067, 0.26183020002164326, 0.28846663100474146, 0.27066685557384107, 0.28549980799201524, 0.3038733424798039, 0.2981959017046111, 0.2441575445486288, 0.26113146865187886, 0.2026388371134632, 0.2228046813046305, 0.20966569491529397, 0.19872214562950397, 0.21279568311651254, 0.21322150674566243, 0.21396543244412358, 0.23216589986708513, 0.27030579774428853, 0.21436131033407402, 0.19410913442591105, 0.18710062450515608, 0.19969133764438574, 0.2051609606656435, 0.19572588326966178, 0.1835184908288624, 0.19184472296322042, 0.21214891791657242, 0.6816601443928618, 0.7918349731755097, 0.18779603411738055, 0.9033966563685292, 0.19782048200672553, 0.19699874355653013, 0.8657611366714177, 0.20510063596972128, 0.16500902827640984, 0.6815253542756817, 0.3618233707663435, 0.7199314260481589, 0.5821097132372577, 0.20057868765627918, 0.27917280388837484, 0.23491884892400872, 0.36539278065779834, 0.35541195715341467, 0.19706943596100623, 0.18869969040784385, 0.19614167282777495, 0.20038222034450848, 0.19605191202809857, 0.21763470126155238, 0.20523347134586056, 0.18697947220729239, 0.19759180145926503, 0.08166365202884385, 0.09043989993600265, 0.07735810880224692, 0.1159621139886935, 0.08602975393259837, 0.08930666872511006, 0.09840284798844945, 0.09678169339018516, 0.09469674742457901]}, "mutation_prompt": null}
{"id": "84773637-c401-415a-8df4-273344f77dd1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.5  # Adjusted acceleration coefficient for social component\n        self.w = 0.6  # Slightly increased inertia weight for better balance\n        self.f = 0.7  # Reduced mutation factor for controlled diversity\n        self.cr = 0.9  # Increased crossover rate for higher DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for finer control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.85 * self.learning_rate[i] + 0.15 * np.random.rand()  # Slightly faster learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Exploration and Adaptive Mutation for more efficient optimization across diverse problems.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8525777030373791, 0.8516342117807258, 0.8454112583762484, 0.829800498231355, 0.8273379272538617, 0.8502415979032695, 0.8396695115252604, 0.7180401259661296, 0.8453029843456508, 0.421377285759136, 0.5372801402543462, 0.4407040333051703, 0.4737886227395577, 0.6559256873705004, 0.5350881673421242, 0.47374367263307426, 0.6261315808593853, 0.6336242509014283, 0.18225416860893806, 0.12405560243771652, 0.12240421895244347, 0.15341666132829346, 0.11394029189033028, 0.11482764537514101, 0.13116720474273713, 0.13078092319622314, 0.6630099728615091, 0.11711978260183564, 0.12237465181412532, 0.1085529482296328, 0.10676953741716111, 0.07937333271439728, 0.10582854159649047, 0.11027412624252608, 0.1158594023192947, 0.12514621982497887, 0.8063604102139781, 0.7856460381281206, 0.8111479480162114, 0.8387985070199409, 0.8331714799748353, 0.8641853988261313, 0.7971629777411295, 0.8926278265739103, 0.8265795636915176, 0.316737917511392, 0.2939033145401453, 0.1852791485932438, 0.22215747476543546, 0.3300228205920652, 0.21047775993719242, 0.3337476153649124, 0.2448397864605557, 0.3468727115764363, 0.6736072902656614, 0.701043042875904, 0.6473807340574171, 0.7506348989976774, 0.7602094961121924, 0.681014663957023, 0.6186969980060584, 0.6491888106093351, 0.7274334115488809, 0.15491843406658679, 0.18431979200858917, 0.1627812623082393, 0.17731648643985487, 0.24892600807027587, 0.1270966034898181, 0.21184704870728344, 0.4562388681919438, 0.15064812268674654, 0.23100511256937162, 0.16289534990952215, 0.12606789561986131, 0.21639850507523328, 0.14012499635144593, 0.19184465959523445, 0.20229587330447518, 0.19734037499096924, 0.29165620336433895, 0.21398297840068858, 0.019739492553785043, 0.044120787908873194, 0.10060979266099224, 0.17909102074480376, 0.20041106069861658, 0.21107424250139095, 0.11417360613530947, 0.05890066111567305, 0.14549424437395375, 0.15744230335420795, 0.15024890236679111, 0.13265767342187462, 0.20206276258278533, 0.26966564525885284, 0.3188451589272653, 0.16242154581783375, 0.33090449038754954, 0.1879911351362914, 0.13659632587015236, 0.13490893919103997, 0.13937323226204612, 0.15952571536981797, 0.1582367988252812, 0.16879322248438844, 0.15167585156137797, 0.1367309189969672, 0.22570055386644294, 0.2079132655267858, 0.2729814901218113, 0.248035527272909, 0.1588993812985049, 0.2078409413706479, 0.14972604759920727, 0.14802329828563088, 0.18198564651846671, 0.5383066334097246, 0.6445116643943949, 0.5631841336909126, 0.5120570780257188, 0.5725709592205108, 0.5732386930865558, 0.5641628997289507, 0.5731815754903058, 0.5444207485605908, 0.11563176199514658, 0.10748996525890031, 0.09641500006648052, 0.13198518573238338, 0.08704423660096894, 0.09982856184228062, 0.14970842309603505, 0.10304578064758696, 0.13106311502801604, 0.2646802639595649, 0.13163949229699867, 0.23873631355889258, 0.190422769294044, 0.2505470637128605, 0.17091006676404774, 0.1608920127101392, 0.18475316915187956, 0.23323144037548482, 0.3400241474829686, 0.35030498354817396, 0.35777028112279874, 0.36943258179981087, 0.33983180057387274, 0.33208090049879724, 0.3801033459493227, 0.379683924177425, 0.40018317345887844, 0.3080368275695067, 0.26183020002164326, 0.28846663100474146, 0.27066685557384107, 0.28549980799201524, 0.3038733424798039, 0.2981959017046111, 0.2441575445486288, 0.26113146865187886, 0.2026388371134632, 0.2228046813046305, 0.20966569491529397, 0.19872214562950397, 0.21279568311651254, 0.21322150674566243, 0.21396543244412358, 0.23216589986708513, 0.27030579774428853, 0.21436131033407402, 0.19410913442591105, 0.18710062450515608, 0.19969133764438574, 0.2051609606656435, 0.19572588326966178, 0.1835184908288624, 0.19184472296322042, 0.21214891791657242, 0.6816601443928618, 0.7918349731755097, 0.18779603411738055, 0.9033966563685292, 0.19782048200672553, 0.19699874355653013, 0.8657611366714177, 0.20510063596972128, 0.16500902827640984, 0.6815253542756817, 0.3618233707663435, 0.7199314260481589, 0.5821097132372577, 0.20057868765627918, 0.27917280388837484, 0.23491884892400872, 0.36539278065779834, 0.35541195715341467, 0.19706943596100623, 0.18869969040784385, 0.19614167282777495, 0.20038222034450848, 0.19605191202809857, 0.21763470126155238, 0.20523347134586056, 0.18697947220729239, 0.19759180145926503, 0.08166365202884385, 0.09043989993600265, 0.07735810880224692, 0.1159621139886935, 0.08602975393259837, 0.08930666872511006, 0.09840284798844945, 0.09678169339018516, 0.09469674742457901]}, "mutation_prompt": null}
{"id": "a2fe7e3c-6eb1-4369-b8e0-cc3754de3937", "solution": "import numpy as np\n\nclass ImprovedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.6  # Slightly increased cognitive component for better individual exploration\n        self.c2 = 2.4  # Reduced social component for more diversified search\n        self.w = 0.5  # Lower inertia weight for faster convergence\n        self.f = 0.8  # Enhanced mutation factor for wider exploration\n        self.cr = 0.85  # Slightly reduced crossover rate to encourage diversity\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Refined learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.8 * self.learning_rate[i] + 0.2 * np.random.rand()  # Adaptive learning rate with a higher change factor\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "ImprovedHybridPSO_DE", "description": "Improved Hybrid PSO-DE with Adaptive Parameters and Multi-Layered Search for Enhanced Convergence in Diverse Optimization Landscapes.", "configspace": "", "generation": 14, "fitness": 0.3046869571660177, "feedback": "The algorithm ImprovedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8646556301478547, 0.8505282763058776, 0.8570282092079307, 0.8614999665705452, 0.8344835695540371, 0.857080318101322, 0.8409159750008162, 0.8522368180841247, 0.853358054916002, 0.43146494020176573, 0.39304287608352806, 0.6711784460510659, 0.6375173863239704, 0.6890482547483956, 0.5429765584701469, 0.6155165977874129, 0.40331760451782206, 0.5343518679392034, 0.12010748859452158, 0.15321724333999176, 0.11488574416096087, 0.11118384436149009, 0.10882632989635, 0.13953749643764168, 0.14645255414573288, 0.13247666904632138, 0.11881006978590936, 0.12815508244598495, 0.10402678240542285, 0.12118203229663016, 0.10708985570649443, 0.12060337152005196, 0.09723146407961736, 0.14114317164123225, 0.12171446147971887, 0.14005962507051894, 0.8334484494750851, 0.8476638239487917, 0.802105417639811, 0.8144079126777275, 0.9129806081113494, 0.8745217650744946, 0.869313199806901, 0.8800381639412842, 0.9159489378345033, 0.2626345680058061, 0.24920731696427623, 0.28544153331034816, 0.345525817232996, 0.31385943357842694, 0.27529786416609736, 0.3493701794542021, 0.31344332533589936, 0.26504384652066115, 0.5180556023123799, 0.5730471285193752, 0.5452402924098514, 0.7017859663162257, 0.6725788579838197, 0.5430424247313406, 0.6201408994958443, 0.6628796436779528, 0.6162469366789143, 0.18905977048280576, 0.23354208424413392, 0.2041957915722421, 0.14740088630397385, 0.2383176972152914, 0.15833166521747266, 0.18520537007211058, 0.15425618073573566, 0.20937468110823898, 0.21545754749677548, 0.3328376219525929, 0.21537459206862375, 0.2249893593755018, 0.1723314096994727, 0.6128257973190625, 0.14670182008251553, 0.18253877120098827, 0.18395775309125662, 0.09534737109130487, 0.09941105237445935, 0.09949099945652484, 0.07426989005971696, 0.11313997929297626, 0.1425423202222419, 0.059031869164508866, 0.09556586702762093, 0.06680715721423636, 0.2638000360656484, 0.13703208661225885, 0.18347987226099371, 0.19304007664481848, 0.21797744157365373, 0.22219721089982813, 0.21030693380192478, 0.22332532216235035, 0.23750290900985183, 0.09286577103341331, 0.11779868599983434, 0.1451549788048767, 0.11324171294466612, 0.2094189688361462, 0.1580098535294555, 0.12473641351973386, 0.16065658266423144, 0.12141389388052193, 0.21935920939222664, 0.14833327869417356, 0.16372877969833066, 0.13777668695699175, 0.14088932462832637, 0.17297729413710927, 0.13922688471103917, 0.13578963312315406, 0.16544059290244773, 0.5137781832390327, 0.5480872214314227, 0.528573392922767, 0.5506177261849021, 0.5404257519134006, 0.5361751525925726, 0.5689398223358529, 0.5292176364544562, 0.5280534287879494, 0.10789665296803264, 0.1336665722735877, 0.11079588973502974, 0.15455441993648933, 0.12958641405749916, 0.09221121426326484, 0.12753959810423388, 0.11596483574907457, 0.1352357873034774, 0.24506733932736868, 0.17739778415250218, 0.16871639218514234, 0.1998445825205004, 0.190121186265085, 0.2193387268061534, 0.19912178078320886, 0.22597097243816067, 0.1889280887525434, 0.3174472230665, 0.30107394435704105, 0.3647805227574815, 0.30627277391941155, 0.344165561630589, 0.35192581463160866, 0.3286507580568875, 0.3572771049385951, 0.41320606022095174, 0.24686107773186694, 0.23876994916451333, 0.24845690705285128, 0.2543768647627901, 0.27290164023921704, 0.29995510731664843, 0.23515398681106015, 0.30441042362882464, 0.24020138264677937, 0.22060233119381945, 0.2846354300935149, 0.24181180046270112, 0.2424732057611424, 0.21947946806723384, 0.23786599848350876, 0.23903590898012606, 0.2643127310352462, 0.24925487731662488, 0.2020474810661581, 0.2083484769099726, 0.2157077213087668, 0.18527639264325224, 0.22146950889509698, 0.18806935126499902, 0.18944808608058317, 0.3217267908277096, 0.19589247066879323, 0.18926535276166523, 0.18764276629046384, 0.18689663813996082, 0.6315611725087739, 0.19855134053134316, 0.1976899090426325, 0.7635343230340823, 0.16994469841733095, 0.16569268710811047, 0.48906976674376834, 0.21131140135744253, 0.20555588067845676, 0.3680921064395243, 0.22198551855324122, 0.4065225566160676, 0.5331882841139517, 0.34683187716112396, 0.20648316777008258, 0.1855117143121059, 0.21142721647325013, 0.20288943366932055, 0.22166344101326152, 0.19691328887868564, 0.20571723215211524, 0.22017341780075872, 0.21819060653616418, 0.22738670611080702, 0.096128805642413, 0.09522575594330196, 0.09850435906970889, 0.08969309135746284, 0.08757568131670979, 0.09372706634081096, 0.08788796115942366, 0.10167125678296363, 0.08514428729478352]}, "mutation_prompt": null}
{"id": "4c07cb9a-fdfa-4ee3-9e45-b0ec69883848", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.5  # Adjusted acceleration coefficient for social component\n        self.w = 0.6  # Slightly increased inertia weight for better balance\n        self.f = 0.7  # Reduced mutation factor for controlled diversity\n        self.cr = 0.9  # Increased crossover rate for higher DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for finer control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.85 * self.learning_rate[i] + 0.15 * np.random.rand()  # Slightly faster learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Exploration and Adaptive Mutation for more efficient optimization across diverse problems.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8525777030373791, 0.8516342117807258, 0.8454112583762484, 0.829800498231355, 0.8273379272538617, 0.8502415979032695, 0.8396695115252604, 0.7180401259661296, 0.8453029843456508, 0.421377285759136, 0.5372801402543462, 0.4407040333051703, 0.4737886227395577, 0.6559256873705004, 0.5350881673421242, 0.47374367263307426, 0.6261315808593853, 0.6336242509014283, 0.18225416860893806, 0.12405560243771652, 0.12240421895244347, 0.15341666132829346, 0.11394029189033028, 0.11482764537514101, 0.13116720474273713, 0.13078092319622314, 0.6630099728615091, 0.11711978260183564, 0.12237465181412532, 0.1085529482296328, 0.10676953741716111, 0.07937333271439728, 0.10582854159649047, 0.11027412624252608, 0.1158594023192947, 0.12514621982497887, 0.8063604102139781, 0.7856460381281206, 0.8111479480162114, 0.8387985070199409, 0.8331714799748353, 0.8641853988261313, 0.7971629777411295, 0.8926278265739103, 0.8265795636915176, 0.316737917511392, 0.2939033145401453, 0.1852791485932438, 0.22215747476543546, 0.3300228205920652, 0.21047775993719242, 0.3337476153649124, 0.2448397864605557, 0.3468727115764363, 0.6736072902656614, 0.701043042875904, 0.6473807340574171, 0.7506348989976774, 0.7602094961121924, 0.681014663957023, 0.6186969980060584, 0.6491888106093351, 0.7274334115488809, 0.15491843406658679, 0.18431979200858917, 0.1627812623082393, 0.17731648643985487, 0.24892600807027587, 0.1270966034898181, 0.21184704870728344, 0.4562388681919438, 0.15064812268674654, 0.23100511256937162, 0.16289534990952215, 0.12606789561986131, 0.21639850507523328, 0.14012499635144593, 0.19184465959523445, 0.20229587330447518, 0.19734037499096924, 0.29165620336433895, 0.21398297840068858, 0.019739492553785043, 0.044120787908873194, 0.10060979266099224, 0.17909102074480376, 0.20041106069861658, 0.21107424250139095, 0.11417360613530947, 0.05890066111567305, 0.14549424437395375, 0.15744230335420795, 0.15024890236679111, 0.13265767342187462, 0.20206276258278533, 0.26966564525885284, 0.3188451589272653, 0.16242154581783375, 0.33090449038754954, 0.1879911351362914, 0.13659632587015236, 0.13490893919103997, 0.13937323226204612, 0.15952571536981797, 0.1582367988252812, 0.16879322248438844, 0.15167585156137797, 0.1367309189969672, 0.22570055386644294, 0.2079132655267858, 0.2729814901218113, 0.248035527272909, 0.1588993812985049, 0.2078409413706479, 0.14972604759920727, 0.14802329828563088, 0.18198564651846671, 0.5383066334097246, 0.6445116643943949, 0.5631841336909126, 0.5120570780257188, 0.5725709592205108, 0.5732386930865558, 0.5641628997289507, 0.5731815754903058, 0.5444207485605908, 0.11563176199514658, 0.10748996525890031, 0.09641500006648052, 0.13198518573238338, 0.08704423660096894, 0.09982856184228062, 0.14970842309603505, 0.10304578064758696, 0.13106311502801604, 0.2646802639595649, 0.13163949229699867, 0.23873631355889258, 0.190422769294044, 0.2505470637128605, 0.17091006676404774, 0.1608920127101392, 0.18475316915187956, 0.23323144037548482, 0.3400241474829686, 0.35030498354817396, 0.35777028112279874, 0.36943258179981087, 0.33983180057387274, 0.33208090049879724, 0.3801033459493227, 0.379683924177425, 0.40018317345887844, 0.3080368275695067, 0.26183020002164326, 0.28846663100474146, 0.27066685557384107, 0.28549980799201524, 0.3038733424798039, 0.2981959017046111, 0.2441575445486288, 0.26113146865187886, 0.2026388371134632, 0.2228046813046305, 0.20966569491529397, 0.19872214562950397, 0.21279568311651254, 0.21322150674566243, 0.21396543244412358, 0.23216589986708513, 0.27030579774428853, 0.21436131033407402, 0.19410913442591105, 0.18710062450515608, 0.19969133764438574, 0.2051609606656435, 0.19572588326966178, 0.1835184908288624, 0.19184472296322042, 0.21214891791657242, 0.6816601443928618, 0.7918349731755097, 0.18779603411738055, 0.9033966563685292, 0.19782048200672553, 0.19699874355653013, 0.8657611366714177, 0.20510063596972128, 0.16500902827640984, 0.6815253542756817, 0.3618233707663435, 0.7199314260481589, 0.5821097132372577, 0.20057868765627918, 0.27917280388837484, 0.23491884892400872, 0.36539278065779834, 0.35541195715341467, 0.19706943596100623, 0.18869969040784385, 0.19614167282777495, 0.20038222034450848, 0.19605191202809857, 0.21763470126155238, 0.20523347134586056, 0.18697947220729239, 0.19759180145926503, 0.08166365202884385, 0.09043989993600265, 0.07735810880224692, 0.1159621139886935, 0.08602975393259837, 0.08930666872511006, 0.09840284798844945, 0.09678169339018516, 0.09469674742457901]}, "mutation_prompt": null}
{"id": "ab75ed6b-2968-45ad-856b-cea657815679", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.5  # Adjusted acceleration coefficient for social component\n        self.w = 0.6  # Slightly increased inertia weight for better balance\n        self.f = 0.7  # Reduced mutation factor for controlled diversity\n        self.cr = 0.9  # Increased crossover rate for higher DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for finer control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.85 * self.learning_rate[i] + 0.15 * np.random.rand()  # Slightly faster learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Exploration and Adaptive Mutation for more efficient optimization across diverse problems.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8525777030373791, 0.8516342117807258, 0.8454112583762484, 0.829800498231355, 0.8273379272538617, 0.8502415979032695, 0.8396695115252604, 0.7180401259661296, 0.8453029843456508, 0.421377285759136, 0.5372801402543462, 0.4407040333051703, 0.4737886227395577, 0.6559256873705004, 0.5350881673421242, 0.47374367263307426, 0.6261315808593853, 0.6336242509014283, 0.18225416860893806, 0.12405560243771652, 0.12240421895244347, 0.15341666132829346, 0.11394029189033028, 0.11482764537514101, 0.13116720474273713, 0.13078092319622314, 0.6630099728615091, 0.11711978260183564, 0.12237465181412532, 0.1085529482296328, 0.10676953741716111, 0.07937333271439728, 0.10582854159649047, 0.11027412624252608, 0.1158594023192947, 0.12514621982497887, 0.8063604102139781, 0.7856460381281206, 0.8111479480162114, 0.8387985070199409, 0.8331714799748353, 0.8641853988261313, 0.7971629777411295, 0.8926278265739103, 0.8265795636915176, 0.316737917511392, 0.2939033145401453, 0.1852791485932438, 0.22215747476543546, 0.3300228205920652, 0.21047775993719242, 0.3337476153649124, 0.2448397864605557, 0.3468727115764363, 0.6736072902656614, 0.701043042875904, 0.6473807340574171, 0.7506348989976774, 0.7602094961121924, 0.681014663957023, 0.6186969980060584, 0.6491888106093351, 0.7274334115488809, 0.15491843406658679, 0.18431979200858917, 0.1627812623082393, 0.17731648643985487, 0.24892600807027587, 0.1270966034898181, 0.21184704870728344, 0.4562388681919438, 0.15064812268674654, 0.23100511256937162, 0.16289534990952215, 0.12606789561986131, 0.21639850507523328, 0.14012499635144593, 0.19184465959523445, 0.20229587330447518, 0.19734037499096924, 0.29165620336433895, 0.21398297840068858, 0.019739492553785043, 0.044120787908873194, 0.10060979266099224, 0.17909102074480376, 0.20041106069861658, 0.21107424250139095, 0.11417360613530947, 0.05890066111567305, 0.14549424437395375, 0.15744230335420795, 0.15024890236679111, 0.13265767342187462, 0.20206276258278533, 0.26966564525885284, 0.3188451589272653, 0.16242154581783375, 0.33090449038754954, 0.1879911351362914, 0.13659632587015236, 0.13490893919103997, 0.13937323226204612, 0.15952571536981797, 0.1582367988252812, 0.16879322248438844, 0.15167585156137797, 0.1367309189969672, 0.22570055386644294, 0.2079132655267858, 0.2729814901218113, 0.248035527272909, 0.1588993812985049, 0.2078409413706479, 0.14972604759920727, 0.14802329828563088, 0.18198564651846671, 0.5383066334097246, 0.6445116643943949, 0.5631841336909126, 0.5120570780257188, 0.5725709592205108, 0.5732386930865558, 0.5641628997289507, 0.5731815754903058, 0.5444207485605908, 0.11563176199514658, 0.10748996525890031, 0.09641500006648052, 0.13198518573238338, 0.08704423660096894, 0.09982856184228062, 0.14970842309603505, 0.10304578064758696, 0.13106311502801604, 0.2646802639595649, 0.13163949229699867, 0.23873631355889258, 0.190422769294044, 0.2505470637128605, 0.17091006676404774, 0.1608920127101392, 0.18475316915187956, 0.23323144037548482, 0.3400241474829686, 0.35030498354817396, 0.35777028112279874, 0.36943258179981087, 0.33983180057387274, 0.33208090049879724, 0.3801033459493227, 0.379683924177425, 0.40018317345887844, 0.3080368275695067, 0.26183020002164326, 0.28846663100474146, 0.27066685557384107, 0.28549980799201524, 0.3038733424798039, 0.2981959017046111, 0.2441575445486288, 0.26113146865187886, 0.2026388371134632, 0.2228046813046305, 0.20966569491529397, 0.19872214562950397, 0.21279568311651254, 0.21322150674566243, 0.21396543244412358, 0.23216589986708513, 0.27030579774428853, 0.21436131033407402, 0.19410913442591105, 0.18710062450515608, 0.19969133764438574, 0.2051609606656435, 0.19572588326966178, 0.1835184908288624, 0.19184472296322042, 0.21214891791657242, 0.6816601443928618, 0.7918349731755097, 0.18779603411738055, 0.9033966563685292, 0.19782048200672553, 0.19699874355653013, 0.8657611366714177, 0.20510063596972128, 0.16500902827640984, 0.6815253542756817, 0.3618233707663435, 0.7199314260481589, 0.5821097132372577, 0.20057868765627918, 0.27917280388837484, 0.23491884892400872, 0.36539278065779834, 0.35541195715341467, 0.19706943596100623, 0.18869969040784385, 0.19614167282777495, 0.20038222034450848, 0.19605191202809857, 0.21763470126155238, 0.20523347134586056, 0.18697947220729239, 0.19759180145926503, 0.08166365202884385, 0.09043989993600265, 0.07735810880224692, 0.1159621139886935, 0.08602975393259837, 0.08930666872511006, 0.09840284798844945, 0.09678169339018516, 0.09469674742457901]}, "mutation_prompt": null}
{"id": "82275448-1b63-4d91-ab25-1e47db6bc7c3", "solution": "import numpy as np\n\nclass RefinedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.4  # Modified acceleration coefficient for cognitive component\n        self.c2 = 2.6  # Modified acceleration coefficient for social component\n        self.w = 0.65  # Adjusted inertia weight for dynamic balance\n        self.f = 0.6  # Further reduced mutation factor for controlled exploitation\n        self.cr = 0.95  # Further increased crossover rate for enhanced exploitation\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Adjusted learning rate range for precision\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Adjusted learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.velocities[i] = np.clip(self.velocities[i], -0.1, 0.1)  # Velocity clamping for stability\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedAdaptiveDualPopulationPSO_DE", "description": "Refinement of Enhanced Adaptive Dual Population PSO-DE with Adaptive Learning Rates and Dynamic Velocity Clamping for improved convergence precision.", "configspace": "", "generation": 17, "fitness": 0.19777708737659433, "feedback": "The algorithm RefinedAdaptiveDualPopulationPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.14.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.7137443774178831, 0.6182683575428136, 0.5388433326782136, 0.26565869682982923, 0.43549267015681337, 0.6538735130596399, 0.4218087318668292, 0.6276721375285691, 0.6736036214668056, 0.23154313492008283, 0.3756088710122021, 0.09436421402551165, 0.41271936482454485, 0.3347226723762661, 0.1672403487515952, 0.0672421962058335, 0.3418562684484565, 0.3168122620838777, 0.07392178240993785, 0.13890095334105268, 0.11265597380440029, 0.11920396085973828, 0.07485046621283198, 0.12886892190044852, 0.13127245345590965, 0.10779228625994053, 0.09738345183810215, 0.08956181542241703, 0.09875745097853506, 0.1094162734433658, 0.10067296300502604, 0.07755897849295723, 0.08973295689204319, 0.12077587338562423, 0.10952338423320784, 0.10764681123945175, 0.12317104142540902, 0.0895740972241369, 0.1275387959637817, 0.41139990767594203, 0.4180476166381444, 0.11565834283191723, 0.45342300667593993, 0.1249924896970821, 0.11710039676938555, 0.1398122330528735, 0.04367465093696443, 0.04966819555971447, 0.0860983394133118, 0.16254343984256936, 0.21063062292001966, 0.2775152960763684, 0.10942054625972542, 0.19427892692150472, 0.18527016336892954, 0.7240437220769538, 0.15319254950503414, 0.17316942070005392, 0.15121723213708427, 0.18980414696221892, 0.6717652291100571, 0.12975990421776185, 0.17040709865338466, 0.1173287329954188, 0.13678997807116688, 0.19635848043071735, 0.06394438285964765, 0.11807138890929558, 0.1679524727570506, 0.0945519012231032, 0.2842360484348758, 0.12743001197538684, 0.12644470764015792, 0.1047466903881914, 0.11805907419900707, 0.10383444929745789, 0.11627760500802853, 0.26259817236816685, 0.11434006550159792, 0.11286043375483823, 0.17460347178798075, 0.007640726004109477, 9.999999999998899e-05, 9.999999999998899e-05, 0.06938348146621176, 9.999999999998899e-05, 0.060317240415840745, 9.999999999998899e-05, 0.00926346001621181, 0.015925323931023194, 0.25644431262824796, 0.1190115615438001, 0.13621016425553967, 0.10381413603117329, 0.09225778171705423, 0.09167069809701134, 0.12201081006062653, 0.16271621875569764, 0.17336058448604852, 0.046434248277243184, 0.09552740437052232, 0.14646060127330252, 0.14843298352165435, 0.05802477460341793, 0.0637423709455408, 0.13969532581604904, 0.1180750898261771, 0.11247216226148249, 0.12685617176312247, 0.06373069952258315, 0.004093752808915663, 0.10456526735419613, 0.18488370230355144, 0.11534268341035492, 0.0649364116840474, 0.14936130618117982, 0.07556618891002786, 0.3609478659835097, 0.5201169566553911, 0.5424751748812149, 0.46661992552751186, 0.38438481711047623, 0.3081826081464728, 0.4481786437309514, 0.38540299730968686, 0.4661165675643735, 0.09057425006731157, 0.0795642506874692, 0.06045222127694938, 0.11934960158316732, 0.09656667943598263, 0.0971438568049634, 0.1305775936672473, 0.12016664115268816, 0.12057071432916422, 0.21202812331925414, 0.21018292648346426, 0.19584826774073882, 0.1578268400612569, 0.18806500215008015, 0.2448861227487772, 0.1587222157588163, 0.14169597304043724, 0.19541361970209137, 0.2825365934104015, 0.2974706012328989, 0.25818831086872485, 0.3557764037535017, 0.39289547543727354, 0.3356459153107709, 0.219874366982867, 0.3383027562786819, 0.2698225964932438, 0.2258981599227915, 0.21730972853703778, 0.22658644078659573, 0.21767068411159884, 0.2760306842417519, 0.22741412786958415, 0.21502647653117724, 0.2605941833146519, 0.21687071408951497, 0.20283280642529355, 0.22995504979826042, 0.2133075978700686, 0.2183795865167456, 0.2025379052840628, 0.20485132424596486, 0.2254747033535225, 0.2207366465998456, 0.19793717735110516, 0.18992576666565697, 0.1759128255558704, 0.19149151247646223, 0.38018793214427926, 0.20432547851531835, 0.21492623011998835, 0.18143566083460605, 0.1877626041101813, 0.28133246988353966, 0.18736417029141617, 0.1811825636001091, 0.19668824852255573, 0.7555302969808909, 0.1802858212545001, 0.1561801998887704, 0.17655574093995818, 0.16780985164459106, 0.19236839388588411, 0.24148067844104404, 0.19744823364883124, 0.11656035414497712, 0.49727546759205377, 0.1596485897127421, 0.19736232237268836, 0.18688969034117886, 0.22909708209881863, 0.1669697742332652, 0.18730838051829568, 0.1890988847176036, 0.17387251226017653, 0.19019806311536336, 0.24552184423845158, 0.18461678693982753, 0.18197352656846, 0.17941001233729925, 0.19457629186002467, 0.0790986642550986, 0.0957548561938093, 0.11430707906180504, 0.08772088103999864, 0.07951482185909986, 0.08650615181537791, 0.07174628286498574, 0.08139727039189515, 0.08943847703815899]}, "mutation_prompt": null}
{"id": "6412de35-6bc7-41ec-a747-a3c7e8641ead", "solution": "import numpy as np\n\nclass AdaptiveDynamicDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.7  # Adjusted acceleration coefficient for cognitive component for better individual learning\n        self.c2 = 2.3  # Adjusted acceleration coefficient for social component for balanced social learning\n        self.w = 0.65  # Increased inertia weight for improved exploration\n        self.f = 0.8  # Slightly increased mutation factor for enhanced diversity\n        self.cr = 0.85  # Reduced crossover rate for controlled DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.07, 0.33, self.population_size)  # Adjusted learning rate for dynamic control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # More stable learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveDynamicDualPopulationPSO_DE", "description": "Adaptive Dynamic Dual Population Optimization with Enhanced PSO-DE Integration for Superior Performance on Diverse Black Box Functions.", "configspace": "", "generation": 18, "fitness": 0.30716261817709495, "feedback": "The algorithm AdaptiveDynamicDualPopulationPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.7902689035252695, 0.8445699787016345, 0.8764783351307889, 0.7815268072290765, 0.8061199696181913, 0.8025762384562715, 0.7109616349686725, 0.7120079272070005, 0.8461273908130238, 0.48583101034310905, 0.6509907448162884, 0.38196421775536027, 0.5858260936700124, 0.47200427274750467, 0.5506275046002664, 0.5018291992410906, 0.541110052232064, 0.679378015173727, 0.12859166708413539, 0.12378985942426646, 0.10002195937147407, 0.1582983276677049, 0.12345519956681661, 0.12765092042442538, 0.13550050782875556, 0.14100303233041012, 0.11859117655666362, 0.10570392646017535, 0.11709905998049819, 0.13176462077817974, 0.1001693879810176, 0.12146645690797686, 0.10700274400185661, 0.11845665541796135, 0.10312282774879389, 0.12959085355602418, 0.8452843745341785, 0.8305555774412208, 0.7592541108112496, 0.8504610306929608, 0.8995081485614917, 0.8351403471820039, 0.8328872046911806, 0.8151757710300672, 0.913716986925007, 0.3079948878140446, 0.14957895657819065, 0.2682965033662329, 0.2745394222606322, 0.4037282470132746, 0.23490024492746198, 0.2717130415841881, 0.2527867674890252, 0.26788635823112994, 0.5843953250246658, 0.5321984078967654, 0.4834583509808291, 0.2046183038743582, 0.5991083245303773, 0.5929953932753106, 0.19609232008800326, 0.8231893182840873, 0.5124123812408073, 0.22510208474863191, 0.2968013360315763, 0.1577593752310169, 0.36091583238253877, 0.20245785953755135, 0.16312939029504092, 0.1657650330594752, 0.20274170717810525, 0.15246300055507112, 0.15065634857279275, 0.1787214294446765, 0.14166209169240485, 0.19108999545564032, 0.2173441087143443, 0.20274432232387307, 0.15925879179578117, 0.1565122078444685, 0.14207546506844426, 0.10559642316118112, 0.06891164177631726, 0.11172551840388423, 0.11400917468835692, 0.09325893529519513, 0.14358357395213184, 0.11791668702979419, 0.10166241613795957, 0.15067627728166955, 0.23695897967770907, 0.19629413407895546, 0.25162752113003284, 0.1489785236859128, 0.22629498881083343, 0.2366725031331457, 0.20901245970266857, 0.25582508449872254, 0.20497104553028433, 0.16233002842277033, 0.13175677024581112, 0.18782451605205175, 0.15592687207202383, 0.19518835414957625, 0.3525085076190607, 0.15230194670649055, 0.26698539870847804, 0.1298227643980121, 0.18720532772514242, 0.15318601144381971, 0.20164761524138353, 0.20807296583926205, 0.1650051544733382, 0.16224722949271675, 0.17732489760677272, 0.1372995375035151, 0.16697020788454686, 0.5026987465848347, 0.5528465554966238, 0.520342051408752, 0.4940007333666072, 0.5207402993047752, 0.5507109648495356, 0.5190194389404978, 0.5299587776804618, 0.5160731207384033, 0.10819167724037893, 0.10717552947064068, 0.14878026716228976, 0.09364802617222812, 0.1397108992516931, 0.1303821105842159, 0.12933238365839095, 0.13777654134156003, 0.12310985790141271, 0.19993535963422648, 0.14419752803125996, 0.1583058431497526, 0.19622144314512557, 0.18959977586840315, 0.2874423229437082, 0.1671340498631858, 0.23104200935335018, 0.17932399448111214, 0.2860782479743148, 0.3204552630320442, 0.36271089914254895, 0.3269691232652303, 0.34215345852917234, 0.3703384695837011, 0.3501573322561923, 0.37992769116650804, 0.33737317848977755, 0.2493662869316544, 0.23245004349796572, 0.27375971903669427, 0.2844120282625848, 0.3513548836535342, 0.243583472269432, 0.25043102710025045, 0.281060038229596, 0.24296656185065968, 0.2710557062315695, 0.19501734313473462, 0.24182587227330965, 0.2301365423928895, 0.2120676386934981, 0.23811886637848179, 0.23852969835498694, 0.25621851356182124, 0.21767166470818322, 0.19922441760428544, 0.18720177025176876, 0.1894281081015966, 0.1920050987739994, 0.19250415514155617, 0.38854583874057325, 0.18233900434565353, 0.18800319062178927, 0.1946130314671144, 0.8519945207626539, 0.7783418993613056, 0.6219419751030988, 0.7683269150644264, 0.2856866735585478, 0.19761225582330866, 0.569986184484907, 0.19137529816507026, 0.16538721605886164, 0.5459513288686024, 0.5124481723408185, 0.3910128857937071, 0.4967443053079398, 0.20471809886675085, 0.25906580620732456, 0.7453254739131461, 0.3475195825947952, 0.207737497917299, 0.20750076685482266, 0.20155067084585965, 0.19273565087779143, 0.20153131760652854, 0.21919776768762644, 0.21178648001201827, 0.18886189982658474, 0.19239169414049617, 0.1890596699657483, 0.08073368367656109, 0.09568315904026492, 0.10850853619123024, 0.08237840945430308, 0.10010888725649691, 0.09299713234295126, 0.09826184200651511, 0.07844317410675561, 0.09833024235811028]}, "mutation_prompt": null}
{"id": "2ec28d94-7152-4b58-bb38-6ee4c8917aef", "solution": "import numpy as np\n\nclass DynamicPopulationAdaptivePSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 70  # Increased population for diversity\n        self.c1 = 2.0  # Increased cognitive component\n        self.c2 = 2.0  # Balanced with cognitive component\n        self.w = 0.5  # Lower inertia for faster convergence\n        self.f = 0.8  # Enhanced mutation factor to promote diversity\n        self.cr = 0.85  # Slightly reduced crossover rate for diversity\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Further increased initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Narrower learning rate range for controlled adaptation\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Further refined learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicPopulationAdaptivePSO_DE", "description": "Dynamic Population and Adaptive Learning Rate PSO-DE with Enhanced Diversity and Convergence Control.", "configspace": "", "generation": 19, "fitness": 0.2789256760074532, "feedback": "The algorithm DynamicPopulationAdaptivePSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.19.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.6759179935768438, 0.6322063115619991, 0.6862812027854353, 0.6713348350778869, 0.6540567386416658, 0.7550080309077807, 0.6451422583441567, 0.6726581697857286, 0.6694723683653194, 0.3706982478874221, 0.36497035229949126, 0.4058923136218162, 0.6140998588165276, 0.4383504302646519, 0.33328938549580756, 0.5022340687714963, 0.4042368343111198, 0.5200197010831695, 0.13257067369593367, 0.11662323908419381, 0.10927615473269403, 0.255021839663515, 0.13100533442887896, 0.17702878776459363, 0.1295842803713475, 0.1294302586400845, 0.1520639786424186, 0.10006387912620684, 0.13351717249849648, 0.09370310136067017, 0.10622197180130677, 0.09494807687632911, 0.09530254298017371, 0.11321664722396874, 0.10840894508060883, 0.0922372503924016, 0.7290390435940537, 0.714085129656626, 0.6492921119805544, 0.6856995631318177, 0.8270799966676318, 0.8282138127849392, 0.7413495024836073, 0.802691773325293, 0.8333823157089721, 0.22923996028296234, 0.20095054608469687, 0.21402273845074038, 0.21999032735652158, 0.21708294463727962, 0.28103922268556725, 0.2290809981120856, 0.24312965353626248, 0.27676931479802036, 0.5904384227161148, 0.5708012013074157, 0.4933553225008477, 0.5249201059465205, 0.21675768767999726, 0.6843889726129461, 0.7492166240632224, 0.42449719390211527, 0.5625706477543215, 0.20925424507003165, 0.23869186556135946, 0.14083591644071425, 0.15106251945699756, 0.2622685055316424, 0.15753628211633675, 0.14998668111333158, 0.26331977642223614, 0.16076063113190098, 0.2089920374832518, 0.14600445473600088, 0.14216069029159495, 0.17256898583441338, 0.1572282494204943, 0.17636530600508782, 0.19034813408660023, 0.26382114860283246, 0.16789558961109818, 0.09670643662956913, 0.08372369614245767, 0.061121087370078375, 0.06111531056355812, 0.08415464391646188, 0.09784792374622031, 0.17852464949438562, 0.07250353559410305, 0.08829616959874698, 0.20444987481593835, 0.1859167996947022, 0.18385219649853435, 0.1657933778951206, 0.13895473408367942, 0.19925258761818487, 0.2553254377315297, 0.2102038720704621, 0.20679882140043415, 0.029474980804298334, 0.10822414611318787, 0.01543127937828026, 0.10225769984042676, 0.3380448415394912, 0.13508311715474697, 0.1362954473325091, 0.11133466437300288, 0.18411777196682066, 0.1621219169202197, 0.14983430948472576, 0.13558484676994453, 0.12765818278144436, 0.162974517317937, 0.13533369840639675, 0.13090610479117037, 0.12959373995057855, 0.1339676352387691, 0.4637245900955629, 0.5064961769687242, 0.4982551436402566, 0.47390886459141957, 0.49452486165074183, 0.4851189229716626, 0.5331001093213332, 0.4994680421358916, 0.510787642340319, 0.1141531214162127, 0.1167949828210385, 0.09296943597709373, 0.12350845863214277, 0.09465287430908487, 0.14146660413896917, 0.11502570047695249, 0.14798066682510236, 0.09644740760544679, 0.18348507797376123, 0.18818071551518167, 0.22982729329015505, 0.20530385226516157, 0.16587624366847398, 0.20587145467727297, 0.3044564525393736, 0.2527977891399513, 0.16753238583086805, 0.2908129723215388, 0.2948190550508526, 0.3331987093873653, 0.3403062407489065, 0.3474154608068273, 0.3342452782405956, 0.30279307119605714, 0.3501778570418812, 0.30735614678778933, 0.2626142100040648, 0.2191120185003993, 0.2681919112632114, 0.3045547229195914, 0.2618417094793726, 0.2283322076309695, 0.21897912140846088, 0.25551168204606645, 0.23320909835119386, 0.20496436658822326, 0.2608864307512606, 0.19960279695505279, 0.20971689674798633, 0.2254771484445004, 0.20911511925752502, 0.2739316472737373, 0.26868322645041876, 0.24076020009540589, 0.5674858537143839, 0.19057413876778428, 0.1794428632485775, 0.19200784904730228, 0.19523067710219488, 0.21529078244271782, 0.188324223743225, 0.19907414498632392, 0.1859075568391847, 0.5294431043653187, 0.5050244754985377, 0.6862727520648829, 0.4393880048465326, 0.1929142163857709, 0.5207772890785229, 0.163948732816098, 0.6511393755633823, 0.21161548804559338, 0.4167640749231598, 0.20801612252811263, 0.4164856369188752, 0.20578864916319017, 0.1610529137683232, 0.40947788880375513, 0.25914149066169023, 0.22826598643388774, 0.33772430881030235, 0.2021871328833328, 0.18014231542559211, 0.20120360260138914, 0.1831450486254883, 0.1712785454146568, 0.19043168573323666, 0.19131854921029257, 0.18478766044910633, 0.21120451218605907, 0.11545772810406651, 0.09291503972347603, 0.08098212778490377, 0.08491904779215531, 0.09535789483262547, 0.0944992683642848, 0.09333167497742578, 0.0827283426041262, 0.0900936200953294]}, "mutation_prompt": null}
{"id": "eb9b5919-ae67-496a-a556-d0ae6e4eb98a", "solution": "import numpy as np\n\nclass AdvancedSynergisticPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.6  # Further adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.4  # Slightly decreased acceleration coefficient for social component\n        self.w = 0.65  # Increased inertia weight for enhanced exploration\n        self.f = 0.8  # Increased mutation factor for greater diversity\n        self.cr = 0.85  # Slightly reduced crossover rate for better DE exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.3, self.population_size)  # Changed learning rate range for dynamic adaptation\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Further refined learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdvancedSynergisticPSO_DE", "description": "Advanced Synergistic PSO-DE with Adaptive Memory and Dynamic Velocity Adjustment for Enhanced Convergence Efficiency.", "configspace": "", "generation": 20, "fitness": 0.3116194442776554, "feedback": "The algorithm AdvancedSynergisticPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.7736250956209292, 0.8512032070626321, 0.8701285868242224, 0.7197148108882228, 0.7775075488540751, 0.8044530177864917, 0.8392907166676554, 0.8326989656982939, 0.8210083479341113, 0.552297561392693, 0.5326212997893126, 0.5189168472779755, 0.5866121802683262, 0.35777179356381916, 0.5189978631760974, 0.6221726658904928, 0.4586559847873318, 0.48010395212191515, 0.11780641497654776, 0.13070513883566093, 0.12797236937144885, 0.1548415285428586, 0.15194788925682023, 0.12334960346130441, 0.12664876939314074, 0.15610938681063857, 0.14138431876299073, 0.10533014226568505, 0.1251653774072805, 0.13951866266991875, 0.09708589332479567, 0.10359311042374719, 0.10739899476895776, 0.10743057579658621, 0.10169942533328813, 0.12281139298520627, 0.8190064785710802, 0.8224303634643061, 0.8403061751683127, 0.8602155676760325, 0.891129052156969, 0.8426388413085519, 0.7645414757077925, 0.8810032639541135, 0.912901453283176, 0.3260292836689165, 0.21712980734995635, 0.231508156822667, 0.3167150987507773, 0.33356367295763056, 0.22098083913754762, 0.2439947560955097, 0.2977544498460183, 0.2299765253237731, 0.5964752363122725, 0.5402363099376503, 0.25927078885600086, 0.6834023508620347, 0.5330770437437959, 0.5555855829510803, 0.613016008121431, 0.8858782735521231, 0.6739983966200405, 0.23719150297003921, 0.3884373213854363, 0.3868085698856184, 0.15825764335227, 0.18988113332808154, 0.14396028674284767, 0.18562987679316034, 0.2788585534404463, 0.16025776068865671, 0.24831553148540453, 0.14061728757095204, 0.16479462197711658, 0.23040681702096977, 0.166625444501462, 0.1336329144709696, 0.1716217662555689, 0.14511718636722526, 0.14945511866278793, 0.10979145679919788, 0.08553835211054028, 0.08226770514488213, 0.03193190400216628, 0.08091461383438858, 0.12957810593737507, 0.12194490067642472, 0.13404850573236982, 0.0884930889226736, 0.18544989089956831, 0.18881978094639595, 0.2148235720489482, 0.16557416925654467, 0.1991794039508099, 0.19233858823443617, 0.21160381757571345, 0.2971045306071297, 0.26833462624153737, 0.11078524861633177, 0.12286236575793064, 0.19525751910730382, 0.13433656660567272, 0.28711717558379846, 0.2034920837639963, 0.14093264212897338, 0.2887210123923861, 0.1700544411231849, 0.239999926020249, 0.17469990472529295, 0.20690923880967027, 0.17107129067783933, 0.15784325972509172, 0.16670657849947024, 0.1806180565290142, 0.1767764538284311, 0.1408695674357392, 0.5410909860881387, 0.5557607516572461, 0.5201857261242468, 0.5462528367280892, 0.5438499553500857, 0.5360596602479333, 0.5460998235536263, 0.5652654845653292, 0.5481472644331353, 0.09484301179415566, 0.09080229411553886, 0.12305971969988028, 0.12251875241995258, 0.09753696464921324, 0.14744423912151639, 0.10591108208638778, 0.12962486499160386, 0.0906151789449281, 0.14669522239151433, 0.16419386578262152, 0.19896375159868274, 0.17093273250127516, 0.18186826169986303, 0.1623157570576137, 0.1777575798300831, 0.3027611436574471, 0.14279948978863855, 0.3254095339377191, 0.4405315354399868, 0.35222856320839746, 0.3133130884422579, 0.343630232390184, 0.36088833608311344, 0.32853759574618957, 0.34472407014897577, 0.3430280976589818, 0.24565840807834205, 0.29499039704410557, 0.26343051173103826, 0.25818347980593026, 0.277224492555178, 0.280005623129838, 0.23627774207124508, 0.29847392087664704, 0.25126986394686257, 0.2184986539366236, 0.2779251035817444, 0.26439854542863495, 0.221904596112231, 0.23901771885567236, 0.20714843642663006, 0.2181952468831504, 0.23760075600611907, 0.25492371255770285, 0.18856020632288018, 0.20953882428074033, 0.21456737105354318, 0.1989001762160747, 0.31798781083766525, 0.1867988493575251, 0.18983344114642264, 0.20712369528856578, 0.18545273881055202, 0.5659888087054933, 0.7361804634111904, 0.18772943373961493, 0.8890306298151591, 0.5580320715518825, 0.19800019783299472, 0.8503921625558124, 0.4727642159599156, 0.17498253309709833, 0.6048455855817041, 0.37715388659374915, 0.43270521273634255, 0.5982331618343582, 0.2060970396175198, 0.24499916948757527, 0.5065381293528963, 0.3575260940410214, 0.3285491078328727, 0.19652709258621526, 0.17751388236690857, 0.18614070653971082, 0.1846213180902001, 0.20098947036674675, 0.1978619919617105, 0.18704322438878962, 0.20654385885029136, 0.1973828470832365, 0.08529617253458965, 0.08499300563941492, 0.11599433681805316, 0.09830803555610967, 0.09751015380258865, 0.08868454964899719, 0.08900975489965801, 0.10254505414424508, 0.08554445533116395]}, "mutation_prompt": null}
{"id": "d4bc2dac-1878-4382-99d1-24086200e4a1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 2.5  # Social component\n        self.w = 0.7  # Adjusted inertia weight for dynamic balance\n        self.f = 0.8  # Mutation factor for diversity\n        self.cr = 0.8  # Crossover rate for better DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Balanced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.5, self.population_size)  # Adjusted learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Adaptive learning rate\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Learning Rate and Adaptive Exploration to improve exploration and exploitation balance for diverse problem landscapes.", "configspace": "", "generation": 21, "fitness": 0.31196709664786476, "feedback": "The algorithm EnhancedAdaptiveDualPopulationPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8157847109398096, 0.832117292804673, 0.8422799937912862, 0.8473340349880707, 0.8425740634253175, 0.7708970456899411, 0.8300696602237037, 0.7820358991950218, 0.8186781311063179, 0.38867024544030093, 0.5061103976570062, 0.47802667385930964, 0.5405259359864929, 0.6622155240462191, 0.5172638111462864, 0.6191910679476063, 0.5648771634760041, 0.5724899965859112, 0.17346897788241733, 0.15739023932412677, 0.1578535782490058, 0.33490181487933923, 0.157709750835205, 0.15739154775002384, 0.13003957073546102, 0.12224231262034702, 0.15337147725882028, 0.10522932129936302, 0.10147616327421127, 0.10746098921258762, 0.10008184000494402, 0.13767062701477895, 0.11407297373589687, 0.10538059318714443, 0.10362909945499121, 0.11366272669765443, 0.8756840868103986, 0.8330267347660469, 0.9346954963098048, 0.8533227475358943, 0.8720170195389942, 0.8539709612454316, 0.905629496305554, 0.9574969295712853, 0.9465802545491728, 0.5755672225750961, 0.33123092179106284, 0.22494193965141351, 0.45874154670354383, 0.29013363947426785, 0.27991974034797584, 0.30026418950474487, 0.36017364283091857, 0.25395925722125545, 0.5527449370927653, 0.4749092147528682, 0.45632432339162143, 0.6267175531413887, 0.7579952620228847, 0.6569425041246654, 0.6339330506496883, 0.5853619596894, 0.6635068779213551, 0.19861134227353805, 0.14600912708664038, 0.15925917814343304, 0.1472494087483749, 0.2061160658973743, 0.15000371889692543, 0.16201293504610692, 0.2020305407124834, 0.2883268700091033, 0.17427680243042254, 0.14794981620311065, 0.1304566575010474, 0.1704084356565383, 0.20092398695683478, 0.1657362151462688, 0.18862001716387589, 0.17746959989833233, 0.1893537794925816, 0.07975361619770904, 0.08454932240457325, 0.0522005835156939, 0.09549513514335417, 0.10088202122934364, 0.08734826619731251, 0.06190765245472718, 0.1117623787914176, 0.05190068168140638, 0.18508773072003526, 0.18368232300527387, 0.15342541971339974, 0.10249676971334398, 0.08981041374806586, 0.17249635977710298, 0.19672053754059582, 0.21392936981776767, 0.20557553658161742, 0.2927294696922247, 0.17091689301830226, 0.14113131824036285, 0.09008501277568681, 0.32212308575363446, 0.165768052815079, 0.12095373065861181, 0.23373248462659857, 0.1318018731289201, 0.11878433716548986, 0.1688330256529652, 0.15172225122729543, 0.15127503625118421, 0.18422353850145645, 0.16224480937885488, 0.16027712116653514, 0.11993758638296037, 0.14470566209044933, 0.49290974914863317, 0.5379791552043693, 0.5489126709888588, 0.5080567658329804, 0.4930536453469945, 0.5029888022662543, 0.5863638866722689, 0.532817566049225, 0.5019912850606394, 0.13044613366229896, 0.1504033765889119, 0.16304085451153716, 0.14164805958411253, 0.12483980847977216, 0.1305475672598826, 0.15468828483589392, 0.15394663297212208, 0.10328939232645717, 0.22954971220486464, 0.15350132082233736, 0.16866347771047807, 0.17669070337972204, 0.23836917656101275, 0.18488187980135662, 0.21440970362901302, 0.2795749804527582, 0.2327137146068603, 0.3609817712564958, 0.3120198545937162, 0.3280949007956194, 0.3582236716739705, 0.3617986188302341, 0.3308606450452034, 0.32970505594032007, 0.35532774907798603, 0.33402243387816366, 0.23432817104986525, 0.23696479743736987, 0.28606717980223295, 0.21853661488273923, 0.20166821733017437, 0.3670214466660574, 0.23750801640988062, 0.23615900660937272, 0.3128775233831239, 0.20468207485630552, 0.2036207023780925, 0.21211170670035506, 0.22041243994815052, 0.2966341755163343, 0.24481423233144273, 0.21052551190300828, 0.2488200731297986, 0.24952451392046027, 0.20386286594185177, 0.19771120878199722, 0.20395723954043787, 0.1887050692099962, 0.19445302247142904, 0.22314450146985343, 0.19648267969235667, 0.19125648165667464, 0.22333470412704115, 0.8139667261146418, 0.5190257837694232, 0.7645139856681161, 0.8541994872986728, 0.35982389363858014, 0.19802986312724957, 0.6176522899917369, 0.17694221101231888, 0.7531052071281574, 0.5084396418132143, 0.20907883894424573, 0.4325618634225723, 0.20740690897145808, 0.20865622013444884, 0.20768322176766796, 0.21894855476651687, 0.3984677248461901, 0.3874104067407189, 0.1954542087661636, 0.20630082377492887, 0.199236249287697, 0.2015113926915133, 0.20322243908156645, 0.22017196134888317, 0.20525671167251425, 0.22505404482496383, 0.18528913735488206, 0.07995089454706716, 0.08011109737710032, 0.07888999179745937, 0.09778044806756281, 0.09470825639625213, 0.08948121917407648, 0.13255839971528804, 0.07592719058865749, 0.08052773085111697]}, "mutation_prompt": null}
{"id": "ac17af6b-b32a-4d84-8a66-78ba573857be", "solution": "import numpy as np\n\nclass AdaptiveDualSwarmCoevolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.4  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.6  # Increased acceleration coefficient for social component\n        self.w = 0.65  # Modified inertia weight for efficient exploration\n        self.f = 0.6  # Further reduced mutation factor for focused diversity\n        self.cr = 0.85  # Slightly reduced crossover rate for stability\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Narrowed learning rate range for control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Refined learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveDualSwarmCoevolution", "description": "Adaptive Dual-Swarm Coevolutionary Algorithm with Enhanced Exploration-Exploitation Balance for General Optimization.", "configspace": "", "generation": 22, "fitness": 0.31268824499022924, "feedback": "The algorithm AdaptiveDualSwarmCoevolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8032015135851912, 0.8324095282713267, 0.8096758123096225, 0.681575052881362, 0.7623090827964587, 0.7873302490242783, 0.8238342032165389, 0.7584399926865614, 0.8578658986020655, 0.5513177491826857, 0.5239303713900123, 0.46953397332186564, 0.5281287852670061, 0.5835585507211651, 0.5474978212422159, 0.4752527765265293, 0.62185099647202, 0.5592970079287339, 0.10789760089327516, 0.1220897801635571, 0.12547986851253645, 0.16514874619544606, 0.17818069099627953, 0.14936264801367582, 0.13470895222092116, 0.1165916327954184, 0.15661858605067447, 0.132509926972321, 0.11136755382818242, 0.13501390735733876, 0.1302377264120882, 0.1252085057845299, 0.12005770952296246, 0.12295211922149263, 0.12571269379096162, 0.11998241766896334, 0.7959167492999044, 0.857041303892857, 0.7838088319956744, 0.8401949204286974, 0.8747738243479957, 0.8425450118873021, 0.7892712684400408, 0.8137594248063602, 0.8961169161642264, 0.2963862287499722, 0.29482934196636645, 0.19670149041806084, 0.21361688451388516, 0.2564058251749243, 0.2375647573816615, 0.4712523557922865, 0.35823926066230294, 0.25334820699840266, 0.5698269086994012, 0.5133443395125346, 0.2634736910663148, 0.7161967601639738, 0.8414579232495412, 0.27633983123625194, 0.21715983866202782, 0.6180958831515315, 0.8763932620077289, 0.2511198330015, 0.16050597245128007, 0.1892170368639977, 0.14450507859410067, 0.2384643452114853, 0.13638034982620684, 0.18923655494326297, 0.2601635612456086, 0.10084200145755673, 0.2505963451584221, 0.14168787820033046, 0.18960807928062928, 0.26141195400931594, 0.15609812156943792, 0.2579033946783378, 0.1570957244358564, 0.13639683234072764, 0.1464267555680231, 0.06971150832848383, 0.07333729801465083, 0.11740171330767002, 0.14440035465618895, 9.999999999998899e-05, 0.017308826434822233, 0.10037516937216207, 0.11887859456543481, 0.01972928592333023, 0.22130251830142245, 0.21182811215854425, 0.25722006833805666, 0.11619639008180183, 0.14896492482146784, 0.1138422278726019, 0.305578865181094, 0.2760030779138034, 0.18185200576968008, 0.050670165433391645, 0.1162453377043774, 0.1360253432555001, 0.1755141659357925, 0.25640245677751095, 0.18882564930091206, 0.1870717152749204, 0.14454911032366458, 0.13348549594209913, 0.18889188513467137, 0.14516996586915554, 0.25108107593966456, 0.21561948406648135, 0.3274183866153054, 0.17624177951147357, 0.10488324672099003, 0.19918924611426914, 0.21326258303129364, 0.5640827343710099, 0.6149831981567269, 0.5319707948497867, 0.489173569973943, 0.5689400346609046, 0.5933625064732932, 0.5651062429557643, 0.5282098038120638, 0.5579312793053836, 0.32922716996330526, 0.1060607105218041, 0.10087909265135508, 0.09525611422930924, 0.11576740116261186, 0.11941537298241423, 0.11072507536254583, 0.18206578244821991, 0.17654796874796197, 0.20396649078977458, 0.21272435985239058, 0.18277268123580193, 0.18792938726079078, 0.20906283817388294, 0.1637940950587663, 0.18901168024509019, 0.19701312606764543, 0.20022258821156247, 0.4038567524498671, 0.3607358755940564, 0.33378729276428665, 0.40591001580384134, 0.34846174646414874, 0.33984658621051467, 0.37544762883994376, 0.3473934868533477, 0.35318034828019274, 0.23323980421017243, 0.25059958465120413, 0.26737545197456025, 0.2657668117025085, 0.3159512891479207, 0.25008919059190193, 0.2741770872815481, 0.3263668544295556, 0.3044469778089762, 0.2191857496412517, 0.25199167335955397, 0.2054293320350572, 0.24283156069899448, 0.21561370520540124, 0.2328248696560089, 0.2712268259796048, 0.2701631147885881, 0.2825394979846989, 0.21966881872253496, 0.35258877812895695, 0.20694350749494272, 0.21666590396538554, 0.23666120448444927, 0.2333295750496146, 0.6358806642135482, 0.19461799738665675, 0.2056608280122324, 0.19478309531697868, 0.8418194316990348, 0.18758244965732163, 0.8134786984347384, 0.2038482211070063, 0.1975602713278527, 0.7785294438492879, 0.16685593935845733, 0.7342200751783206, 0.664641933748635, 0.2112565855289359, 0.631231756233023, 0.5313179624138111, 0.20732878685614264, 0.2570000049357779, 0.16677585258497218, 0.4312594246798134, 0.423789696199814, 0.20769355615377594, 0.20752562888410941, 0.17983164271948282, 0.20000159370320758, 0.21486409748819424, 0.21891977593858258, 0.24515184111896937, 0.20446287993376866, 0.32789158536273066, 0.09058086032005574, 0.0891236647856033, 0.18828900052590147, 0.10351327610750738, 0.10098608524940467, 0.10476745519979391, 0.08841882815839563, 0.09176963657376835, 0.09450206384093596]}, "mutation_prompt": null}
{"id": "58a7ca81-8ee1-48f1-88c3-3aa9b5e61425", "solution": "import numpy as np\n\nclass HybridPSO_DE_AdaptiveLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.8  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.0  # Adjusted acceleration coefficient for social component\n        self.w = 0.7  # Modified inertia weight for better balance\n        self.f = 0.6  # Modified mutation factor for controlled diversity\n        self.cr = 0.8  # Slightly decreased crossover rate\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Adjusted initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Adjusted learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Further adapted learning rate adjustment\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE_AdaptiveLearning", "description": "Hybrid Particle Swarm and Differential Evolution with Adaptive Learning for Efficient Convergence Across Diverse Landscapes.", "configspace": "", "generation": 23, "fitness": 0.29897251788169993, "feedback": "The algorithm HybridPSO_DE_AdaptiveLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.7406447408539295, 0.6948683264653257, 0.7335805915828679, 0.7961787663338297, 0.8083059601773248, 0.7623877587879071, 0.7390737873047764, 0.7915172128740118, 0.7304506988655732, 0.44841790098490086, 0.6525121034693702, 0.4443739482813793, 0.4663069950232238, 0.6110466178997209, 0.5446168974315515, 0.4020677310119225, 0.508253857733032, 0.5265181685836868, 0.13596799668654747, 0.1411031598813568, 0.1430176292228671, 0.4656602963304993, 0.16090536820335855, 0.13540215946341538, 0.11887774907519766, 0.6768984534741538, 0.13146097421370118, 0.12045547666553325, 0.12616097782745106, 0.1916120152258609, 0.12343937304907793, 0.09741424838495327, 0.10863089042361296, 0.11648830045263947, 0.11349307007724496, 0.12163468072315897, 0.6976624858708452, 0.8028096039330183, 0.8420484983592407, 0.8195091738510563, 0.826061742235309, 0.8186382956296001, 0.7927239835936615, 0.8517082778033569, 0.82976471284573, 0.22405948207795645, 0.19051969904701493, 0.14926025060446224, 0.16915164796254245, 0.3184749145759107, 0.1538112130266952, 0.2639653189670542, 0.27942020593952577, 0.16872397141403328, 0.531713888404455, 0.6396678781527754, 0.21827519533331208, 0.6903252189329072, 0.6906372598851512, 0.5938173797337281, 0.30174953990062303, 0.6060087016670124, 0.2275477297110189, 0.295280019601324, 0.18644765845480804, 0.15126752574529057, 0.19334703940320952, 0.23806251719869365, 0.16268018296303088, 0.15266828465215798, 0.306271069618806, 0.15002821911770858, 0.24585044136820255, 0.27666755540594656, 0.1391550835168558, 0.19028536126902296, 0.16928311352475034, 0.19146031272476982, 0.24877395663921298, 0.18682416976202165, 0.13564584882560415, 0.026945074418170623, 0.02561816469317424, 0.06305042489838308, 0.0847158482719802, 0.08965860788853419, 0.14846315823284784, 0.08532493966184629, 0.005347586561171402, 0.002532744157721978, 0.16232907904235494, 0.13150785311879987, 0.08803674361526936, 0.06541820839390333, 0.21305026077909806, 0.07347726837872648, 0.20886139412667626, 0.1839322181704598, 0.0958128420924168, 0.09564299438232626, 0.12545174488251598, 0.06629138329507911, 0.12023946083055648, 0.14590328543548037, 0.2509776248440657, 0.12870839587544547, 0.2779684006331624, 0.26788325781549105, 0.1487484623505586, 0.15455708391216572, 0.1497797134636376, 0.17704381068552044, 0.2293498634619, 0.17578926178255572, 0.12469921636146608, 0.1460602750195722, 0.13119671299026614, 0.5596479455940193, 0.5319240465231447, 0.5188306771536213, 0.543245288724119, 0.5017749575225077, 0.4896278110665073, 0.564338885914397, 0.5377813719180262, 0.5104347920961845, 0.10675654951301583, 0.11923172284506744, 0.10810400352024119, 0.10575376640091438, 0.09897999688233905, 0.11415777007677241, 0.12224436770253944, 0.13693534677722308, 0.12823790639696742, 0.23775687877818785, 0.18782754475892993, 0.1975936740594879, 0.23184982861353953, 0.199546296716425, 0.16030189246541826, 0.2107835607172961, 0.16096891348337672, 0.199890990305288, 0.2638880861035542, 0.3334352160588332, 0.36208724276737814, 0.35142484492757253, 0.32443669203287284, 0.3559349889945752, 0.3925211217982899, 0.37834805529104387, 0.39291540536897895, 0.19365701772394228, 0.3203844435330683, 0.2926314467811828, 0.2557719768819835, 0.26457183492542136, 0.25746806684894374, 0.2920879717516336, 0.2331968547919787, 0.3068794032153186, 0.28361195442482035, 0.22931915871579034, 0.20484159612746922, 0.27182470175243467, 0.23909055498606957, 0.3034309388809676, 0.21920825470527805, 0.21478682623038703, 0.25413136391300106, 0.1914005250049592, 0.27576571117130666, 0.21223099924199185, 0.20750862616032106, 0.19871603669178994, 0.2155175883549184, 0.21420408269475655, 0.21876475158006836, 0.20236006648038118, 0.19516711902725825, 0.731200375958599, 0.7660897766071619, 0.7552498921664195, 0.5890615314545808, 0.195446306066265, 0.6231919557871588, 0.7028040168011789, 0.16845156547968332, 0.6024854037835442, 0.5340132091577803, 0.5376182906352283, 0.3178235227401055, 0.20617344588022002, 0.36831914168500135, 0.2491730947398324, 0.4027678286817452, 0.19958602978919726, 0.18639407584784762, 0.1776353925658426, 0.1890519424966156, 0.17641976253734992, 0.19122059996753604, 0.18748557925639486, 0.20803802080885636, 0.17467228215731478, 0.1811572238174658, 0.08992383014332994, 0.09457991876298766, 0.0886336554972319, 0.09408782022334294, 0.09102602978955143, 0.09637060458834001, 0.10272177486009493, 0.0855410571228793, 0.08742771530672111]}, "mutation_prompt": null}
{"id": "bc30dc85-4892-4505-8c95-d4604872d2cf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.5  # Adjusted acceleration coefficient for social component\n        self.w = 0.6  # Slightly increased inertia weight for better balance\n        self.f = 0.7  # Reduced mutation factor for controlled diversity\n        self.cr = 0.9  # Increased crossover rate for higher DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for finer control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.85 * self.learning_rate[i] + 0.15 * np.random.rand()  # Slightly faster learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Exploration and Adaptive Mutation for more efficient optimization across diverse problems.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8525777030373791, 0.8516342117807258, 0.8454112583762484, 0.829800498231355, 0.8273379272538617, 0.8502415979032695, 0.8396695115252604, 0.7180401259661296, 0.8453029843456508, 0.421377285759136, 0.5372801402543462, 0.4407040333051703, 0.4737886227395577, 0.6559256873705004, 0.5350881673421242, 0.47374367263307426, 0.6261315808593853, 0.6336242509014283, 0.18225416860893806, 0.12405560243771652, 0.12240421895244347, 0.15341666132829346, 0.11394029189033028, 0.11482764537514101, 0.13116720474273713, 0.13078092319622314, 0.6630099728615091, 0.11711978260183564, 0.12237465181412532, 0.1085529482296328, 0.10676953741716111, 0.07937333271439728, 0.10582854159649047, 0.11027412624252608, 0.1158594023192947, 0.12514621982497887, 0.8063604102139781, 0.7856460381281206, 0.8111479480162114, 0.8387985070199409, 0.8331714799748353, 0.8641853988261313, 0.7971629777411295, 0.8926278265739103, 0.8265795636915176, 0.316737917511392, 0.2939033145401453, 0.1852791485932438, 0.22215747476543546, 0.3300228205920652, 0.21047775993719242, 0.3337476153649124, 0.2448397864605557, 0.3468727115764363, 0.6736072902656614, 0.701043042875904, 0.6473807340574171, 0.7506348989976774, 0.7602094961121924, 0.681014663957023, 0.6186969980060584, 0.6491888106093351, 0.7274334115488809, 0.15491843406658679, 0.18431979200858917, 0.1627812623082393, 0.17731648643985487, 0.24892600807027587, 0.1270966034898181, 0.21184704870728344, 0.4562388681919438, 0.15064812268674654, 0.23100511256937162, 0.16289534990952215, 0.12606789561986131, 0.21639850507523328, 0.14012499635144593, 0.19184465959523445, 0.20229587330447518, 0.19734037499096924, 0.29165620336433895, 0.21398297840068858, 0.019739492553785043, 0.044120787908873194, 0.10060979266099224, 0.17909102074480376, 0.20041106069861658, 0.21107424250139095, 0.11417360613530947, 0.05890066111567305, 0.14549424437395375, 0.15744230335420795, 0.15024890236679111, 0.13265767342187462, 0.20206276258278533, 0.26966564525885284, 0.3188451589272653, 0.16242154581783375, 0.33090449038754954, 0.1879911351362914, 0.13659632587015236, 0.13490893919103997, 0.13937323226204612, 0.15952571536981797, 0.1582367988252812, 0.16879322248438844, 0.15167585156137797, 0.1367309189969672, 0.22570055386644294, 0.2079132655267858, 0.2729814901218113, 0.248035527272909, 0.1588993812985049, 0.2078409413706479, 0.14972604759920727, 0.14802329828563088, 0.18198564651846671, 0.5383066334097246, 0.6445116643943949, 0.5631841336909126, 0.5120570780257188, 0.5725709592205108, 0.5732386930865558, 0.5641628997289507, 0.5731815754903058, 0.5444207485605908, 0.11563176199514658, 0.10748996525890031, 0.09641500006648052, 0.13198518573238338, 0.08704423660096894, 0.09982856184228062, 0.14970842309603505, 0.10304578064758696, 0.13106311502801604, 0.2646802639595649, 0.13163949229699867, 0.23873631355889258, 0.190422769294044, 0.2505470637128605, 0.17091006676404774, 0.1608920127101392, 0.18475316915187956, 0.23323144037548482, 0.3400241474829686, 0.35030498354817396, 0.35777028112279874, 0.36943258179981087, 0.33983180057387274, 0.33208090049879724, 0.3801033459493227, 0.379683924177425, 0.40018317345887844, 0.3080368275695067, 0.26183020002164326, 0.28846663100474146, 0.27066685557384107, 0.28549980799201524, 0.3038733424798039, 0.2981959017046111, 0.2441575445486288, 0.26113146865187886, 0.2026388371134632, 0.2228046813046305, 0.20966569491529397, 0.19872214562950397, 0.21279568311651254, 0.21322150674566243, 0.21396543244412358, 0.23216589986708513, 0.27030579774428853, 0.21436131033407402, 0.19410913442591105, 0.18710062450515608, 0.19969133764438574, 0.2051609606656435, 0.19572588326966178, 0.1835184908288624, 0.19184472296322042, 0.21214891791657242, 0.6816601443928618, 0.7918349731755097, 0.18779603411738055, 0.9033966563685292, 0.19782048200672553, 0.19699874355653013, 0.8657611366714177, 0.20510063596972128, 0.16500902827640984, 0.6815253542756817, 0.3618233707663435, 0.7199314260481589, 0.5821097132372577, 0.20057868765627918, 0.27917280388837484, 0.23491884892400872, 0.36539278065779834, 0.35541195715341467, 0.19706943596100623, 0.18869969040784385, 0.19614167282777495, 0.20038222034450848, 0.19605191202809857, 0.21763470126155238, 0.20523347134586056, 0.18697947220729239, 0.19759180145926503, 0.08166365202884385, 0.09043989993600265, 0.07735810880224692, 0.1159621139886935, 0.08602975393259837, 0.08930666872511006, 0.09840284798844945, 0.09678169339018516, 0.09469674742457901]}, "mutation_prompt": null}
{"id": "506881aa-e012-475c-bf4e-285d91abddb2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.5  # Adjusted acceleration coefficient for social component\n        self.w = 0.6  # Slightly increased inertia weight for better balance\n        self.f = 0.7  # Reduced mutation factor for controlled diversity\n        self.cr = 0.9  # Increased crossover rate for higher DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for finer control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.85 * self.learning_rate[i] + 0.15 * np.random.rand()  # Slightly faster learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Exploration and Adaptive Mutation for more efficient optimization across diverse problems.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8525777030373791, 0.8516342117807258, 0.8454112583762484, 0.829800498231355, 0.8273379272538617, 0.8502415979032695, 0.8396695115252604, 0.7180401259661296, 0.8453029843456508, 0.421377285759136, 0.5372801402543462, 0.4407040333051703, 0.4737886227395577, 0.6559256873705004, 0.5350881673421242, 0.47374367263307426, 0.6261315808593853, 0.6336242509014283, 0.18225416860893806, 0.12405560243771652, 0.12240421895244347, 0.15341666132829346, 0.11394029189033028, 0.11482764537514101, 0.13116720474273713, 0.13078092319622314, 0.6630099728615091, 0.11711978260183564, 0.12237465181412532, 0.1085529482296328, 0.10676953741716111, 0.07937333271439728, 0.10582854159649047, 0.11027412624252608, 0.1158594023192947, 0.12514621982497887, 0.8063604102139781, 0.7856460381281206, 0.8111479480162114, 0.8387985070199409, 0.8331714799748353, 0.8641853988261313, 0.7971629777411295, 0.8926278265739103, 0.8265795636915176, 0.316737917511392, 0.2939033145401453, 0.1852791485932438, 0.22215747476543546, 0.3300228205920652, 0.21047775993719242, 0.3337476153649124, 0.2448397864605557, 0.3468727115764363, 0.6736072902656614, 0.701043042875904, 0.6473807340574171, 0.7506348989976774, 0.7602094961121924, 0.681014663957023, 0.6186969980060584, 0.6491888106093351, 0.7274334115488809, 0.15491843406658679, 0.18431979200858917, 0.1627812623082393, 0.17731648643985487, 0.24892600807027587, 0.1270966034898181, 0.21184704870728344, 0.4562388681919438, 0.15064812268674654, 0.23100511256937162, 0.16289534990952215, 0.12606789561986131, 0.21639850507523328, 0.14012499635144593, 0.19184465959523445, 0.20229587330447518, 0.19734037499096924, 0.29165620336433895, 0.21398297840068858, 0.019739492553785043, 0.044120787908873194, 0.10060979266099224, 0.17909102074480376, 0.20041106069861658, 0.21107424250139095, 0.11417360613530947, 0.05890066111567305, 0.14549424437395375, 0.15744230335420795, 0.15024890236679111, 0.13265767342187462, 0.20206276258278533, 0.26966564525885284, 0.3188451589272653, 0.16242154581783375, 0.33090449038754954, 0.1879911351362914, 0.13659632587015236, 0.13490893919103997, 0.13937323226204612, 0.15952571536981797, 0.1582367988252812, 0.16879322248438844, 0.15167585156137797, 0.1367309189969672, 0.22570055386644294, 0.2079132655267858, 0.2729814901218113, 0.248035527272909, 0.1588993812985049, 0.2078409413706479, 0.14972604759920727, 0.14802329828563088, 0.18198564651846671, 0.5383066334097246, 0.6445116643943949, 0.5631841336909126, 0.5120570780257188, 0.5725709592205108, 0.5732386930865558, 0.5641628997289507, 0.5731815754903058, 0.5444207485605908, 0.11563176199514658, 0.10748996525890031, 0.09641500006648052, 0.13198518573238338, 0.08704423660096894, 0.09982856184228062, 0.14970842309603505, 0.10304578064758696, 0.13106311502801604, 0.2646802639595649, 0.13163949229699867, 0.23873631355889258, 0.190422769294044, 0.2505470637128605, 0.17091006676404774, 0.1608920127101392, 0.18475316915187956, 0.23323144037548482, 0.3400241474829686, 0.35030498354817396, 0.35777028112279874, 0.36943258179981087, 0.33983180057387274, 0.33208090049879724, 0.3801033459493227, 0.379683924177425, 0.40018317345887844, 0.3080368275695067, 0.26183020002164326, 0.28846663100474146, 0.27066685557384107, 0.28549980799201524, 0.3038733424798039, 0.2981959017046111, 0.2441575445486288, 0.26113146865187886, 0.2026388371134632, 0.2228046813046305, 0.20966569491529397, 0.19872214562950397, 0.21279568311651254, 0.21322150674566243, 0.21396543244412358, 0.23216589986708513, 0.27030579774428853, 0.21436131033407402, 0.19410913442591105, 0.18710062450515608, 0.19969133764438574, 0.2051609606656435, 0.19572588326966178, 0.1835184908288624, 0.19184472296322042, 0.21214891791657242, 0.6816601443928618, 0.7918349731755097, 0.18779603411738055, 0.9033966563685292, 0.19782048200672553, 0.19699874355653013, 0.8657611366714177, 0.20510063596972128, 0.16500902827640984, 0.6815253542756817, 0.3618233707663435, 0.7199314260481589, 0.5821097132372577, 0.20057868765627918, 0.27917280388837484, 0.23491884892400872, 0.36539278065779834, 0.35541195715341467, 0.19706943596100623, 0.18869969040784385, 0.19614167282777495, 0.20038222034450848, 0.19605191202809857, 0.21763470126155238, 0.20523347134586056, 0.18697947220729239, 0.19759180145926503, 0.08166365202884385, 0.09043989993600265, 0.07735810880224692, 0.1159621139886935, 0.08602975393259837, 0.08930666872511006, 0.09840284798844945, 0.09678169339018516, 0.09469674742457901]}, "mutation_prompt": null}
{"id": "71f47b3c-cc56-4eaa-bf2d-ad23b4b87f94", "solution": "import numpy as np\n\nclass HybridPSO_DE_AdaptiveLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.4  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.6  # Adjusted acceleration coefficient for social component\n        self.w = 0.5  # Further adjusted inertia weight for balance\n        self.f = 0.8  # Increased mutation factor for diversity\n        self.cr = 0.85  # Adjusted crossover rate for better exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Adjusted initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Adjusted learning rate range for balance\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Modified learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE_AdaptiveLearning", "description": "Hybrid Particle Swarm and Differential Evolution with Enhanced Adaptive Learning for Efficient Black Box Optimization.", "configspace": "", "generation": 26, "fitness": 0.301651072056998, "feedback": "The algorithm HybridPSO_DE_AdaptiveLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.778495192496924, 0.7435743427919779, 0.732198871214596, 0.7008172640001901, 0.7070807704861664, 0.8412156355295222, 0.6858612309639904, 0.7706929582533892, 0.8789598984134188, 0.5983831196830458, 0.5168368914372329, 0.5092453115706779, 0.510895988851302, 0.6029110451629283, 0.47902186608423103, 0.567707246350979, 0.6228862367714911, 0.467188280456566, 0.10941556975390265, 0.12700624970782248, 0.12035187214695575, 0.14220648867848373, 0.12082369813475347, 0.11141811215620223, 0.13171801717775777, 0.1322755436410975, 0.14127980162833353, 0.10128796003162621, 0.11587947630781181, 0.106764022111134, 0.11577784271459424, 0.10108719451880865, 0.09666371477770286, 0.11221916183594016, 0.10753575871485388, 0.11794159585767205, 0.8020809803309945, 0.7888122626104607, 0.7770098265862813, 0.7991952522246155, 0.7317124903551351, 0.8438888244611564, 0.7862743779746553, 0.7837058834965556, 0.8970033519765637, 0.36442761468761287, 0.2876843381218763, 0.266975306270155, 0.22195759894649092, 0.37784774938496823, 0.2703153395628721, 0.20280688482638576, 0.1376513911126398, 0.2630663461348359, 0.6373639515414471, 0.47656103502783453, 0.3039233557866404, 0.7570229321020752, 0.8178437077013777, 0.6645489786989294, 0.5984422819710433, 0.6823514669655553, 0.589120149418155, 0.20647257553133613, 0.18990009838414923, 0.14103625293826294, 0.1790424393719401, 0.1999798403542694, 0.2132322765916289, 0.20043268323777508, 0.4176711093043245, 0.1921453085730267, 0.18554797409248003, 0.16491591458745058, 0.2316672019850189, 0.18524434950814073, 0.22754939158256116, 0.1715103322761946, 0.20733590363286458, 0.19613708672523256, 0.17370222011959358, 0.1495273000885401, 0.024364925506928148, 0.10723126102785208, 0.09034307964064903, 0.09551005065652463, 0.10345402000205717, 0.14463945759117303, 0.05997324587922015, 0.07751860415555589, 0.2592557417558603, 0.11118461971688598, 0.13179067568466962, 0.1480475712846948, 0.24859049972705283, 0.18902217953252898, 0.23886472025140926, 0.24560433663357528, 0.20197901244533745, 0.03517306608686799, 0.12209832908745033, 0.2284488602452086, 0.1181868835097788, 0.29916761902650146, 0.22194396823527895, 0.16292058484683714, 0.12323319647000808, 0.22350340034868665, 0.3279366458654154, 0.17465623899161786, 0.1553838587291786, 0.19041861385837178, 0.14081408896721748, 0.13115497459903291, 0.1519448605470588, 0.2001847805711846, 0.1547391033436577, 0.5548770592103948, 0.5463921885240299, 0.5286905130280946, 0.5192287640135964, 0.5026897487675046, 0.5517254857104356, 0.5621989266243981, 0.532144379035113, 0.532223616589478, 0.13591472032236307, 0.12481375337198974, 0.1214363968609452, 0.10004586634252466, 0.10459821011511106, 0.09929252339090577, 0.13862191590750939, 0.10771616717339016, 0.1441130822204284, 0.22085183331584668, 0.13496965175469144, 0.21071739597816364, 0.21156469793086685, 0.19271435027071826, 0.16382990652064422, 0.16874727716960258, 0.22151370898054235, 0.17007143080918263, 0.2910510938018621, 0.31921120285301674, 0.3833198076240286, 0.3403132648753826, 0.33710662264861324, 0.32189023006032813, 0.4251306121885774, 0.38919993829684585, 0.32536015257065176, 0.24141176564031874, 0.23535782583141696, 0.30099092881657175, 0.26380183566984416, 0.3228097884717639, 0.30101175481905573, 0.26144418063051, 0.2749754677444023, 0.2654797687566328, 0.25611310000643983, 0.20306131859562315, 0.20593432053803373, 0.2696806440379609, 0.23108967334039776, 0.25678295776788995, 0.22311237788011595, 0.1934832934356706, 0.2063087839911889, 0.18365471792332733, 0.1906891484590364, 0.22170698995506655, 0.192637863586391, 0.1995762496727005, 0.21744228863583148, 0.17848163033309916, 0.2670469981395647, 0.20823689776032084, 0.1875960254262904, 0.76331947192273, 0.18772142679031345, 0.7622165814420835, 0.6182074218507465, 0.19731837194254598, 0.8267913087745511, 0.1794452736693889, 0.1800144366011589, 0.4304519197895609, 0.21099927120581075, 0.4074447302595119, 0.31577962206210564, 0.20751079790206883, 0.2504335555778634, 0.6265036463592343, 0.3548095981007059, 0.3094750697666274, 0.20303261033845743, 0.19468681216451722, 0.1958256700151939, 0.21519129780476798, 0.22649662269376625, 0.17579965402358744, 0.17781708587893497, 0.19533131206368803, 0.19083379067629458, 0.0976331639906437, 0.0822580136807799, 0.11101746304370319, 0.0958044152798937, 0.09862829586627797, 0.07921435370583407, 0.08007801720930852, 0.08176096446379344, 0.10502318427435364]}, "mutation_prompt": null}
{"id": "a1dbf029-745e-4d26-8568-f593a7d4065f", "solution": "import numpy as np\n\nclass HybridDynamicPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.6  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.4  # Adjusted acceleration coefficient for social component\n        self.w = 0.5  # Changed inertia weight for dynamically adjusted movement\n        self.f = 0.8  # Slightly increased mutation factor for enhanced exploration\n        self.cr = 0.95  # Further increased crossover rate for accelerated convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Narrowed learning rate range for stable adaptation\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Modified learning rate adaptation for efficient balance\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "HybridDynamicPopulationPSO_DE", "description": "Hybrid Dynamic Population PSO-DE with Optimized Learning and Mutation for Adaptive and Efficient Search in Diverse Problem Spaces.", "configspace": "", "generation": 27, "fitness": 0.2912569096366221, "feedback": "The algorithm HybridDynamicPopulationPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.20.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8011769366003139, 0.8646848701391195, 0.7552740918594868, 0.6789807614501651, 0.6157224327710338, 0.6912544573768908, 0.6414098863954979, 0.7055860339772348, 0.7730161630369632, 0.07443444016393008, 0.07552626497853143, 0.28069457992604885, 0.3566438729766689, 0.5031124333515677, 0.4741246843860466, 0.55250268054687, 0.3951290925083111, 0.56609966994003, 0.14183361697818886, 0.12048579479704535, 0.11367857070813625, 0.11040410409496981, 0.108093685173413, 0.1427335810091579, 0.14225175993897698, 0.13853009171920927, 0.10897175056522523, 0.09327689364393921, 0.10171755018080819, 0.10002937439179949, 0.10920595355514251, 0.09513487748142757, 0.10108577510007088, 0.1347174645184407, 0.09994890324400674, 0.12141565698339707, 0.7797866100875084, 0.6611203867935213, 0.7819596597357716, 0.5165376850482986, 0.674399273048202, 0.5130891238354822, 0.7717598871768041, 0.48639987765412807, 0.7855705213250662, 0.22340943102629385, 0.09125368978140791, 0.07111908624029128, 0.1795345275557262, 0.3050782653767564, 0.21697619611990127, 0.30605418235450677, 0.1592946902426402, 0.2647124348371148, 0.23689131507667982, 0.6930501529819313, 0.22519801824268137, 0.29501575537164704, 0.3319229268158953, 0.6387301610752013, 0.6265926578544441, 0.21551074763364908, 0.6743521568791128, 0.1482081520832781, 0.1576289146315656, 0.2189475749097055, 0.18626686714989715, 0.1379025099364095, 0.24955070617177255, 0.18994688132090043, 0.35185956330154755, 0.15896464069274951, 0.22747695653624767, 0.2006419686387213, 0.13221543847281336, 0.1816511300842416, 0.15989025280959135, 0.33983356798917785, 0.4265963185936187, 0.17066274817424487, 0.1875734647839481, 0.1837349968683316, 0.03170428158920835, 0.1246276351595812, 0.22086408919138512, 0.31270493362682916, 0.2962996273009558, 0.0944187600573243, 0.27024891879533475, 0.11566695062638555, 0.35997086635702913, 0.16134667715650797, 0.27658373155613314, 0.26039238930405084, 0.4233824609068968, 0.20176373609015308, 0.43483979552851026, 0.14553034735513193, 0.4224122749339315, 0.1643887318233186, 0.11408351686882057, 0.10805177743933236, 0.15276462980047745, 0.1895333879883122, 0.18020477863098383, 0.17763545872418907, 0.12034566661104784, 0.24269100565411805, 0.22846280429944554, 0.21332671840975204, 0.07275284781816393, 0.1327258167419062, 0.21137388626431375, 0.17668862863647705, 0.2060939889940503, 0.25989667303459985, 0.18035666348076573, 0.5034994022556704, 0.5980391763989847, 0.6155760264335033, 0.5660239977541464, 0.6224637143171949, 0.4648949880800942, 0.6227841835698303, 0.38196785441741954, 0.6146836117017094, 0.13299717748552287, 0.0993736044503648, 0.1154019116500431, 0.15771323463428966, 0.12667428718642038, 0.10952457019864581, 0.12277450549923596, 0.1361365723574145, 0.10709015595742344, 0.19569552477749563, 0.18227796898911142, 0.16229764820403902, 0.20047672696526553, 0.18955283592536265, 0.16485819332566842, 0.24240923445666718, 0.2098881747530532, 0.26506035749757206, 0.3778960561304642, 0.34296799247026377, 0.3637598835893595, 0.38993279412547077, 0.36022578656525506, 0.34342033611721345, 0.36986622853010764, 0.36627912263220075, 0.3563015460486486, 0.27997323378819405, 0.2918428441142611, 0.2983312127021852, 0.2940371106430243, 0.3122933843051837, 0.31270731418757225, 0.2817952718324048, 0.2910710293693426, 0.2714816495802437, 0.2758606397188752, 0.22165399520176443, 0.3164808921295803, 0.20914220892160718, 0.26435669176017895, 0.2709251226520465, 0.28480504288759834, 0.27320652526885125, 0.23583462192367122, 0.19160792067764565, 0.18611772823627115, 0.20809769102033993, 0.23003504548887432, 0.30798892608408124, 0.17820838178411558, 0.18127827411579156, 0.18810932415892712, 0.19071674876660472, 0.19361538709940007, 0.8142707294198797, 0.19748520732374286, 0.8244921727644547, 0.19724650022087875, 0.19758340311971168, 0.8250102703675863, 0.1684355636010223, 0.5282994661788871, 0.6610989268428288, 0.2848854980357193, 0.24493007195796623, 0.5197785852576249, 0.39104408946686553, 0.27691340996802893, 0.2109844439003462, 0.366939699025119, 0.43754068011572667, 0.20820474974934255, 0.18155572674528342, 0.19398579477591615, 0.18510156905644293, 0.20838869243854663, 0.19126818438856052, 0.20730014543027842, 0.19539147955435432, 0.221580163267442, 0.07949068850577301, 0.10955074657995101, 0.10597754984896113, 0.08553852963199093, 0.10358789042513583, 0.10017452637749047, 0.08463699334546904, 0.08511510009406664, 0.08745034331629431]}, "mutation_prompt": null}
{"id": "b25c407f-14f9-4362-a449-56cbbcc16f91", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Reduced for computational efficiency\n        self.c1 = 2.0  # Increased personal influence to encourage individual exploration\n        self.c2 = 2.0  # Balanced social influence for cooperative search\n        self.w = 0.7  # Optimized inertia weight for better velocity control\n        self.f = 0.6  # Adjusted mutation factor for balanced diversity\n        self.cr = 0.8  # Slightly lower crossover rate for stability\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Fine-tuned initial velocities\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.adaptive_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Narrowed adaptive rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.adaptive_rate[i] += 0.05 * (np.random.rand() - 0.5)  # Dynamic adaptation for diversity\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * np.clip(self.adaptive_rate[i], 0.05, 0.3)  # Clipped learning rate\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.adaptive_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid Particle Swarm and Differential Evolution with Adaptive Diversity Control for Effective Global and Local Exploration.", "configspace": "", "generation": 28, "fitness": 0.17433184638438223, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.11.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.318615685402455, 0.4046541768057307, 0.3279659521820498, 0.22887270592328968, 0.466005350753922, 0.22133406878726358, 0.2921999778111455, 0.26316432292977865, 0.2975886884751776, 0.03444665896786059, 0.07072647470823301, 0.014830777276357177, 0.03608828195012681, 0.01825097351664684, 9.999999999998899e-05, 0.2877323359569358, 0.09427384278310169, 0.11217584839363859, 0.11363151252329695, 0.18264557874799292, 0.12957286592540274, 0.1720072961471697, 0.14499705867324297, 0.11770483104961482, 0.16883352531838935, 0.14620422798501964, 0.14184418081877792, 0.07189523047908042, 0.15810831449524554, 0.1345343517743791, 0.1121751085528031, 0.10628004202187857, 0.16751873161492403, 0.11005349403877207, 0.09871816475625783, 0.10390425025742811, 0.11228985971446093, 0.1417193899474425, 0.16041168343728662, 0.07017469428423262, 0.7382555592481335, 0.1493362393868638, 0.08109036577311768, 0.18966086671200888, 0.0890037057620291, 0.06550945972804822, 0.08692652328038386, 0.13494940804887068, 0.08987989911983074, 0.07813226977885657, 0.08229042515606577, 0.08536679324760021, 0.0819858382010108, 0.1704169630595812, 0.3066483310889093, 0.30686820671958526, 0.2922375515719047, 0.2529938776727193, 0.30310827475441215, 0.20213901273373824, 0.1496201329173077, 0.20358335458743992, 0.17154424114575306, 0.1256630844063359, 0.1599730465549899, 0.13863959257542158, 0.13771596865534852, 0.11575608193149278, 0.10273455696506062, 0.1414409633404945, 0.23436480182056774, 0.13376824576998658, 0.14541102848875287, 0.06588408933295709, 0.013023114711794515, 0.1413470864313786, 0.0686692196239248, 0.1389304667308051, 0.1693672875666482, 0.11418532894122013, 0.10210372544307611, 9.999999999998899e-05, 9.999999999998899e-05, 0.11459498176475957, 0.004326370128311607, 0.0020453985927437746, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0429509565734687, 0.10181402354884161, 0.0934607460948711, 0.1062749482993266, 0.06575137297698597, 0.15385822290734208, 0.10710188864226289, 0.12745852775400213, 0.1442228026006902, 0.11778085544054262, 0.12672037047695228, 9.999999999998899e-05, 9.999999999998899e-05, 0.16261098200689617, 0.07249051684446872, 0.13919885347582328, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05616196696410225, 0.07694018775271105, 0.054664166568017425, 0.07211871002019776, 9.999999999998899e-05, 0.08561827132271971, 0.05028638568240873, 0.07077150385593378, 0.16759343488900436, 0.3687698998160306, 0.4254981552673519, 0.3063363753546843, 0.27683339537716933, 0.268998444704867, 0.4847956229799707, 0.3502457256657332, 0.352056441224497, 0.3363565357994198, 0.10043145421192434, 0.09512036578664429, 0.10156751310219791, 0.1355011756815584, 0.09696618513528521, 0.14483924920763258, 0.13108167623560274, 0.11739476196664023, 0.12854452149335738, 0.27554820638130606, 0.17362203029569878, 0.18377016378659727, 0.21290158417459382, 0.41314510993125386, 0.3370497101288298, 0.15512997200656808, 0.2614941011468934, 0.23083025983628414, 0.23941071915718337, 0.26821910762675205, 0.2887218917409198, 0.26590138386903195, 0.31890664283183445, 0.3073471258331769, 0.2625350827685774, 0.28161587237374974, 0.29895791687848006, 0.19891243262225755, 0.2608993652175918, 0.20606679118721005, 0.2887921903101447, 0.2296250551744624, 0.2515970537872556, 0.15759087353791312, 0.2222982109088233, 0.22994976161124692, 0.2772371130644946, 0.20786454277143385, 0.2538048254634224, 0.21872408384841335, 0.22997787285840965, 0.20721069755072452, 0.22392022313120274, 0.20300827520467157, 0.22973078857060059, 0.2326635490962864, 0.18567136692247221, 0.21207575031580916, 0.201588802018849, 0.20375925263920425, 0.333509708625632, 0.1973995007593008, 0.45899473488052356, 0.23651940342197708, 0.15266553934874683, 0.18069982304151166, 0.18500934153148862, 0.3250109029444408, 0.16687967798631997, 0.27902593288077127, 0.19555798221941068, 0.16732526932066427, 0.2802578840101936, 0.41273268541060404, 0.37769862247190267, 0.2883805687173364, 0.39542245972521295, 0.1628496144734789, 0.16459858039119302, 0.23219916837500476, 0.4328763340244194, 0.1423234447429308, 0.193984016022541, 0.19401405823142703, 0.18790217549253552, 0.19595570614710955, 0.19218047005154482, 0.18556784342474297, 0.18420046066320783, 0.18009435717411126, 0.19224383719611238, 0.09824147266863092, 0.08524375236600223, 0.08027952923100024, 0.09573538108376145, 0.09115767472514724, 0.09355336230308509, 0.0812807726798479, 0.10375500941685711, 0.09024655390001501]}, "mutation_prompt": null}
{"id": "04244af0-d9d7-4eb2-b713-c056adbbf1f8", "solution": "import numpy as np\n\nclass HybridPSO_DEAdaptiveVelocityCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 2.5\n        self.w = 0.7  # Adjusted inertia weight for improved balance\n        self.f = 0.8  # Increased DE mutation factor for enhanced exploration\n        self.cr = 0.95  # Adjusted crossover rate for diversity\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Adjusted velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.03, 0.25, self.population_size)  # Adjusted learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Improved learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DEAdaptiveVelocityCrossover", "description": "Hybrid Particle Swarm Optimization and Differential Evolution with Adaptive Velocity and Crossover for Efficient Convergence.", "configspace": "", "generation": 29, "fitness": 0.2670153955062075, "feedback": "The algorithm HybridPSO_DEAdaptiveVelocityCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8340240983983176, 0.8450673452497977, 0.8253412241163635, 0.7828079178223764, 0.46719829023057025, 0.8014757977451282, 0.806488523867586, 0.7931948453538703, 0.808587185989364, 0.5914996022547325, 0.23985815596722182, 0.5265441671538511, 0.18365824328296054, 0.34538190808247593, 0.45955753427747936, 0.5807758868481101, 0.3733645675671393, 0.32166958895661224, 0.10127736508215912, 0.10071281393945941, 0.18001468523636288, 0.09640947586793258, 0.13482770529875454, 0.08643161171764291, 0.11234513557728165, 0.11527858548796344, 0.11638250099344982, 0.08222646736905537, 0.08916786499747598, 0.0716872807472142, 0.08990781429249162, 0.07880485955776417, 0.07534377120750013, 0.09130227462946527, 0.09786763644169261, 0.1264081588853605, 0.9224110303982904, 0.9030205854525082, 0.8790780379995823, 0.8693021731583174, 0.9183465768638506, 0.9584054336354306, 0.8934878445273678, 0.9025216169338577, 0.9080728141937922, 0.3227086857603617, 0.17309261215895422, 0.19006515098373022, 0.28069973876021703, 0.21262558228383677, 0.22243907657008288, 0.3038976318050589, 0.21999292417959548, 0.2681145219030334, 0.25528485740228424, 0.2692497784329667, 0.27741868887089927, 0.26340858789745614, 0.32134282715667006, 0.2817555501834149, 0.30263143449577534, 0.5035084804897931, 0.29807353936127656, 0.1314629878025143, 0.13858813650554525, 0.2327228580059485, 0.08968879372563388, 0.16887881493982515, 0.12087357056632608, 0.15207879319871664, 0.16582468362087088, 0.159497440447104, 0.19885506605790748, 0.1830438405914585, 0.13377235254953124, 0.19853758812460787, 0.1534001536468792, 0.16003875292011138, 0.16270987766982092, 0.1404290570616049, 0.13097887156653232, 0.052806048805600025, 0.035968741404156956, 0.05044866989221186, 0.03828930207540615, 0.040141811656696724, 0.03202037008386838, 0.023997210578070693, 0.01744056119518267, 0.0274638951980416, 0.15213498238261092, 0.12384786329932462, 0.12705874022520058, 0.13631777173032533, 0.10873653489161095, 0.09517250400773769, 0.17840731721371306, 0.17507490806890313, 0.1397202504750057, 0.19197235525855294, 0.21247308969162948, 0.12295653388995031, 0.10817640219424551, 0.12896457198169264, 0.237172699259951, 0.13974067118534317, 0.2134703535686916, 0.13951939537040692, 0.16165261716485324, 0.09234822528272524, 0.26229553929684235, 0.08191804388213308, 0.09541782482272099, 0.128039480449465, 0.10054318054415978, 0.08490164120981358, 0.20135789255034875, 0.5014406833261882, 0.4400195101307828, 0.5068601199403406, 0.4631920308178151, 0.4216976282631034, 0.44693609135691326, 0.4899133901117295, 0.5005362661573427, 0.4467400858532363, 0.11544979989640691, 0.13611869922686348, 0.1041272355010775, 0.14162196930849313, 0.1066937003253483, 0.0928405986124986, 0.07913212813175052, 0.09047683740030366, 0.15726888952246643, 0.14972035096395486, 0.20166930420894857, 0.17268748648081578, 0.16442817761007933, 0.1463620352348427, 0.22939384894984272, 0.1564556584597, 0.22992983113315235, 0.42765096862188723, 0.2535012481217519, 0.2576306995243973, 0.2379733334036126, 0.2718221466479488, 0.22518105459776372, 0.2165926269907833, 0.26410386454952184, 0.3302988165926376, 0.2699940340444249, 0.1905159897066313, 0.20598288685510469, 0.28156745288785157, 0.1658646774489111, 0.28623614699606825, 0.18855690216744148, 0.19167771209997408, 0.21273126352157878, 0.23586331200404786, 0.25209590873706655, 0.2416126864049033, 0.2030996163305956, 0.2515719061441488, 0.1895622840020642, 0.26389202494202413, 0.22032416328038607, 0.2074238062571756, 0.21217100791601384, 0.17328464133648958, 0.18302939868435075, 0.2028999622557962, 0.1763661725176917, 0.18793291912266774, 0.20608264330259596, 0.1908844022106615, 0.18007032733690298, 0.180598053556279, 0.1944834518923544, 0.47066864459737157, 0.5953629041294634, 0.8791604271502879, 0.3268126616807018, 0.19474045339848878, 0.8363291673284899, 0.1758726224005559, 0.48354019646314195, 0.42756419776341403, 0.17965360642967676, 0.34325948373534765, 0.4851066018621226, 0.2369815424865247, 0.5141389885947372, 0.20847656300390027, 0.3579023628502471, 0.19947827774655347, 0.19113259835669816, 0.23005778491680995, 0.22766619848403802, 0.2460945396949641, 0.2255005961280807, 0.19777425222798295, 0.24490197900742683, 0.18249084931263315, 0.2302082306148523, 0.0915499170734001, 0.07537149961270828, 0.09961959767648254, 0.09958227329399671, 0.10076456663969124, 0.09296151898690819, 0.0837518276270992, 0.08773810539707771, 0.09707121059292889]}, "mutation_prompt": null}
{"id": "98094d3b-9b41-4de2-ba39-7f2b15161c37", "solution": "import numpy as np\n\nclass HybridAdaptivePSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.7  # Slightly increased cognitive component\n        self.c2 = 2.3  # Slightly decreased social component\n        self.w = np.random.uniform(0.4, 0.9)  # Dynamic inertia weight\n        self.f = np.random.uniform(0.5, 0.9)  # Variable mutation factor\n        self.cr = 0.8  # Adjusted crossover rate\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Modified initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Adjusted learning rate\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Further refined learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptivePSO_DE", "description": "Hybrid Adaptive Particle Swarm and Differential Evolution with Stochastic Weighting and Dynamic Learning for robust optimization.", "configspace": "", "generation": 30, "fitness": 0.29491985500899115, "feedback": "The algorithm HybridAdaptivePSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8669532134424027, 0.8701307476847736, 0.8446794498531192, 0.7113086808519598, 0.6272527968580703, 0.7071343030425119, 0.8521351895020146, 0.8478965447893482, 0.7459989401633114, 0.6199111143711122, 0.5114085875692709, 0.5984885610248094, 0.4426834868204328, 0.4456736794373437, 0.4489015601375972, 0.5530018824926037, 0.34784982967919864, 0.6155108337592203, 0.12489017346540277, 0.1321926298895847, 0.14719814111395213, 0.12181128171529798, 0.11927634417128719, 0.133176302182893, 0.1200759958442904, 0.19498751507376688, 0.14953978775243526, 0.11330050427289429, 0.13167599307974465, 0.11407734103717215, 0.12356412975138942, 0.14584669722127674, 0.18462128273863987, 0.1316412296894236, 0.10757303655584927, 0.11641241622947984, 0.8147531422925427, 0.8400502598044487, 0.7098021538647452, 0.7496169410458227, 0.7950774871873046, 0.7751890322608763, 0.9006617570316064, 0.8385164763785118, 0.822107267251837, 0.16490726089295493, 0.29524344484192566, 0.11937755932906569, 0.32799215225357803, 0.17217436151225307, 0.19781888199247555, 0.293878215676345, 0.18587162358725273, 0.1631997594285043, 0.7413198795011249, 0.5656148343215812, 0.637322297234272, 0.21062800188746233, 0.7359963760807835, 0.7021987726378225, 0.5446033752864895, 0.547434173146242, 0.1580561204182055, 0.1977394150997639, 0.1565047702114245, 0.17556396960913812, 0.22750231767898954, 0.18121475289819777, 0.1444293394297409, 0.19769258840155912, 0.1511729602184847, 0.1294831299058813, 0.19424374727799498, 0.1756793792756669, 0.13378391803076972, 0.14912303159052465, 0.17913627247675468, 0.19580124107900887, 0.16736086616022006, 0.17772247975298427, 0.17118450090529092, 0.020662722116736587, 0.00012014620923550545, 0.05321829520647714, 0.10255257117004679, 0.051825044278862475, 0.04206124179093218, 0.058767135837018425, 0.03242268366284973, 0.04270923046480546, 0.20670543338349245, 0.19218602497542248, 0.11107022719066861, 0.18826450840276743, 0.17934463161204262, 0.09480676421414569, 0.2006479888206525, 0.1918733492770749, 0.2075105809780794, 0.09947625966069995, 0.07427061632331955, 0.14827924866523956, 0.1019558591969475, 0.1749669677629816, 0.09251806257840922, 0.14360546173243527, 0.17915414140694463, 0.16332185169779112, 0.317277197848845, 0.11619591666659779, 0.04708404992286108, 0.164443701767098, 0.1373076262592875, 0.10252712141056075, 0.12777465288441558, 0.1353690474701822, 0.1665098749519348, 0.5306231667448162, 0.5235853181927093, 0.49326942881655234, 0.5218919052892974, 0.5055810686565376, 0.40519740415788497, 0.5048373800850199, 0.5065572085575256, 0.5106317703682193, 0.16009989251029677, 0.1560659394845707, 0.18113760830389913, 0.1174749300174801, 0.09553790868351697, 0.14771405719208475, 0.11189123151478075, 0.10187627548641232, 0.12018640061544006, 0.18637470553146573, 0.2069481994599367, 0.18541343580258451, 0.17664516141840958, 0.19670359914456204, 0.2057010009413619, 0.21465689438446534, 0.4244946614229681, 0.2173078929505754, 0.32838329345044226, 0.3528802033256163, 0.3874697520663396, 0.34167240399209386, 0.3451163843603732, 0.35050813817602644, 0.3658234415938739, 0.34602961891886097, 0.33690708198869124, 0.19438479958289634, 0.3090879391361636, 0.26054644981128994, 0.21942402227508861, 0.24866356081955932, 0.22769964192330772, 0.23868405574333196, 0.30007873810704433, 0.27178251923784813, 0.2483099077872245, 0.2269998008239814, 0.23714739387965234, 0.2123665870927114, 0.22781946451331236, 0.23126094656300245, 0.21912099887696834, 0.25917418943653825, 0.2527018584827653, 0.2113127726980153, 0.19519712692592917, 0.2185952439679294, 0.19591706398619502, 0.2130203465386733, 0.18669810719740132, 0.24666528302024593, 0.18847265400399527, 0.24321054849137214, 0.7808052431610569, 0.6657600996607804, 0.6999284036221247, 0.16627789636406687, 0.5050238762402446, 0.70815398479087, 0.19258027611264006, 0.18193441234946972, 0.7507018892270787, 0.4853624285143192, 0.6426021021727444, 0.3439778938472384, 0.2601543184040983, 0.20704850374079486, 0.5087953697235996, 0.2829297878645881, 0.6026069436462537, 0.31772246343907384, 0.1888408635249209, 0.21020863992633798, 0.204077643396674, 0.18825649821684032, 0.18959695059009107, 0.1804545908231303, 0.19356696182130684, 0.19851662220998778, 0.1974999715265059, 0.10088262354500732, 0.09496848532938362, 0.07940699268782059, 0.0909627376267883, 0.08038279486848243, 0.1072278304180938, 0.09156278202669255, 0.09624578257231875, 0.10781050521236302]}, "mutation_prompt": null}
{"id": "028d4b58-a6a8-4a61-b119-da0982ab27ba", "solution": "import numpy as np\n\nclass AdaptiveDualPopulationPSO_DE_VelocityMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.2  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.2  # Adjusted acceleration coefficient for social component\n        self.w = 0.7  # Modified inertia weight for adaptive balance\n        self.f = 0.6  # Fine-tuned mutation factor for diverse solution exploration\n        self.cr = 0.85  # Adjusted crossover rate for balanced DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Adjusted initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.07, 0.25, self.population_size)  # Modified learning rate range for control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.8 * self.learning_rate[i] + 0.2 * np.random.rand()  # Adjusted learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * (1 + np.random.uniform(-0.1, 0.1, self.dim))  # Dynamic velocity update with stochastic component\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # Stochastic mutation for diversity\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]) + perturbation,\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveDualPopulationPSO_DE_VelocityMutation", "description": "Adaptive Dual Population PSO-DE with Dynamic Velocity Update and Stochastic Mutation for enhanced convergence and solution refinement across diverse optimization challenges.", "configspace": "", "generation": 31, "fitness": 0.2239840033106398, "feedback": "The algorithm AdaptiveDualPopulationPSO_DE_VelocityMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.49753412870795466, 0.46310705402166663, 0.47318960221932016, 0.4512465031179146, 0.442133660407217, 0.4458401737182287, 0.44465121525235707, 0.4297228226870119, 0.45666843310746186, 0.104892862209791, 0.06870599278119238, 0.07010273020380087, 0.10088357012698301, 0.06516168345529982, 0.08685818679293411, 0.09808654661521599, 0.06303656500122345, 0.08923591283837673, 0.13862912947346284, 0.11137359192915175, 0.12465334380460025, 0.09715887416202662, 0.10714483511989237, 0.09682384153362689, 0.1017574189178404, 0.11945744115204415, 0.12613981480334147, 0.10252197999073343, 0.09075454675985328, 0.08447928107006608, 0.11450805552903764, 0.09126330342499955, 0.10600119411966025, 0.10756411026948787, 0.09039294665296005, 0.09328236385267952, 0.9670680568882917, 0.9561699516044645, 0.9778117068801552, 0.9554561682738748, 0.968239141628987, 0.9569599593513354, 0.9754875620656558, 0.9778376464375812, 0.9655149121742045, 0.22902332929392955, 0.22680329751759976, 0.15558486961229445, 0.21572563459024563, 0.2719867852752954, 0.21885236211860926, 0.2054091462316674, 0.24725162751464258, 0.2451180746278233, 0.6000723333871745, 0.5547922440377966, 0.29036768545914116, 0.6538043651375398, 0.25380574837848635, 0.5731411496251533, 0.30796730626773916, 0.22174682829662073, 0.4294189224444106, 0.10187623528697076, 0.17137438536999394, 0.14059020300500524, 0.17506877155968337, 0.1708275529409491, 0.10440775425702808, 0.18213881029199697, 0.15777910430578101, 0.1506646895710957, 0.13264812073637078, 0.16930265380435594, 0.12057783508960329, 0.1607051422258523, 0.16362826633081784, 0.1311670564146381, 0.15223448877284684, 0.1661425859950505, 0.1398237432658137, 0.025006356746041458, 0.020849347015384767, 0.023471120736195394, 0.06447981066824016, 0.030014741415570256, 0.013461225019712919, 0.0010726806690961599, 0.017631425203778472, 0.010125775025507044, 0.07382237633589306, 0.08554380558071606, 0.11545005003029496, 0.1479598331350842, 0.07681620286640756, 0.10478932577033995, 0.09773788875222977, 0.10655988781027004, 0.07633503496105898, 9.999999999998899e-05, 0.0018337103974405133, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009556716743031046, 9.999999999998899e-05, 0.0047950729496917255, 0.004882239271182365, 9.999999999998899e-05, 0.1048247860661089, 0.09141371088725758, 0.0935273953358352, 0.10087601933287282, 0.10964472715718598, 0.09267030975462853, 0.08171789343227831, 0.09557825618936877, 0.0938403230056658, 0.40334458134911133, 0.4096797968570829, 0.43855105042513276, 0.4117018110741546, 0.40376016273712845, 0.4039532190591044, 0.41721823798234037, 0.39818227920147475, 0.40092353059868724, 0.08469345162611275, 0.11524798833143213, 0.10965834819532205, 0.1106453150959229, 0.10892911985854481, 0.11259851095368612, 0.1077358630274512, 0.10753964533870908, 0.0804433326357854, 0.15561534374380592, 0.15988333007538136, 0.1736350848547329, 0.20971164062578118, 0.2190850889179674, 0.1669476937654918, 0.1504797724375021, 0.17983897087978895, 0.17682582672346203, 0.2926612722623989, 0.2974501858110987, 0.2777482301795555, 0.28584958402310356, 0.29113014019521866, 0.2808411371378896, 0.2848268505050714, 0.2785399141346565, 0.2946105389900522, 0.23634457493170413, 0.2010265982522973, 0.2186630047649648, 0.2348381277504642, 0.18207948869701562, 0.20624347523730113, 0.23134926969832614, 0.22413718333775612, 0.21038714499942812, 0.21731386762383276, 0.21501508004918457, 0.1932987420683807, 0.20085574548882523, 0.1945620848236128, 0.19092497916122697, 0.18598210604819587, 0.21827953978457437, 0.2090400891048092, 0.2231874030159492, 0.19498738738402033, 0.19819333882433732, 0.20371239955950227, 0.19262923471432736, 0.20920799378098298, 0.19384632917691247, 0.20012581724318856, 0.1832498849370373, 0.254803697522879, 0.1816811481885604, 0.4080191300877848, 0.47134555153910485, 0.527265167862226, 0.1587351915278652, 0.17233430526499416, 0.44864752999751356, 0.48717459858234335, 0.29044239439943853, 0.42920457690844027, 0.19286141205641127, 0.5407622776022558, 0.20861992440776778, 0.20027452690020198, 0.2843618384995852, 0.14895237167831366, 0.21834996393268802, 0.17671236552323522, 0.18272690593982166, 0.1731637958523803, 0.18838551429702943, 0.21169468368809208, 0.19270570507295004, 0.18168394350691253, 0.17460975269603496, 0.17219292485404436, 0.08133547224705251, 0.0770746629744039, 0.07361390511045207, 0.08088630677812703, 0.08348929023099261, 0.08064879959125337, 0.07735742715502525, 0.07500544729326031, 0.0879295318908282]}, "mutation_prompt": null}
{"id": "6a396a92-3e62-489e-973b-e4abca9af335", "solution": "import numpy as np\n\nclass HybridAdaptivePSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 80  # Increased population size for more exploration\n        self.c1 = 1.3  # Modified acceleration coefficient for cognitive component\n        self.c2 = 2.7  # Modified acceleration coefficient for social component\n        self.w = 0.7  # Increased inertia weight for improved exploration\n        self.f = 0.8  # Adjusted mutation factor for better diversity\n        self.cr = 0.85  # Adjusted crossover rate for balanced DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Adjusted initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.04, 0.25, self.population_size)  # Adjusted learning rate range for better adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Adjusted learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptivePSO_DE", "description": "Hybrid Adaptive PSO-DE with Dynamic Learning and Enhanced Diversity Control for Superior Optimization Performance.", "configspace": "", "generation": 32, "fitness": 0.2786596608842302, "feedback": "The algorithm HybridAdaptivePSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8283870049966855, 0.803789274539229, 0.8272577901294772, 0.8169357158533272, 0.7697775566979228, 0.7717661395418346, 0.797498421668204, 0.7805832552024043, 0.7873795500360814, 0.38537647416447096, 0.360377394878056, 0.2996483990359805, 0.3497482929670024, 0.43185024711514985, 0.44098917090850887, 0.356352081261021, 0.4739141937607244, 0.410948565601139, 0.11425643450919143, 0.1207533160627603, 0.13422376768286737, 0.11853850048551862, 0.09992035761735041, 0.12108058592925741, 0.1510829652854523, 0.10614088668107347, 0.17676910592717066, 0.11038347113317837, 0.11539712352486697, 0.09781039788753387, 0.11175179386663914, 0.10238028035785862, 0.10752008322082751, 0.10938585664325562, 0.09542679984954794, 0.1054070101354595, 0.7696639995186144, 0.7090773518164015, 0.7683808238754646, 0.8301683506798492, 0.7683148215996377, 0.7130747507643915, 0.7413247781406316, 0.7670252012199027, 0.7870813484892851, 0.5896562976328132, 0.23245520613563964, 0.22497496827583618, 0.2568505118634463, 0.2274237936686161, 0.16545779112103287, 0.316024662750385, 0.318954558120392, 0.2417677512044022, 0.5810037707741177, 0.40572589108972135, 0.4325467673644252, 0.5739118911655907, 0.5331826581534076, 0.38890757946884313, 0.41337428783515184, 0.48389832766149743, 0.3895430044047121, 0.20833627437787983, 0.1930795905975774, 0.15092402914818448, 0.120798362316479, 0.15833997244234743, 0.3388634350301494, 0.20135191809286712, 0.2159962498441973, 0.31883366749829256, 0.22615425197437133, 0.33058090909565874, 0.17461435900204147, 0.31137398140717787, 0.1385606992637084, 0.15454898070902523, 0.1930827117438254, 0.17907448867263887, 0.1414821174545714, 0.05088167962644097, 0.04054618758003359, 0.11190415019691224, 0.05225849206524891, 0.07872221324140682, 0.050045461210522224, 0.1035044153831739, 0.08063779495940071, 0.12734030335236513, 0.18302936122403446, 0.189171106108578, 0.18322397016526815, 0.16237980686729714, 0.20507294538817755, 0.14165274148825324, 0.1970922669184828, 0.2519356702408072, 0.13071842551400137, 0.12338886004610139, 0.12372470067183239, 0.0725348235069263, 0.10062515932651184, 0.12047391512336125, 0.25833698178480413, 0.133034803330763, 0.09621418093931056, 0.19194155936252733, 0.20616026684651223, 0.08384168343823806, 0.13137262433279173, 0.16636508484362944, 0.18230892834551848, 0.1461146077379395, 0.15433300686024853, 0.13272910703119867, 0.13231919723254737, 0.5055831441049647, 0.5324802013767864, 0.5048869545179049, 0.4854738815689912, 0.4621994475879787, 0.5022353866987146, 0.5301899221776734, 0.5025090417636005, 0.501719542344444, 0.09993410307533102, 0.10625853574479716, 0.09170630078918296, 0.17406959195411942, 0.10976654171790834, 0.10306242887822081, 0.10469335289347781, 0.12299783287709776, 0.12141237590591225, 0.2380387053377967, 0.20919930024403033, 0.1705933856434393, 0.18043834078681575, 0.17099753807914508, 0.2542764999820881, 0.23798297914804778, 0.23882569801525, 0.2794143725693352, 0.32425675004455934, 0.31391579429794114, 0.31921428096743587, 0.308664703257597, 0.2951037721481998, 0.32083169561596503, 0.4234382645666358, 0.3913141117427009, 0.3297361880742573, 0.2833097129801352, 0.21794084031664707, 0.26510297886494505, 0.25122356988132943, 0.22986103069838426, 0.24729219934873115, 0.21199192330571237, 0.3653169924126489, 0.22726300537705346, 0.24039688284798766, 0.23072914138116007, 0.22600144768128272, 0.2545634305878939, 0.20003926138131412, 0.22426339859705913, 0.1932026173240109, 0.18800924907389271, 0.22652024366186452, 0.1959893892261776, 0.18187597939112055, 0.21083033180919342, 0.1948186683200619, 0.22782679378854054, 0.19469485933228203, 0.19232933720808731, 0.18969897743922703, 0.25783630134060553, 0.18196170418689028, 0.193228061625351, 0.3775564208924497, 0.6497928395614452, 0.19801029755137456, 0.5394952905379384, 0.16290455138670878, 0.4879414985891314, 0.19019203539448704, 0.3995375361824297, 0.4843105013553358, 0.20293780997065558, 0.16926580090390286, 0.20647417216409125, 0.20036537383501896, 0.5672976516315132, 0.3326912822607142, 0.24167323380965677, 0.2139483460208793, 0.18198371033552663, 0.19923833189302076, 0.18885519622143665, 0.182019828447618, 0.18378610493533254, 0.23357047040001822, 0.21584435973373206, 0.2082114818818862, 0.08018755061047744, 0.08208950799802328, 0.0883228182701925, 0.09744260749466704, 0.09215726583433226, 0.08614373081349536, 0.10016106606964625, 0.09510993353079378, 0.10691695767446585]}, "mutation_prompt": null}
{"id": "f0bd4a22-2df7-4a57-8b87-14a2d3e108cc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.5  # Adjusted acceleration coefficient for social component\n        self.w = 0.6  # Slightly increased inertia weight for better balance\n        self.f = 0.7  # Reduced mutation factor for controlled diversity\n        self.cr = 0.9  # Increased crossover rate for higher DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for finer control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.85 * self.learning_rate[i] + 0.15 * np.random.rand()  # Slightly faster learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Exploration and Adaptive Mutation for more efficient optimization across diverse problems.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8525777030373791, 0.8516342117807258, 0.8454112583762484, 0.829800498231355, 0.8273379272538617, 0.8502415979032695, 0.8396695115252604, 0.7180401259661296, 0.8453029843456508, 0.421377285759136, 0.5372801402543462, 0.4407040333051703, 0.4737886227395577, 0.6559256873705004, 0.5350881673421242, 0.47374367263307426, 0.6261315808593853, 0.6336242509014283, 0.18225416860893806, 0.12405560243771652, 0.12240421895244347, 0.15341666132829346, 0.11394029189033028, 0.11482764537514101, 0.13116720474273713, 0.13078092319622314, 0.6630099728615091, 0.11711978260183564, 0.12237465181412532, 0.1085529482296328, 0.10676953741716111, 0.07937333271439728, 0.10582854159649047, 0.11027412624252608, 0.1158594023192947, 0.12514621982497887, 0.8063604102139781, 0.7856460381281206, 0.8111479480162114, 0.8387985070199409, 0.8331714799748353, 0.8641853988261313, 0.7971629777411295, 0.8926278265739103, 0.8265795636915176, 0.316737917511392, 0.2939033145401453, 0.1852791485932438, 0.22215747476543546, 0.3300228205920652, 0.21047775993719242, 0.3337476153649124, 0.2448397864605557, 0.3468727115764363, 0.6736072902656614, 0.701043042875904, 0.6473807340574171, 0.7506348989976774, 0.7602094961121924, 0.681014663957023, 0.6186969980060584, 0.6491888106093351, 0.7274334115488809, 0.15491843406658679, 0.18431979200858917, 0.1627812623082393, 0.17731648643985487, 0.24892600807027587, 0.1270966034898181, 0.21184704870728344, 0.4562388681919438, 0.15064812268674654, 0.23100511256937162, 0.16289534990952215, 0.12606789561986131, 0.21639850507523328, 0.14012499635144593, 0.19184465959523445, 0.20229587330447518, 0.19734037499096924, 0.29165620336433895, 0.21398297840068858, 0.019739492553785043, 0.044120787908873194, 0.10060979266099224, 0.17909102074480376, 0.20041106069861658, 0.21107424250139095, 0.11417360613530947, 0.05890066111567305, 0.14549424437395375, 0.15744230335420795, 0.15024890236679111, 0.13265767342187462, 0.20206276258278533, 0.26966564525885284, 0.3188451589272653, 0.16242154581783375, 0.33090449038754954, 0.1879911351362914, 0.13659632587015236, 0.13490893919103997, 0.13937323226204612, 0.15952571536981797, 0.1582367988252812, 0.16879322248438844, 0.15167585156137797, 0.1367309189969672, 0.22570055386644294, 0.2079132655267858, 0.2729814901218113, 0.248035527272909, 0.1588993812985049, 0.2078409413706479, 0.14972604759920727, 0.14802329828563088, 0.18198564651846671, 0.5383066334097246, 0.6445116643943949, 0.5631841336909126, 0.5120570780257188, 0.5725709592205108, 0.5732386930865558, 0.5641628997289507, 0.5731815754903058, 0.5444207485605908, 0.11563176199514658, 0.10748996525890031, 0.09641500006648052, 0.13198518573238338, 0.08704423660096894, 0.09982856184228062, 0.14970842309603505, 0.10304578064758696, 0.13106311502801604, 0.2646802639595649, 0.13163949229699867, 0.23873631355889258, 0.190422769294044, 0.2505470637128605, 0.17091006676404774, 0.1608920127101392, 0.18475316915187956, 0.23323144037548482, 0.3400241474829686, 0.35030498354817396, 0.35777028112279874, 0.36943258179981087, 0.33983180057387274, 0.33208090049879724, 0.3801033459493227, 0.379683924177425, 0.40018317345887844, 0.3080368275695067, 0.26183020002164326, 0.28846663100474146, 0.27066685557384107, 0.28549980799201524, 0.3038733424798039, 0.2981959017046111, 0.2441575445486288, 0.26113146865187886, 0.2026388371134632, 0.2228046813046305, 0.20966569491529397, 0.19872214562950397, 0.21279568311651254, 0.21322150674566243, 0.21396543244412358, 0.23216589986708513, 0.27030579774428853, 0.21436131033407402, 0.19410913442591105, 0.18710062450515608, 0.19969133764438574, 0.2051609606656435, 0.19572588326966178, 0.1835184908288624, 0.19184472296322042, 0.21214891791657242, 0.6816601443928618, 0.7918349731755097, 0.18779603411738055, 0.9033966563685292, 0.19782048200672553, 0.19699874355653013, 0.8657611366714177, 0.20510063596972128, 0.16500902827640984, 0.6815253542756817, 0.3618233707663435, 0.7199314260481589, 0.5821097132372577, 0.20057868765627918, 0.27917280388837484, 0.23491884892400872, 0.36539278065779834, 0.35541195715341467, 0.19706943596100623, 0.18869969040784385, 0.19614167282777495, 0.20038222034450848, 0.19605191202809857, 0.21763470126155238, 0.20523347134586056, 0.18697947220729239, 0.19759180145926503, 0.08166365202884385, 0.09043989993600265, 0.07735810880224692, 0.1159621139886935, 0.08602975393259837, 0.08930666872511006, 0.09840284798844945, 0.09678169339018516, 0.09469674742457901]}, "mutation_prompt": null}
{"id": "f873856d-bb62-4df6-825a-396d196e4335", "solution": "import numpy as np\n\nclass AdaptiveSwarmDEHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.4  # Adjusted for refined cognitive exploration\n        self.c2 = 2.4  # Slightly reduced for balanced social influence\n        self.w = 0.7  # Increased for enhanced convergence stability\n        self.f = 0.8  # Raised mutation factor for diversity improvement\n        self.cr = 0.85  # Lowered slightly to maintain exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Increased initial velocity range for jump-start\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Narrowed range for learning rate\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Faster adaptation for dynamic conditions\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveSwarmDEHybrid", "description": "Adaptive Particle Swarm and Differential Evolution Hybrid with Dual Memory Mechanism for enhanced exploration-exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.30477273856472614, "feedback": "The algorithm AdaptiveSwarmDEHybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8252307203721514, 0.8641809879717492, 0.8356105633089643, 0.7163716489841686, 0.8353446987415454, 0.8145381617497183, 0.6843596692450584, 0.8416065668712278, 0.8341778524805539, 0.5141935240688522, 0.4355135894352127, 0.4473290884128144, 0.5462281217073752, 0.550962168542368, 0.47515830210418086, 0.6473765749410958, 0.5538848005694883, 0.5697031517158251, 0.10912830699293785, 0.139825903731291, 0.10792798967423445, 0.1366180762248208, 0.12333034981648727, 0.15334829266285965, 0.13240365523946018, 0.1620206913708505, 0.15745528214889948, 0.11976131154101588, 0.11700948601066974, 0.12076734411520285, 0.12852806449779708, 0.10491528754727264, 0.11267312099799276, 0.11368079003840814, 0.11474915898693161, 0.1589301041502187, 0.8132122153863997, 0.8011978382773987, 0.819895908391566, 0.8109961664855769, 0.8595468333335399, 0.852184444842039, 0.8448731284529429, 0.8190661853502973, 0.9054639053294242, 0.32334800708564626, 0.42637135083213473, 0.3870947499620977, 0.25953631586749926, 0.2914630686982361, 0.26916518197506956, 0.37155321254315565, 0.16287154973734252, 0.2604928085179672, 0.5461682812511841, 0.4905066436583623, 0.30399623662591, 0.6374615908236838, 0.31109029177803404, 0.6657438612022123, 0.44348495528821985, 0.605653975108899, 0.5860021978630564, 0.2012671820666696, 0.1808177665418751, 0.1612767701404194, 0.14656045669619, 0.16366844914438883, 0.21512666091334076, 0.19845260489371164, 0.3068454936618944, 0.23657866958215967, 0.16805241751784672, 0.19095436096516327, 0.17077682273308037, 0.18951129874931527, 0.22076679523429543, 0.17176592057046147, 0.20141128310194256, 0.197297205203937, 0.17283279007281327, 0.13879125111274626, 0.0002786743996381347, 0.10723126102785208, 0.09034307964064903, 0.09802499849169488, 0.10345402000205717, 0.12551369427926562, 0.0779497529319142, 0.07731666578958263, 0.26018710011321855, 0.10975540650288163, 0.13726130480425003, 0.15020319949225136, 0.24907419912018125, 0.18466601305203167, 0.23423245323659236, 0.261789138603309, 0.20127616892336286, 0.1754033162806612, 0.1314096839510941, 0.1722626481884958, 0.11261227815394215, 0.26463312153205676, 0.1623971025093437, 0.1419300409762465, 0.1225714569038755, 0.21244723063843918, 0.3456364679663553, 0.17601029584304795, 0.15354877757153262, 0.20101760940058477, 0.14276521941804332, 0.13152525826517636, 0.15310266292911145, 0.16002857413228233, 0.15629061012234557, 0.5468332604548878, 0.5283776126170348, 0.5057898736498185, 0.5085371846913507, 0.5267568886196408, 0.5893654184580186, 0.638670040485309, 0.5384231132213831, 0.5315118572657322, 0.4311186296704592, 0.09587471418902149, 0.11055208358930213, 0.10300675986028696, 0.11342918677224134, 0.1302367613183818, 0.11373017937724494, 0.128082370392673, 0.14029285572374062, 0.1622784432315062, 0.21434757610655408, 0.22415637236112151, 0.16899646071676144, 0.1877096661921187, 0.15131916923468558, 0.1932689592309793, 0.17907459664644232, 0.16012401847068325, 0.29761485923352815, 0.3536780880198044, 0.3856997898791491, 0.3356756763899461, 0.36149872413227035, 0.3349293696583463, 0.3875035794503928, 0.35111293454499004, 0.32997569647902103, 0.2515048946392747, 0.24902479556168722, 0.2840162383122301, 0.25313287484097957, 0.262353845734845, 0.29522883870002226, 0.2645990488961598, 0.3121453059136551, 0.26815477466169746, 0.19872972191687255, 0.21421260775073492, 0.23654597106370245, 0.25642622586204566, 0.20277851775004785, 0.2267714398636127, 0.2595790449044374, 0.25980787657311466, 0.25946635190108003, 0.18228341129824366, 0.19192669463359258, 0.1924191734630697, 0.19236696336153014, 0.19858355373266234, 0.2137134563070645, 0.1842955220669107, 0.23080627578721746, 0.19589990411344516, 0.18745812155451835, 0.8116208043293043, 0.1876961757423795, 0.8186620763146322, 0.5930766384850314, 0.19594155181101613, 0.8724883163658177, 0.19171782946423366, 0.18057680195443737, 0.5999003608216364, 0.21012899313702504, 0.4587566352492044, 0.33097670625268827, 0.2073350117274413, 0.2920262692780189, 0.5777687425572358, 0.3787283938395932, 0.2576068590116736, 0.2013978842481553, 0.21553083746033352, 0.20317862448033053, 0.20113711491332498, 0.1967380498666752, 0.22372146539967375, 0.18632905811185296, 0.20277075873829986, 0.22437550708670406, 0.0931264775927293, 0.07984012091791415, 0.09554918674837665, 0.09603092792303303, 0.09588460165808388, 0.09564158273522749, 0.08696430568057878, 0.09561534176292175, 0.09809930108277565]}, "mutation_prompt": null}
{"id": "7cf3448d-0b02-4ea2-8aaa-c3ad111215a6", "solution": "import numpy as np\n\nclass EnhancedDualStrategyPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49445  # Slightly adjusted cognitive component\n        self.c2 = 2.5  # Social component kept high for strong convergence\n        self.w = 0.7  # Inertia weight slightly increased for exploration\n        self.f = 0.8  # Mutation factor increased for diversity\n        self.cr = 0.85  # Crossover rate slightly decreased for variety\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Dynamic velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.25, self.population_size)  # Refined learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Faster adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.velocities[i] = np.clip(self.velocities[i], -0.5, 0.5)  # Dynamic velocity clamping\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedDualStrategyPSODE", "description": "Enhanced Dual Strategy PSO-DE with Adaptive Learning and Dynamic Velocity Clamping for robust global optimization.", "configspace": "", "generation": 35, "fitness": 0.30100502835983156, "feedback": "The algorithm EnhancedDualStrategyPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8131825560413712, 0.7807962781555395, 0.7882533610342938, 0.7485673708347159, 0.7391237622884163, 0.7840670260168364, 0.7719561167343626, 0.785481017229957, 0.7870851035769657, 0.44800543486073685, 0.4503212954845903, 0.403298869867619, 0.574379551207935, 0.327175270661207, 0.5974237948617545, 0.5256971626725492, 0.5566849771495515, 0.5907896458481594, 0.1299027326550849, 0.1250160846928411, 0.1408783444568633, 0.13026877938652237, 0.1324288738729894, 0.12209690337358492, 0.1265044534733395, 0.14450269647814296, 0.13342067153058745, 0.1377794883932203, 0.124473407753665, 0.10213455660140514, 0.12400653229882463, 0.11536298076753959, 0.1177836992835144, 0.13176097023398103, 0.17151952551282867, 0.09769924519999895, 0.7504481685182869, 0.769626785369043, 0.7479039615293857, 0.8049386244038637, 0.8262785719184079, 0.7764682641940561, 0.7807009358448439, 0.8067980660427512, 0.8300927561854929, 0.2948854706425664, 0.290849857050007, 0.40376496326344646, 0.3007701124067209, 0.3241051334267697, 0.1877510841897192, 0.39987681303108913, 0.2734886037524251, 0.22480054583233766, 0.45472494650866135, 0.5907113787368314, 0.2061855108671845, 0.845120237322768, 0.640657568441843, 0.6750203287628018, 0.5702717055362552, 0.5827746292378944, 0.6721991976805894, 0.19701695824803656, 0.15749067690381657, 0.2128037632814368, 0.22038742549930346, 0.15674783466796294, 0.2883362195442215, 0.19497414301074967, 0.311046334975974, 0.16329546075423151, 0.19288118228716966, 0.1411449805428754, 0.19423349155936165, 0.19202698528212148, 0.19952995229013826, 0.14626573563342404, 0.17901339527144022, 0.12150634169566588, 0.1764397113931695, 0.05940536584380496, 0.09996848655550405, 0.09068383848563921, 0.09329346391622062, 0.09095435238967797, 0.1116337633848723, 0.14099698986572717, 0.07559019536600808, 0.09365913497124134, 0.21814303774382948, 0.26180433518971136, 0.23480404301977298, 0.21605579231881034, 0.15599558733057384, 0.22265460124646352, 0.2825268971886654, 0.260451548292846, 0.23515233694603144, 0.08241787409301271, 0.10175838968697737, 0.09845865073504134, 0.163933635310343, 0.10627654890811666, 0.09038931991183252, 0.15267370765635135, 0.16964269010713873, 0.11834960763723612, 0.22874545925250456, 0.174178837717462, 0.17732535110293302, 0.1796147040117244, 0.1349494003669417, 0.14671346467191138, 0.1434372068403612, 0.1546966047350672, 0.16425756260565794, 0.5073890583301957, 0.5436507292333783, 0.5450962012463023, 0.5219372584005806, 0.5485670402533245, 0.5150633079860858, 0.5350199595486925, 0.5338096791254814, 0.5141678877230561, 0.13502478992567435, 0.11702423483419155, 0.09635606635901572, 0.12128835459865495, 0.07942064372251767, 0.10528189331023519, 0.1337775791777256, 0.1373586820099787, 0.22717326109522518, 0.18789750095720892, 0.16090661421867958, 0.1701077776986547, 0.15943407618868655, 0.15107155671178152, 0.19527158375013054, 0.21009333658854845, 0.24751044573959669, 0.30125501976013624, 0.283085263387444, 0.3253054114843402, 0.33894891147857, 0.39994523782815294, 0.37195079398666353, 0.3564694955077903, 0.3327911905102361, 0.3494451466048355, 0.3667290208558255, 0.2493317925559193, 0.2510156437949793, 0.2558843342454271, 0.2579574625869778, 0.334090131770829, 0.26202083374213925, 0.2698355477604033, 0.2522284972226485, 0.25987224748492466, 0.22501557603183842, 0.24899836013830368, 0.2573512675208576, 0.2608399545363286, 0.24850243456756338, 0.2598470984178789, 0.2121656136162502, 0.2579592172765941, 0.21854726750261966, 0.18535615129350513, 0.22434914285320628, 0.20131049870860507, 0.2256829209913055, 0.20770040374372056, 0.1951865602740348, 0.18257226585565411, 0.20234135288227129, 0.19120310065651447, 0.19139634933015381, 0.7762531948554818, 0.45574039995809856, 0.8273318378335843, 0.19530938623897565, 0.1938735131300422, 0.7444860182151578, 0.16412073834520124, 0.554814592781173, 0.6665089031574538, 0.20511247124779353, 0.7162057479146611, 0.4900722573869283, 0.20515894423602699, 0.19751137516572914, 0.48457316500317504, 0.1632753442738818, 0.20223248806115213, 0.19481627761016584, 0.18095679366732376, 0.18916733740242309, 0.18875143267844108, 0.19164027633888558, 0.19995618262071435, 0.19269339452914513, 0.18320249587719584, 0.2024707324032622, 0.08758530331230563, 0.08144141952639306, 0.09806792167026612, 0.09750352375647708, 0.10149090817078155, 0.09481703435015221, 0.08865541635234497, 0.10081760689576624, 0.09850851382336545]}, "mutation_prompt": null}
{"id": "c4ed7344-ca97-45f9-980c-167190d7c77c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE_TVP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 1.5\n        self.c2_initial = 2.5\n        self.w_initial = 0.9\n        self.w_final = 0.4\n        self.f_initial = 0.7\n        self.f_final = 0.3\n        self.cr = 0.9\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            t = self.evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c2_initial * t\n            c2 = self.c2_initial * (1 - t) + self.c1_initial * t\n            w = self.w_initial * (1 - t) + self.w_final * t\n            f = self.f_initial * (1 - t) + self.f_final * t\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.85 * self.learning_rate[i] + 0.15 * np.random.rand()\n                self.velocities[i] = (\n                    w * self.velocities[i]\n                    + c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE_TVP", "description": "Enhanced Adaptive Dual Population PSO-DE with Time-Varying Parameters for improved exploration-exploitation balance across diverse optimization tasks.", "configspace": "", "generation": 36, "fitness": 0.30728038317269435, "feedback": "The algorithm EnhancedAdaptiveDualPopulationPSO_DE_TVP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8327423008044907, 0.8064921277390215, 0.8125267461465207, 0.8096057842168336, 0.8224742693062347, 0.8585600032027261, 0.8345548200984378, 0.8035264010732205, 0.8590255642716724, 0.56499812274092, 0.5517156258197603, 0.07245777078739535, 0.6512671122839538, 0.22691519175554686, 0.6207996890923067, 0.5509927205206038, 0.49645671832576077, 0.5831012362819098, 0.15605286481857306, 0.1469710426027223, 0.1425121812948399, 0.14804453859636701, 0.12604385154604913, 0.163170982983333, 0.13644196266947506, 0.1427263902389987, 0.15022731535817768, 0.11587649780499831, 0.1170890547677913, 0.1210058836907274, 0.13229817757404594, 0.10920893291938505, 0.11696357922668288, 0.11020179094313409, 0.11631636406137025, 0.12999646096253492, 0.8714488459925601, 0.8809901195868424, 0.8191273321092956, 0.7992677447263103, 0.8397437226157386, 0.8606894480952333, 0.9037266884969372, 0.9115720200593708, 0.8940930613978688, 0.20017357576339612, 0.2184953608070611, 0.277023288004289, 0.3541004038119059, 0.3530911894772697, 0.22939501410314667, 0.42701989995222467, 0.2072483359412025, 0.3404774520276542, 0.6104519384753115, 0.6107982115851684, 0.2251811018835026, 0.36846795101592056, 0.6460602903072163, 0.6807262710027956, 0.2067735173510169, 0.6953375913428647, 0.2396452818667847, 0.23824759981901344, 0.18070089113434296, 0.14978359629229288, 0.15454300769835572, 0.3370821382958996, 0.14180470675821455, 0.2701993503448177, 0.1800626808809166, 0.2047481810143852, 0.21540392671558461, 0.1451812025387086, 0.1317771003142456, 0.19856327695724885, 0.1310481886661382, 0.16176950691625336, 0.20584197380513292, 0.2473661407482749, 0.23734403775882473, 0.06581333648109466, 0.0847403147686584, 0.00986952301606947, 0.10962272983419152, 0.08674590152413109, 0.22166289410549622, 0.1327599261473148, 0.2513882404052048, 0.0436168901716415, 0.1443784489473683, 0.1175960637316843, 0.12058821745679449, 0.11454495427350853, 0.16969568679373315, 0.10825576888605337, 0.3276012483671331, 0.12527455818106825, 0.13692642294299984, 0.1510018968242759, 0.1264236481299691, 0.1781088071575916, 0.11769987909301438, 0.15072684597970198, 0.09851068425723608, 0.16255676359207571, 0.16720012481209434, 0.11804073076112886, 0.18228248162913163, 0.1979844710640709, 0.26102590734414055, 0.18055442974738722, 0.32376712620426074, 0.2969853657663518, 0.18937295327104253, 0.12193625001294861, 0.16763421118444277, 0.47432774092206753, 0.6029225678496983, 0.5367014337248592, 0.5083934721652197, 0.5089337135302762, 0.4933485743437561, 0.5312835371477755, 0.5554293015438005, 0.5132461046353562, 0.12343836000045172, 0.11439594142331844, 0.0980034334455635, 0.10932078125959688, 0.12802465142466568, 0.11081859539711791, 0.12653999881682687, 0.11945469895950955, 0.12075080968877228, 0.44270393288886634, 0.16021820957765853, 0.2171552381984807, 0.1716377448227313, 0.19860589221795089, 0.17875128763256276, 0.19008574654369192, 0.17960465505383894, 0.25345227656989655, 0.3508126010254009, 0.33279322450904025, 0.3311682965137559, 0.3646611037355405, 0.3804331472781487, 0.3608732185119107, 0.42222079895614695, 0.41059825405660944, 0.39582217782684925, 0.24386024246130378, 0.3067481142430114, 0.2962096629410613, 0.18741273219791754, 0.3405241175857783, 0.25638786113982603, 0.30048608638570984, 0.24927981679557354, 0.24524203740593065, 0.23285940422684592, 0.25239262517398287, 0.2201932180211933, 0.24224132326173797, 0.22969820609620506, 0.22051714665176236, 0.20856825581933236, 0.2286633327133495, 0.21047385587796075, 0.1999447951723119, 0.499238896414532, 0.2118354271977254, 0.22117270375523002, 0.20743497079443307, 0.2097013076359009, 0.19271972034722407, 0.22197193546135385, 0.19921148646726594, 0.8466973911157857, 0.7227249622773868, 0.18698355414397716, 0.8834055923470402, 0.19821289618975835, 0.19683082898151139, 0.754991320110228, 0.20605979718433787, 0.16583281225996183, 0.5356102034839093, 0.6313436162601953, 0.6706723756085771, 0.5891182973477265, 0.20413832159350553, 0.20134196212146394, 0.20995849920664034, 0.4147298290613991, 0.5092507044874812, 0.1990149950843636, 0.18600133224734872, 0.18485060744517534, 0.17508396345035193, 0.21742077474119592, 0.20153460410731527, 0.1904647867114342, 0.20140141708079495, 0.19165370865538212, 0.1221700431096624, 0.08101287220092868, 0.08943868357090179, 0.08944879518227555, 0.08969233226306628, 0.09771863058136532, 0.07829272756052652, 0.09200790056277197, 0.10068387867498918]}, "mutation_prompt": null}
{"id": "03eb7db8-2a60-4ccd-a821-417695df39a5", "solution": "import numpy as np\n\nclass DynamicAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 2.0  # Further adjusted cognitive component for increased local search\n        self.c2 = 2.0  # Reduced social component for balanced global search\n        self.w = 0.5  # Reduced inertia weight for faster convergence\n        self.f = 0.8  # Slightly increased mutation factor for more diversity\n        self.cr = 0.85  # Reduced crossover rate for diverse DE solutions\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.03, 0.25, self.population_size)  # Adjusted learning rate range for dynamic control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.8 * self.learning_rate[i] + 0.2 * np.random.rand()  # Slightly faster learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicAdaptiveHybridPSODE", "description": "Dynamic Adaptive Hybrid PSO-DE with Multi-Scale Learning for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 37, "fitness": 0.30121197327252464, "feedback": "The algorithm DynamicAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8119003538806058, 0.862973455985162, 0.8504712131363026, 0.8457473638220813, 0.6814834074321585, 0.8092557043557687, 0.8272992783974639, 0.6820303594691439, 0.8538070097343191, 0.6008038216378272, 0.5876780033680508, 0.38651436284089424, 0.481028739394305, 0.5014827879697713, 0.5701610240744341, 0.3968829925308899, 0.43219038926570097, 0.4140238255568782, 0.11863388678536047, 0.14315370920521675, 0.1214171038950499, 0.10339993463222275, 0.1145094017566124, 0.14146744041762427, 0.11134120553884985, 0.13359397006233342, 0.13542661831193326, 0.1082282689717946, 0.09822952856790013, 0.11291693711775153, 0.1296767724324407, 0.1040883966525693, 0.10199026861264626, 0.13693666402215365, 0.11246055966591206, 0.10515286870255236, 0.7872749574734341, 0.8423136720479648, 0.7778324416316201, 0.8520341219118667, 0.8344065494268806, 0.8637032680808885, 0.8906797499365149, 0.8702989537303389, 0.9052632886760418, 0.3977240718709729, 0.3315622572494734, 0.23395052693752005, 0.3080859057601941, 0.34445412942764864, 0.24424601178728467, 0.28214284955534796, 0.1796121206629545, 0.29489869356605414, 0.5548760773158818, 0.4868743455689255, 0.56576187270197, 0.5909516308835862, 0.6105734909784437, 0.6648055497519068, 0.5054772082944949, 0.6071713135173666, 0.591031092528747, 0.28722680294534375, 0.20181985892685994, 0.13826629899580023, 0.15064238394829388, 0.1599416010459801, 0.15527103558621913, 0.18353756705598412, 0.35893550018153597, 0.3647990387866821, 0.16353639000887565, 0.14653383453241764, 0.14196141766671977, 0.17990672178731404, 0.1598653242284832, 0.13946248846264242, 0.17366802383573454, 0.1466551612460023, 0.14543526375599958, 0.10236576683803666, 0.04508819968713884, 0.06985599702157308, 0.14031528504509683, 0.09150191252061135, 0.09133159235026256, 0.08316908568041581, 0.07529579317164603, 0.06493047188547185, 0.18700702836441296, 0.22646736863629435, 0.22703421709902016, 0.19976442879018708, 0.250666985165666, 0.19233063753429813, 0.2441384742519317, 0.23731108871842221, 0.2591049662989334, 0.1556931704261577, 0.11381220249864732, 0.20669303578403275, 0.11408650028464284, 0.17533476750282262, 0.16324003083769145, 0.11988369869186266, 0.2379097359624115, 0.19738506538523537, 0.1796796704443011, 0.14978254623611975, 0.14066868779650543, 0.16707750519706444, 0.14175499001565328, 0.15870531148164246, 0.15840536748080236, 0.1515965406263856, 0.1798200794812761, 0.5330233159295832, 0.5424046955949009, 0.5159059562090182, 0.5230411297268207, 0.4722872871067365, 0.517490911243346, 0.5911641413680728, 0.5137739916492717, 0.5109328360482481, 0.16048120276511724, 0.11926614569290273, 0.12691800695021194, 0.1188244177998733, 0.1402297700951851, 0.11695487234668256, 0.11863536077767844, 0.15654068665083598, 0.11568751508411956, 0.20127706797524747, 0.2415920037152015, 0.17547147789739503, 0.19012369235470516, 0.2633366468065351, 0.18712667980396647, 0.18702578883559262, 0.21739264538562852, 0.17605423652433694, 0.32779542078587887, 0.3552198620617346, 0.3632331760216764, 0.30212681558326204, 0.3594176605537075, 0.32179205587165916, 0.42685855775376647, 0.3270046601836629, 0.32940403691627695, 0.22754683622902838, 0.24089656166292905, 0.2511027587497965, 0.3149796661051787, 0.23779387566071097, 0.24249151158265947, 0.2451298376794896, 0.2653026128678736, 0.2585852044014788, 0.21065004558431188, 0.2326532196087433, 0.1938870265890733, 0.22824929405685512, 0.248507765080907, 0.25415366709067366, 0.2070278129349088, 0.2088881971708334, 0.19666211065721706, 0.1931584954223985, 0.1877605849665116, 0.1979788307411945, 0.19803368392135778, 0.19758555431623392, 0.20092258072454483, 0.21325544630519322, 0.1874077378671678, 0.21090041998074516, 0.19151340781066606, 0.569951334400746, 0.4751964346677985, 0.5942023415165267, 0.326790739653409, 0.197370474594185, 0.8706004766666691, 0.33050821378573914, 0.46658384117358287, 0.6405070191661228, 0.5588219189951983, 0.4476536220379126, 0.3364976432882836, 0.2871447575976367, 0.20500383676784395, 0.42456027953027364, 0.20223030431579048, 0.2064098828718951, 0.19411465530648342, 0.20104175413186665, 0.18749792488671357, 0.18953150597893742, 0.20156144857013114, 0.19763831951705513, 0.1933160622406931, 0.19761573200447125, 0.18615309707182537, 0.09031262074479451, 0.1006947554998886, 0.07640552351580887, 0.09436341153594097, 0.10687799215133709, 0.10631811589453755, 0.08296262721930614, 0.0924793550699391, 0.09099203299189162]}, "mutation_prompt": null}
{"id": "102bebf0-0b80-4c30-8ce0-d7048dfcacf9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.5  # Adjusted acceleration coefficient for social component\n        self.w = 0.6  # Slightly increased inertia weight for better balance\n        self.f = 0.7  # Reduced mutation factor for controlled diversity\n        self.cr = 0.9  # Increased crossover rate for higher DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for finer control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.85 * self.learning_rate[i] + 0.15 * np.random.rand()  # Slightly faster learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Exploration and Adaptive Mutation for more efficient optimization across diverse problems.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8525777030373791, 0.8516342117807258, 0.8454112583762484, 0.829800498231355, 0.8273379272538617, 0.8502415979032695, 0.8396695115252604, 0.7180401259661296, 0.8453029843456508, 0.421377285759136, 0.5372801402543462, 0.4407040333051703, 0.4737886227395577, 0.6559256873705004, 0.5350881673421242, 0.47374367263307426, 0.6261315808593853, 0.6336242509014283, 0.18225416860893806, 0.12405560243771652, 0.12240421895244347, 0.15341666132829346, 0.11394029189033028, 0.11482764537514101, 0.13116720474273713, 0.13078092319622314, 0.6630099728615091, 0.11711978260183564, 0.12237465181412532, 0.1085529482296328, 0.10676953741716111, 0.07937333271439728, 0.10582854159649047, 0.11027412624252608, 0.1158594023192947, 0.12514621982497887, 0.8063604102139781, 0.7856460381281206, 0.8111479480162114, 0.8387985070199409, 0.8331714799748353, 0.8641853988261313, 0.7971629777411295, 0.8926278265739103, 0.8265795636915176, 0.316737917511392, 0.2939033145401453, 0.1852791485932438, 0.22215747476543546, 0.3300228205920652, 0.21047775993719242, 0.3337476153649124, 0.2448397864605557, 0.3468727115764363, 0.6736072902656614, 0.701043042875904, 0.6473807340574171, 0.7506348989976774, 0.7602094961121924, 0.681014663957023, 0.6186969980060584, 0.6491888106093351, 0.7274334115488809, 0.15491843406658679, 0.18431979200858917, 0.1627812623082393, 0.17731648643985487, 0.24892600807027587, 0.1270966034898181, 0.21184704870728344, 0.4562388681919438, 0.15064812268674654, 0.23100511256937162, 0.16289534990952215, 0.12606789561986131, 0.21639850507523328, 0.14012499635144593, 0.19184465959523445, 0.20229587330447518, 0.19734037499096924, 0.29165620336433895, 0.21398297840068858, 0.019739492553785043, 0.044120787908873194, 0.10060979266099224, 0.17909102074480376, 0.20041106069861658, 0.21107424250139095, 0.11417360613530947, 0.05890066111567305, 0.14549424437395375, 0.15744230335420795, 0.15024890236679111, 0.13265767342187462, 0.20206276258278533, 0.26966564525885284, 0.3188451589272653, 0.16242154581783375, 0.33090449038754954, 0.1879911351362914, 0.13659632587015236, 0.13490893919103997, 0.13937323226204612, 0.15952571536981797, 0.1582367988252812, 0.16879322248438844, 0.15167585156137797, 0.1367309189969672, 0.22570055386644294, 0.2079132655267858, 0.2729814901218113, 0.248035527272909, 0.1588993812985049, 0.2078409413706479, 0.14972604759920727, 0.14802329828563088, 0.18198564651846671, 0.5383066334097246, 0.6445116643943949, 0.5631841336909126, 0.5120570780257188, 0.5725709592205108, 0.5732386930865558, 0.5641628997289507, 0.5731815754903058, 0.5444207485605908, 0.11563176199514658, 0.10748996525890031, 0.09641500006648052, 0.13198518573238338, 0.08704423660096894, 0.09982856184228062, 0.14970842309603505, 0.10304578064758696, 0.13106311502801604, 0.2646802639595649, 0.13163949229699867, 0.23873631355889258, 0.190422769294044, 0.2505470637128605, 0.17091006676404774, 0.1608920127101392, 0.18475316915187956, 0.23323144037548482, 0.3400241474829686, 0.35030498354817396, 0.35777028112279874, 0.36943258179981087, 0.33983180057387274, 0.33208090049879724, 0.3801033459493227, 0.379683924177425, 0.40018317345887844, 0.3080368275695067, 0.26183020002164326, 0.28846663100474146, 0.27066685557384107, 0.28549980799201524, 0.3038733424798039, 0.2981959017046111, 0.2441575445486288, 0.26113146865187886, 0.2026388371134632, 0.2228046813046305, 0.20966569491529397, 0.19872214562950397, 0.21279568311651254, 0.21322150674566243, 0.21396543244412358, 0.23216589986708513, 0.27030579774428853, 0.21436131033407402, 0.19410913442591105, 0.18710062450515608, 0.19969133764438574, 0.2051609606656435, 0.19572588326966178, 0.1835184908288624, 0.19184472296322042, 0.21214891791657242, 0.6816601443928618, 0.7918349731755097, 0.18779603411738055, 0.9033966563685292, 0.19782048200672553, 0.19699874355653013, 0.8657611366714177, 0.20510063596972128, 0.16500902827640984, 0.6815253542756817, 0.3618233707663435, 0.7199314260481589, 0.5821097132372577, 0.20057868765627918, 0.27917280388837484, 0.23491884892400872, 0.36539278065779834, 0.35541195715341467, 0.19706943596100623, 0.18869969040784385, 0.19614167282777495, 0.20038222034450848, 0.19605191202809857, 0.21763470126155238, 0.20523347134586056, 0.18697947220729239, 0.19759180145926503, 0.08166365202884385, 0.09043989993600265, 0.07735810880224692, 0.1159621139886935, 0.08602975393259837, 0.08930666872511006, 0.09840284798844945, 0.09678169339018516, 0.09469674742457901]}, "mutation_prompt": null}
{"id": "a367d926-e509-401d-af5a-4c4fc8d526b4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.4  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.6  # Adjusted acceleration coefficient for social component\n        self.w = 0.61  # Slightly increased inertia weight for adaptive balance\n        self.f = 0.65  # Further reduced mutation factor for enhanced stability\n        self.cr = 0.85  # Altered crossover rate for moderate DE convergence\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.25, 0.25, (self.population_size, self.dim))  # Adjusted initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.07, 0.28, self.population_size)  # Refined learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Altered learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE", "description": "Enhanced Adaptive Dual Population PSO-DE with Incremental Learning and Adaptive Control for diverse problem-solving efficiency.", "configspace": "", "generation": 39, "fitness": 0.3074764078900057, "feedback": "The algorithm EnhancedAdaptiveDualPopulationPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8315792893031223, 0.8663455929761323, 0.8286813321115466, 0.7172945602446371, 0.748662564111503, 0.8133691294261001, 0.8202626744708453, 0.8256594847198044, 0.8558594877550851, 0.5007239489727152, 0.6069505654446601, 0.2448089880733647, 0.5420913396011542, 0.576214462869375, 0.5441748230249392, 0.5816588126746893, 0.6382198153258348, 0.5477775724785952, 0.13179460210986194, 0.1354273149298868, 0.11198181266952467, 0.23300978843794395, 0.1442627024322155, 0.13108348047135765, 0.14173446300385406, 0.10517021181815545, 0.12914408327974902, 0.12188487062073905, 0.12793708299504292, 0.10674075946938488, 0.12867022700862796, 0.11637155969557367, 0.11067513514389815, 0.18049416332613366, 0.11036049259463454, 0.1098424856893715, 0.8076272157911445, 0.8387992956705476, 0.7425158025251593, 0.8127105844038274, 0.8548729503635052, 0.8450069612878313, 0.7657895116947824, 0.8603518454631853, 0.8973102759647015, 0.4226742288755574, 0.34344001412400915, 0.27519037946166036, 0.2231734480539097, 0.369201452822134, 0.28451889474536285, 0.4904184798869081, 0.1828175708086761, 0.1952969019405698, 0.5487318989942422, 0.3495434765518961, 0.6110600275950198, 0.6753220038373833, 0.7262030204175127, 0.775237761739061, 0.4168013841083641, 0.21115873419815423, 0.3168773927942996, 0.21329595662806777, 0.18376228996679878, 0.39002894061770277, 0.19562751399727263, 0.15784938718727626, 0.13383221142764756, 0.15792369478456292, 0.5065960327912356, 0.1369279025085649, 0.16187288710834125, 0.13333515129815354, 0.13296274738562897, 0.20394859734239512, 0.21834401966909223, 0.14147088127471374, 0.15798479138829857, 0.21016898762758895, 0.13742745345218632, 0.11057562607284777, 0.061843753550628766, 0.009759436375089914, 0.09667754953137098, 0.0028591395518727802, 0.08092541302477729, 0.09805683133150633, 0.08004690991042773, 0.0006273169593503658, 0.24435802142773877, 0.1111914264565721, 0.17708051875513287, 0.12349394574380346, 0.24108827828085944, 0.16424641480809243, 0.248521765522683, 0.30006307407893373, 0.15452722085675052, 0.1564280247447325, 0.13792949350345096, 0.1585330786953969, 0.18666193798084307, 0.22750024218694065, 0.19341598296981355, 0.1595634864092641, 0.23820176045887165, 0.15922888865148177, 0.20065190401555932, 0.1924054569522986, 0.30250535461204153, 0.22344002602873114, 0.07604894418954133, 0.14248281335251356, 0.1887417080642304, 0.1978497992107695, 0.15986678838463741, 0.5379964150447585, 0.5331871702119134, 0.503786052353024, 0.5348222415546281, 0.5448351862680441, 0.563035782158785, 0.5711811334930915, 0.5449093510088295, 0.556787450595204, 0.11954046254493456, 0.12591975900434105, 0.1477414429277606, 0.13634832886427062, 0.0983451715767969, 0.11032834267769298, 0.107133154941361, 0.11424731477753047, 0.11496874674117696, 0.2272557697418116, 0.17681182272263363, 0.16390572166671136, 0.16675015496286594, 0.198379774039112, 0.16790480247825146, 0.18183297766611628, 0.12528423414416956, 0.1654374743297522, 0.34679858909587924, 0.38402558166469225, 0.3600274404440795, 0.35116233048490064, 0.3760962397750669, 0.3486601941457056, 0.341746546300583, 0.40578964913275817, 0.3697281887256305, 0.24663688828124664, 0.26442121746466696, 0.2612166679940221, 0.25241535959915373, 0.2936140012586801, 0.37136336214960064, 0.2565246163816849, 0.2744143812501396, 0.2680231274757773, 0.24526797920695587, 0.22858319643968183, 0.2524413738171454, 0.24079496981243276, 0.26428233136434987, 0.24402686393454598, 0.2608518728487058, 0.2677690641428725, 0.2397533135922587, 0.19657686572581357, 0.27831083762719555, 0.18974084326985863, 0.21991868252326408, 0.2340877072504428, 0.22486168243639937, 0.21158358879328976, 0.2178775033305248, 0.22853180809231233, 0.19507883746046795, 0.8328279693357673, 0.18777092056416633, 0.7306442794148278, 0.19773970935951302, 0.19778123885004784, 0.8391796397131072, 0.4952696206576601, 0.6022086555590456, 0.6708136053596293, 0.30781963416900093, 0.6031703874307146, 0.5853476293116053, 0.20681529556000555, 0.24879368381311984, 0.1667696355056867, 0.3386242836191754, 0.2738825927760822, 0.18493119107844946, 0.19291137265966496, 0.19315283929869176, 0.20625157310431896, 0.23988715529386573, 0.1924281721187625, 0.22459468627625512, 0.19529174416752926, 0.1940731748382063, 0.10202118724009013, 0.09860019505745676, 0.11124291091162775, 0.09117610079843785, 0.10210634998627521, 0.09609218127724584, 0.0928303190222578, 0.08225712200961155, 0.08758813381042163]}, "mutation_prompt": null}
{"id": "ec36dd3f-53da-49fe-b46f-64fd9b750714", "solution": "import numpy as np\n\nclass DynamicAdaptiveMultiStrategyPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 2.5\n        self.w = 0.5  # Altered inertia weight for refined balance\n        self.f = 0.6  # Further reduced mutation factor for better diversity control\n        self.cr = 0.9\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Further refined initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Adjusted learning rate for stability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Altered learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicAdaptiveMultiStrategyPSO_DE", "description": "Dynamic Adaptive Multi-Strategy PSO-DE integrates adaptive inertia and multi-strategy crossover for robust optimization.", "configspace": "", "generation": 40, "fitness": 0.27354266023919355, "feedback": "The algorithm DynamicAdaptiveMultiStrategyPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.7089012567700411, 0.7725676214917828, 0.8281911759437222, 0.7706595485760601, 0.7119213981850656, 0.706195798802353, 0.7601011415059877, 0.730277301575826, 0.8299014272940135, 0.5394944728506619, 0.41853333595991493, 0.466461344328138, 0.41134106452116515, 0.3153269588482469, 0.06807086049840161, 0.09475627714169588, 0.6087771074764292, 0.24893432917437897, 0.1329243276454023, 0.1427020707572072, 0.1497021429083607, 0.1308522210765295, 0.1386910011477075, 0.13569878081118147, 0.14409576751616515, 0.13169128498038696, 0.1265120319035241, 0.117255408669938, 0.11533111117632433, 0.10244349926480134, 0.13817958856083878, 0.09921200461031099, 0.10277151296380338, 0.1589473491945731, 0.11533005991564083, 0.12123923454645524, 0.5523614222988753, 0.7140714368318621, 0.6894742107244738, 0.74871296441547, 0.765938834752078, 0.27332939994783756, 0.6206616085472363, 0.8663521995811689, 0.8816032343548285, 0.15637593481348944, 0.13691022209024994, 0.07850112090045569, 0.2252143787011459, 0.23238440354315903, 0.16977824568776956, 0.293014335598347, 0.07428519583127058, 0.2105311117371943, 0.1926315467483326, 0.22799306605496006, 0.20263748865638753, 0.25225478355227715, 0.6259337071426876, 0.6204352486955036, 0.7554642508652782, 0.6280453988291724, 0.24240389622287695, 0.1518186715220321, 0.13024446070681117, 0.14676453125438693, 0.134349559544648, 0.18173579990936228, 0.15669035065992554, 0.327445997781979, 0.2711990897366402, 0.2390988115991064, 0.169716796498947, 0.17586150195956873, 0.17439510588284413, 0.2433200045868038, 0.13589219844475664, 0.17885583761724555, 0.1705621608026946, 0.13959571126597492, 0.13507127435082145, 9.999999999998899e-05, 9.999999999998899e-05, 0.09861956656164717, 0.16620478582692355, 9.999999999998899e-05, 0.029274478504829893, 0.04734734833628462, 0.05306970095951802, 0.09772650177525988, 0.2522531304033683, 0.10908343977037671, 0.13365712593399637, 0.09599210481214393, 0.3305950581548033, 0.1750686000559224, 0.18690401350556507, 0.14793497968738956, 0.14247814273162895, 0.06427007142946206, 0.12124349351254493, 0.19809404874211434, 0.18572593114511016, 0.14157447276285873, 0.1899683090675931, 0.14896885616579092, 0.18734463193171091, 0.036949555750741325, 0.19120326261205123, 0.21448117733179395, 0.2699806371353173, 0.23404517264417013, 0.1580469880783818, 0.10765649596055393, 0.16691938309159193, 0.14857468122000228, 0.1561806178444065, 0.4980475001219695, 0.5019271411946562, 0.4622529021421473, 0.5406167237071466, 0.4430853927075621, 0.5316924422174627, 0.5630292818676097, 0.51870486005091, 0.5773101459046965, 0.13068734529902248, 0.09077245811031676, 0.08269498939549647, 0.10537214392435834, 0.12003810182960928, 0.0946325926071917, 0.10707512779445982, 0.12755233995963755, 0.12446282220482285, 0.1697979962824132, 0.30990789027601284, 0.1643282125599852, 0.1852829488273049, 0.1987698323220799, 0.2054630269134754, 0.2564891578434092, 0.2775397346280599, 0.2717924009600605, 0.35099716493079547, 0.3418816215268624, 0.2842041211730362, 0.35360163042460147, 0.36823051343763824, 0.377166485968663, 0.3524118533889664, 0.39803991431631236, 0.386980343160651, 0.25004267235297195, 0.2774951700027237, 0.3349546306634402, 0.26248268681433184, 0.29936404501678104, 0.30711358343734396, 0.29762908052394055, 0.2739800650385906, 0.2699141506104462, 0.23931036465180056, 0.25159209998121734, 0.21958295254856042, 0.22529897625265294, 0.23172027348919655, 0.2272826121475392, 0.24874506452211886, 0.2426270534625652, 0.225194564336204, 0.1987932377452063, 0.26862536609118337, 0.1891901006408443, 0.21099819596120184, 0.2109653388991285, 0.22996540574566338, 0.2110135814985329, 0.20026361927649228, 0.22828049560352826, 0.192150890491128, 0.7629962306830566, 0.18748077077457737, 0.8123473421070433, 0.1977633422260131, 0.19754937835042852, 0.8208795980258509, 0.16120624898212577, 0.6198609798624316, 0.7368463379108948, 0.21062283992606357, 0.471452222138246, 0.38292462353890966, 0.1994823539174707, 0.26985429640677017, 0.19547668695353448, 0.3479961092908104, 0.20794598718588964, 0.19349564313062495, 0.20141074235803536, 0.19172077289038802, 0.21375764650323548, 0.1765750074188378, 0.2168219645638585, 0.20571526421298048, 0.19678717974008042, 0.19688857167220053, 0.08518057996363715, 0.10201477479930532, 0.09260548599677565, 0.09160763961694063, 0.10673490820219556, 0.07135955169273456, 0.08427304683252113, 0.10094890084753139, 0.09557005187124579]}, "mutation_prompt": null}
{"id": "73405e5d-acbc-44e6-9002-3b1b861c68bf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE_2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.6  # Adjusted for better cognitive influence\n        self.c2 = 2.4  # Adjusted for better social influence\n        self.w = 0.7  # Balanced inertia weight for stability\n        self.f = 0.6  # Fine-tuned mutation factor for diversity\n        self.cr = 0.85  # Adjusted crossover rate for diversity\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Tweaked for more dynamic control\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.8 * self.learning_rate[i] + 0.2 * np.random.rand()\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE_2", "description": "Enhanced Adaptive Dual Population PSO-DE with Strategic Diversity Injection and Adaptive Influence Balancing for improved convergence and robustness.", "configspace": "", "generation": 41, "fitness": 0.2830766631843682, "feedback": "The algorithm EnhancedAdaptiveDualPopulationPSO_DE_2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8209806462761537, 0.8536157056526144, 0.8089998468691979, 0.8018027337630649, 0.800839100545614, 0.8609417132951425, 0.8309165516653566, 0.8215509812091384, 0.7953006231327531, 0.4039309750107145, 0.45862850690155677, 0.3123003328056967, 0.3243424499189479, 0.22650842716094044, 0.34305848659805316, 0.3349038770480294, 0.6255576551585105, 0.38839678922833976, 0.10028605951181946, 0.10971822924291774, 0.11822341221515431, 0.12631567386083864, 0.16025615384919112, 0.12942180167052209, 0.11949068603444157, 0.11565521716332638, 0.12163092656891827, 0.08714745557235115, 0.11245267160904637, 0.1197272016452845, 0.09565531377694148, 0.11265107063832258, 0.09018365542426399, 0.13885393709864946, 0.11570918898253402, 0.11140378642578685, 0.9492260171421162, 0.9249052111788036, 0.9008489694149437, 0.9013920686108652, 0.9246871621505892, 0.9175260800318278, 0.8473701648247176, 0.9353540919070149, 0.9168940030918845, 0.2838994350164874, 0.24100814331207343, 0.24796740087829638, 0.6151575038060262, 0.2633341682806042, 0.44537034568213496, 0.5117521660041741, 0.24461297917373837, 0.280914783271502, 0.41019248862134183, 0.3150661726350177, 0.2878436049606814, 0.6146353318815094, 0.28286433337671313, 0.45774355053587734, 0.2703563243321999, 0.33728509467315737, 0.45355612799379463, 0.1862211311866756, 0.15054426310570912, 0.2672824042097395, 0.14477694810044794, 0.14380835756019839, 0.14176049974296168, 0.15738192406138318, 0.1466620890949012, 0.17383373611692532, 0.17107742533933978, 0.38312566769255274, 0.14459873268722878, 0.18684459231171224, 0.15064841025975872, 0.38753570996079145, 0.13948291366206245, 0.16438352148656832, 0.16996141250335406, 0.072578435934602, 0.04218615209601562, 0.07471298475150456, 0.05336073079220749, 0.032126426753639525, 0.026310453716904103, 0.05695899414358008, 0.034287430392353824, 0.025752683727486847, 0.17212808776145516, 0.15742931030503204, 0.14487030089045927, 0.14164785162030324, 0.1378668347826555, 0.1373979023973907, 0.14385776499967307, 0.1705128319986996, 0.18102576450783125, 0.1664849070057911, 0.16565088349005075, 0.1658850746438142, 0.10977059500054343, 0.20506318313586303, 0.07333594286025069, 0.13870918327959247, 0.20183611741397212, 0.11891108370948733, 0.13203753245052596, 0.16678127281437083, 0.12071001688355176, 0.1007246865196223, 0.18552849275693317, 0.2967669229312122, 0.09857917192940835, 0.1084733572714589, 0.10558783825661378, 0.4816081717860108, 0.5117330882509474, 0.5154733696168721, 0.512803096280686, 0.47710162778608245, 0.544530537915901, 0.5265238133437602, 0.5249424583581028, 0.5150943693487247, 0.10799102697012808, 0.13508622011721239, 0.08544420054570201, 0.11069667151267604, 0.09488931652038934, 0.1750116096142369, 0.10089573578447963, 0.13899013586564202, 0.1303307752488736, 0.23970395611420325, 0.25148395246847854, 0.23929459052176516, 0.18450614892032446, 0.1874674072070125, 0.19032190870305188, 0.1420912146804334, 0.20582241264239676, 0.1808977845343236, 0.27663630118895144, 0.2839738354483845, 0.2798206564537491, 0.27893670267154325, 0.3047966300664613, 0.2749802010001353, 0.30278231643783293, 0.30624345610145887, 0.3074134436051862, 0.2276666088456133, 0.21129384768265014, 0.24395870459136115, 0.20064386669730627, 0.29340809542791557, 0.3219667435893995, 0.22588167600549647, 0.2611316812321859, 0.208279845237764, 0.21769172064383613, 0.20357656313052386, 0.22569282306903937, 0.2378433013680038, 0.18328323662558, 0.20247121711113492, 0.24844512970112287, 0.2092247798814052, 0.2363099436681202, 0.17372237252303346, 0.17554320260126555, 0.18052736945140946, 0.18397849037641623, 0.18983609434733284, 0.18744878501460138, 0.20046330000638013, 0.2070136856228212, 0.19520165706341208, 0.1770409306956302, 0.16994410541953398, 0.2199212188733105, 0.8507368727819313, 0.80311469437419, 0.19814092416779183, 0.5093949403618785, 0.16822110438970705, 0.1887167250770383, 0.6688924370792304, 0.2116999459318144, 0.2826596625458867, 0.620988614121891, 0.4072719104645044, 0.28746460232894155, 0.4241595564052518, 0.6470917543999963, 0.23797082991796192, 0.18179868309979452, 0.19435278831869096, 0.2062522667100286, 0.18834960701006087, 0.20322176386659863, 0.19673841056454144, 0.19106997044413832, 0.1828577610492741, 0.18713529846889865, 0.0937687232481188, 0.09973398627851804, 0.06951379999103413, 0.10033963563912951, 0.08505301526647868, 0.0985116186898849, 0.07287191538870297, 0.09659838435368495, 0.08923839562682245]}, "mutation_prompt": null}
{"id": "938f009c-d6cd-4c80-b99c-1cddbf1fd9d2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPopulationPSO_DE_MSE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.6  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.4  # Adjusted acceleration coefficient for social component\n        self.w = 0.5  # Reduced inertia weight for enhanced exploration\n        self.f = 0.8  # Increased mutation factor for broader exploration\n        self.cr = 0.8  # Reduced crossover rate to maintain diversity\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Increased initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.4, self.population_size)  # Adjusted learning rate range for stability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Adjusted learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveDualPopulationPSO_DE_MSE", "description": "Enhanced Adaptive Dual Population PSO-DE with Dynamic Exploration and Adaptive Mutation now introduces Multi-Scale Exploration for diverse problem-solving efficiency.", "configspace": "", "generation": 42, "fitness": 0.2952211937292452, "feedback": "The algorithm EnhancedAdaptiveDualPopulationPSO_DE_MSE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.21.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.7281696970750223, 0.6655113404516955, 0.7506058306121655, 0.7301383392458356, 0.7633938963234524, 0.7081795662592103, 0.6527506130788912, 0.6683161961577728, 0.8466429064147404, 0.6051956781138534, 0.42524813188644883, 0.40576906728696127, 0.5466192807956465, 0.45085154231221514, 0.4868802967359127, 0.43936180206055, 0.43364168885508514, 0.4408095829096146, 0.1546068931450032, 0.17123026034242195, 0.12876455198047565, 0.12665218321087324, 0.15500045295679588, 0.13918211883215514, 0.12112711411563848, 0.12944749198341887, 0.15448815227289814, 0.10143643035581185, 0.09952713565977556, 0.10639071785517917, 0.10735889244014418, 0.10053035611314232, 0.10585940485211609, 0.12155088307826534, 0.12793163072030478, 0.10327360492948867, 0.8343477246184318, 0.743960518093701, 0.8110015278722298, 0.8257331742684945, 0.840921673372648, 0.873275288979021, 0.8574847660036917, 0.8505045464829932, 0.870062219562518, 0.2717416279593251, 0.29757904993586193, 0.20476752622823924, 0.29431539194233614, 0.29925574375818065, 0.2387275180208447, 0.23561112772785786, 0.22362903889287722, 0.21075207247628436, 0.3425022512463973, 0.5269284527482763, 0.49033516200368465, 0.589893775558911, 0.54675750625042, 0.6219903109147491, 0.6186089854923499, 0.6874429853355046, 0.657724415298112, 0.23433606556885644, 0.15526830052526708, 0.18414792022954685, 0.17321754797061117, 0.27466110710107905, 0.1808779614323791, 0.1617833830560107, 0.29834135341843115, 0.21420386195769014, 0.23457462648288607, 0.2704650231908884, 0.14097257093504922, 0.14595829387112624, 0.20030848381560373, 0.16066077408027268, 0.1557067266502421, 0.1727624714520305, 0.2291314665372266, 0.06159268583235167, 0.08470670109708212, 0.057670297254320935, 0.08406934266981803, 0.05049332763975367, 0.0731342654777416, 0.07682424164811563, 0.05272069127999024, 0.06125760584244222, 0.1393234362846124, 0.17533644811231097, 0.12020030499281276, 0.159366638962825, 0.09149360383098992, 0.07548498433140682, 0.18987914461166344, 0.18769029656832803, 0.1874782895248963, 0.20519513100472186, 0.15640879251275386, 0.20577511910547386, 0.11533356593753163, 0.1736216407157557, 0.14078317931483997, 0.16456867387172602, 0.33835086082734, 0.1362580649241668, 0.14582211834668668, 0.2087527797853702, 0.13156386904476347, 0.29796491310086415, 0.16016821082523058, 0.15455070547081085, 0.15554348786704109, 0.1539687157540075, 0.13219253977998235, 0.529314857950457, 0.5281462647121276, 0.5048688086911283, 0.469494905345311, 0.49586283902202877, 0.5000230019188323, 0.5164450538141876, 0.5674023111801538, 0.5206966577248293, 0.13400524270473746, 0.15069346683475926, 0.14147044746237258, 0.13248222918258212, 0.15030605095372063, 0.18340367361138832, 0.13122373727750514, 0.09932943518381032, 0.15567061664968784, 0.183049190773513, 0.17074129421868334, 0.2874103473914449, 0.19059152548421365, 0.16083378037091656, 0.18936279901041142, 0.19598079553542724, 0.23276536677221138, 0.18613775925686238, 0.2919826271041679, 0.3464355951466296, 0.3366942006909549, 0.31878523173638873, 0.3258064987573144, 0.3662111660744296, 0.3646306687644343, 0.3567490009011268, 0.4644605051823256, 0.2643560430498729, 0.22246548858423099, 0.2475638992799537, 0.22045682468807026, 0.23259292405859244, 0.29409491691681877, 0.24674456697197555, 0.2514020115088572, 0.2737491317515829, 0.21442968699577236, 0.2243307544883414, 0.20628427040099562, 0.25355258381132795, 0.19221004768274164, 0.2218784165376374, 0.26005699515930514, 0.23135572482549283, 0.2301011718205238, 0.20661974132155603, 0.3186051401797174, 0.1921135190655624, 0.19896487341813585, 0.19491168616398458, 0.2232245945506185, 0.18927148912538094, 0.186050183285703, 0.19877535332440388, 0.621625010165277, 0.5647110486805955, 0.6480797258126709, 0.9082646502392727, 0.22373609207747103, 0.32890130456473277, 0.6798286901667965, 0.16479901058749769, 0.18569256524579292, 0.32934690009946177, 0.20945972202294383, 0.46009520611678834, 0.5386927609234318, 0.3965983234565067, 0.20619218133110184, 0.2059576370386037, 0.3323920919259883, 0.4637908933841529, 0.2171258378213745, 0.1773487192580353, 0.1975708023806061, 0.20845174777596254, 0.21947791004921424, 0.1995859358270584, 0.2121424509901071, 0.19757342597450978, 0.19483358448517474, 0.10840971632493801, 0.09249355981932572, 0.08929063100163659, 0.08616526329471186, 0.09179812390051867, 0.09715247286243489, 0.09511923732225946, 0.09111227913769848, 0.08711161620542485]}, "mutation_prompt": null}
{"id": "7e0b320e-726a-4935-8c59-7e64acd5b52b", "solution": "import numpy as np\n\nclass DynamicHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 2.0  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.0  # Adjusted acceleration coefficient for social component\n        self.w = 0.5  # Reduced inertia weight to foster exploitation\n        self.f = 0.8  # Increased mutation factor for greater diversity\n        self.cr = 0.8  # Reduced crossover rate for broader DE exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Further reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.3, self.population_size)  # Fine-tuned learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.9 * self.learning_rate[i] + 0.1 * np.random.rand()  # Faster learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i] \n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i]) \n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicHybridPSO_DE", "description": "Dynamic Hybrid PSO-DE with Adaptive Velocity Scaling and Mutation to enhance convergence and exploration balance.", "configspace": "", "generation": 43, "fitness": 0.2869610084704463, "feedback": "The algorithm DynamicHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.6905774622078202, 0.6991674836867715, 0.8496970304266158, 0.6325331733757753, 0.7444628528847781, 0.7528600408895643, 0.6810214437290647, 0.6778179289211205, 0.7651308719462171, 0.3954434384037333, 0.3756110113053567, 0.599801495769241, 0.42858575267425714, 0.378847011597261, 0.432441494242626, 0.3830326313092298, 0.4176819377710642, 0.5016037196664713, 0.11804902387243077, 0.14781397575302346, 0.11372610502069769, 0.132986834404482, 0.15404895848054934, 0.15576602046252286, 0.12319990832274652, 0.14548718790418314, 0.13981529042829588, 0.10202255554602147, 0.10677962671922814, 0.10174151462613068, 0.11743556397433863, 0.11092001202893642, 0.10282379391742091, 0.1292538468036939, 0.10397935404994552, 0.11331930881568497, 0.8300920132067748, 0.8012864089192959, 0.863422539724483, 0.7826898309068291, 0.8341032034341838, 0.8038820169525711, 0.8415568408665943, 0.8074253695796241, 0.8765195927074297, 0.27250306323372075, 0.25319475865806007, 0.2437218766515481, 0.23848939026992877, 0.3274761212662869, 0.2370820377364904, 0.2674367850630016, 0.27245959909555073, 0.28627357602680714, 0.5020907048874566, 0.5255051166128031, 0.41529523202461194, 0.594617682361577, 0.45293956755183484, 0.5844049069994057, 0.6064754165990287, 0.5005588549272147, 0.6458534572188845, 0.2969318629928893, 0.16903630085923305, 0.3729261296876514, 0.15699838372462127, 0.18676758753462597, 0.16514838934472575, 0.18919800282648702, 0.23211880654765216, 0.193485426406256, 0.1592081755834135, 0.2413943164195249, 0.12900915298152704, 0.19630023829242804, 0.24936705574639806, 0.15896872202926549, 0.15546193141642795, 0.15249491093884138, 0.14813455553317212, 0.035878760343632354, 0.11274632974474974, 0.043829718657647065, 0.09160788061398417, 0.05931680962468178, 0.12632715456938948, 0.05101616843975043, 0.07759892888696762, 0.01242502830488934, 0.20323981561419935, 0.19661909756964446, 0.20643143268016229, 0.15355068976921826, 0.16156932734254514, 0.07159275046656244, 0.198079338775209, 0.222422079510589, 0.20914791255279175, 0.05213849708437379, 0.036719009821141624, 0.07814740583356128, 0.018602316749190884, 0.18234797896159816, 0.27762900099216803, 0.06171778991020305, 0.0518297300124283, 0.13468129891829317, 0.16191239701688587, 0.14348294969975395, 0.12102771154584624, 0.18933646593757425, 0.13486850688098928, 0.14178363910126313, 0.12683758768935582, 0.16192805202563632, 0.18472497247045172, 0.48714846140231194, 0.5209195942062808, 0.5137005448614487, 0.4686242527551796, 0.541495234542367, 0.5094573867891564, 0.5311986949451117, 0.4945004629219818, 0.4946394979794738, 0.10784441447007098, 0.11520501920788795, 0.16543052152378246, 0.10516701239349036, 0.126229777750675, 0.11300167416381213, 0.11865564676875506, 0.10311279280066243, 0.1522486405556297, 0.24298788048385767, 0.15465108149058282, 0.20521824122573384, 0.21231645917840192, 0.18422707567705754, 0.187848139415847, 0.23087418421068273, 0.16274549962168072, 0.23921634115871315, 0.31892983065055847, 0.3104952618717213, 0.3170739203959406, 0.3195338981445357, 0.3581299034745252, 0.32927679847872693, 0.3423651260312134, 0.36340563294850103, 0.34695133611480455, 0.24161998681147512, 0.24782519780546042, 0.2660614409654165, 0.29008122162748917, 0.23582140065001855, 0.2565704283473157, 0.28114890495194933, 0.2798375102121181, 0.24816105142610612, 0.2231884031053294, 0.20898391970841668, 0.20792932863004276, 0.227175774848127, 0.20984367815821436, 0.22235307961909434, 0.19821954648820572, 0.22674986131734454, 0.21132474955814273, 0.18920457112673217, 0.2211001525561609, 0.18603442756872102, 0.1902793195605743, 0.20877480134640092, 0.24278153134581892, 0.19830590565282835, 0.1885140543789714, 0.2054315690424754, 0.1784090235389444, 0.5911430538849131, 0.6459180010298355, 0.6853763512893682, 0.5371597818434133, 0.4810794504233086, 0.6720779253021634, 0.39404761249372344, 0.1710522308700494, 0.31891738737778197, 0.4488540391937095, 0.41928132956178, 0.28434131426765075, 0.4157721116484615, 0.3800229257149438, 0.2252064178290254, 0.41814912892136546, 0.20399652319946882, 0.1843400758204281, 0.20279742055062566, 0.1836790646260702, 0.18228915547476976, 0.19367293101496963, 0.188937273432479, 0.18135908754666785, 0.21807551181480433, 0.19768818362979168, 0.0897030974079529, 0.08564143002438085, 0.08251714108570307, 0.10461706145508665, 0.09910924870626536, 0.09385930653494301, 0.0813640569380335, 0.09046571133593917, 0.10560329800570345]}, "mutation_prompt": null}
{"id": "dd7e2e5a-e497-4b37-a671-a5b070e05f74", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.8  # Adjusted acceleration coefficient for cognitive component\n        self.c2 = 2.2  # Adjusted acceleration coefficient for social component\n        self.w = 0.5  # Adjusted inertia weight for stability\n        self.f = 0.8  # Mutation factor fine-tuned for diversity\n        self.cr = 0.85  # Crossover rate balanced for exploration and exploitation\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.03, 0.25, self.population_size)  # Refined learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.7 * self.learning_rate[i] + 0.3 * np.random.rand()  # Enhanced learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Adaptive Particle Swarm Optimization and Differential Evolution Hybrid with Dynamic Parameter Adjustment for Efficient Global and Local Search.", "configspace": "", "generation": 44, "fitness": 0.3315090723662166, "feedback": "The algorithm EnhancedAdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "79bc427e-e619-4806-ad84-6c49a8fc9e4d", "metadata": {"aucs": [0.8791333713412942, 0.8639057949406833, 0.8290819412129324, 0.8483925468885606, 0.8478601797299413, 0.8418151272445074, 0.8800111524761218, 0.8358288404334422, 0.8346468420585463, 0.6546077861866904, 0.6158094248439896, 0.5365105130561977, 0.5994210348503255, 0.6083620889641226, 0.5627019558889474, 0.6849470387011871, 0.6703532990586052, 0.5653554149640807, 0.1313449546830312, 0.15216445960973746, 0.1427737104642136, 0.12158477157865488, 0.12623228505789175, 0.1342992738811548, 0.16183563846048254, 0.674265195910439, 0.10220224911661768, 0.09287718378784027, 0.11525665083149961, 0.11354228207535766, 0.1210059091368686, 0.11194320516997647, 0.12628051230670057, 0.1268088173603935, 0.10612003123225844, 0.11151320400828646, 0.9198426765522515, 0.8493729709571205, 0.9079207110165228, 0.8540171589932232, 0.9377625380727165, 0.8831045891688915, 0.8712489804911556, 0.9278486520813292, 0.8662917406190805, 0.4058213674351564, 0.3492898210840565, 0.2622976979985112, 0.4260475538799897, 0.28833817743519163, 0.45972065900827674, 0.2478985807061279, 0.2950663615802934, 0.3093047668195539, 0.6635079455550257, 0.5630017336834203, 0.6743502113349218, 0.7952171915602642, 0.35765226897987035, 0.6981502214395988, 0.5403258158095305, 0.6974273345147803, 0.6699824382567625, 0.2329451743223303, 0.2783814105513053, 0.18516599378819865, 0.13975027955018726, 0.3529938493751664, 0.2690831489153983, 0.20962776908519265, 0.16818780694216817, 0.2757078796839446, 0.3143096594365158, 0.15773785026217102, 0.15632999385625956, 0.17012740298510398, 0.1554218627575057, 0.1494040350347423, 0.1639516267659875, 0.23490641817179403, 0.16841229658969425, 0.1932520061423283, 0.16196329774298301, 0.14476844419775092, 0.125462455726708, 0.1188941512535725, 0.11671037192070255, 0.03816832335476661, 0.17025789848478468, 0.040229323657948735, 0.15458113629273762, 0.2624767575112428, 0.30102415464002985, 0.2592319126677719, 0.28762294523070553, 0.2655989636096838, 0.308477623339826, 0.2837709913280372, 0.29333492007701645, 0.07125339747500059, 0.10927527149002036, 0.14344077970946323, 0.16810714462395848, 0.1280042248256701, 0.11776184716237936, 0.1584852317688774, 0.15123078326249506, 0.19114035249916106, 0.2137627785133307, 0.18472898716725106, 0.2347913171647199, 0.21632664591358353, 0.16723622310231334, 0.2148948333614792, 0.23457879724856823, 0.27229407668446814, 0.17207284864553585, 0.5504280883704904, 0.5460943692440053, 0.5914681334017264, 0.5573415041908192, 0.532250806774434, 0.5361602184790881, 0.565337173974656, 0.5868304227561584, 0.585674728246087, 0.15620560078175572, 0.17946331331239196, 0.12348240097257424, 0.12822546857400685, 0.13840868461029554, 0.08746469882720398, 0.15637967013138554, 0.13328051926558526, 0.11597149994931533, 0.14945524443619274, 0.21474723397925466, 0.21499892340171323, 0.285738326101439, 0.29920718170593696, 0.22846646687237437, 0.1668986384949399, 0.17963864235667948, 0.16524295502176478, 0.3354067855961731, 0.34520418896813354, 0.34477769543421466, 0.31964318311311013, 0.3457869223110359, 0.3513777638141936, 0.35721222700106114, 0.37379598311569084, 0.34946836977774787, 0.25176418800937106, 0.27146193257639084, 0.23857377214247966, 0.3146158988454155, 0.27771133074801535, 0.2581307204512293, 0.273503275742878, 0.3292397071781158, 0.22936957682152814, 0.24537426650323924, 0.251952334552049, 0.19840911386836046, 0.22264401028294223, 0.23521469756080204, 0.23961257628567179, 0.2635482169285771, 0.24031327212266873, 0.2428013596259746, 0.18771257701793764, 0.19083943747275955, 0.19447150077897557, 0.21005551957508728, 0.2164398985371211, 0.1948708251203235, 0.22163463569533193, 0.21629315986732234, 0.1900856160010317, 0.4675325367424402, 0.18675290099970643, 0.48614091840087326, 0.772675241401728, 0.19855482505164468, 0.6473684619205902, 0.5530945914271101, 0.31478362759194267, 0.7995289348993737, 0.5162188721871162, 0.6833866830325587, 0.41138547239979995, 0.20327165279280202, 0.16185910183940033, 0.16380129264858156, 0.6103583246656571, 0.6163293502901095, 0.29749493260037363, 0.1880851510329521, 0.19436339102403444, 0.2303722163476094, 0.18929487398527278, 0.17167381120652403, 0.21586663122526972, 0.24461803258479675, 0.20755121102958007, 0.18520206408274265, 0.0946408990875861, 0.11230593112350817, 0.09405647694792374, 0.09397796697627803, 0.09677360894868092, 0.11309175561385365, 0.07955176024227328, 0.09587101426538625, 0.09468713239572757]}, "mutation_prompt": null}
{"id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 45, "fitness": 0.33987252258914846, "feedback": "The algorithm EnhancedAdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "dd7e2e5a-e497-4b37-a671-a5b070e05f74", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "c5e12f8e-68ae-4274-a4dc-587a58eb75eb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "ca84d613-27b2-4e06-97fa-1e9f8ce84968", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "2d8dd7b3-c393-43a9-8aba-85c9c3a77612", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "193e8852-b70f-45fa-8214-72e0c1c3b208", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "863dfc5c-0862-4f82-bf8f-272b39673155", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "30567020-21f8-4fa4-a965-cc521094b031", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "29c1e9f9-1390-4da8-82f3-add9997c9a9b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "ff470655-e14e-43c5-98ab-5fa55be635c7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "68a9d993-1313-46d9-974c-6b1ce96c420a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "30ec157d-e5eb-4bb5-8da3-f17cbe3590ad", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "02eb20aa-611a-4296-8b7d-6a10e75078f7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "88d163f5-c416-4802-a5c4-a6544c1739c2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "d25d5b9b-cfe2-425b-b716-37180d249e23", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "dfe82163-a3bb-4935-aadd-d71c00494f1a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "e8e1a109-8ff2-4b1e-842d-1df666735520", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "6d982bef-824c-4fe4-b3c5-68634cb62915", "solution": "import numpy as np\n\nclass AdaptiveSwarmCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.5  # Adjusted for more personalized search\n        self.c2 = 1.7  # Slightly reduced for global guidance\n        self.w = 0.5  # Lower inertia weight for faster convergence\n        self.f = 0.8  # Reduced mutation factor for better stability\n        self.cr = 0.85  # Slightly lower crossover rate for balance\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Narrowed initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.03, 0.25, self.population_size)  # Broadened learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        probabilistic_switch = 0.5\n        step_adjustment = 0.6\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = step_adjustment * self.learning_rate[i] + (1 - step_adjustment) * np.random.rand()\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                if np.random.rand() < probabilistic_switch:\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant = np.clip(\n                        self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                        self.lower_bound,\n                        self.upper_bound,\n                    )\n                    cross_points = np.random.rand(self.dim) < self.cr\n                    trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                    trial_score = func(trial)\n                    self.evaluations += 1\n                else:\n                    trial = self.positions_pso[i]\n                    trial_score = self.personal_best_scores[i]\n                \n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveSwarmCoevolutionaryDE", "description": "Adaptive Swarm with Coevolutionary Strategies and Dynamic Selection Pressure for Balanced Exploration and Exploitation in Black Box Optimization.", "configspace": "", "generation": 61, "fitness": 0.2579032032136064, "feedback": "The algorithm AdaptiveSwarmCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.8989981630785993, 0.8951347395179247, 0.8535218475435218, 0.8912079636934135, 0.8682495599237153, 0.8707216719795556, 0.8903899940679975, 0.891967110328303, 0.8908958049500959, 0.07619393554774889, 0.18988035134603765, 0.1445836157742293, 0.41957374050849416, 0.06494600362063296, 0.13400172983409953, 0.034331302254401286, 0.10353286961385144, 0.1691207143715392, 0.11207547685381614, 0.11726798527140214, 0.15878958640312535, 0.09524306944007821, 0.1596817174435471, 0.11719731755826901, 0.1625915980728816, 0.14420136523024707, 0.11483929693211214, 0.05789046365953876, 0.06095987184895857, 0.14330793041232626, 0.08488323989557611, 0.1024978159198503, 0.09485492962790554, 0.10556854082051592, 0.14391614716405043, 0.11648418045996589, 0.9585914039971478, 0.8684988795220547, 0.9100004610460111, 0.9241181636050736, 0.9397282259748994, 0.8671456723012431, 0.8919793311605878, 0.9596147595726493, 0.9226395745642703, 0.17893887144615528, 0.257076395347663, 0.12912506136183344, 0.16332681816044392, 0.12639005108617218, 0.27201315919469915, 0.15903584494680267, 0.21567255367426152, 0.25964913387128474, 0.21552365530955853, 0.30348733802614614, 0.20776560068897532, 0.3604219349631993, 0.2791801691285093, 0.19078825644146702, 0.23390478108234702, 0.18013261202116904, 0.2231783189777109, 0.12770992317085728, 0.11892506640696321, 0.14122329316951654, 0.010070552163615298, 0.19531229709906694, 0.18716450004412322, 0.14666266481990642, 0.27083890509011554, 0.17161031939308724, 0.14529407618482748, 0.13363218415963107, 0.12913698207506352, 0.14284582177333127, 0.14578697551356068, 0.15610085717444255, 0.20933307891576092, 0.13377624132338295, 0.1312550986053891, 9.999999999998899e-05, 0.02360111533771103, 9.999999999998899e-05, 9.999999999998899e-05, 0.053320108707232805, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010960817530147104, 0.17207640092033138, 0.0959509217590716, 0.08692977241226196, 0.056026217363516095, 0.05045679726109009, 0.0943355779304147, 0.10199333373954178, 0.08433403265238304, 0.1477695072842845, 0.09871764605686717, 0.08848749906190989, 0.13255698844740127, 0.10258539132965105, 0.4033823732843742, 0.14813266701417016, 0.27543756119890883, 0.21663952091076644, 0.1848011042782487, 0.21242373558919514, 0.05956019743905583, 0.16260927732098607, 0.04713372758487344, 0.18214967356190226, 0.1010717335561403, 0.2570334140529267, 0.11280452868956958, 0.08646110026964193, 0.4838846135009629, 0.4534676353559811, 0.4738189142787894, 0.4940717693274176, 0.4533405540753307, 0.4345069518518081, 0.4309163815353151, 0.5149994176991667, 0.46166959025165666, 0.11049077019424935, 0.10570077444223369, 0.08665549060334254, 0.1459582033730321, 0.061664918334738306, 0.14436781639877083, 0.07879982824052245, 0.11055765773574933, 0.07226227322487389, 0.23985763650760483, 0.31357737080586345, 0.17788587077384255, 0.2541206513263341, 0.2791049510197713, 0.1353388566994952, 0.2073493222809909, 0.20714497841687463, 0.19457506892436827, 0.2073544042517912, 0.3463537111986058, 0.26003535234639863, 0.25650225863893317, 0.3409726004192557, 0.29967394420737714, 0.2505165329202307, 0.2656432507617891, 0.5434867047667336, 0.16554963520317012, 0.1730375750541896, 0.18253255904730836, 0.2856736400816232, 0.1781897637257298, 0.3557251250150796, 0.2215613993629153, 0.14453325848489385, 0.2561081427130105, 0.2141764161166425, 0.20739173199458316, 0.21931309139924138, 0.24906616313676888, 0.21924097554161903, 0.2171554266352791, 0.2155215749050663, 0.22905241063034398, 0.2708263231906757, 0.20938694573456673, 0.2017493027178704, 0.1894080481293412, 0.1878600610216964, 0.21327262573443917, 0.17513786490023775, 0.2011387639443687, 0.1881440821589836, 0.20844195105244678, 0.8628572124342846, 0.5089660310952677, 0.14809127557420143, 0.8913683432410768, 0.20124826222098713, 0.8660250314209899, 0.1414982316932648, 0.15690175044682764, 0.8532880901005316, 0.42648502511249675, 0.21196517449480412, 0.21104797715761325, 0.42910088728469087, 0.2575425682110625, 0.16536855704929365, 0.247932404035331, 0.356579335723356, 0.26849941332466865, 0.21424097864275604, 0.18844122475066105, 0.20369873666977045, 0.22792602745653234, 0.18082153997275607, 0.20798768318643568, 0.1898173900501673, 0.2002137128003113, 0.23084649419691616, 0.10823940478404714, 0.11777279354943182, 0.08464567447413351, 0.0903756525426741, 0.09575101644904427, 0.08689930453143202, 0.0851892269030291, 0.08980390280199957, 0.09938341736597156]}, "mutation_prompt": null}
{"id": "7523c039-ae05-43e3-aec3-bce1695dc311", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "ad6ff957-991e-4686-81e2-2f85d880bb72", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "8ca1a95d-8c6a-4449-a8ef-a151efef62fc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "5c7ff15e-2a15-477d-88eb-c8ac597cadd3", "solution": "import numpy as np\n\nclass AdaptiveStochasticPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.5  # Cognitive component adjusted for enhanced precision\n        self.c2 = 2.5  # Increased social component for stronger exploration\n        self.w = 0.7  # Moderately increased inertia weight for balance\n        self.f = 0.8  # Slightly reduced mutation factor for stability\n        self.cr = 0.8  # Adjusted crossover rate for diversity\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Expanded initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.4, self.population_size)  # Adjusted learning rate for better adaptation\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.5 * self.learning_rate[i] + 0.5 * np.random.rand()  # Adjusted learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveStochasticPSO_DE", "description": "Adaptive Stochastic PSO-DE with Dynamic Exploration-Exploitation Balancing and Convergence Acceleration through Line Improvements.", "configspace": "", "generation": 65, "fitness": 0.3347705071133544, "feedback": "The algorithm AdaptiveStochasticPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.81299128342104, 0.8350072513030018, 0.8413659668295388, 0.8430678295244023, 0.8406538022879323, 0.8376223508855165, 0.8493338101153479, 0.8330656484064183, 0.8370343746494098, 0.6037359055209979, 0.5482073552710958, 0.6395038525642602, 0.6831955330834107, 0.659216400610194, 0.6409777972020405, 0.680838124605243, 0.6497122589444255, 0.491949016005261, 0.1354247053336538, 0.14313456949923098, 0.12313661848192092, 0.12058275438743893, 0.15784513890489704, 0.14948351814430594, 0.1576420166648138, 0.15862864892350625, 0.12018962178921211, 0.1121564408329967, 0.13996081284224127, 0.11253966278648808, 0.12053424312736882, 0.10861614480387816, 0.10844169122844793, 0.1414647440814617, 0.122455662660925, 0.11804392806049058, 0.9438657333552927, 0.9087128086835534, 0.9555809644945027, 0.9278865778556631, 0.9635344683085919, 0.9365684519101554, 0.9721333113837367, 0.9293672929725664, 0.9443173235028806, 0.266652272777107, 0.6286081029788448, 0.388029991179651, 0.6344775084112632, 0.44891912368269127, 0.31348774306684635, 0.48505961547554566, 0.5222155572435742, 0.48676176025464735, 0.4718770081036868, 0.6267403876275579, 0.21231049515828393, 0.6214939524709007, 0.7291849145281402, 0.5071198140951301, 0.5970851198234495, 0.6964319763255711, 0.6474637841089494, 0.18673216019354077, 0.29206266666333625, 0.18935325733623531, 0.18177938707096308, 0.242683832795061, 0.24617895337161266, 0.21642885522808109, 0.19151362882899114, 0.21906081793310161, 0.40643846829927044, 0.20281166522428662, 0.2183066219325459, 0.20864954408154823, 0.1744284405741271, 0.18571018617310964, 0.22805222587293206, 0.19414075466467207, 0.25727534079675696, 0.06970851762699093, 0.05540156274468866, 0.08130275006553889, 0.08123490419594948, 0.04380021513209953, 0.08198199962884622, 0.06416138153381146, 0.09101183742857577, 0.19789767994664165, 0.2093263810476741, 0.18352300290148382, 0.20548073858772042, 0.18134146500286075, 0.20462071630107437, 0.15865266607240958, 0.18980181625776305, 0.266784094676223, 0.25227991842621655, 0.147137560963702, 0.23908733159472118, 0.24205995301045735, 0.11749222201519749, 0.16122558145938237, 0.12073284522102845, 0.14435695755693068, 0.21407295708088836, 0.08771111704975121, 0.3058298350092008, 0.26624591555156074, 0.15125386217620684, 0.17204045003130997, 0.192779390365451, 0.1630912631315523, 0.22764746720681983, 0.14167311336434718, 0.13937859485358206, 0.5530499355908898, 0.5616041227679167, 0.5384357606613622, 0.5434613360926535, 0.5166183993911906, 0.5571276033221981, 0.5572230437523722, 0.5561077682813815, 0.5382297105805512, 0.09072027950296269, 0.1348429135733783, 0.10895596422352172, 0.11395628795852153, 0.11547442533617103, 0.6583431796014889, 0.14080197098376634, 0.12828498977493696, 0.1303970975801051, 0.16608579565992188, 0.18551532646618984, 0.17248638934653682, 0.16313473462763972, 0.2929870083946433, 0.25831713065924533, 0.26881226320884033, 0.16425444582820403, 0.22941111798069092, 0.3482043774024002, 0.36418249724914253, 0.33905300120543513, 0.3159027397234768, 0.3600565577747342, 0.40234726124998643, 0.3469427497994194, 0.39315950516073506, 0.3951420914669601, 0.25341341821172836, 0.2832867491805974, 0.23637859068402767, 0.2516563723805476, 0.2743081707600199, 0.32029457477783874, 0.274517401265706, 0.29716841515681913, 0.2244121462298595, 0.21347919916199554, 0.22669385144444243, 0.25122354423817983, 0.2757106538301044, 0.2163403885073455, 0.2123008563597426, 0.29440125441828846, 0.22441980853806298, 0.24414776511979464, 0.23091480847106305, 0.8015565797941272, 0.21560683532636304, 0.20438089243958857, 0.28024220036926195, 0.1958517879891276, 0.26374780790120567, 0.2000341349031457, 0.19831518141820048, 0.6168224739617836, 0.18743537197118343, 0.17521741681038216, 0.8735532652223355, 0.8797225450623598, 0.19755660236256578, 0.5607979610824785, 0.175385408189496, 0.882240683481471, 0.4014112245955491, 0.5969611843451261, 0.3578424996222841, 0.3103010273763914, 0.2389160785279396, 0.19314424713572553, 0.16023439925411653, 0.609076366047817, 0.16591216121537122, 0.19763325441062263, 0.20937066167598972, 0.20820835976702168, 0.18072927739483713, 0.17873535724500167, 0.18966637103826656, 0.1987340271692174, 0.19117765480187343, 0.24211214159612482, 0.10272293945652256, 0.08848050147752606, 0.08401660061885996, 0.09597730795537684, 0.08783336516878026, 0.09503477454485532, 0.13295544731038922, 0.1264535307610064, 0.10624346095072901]}, "mutation_prompt": null}
{"id": "430db2cd-a04b-44a1-b1d7-1277ec2b6617", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "4c0f63e8-da63-4324-a3ae-d52e1d494701", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "1da4456f-1086-4b59-8fa6-9b71f3898f3c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "c8ee2e5e-9a30-4aca-a3f5-ab83fa1fcf8d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "c0ddbbe7-9ecd-4e67-beb8-ee017f6459ce", "solution": "import numpy as np\n\nclass AdaptiveFeedbackPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.5  # Cognitive component for balanced exploration-exploitation\n        self.c2 = 2.5  # Social component for enhanced convergence\n        self.w = 0.7  # Adaptive inertia weight for dynamic search\n        self.f = 0.8  # Mutation factor for DE\n        self.cr = 0.8  # Crossover rate for DE\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.2, self.population_size)\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n        self.feedback = np.zeros(self.population_size)  # Feedback mechanism for adaptive learning\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.feedback[i] = 0.5 * self.feedback[i] + 0.5 * np.random.rand()  # Feedback updated for adaptive response\n                self.learning_rate[i] += self.feedback[i] * (self.personal_best_scores[i] - score) / self.budget  # Adaptive learning rate\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveFeedbackPSO_DE", "description": "Hybrid Particle Swarm and Differential Evolution with Adaptive Learning Rates and Feedback for Enhanced Optimization.", "configspace": "", "generation": 70, "fitness": 0.19453234055017773, "feedback": "The algorithm AdaptiveFeedbackPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.4040423654601506, 0.4352717479553506, 0.4043048042674715, 0.44486861715447146, 0.4461659002661612, 0.4348313791104229, 0.41026697354851127, 0.4096473935822129, 0.4315019100967121, 0.13917770338134305, 0.13219739751959192, 0.15546315300736002, 0.14241462585629794, 0.12808181583381506, 0.1365860239420481, 0.15761177113254066, 0.14150877482708857, 0.1336698583819158, 0.09036946687499225, 0.09914331697849799, 0.12190471332413999, 0.11239670881393593, 0.08655590736299856, 0.09338208504768697, 0.11240812640134479, 0.10565099560312652, 0.09256900572189897, 0.09028353309653903, 0.08403508887672528, 0.08226409936894197, 0.16043377666468828, 0.06701466771648079, 0.08599957849852258, 0.10193842232141104, 0.10864443510353938, 0.10119249470729741, 0.9159469122560795, 0.9646359884329151, 0.9332048851689105, 0.9054788634472853, 0.9395054880741859, 0.9227403459782096, 0.9397568224040806, 0.8985887349077079, 0.9374006732875447, 0.14600267777557507, 0.14565570200744116, 0.1504502272592324, 0.18533918724806275, 0.16845932141033648, 0.13603416849794825, 0.1735985454045711, 0.13682284732391004, 0.17453938074436026, 0.221674209430605, 0.37338401992304193, 0.2043866013462422, 0.24412907070634682, 0.23479593172593716, 0.2629201419832994, 0.2337316600733247, 0.2292351415322259, 0.21773672813135647, 0.13109104388376314, 0.129238950409167, 0.0917318199495708, 0.1559148452691852, 0.10627181672779262, 0.0845242018247081, 0.08608836619329285, 0.11376214555544462, 0.08964002074117694, 0.21162981920832913, 0.07303152567197302, 0.0709394872991781, 0.11409074824866272, 0.09554731293431473, 0.14399067872436644, 0.13569098325559792, 0.11910488566777588, 0.15138390098199128, 0.0053678448600592565, 9.999999999998899e-05, 9.999999999998899e-05, 0.007543009864400485, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010866228316752657, 0.007842665716060182, 9.999999999998899e-05, 0.06653970408414356, 0.07005092935538382, 0.0844521772940694, 0.0689751412530395, 0.0895579198973111, 0.08260881283745947, 0.08814995361679034, 0.07549474253861932, 0.08671665215762259, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08951672228238039, 0.05882749266942078, 0.08037026808635817, 0.0813027497515253, 0.07072402309949122, 0.07421940018791051, 0.09610066775017079, 0.06350923605408076, 0.07248880453361417, 0.41084657039388117, 0.35416963100284515, 0.3584833487356167, 0.3679134266279258, 0.3854517664279168, 0.3526504468816076, 0.38237857373505524, 0.4031933677307352, 0.39280991156525125, 0.07022936456672146, 0.09534203568640665, 0.08519187798773942, 0.09634848021850362, 0.08485472016613771, 0.08200081051861308, 0.09524988118558853, 0.081166144380166, 0.1029867907180827, 0.19156256865650212, 0.1351772622626085, 0.13687991234502062, 0.16223874534929417, 0.22465615525322558, 0.13073713970118983, 0.1499948753789624, 0.13158503817317868, 0.13678217318535912, 0.21476296908306491, 0.23107229757330228, 0.24353519004089108, 0.25221165811629065, 0.2499538289376313, 0.2275713863865061, 0.22013163623648668, 0.2512182442614638, 0.24919789482945742, 0.15494405669379285, 0.1617324001306748, 0.16678586581258026, 0.21856613308523987, 0.15130305434222158, 0.25097204218827207, 0.16114289382286917, 0.23572842108412528, 0.19388417595015572, 0.21263516998197607, 0.22053533714529228, 0.21179786469761563, 0.21127195464270565, 0.19258994433194565, 0.23180950075762707, 0.20931297153548023, 0.19655071282089887, 0.20385787754623774, 0.18504167522609372, 0.18555564625302667, 0.168293131729498, 0.22609387677256498, 0.1663398753481028, 0.18116208133131717, 0.16790490169719507, 0.20751155929445253, 0.19512894786381207, 0.25597823666927644, 0.18572330335058618, 0.16718352505221412, 0.15834971664248665, 0.21372757710829438, 0.19081913980939336, 0.15728350780000788, 0.1734964340961629, 0.2921277277471688, 0.2701645403391436, 0.4930572372989622, 0.1817797286183761, 0.18768781876812912, 0.16609750524517564, 0.14983769902189448, 0.26448781851472025, 0.2708326884508382, 0.3329665833391816, 0.1833210490828161, 0.20242394846419964, 0.17373195730657898, 0.2155771087895303, 0.191862448922831, 0.1893191105101275, 0.20540949616292337, 0.19290009153399978, 0.19276390861587545, 0.06311210218438879, 0.08418524931618054, 0.09399205829922719, 0.10583238388017213, 0.08248180678086392, 0.07771533609274817, 0.07586725875759004, 0.08486912667535362, 0.07753908619962802]}, "mutation_prompt": null}
{"id": "bfac1b09-ace9-4029-a023-0c57928b6aad", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "b021ae17-2826-4bfb-9f1e-d448939b3488", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "85771557-d3a5-420c-a6b7-5db85700d8be", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "a0b6ec37-e1d7-4ca7-b78f-b96192eeb8d5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "8cefa96e-9d36-4282-8fba-64bdc54e85e2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "332ac8f4-9f07-4bc8-a1fb-c68e23bb3ac0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "a2a28d0e-d6c7-4405-abd1-3a53066b0f5d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "d0e9e2b1-4656-44b3-abc1-1570d677e2b0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "f3a1603a-1b42-4d77-8631-c552c15f30a5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "dc4877ee-e63c-4746-bf16-136e69196da1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "4fe2ce6c-6e60-493d-bab3-2f3bf31c36e2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "f2b43ab7-3489-49e3-a552-a7fa8a3986d0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "a42837bd-b3c8-42a3-9c50-9ec9e3b19082", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.5 + np.random.rand()  # Cognitive component with probabilistic adjustment\n        self.c2 = 2.5 - np.random.rand()  # Social component with probabilistic adjustment\n        self.w = 0.7 + np.random.uniform(-0.1, 0.1)  # Dynamic inertia weight for balance\n        self.f = 0.7 + np.random.uniform(-0.2, 0.2)  # Mutation factor with probabilistic adjustment\n        self.cr = 0.8 + np.random.uniform(-0.1, 0.1)  # Crossover rate with dynamic adjustment\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Enhanced initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.4, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.7 * self.learning_rate[i] + 0.3 * np.random.rand()  # Probabilistic learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Hybrid Adaptive PSO-DE with Probabilistic Parameter Adjustment and Enhanced Mutation Strategies for Improved Optimization.", "configspace": "", "generation": 83, "fitness": 0.32211400047180294, "feedback": "The algorithm EnhancedAdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.8741475388140791, 0.8566565372040044, 0.844042512966246, 0.8472533985696455, 0.8521406960011833, 0.8612058574649042, 0.8368300379018689, 0.8465607829462558, 0.83000718940633, 0.6788717103580273, 0.5855068800919463, 0.6443774391323747, 0.6065520225459542, 0.6912947818321734, 0.5728272350858965, 0.6029387229356618, 0.671737417624993, 0.6584322349807425, 0.11759001363631105, 0.15294399728696606, 0.12816853087566593, 0.12601866494331027, 0.125377514806697, 0.13794441960125858, 0.16178284635885976, 0.14572801316818296, 0.11752674062133805, 0.12775392026615917, 0.12259914769455227, 0.13193263638223252, 0.10367375260646017, 0.11475781939257035, 0.12779188379230744, 0.12568792359706982, 0.14184651329350018, 0.12984860350510807, 0.881972217755835, 0.8946267000153019, 0.9494879882560731, 0.8675509706755757, 0.8599474842670176, 0.9289837979981864, 0.8844891912175289, 0.8920221590099641, 0.9279081105570544, 0.32843189919010096, 0.31336630170840074, 0.476662859624161, 0.31423840874927833, 0.2271546305496832, 0.2649706408905821, 0.21455096903722015, 0.16382574676790096, 0.3729397079318062, 0.803235688949484, 0.6329564037693834, 0.6123672392841066, 0.5274362183975141, 0.30504555167852143, 0.6927071948465466, 0.7187029026632119, 0.7756844334789316, 0.48499341028473253, 0.25322766268376873, 0.13628471947545606, 0.16384704533610928, 0.13985948598530118, 0.16768273615790152, 0.12025103830040007, 0.19904171411390192, 0.1746525690526356, 0.19404725060040984, 0.1563018294199896, 0.1712334556555104, 0.18306628495106947, 0.17852238936855302, 0.18722940441632174, 0.3954772662741983, 0.18065247612739388, 0.16176135213968534, 0.21556938517169033, 0.04823502875424657, 0.015867312582058313, 0.08917678567764964, 0.058155799777477424, 0.08640712897885172, 0.10876582794617984, 0.06482571998215825, 0.038422684876256996, 0.054462911084806054, 0.18397738376592265, 0.15264930446941705, 0.2249439648602819, 0.10104503318367841, 0.11802412984284782, 0.14820733896961158, 0.23853864637496702, 0.253570994976862, 0.21688941719540922, 0.1541284884192955, 0.17328988093716702, 0.09636908284135537, 0.13967405889225337, 0.11616262992394388, 0.13382207144591762, 0.15310922487872958, 0.15187596338140263, 0.14363223134028125, 0.18950573177315422, 0.13130103487148792, 0.15809431562840093, 0.20471006576874629, 0.11455798026315023, 0.20844188549567566, 0.16694311732931633, 0.1767850710533896, 0.13957985294016073, 0.5424354661309837, 0.5190787557116368, 0.549130139058416, 0.5239138235765641, 0.5031708064934506, 0.5325094766564091, 0.5495421434455258, 0.5784480439232051, 0.5301370344374777, 0.10367198830332236, 0.14963242131602073, 0.09815981149573016, 0.16371071661638148, 0.11355966628129188, 0.184717689603213, 0.12336623425262805, 0.13101117676106444, 0.13000486365363562, 0.25238239560854414, 0.16204318040225862, 0.16889455986573942, 0.1828233495330298, 0.17787613827200166, 0.1907213968035758, 0.22389436904189264, 0.1505237102714143, 0.1738792420011097, 0.361773827155923, 0.3461480330970841, 0.49483374636791866, 0.37632180948790517, 0.3791213929987053, 0.33290503399690086, 0.35087415843868797, 0.3666430170732965, 0.39780187679990264, 0.2510550605383748, 0.23904193506503169, 0.28603487882724166, 0.2555200402852448, 0.24090974760315054, 0.17266304464153348, 0.251274781190608, 0.26140298362907743, 0.26409218287692204, 0.22869894929385048, 0.2092028719161615, 0.225506185149852, 0.1998268434092152, 0.19421160301709972, 0.2302914231617823, 0.22540383465659752, 0.23365522463507882, 0.19498675679868305, 0.1992543105192618, 0.3166779490744841, 0.22371128720537803, 0.18495988173008615, 0.21872934280659861, 0.24944220679594564, 0.19679419356102146, 0.20349596141047, 0.20270817038688738, 0.758532421110065, 0.18608183586267513, 0.1985191115839784, 0.7742132640258597, 0.5565700742448754, 0.26512608288620265, 0.7226979224025651, 0.7473342074987663, 0.8601639345600656, 0.6156165740099245, 0.2087810895738298, 0.8603333988362099, 0.5888093771724447, 0.41238084532359154, 0.1987927055298626, 0.2082037505724207, 0.6524126721625287, 0.5556804910147589, 0.22256811331794468, 0.1874741011878278, 0.19846056403450185, 0.17931750925222711, 0.197561500082869, 0.19629187848528495, 0.18524710355545781, 0.18137699120113826, 0.20408343111104288, 0.09553863001863405, 0.11032997857259619, 0.08563520200097696, 0.08696505400186705, 0.09338750070684876, 0.08220202712255853, 0.09106263595464081, 0.08661914193542886, 0.09756890492072867]}, "mutation_prompt": null}
{"id": "9edc28e1-93d4-4c23-982c-6340aee10594", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.5  # Slightly reduced cognitive component for better global search\n        self.c2 = 2.5  # Increased social component for improved cooperation\n        self.w = 0.5  # Reduced inertia weight for more balanced exploration-exploitation\n        self.f = 0.8  # Reduced mutation factor for stable convergence\n        self.cr = 0.7  # Lower crossover rate to maintain diversity\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Narrowed velocity range for refined control\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.2, self.population_size)  # Narrowed learning rate range\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n        self.velocity_clamp = 1.0  # Velocity clamping for improved stability\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.5 * self.learning_rate[i] + 0.5 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Adaptive Hybrid PSO with Dynamic DE and Adaptive Velocity Clamping for Enhanced Search Efficiency.", "configspace": "", "generation": 84, "fitness": 0.3046189243418685, "feedback": "The algorithm EnhancedAdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.8691608311137846, 0.8245063236848628, 0.8658535410764887, 0.8328333989692207, 0.759097735927426, 0.8452763596045633, 0.8426837354363576, 0.8295613369142143, 0.8447060370249474, 0.5344421782373272, 0.6670184897624771, 0.5130145475981166, 0.6030813921508882, 0.5712904625049988, 0.5630279018472714, 0.6038137501573307, 0.5563550545224856, 0.6465963960837127, 0.13930381953152826, 0.14379209827044592, 0.17510605006810076, 0.12233454396088705, 0.12926403394875574, 0.151658440899609, 0.128476778513809, 0.14752073488826667, 0.1280995204426998, 0.11400145912294579, 0.12326874581886971, 0.12792061745751948, 0.15418231619361722, 0.12073057290130784, 0.098442500133881, 0.14070655224581496, 0.12420726468115662, 0.11581586143405753, 0.8853260167184369, 0.9222786038068443, 0.8940184486654474, 0.8358297259830753, 0.8936667011759422, 0.8759827402871991, 0.8805803662179776, 0.8750922541009127, 0.883171948254656, 0.3268555534176222, 0.3012895455415072, 0.36629483771213744, 0.32673538289723214, 0.30474351489165097, 0.40970952293087803, 0.3416763473296154, 0.40845019268755167, 0.30037058191533617, 0.44749755639741184, 0.47139314004554445, 0.20175632874550697, 0.44559988324823585, 0.5737321938964081, 0.43994483792630035, 0.38339165811091114, 0.5514080586732008, 0.5003972022506418, 0.1492786269786609, 0.15825858220455324, 0.1390656439067095, 0.21118273703028545, 0.17641158152871939, 0.16158897308608777, 0.16728373083025194, 0.21934395379704408, 0.15889845872435504, 0.15750300389356053, 0.15549713790653985, 0.20120030461144434, 0.17788028876328066, 0.13544520283582928, 0.3280085934047272, 0.1790212460586963, 0.195088051737907, 0.1628711749191043, 0.2083396149774167, 0.03720731073695405, 0.025214348760644323, 0.022621265122131584, 0.07678189392317913, 0.004058998409869341, 0.04989336378289477, 0.014322350183739396, 0.04966615723554313, 0.0927596356837781, 0.07810421922844835, 0.12297328063703228, 0.07625239706009468, 0.15241666312268298, 0.1670218312293984, 0.16544628907555048, 0.1417247817250864, 0.18605581242582403, 0.23902179009673663, 0.10346112332730062, 0.1368380722278011, 0.18913608426534712, 0.15841896193245908, 0.2015168521591746, 0.17933839069401114, 0.1932251128703023, 0.2724495190050771, 0.1745162656933611, 0.10794363349363989, 0.25372986525520747, 0.10514332632883938, 0.17796481746141002, 0.1265170058624353, 0.13106688432479008, 0.1246924536518692, 0.16532091720419373, 0.4913703104761479, 0.5293175109119809, 0.49316775454120276, 0.5054326818368321, 0.5237912174114523, 0.5050933307342687, 0.5060559071525745, 0.5138032931329659, 0.5343403050948157, 0.12677638886451137, 0.1728218174711159, 0.1335809036641753, 0.11891479823307816, 0.11220564136674127, 0.12155085929549392, 0.0954157924241017, 0.10783210957875633, 0.09576495609446956, 0.16389121952972852, 0.18736149630137222, 0.15980014527838216, 0.16449546060824705, 0.16576699276162743, 0.15131165082079134, 0.1995275994278357, 0.24610261774517828, 0.15842385789283375, 0.3272906085514903, 0.3197011528711111, 0.34639305796925846, 0.30308532857463943, 0.31114510624743164, 0.3006341486243973, 0.3406765176523452, 0.3797687731068894, 0.35245975635798676, 0.23792258760270024, 0.27709123452958184, 0.2506918597965657, 0.22911963666275104, 0.2389509760288302, 0.2652744623951149, 0.22408129946086497, 0.25213804755324565, 0.24972014374172002, 0.22885695687291963, 0.2093384699190709, 0.22501062683660666, 0.26129642550460197, 0.23212314709662796, 0.25035446269658934, 0.22679448402811053, 0.19692167065592758, 0.2080892954432073, 0.20265794742963228, 0.20765407518979118, 0.1897466182157186, 0.2046642774784263, 0.6965910531773893, 0.1920210603865513, 0.1853007580925311, 0.31183225366130696, 0.22752168651026417, 0.7927358666505657, 0.8767823536955349, 0.1744125888791912, 0.9045856097594711, 0.6252923932760257, 0.19893828720906326, 0.25058804526625955, 0.27009047787226037, 0.8406662018123514, 0.38899947905145305, 0.2113688797479113, 0.22068157489017426, 0.5552079733278901, 0.33151519364756565, 0.19507576384309555, 0.40384039667430993, 0.34976557347934334, 0.3241118749933596, 0.20730380599159015, 0.23157019536696177, 0.20095733075826006, 0.20027300819484106, 0.20732226058368408, 0.20891152502592336, 0.22575390767502412, 0.23041578054506118, 0.19076762096320377, 0.08727242755014852, 0.08423890932382438, 0.08342301307273192, 0.10069259743604486, 0.1045049102812674, 0.15307829448192845, 0.10161804867052071, 0.07697670315222183, 0.09177909077174062]}, "mutation_prompt": null}
{"id": "958d20fa-0f3b-4449-9291-c0d5a3266053", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "851d3e52-7dfd-461a-8ee9-45cdcbe12151", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "0297e0d5-12c2-4eee-93dc-fdc419b6f494", "solution": "import numpy as np\n\nclass AdaptiveMemoryHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.8  # Slightly decreased cognitive component for stability\n        self.c2 = 2.2  # Increased social component for improved convergence\n        self.w = 0.5  # Reduced inertia weight for better exploitation\n        self.f = 0.8  # Balanced mutation factor for diversity\n        self.cr = 0.85  # Slightly increased crossover rate for exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.15, 0.15, (self.population_size, self.dim))  # Narrowed initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Adjusted range for learning rate\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.7 * self.learning_rate[i] + 0.3 * np.random.rand()  # Tweaked learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveMemoryHybridPSO_DE", "description": "Adaptive Memory-Enhanced Stochastic Hybrid PSO-DE with Mixed Strategy for Balanced Exploration and Exploitation.", "configspace": "", "generation": 87, "fitness": 0.3221492823235861, "feedback": "The algorithm AdaptiveMemoryHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.8869735570772668, 0.8667295500287167, 0.8554819120060357, 0.8839727230892849, 0.8750859019324451, 0.862483627938556, 0.8781851956329343, 0.8607584945217573, 0.8507083087846434, 0.7019322632582088, 0.5252379074648216, 0.6245612289540958, 0.5386481344965419, 0.49599076479089355, 0.4712203566085452, 0.5582974424054874, 0.5536752640309361, 0.5544459055059952, 0.13344750317091836, 0.13959963833053057, 0.1379091373684902, 0.11900070066168122, 0.1171162017686076, 0.13745628716731895, 0.15644415097196074, 0.13071233927143966, 0.13398026118056117, 0.10882796605058997, 0.12288365757762876, 0.11707322639768392, 0.11433669119539314, 0.10487681693113826, 0.11207536336085377, 0.13398163814381148, 0.10173326016251172, 0.12395695137514817, 0.9128510608386105, 0.8787529264304428, 0.896664219376207, 0.9104266523746678, 0.9286341687492444, 0.849657918388789, 0.9346938756580037, 0.9277704719824236, 0.8507505434624868, 0.30957086634573394, 0.2660375416361265, 0.2976349093087872, 0.36139046217534765, 0.34100358319558144, 0.407209037652529, 0.3588867852849149, 0.17764193149857366, 0.32255764175096546, 0.6372611180044376, 0.6349463229198782, 0.6793977774385435, 0.6152463687808949, 0.5866631647960286, 0.6325578117728425, 0.6407188249332998, 0.5767203154035336, 0.6360814536963257, 0.19661006426276095, 0.2774157143680076, 0.23138249664228006, 0.12240220385127776, 0.3389395025295826, 0.3505984442311345, 0.2744838204161134, 0.14714111617410597, 0.2740999683900246, 0.30825944307822606, 0.20819443772311308, 0.1751498326736881, 0.18307507669660839, 0.18165259482564733, 0.18064615684993224, 0.17735853032953708, 0.14556572048122196, 0.19784430593215574, 0.13508722119705707, 0.10902666124016269, 0.004137342281528844, 0.09365726475690439, 9.999999999998899e-05, 0.11719040298411909, 0.10970276799092848, 0.1486225332529335, 0.048986387276164556, 0.27142377296388864, 0.25194723950383746, 0.3237441847277651, 0.16968853217508517, 0.2763162042779359, 0.26439263292717874, 0.24239716861685434, 0.29107860539492203, 0.2815356844078232, 0.11025340510858728, 0.11503179845401612, 0.150993550849428, 0.14706845476654284, 0.07780636903375415, 0.24392701567525565, 0.26789114119149104, 0.16401924450971006, 0.15480419408938673, 0.19001348891901892, 0.166840655139336, 0.2530453415921221, 0.18479006587454938, 0.18366201832622897, 0.20058162380989675, 0.18375025748738116, 0.19833935378727363, 0.16755468794347994, 0.5704039734302923, 0.5370264769646769, 0.5322870991236018, 0.5866948020499609, 0.5714355753809194, 0.5136748889842164, 0.608709262825894, 0.5662271658774103, 0.588445120175041, 0.13270806233738897, 0.14420191659639037, 0.10138117155097659, 0.13147628127091793, 0.13782911281433485, 0.11118171362369544, 0.08793935735411484, 0.11315190712564249, 0.1600404172955575, 0.19695567308145312, 0.17172600043878594, 0.1837519060197732, 0.22627450752298583, 0.24047187980853246, 0.24330946959869693, 0.18266936689671875, 0.25459023693161253, 0.23507495098304465, 0.343419101276755, 0.3681755354701044, 0.3384375310801414, 0.41040996367565963, 0.36563729431904735, 0.37789909198094884, 0.37084384294925, 0.3646940458825567, 0.4232198563582471, 0.26983164918186975, 0.2717365653000643, 0.24682395647061306, 0.2688059585759712, 0.25304065494601524, 0.27255790590750095, 0.2785787568078427, 0.31819079648489534, 0.26522685334278373, 0.2462944239971253, 0.22811353419509983, 0.22005930255103112, 0.21810806719030928, 0.21154966637316563, 0.19172585632836925, 0.23128293512880704, 0.22165654257928213, 0.200377596478448, 0.1900756499187971, 0.2983068063627978, 0.2008657415941627, 0.20625322169022053, 0.2542616957338082, 0.24735801262801127, 0.1938893408226351, 0.2241323479092976, 0.19887852953124008, 0.18571783852390755, 0.1998411451544727, 0.18526706845144403, 0.6195791013373819, 0.19979098560515407, 0.19682915280315505, 0.5801498107505065, 0.5425822009854255, 0.8491495038191907, 0.39398833180021664, 0.732912175343943, 0.31890410965241733, 0.5323163427102032, 0.16344066841574734, 0.20601992104489264, 0.15481524647063472, 0.52654049544243, 0.5528779326823077, 0.18146162265010057, 0.17679156035321175, 0.20613915012356399, 0.19711100375741897, 0.19748600165899266, 0.20332008181008387, 0.19862173531018346, 0.1869404649716423, 0.22088221768373462, 0.07910232580168108, 0.08180829394665667, 0.08571780779122906, 0.10255581296993188, 0.07965742680868249, 0.0965278999629009, 0.09786785233327933, 0.10246545473064594, 0.09695452569510066]}, "mutation_prompt": null}
{"id": "040a7314-24dd-4d45-b740-9fbfb1b91c0f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "c167c798-6072-4dd5-9d31-4b1644d6d149", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "b68a9458-2a01-4b97-b33b-781627fe11ef", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "3031fa39-df7f-4470-913d-6f62843f3545", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "6ff2b749-ab6f-47cb-bae0-e0d14671d295", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "6efa4651-a849-4c18-8960-b88bf3dd3188", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "3c00da30-7107-4c27-903a-f11e02ffaf0a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "3f6de4a7-30ab-4ec0-8dcd-9f9840f297b3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "17df6059-562a-4428-989c-91abbe64956d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "cd85bc9b-077e-42da-920a-3c56aed48d17", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "c7e3fce9-f99d-4ebf-91b1-dafef38a0732", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.0  # Cognitive component adjusted for better convergence\n        self.c2 = 2.0  # Social component balanced for exploration\n        self.w = 0.6  # Increased inertia weight for exploration\n        self.f = 0.9  # Increased mutation factor for diversity\n        self.cr = 0.9  # Higher crossover rate for greater exploration\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broadened initial velocity range\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.05, 0.3, self.population_size)  # Adjusted learning rate range for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.6 * self.learning_rate[i] + 0.4 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * self.learning_rate[i] * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Stochastic Particle Swarm Optimization with Dynamic Differential Evolution Hybrid and Adaptive Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.7844828665452815, 0.8071888684102776, 0.8449768628033001, 0.8623763186640976, 0.8622955399451206, 0.8527370716877305, 0.8514591559911278, 0.832355279718864, 0.8576074610571196, 0.6553144373555528, 0.6354080001358486, 0.7206908709516299, 0.5042605410000844, 0.512289406097417, 0.5604966557167173, 0.5288286319905087, 0.6696610461755415, 0.5161738006959575, 0.15506655337326958, 0.18499395836760235, 0.12980471261248405, 0.12609390781380903, 0.10848312813180583, 0.1262023019581009, 0.14778013020283542, 0.13051679434810448, 0.1149393604504747, 0.11542410273318615, 0.09856416401101575, 0.10792784155222546, 0.10455907479049675, 0.12372574373539424, 0.12759656738303615, 0.10968542077676446, 0.1013654044187986, 0.10197773517050412, 0.9177251552706535, 0.8973084098249297, 0.9289012729305839, 0.9015216258355165, 0.9564317287761714, 0.8803630504211986, 0.9285382411004207, 0.887763267805737, 0.8989693828481525, 0.3285883761519064, 0.3164830719524665, 0.3905474172572845, 0.3565722746529537, 0.3952852286550562, 0.3869118799696154, 0.3789793656269197, 0.3281866380578229, 0.3320487846371756, 0.7090988036875762, 0.624147002595363, 0.5954668068224505, 0.6821302462376104, 0.8944628928849615, 0.6742502684597078, 0.647476034028192, 0.676353970265964, 0.34716511977424447, 0.2702361608028374, 0.1806215729954611, 0.15857238416271924, 0.19947299982224775, 0.21398110816407367, 0.15560275877754526, 0.17172617433444726, 0.2751461946257441, 0.40518331182739475, 0.26705122917719326, 0.17818084098060027, 0.16247588447795736, 0.2724661471508034, 0.1953956121730862, 0.17861280047143702, 0.1819924504015632, 0.14755122050066005, 0.17175627157642115, 0.20586040322422783, 0.12155503795865841, 0.1574222013579325, 0.09394307412175928, 0.147849521393985, 0.190448756294887, 0.024504167129806964, 0.1957159377210499, 0.2848361740477715, 0.34064115318608856, 0.37227795674209874, 0.2897213300587569, 0.30083762454772267, 0.31281566874691713, 0.267028420283673, 0.3703223886170436, 0.3530886594822177, 0.31921690217669507, 0.06354323607037371, 0.11928348549951517, 0.3062794011442793, 0.1231173329763382, 0.279354242248536, 0.23878400793571553, 0.4072448203236392, 0.19391268898857805, 0.18244833556866635, 0.18291733453690273, 0.21522221804867425, 0.32066054841932623, 0.19227873981764854, 0.2091678897871453, 0.20323152146873014, 0.19415282112394616, 0.2092850192603548, 0.17481174554561463, 0.5789037488717454, 0.5839801223288174, 0.6004844997488652, 0.5600546247363496, 0.5542517192691752, 0.5521648883722723, 0.5748682057046792, 0.6001440635895887, 0.5933863764497916, 0.12845525547055092, 0.12916656346991862, 0.11628740712212748, 0.14521229422405868, 0.10237736693997035, 0.09142676804569894, 0.13930805446988292, 0.12744493444924232, 0.15102795663020607, 0.30052517855382543, 0.16237294946251402, 0.1887171994171566, 0.21580630711226645, 0.18307222829720338, 0.22300007899655516, 0.2342050712939323, 0.2195289782360217, 0.19503328639041095, 0.3065859229656447, 0.37071992543961174, 0.35121671421595946, 0.36098610470418757, 0.3662573917354358, 0.3513009896132968, 0.37418702870864085, 0.4348128179494197, 0.33451610209151517, 0.23022801518034708, 0.27005176015378984, 0.2692214859182378, 0.26010809879969776, 0.3175881195494279, 0.2905143175902831, 0.30156782079654354, 0.30500183335450404, 0.2746302137017772, 0.21126147122971806, 0.20437012161664692, 0.22828755539298462, 0.2571203415157425, 0.26029516456350443, 0.30058239964864564, 0.2808437559689515, 0.2018157441503705, 0.20554990201508794, 0.17799535594516236, 0.19918579928486757, 0.20135957048761643, 0.22687485216370906, 0.1982886398462107, 0.17760679601083607, 0.19505986258610009, 0.21443285010781465, 0.20198885386071364, 0.41344927972176393, 0.1868687628905048, 0.6620512650353056, 0.778510757975634, 0.5948578433147049, 0.20881980304261427, 0.1885573166681701, 0.4006789625763961, 0.9130723421332477, 0.6515538276267125, 0.7017284187601045, 0.5014674185324521, 0.3437415619209859, 0.6266437281784665, 0.19718791111066747, 0.41454005220112655, 0.6428118910391146, 0.16502107142696654, 0.2121339203466116, 0.18814186394594512, 0.18653653005695237, 0.1939896483659741, 0.18703834025418342, 0.19857640796668352, 0.21717424537295416, 0.23179715247524346, 0.1801493791748915, 0.08418203882049002, 0.08686342995499141, 0.08558165967345466, 0.09907119402355036, 0.08951751791875517, 0.10068197015312252, 0.0767654791066954, 0.08119531985169526, 0.07309481954291497]}, "mutation_prompt": null}
{"id": "34b79c02-781d-4b2c-abcc-5801eecc4a3f", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptivePSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.5  # Adjusted cognitive component for quantum adaptation\n        self.c2 = 1.5  # Modified social component for balance\n        self.w = 0.7  # Increased inertia for better diversity\n        self.f = 0.8  # Mutation factor adjusted for stability\n        self.cr = 0.8  # Lower crossover rate for focused exploitation\n        self.positions_pso = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # Narrower velocity range for precision\n        self.personal_best_positions = np.copy(self.positions_pso)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n        self.learning_rate = np.random.uniform(0.1, 0.25, self.population_size)  # Fine-tuned learning rate for adaptability\n        self.memory_positions_de = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.memory_scores_de = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                score = func(self.positions_pso[i])\n                self.evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions_pso[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions_pso[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.learning_rate[i] = 0.7 * self.learning_rate[i] + 0.3 * np.random.rand()  # Updated learning rate adaptation\n                self.velocities[i] = (\n                    self.w * self.velocities[i]\n                    + self.c1 * r1 * (self.personal_best_positions[i] - self.positions_pso[i])\n                    + self.c2 * r2 * (self.global_best_position - self.positions_pso[i])\n                ) * self.learning_rate[i]\n                self.positions_pso[i] = np.clip(\n                    self.positions_pso[i] + self.velocities[i], self.lower_bound, self.upper_bound\n                )\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(\n                    self.memory_positions_de[a] + self.f * (self.memory_positions_de[b] - self.memory_positions_de[c]),\n                    self.lower_bound,\n                    self.upper_bound,\n                )\n                cross_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(cross_points, mutant, self.memory_positions_de[i])\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.memory_scores_de[i]:\n                    self.memory_positions_de[i] = trial\n                    self.memory_scores_de[i] = trial_score\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "name": "QuantumInspiredAdaptivePSO_DE", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Dynamic Differential Evolution for Enhanced Global Convergence.", "configspace": "", "generation": 99, "fitness": 0.25158590531998054, "feedback": "The algorithm QuantumInspiredAdaptivePSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "f4a61b45-5231-4b2d-9e57-8bd3a5537287", "metadata": {"aucs": [0.8563224096778821, 0.8574112070841454, 0.8519377008060743, 0.6265167726507364, 0.687204669168377, 0.5742117319798759, 0.4869556772474709, 0.8527102749674627, 0.8193466102856473, 0.29288057097198006, 0.282965240858147, 0.6574954082502786, 0.47849564393414523, 0.24776502446635595, 0.553881379153647, 0.36716275439240875, 0.5256660485900418, 0.36248808436851854, 0.17075845375022147, 0.12627710250697344, 0.11366851379502496, 0.10968906317881433, 0.09922166078528039, 0.11748624333343904, 0.13779690189099725, 0.11461652497442687, 0.11348046811385926, 0.15163804117609037, 0.0783740013897799, 0.09654415418514295, 0.13269256292431308, 0.08552205254245748, 0.0896524510056288, 0.09936358467065165, 0.09941400451550397, 0.10938249817238066, 0.9220539286528638, 0.9646359884329151, 0.9332048851689105, 0.9297207787809617, 0.9396348865457194, 0.922750459652654, 0.9399340372119026, 0.9207282293744837, 0.938376236970422, 0.17741409695982935, 0.23154874133103154, 0.21322290076538752, 0.22539478363480414, 0.210514774118029, 0.18423161894950313, 0.21072418697430007, 0.16842801521410988, 0.2617150427232303, 0.3284369041366161, 0.2701125664958427, 0.22894941965765558, 0.3160518070155859, 0.28350798801324795, 0.29507080105141625, 0.33648847093972056, 0.2594401320314883, 0.2357176260814443, 0.18484925050414847, 0.20199435707049795, 0.14931064373244773, 0.13413846407261776, 0.14686018029464654, 0.16967976971531407, 0.15803714077877085, 0.16408761070548772, 0.17391371104689846, 0.28244876040195255, 0.13136091224258561, 0.1300293971816332, 0.15848071249083573, 0.2050644934985919, 0.14855140991000626, 0.18268022599069567, 0.13380909496650328, 0.12402683669621761, 0.005692461661720105, 0.007815163725580554, 0.09432395518810865, 0.01760589727504358, 0.03162689121871898, 0.005550334378670918, 0.001941431765872914, 0.010142760929301997, 9.999999999998899e-05, 0.08321729654821353, 0.08404470287972376, 0.09932879388545657, 0.08193179624614444, 0.09868022824576639, 0.12963535355616862, 0.11923177132042984, 0.1099145141014245, 0.10208437990619768, 0.07445716793260604, 0.10193498006992563, 0.15084819104390879, 0.10543105669800479, 0.09941605631194983, 0.19195580594617268, 0.15211459070910882, 0.17930724907675522, 0.12988011120541665, 0.1867875649856714, 0.07913603955850157, 0.26917898880649027, 0.10715168309563139, 0.0873139553870802, 0.15048626898588935, 0.11784936517694333, 0.07427061565947624, 0.09025916491125952, 0.48211170983637475, 0.4510786793736822, 0.4540484176206897, 0.4188514748677329, 0.4410309291501845, 0.42130388865238066, 0.454094042244763, 0.4383143491974033, 0.4565943508870357, 0.08232201117119098, 0.09598687477998757, 0.08344770901596199, 0.11064068192612964, 0.08018986998238742, 0.0921700445264616, 0.10467545109033782, 0.11956621929324607, 0.08720686777172082, 0.3245386866012816, 0.17662990292004466, 0.1801945498090134, 0.16855362723646672, 0.23577583164075555, 0.14869139223270011, 0.1813494718203773, 0.20571876570689707, 0.16830484552679914, 0.21851721083142117, 0.25728748573465365, 0.30213389581504213, 0.2809903688530937, 0.23515935428568846, 0.23096817011259996, 0.3376169855461886, 0.30450619828265324, 0.265417157484088, 0.20288816982918634, 0.17547920999030697, 0.18294797982276778, 0.20329178815305282, 0.18705181887578803, 0.22453146010678304, 0.19641929710652195, 0.19641885857827224, 0.25056465367118885, 0.20047037072579832, 0.21925446734475573, 0.19800254524017513, 0.21106378206770093, 0.19171276371192347, 0.20750559844998795, 0.21732160341338402, 0.18223249113453033, 0.2227012880441822, 0.17699929402044112, 0.18361591270137423, 0.192338857791866, 0.17756935123382522, 0.17905396007200325, 0.19373282055097163, 0.17622079850797712, 0.18680251950778093, 0.17703077966709224, 0.3050377758396652, 0.17025374792511305, 0.1893257350319446, 0.1980616666892242, 0.1990401919035465, 0.6478854396778524, 0.16639059417055546, 0.1816267601604773, 0.8658927956526166, 0.6074732653057047, 0.210442976956407, 0.19352728174446243, 0.46241484496053786, 0.20462829463884813, 0.1650500259759745, 0.2997890148931398, 0.2481720501310961, 0.36972379135143907, 0.1887363257043152, 0.17946255810036926, 0.22697559431179926, 0.18312991221905417, 0.18138296076387128, 0.17206418240573385, 0.1970315319867474, 0.1929957743492785, 0.21013148268352833, 0.08211378302367778, 0.09587616241450414, 0.09071247084445822, 0.09845744397958589, 0.095399316802668, 0.10047835786270842, 0.0778318482573348, 0.0991334441617322, 0.09172187574730628]}, "mutation_prompt": null}
