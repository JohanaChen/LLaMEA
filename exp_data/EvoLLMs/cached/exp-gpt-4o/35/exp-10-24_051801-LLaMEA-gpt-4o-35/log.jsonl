{"id": "a59a9297-7bdc-4ecb-b7da-981128a22d83", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.inertia = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] + \n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_ADM", "description": "A hybrid Particle Swarm Optimization with Adaptive Differential Mutation for improved exploration and exploitation balance.", "configspace": "", "generation": 0, "fitness": 0.28898272734569497, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7526986232879042, 0.7715613408716807, 0.7669401296977081, 0.7632776866110003, 0.7577078623178927, 0.7884807780348742, 0.770604534014956, 0.7834378759484486, 0.7652320989680721, 0.3890788820904246, 0.3949375109241444, 0.43297537251524487, 0.4770006081793051, 0.46738661784219726, 9.999999999998899e-05, 0.4873947655224409, 0.4993654849734439, 0.46463351760481997, 0.17659152810485435, 0.10821275286907639, 0.07311229557563181, 0.1355585206011276, 0.1777408403750338, 0.14215573185715424, 0.17247118363192515, 0.15185008238483677, 0.14449570286094748, 0.14405048377641194, 0.1689922619640123, 0.1151937654208437, 0.12139929994151955, 0.11397537543697267, 0.09507020933944588, 0.11088562571079341, 0.09839126442756874, 0.17008375067014891, 0.9826887765509578, 0.9813543856967017, 0.9793607818415632, 0.9847178267754744, 0.9808082974986725, 0.9795398549564044, 0.9854688722524505, 0.9860426258516761, 0.9847394866494249, 0.5306186986480347, 0.4704787392457487, 0.46804272373887745, 0.4959534880990589, 0.5337824757215894, 0.4806915031281498, 0.46384054489237236, 0.08884448346187834, 0.4635295754461538, 0.746919907202181, 0.31370179454769753, 0.22333109895442427, 0.21922414073187624, 0.6552788065018679, 0.704203191271189, 0.22400734807527078, 0.2243193320190522, 0.6790526726854038, 0.17668435868009402, 0.20248748859116972, 0.19506936669201103, 0.18150480928088164, 0.09925934884343746, 0.12516909888144778, 0.18423004242278118, 0.15054927054603762, 0.19244866726626242, 0.1903302735553638, 0.02166313825964228, 0.10950526879028477, 0.21096644301559497, 0.17974780486989184, 0.21169288394321562, 0.23220615720900173, 0.1824168828017032, 0.18006191730739707, 0.007963846750266512, 0.009981715419051906, 0.006830107474556146, 0.03701269485544256, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004514749316656408, 0.005150248930307133, 0.1451416138240691, 0.1440835271750317, 0.08739992075248171, 0.08254120593937075, 0.13562086941545315, 0.011338641548662376, 0.019706426135744026, 0.08875347976261105, 0.08469164821434316, 0.04830140000010252, 0.11163014890884693, 0.09849231790497992, 0.0838587654034223, 0.06370154427517916, 0.06565272678838951, 0.06334843594806006, 0.07614797387174421, 0.17736603370661652, 0.10575994131254429, 0.12989703367854522, 0.23642233019294934, 0.15693867366558023, 0.09303386962104432, 0.006021154672415263, 0.16556121345421415, 0.07693428098018762, 0.0541985292878282, 0.11780433739234486, 0.5346271556692398, 0.5310188552510667, 0.4924974076832248, 0.48239958548118367, 0.5075738795027789, 0.5086525162423061, 0.4986578072918517, 0.5211810704107449, 0.5326591165052758, 0.1254119369321739, 0.11774517303912457, 0.062257013515547466, 0.14601320960215436, 0.15996205046670298, 0.11520851363066664, 0.07519845595128771, 0.08804049607681119, 0.14904561639305958, 0.1791776266146875, 0.44183479028222017, 0.22709476922154914, 0.23813266656955834, 0.19691478747728297, 0.22848651768904915, 0.3490092147207603, 0.1995991732215443, 0.2724668753266607, 0.36653044648662103, 0.3958373592894501, 0.4631064996123051, 0.37475654482325393, 0.31937649337782636, 0.4320723603380414, 0.25378503223315707, 0.45499439667990305, 0.4295815314230643, 0.2686813878993106, 0.24461231936842498, 0.337715987320212, 0.3222214145617901, 0.22021465433837872, 0.2442692983580962, 0.27681737485021574, 0.23356352612711773, 0.26912864680964343, 0.2090170020368438, 0.22337312080610405, 0.21118032726250813, 0.22513102169826038, 0.21705363641437458, 0.19610808284027048, 0.23323022664275472, 0.22149941964139297, 0.2132642449468719, 0.23691045205243177, 0.21331205054377478, 0.22299432214956505, 0.19074762691633007, 0.39774365524520927, 0.20294398750128329, 0.5257218133578798, 0.1895585540931266, 0.2247815128107592, 0.8722963923232274, 0.1891266566856974, 0.15405525197208114, 0.17251258261068547, 0.1997585991088605, 0.1995919977567271, 0.13041337040064194, 0.16924142192624225, 0.8445676097728306, 0.7010880693596167, 0.15583082174773588, 0.6452714699573567, 0.484741028248167, 0.11169032524505951, 0.569930907111335, 0.10502553686855676, 0.11613643098739557, 0.16814887314872284, 0.2111437919463529, 0.18787724135155537, 0.19958717751203192, 0.18628652853984895, 0.1881476750800729, 0.20284954177447567, 0.20810524793407026, 0.19596649357356133, 0.18260561529624042, 0.08450969948763598, 0.0977943949521416, 0.09565116012784347, 0.08144798974767253, 0.10076134709684081, 0.0857650863904259, 0.07210247350007792, 0.10433195811528162, 0.09568857744070114]}, "mutation_prompt": null}
{"id": "cc82b7d7-f48b-4c1e-981b-871b2101fa44", "solution": "import numpy as np\n\nclass HybridPSO_ADMW:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.inertia_initial = 0.9\n        self.inertia_final = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Dynamic inertia weight\n            inertia = (self.inertia_initial - self.inertia_final) * (self.budget - eval_count) / self.budget + self.inertia_final\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_ADMW", "description": "Particle Swarm Optimization with Adaptive Differential Mutation and Dynamic Inertia Weight for enhanced convergence.", "configspace": "", "generation": 1, "fitness": 0.2571377008021137, "feedback": "The algorithm HybridPSO_ADMW got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "a59a9297-7bdc-4ecb-b7da-981128a22d83", "metadata": {"aucs": [0.6786433064831552, 0.6799044768822096, 0.6627335715194758, 0.676742591993763, 0.67313665290086, 0.6618205953410121, 0.68037203186122, 0.6798334870181795, 0.6722879340392739, 9.999999999998899e-05, 0.26047701991873073, 0.052660700997415044, 0.3762445537798962, 0.4089091987270608, 0.3656986164816206, 0.3893738588806107, 0.03979122047498729, 0.4010811650098264, 0.1871405320072851, 0.11712018938341384, 0.36728230209935764, 0.3182342751865228, 0.11631052800423736, 0.1522651658477191, 0.13397187448485837, 0.14137565913924122, 0.1495140748035637, 0.14900822528436142, 0.10776333012198125, 0.11047770177341831, 0.10467900099746708, 0.09550964061582345, 0.1070445734528861, 0.09347730745667593, 0.10337547244001832, 0.10395955634856824, 0.9827982623105813, 0.9854666952523398, 0.9820469231978121, 0.9828909548884911, 0.9857394753125708, 0.9795210244230826, 0.9863851221739197, 0.9860739980451334, 0.9847376522802275, 0.39746078342336655, 0.39070955599761537, 0.45416950883491736, 0.43984168640521837, 0.4202568546207295, 0.36506075770048974, 0.33367950682061875, 0.08859847480226546, 0.08488604604929006, 0.2980061197065529, 0.5370893904390753, 0.21515294054715994, 0.3167954639286895, 0.1864281415385004, 0.20772974769688402, 0.2128287981315351, 0.6069207527298788, 0.6780155691943297, 0.1673970697154087, 0.19100088753481637, 0.16010467915224857, 0.11097692578203455, 0.11537794004883306, 0.09537205148676275, 0.11078746407692175, 0.15828279416360524, 0.1756352467904102, 0.15392960784588172, 0.05272241254289001, 0.18673903335841835, 0.16997834274604684, 0.18955747704251558, 0.17114803002009216, 0.18480167533264735, 0.16688433319112705, 0.16744970381150903, 0.0334943744675793, 0.04278189108087793, 0.03137188939725988, 0.03421759215997611, 9.999999999998899e-05, 9.999999999998899e-05, 0.03739303533841487, 9.999999999998899e-05, 9.999999999998899e-05, 0.10124934052886525, 0.06591166683526939, 0.08296232261757541, 0.053532712995517207, 0.009702288793994152, 0.016989961034269307, 0.03827447621255142, 0.06891088222987019, 0.03542909927654159, 0.06865748265096971, 0.1495920605870229, 0.032762080872788424, 0.04704788025383988, 0.051635612626751426, 0.049814086244963085, 0.06170817216567703, 0.07009340513815965, 0.06038897290968215, 0.03764246540034455, 0.11098054410787062, 0.07726918766052826, 0.1801865562130741, 0.004758187122910984, 0.17876717623022365, 0.21484600402116716, 0.04971790407115917, 0.06851126825916909, 0.43899648448062367, 0.44163883330064824, 0.4326215166955859, 0.4971070116841412, 0.4542453234728079, 0.46344948306620193, 0.4757704297206131, 0.47517898735770503, 0.47285727131423094, 0.059153347102499754, 0.08452607766777454, 0.11174155416303233, 0.0902381015403887, 0.09713986415988096, 0.11952878185391569, 0.0844686036157889, 0.09971949391816692, 0.10944456235185862, 0.20660953194581744, 0.2847978544373183, 0.14204637833231715, 0.1959716823739317, 0.23441545806007125, 0.2075600640974281, 0.17959799553524047, 0.15502938927344967, 0.19627363791911745, 0.3116858430970322, 0.30489442447272463, 0.32755764567496815, 0.32767032370389304, 0.39927089593329956, 0.32436194071292135, 0.4129612719277589, 0.34671167134669323, 0.4028207349158053, 0.25697871302755326, 0.2758084572163355, 0.25872395105237433, 0.2554704739171084, 0.2812906519062275, 0.1827174673820786, 0.28783624352842085, 0.2700012063747871, 0.23914408020627653, 0.18231540166034832, 0.18512610288433784, 0.19003306359692673, 0.2193914269198558, 0.20358636213260495, 0.21567025644005755, 0.18282708025839478, 0.19155712411983772, 0.21795577016064116, 0.20596556329149673, 0.2109461936967264, 0.19867713522668007, 0.2820776586033168, 0.1990293255191381, 0.19575735354592183, 0.3772210314097715, 0.19571895833160413, 0.18517183577771568, 0.15287176242703904, 0.18698400437345586, 0.15298607477367931, 0.7397205321954328, 0.19493030655683297, 0.19506649628545258, 0.09859254265679629, 0.1695095192609961, 0.7427996768537583, 0.4309609289760844, 0.15421865286162806, 0.6033764899716869, 0.536382977409654, 0.5017789458089601, 0.5602082982202985, 0.19045851359027455, 0.12633518736753357, 0.16715533438313757, 0.1991173505637187, 0.20631408543424645, 0.20185080464329042, 0.19194918752346302, 0.1922865333902054, 0.17922988430176667, 0.1928898614911828, 0.18226926967147516, 0.18145925436735022, 0.08336916773557768, 0.08187002133124588, 0.08587508511332853, 0.08645124466344767, 0.0825607412267676, 0.0872208048008577, 0.10196013994591979, 0.10070630978992745, 0.08220917152289098]}, "mutation_prompt": null}
{"id": "ac636c4d-6f4f-4f59-897f-06a2a5d55142", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30\n        self.inertia = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] + \n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_ADM", "description": "A hybrid Particle Swarm Optimization with Adaptive Differential Mutation for improved exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a59a9297-7bdc-4ecb-b7da-981128a22d83", "metadata": {"aucs": [0.7526986232879042, 0.7715613408716807, 0.7669401296977081, 0.7632776866110003, 0.7577078623178927, 0.7884807780348742, 0.770604534014956, 0.7834378759484486, 0.7652320989680721, 0.3890788820904246, 0.3949375109241444, 0.43297537251524487, 0.4770006081793051, 0.46738661784219726, 9.999999999998899e-05, 0.4873947655224409, 0.4993654849734439, 0.46463351760481997, 0.17659152810485435, 0.10821275286907639, 0.07311229557563181, 0.1355585206011276, 0.1777408403750338, 0.14215573185715424, 0.17247118363192515, 0.15185008238483677, 0.14449570286094748, 0.14405048377641194, 0.1689922619640123, 0.1151937654208437, 0.12139929994151955, 0.11397537543697267, 0.09507020933944588, 0.11088562571079341, 0.09839126442756874, 0.17008375067014891, 0.9826887765509578, 0.9813543856967017, 0.9793607818415632, 0.9847178267754744, 0.9808082974986725, 0.9795398549564044, 0.9854688722524505, 0.9860426258516761, 0.9847394866494249, 0.5306186986480347, 0.4704787392457487, 0.46804272373887745, 0.4959534880990589, 0.5337824757215894, 0.4806915031281498, 0.46384054489237236, 0.08884448346187834, 0.4635295754461538, 0.746919907202181, 0.31370179454769753, 0.22333109895442427, 0.21922414073187624, 0.6552788065018679, 0.704203191271189, 0.22400734807527078, 0.2243193320190522, 0.6790526726854038, 0.17668435868009402, 0.20248748859116972, 0.19506936669201103, 0.18150480928088164, 0.09925934884343746, 0.12516909888144778, 0.18423004242278118, 0.15054927054603762, 0.19244866726626242, 0.1903302735553638, 0.02166313825964228, 0.10950526879028477, 0.21096644301559497, 0.17974780486989184, 0.21169288394321562, 0.23220615720900173, 0.1824168828017032, 0.18006191730739707, 0.007963846750266512, 0.009981715419051906, 0.006830107474556146, 0.03701269485544256, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004514749316656408, 0.005150248930307133, 0.1451416138240691, 0.1440835271750317, 0.08739992075248171, 0.08254120593937075, 0.13562086941545315, 0.011338641548662376, 0.019706426135744026, 0.08875347976261105, 0.08469164821434316, 0.04830140000010252, 0.11163014890884693, 0.09849231790497992, 0.0838587654034223, 0.06370154427517916, 0.06565272678838951, 0.06334843594806006, 0.07614797387174421, 0.17736603370661652, 0.10575994131254429, 0.12989703367854522, 0.23642233019294934, 0.15693867366558023, 0.09303386962104432, 0.006021154672415263, 0.16556121345421415, 0.07693428098018762, 0.0541985292878282, 0.11780433739234486, 0.5346271556692398, 0.5310188552510667, 0.4924974076832248, 0.48239958548118367, 0.5075738795027789, 0.5086525162423061, 0.4986578072918517, 0.5211810704107449, 0.5326591165052758, 0.1254119369321739, 0.11774517303912457, 0.062257013515547466, 0.14601320960215436, 0.15996205046670298, 0.11520851363066664, 0.07519845595128771, 0.08804049607681119, 0.14904561639305958, 0.1791776266146875, 0.44183479028222017, 0.22709476922154914, 0.23813266656955834, 0.19691478747728297, 0.22848651768904915, 0.3490092147207603, 0.1995991732215443, 0.2724668753266607, 0.36653044648662103, 0.3958373592894501, 0.4631064996123051, 0.37475654482325393, 0.31937649337782636, 0.4320723603380414, 0.25378503223315707, 0.45499439667990305, 0.4295815314230643, 0.2686813878993106, 0.24461231936842498, 0.337715987320212, 0.3222214145617901, 0.22021465433837872, 0.2442692983580962, 0.27681737485021574, 0.23356352612711773, 0.26912864680964343, 0.2090170020368438, 0.22337312080610405, 0.21118032726250813, 0.22513102169826038, 0.21705363641437458, 0.19610808284027048, 0.23323022664275472, 0.22149941964139297, 0.2132642449468719, 0.23691045205243177, 0.21331205054377478, 0.22299432214956505, 0.19074762691633007, 0.39774365524520927, 0.20294398750128329, 0.5257218133578798, 0.1895585540931266, 0.2247815128107592, 0.8722963923232274, 0.1891266566856974, 0.15405525197208114, 0.17251258261068547, 0.1997585991088605, 0.1995919977567271, 0.13041337040064194, 0.16924142192624225, 0.8445676097728306, 0.7010880693596167, 0.15583082174773588, 0.6452714699573567, 0.484741028248167, 0.11169032524505951, 0.569930907111335, 0.10502553686855676, 0.11613643098739557, 0.16814887314872284, 0.2111437919463529, 0.18787724135155537, 0.19958717751203192, 0.18628652853984895, 0.1881476750800729, 0.20284954177447567, 0.20810524793407026, 0.19596649357356133, 0.18260561529624042, 0.08450969948763598, 0.0977943949521416, 0.09565116012784347, 0.08144798974767253, 0.10076134709684081, 0.0857650863904259, 0.07210247350007792, 0.10433195811528162, 0.09568857744070114]}, "mutation_prompt": null}
{"id": "13350b2d-768c-4a22-8b38-a01d0a2ff76a", "solution": "import numpy as np\n\nclass EnhancedPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly increased population for diversity\n        self.inertia = 0.6  # Modified inertia for better stability\n        self.c1 = 1.7  # Increased cognitive component\n        self.c2 = 1.3  # Decreased social component\n        self.mutation_factor = 0.9  # Increased mutation factor for diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.5  # Reduced clamping for more control\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Dynamic adjustment of inertia\n            self.inertia = 0.4 + 0.3 * (self.budget - eval_count) / self.budget\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedPSO_ADM", "description": "An enhanced Particle Swarm Optimization incorporating Adaptive Differential Mutation with dynamic parameter adjustment for optimal balance between exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.3081415356950033, "feedback": "The algorithm EnhancedPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "a59a9297-7bdc-4ecb-b7da-981128a22d83", "metadata": {"aucs": [0.7845251077307343, 0.7660275340395952, 0.7952791055428069, 0.7794720347966636, 0.7621351370341113, 0.7783981959527053, 0.7877189543676247, 0.7556435663310455, 0.7704395581869145, 0.037143703825378016, 0.5554673687247349, 0.5638339160460497, 0.5265722493060752, 0.4650690202612876, 0.5399811099854908, 0.5641347188782828, 0.5631598450390969, 0.5280927114004718, 0.12842235814728542, 0.1122556008279807, 0.1331429251512244, 0.15002490962282988, 0.4924985232846947, 0.13279498823988523, 0.13966481342346648, 0.14562145887181865, 0.13233533485151894, 0.12046278712933167, 0.13632219814327018, 0.11077819075416084, 0.17300843169167546, 0.12129357427173659, 0.09788250562289647, 0.11166739548395432, 0.14753233467288795, 0.10773245748664906, 0.9764650826897631, 0.9824065744535867, 0.9756703152866145, 0.9710595454441476, 0.973343637653513, 0.975499014208232, 0.9830014159880682, 0.9763554536690028, 0.9736491350255296, 0.5619136011314945, 0.4757994516439923, 0.5204314912229966, 0.5216058653021132, 0.45295635344177854, 0.527417126249454, 0.46155623127531664, 0.532763377446074, 0.5297467971647298, 0.22241807944974457, 0.6240729273848042, 0.7471561586741136, 0.2708993016576785, 0.5995994325698708, 0.20274679891551117, 0.5931666287554491, 0.23605093599806481, 0.2839964236908026, 0.1778772658358595, 0.1844274882917818, 0.18947874188489244, 0.12272419741150609, 0.12529318805136336, 0.18185357416198933, 0.18146633014942604, 0.22932678520148853, 0.20143369740605688, 0.20552304753281359, 0.18592065848357986, 0.19535044691863768, 0.21623761171290712, 0.1874377494322621, 0.24090628868715258, 0.309581794657101, 9.999999999998899e-05, 0.09173054499033784, 0.05488951572597489, 0.0009819377928100836, 9.999999999998899e-05, 0.00021194801354540438, 0.008400159637467763, 9.999999999998899e-05, 9.999999999998899e-05, 0.005839762044269392, 0.10942679727868732, 0.10517387241972409, 0.0723820068390918, 0.1015318701063006, 0.08389311578669989, 0.08762040964432505, 0.036184635935237575, 0.08764460428813559, 0.07299513030959237, 0.05568800488661596, 0.13191073809281584, 0.028520633246402527, 0.04153178510224875, 0.1475099975761328, 0.07872225870190974, 0.10690854434924368, 0.0790887963160758, 0.1320886226013046, 0.12477396647940897, 0.1933503285785546, 0.23349189136939053, 0.20877005765768708, 0.006124904847331192, 0.14985004689642922, 0.08381602816914113, 0.2541073649444675, 0.07722259142270049, 0.07610926009657704, 0.5099132685300363, 0.5241878324730143, 0.5091105548247381, 0.526989302104882, 0.5099192605949354, 0.5045215576720887, 0.5249879571529023, 0.5114437152707592, 0.5287181909810679, 0.12379507735600526, 0.10780455485474172, 0.09882238444589353, 0.10655088404553426, 0.13281640683316853, 0.13834362904009978, 0.12525631964277395, 0.5077117207632391, 0.13908972817858956, 0.15746293743214224, 0.16046832730625415, 0.30027768320451687, 0.18889157360308562, 0.16040542364593346, 0.17257449869410868, 0.19115853570373376, 0.12951577553219829, 0.204821349433277, 0.3689360875545007, 0.29226813902423665, 0.40031229666123935, 0.2562008903380053, 0.35390879646513795, 0.3632004239556279, 0.464016665562043, 0.4526143955764368, 0.4130255772324063, 0.30372974476179737, 0.22342342396206372, 0.2124234115094107, 0.36761667243208307, 0.2985201121831542, 0.19892304417027973, 0.288069552994758, 0.22910480279751877, 0.3715078368813759, 0.20377013881969475, 0.23881704884466914, 0.18483878600507953, 0.20611687714243554, 0.21501342535298584, 0.24657297897974828, 0.22678331203989754, 0.23262536750907092, 0.2376504044279928, 0.23597053575102322, 0.18915802724391995, 0.22237803456432348, 0.23439804523181007, 0.5471202758277437, 0.21860399531556873, 0.19341531108421173, 0.2049835241751623, 0.20425038600056933, 0.8582405268925846, 0.7828652625210534, 0.15164031902609876, 0.8980587417015418, 0.19927983074901756, 0.19893732136242437, 0.14191657975478644, 0.1690591497711582, 0.8536491394136746, 0.6464367171051468, 0.2103867372146878, 0.776629234362583, 0.6517815525181412, 0.5520792980370757, 0.1675853973948016, 0.6415356608229424, 0.19709093299238778, 0.6428552567057852, 0.18987299229618015, 0.2069391268433073, 0.1705295368179428, 0.19489699649971548, 0.19183654419503104, 0.17688039293891766, 0.18329912332168274, 0.17512960331970318, 0.17550627627467585, 0.08415117056533872, 0.08470791592428883, 0.12513102276212373, 0.08984098057707246, 0.08578538042085893, 0.08923812685963972, 0.093775577322871, 0.0846841036571524, 0.08849960399639134]}, "mutation_prompt": null}
{"id": "0e02eefe-d99b-411e-b5f7-66b08c14e96d", "solution": "import numpy as np\n\nclass QuantumEnhancedPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population size for greater exploratory power\n        self.inertia = 0.7  # Enhanced inertia for better exploration phase\n        self.c1 = 1.5  # Balanced cognitive component\n        self.c2 = 1.5  # Balanced social component\n        self.mutation_factor = 0.85  # Slightly reduced mutation factor\n        self.crossover_rate = 0.9  # Enhanced crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0  # Further reduced clamping\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Quantum-inspired velocity update\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            self.inertia = 0.5 + 0.2 * (self.budget - eval_count) / self.budget\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.tanh(velocities) * self.velocity_clamp\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Quantum Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (self.mutation_factor * particles[a] +\n                                     (1 - self.mutation_factor) * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "QuantumEnhancedPSO_ADM", "description": "A novel hybrid metaheuristic combining Quantum-inspired Particle Swarm Optimization with Adaptive Differential Mutation for enhanced convergence and diversity.", "configspace": "", "generation": 4, "fitness": 0.15916022609010408, "feedback": "The algorithm QuantumEnhancedPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "13350b2d-768c-4a22-8b38-a01d0a2ff76a", "metadata": {"aucs": [0.23905737598243249, 0.27702860739751634, 0.26487974707957185, 0.2716098808186145, 0.2511555296364347, 0.26348205465430563, 0.24367039282719494, 0.267514780626419, 0.24506291284998627, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07277126503855835, 0.07700951772722087, 0.07013814956260267, 0.061362511931297714, 0.07090846052904676, 0.07179445478689284, 0.06639413715069908, 0.07793097733995213, 0.06480893831060197, 0.05671220132519006, 0.058345134735597326, 0.07476686325712567, 0.07627600159456394, 0.054500558943204824, 0.07248438770414412, 0.05838499990963697, 0.06063847238887177, 0.057473707593627466, 0.9735347951123831, 0.9524191274352609, 0.9655274073818394, 0.9659008880022545, 0.964582319633161, 0.9655190492915156, 0.9748000804860214, 0.9647331389668244, 0.9655858405090395, 0.13734406160036083, 0.14000910064904115, 0.1179465685334753, 0.17128818423150516, 0.14753140783142604, 0.13939988465733788, 0.13980630776140102, 0.15825920509967795, 0.13230744064374977, 0.18067059823738107, 0.1954083390790493, 0.1679201031520421, 0.18030523025459588, 0.19273298501186298, 0.20505494389576195, 0.19195555224621952, 0.15953713783861656, 0.17734582757079875, 0.06009081565894525, 0.053686948708584925, 0.07426842125812783, 0.0352490032727677, 0.05523387431302218, 0.05512510717583152, 0.05105222648290286, 0.06472312365434552, 0.0709109193123808, 0.061298004712187826, 0.06605043781394748, 0.06192762468492696, 0.09406455655302615, 0.04922751796791458, 0.10424454320724286, 0.11026961520190248, 0.010853456371674453, 0.0688002243596515, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0847027984197195, 0.07176788808041057, 0.08788891825057088, 0.02763778345624124, 0.03775690190827741, 0.0839091897764731, 0.06401854299436582, 0.073330120981142, 0.0790825338333272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02315279938700665, 0.019972798501619926, 0.014026295901857555, 0.02267507088974763, 0.014286053046554614, 0.01136092431361524, 0.01765164553919618, 0.02823253423070382, 0.031051244067988093, 0.2757005517913311, 0.2645037445798113, 0.2699850841708805, 0.23718357140181712, 0.2941741527395815, 0.2599044125759289, 0.31166076590899205, 0.2756204180300208, 0.27091316538066423, 0.07308780151787764, 0.06631583831049159, 0.07021247417173904, 0.07568006930211868, 0.06680789146609278, 0.0682386206944422, 0.06494874567711517, 0.06627151344668858, 0.07527555934910357, 0.1299729878563599, 0.15134299510099458, 0.1373242936110297, 0.14815615517752434, 0.2098241910540869, 0.15579207025855724, 0.1350325544566403, 0.17934497146480566, 0.12980000281888604, 0.20663377496211766, 0.21135689585497686, 0.20568568043382274, 0.2088554132439231, 0.19937161071450482, 0.19443665027634005, 0.20433498226144275, 0.23744104729555904, 0.20873334355429285, 0.15270994138385374, 0.13481592446299473, 0.14276157340664797, 0.13937713908617166, 0.15229751556231552, 0.14824686488129557, 0.14993203703227087, 0.15552805561070493, 0.14870630086175152, 0.18518758993766238, 0.1910742647191651, 0.19145773446490377, 0.19824111957138013, 0.18533684357098879, 0.1906354256362498, 0.19883728875495477, 0.17560026661769756, 0.18116866458641012, 0.17329186402311225, 0.1617255026398403, 0.17934581122380555, 0.18065509533772905, 0.17420333496523488, 0.17181720104805476, 0.1819656200472125, 0.17124985427591277, 0.16354569605383562, 0.33632555545915577, 0.1648747205449721, 0.1395335842179003, 0.27979268891373377, 0.17925256509209198, 0.20253942705234063, 0.2921769636680661, 0.17614188628675842, 0.2377738644755718, 0.26572160942775724, 0.1803677378711236, 0.31536755903916236, 0.2779116220405423, 0.21406377335560622, 0.1169625883916009, 0.240444144767466, 0.16869734154152138, 0.2578101551863964, 0.18951561009950346, 0.17215275874251257, 0.17489146830123514, 0.18111761390626913, 0.1929369472967275, 0.1772339813865288, 0.2123116012552655, 0.18571032233100349, 0.18548437863294642, 0.07052095984108286, 0.06995258627324819, 0.07105308308747704, 0.07496094690894828, 0.07455709508912645, 0.07534141147378437, 0.06980872166886798, 0.07117329642451153, 0.06862172363683972]}, "mutation_prompt": null}
{"id": "66a0d24e-9c61-46f6-8c84-25a2c69cc356", "solution": "import numpy as np\n\nclass EnhancedPSO_ADM_SAS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for higher diversity\n        self.inertia = 0.7  # Slightly higher inertia for robustness\n        self.c1 = 1.5  # Adjusted cognitive component\n        self.c2 = 1.5  # Balanced social component\n        self.mutation_factor = 0.85  # Fine-tuned mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate for recombination\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0  # Slightly adjusted velocity clamp\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Stochastic Adaptive Strategy for inertia\n            self.inertia = 0.5 + 0.4 * np.random.rand()\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation with Stochastic Strategy\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedPSO_ADM_SAS", "description": "A novel Particle Swarm Optimization with Adaptive Differential Mutation and Stochastic Adaptive Strategy for better exploration and convergence.", "configspace": "", "generation": 5, "fitness": 0.26115281689275516, "feedback": "The algorithm EnhancedPSO_ADM_SAS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "13350b2d-768c-4a22-8b38-a01d0a2ff76a", "metadata": {"aucs": [0.6950156394817572, 0.6537947924663067, 0.6216070870935455, 0.7109768103892957, 0.6660549725667286, 0.6286706908400672, 0.6467872737370033, 0.6308464496790667, 0.6566534315396453, 0.06105802518394088, 0.23920304956007954, 0.0342771891306527, 0.3141428393164222, 0.3106482936621665, 0.2648823241144328, 0.33789431259508174, 0.03953272262545948, 0.29469080337241116, 0.11195218557939057, 0.10895100848303685, 0.12033168288152685, 0.13467231415638548, 0.11201310666137865, 0.17596160212514766, 0.14120854855356268, 0.12610182430358674, 0.10389811489671519, 0.12699639375440364, 0.10621439409543276, 0.13040445918099175, 0.11568682912589479, 0.09149174860715337, 0.11539610283991264, 0.14093697284510487, 0.13187935017983332, 0.13778574265482424, 0.9757640825593822, 0.9648967542244967, 0.9752659199472065, 0.9592447523492094, 0.9730972817022883, 0.9765273705489296, 0.9689667529849006, 0.9692410977581958, 0.9691723185353414, 0.3703952346749988, 0.351629858645493, 0.3035273861489123, 0.3548451823444343, 0.1450480852089835, 0.30340513107155, 0.33204418135238745, 0.3406328445957131, 0.32694020330145124, 0.22064435833774187, 0.22546547050905963, 0.534943165145963, 0.20453059066627888, 0.3177811486827713, 0.197724191382317, 0.21330612977584873, 0.2797578299333031, 0.518534570632015, 0.15400618082074435, 0.11440658648069635, 0.14566236956369938, 0.09156336253699082, 0.16624766717604833, 0.14047186458733574, 0.16012325452640574, 0.12292929226616767, 0.16251686150844435, 0.11199380828895877, 0.17125063094709525, 0.12159686663380875, 0.21062694379158498, 0.10704566685441974, 0.21771576539763204, 0.1947069997620018, 0.1627706753453505, 0.17408050009194143, 0.004551809369921833, 0.02685780612029065, 0.009240521792002299, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031237393970277028, 9.999999999998899e-05, 0.02793546404741687, 0.09577316068107122, 0.06684529184472576, 0.11185235486599776, 0.061699306199467396, 0.014242674007770129, 0.039916721063412264, 0.050159664125622894, 0.13014823587534796, 0.07735651561833434, 0.02247431612133044, 9.999999999998899e-05, 0.04320161416304691, 0.14015735719084554, 0.05133333412765717, 0.07982536895058379, 0.07403826028468175, 0.05772706029589858, 0.02867288696948944, 0.08556000889352089, 0.08227605984511532, 0.08937663921512995, 0.16474302933270424, 0.10120834999997075, 0.11608112552088845, 0.07425351531945013, 0.046915448697714246, 0.07331856509827417, 0.471141127331031, 0.4896598679732569, 0.45338134591415047, 0.4823746098641568, 0.5184039069606324, 0.45842249984197025, 0.5100442249005792, 0.4430138671074837, 0.4757019265700132, 0.08707643992627068, 0.14390528756192977, 0.14552201567431078, 0.11697885595955448, 0.1134711875467086, 0.10154088798046801, 0.1240773217043738, 0.14053177146830453, 0.1272383689402895, 0.2126084179797879, 0.3106639565796949, 0.18056504075240665, 0.17779575691859806, 0.27492902658635043, 0.2778032056616364, 0.18033902394023804, 0.19687734100398147, 0.16664755181374857, 0.35044439021064544, 0.29983632558738105, 0.33384221459747465, 0.24205293265724848, 0.35139178787444425, 0.3165462674363658, 0.33442984045175694, 0.39543734086846194, 0.34537941154070273, 0.2292240700157646, 0.26217825475782486, 0.2447563328941087, 0.22820806120257042, 0.24198284226899003, 0.2135332235015156, 0.20923328384581996, 0.2570283534716167, 0.20131509525476543, 0.1934117749219666, 0.20329794672005697, 0.1853324857955274, 0.2181775615371654, 0.22341944919898304, 0.2227217074104606, 0.20957341328841073, 0.1994376792873711, 0.196100208160648, 0.20592768138663142, 0.3167609645700944, 0.2010212214726963, 0.19997627876572244, 0.1907814692806432, 0.188187840399215, 0.19723852050948554, 0.1997896980639472, 0.22765430525766617, 0.8172786507841487, 0.1808223266990956, 0.6982245280072563, 0.7493924386527575, 0.19746635953216418, 0.751432924563424, 0.6842639823383578, 0.6893785446485727, 0.8067717504354798, 0.4108937645874077, 0.20965706135538598, 0.4072334410975097, 0.55357202782985, 0.46203072506046106, 0.1518245214255397, 0.2080078663196261, 0.1042698573377514, 0.552658887105576, 0.18293576625454977, 0.19846080785244702, 0.18214614169722187, 0.1880208959964741, 0.18177920135481473, 0.1827404966239412, 0.18170816910069965, 0.18901872020472832, 0.19723596677706623, 0.08669360794761738, 0.09159768533086554, 0.09814772899936797, 0.07951969545953541, 0.08576125187479267, 0.08467443047939383, 0.09580597979379546, 0.07968535849982694, 0.07851933496998265]}, "mutation_prompt": null}
{"id": "ae3dec6a-0e81-4635-8d4f-4ec393a3be69", "solution": "import numpy as np\n\nclass SynergisticPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for greater diversity\n        self.inertia = 0.7  # Improved inertia for better exploration\n        self.c1 = 1.5  # Adjusted cognitive component\n        self.c2 = 1.5  # Adjusted social component for balance\n        self.mutation_factor = 0.8  # Fine-tuned mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate for more trials\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0  # Slightly higher clamping for broader search\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Dynamic adjustment of inertia\n            self.inertia = 0.4 + 0.3 * (self.budget - eval_count) / self.budget\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Synergistic Differential Evolution\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "SynergisticPSO_DE", "description": "A synergistic Particle Swarm Optimization employing Differential Evolution with adaptive learning and dynamic swarm behavior for enhanced optimization performance.", "configspace": "", "generation": 6, "fitness": 0.28348097267739625, "feedback": "The algorithm SynergisticPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "13350b2d-768c-4a22-8b38-a01d0a2ff76a", "metadata": {"aucs": [0.7231819694416974, 0.7152781237110861, 0.7546739440544792, 0.7255672476276256, 0.7410589720155418, 0.7432244528272457, 0.7062250968263379, 0.7359593701929297, 0.73270787377914, 0.49555041999279104, 0.4637014711007277, 0.40311372052495176, 0.4104860338431574, 0.4384494914087843, 0.37211801266350886, 0.346146319775799, 0.04277251340322841, 0.47642037575911267, 0.1304040698416009, 0.1284719386010924, 0.14488856136127815, 0.4638289961584624, 0.12583279980594686, 0.11943703951291462, 0.15253995288782285, 0.1551503093769403, 0.13493400049596016, 0.14730194164365806, 0.13141447523336136, 0.10143404173651527, 0.11764645423242359, 0.13274236529840822, 0.1303695589990761, 0.08797132338131175, 0.13735692339610572, 0.15747797899275373, 0.9767372471780457, 0.9681326354885972, 0.9775746951755659, 0.9675749096518497, 0.9699907435183396, 0.9763420657816356, 0.9700063174592879, 0.962735693010371, 0.9665604219117799, 0.48352899886554346, 0.46966862184457914, 0.44376140063270564, 0.4513848739927159, 0.4223318782108615, 0.43778581727299926, 0.08714411495270358, 0.44539731824263096, 0.44710925163659754, 0.2142724694547572, 0.6012910591432608, 0.2241441499438369, 0.20635283604297572, 0.1922873378262222, 0.20003136941165856, 0.504598314984463, 0.22104562418225226, 0.6376022868980364, 0.18183475338639132, 0.09193044982824483, 0.17322794327854807, 0.11736426470934425, 0.20093008173362037, 0.18409456093350796, 0.1222154319429345, 0.1778920849757698, 0.17304970298390943, 0.12152014764416641, 0.19455516822717045, 0.17722531175105327, 0.3671775283063796, 0.11735798381421358, 0.12948420001920002, 0.2094196174875641, 0.20844580429342452, 0.21462169649040297, 0.0255151159112027, 0.03746110968207217, 0.0004693307761939325, 0.04072242505236923, 9.999999999998899e-05, 9.999999999998899e-05, 0.001271507118740356, 9.999999999998899e-05, 9.999999999998899e-05, 0.1130771412577195, 0.09245344627660701, 0.0986855000371506, 0.13085304029566125, 0.022040960847114155, 0.052453940982540526, 0.06426291851038712, 0.12490855884904029, 0.08613633481094496, 0.1671056177476008, 9.999999999998899e-05, 0.09219118227572631, 0.16249181613151764, 0.054218538716126696, 0.0857885621539013, 0.0755063674898605, 0.07604763463712805, 0.12007513402278314, 0.12471092794974303, 0.12850887457324878, 0.23013306984362036, 0.10647112052659291, 0.08744615821523072, 0.14420520026943873, 0.19558395273902496, 0.1064689876921604, 0.07434323649017083, 0.48537748774253864, 0.5115901689888002, 0.4696137041358478, 0.49022598159687725, 0.5077054687795417, 0.20733135952384418, 0.5156274148166502, 0.4962179488852123, 0.5107853009369442, 0.07653869081689879, 0.1321779162090364, 0.12129489149618544, 0.3650592285423361, 0.15141796625710235, 0.11565682903402008, 0.14733474283177217, 0.10674302005175162, 0.10456490880007241, 0.1443817135367339, 0.2518215763214273, 0.2228927473292217, 0.24116046656029289, 0.3355606006270244, 0.2658526316764881, 0.34558086929757226, 0.24217648674727132, 0.1728694201876042, 0.3157982358643513, 0.40303231701057174, 0.34161011277513786, 0.39571261291050563, 0.4047064081439179, 0.41627484846668295, 0.4054944562802264, 0.4329095463605278, 0.3806404525076509, 0.1689945505095033, 0.18592699409340263, 0.24990326662053064, 0.14378419764542338, 0.23796871331762848, 0.2583993086098735, 0.2325885893437386, 0.29301767772055376, 0.2814042033832903, 0.225117074233268, 0.20996561548334525, 0.20439760672035823, 0.21822344791255555, 0.22912584549515946, 0.21787475550213653, 0.24905892377605077, 0.19414917173891866, 0.2126591362870759, 0.19307411517799478, 0.19982474128018468, 0.2147615472802813, 0.2209801426445469, 0.3769749450352424, 0.19296436188125476, 0.19948644380538882, 0.21014562360928568, 0.1997427987746766, 0.7986149153852793, 0.18307388768938038, 0.12404124400791372, 0.8044484449311383, 0.19971713175749295, 0.19703332317967237, 0.17434397025901638, 0.16465006217092126, 0.7942539237849641, 0.669776391624215, 0.20828567546109666, 0.5882713854378139, 0.5637481904424405, 0.21983697636168675, 0.15334527247652985, 0.19743810834074638, 0.5906343316633257, 0.585885275517086, 0.19458808747615453, 0.1870967801154373, 0.18119926428936628, 0.19321370095946744, 0.19863458001193257, 0.18987149995159414, 0.20090447760664387, 0.19280968212923766, 0.20629032018776305, 0.0857404114834509, 0.0739986744245178, 0.09058678045471147, 0.08883152751957046, 0.099450026712679, 0.08352394961209486, 0.08045957653514202, 0.0877171347532183, 0.08963774736807195]}, "mutation_prompt": null}
{"id": "c0d5fd0b-e0de-4b8c-9160-0f183c782572", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSO_ALF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for better exploration\n        self.inertia = 0.5  # Base inertia for energy conservation\n        self.c1 = 1.8  # Slightly higher cognitive component for stronger personal learning\n        self.c2 = 1.5  # Balanced social component\n        self.mutation_factor = 0.8  # Slightly modified mutation factor\n        self.crossover_rate = 0.9  # Higher crossover rate for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0  # Increased clamping range\n        self.num_swarms = 3  # Number of sub-swarms\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_swarms, self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_swarms, self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full((self.num_swarms, self.pop_size), float('inf'))\n        global_best = np.full((self.num_swarms, self.dim), float('inf'))\n        global_best_fitness = np.full(self.num_swarms, float('inf'))\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for s in range(self.num_swarms):\n                for i in range(self.pop_size):\n                    fitness = func(particles[s, i])\n                    eval_count += 1\n\n                    if fitness < personal_best_fitness[s, i]:\n                        personal_best_fitness[s, i] = fitness\n                        personal_best[s, i] = particles[s, i].copy()\n\n                    if fitness < global_best_fitness[s]:\n                        global_best_fitness[s] = fitness\n                        global_best[s] = particles[s, i].copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n                if eval_count >= self.budget:\n                    break\n\n            # Update velocities and positions\n            for s in range(self.num_swarms):\n                r1 = np.random.rand(self.pop_size, self.dim)\n                r2 = np.random.rand(self.pop_size, self.dim)\n\n                # Dynamic adjustment of inertia using a non-linear formula\n                self.inertia = 0.4 + 0.3 * np.exp(-3 * eval_count / self.budget)\n\n                velocities[s] = (self.inertia * velocities[s] +\n                                 self.c1 * r1 * (personal_best[s] - particles[s]) +\n                                 self.c2 * r2 * (global_best[s] - particles[s]))\n                velocities[s] = np.clip(velocities[s], -self.velocity_clamp, self.velocity_clamp)\n\n                particles[s] += velocities[s]\n                particles[s] = np.clip(particles[s], self.lower_bound, self.upper_bound)\n\n                # Apply Adaptive Differential Mutation with Lévy Flights\n                for i in range(self.pop_size):\n                    if np.random.rand() < self.crossover_rate:\n                        idxs = [idx for idx in range(self.pop_size) if idx != i]\n                        a, b, c = np.random.choice(idxs, 3, replace=False)\n                        alpha = 0.01\n                        u = np.random.normal(0, 1, self.dim)\n                        v = np.random.normal(0, 1, self.dim)\n                        levy_flight = alpha * u / (np.abs(v) ** (1 / 3))\n\n                        mutant_vector = (particles[s, a] +\n                                         self.mutation_factor * (particles[s, b] - particles[s, c]) + levy_flight)\n                        mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                        trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                                mutant_vector, particles[s, i])\n\n                        trial_fitness = func(trial_vector)\n                        eval_count += 1\n\n                        if trial_fitness < personal_best_fitness[s, i]:\n                            personal_best_fitness[s, i] = trial_fitness\n                            personal_best[s, i] = trial_vector.copy()\n\n                        if trial_fitness < global_best_fitness[s]:\n                            global_best_fitness[s] = trial_fitness\n                            global_best[s] = trial_vector.copy()\n\n                        if eval_count >= self.budget:\n                            break\n\n        best_swarm = np.argmin(global_best_fitness)\n        return global_best[best_swarm]", "name": "DynamicMultiSwarmPSO_ALF", "description": "A Dynamic Multi-Swarm PSO with Adaptive Lévy Flights for enhanced exploration and convergence rates.", "configspace": "", "generation": 7, "fitness": 0.2183669202136491, "feedback": "The algorithm DynamicMultiSwarmPSO_ALF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "13350b2d-768c-4a22-8b38-a01d0a2ff76a", "metadata": {"aucs": [0.4529158716605337, 0.4520794581167755, 0.45608017242527155, 0.4649499039197875, 0.47014206751517607, 0.45737869821033006, 0.4421110467866324, 0.4566375259538864, 0.4667380605810656, 0.07315179687372697, 0.09770651970877842, 0.06942957926815307, 0.08864280769586674, 0.09059663718537592, 0.09089928125119118, 0.0826722590202944, 0.10067886103520562, 0.08789552859234451, 0.09893103540255577, 0.09172296375516709, 0.11184875706357156, 0.09923782579335239, 0.11595906222695196, 0.0986894736067665, 0.10195911908574795, 0.10307411880488293, 0.09354421938745272, 0.09037158432464343, 0.08597650039135041, 0.11045937484507085, 0.10053626600306198, 0.08947592756920075, 0.10699089941903572, 0.09575210638125331, 0.088127313100541, 0.08348626277878013, 0.9494023599112528, 0.9394739114092036, 0.9224059959047988, 0.9167903409840504, 0.9276808306576354, 0.9142462996907135, 0.9276968945125899, 0.9265033588888009, 0.9232597196352504, 0.22451828524438933, 0.2308937611612989, 0.24157971771982145, 0.24436171531753403, 0.22349074902119026, 0.22342766431027028, 0.2191379207868388, 0.2067153026987537, 0.2406524633859627, 0.359102005455182, 0.26179907171303995, 0.26428635762412234, 0.2799214423840549, 0.20508531848899625, 0.4416713195233348, 0.27073708030933974, 0.2668091222802248, 0.21757255743879533, 0.12655297314942238, 0.13092756927904392, 0.1951824451347629, 0.15806185460522193, 0.13400079922661845, 0.12247034313905913, 0.1604392977296295, 0.12439096935349658, 0.12262543061166764, 0.13618110443648968, 0.13591750386227008, 0.14952991857711873, 0.120600376404849, 0.14516241876443947, 0.15461872883514538, 0.1332362282814764, 0.1484085311565777, 0.10791819718335594, 0.003244768678657084, 9.999999999998899e-05, 0.00410779947686335, 0.0079575547762335, 0.0045824852178860676, 9.999999999998899e-05, 0.008161538508501875, 0.003189017417293827, 0.014746459687331348, 0.08290741073998198, 0.07067997630742306, 0.08546962565619942, 0.021411123487904637, 0.12800834933734273, 0.029091422649608067, 0.05317598765723108, 0.06400983173535335, 0.06978275317399762, 0.013342647048583456, 0.02008881737084356, 0.018244740190966335, 0.026891313389482807, 0.02141073671726157, 0.033465563451334335, 0.030861531835927547, 0.021049444331047384, 0.038709143942084356, 0.0900538962016113, 0.0978110217472482, 0.09825399543366131, 0.08230563380189126, 0.07602293274020322, 0.07706913351392908, 0.09373680675247165, 0.043201434204482414, 0.060179720680363924, 0.38720942398934244, 0.37850688069226524, 0.38109001042278046, 0.3814747479392435, 0.3724563986030298, 0.39292322908094124, 0.3933555231939858, 0.39045149440359006, 0.3900205521018827, 0.08894977465691989, 0.10398355073344479, 0.10416711340732032, 0.10687882768724499, 0.09765200481175618, 0.0924749353877018, 0.0890089073584519, 0.08888004542815675, 0.11933048201780361, 0.14315264360208968, 0.21827682540037263, 0.2189695311471157, 0.1895495291677891, 0.2076020334904075, 0.20952038492045655, 0.16303888053538573, 0.1723557842194614, 0.16567027702469828, 0.28301752903121213, 0.26503853487906703, 0.252250620924369, 0.28145318126246344, 0.2640437466588963, 0.26884104120455155, 0.27150135650294605, 0.2845985019121604, 0.28813641244933375, 0.2192258256727676, 0.20309455959323286, 0.1985300435755657, 0.1700533047343772, 0.21275164313081796, 0.20750129438366893, 0.19375199533349685, 0.20190752516838784, 0.2012062316341522, 0.1990754877447264, 0.19957146258594383, 0.22316579726622265, 0.18870269114280458, 0.20674917425841466, 0.20467794904271952, 0.19461783940315736, 0.18703486653001422, 0.20287458863685903, 0.18525764069084893, 0.20013681936138483, 0.20318063689508115, 0.19202038760028017, 0.2131192332095816, 0.2610614983884487, 0.19204142499406485, 0.18669412647677042, 0.1925100820283585, 0.5380456299631664, 0.5225292456276923, 0.5763854690525096, 0.5718365095716179, 0.1879580226090488, 0.4840840088513607, 0.4651191482645952, 0.1714370766020229, 0.6148437356959844, 0.36038322638530484, 0.411828951171725, 0.36785116297603904, 0.40335528567228207, 0.38499581341975764, 0.16191037538457853, 0.19901218367278906, 0.3261964165631486, 0.30525688699174147, 0.18714879789582162, 0.1897174689920148, 0.1830013538400861, 0.19147934012416135, 0.18851146742949365, 0.18309865803007852, 0.18605549413189337, 0.19644138722317572, 0.20706894502829387, 0.0784085529285441, 0.07927567373768907, 0.0836008990402819, 0.07444821179663774, 0.08166122877788262, 0.07576268051128576, 0.08908726570732928, 0.07513711316124405, 0.08225647379706147]}, "mutation_prompt": null}
{"id": "fede4fd9-1d06-4998-8c69-86b9a082f2f3", "solution": "import numpy as np\n\nclass EnhancedPSO_ADM_GP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Increased population for diversity\n        self.inertia = 0.7  # Adjusted inertia for exploration\n        self.c1 = 1.5  # Fine-tuned cognitive component\n        self.c2 = 1.5  # Equal social component for balanced influence\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0  # Increased velocity clamp\n        self.perturbation_strength = 0.05  # Added Gaussian perturbation strength\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Dynamic adjustment of inertia\n            self.inertia = 0.5 + 0.2 * (self.budget - eval_count) / self.budget\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation with Gaussian Perturbation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n                    # Apply Gaussian perturbation for additional exploration\n                    trial_vector += self.perturbation_strength * np.random.normal(0, 1, self.dim)\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedPSO_ADM_GP", "description": "A Particle Swarm Optimization enhanced with Adaptive Differential Mutation and Gaussian Perturbation for improved exploration and exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.29212046164556704, "feedback": "The algorithm EnhancedPSO_ADM_GP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "13350b2d-768c-4a22-8b38-a01d0a2ff76a", "metadata": {"aucs": [0.7652131806066265, 0.7119988123066231, 0.7669386807768309, 0.7546757323151969, 0.745297316331352, 0.7814706387726917, 0.7605143906118349, 0.7555897009111617, 0.7623617979168158, 0.468553052024414, 0.40502435845332274, 0.4801972829298541, 0.393026246829253, 0.2565303851420012, 0.4762229662028563, 0.47698974880204625, 0.47065528081101293, 0.4986971958233387, 0.14786040160452796, 0.1257928434421539, 0.13640953335686812, 0.15298063232244907, 0.15623227692623964, 0.13182944946622988, 0.1547550639158347, 0.13652402243103168, 0.1335649231202375, 0.13432721484333376, 0.11582900640519134, 0.10257349173261354, 0.12233110911501865, 0.1400889438785996, 0.11242739429835424, 0.1276145289888313, 0.1527180719394411, 0.11983528867973559, 0.9731518193057843, 0.9797536857331233, 0.9730921802792649, 0.9672345653717122, 0.9673152711092822, 0.9665256298717461, 0.9793119720539847, 0.9759026547207642, 0.9727254230566214, 0.4621158676266064, 0.53519593461047, 0.4845997502545373, 0.44286266969568056, 0.41297720944306615, 0.45931654892556395, 0.3608535253941487, 0.47213692551115183, 0.4505684229368263, 0.3615760427526097, 0.21554067612897543, 0.17238007887314266, 0.7639716551248557, 0.43577038046024685, 0.19057827071502398, 0.6849867717698249, 0.22973609676632756, 0.7779702635923944, 0.22815525161894035, 0.10802091966080174, 0.18554934507153553, 0.17793668716151112, 0.18070685006271836, 0.18463084814962405, 0.1739901876883223, 0.10780962772956826, 0.18712327113512806, 0.19442618848676607, 0.18331878190289574, 0.1963047191290811, 0.1970916631710249, 0.12580235907625303, 0.19686279604571066, 0.22521484303046224, 0.12961563893881578, 0.3029379699221869, 0.012997301291871377, 0.039536092644052556, 9.999999999998899e-05, 0.04424649999947472, 0.003814568408934571, 9.999999999998899e-05, 0.007809645789208841, 0.024519569295400112, 9.999999999998899e-05, 0.16061288521493766, 0.06451428824311556, 0.12819140108986904, 0.080775317356515, 0.01466567160623966, 0.0569624453347205, 0.06717379515322353, 0.10944859090182923, 0.11662642655223354, 0.04393090376755804, 0.027794936903402068, 0.04012364375121036, 0.21347920249480645, 0.07155832167115928, 0.19894571022624763, 0.06701087983198317, 0.08196954433688497, 0.08312546257858744, 0.2863855500817658, 0.1704338241167217, 0.10300074091693345, 0.10031194086267792, 0.08275681298568638, 0.11115312586237291, 0.05614246376486931, 0.07606399550235476, 0.3056384376845157, 0.47866696446888113, 0.48389433015349037, 0.5078695181338012, 0.4808280781706674, 0.5111091970941148, 0.5171018848963802, 0.5078628245266189, 0.514566011229608, 0.4822417260529981, 0.1387867023836783, 0.10247726513348265, 0.11790820002061886, 0.12314862886463451, 0.09762052561976176, 0.14510871889822663, 0.08299067283255912, 0.12685730940965456, 0.11365944840132347, 0.18471857822832005, 0.16067405627293696, 0.17757728672936823, 0.3296117698606177, 0.33819259489068787, 0.24430545222439104, 0.2971694509772672, 0.20358472014900253, 0.21574766169657178, 0.3840186050788844, 0.35156571958357363, 0.4197862629080925, 0.34752659969239896, 0.3625721243244864, 0.35923785841275235, 0.37593136813375927, 0.37593979222321927, 0.3233957772605587, 0.22695178086672307, 0.30508070958427447, 0.19733816199747622, 0.2787594236652893, 0.2960332680587511, 0.3025064253577461, 0.22319020984470728, 0.2487140449412133, 0.32744396159283673, 0.26030852853010433, 0.1944670900686869, 0.20356612372531235, 0.212594600026083, 0.2053867641386451, 0.18262412626743807, 0.21430378466225097, 0.25582820193816225, 0.21083624110160715, 0.2058549475778776, 0.2108110234062025, 0.19316118180211983, 0.2138427358017655, 0.21690246898802412, 0.19256983850607146, 0.21263718840845813, 0.21932692867720371, 0.48759476132882507, 0.7925647878003189, 0.19585351483850832, 0.1459891474691538, 0.8321044059964227, 0.1996766116832639, 0.19902395317291233, 0.1411550244457227, 0.1693774818052901, 0.8112957589237485, 0.6153768444543378, 0.20940655355156146, 0.6777617448258939, 0.6440024719582715, 0.582678727571456, 0.16761834418080102, 0.10447946374896788, 0.20770284025321617, 0.21061318462609202, 0.18525079627982088, 0.20106601979455974, 0.19345170589228433, 0.2002924990406958, 0.1919878105038263, 0.17935294854618422, 0.20012108487707048, 0.20623113831204676, 0.19304507956746597, 0.11903488905342441, 0.09348104148163383, 0.09010519618169965, 0.08541029822511426, 0.0890044225725154, 0.08793359572562842, 0.08610257680458033, 0.09038980773650762, 0.07687053741986927]}, "mutation_prompt": null}
{"id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for better sampling\n        self.inertia = 0.5  # Balanced inertia for stability and exploration\n        self.c1 = 1.5  # Balanced cognitive component\n        self.c2 = 1.5  # Balanced social component\n        self.mutation_factor = 0.8  # Optimized mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Adaptive clamping for more refined movement\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Adaptive velocity clamping\n            self.velocity_clamp = 2.0 + 1.5 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_ADM", "description": "A hybrid Particle Swarm Optimization with Adaptive Differential Mutation enhanced by adaptive velocity clamping and dynamic cognitive-social balance for robust optimization across diverse problem landscapes.", "configspace": "", "generation": 9, "fitness": 0.33382796728577524, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "13350b2d-768c-4a22-8b38-a01d0a2ff76a", "metadata": {"aucs": [0.8047981201520592, 0.8014145459407386, 0.8299822505700143, 0.8147397642257295, 0.8080713883878474, 0.8185630766156693, 0.8088670323968696, 0.7969960299533266, 0.8088256363249179, 0.5700790984944647, 0.5855977260816425, 0.6092443950973077, 0.5686531625103705, 0.5581668762793364, 0.5983185372471601, 0.5341746363633624, 0.588826309606014, 0.5574984582414154, 0.13542116366434442, 0.16427541440716253, 0.1455399559178131, 0.6056400650890901, 0.1295641678976328, 0.14565244399182975, 0.1646738615115746, 0.11462153815499809, 0.14412620262326747, 0.1359769833230694, 0.11354369073322301, 0.13210743652791512, 0.13304089339089153, 0.14967784754171554, 0.1094798973832769, 0.13702411630031586, 0.13364130065247104, 0.11714906615969745, 0.9538781383866126, 0.9418240794845424, 0.9612176475847485, 0.9500374649818878, 0.9590153775696233, 0.9453486791045913, 0.9451934145836913, 0.9423243977387716, 0.943932240857037, 0.6244000308883718, 0.5961565277600653, 0.5784080577309823, 0.6248266877647781, 0.5651097619983909, 0.45265038013819625, 0.6038752795943589, 0.6006749185156577, 0.5563271161106801, 0.8594059682957624, 0.8629346235825937, 0.22428884783354086, 0.22025971504373443, 0.6999860440701888, 0.8149100796525293, 0.5469149601018534, 0.34667801568774315, 0.6585957312928638, 0.2179717369654075, 0.11701551359862483, 0.19997265354569493, 0.19199357052448218, 0.13051230705717476, 0.27754488756528617, 0.21598793671054484, 0.19851419049563124, 0.1300009527975703, 0.24024545971485312, 0.21165462462709583, 0.21308791764669655, 0.2110213397237285, 0.2656144556645821, 0.23127655496088295, 0.3424159983457754, 0.23178653969418683, 0.24889812042661674, 9.999999999998899e-05, 0.007918843490078542, 9.999999999998899e-05, 0.03368861656850586, 0.011335916125243761, 0.06650292507872291, 0.000688562816995586, 0.12355986251605866, 0.052723648837519455, 0.0973924984247242, 0.05448783192051865, 0.09159628873038095, 0.06797823388870583, 0.04800337355329809, 0.05592165680366057, 0.0816177795635622, 0.11690987100532568, 0.13200353704344758, 0.2549676322429517, 0.2723709148265929, 0.1372637817855773, 0.10683398441194858, 0.08486561028424944, 0.11869805117170218, 0.08822728709789429, 0.17239605330550944, 0.08658524779370491, 0.14958724781008514, 0.09982640090314687, 0.12687698322473429, 0.10380065004745687, 0.12730556475430732, 0.0777636496167533, 0.14488044073514028, 0.09806815999443208, 0.08116007167714745, 0.5376424798768304, 0.654415012111722, 0.528534000578559, 0.5605188613668475, 0.5292786694763882, 0.5173497966775336, 0.5732315506902212, 0.5630242436917063, 0.5569553281285944, 0.12612808319112156, 0.07585533291159807, 0.12312328344949197, 0.13579526257173746, 0.15105198257106311, 0.14570018090005565, 0.0981904874834183, 0.14029308288760844, 0.11222215874415964, 0.3131718209283678, 0.2337400681893882, 0.2208150094182567, 0.48213576263346547, 0.2558344814638782, 0.190098955285523, 0.41467317156755856, 0.19605613231935037, 0.17594713946007834, 0.3532757918756333, 0.34374633173384794, 0.36941880415187545, 0.3651978114375658, 0.40628924469951455, 0.36513918994324424, 0.5369111147088341, 0.4822192671535841, 0.34035892384661826, 0.2536616132900328, 0.23383049770664943, 0.27323677087188214, 0.31961937870285007, 0.2946648249155116, 0.2665097025966273, 0.2640123289773343, 0.38785140698255005, 0.22245157753699818, 0.2378900559340439, 0.22470350145066498, 0.20924148644335905, 0.21302447224539078, 0.23000413169296197, 0.22505121831436203, 0.23928233218741557, 0.2201147909215927, 0.24944127248925574, 0.20763701718708172, 0.21639062213945348, 0.21699779120936735, 0.1922538209278637, 0.2458044097791945, 0.21899628655067205, 0.21502367107434772, 0.19055885791332217, 0.18358023374864574, 0.889773636440326, 0.18575332476676587, 0.17101045593100794, 0.9032816350358387, 0.20001667953952873, 0.19988534254779355, 0.1417726521817978, 0.8340501767999757, 0.8768338665119172, 0.7831280405437034, 0.21195248792487742, 0.6279185012494218, 0.6982399889430523, 0.630921874182154, 0.16773431653374882, 0.15437177931597235, 0.7757173997878739, 0.8037784931139148, 0.19506141244694308, 0.20423022946124425, 0.1913837879944883, 0.19817127357590436, 0.18111660260929363, 0.19852827575664278, 0.1896349190984451, 0.18126539170469969, 0.21400093242320262, 0.09710084653249618, 0.09120506651668514, 0.10554594731538669, 0.08932602205647489, 0.10902688068273636, 0.09412713634354986, 0.11055765287472408, 0.08826229508461836, 0.08331350375833624]}, "mutation_prompt": null}
{"id": "9cbf355d-eb5f-473a-81b4-e603c0f0a309", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for better sampling\n        self.inertia = 0.5  # Balanced inertia for stability and exploration\n        self.c1 = 1.5  # Balanced cognitive component\n        self.c2 = 1.5  # Balanced social component\n        self.mutation_factor = 0.8  # Optimized mutation factor for diversity\n        self.crossover_rate = 0.9  # Increased crossover rate for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Adaptive clamping for more refined movement\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Adaptive velocity clamping\n            self.velocity_clamp = 2.0 + 1.5 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_ADM", "description": "A hybrid Particle Swarm Optimization with Adaptive Differential Mutation enhanced by adaptive velocity clamping and dynamic cognitive-social balance for robust optimization across diverse problem landscapes.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.8047981201520592, 0.8014145459407386, 0.8299822505700143, 0.8147397642257295, 0.8080713883878474, 0.8185630766156693, 0.8088670323968696, 0.7969960299533266, 0.8088256363249179, 0.5700790984944647, 0.5855977260816425, 0.6092443950973077, 0.5686531625103705, 0.5581668762793364, 0.5983185372471601, 0.5341746363633624, 0.588826309606014, 0.5574984582414154, 0.13542116366434442, 0.16427541440716253, 0.1455399559178131, 0.6056400650890901, 0.1295641678976328, 0.14565244399182975, 0.1646738615115746, 0.11462153815499809, 0.14412620262326747, 0.1359769833230694, 0.11354369073322301, 0.13210743652791512, 0.13304089339089153, 0.14967784754171554, 0.1094798973832769, 0.13702411630031586, 0.13364130065247104, 0.11714906615969745, 0.9538781383866126, 0.9418240794845424, 0.9612176475847485, 0.9500374649818878, 0.9590153775696233, 0.9453486791045913, 0.9451934145836913, 0.9423243977387716, 0.943932240857037, 0.6244000308883718, 0.5961565277600653, 0.5784080577309823, 0.6248266877647781, 0.5651097619983909, 0.45265038013819625, 0.6038752795943589, 0.6006749185156577, 0.5563271161106801, 0.8594059682957624, 0.8629346235825937, 0.22428884783354086, 0.22025971504373443, 0.6999860440701888, 0.8149100796525293, 0.5469149601018534, 0.34667801568774315, 0.6585957312928638, 0.2179717369654075, 0.11701551359862483, 0.19997265354569493, 0.19199357052448218, 0.13051230705717476, 0.27754488756528617, 0.21598793671054484, 0.19851419049563124, 0.1300009527975703, 0.24024545971485312, 0.21165462462709583, 0.21308791764669655, 0.2110213397237285, 0.2656144556645821, 0.23127655496088295, 0.3424159983457754, 0.23178653969418683, 0.24889812042661674, 9.999999999998899e-05, 0.007918843490078542, 9.999999999998899e-05, 0.03368861656850586, 0.011335916125243761, 0.06650292507872291, 0.000688562816995586, 0.12355986251605866, 0.052723648837519455, 0.0973924984247242, 0.05448783192051865, 0.09159628873038095, 0.06797823388870583, 0.04800337355329809, 0.05592165680366057, 0.0816177795635622, 0.11690987100532568, 0.13200353704344758, 0.2549676322429517, 0.2723709148265929, 0.1372637817855773, 0.10683398441194858, 0.08486561028424944, 0.11869805117170218, 0.08822728709789429, 0.17239605330550944, 0.08658524779370491, 0.14958724781008514, 0.09982640090314687, 0.12687698322473429, 0.10380065004745687, 0.12730556475430732, 0.0777636496167533, 0.14488044073514028, 0.09806815999443208, 0.08116007167714745, 0.5376424798768304, 0.654415012111722, 0.528534000578559, 0.5605188613668475, 0.5292786694763882, 0.5173497966775336, 0.5732315506902212, 0.5630242436917063, 0.5569553281285944, 0.12612808319112156, 0.07585533291159807, 0.12312328344949197, 0.13579526257173746, 0.15105198257106311, 0.14570018090005565, 0.0981904874834183, 0.14029308288760844, 0.11222215874415964, 0.3131718209283678, 0.2337400681893882, 0.2208150094182567, 0.48213576263346547, 0.2558344814638782, 0.190098955285523, 0.41467317156755856, 0.19605613231935037, 0.17594713946007834, 0.3532757918756333, 0.34374633173384794, 0.36941880415187545, 0.3651978114375658, 0.40628924469951455, 0.36513918994324424, 0.5369111147088341, 0.4822192671535841, 0.34035892384661826, 0.2536616132900328, 0.23383049770664943, 0.27323677087188214, 0.31961937870285007, 0.2946648249155116, 0.2665097025966273, 0.2640123289773343, 0.38785140698255005, 0.22245157753699818, 0.2378900559340439, 0.22470350145066498, 0.20924148644335905, 0.21302447224539078, 0.23000413169296197, 0.22505121831436203, 0.23928233218741557, 0.2201147909215927, 0.24944127248925574, 0.20763701718708172, 0.21639062213945348, 0.21699779120936735, 0.1922538209278637, 0.2458044097791945, 0.21899628655067205, 0.21502367107434772, 0.19055885791332217, 0.18358023374864574, 0.889773636440326, 0.18575332476676587, 0.17101045593100794, 0.9032816350358387, 0.20001667953952873, 0.19988534254779355, 0.1417726521817978, 0.8340501767999757, 0.8768338665119172, 0.7831280405437034, 0.21195248792487742, 0.6279185012494218, 0.6982399889430523, 0.630921874182154, 0.16773431653374882, 0.15437177931597235, 0.7757173997878739, 0.8037784931139148, 0.19506141244694308, 0.20423022946124425, 0.1913837879944883, 0.19817127357590436, 0.18111660260929363, 0.19852827575664278, 0.1896349190984451, 0.18126539170469969, 0.21400093242320262, 0.09710084653249618, 0.09120506651668514, 0.10554594731538669, 0.08932602205647489, 0.10902688068273636, 0.09412713634354986, 0.11055765287472408, 0.08826229508461836, 0.08331350375833624]}, "mutation_prompt": null}
{"id": "cd4789a8-b0cf-48ab-89a3-f76bff7d1c0b", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for better exploration\n        self.inertia = 0.7  # Dynamic inertia for improved exploration-exploitation balance\n        self.c1 = 1.4  # Slightly reduced cognitive component\n        self.c2 = 1.7  # Slightly increased social component for better convergence\n        self.mutation_factor = 0.85  # Slightly increased mutation factor for diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0  # Wider clamping range for dynamic adjustment\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Dynamic inertia update\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedHybridPSO_ADM", "description": "An enhanced Hybrid Particle Swarm Optimization utilizing Dynamic Inertia Adjustment and Adaptive Differential Mutation for superior exploration and convergence.", "configspace": "", "generation": 11, "fitness": 0.22590908259217102, "feedback": "The algorithm EnhancedHybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.5528011507751116, 0.5253459530160911, 0.5393716600453036, 0.5656715617347755, 0.5585536841278803, 0.5345983843321946, 0.5634761361203173, 0.5614418213082324, 0.5234809621284816, 0.18858726206362153, 0.18395473212939362, 0.12403696269572351, 0.23148954157110457, 0.19275948935196685, 0.03959642898662186, 0.031634867108215836, 0.156795894380808, 0.17716824320650137, 0.13126282449156512, 0.1260596504709245, 0.11947833248160711, 0.08178998397931903, 0.1277370763982001, 0.12696977325003722, 0.10685180211537604, 0.11150616526749668, 0.1059114653705614, 0.10276437118599335, 0.09817685307874435, 0.11991011620828762, 0.09655552484510388, 0.1244251984253637, 0.10679741140284726, 0.1060296716479685, 0.11784745201451441, 0.12129198555401566, 0.9655833905428595, 0.9739000980619483, 0.9681326850499177, 0.9641389168434332, 0.9647335230018805, 0.959696638694148, 0.9686566611203038, 0.9740099479861714, 0.956454587573339, 0.324821410291419, 0.3024810406407481, 0.31525504500089097, 0.283291120660385, 0.17462712280955217, 0.24956883652386086, 0.08654466930295435, 0.0877471563843234, 0.08697100756450049, 0.34939043260359515, 0.21967224311424616, 0.40448251679423297, 0.19823267050193805, 0.3172864168236601, 0.19335854099568617, 0.34184145128062404, 0.37752695599287944, 0.3835655970920887, 0.14786251777167148, 0.10614699806363403, 0.0941237116327347, 0.08853385714531137, 0.14618529163345717, 0.14077165233993783, 0.1538445025423213, 0.13581250799143418, 0.1469979770158829, 0.14361495275976977, 0.1081723441838145, 0.13202857508362031, 0.11679753358908762, 0.14717559965634008, 0.11399644096547412, 0.1397879746846935, 0.11043291260707122, 0.14957313418814377, 9.999999999998899e-05, 0.009879520795829877, 0.014928685637458305, 0.01149674444855242, 9.999999999998899e-05, 0.018148806114286153, 0.00020373285413644027, 9.999999999998899e-05, 0.002955093106026263, 0.04765603529124873, 0.06615401965922496, 0.12394654644773395, 0.07083044700677255, 0.0638001701984493, 0.04176136986373369, 0.08766985501900526, 0.12006436897033912, 0.07238952878978067, 0.028425489660783065, 0.056181474009586285, 0.05296809669774449, 0.08410403315592996, 0.03377477751251701, 0.07450769598368734, 0.041100089123496386, 0.058623918710905665, 0.03878768161877799, 0.13512809708198403, 0.11484543053064322, 0.08533764507645358, 0.004600153620807568, 0.12158071688885175, 0.16597928545973883, 0.12604786921110078, 0.0646882567471968, 0.06914490034819887, 0.41476758902653077, 0.4407638641962993, 0.41420115842249505, 0.37991975360380603, 0.4449464324819288, 0.4190719071554888, 0.43187487562200844, 0.41016334534675036, 0.41281709650018716, 0.07744265103173309, 0.1078741657515151, 0.10528047991580258, 0.11406295582194925, 0.09434685574018242, 0.09254327252805084, 0.09774622470317063, 0.11933981347025269, 0.10711529750494608, 0.15621355318947772, 0.21977306978792788, 0.23386841172618056, 0.1995888835244941, 0.1881140628212129, 0.1617591194880098, 0.20263175134336509, 0.1781843524200556, 0.16659193451306964, 0.2594809604582462, 0.23397541451327064, 0.26849901818470834, 0.28239106810372105, 0.29767284358639357, 0.2725210980340722, 0.33071062731035517, 0.31525798957282936, 0.26236293274281974, 0.24875103197521786, 0.19508777940284838, 0.19712903930936554, 0.15778296287899207, 0.1980719210567885, 0.18187795045368793, 0.21565236561707646, 0.19634121729825627, 0.13765298713307295, 0.18424533555847533, 0.18956628813029297, 0.19165531942124403, 0.20000706092476705, 0.18927062955100948, 0.21283121766229163, 0.2100583750839754, 0.20192194358181736, 0.19804846900642004, 0.19773484630240612, 0.21126571434949326, 0.18616956559667064, 0.18565792593051733, 0.2656731117959086, 0.280972888374158, 0.2182353863120018, 0.23001007880629254, 0.18692226478028173, 0.17110958664002518, 0.1823269892774353, 0.18091280601335125, 0.6945360989308464, 0.19340917006535396, 0.1942513006765929, 0.5403702570378746, 0.6305243910331322, 0.6608714149070385, 0.6459164213732356, 0.20737870381795775, 0.15780327205354006, 0.4404530842076928, 0.3163563303126786, 0.1503564656724986, 0.10400977347104523, 0.10281124482194304, 0.29852778119361634, 0.17780929203946416, 0.18245868471486326, 0.19118986436434893, 0.1769643963725761, 0.1915764145790949, 0.1911297625110686, 0.17325356257411295, 0.19301325617153986, 0.20409389486254625, 0.08318141561351478, 0.07924524548214262, 0.07674149035111277, 0.07617300786699566, 0.08286248585309242, 0.08959766757562249, 0.10076244165805726, 0.08476969872886819, 0.08317556463018627]}, "mutation_prompt": null}
{"id": "1d358ddd-e716-4ff8-87c7-f776ccb96f25", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for enhanced diversity\n        self.inertia = 0.9  # Start with high inertia for exploration\n        self.c1 = 2.0  # Increased cognitive component for better personal learning\n        self.c2 = 2.0  # Increased social component for better global sharing\n        self.mutation_factor = 0.85  # Adjusted mutation factor for balance\n        self.crossover_rate = 0.95  # Further increased crossover rate for more exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 1.5  # Reduced clamping for more precise movements\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Adaptive inertia reduction\n            self.inertia = max(0.4, self.inertia - 0.5 * (eval_count / self.budget))\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedHybridPSO_ADM", "description": "An enhanced Particle Swarm Optimization integrated with Adaptive Differential Mutation using adaptive inertia reduction and stochastic crossover to improve convergence and exploration balance.", "configspace": "", "generation": 12, "fitness": 0.27980204021434335, "feedback": "The algorithm EnhancedHybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.7071432969682706, 0.7133950636538717, 0.703366366603371, 0.7295740563103121, 0.7063151799522327, 0.6949005263821575, 0.715604242996765, 0.7235961303464251, 0.6849349082382623, 0.42030073077319985, 0.378962186406701, 0.061124358257909406, 0.4441251412276791, 0.36996763482895645, 0.3623211000923747, 0.37270562658070405, 0.39446404702173954, 0.32268756809449495, 0.125762508269323, 0.14019396335587897, 0.12967940239235065, 0.25315956127576145, 0.10807323065250041, 0.11925654101598415, 0.12408443663062896, 0.1402659176009471, 0.25108213193390116, 0.10409820836414907, 0.12042990464370618, 0.10453649647401764, 0.10191023792050857, 0.11860032127667841, 0.12757474711611994, 0.1326740017865372, 0.11817193494815204, 0.11060585300971504, 0.9621196213359142, 0.9497635407382159, 0.9402498295407379, 0.9410997087934116, 0.910869924577069, 0.9408565472731877, 0.9523344475876534, 0.9317950987304132, 0.9412784065253466, 0.36163784277048616, 0.3574322957827005, 0.32947925303251957, 0.32814206018869296, 0.3406323568905524, 0.3146533414150058, 0.3271010948639045, 0.3370808119841153, 0.3539072701793695, 0.617467182830594, 0.22041431761195296, 0.33687132187612756, 0.2639782953292633, 0.25645394001747246, 0.26575524968787034, 0.3883290124462191, 0.5118819735932854, 0.6268008066467008, 0.11960990924464898, 0.10819448434646839, 0.15548720183093212, 0.16352227646076478, 0.3292309527175584, 0.1961011227604018, 0.16150413766348626, 0.16292155308962641, 0.16111343340270956, 0.19838622683578, 0.10819924363831745, 0.19667684651545647, 0.1627459714742847, 0.1673124314576767, 0.16889337675069405, 0.20105013991325626, 0.18479203498189967, 0.18910945195690088, 0.0620757260630328, 0.0058002906449199365, 9.999999999998899e-05, 0.03562690829249893, 9.999999999998899e-05, 9.999999999998899e-05, 0.07604528448537384, 0.0002044727894159326, 0.00841408900874685, 0.10654855843890687, 0.12921918561931123, 0.1061094837140194, 0.08649698199440758, 0.08331786830498367, 0.07581457052306773, 0.10436795503182095, 0.13065861885982744, 0.07945928525434032, 0.0731228361704801, 0.07182667975728707, 0.14607607317846327, 0.090593096737142, 0.05010699553155207, 0.19507461611690935, 0.06442372176202604, 0.09325178706053028, 0.08104826256062336, 0.14498304516689586, 0.08484021818057985, 0.20051249487674627, 0.06623747912787603, 0.035340916509706055, 0.14362075292820042, 0.07451271919963476, 0.07397261243329745, 0.08746056391673251, 0.500485307962176, 0.45784183442486226, 0.47169344523484624, 0.45496174352986574, 0.49754962849243933, 0.4643546239776364, 0.5121238106121397, 0.4767447477636618, 0.5014182486125074, 0.15847950565857571, 0.099734486066265, 0.09278009496762685, 0.11054975337290252, 0.10176863354994925, 0.1320574267995156, 0.10473023599832654, 0.11909994513254019, 0.1119801414539574, 0.2701200675015015, 0.32200927098573184, 0.20421052584939503, 0.23641011666638756, 0.1902061313560971, 0.20488735571225436, 0.239199602443663, 0.25936512258967825, 0.3616748249193461, 0.36434202949373584, 0.3429687969802476, 0.3330961030401157, 0.32506468781941766, 0.33496186066661837, 0.34973943646418926, 0.3212378304803878, 0.36277424081739773, 0.36995424625766693, 0.24287500987114108, 0.2340958220923146, 0.2659458958645702, 0.17505270270829465, 0.20963966736753514, 0.26518999588879244, 0.21496461203343342, 0.28394576233279045, 0.19935893937756066, 0.23273381803144855, 0.2172043864072961, 0.22244984950186264, 0.2147754369387751, 0.20079336374343604, 0.24092871842761798, 0.20869326434236768, 0.23132440973106305, 0.1998865782431346, 0.19428615460931675, 0.21189328559677412, 0.3295930501051316, 0.2042081732576707, 0.20076648629134264, 0.2388426060326928, 0.3976448168206125, 0.23654372963093706, 0.19865936694865804, 0.1841706699460659, 0.7487782023313176, 0.1847992354797805, 0.8171365158111709, 0.16709267743512213, 0.1686379828577177, 0.7701609696012262, 0.7806332335124017, 0.2099135154447056, 0.5209063783273258, 0.2089323443705764, 0.5282021723136701, 0.20650359392038886, 0.3982429187660187, 0.4866698131360224, 0.7861649302659934, 0.5904851975201706, 0.1635389244594937, 0.19353809984256876, 0.2108355260269933, 0.1901899141783049, 0.19783751950348405, 0.19071583462219344, 0.17771151200438362, 0.18720228194743482, 0.18998654267776915, 0.19112381370228437, 0.08482450089484062, 0.0808004396862434, 0.1193062723170526, 0.07911448014676914, 0.08340676305582273, 0.084037145934305, 0.10827796544166535, 0.08421110189471315, 0.08393187014068737]}, "mutation_prompt": null}
{"id": "a5e53cbc-a97f-4cf1-a121-8d61b657d833", "solution": "import numpy as np\n\nclass HybridPSO_ADM_SCI:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Population size\n        self.inertia = 0.6  # Slightly increased inertia for exploration\n        self.c1 = 1.4  # Slightly adjusted cognitive component\n        self.c2 = 1.6  # Slightly adjusted social component\n        self.mutation_factor = 0.9  # Enhanced mutation factor for more diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Initial velocity clamping\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Adaptive velocity clamping\n            self.velocity_clamp = 1.5 + 2.0 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Stochastic Component Integration - Enhanced Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    \n                    if np.random.rand() < 0.5:\n                        mutant_vector = particles[a] + self.mutation_factor * (particles[b] - particles[c])\n                    else:\n                        mutant_vector = personal_best[a] + self.mutation_factor * (personal_best[b] - personal_best[c])\n                    \n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_ADM_SCI", "description": "A hybrid Particle Swarm Optimization with Adaptive Differential Mutation and Stochastic Component Integration, featuring enhanced adaptive velocity clamping and dynamic cognitive-social balance for robust optimization across diverse problem landscapes.", "configspace": "", "generation": 13, "fitness": 0.32176776583894184, "feedback": "The algorithm HybridPSO_ADM_SCI got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.7757145570490439, 0.7790407852886561, 0.7729759731034072, 0.7751088709357086, 0.7723708361613023, 0.7717952444701344, 0.7801827790851619, 0.7712092693534569, 0.7743084179545452, 0.4779136643271954, 0.4664006231153375, 0.48692653713133505, 0.526661689291654, 0.4913833221039252, 0.4921560080166686, 0.44071505757660945, 0.4613394098325976, 0.4570300589133751, 0.16924904137150987, 0.3229549106658708, 0.15378802507711187, 0.1128698669460606, 0.31419626447704707, 0.15626458494430406, 0.4142736796996225, 0.11326601881158005, 0.14332988960391158, 0.13447218725031795, 0.10955337999426651, 0.11262443712475889, 0.14555047150415978, 0.12710532118766027, 0.1406214854881841, 0.12758725598784237, 0.1396645456087856, 0.13120260568883801, 0.9470511706904605, 0.947311175566484, 0.9429111383226633, 0.9506233617641371, 0.9376349867968372, 0.9521453164601414, 0.9426391654544212, 0.9376327680898227, 0.943310541376428, 0.5207388742880725, 0.518536948831947, 0.47628558649548025, 0.4691600648896148, 0.43985799579601503, 0.5315157824031997, 0.4856245480571717, 0.4318813855441205, 0.45868756785827114, 0.7674872291616051, 0.674946732633146, 0.36575117459141016, 0.26334443071506575, 0.7529824621067908, 0.20777942479571798, 0.5593382874391908, 0.7550273779742731, 0.6263294267753389, 0.23219444827883318, 0.21553340324407178, 0.18471566196282752, 0.2673788692576624, 0.21182543822582967, 0.27096854817243243, 0.2165702207811896, 0.19800490670649828, 0.13123818977035684, 0.2396305268328761, 0.13154456773351653, 0.2010126479142117, 0.2201251250854298, 0.23175010868242585, 0.209894354703262, 0.23912989633013104, 0.192990182714589, 0.26741670399286077, 0.02496156667502314, 0.07264053099446954, 0.06416948080771523, 0.03146954590617557, 0.012240464622823133, 0.04527582213216208, 0.020109013962925526, 0.08913973872402225, 0.06427197546310637, 0.13456184264653515, 0.1127347297295288, 0.14700670512585834, 0.1899181595963111, 0.07636252650855546, 0.09968333665914275, 0.1281201184103602, 0.15592065825949653, 0.14084248171133895, 0.16454282894848438, 0.09984769396602877, 0.1700124666801659, 0.08519489649225565, 0.07291201234773526, 0.06770597471709405, 0.0869069811564781, 0.16386224813262174, 0.15382190030186682, 0.15102084096681123, 0.18043329930375662, 0.12452353347873668, 0.200686113737788, 0.12639792289679008, 0.14867531790746347, 0.1193460984542809, 0.14615144131258673, 0.1487222002406282, 0.5334310771804783, 0.5007627950226641, 0.5363174890792485, 0.5249619434371933, 0.4974640469409404, 0.5324564448989171, 0.5661575159159177, 0.522726048379041, 0.5702645177355932, 0.14349086256262344, 0.12148549460475311, 0.15409153621109817, 0.13522133054905683, 0.155003386418893, 0.12409475013638982, 0.13008722624016023, 0.12283880528003632, 0.1231195414514914, 0.2114441599622362, 0.23095668696987515, 0.1936845248266007, 0.2158427095323291, 0.19211200680211227, 0.2141176130794955, 0.36253109044373133, 0.32178542623099227, 0.16672059252786353, 0.40454960991275113, 0.35444291934977834, 0.4206192998935504, 0.37679877819161023, 0.4555819366429886, 0.46086738743401323, 0.42979172013389877, 0.44384710391898763, 0.3927807880446058, 0.2683114560908548, 0.3113590159874222, 0.31519905445113605, 0.21702877758137318, 0.27453016174382994, 0.25762836633761776, 0.23061501113015714, 0.2480863181176085, 0.22919590708585103, 0.22234615031155025, 0.22975206254150593, 0.21579012428900468, 0.27007153558185626, 0.2053652360702013, 0.23241818466157893, 0.24151723180827644, 0.2154466528453658, 0.23764119648204063, 0.42876424207005903, 0.24168289583745495, 0.20682701711799079, 0.2193097092093501, 0.2411329364471737, 0.20241514840760433, 0.21277697509735982, 0.20951106847857504, 0.37588776827734327, 0.1959318137549877, 0.18703399747287275, 0.18473847923828302, 0.872100106560739, 0.8375443560933307, 0.18880140920547583, 0.7289609242210666, 0.16548766119982605, 0.8684847816939616, 0.6989936433972951, 0.21099872470945247, 0.6727457284888079, 0.7375366761956366, 0.16749309512176458, 0.1519296916560645, 0.10400178878943767, 0.6582792973963973, 0.6597015271758653, 0.18607320881272493, 0.1942354385256907, 0.19274608195430976, 0.19119904084278627, 0.18424126182411793, 0.18865708284177984, 0.19365794708998119, 0.19658987748270762, 0.18963112658389103, 0.0873932212439722, 0.08272593650156801, 0.09364268781648677, 0.10138435820122649, 0.09669978715460215, 0.09649479530216998, 0.08828268016172902, 0.10111203784019851, 0.11278950927226761]}, "mutation_prompt": null}
{"id": "96c19f7d-5d45-4ab7-b563-96536b89d5f9", "solution": "import numpy as np\n\nclass DynamicSwarm_ProbExploration:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for enhanced diversity\n        self.inertia = 0.4  # Lower inertia for quicker convergence\n        self.c1 = 2.0  # Increased cognitive component for improved self-exploration\n        self.c2 = 1.4  # Slightly reduced social component\n        self.mutation_factor = 0.9  # Increased mutation factor for higher diversity\n        self.crossover_rate = 0.85  # Balanced crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Increased clamping for wider search in later stages\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Adaptive velocity clamping\n            self.velocity_clamp = 2.5 + 1.0 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Probabilistic Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "DynamicSwarm_ProbExploration", "description": "A dynamic swarm strategy with probabilistic exploration and adaptive mutation to enhance convergence precision and diversity across complex search landscapes.", "configspace": "", "generation": 14, "fitness": 0.321827310252317, "feedback": "The algorithm DynamicSwarm_ProbExploration got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.811049281318375, 0.8045721487692926, 0.7999931897736043, 0.8108100564433325, 0.8261409267495079, 0.8232292949572644, 0.8439638816342748, 0.8092366047888835, 0.8151490346738623, 0.5970400501911487, 0.5936166315858826, 0.5647072889050735, 0.5948756596573457, 0.6448069443339126, 0.5698766412678841, 0.5747497932148288, 0.6231781733801991, 0.6274322598852975, 0.1528721024478542, 0.15832435657679766, 0.3128683175324769, 0.14389415544175554, 0.1785758631584946, 0.1425123110799832, 0.14365689009593896, 0.1500421343076963, 0.14810518564351083, 0.14424684034475654, 0.1106260348860173, 0.14561685386950918, 0.12664137079020044, 0.10820706864294338, 0.10297778282001968, 0.16449217806345928, 0.15332799956322396, 0.1381559769403342, 0.954909063173423, 0.946331071291966, 0.9499154482174075, 0.9542572084272579, 0.9470602967680822, 0.9427113479267999, 0.9643581411033624, 0.9567061299019651, 0.9421017099042402, 0.4344116903002291, 0.5040157055275242, 0.5077010207449375, 0.5533627802079091, 0.5251938273363611, 0.5057139059729292, 0.47962034303978585, 0.51265690882495, 0.5100578975230308, 0.8304149313531686, 0.22822469827525593, 0.7751900399111021, 0.2710461585948978, 0.27470529764594, 0.7614437370548683, 0.7239000910176356, 0.6429349570388562, 0.236495243807765, 0.18771430765218777, 0.14909170367078628, 0.18135490041201818, 0.23190935804768054, 0.1790190253914128, 0.1820275566163383, 0.19303934192467664, 0.15534151996935486, 0.20723088429908176, 0.21215286472764006, 0.19828155785683843, 0.18445887131257477, 0.19421115473761552, 0.2024265225841999, 0.19471137413019013, 0.23292171924030092, 0.23453542821936157, 0.25025736294327006, 0.05066123943431011, 0.014672777496339995, 0.07957029632228574, 0.02108159449624858, 9.999999999998899e-05, 9.999999999998899e-05, 0.0423629413823472, 9.999999999998899e-05, 0.003466737819466159, 0.10374540865599069, 0.09284728615170712, 0.14900849669047478, 0.07855968287645887, 0.091541055721161, 0.06715214848190698, 0.07328079980973856, 0.0919390663164037, 0.10766304765244417, 0.11229090679135001, 0.1659537918578068, 0.19101660391304132, 0.1165242189443878, 0.12164448124880745, 0.11926675243942952, 0.09040387168971631, 0.17873379982401616, 0.2280000080310286, 0.15107555274573425, 0.12751843317344758, 0.14108397082009527, 0.2537045009640776, 0.04947616151567069, 0.20646112916179504, 0.14046247191306305, 0.07961209705196637, 0.1377219610894228, 0.5197425036217129, 0.5005790547233511, 0.509235303995543, 0.5362832874217847, 0.5106132745747236, 0.5154422572558736, 0.5597692172201831, 0.5477830075892274, 0.5464461098283326, 0.11296549493746866, 0.10907888760667994, 0.12831951255700802, 0.17448196193950294, 0.10137713626033695, 0.11888314560018776, 0.14585662727020865, 0.14470856077666472, 0.08962090038493065, 0.2549643238578555, 0.19132060794539707, 0.16806817512482575, 0.17434306146720646, 0.3029909225292807, 0.2920615600169477, 0.2458711067314946, 0.17581636974390402, 0.2402770894122963, 0.4806115149798914, 0.23331863695334465, 0.37533112619073394, 0.2957629724220554, 0.36034996880931724, 0.39584706304386186, 0.5091503215257118, 0.3946033604470195, 0.49930528293731335, 0.2798906142544494, 0.2966295327263401, 0.316891345325372, 0.31567467817556816, 0.37856783435670305, 0.2840654600252719, 0.23284332525835272, 0.22743341530699168, 0.28458712393664143, 0.21687555267201775, 0.22918509117214025, 0.2070467435793395, 0.21547634961000295, 0.23277515820456474, 0.2125830403515101, 0.208468712574975, 0.2008831994895085, 0.23168307209588634, 0.21185612537228704, 0.22090304626939605, 0.19642582719333146, 0.21917947500657764, 0.6902603213020737, 0.21778987815488682, 0.23958202205247503, 0.525639555330541, 0.2447224666914657, 0.17762030051881506, 0.1877563606575865, 0.2093552518168329, 0.9053192241759725, 0.199303780440929, 0.7951662704447886, 0.14188146076423858, 0.166512314149315, 0.8776010159300757, 0.5990439910331506, 0.20970244842687702, 0.07347249058279137, 0.7338596181672561, 0.583832815693937, 0.1664078205538848, 0.10500349463896042, 0.6399246623541128, 0.8393748191547615, 0.1836447410379236, 0.20201097172472404, 0.19298964952554465, 0.18395083281690572, 0.17757768975477717, 0.18795467942930777, 0.19325857367490762, 0.20095265662647765, 0.21066446503139802, 0.08280728741054555, 0.10060129690493491, 0.08745766239283115, 0.09817550398205244, 0.08724058063585294, 0.08981013653865888, 0.09171702540371773, 0.10411388668832366, 0.08503488038218088]}, "mutation_prompt": null}
{"id": "8ae59b09-268a-49b5-80a9-139942f48800", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly increased population for better diversity\n        self.inertia = 0.6  # Slightly higher inertia for more exploration\n        self.c1 = 1.4  # Adjusted cognitive component for balance\n        self.c2 = 1.6  # Adjusted social component for balance\n        self.mutation_factor = 0.9  # Increased mutation factor for diversity\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Stochastic velocity clamping\n            self.velocity_clamp = 2.0 + np.random.uniform(1.0, 2.0) * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Mutation with stochastic selection\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_ADM", "description": "A hybrid Particle Swarm Optimization with Adaptive Differential Mutation, enhanced by stochastic velocity clamping and adaptive mutation strategy, for improved handling of diverse optimization challenges.", "configspace": "", "generation": 15, "fitness": 0.2935145717839258, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.7785851426453085, 0.7260735172804025, 0.7293681426157992, 0.7327222896188421, 0.7188859533205181, 0.7459627605835709, 0.7382780388405307, 0.7122542908718796, 0.7112349355216803, 0.36769220370103306, 0.3472426451823487, 0.34520296194395617, 0.3382970558427514, 0.37724188990657126, 0.3691502423230604, 0.042617981137294536, 0.4226555221248607, 0.2629592810194187, 0.12987872118701838, 0.11837802267657649, 0.11490682120758211, 0.1569747775273549, 0.2350488796504977, 0.16845688650472057, 0.1677466448829822, 0.32289666282046114, 0.16094276773040783, 0.1002796630103936, 0.09913395069157183, 0.15809574945716687, 0.11729734565422845, 0.12820088612918823, 0.12589550660825521, 0.12605690635478384, 0.1135686419635138, 0.13243153139743624, 0.9544083520477161, 0.9549402282085367, 0.951064073792377, 0.9548898592822065, 0.9373070425496693, 0.9506865015793529, 0.9552687730754001, 0.9646723009463876, 0.9354371094684589, 0.4581083995887105, 0.4274179895114345, 0.4405360742716551, 0.41426338492981263, 0.4317770332861083, 0.4679456552373331, 0.4164066135660466, 0.44375632678641885, 0.4359015438525399, 0.372913617632757, 0.7878859382104952, 0.780506221069545, 0.2588315313631011, 0.27398728733311195, 0.19128786590603386, 0.6101415940092487, 0.32744198460355634, 0.6577731523394268, 0.11348424356583109, 0.0997731339147907, 0.17813200200837986, 0.12365796847300448, 0.1990567485220932, 0.18049135938620675, 0.19576039075806861, 0.17941169188618356, 0.17983771602337906, 0.1874101244519506, 0.15978070791537158, 0.13681232381962527, 0.1291294691698769, 0.1781539864966697, 0.12828267448623232, 0.2239893702806759, 0.22019601202032169, 0.12027372410364146, 9.999999999998899e-05, 0.03760647282190366, 9.999999999998899e-05, 0.027989347810523535, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0949385901240094, 0.03275749588575383, 0.08493904377973982, 0.12290492906917239, 0.07217402849156351, 0.038881595799125535, 0.0859756982073584, 0.11833396701558974, 0.1281819306924774, 0.03741195358412064, 0.12905928114905818, 0.09647146128317707, 0.11752658733154409, 0.10371611459763608, 0.06752935601267451, 0.07973622732117425, 0.17119348199700457, 0.07684784770133324, 0.09479489088182813, 0.1070344733328944, 0.21227077958634266, 0.12143355748603935, 0.12525780984619506, 0.13720242351286704, 0.17624611873823393, 0.21903056395577392, 0.0887515399994867, 0.4956962636949763, 0.5406438863297254, 0.5071047863541319, 0.5447066630567741, 0.49856955040672213, 0.5656395777582763, 0.4950168495325299, 0.5113183117675473, 0.529196008233201, 0.13781556068010903, 0.10979161367570722, 0.1713185323915517, 0.12973467423507734, 0.16752754965919525, 0.13975348558245282, 0.137600015032471, 0.16615958463809888, 0.13048199961832363, 0.36579459569068395, 0.18006063081960288, 0.16691276591836957, 0.20563899340268832, 0.3334857151001742, 0.2846630328305231, 0.2655072053211892, 0.19604579950376044, 0.40400501540771816, 0.3387717802519137, 0.35390772964255357, 0.2844462812136005, 0.4148496678098488, 0.3814051008560515, 0.390587802856473, 0.36184681715962663, 0.47336284143443685, 0.42083199140996375, 0.309281957639581, 0.35288664389277136, 0.24057364327914732, 0.2707490733760066, 0.23441318459214033, 0.29131699117932386, 0.3203150057554063, 0.29766466113823176, 0.18554314356993884, 0.22133593054774803, 0.2336553394438332, 0.20384011804523072, 0.21278178521515323, 0.20195355542256122, 0.21469603300910733, 0.19378181141162099, 0.23367771179630215, 0.20871240090406862, 0.24601184669562293, 0.20629605974716936, 0.23984980069998174, 0.21167741106945226, 0.19813437934566946, 0.40041103751014706, 0.1998996336520089, 0.2435601789712598, 0.23154183685993568, 0.8171528261075849, 0.18658995740823303, 0.18481240623597017, 0.8541092168022646, 0.19863607906254632, 0.16911181485389282, 0.14200844852394345, 0.8492081136983354, 0.8112525463088952, 0.7058102611817888, 0.20842599534229278, 0.6448561431315948, 0.20772588288501825, 0.41548946311220114, 0.15088410818620268, 0.10447091392580932, 0.16374491076398645, 0.7804906464892298, 0.21274847394637575, 0.18173543453433738, 0.18231078810466717, 0.19004527036258478, 0.1796908383348197, 0.19683490230123502, 0.19518862319738717, 0.19340247648886444, 0.19068127307313676, 0.09793532664189297, 0.08794467800148376, 0.08458125234631475, 0.08421874084385905, 0.08511064043401728, 0.0916366087410303, 0.1357914299631401, 0.07939162435113922, 0.09165664591812639]}, "mutation_prompt": null}
{"id": "29f05118-c531-48d1-af9b-0f8d27a392e1", "solution": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.7  # Increased inertia for broader exploration\n        self.c1 = 1.4  # Slightly reduced cognitive component for better social interaction\n        self.c2 = 1.6  # Enhanced social component for better convergence\n        self.mutation_factor = 0.9  # Higher mutation factor for more diverse solutions\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_velocity_clamp = 2.0  # Initial clamping\n        self.delta_velocity_clamp = 1.0  # Change factor for velocity clamping\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            current_velocity_clamp = self.initial_velocity_clamp + self.delta_velocity_clamp * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -current_velocity_clamp, current_velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_SA", "description": "A novel Self-Adaptive Hybrid PSO with Dynamic Differential Mutation adjusting mutation, crossover, and velocity in response to optimization progress for enhanced performance across varying problem landscapes.", "configspace": "", "generation": 16, "fitness": 0.27731217748466086, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.6780152055338611, 0.6790391173394004, 0.7037691748936358, 0.7034375107955053, 0.6629053187501637, 0.6963460186048301, 0.7007662892709176, 0.6862631021985942, 0.6388454945041169, 0.2700554104171634, 0.30485654969788434, 0.34086331345595944, 0.2867500699865352, 0.2791702792966245, 0.31050284137464446, 0.2925338108032355, 0.27435433043865054, 0.2490561143551504, 0.1352704319030319, 0.19225283683213024, 0.13662852596181074, 0.10743309381549626, 0.1106930609251553, 0.11797279753101175, 0.16611219304727542, 0.15419847954115318, 0.16361464349378696, 0.10153483442437883, 0.14122511147497374, 0.09531762653391784, 0.14739993238515603, 0.10403859364605705, 0.13706906394597662, 0.15328372823938863, 0.10958838849150065, 0.09985402001107846, 0.9542570602313739, 0.9445932581728533, 0.961113377770915, 0.9520388677585694, 0.9612172682454241, 0.9536065950484838, 0.9615604534033008, 0.944293589669105, 0.944948186884861, 0.37249161550018794, 0.37022036333432196, 0.37911673561270265, 0.36073489963625993, 0.4169496294672541, 0.14895287253451694, 0.3738147259981298, 0.3751109277131143, 0.4172532296425632, 0.37622634963587587, 0.33983467452765626, 0.668829658549557, 0.2130036483571791, 0.27126030445781246, 0.2684834765054095, 0.36583184607550934, 0.23042367437859257, 0.6732315202975379, 0.1784764825403925, 0.1567772831839067, 0.17847394639123526, 0.15515442241362476, 0.1674087370392412, 0.10215241803047925, 0.1615641681213299, 0.16090909695127686, 0.1820837806646507, 0.1859505347928827, 0.29064104569008165, 0.19921887760061796, 0.12655215353579297, 0.1250652609522065, 0.1723070805622674, 0.1790337426777049, 0.18406779122711925, 0.10076991463570206, 0.019172319404990756, 0.0010169505306144577, 0.022057030603212846, 0.043629376637771, 9.999999999998899e-05, 0.03368125494707386, 0.0005927952020441385, 9.999999999998899e-05, 0.06579644717997835, 0.12261826675791976, 0.06701340689589974, 0.07101733287000411, 0.09264335233979581, 0.04179595226045418, 0.0925723965252786, 0.08989335505484819, 0.08760799642006545, 0.13804412161415403, 0.13408834123574254, 0.09353084662813582, 0.09953712395068448, 0.09510622029660021, 0.06111687145746891, 0.08980054985332153, 0.07735122205323264, 0.11798299582242566, 0.051455575263236075, 0.11487477443216942, 0.10741678179024805, 0.18138316724977632, 0.005407305206433066, 0.13070553926415684, 0.19467652266693247, 0.11840294200900758, 0.05273580682600354, 0.07709660340218383, 0.45739558164524297, 0.4794326642241248, 0.47957080016281317, 0.4989153604363339, 0.4953054133429018, 0.4826328996343503, 0.5039648863841409, 0.46884751685458603, 0.4861778720890506, 0.14750476466584006, 0.11541585349063566, 0.10762848016275295, 0.1268971437699674, 0.11961175198021812, 0.12182607019710634, 0.12557270669042586, 0.12028115966958064, 0.12529517305393945, 0.27663442939577076, 0.26201164039187874, 0.3169287821494646, 0.28585604553188504, 0.19337602953498667, 0.20580217182158267, 0.20712684390470082, 0.18328275415350126, 0.3107767619084171, 0.3838768451385355, 0.276282754585469, 0.28572511738403206, 0.3785144881913781, 0.36961117258851206, 0.3598720429732233, 0.3891340472371766, 0.3415499844409349, 0.4334357435690366, 0.17864952314440508, 0.23079358434894848, 0.30788231768551644, 0.21576018242519113, 0.188323540783917, 0.24497798597266496, 0.31539425282189837, 0.259021890182041, 0.2448810121493189, 0.20623763014685015, 0.19191333217315076, 0.2307608206319628, 0.19742066462647567, 0.19609785995850038, 0.20175670267390355, 0.22401363927803342, 0.20143353023572985, 0.21495501383060933, 0.22396077724530583, 0.1942329220720006, 0.2956534215856206, 0.4167751954761646, 0.2118859182326044, 0.2374698571486178, 0.20835110982675653, 0.20987424123775955, 0.23610669781824978, 0.7761992194651577, 0.804388349005313, 0.1512485511794519, 0.8441625236683371, 0.19830501817353718, 0.19861723016449528, 0.16104934045503871, 0.7838602523093885, 0.8171350994698465, 0.6133099322390668, 0.21047697732280957, 0.6627736000724094, 0.20847240556605828, 0.5903287579923542, 0.16674908040745628, 0.208075920981465, 0.10389334961428265, 0.575410104203711, 0.21454999247402462, 0.18594609486389813, 0.1863245105696647, 0.18547857847646199, 0.1897179260581332, 0.17705976190097805, 0.1803769981023513, 0.18188781555143163, 0.18643678770512118, 0.07953301012606284, 0.08532889684072908, 0.07670341360620714, 0.0969364728669736, 0.09315705931211726, 0.08750575010482498, 0.11463930991731885, 0.08438266794793348, 0.08330779591405613]}, "mutation_prompt": null}
{"id": "b53d2b23-2e9a-491e-8033-16f370fc7877", "solution": "import numpy as np\n\nclass QuantumPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for quantum exploration\n        self.inertia = 0.4  # Reduced inertia for faster convergence\n        self.c1 = 1.7  # Enhanced cognitive component for individual learning\n        self.c2 = 1.5  # Standard social component\n        self.mutation_factor = 0.85  # Slightly increased mutation for diversity\n        self.crossover_rate = 0.85  # Balanced crossover rate for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 1.5  # Tighter clamping for controlled exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using quantum superposition\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Quantum-inspired adaptive velocity clamping\n            self.velocity_clamp = 1.5 + (0.5 * np.sin(eval_count / self.budget * np.pi))\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Enhanced Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "QuantumPSO_ADM", "description": "Quantum-Inspired Particle Swarm Optimization with Enhanced Differential Mutation for improved exploration through quantum superposition principles.", "configspace": "", "generation": 17, "fitness": 0.324598552045943, "feedback": "The algorithm QuantumPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.8325796794933066, 0.8400098488467171, 0.8070965523382733, 0.8091629203277686, 0.7919860899649256, 0.8216483397471496, 0.8042197406686493, 0.8171387087955532, 0.8223236747132048, 0.6056016553762871, 0.6173681574251249, 0.6199879046686507, 0.6324021203880126, 0.6174041917666728, 0.6262246845517219, 0.611107256870538, 0.5700251701760642, 0.5894824927030085, 0.15651084165612372, 0.14113478172305516, 0.5585404633675276, 0.16717988777056125, 0.14935017318052746, 0.11636538034622501, 0.15777648596725613, 0.14705039426911315, 0.17954630116761128, 0.14830292713266624, 0.13668672914449964, 0.13196237951595702, 0.17160350025500104, 0.11048550232219656, 0.1422885740214166, 0.11946695046706568, 0.14131971379573338, 0.11284283812085327, 0.9462523824903241, 0.9178446078628929, 0.9125463238722722, 0.9340505157939215, 0.9071259591887241, 0.9158809169544035, 0.9343289695856335, 0.9516910102835087, 0.9221132071640761, 0.5724101904989856, 0.5795804273765073, 0.5282009712180793, 0.615992883538602, 0.5442914513823853, 0.5751897637062799, 0.5485681253619039, 0.5314000050811942, 0.5513704402270996, 0.8018564926784683, 0.22784407871305956, 0.388138870640766, 0.8664598048046842, 0.2775781106316999, 0.21580855449313974, 0.2368850156531329, 0.621436908339799, 0.8117877555949503, 0.20614172391083763, 0.19072456772867696, 0.1277274868013345, 0.187268060854217, 0.19104815140323694, 0.21872306584927514, 0.3072120117935465, 0.25419824337046926, 0.19963456528404344, 0.1303525872064467, 0.2018671875732121, 0.20760684583038747, 0.21838574773488784, 0.2366100443966911, 0.22533489631951764, 0.22337396831891032, 0.20190792278164937, 0.23189364756703768, 0.07027673486132568, 0.10258651169658439, 0.0075429625555063495, 0.06506768713176503, 0.0029111718990701974, 0.002970975488520655, 0.03448388015194448, 9.999999999998899e-05, 0.04123456053642016, 0.11360964557499043, 0.09668062410680034, 0.0934631301166895, 0.06824803303058613, 0.08414646241538426, 0.12596283230193295, 0.18569776536267213, 0.13594376827548094, 0.08990992048956159, 0.18973559375946503, 0.24743638630068954, 0.13408256669076268, 0.15331781506820008, 0.20161593288236246, 0.11812587146035858, 0.09102394021536997, 0.17370125395379343, 0.17334420326464062, 0.1466459245653745, 0.12359746848424369, 0.15010428755751015, 0.0575899068765493, 0.10630803548294332, 0.14054949333723143, 0.149925332157816, 0.10363401421840224, 0.2404248041333884, 0.5189765785872342, 0.5405009231116024, 0.5589921925984728, 0.5522106667957187, 0.5243779707211912, 0.5388547852734211, 0.5507780148979631, 0.541021450054069, 0.557690334920501, 0.1245324143540858, 0.11221786625045993, 0.1336821987359884, 0.11515812393502534, 0.10921196747659923, 0.11577231656906117, 0.1463375765851288, 0.11918217932613695, 0.13589150626394242, 0.623141004556824, 0.24631902214387014, 0.19071259977950017, 0.18996424317556704, 0.25120285319887137, 0.2806329874604717, 0.20847949738751326, 0.18797434506001287, 0.21490608867758354, 0.43242862919464853, 0.40423050674554184, 0.3377993673133557, 0.4315303774237095, 0.49963531151460305, 0.45869518400686893, 0.5328931873191236, 0.5207631775367992, 0.3722808439035362, 0.2709363936487227, 0.35976387752041283, 0.314703019146814, 0.37151508109451437, 0.3135184223094045, 0.3569382606322036, 0.2399019862287114, 0.25136093897548295, 0.20257673726167313, 0.21301209639365493, 0.20739514552089044, 0.2054081893113482, 0.24040608922808937, 0.2948810445502792, 0.2254881234311612, 0.22249611219399834, 0.2294642684744992, 0.25516458527145125, 0.17872247104891503, 0.21255858852407594, 0.21901655853722446, 0.24456604169923846, 0.20697114732649502, 0.1839060347828272, 0.2026147898915598, 0.20684008761119432, 0.19917000967091203, 0.18647865198086733, 0.19493353364130406, 0.16749117575443828, 0.9197961382548854, 0.16813413207878036, 0.1691234795951757, 0.1418965279642067, 0.8327517187414714, 0.8850458341540223, 0.6678130866921753, 0.21048710452397645, 0.6099271446303882, 0.20924572271090403, 0.5125271119677008, 0.15342252292056346, 0.7497846136462354, 0.15232401347239433, 0.1662348305814778, 0.19826719141089788, 0.17476687653586376, 0.21930707991458886, 0.18218832122486306, 0.21321118079503, 0.18220555864802723, 0.18521787501626408, 0.18217427679913112, 0.20434023950306657, 0.08491047249537875, 0.08424927538811922, 0.07514750838074846, 0.0925047310060334, 0.08795855491985005, 0.08908001253422793, 0.0878268615227411, 0.09110327046550026, 0.1303092416014051]}, "mutation_prompt": null}
{"id": "af86652e-b708-4601-b6ed-ca276449265d", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted population for diverse exploration\n        self.inertia = 0.6  # Slightly increased inertia for better convergence\n        self.c1 = 2.0  # Enhanced cognitive component for intensified individual learning\n        self.c2 = 1.3  # Reduced social component for diverse group dynamics\n        self.mutation_factor = 0.9  # Stronger mutation for extensive search\n        self.crossover_rate = 0.85  # Adjusted for balanced exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 1.5  # Adaptive clamping for refined convergence\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Stochastic velocity adaptation\n            velocity_adjustment = np.random.normal(0, 1, size=(self.pop_size, self.dim))\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles) +\n                          velocity_adjustment)\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Dynamic Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedHybridPSO_ADE", "description": "An Enhanced Hybrid PSO with Adaptive Differential Evolution leveraging stochastic velocity adaptation and dynamic mutation strategies for improved exploration-exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.1724749316052233, "feedback": "The algorithm EnhancedHybridPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.28233815673708196, 0.28540694255080656, 0.301875787392348, 0.26679836377387733, 0.2594916214344051, 0.26808202591708785, 0.2847254358281057, 0.30119250499149497, 0.3139196992716512, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08541096954448146, 0.08140479552254742, 0.1013133357775825, 0.08658446301393741, 0.07412322649871605, 0.0815735440893095, 0.09139612720238455, 0.0829107015688878, 0.09164632956874463, 0.07140281560568273, 0.06880956954366813, 0.06446025016662493, 0.06952142595095379, 0.06268639905376583, 0.06710962298059331, 0.08642696006091832, 0.07100710291125889, 0.07571230774547877, 0.9306599514908013, 0.9202836594536604, 0.9422791537499038, 0.9494596106621209, 0.8919966707991736, 0.9262154473289599, 0.9064292437143142, 0.9137945523570733, 0.9235614137794275, 0.16666323611183564, 0.16520711743597516, 0.19757817822237844, 0.15221603984140109, 0.1548028741163806, 0.16525078263424553, 0.16135278027668443, 0.1595026275428325, 0.15966468728007566, 0.22507641598584016, 0.21943302706388623, 0.24880307535662516, 0.19340392201629109, 0.19012173586106673, 0.22830837635088497, 0.1986852170050658, 0.23784587522942024, 0.19506963999055738, 0.060350563195044726, 0.04247925320286772, 0.09923790682655054, 0.11289434217971539, 0.11488797591581801, 0.09939166371026842, 0.08837129975952884, 0.09083801501173805, 0.0965309402982597, 0.1042207922877062, 0.07406654686629721, 0.0879447211769171, 0.12144335823469887, 0.07155539497434216, 0.10847418422726773, 0.0836069278841467, 0.08843187507121197, 0.10145509012974874, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002458249746508656, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10286391566793518, 0.0903539288052172, 0.1116248010748554, 0.09138995255525317, 0.13672389669153873, 0.07105715078200014, 0.0769407673471818, 0.11426500389383387, 0.07532140927260755, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012544944515618273, 0.051911670004635035, 0.031118074973819576, 0.03588641995614961, 0.04574118217685719, 0.019583616289044925, 0.03192614538134808, 0.05519913531591447, 0.027114439724949313, 0.29258874308363714, 0.2716892242811303, 0.29962274043610015, 0.2973405122868731, 0.2756215220672257, 0.2868709721110956, 0.3166365019509406, 0.2932044924583037, 0.29017987900057474, 0.08380791786227926, 0.07685973498319398, 0.08052805670331786, 0.09255207638428675, 0.08295905377748236, 0.10456691855117717, 0.07615805818485955, 0.10510166572839374, 0.08237117496228397, 0.12018940914684739, 0.12225737697286565, 0.1433801282650673, 0.13822494745236746, 0.15107901488959252, 0.16208598847282285, 0.13437150919723007, 0.1638821739483146, 0.15655310993783456, 0.2177514353168407, 0.22687504921904666, 0.22358732296968564, 0.207609208721657, 0.21018370700127942, 0.2208552854726965, 0.22381936159335425, 0.21205866863403444, 0.22487542837130636, 0.15783925015820588, 0.1476007212313789, 0.1699599761732521, 0.16668848336925368, 0.1722493169443715, 0.16031468107276792, 0.15032617815823324, 0.1651259408199527, 0.16787831615366156, 0.18107349513265358, 0.21741999274314416, 0.19773147081185993, 0.19182309237737905, 0.18996249063300885, 0.22836424836145075, 0.22068737037718988, 0.23328766313357152, 0.20937560282925283, 0.18014432372634748, 0.17124653466814288, 0.1883543309903717, 0.17523581787623332, 0.16989256047955947, 0.17844354586052213, 0.1732278400631596, 0.17477183904470928, 0.181283639500311, 0.261445868969453, 0.17568423109051345, 0.17406733009903697, 0.30865679139379043, 0.1643888560769492, 0.1765277128376651, 0.3425782615007855, 0.29847674053140816, 0.33921293924146034, 0.3526077381789967, 0.1934959191748521, 0.30569610601796193, 0.27937332473690113, 0.292958489008484, 0.13786231205912702, 0.2695517243014778, 0.3107334029594129, 0.3261088368224676, 0.1830479949170527, 0.19773651902416045, 0.183002515676169, 0.19431721672602387, 0.20070671854179267, 0.18350127852638587, 0.17485707606692247, 0.1865288624184409, 0.1995466305194351, 0.09366335047747054, 0.07413378533490522, 0.08260046352697004, 0.07416912436595613, 0.07594723520521052, 0.07783020684781927, 0.08141997246892385, 0.07832098342852556, 0.08363268785456746]}, "mutation_prompt": null}
{"id": "06682806-b073-4678-8e29-fe49ed31f520", "solution": "import numpy as np\n\nclass HybridPSO_DynamicADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for enhanced diversity\n        self.inertia = 0.6  # Slightly increased inertia for exploratory capability\n        self.c1 = 1.4  # Adjusted cognitive component for better personal learning\n        self.c2 = 1.6  # Adjusted social component for enhanced convergence\n        self.mutation_factor = 0.9  # Slightly increased mutation factor for greater diversity\n        self.crossover_rate = 0.85  # Moderately high crossover rate for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_min = 1.0  # Minimum clamping increased for stability\n        self.velocity_clamp_max = 3.0  # Maximum clamping increased for flexibility\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Dynamic velocity update strategy\n            velocity_clamp = self.velocity_clamp_min + (self.velocity_clamp_max - self.velocity_clamp_min) * (1 - eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_DynamicADM", "description": "A hybrid Particle Swarm Optimization with Adaptive Differential Mutation and Dynamic Velocity Update Strategy, balancing global exploration and local exploitation for improved convergence.", "configspace": "", "generation": 19, "fitness": 0.28138997264869364, "feedback": "The algorithm HybridPSO_DynamicADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.7409239924809894, 0.7288505307759141, 0.7313790315675168, 0.7224044595421897, 0.7355540133458203, 0.7213375998157787, 0.7211192779086316, 0.7390236014948092, 0.6791552068624094, 0.28656925897894503, 0.33550762675538703, 0.36917652618145513, 0.37487779974384183, 0.36026738647197154, 0.38054360036628054, 0.3892489353077765, 0.34992332959876293, 0.3936301610577839, 0.1348663630022564, 0.16577422769027927, 0.22930888205820388, 0.15748151650301057, 0.13401250166660683, 0.11011555091097902, 0.1407744002220208, 0.1357873798891449, 0.16167106113669039, 0.13161176122956642, 0.14205341785434433, 0.1136280596170538, 0.12884810677749015, 0.10060813727273121, 0.11619736813830783, 0.1362491998682286, 0.10123129185649138, 0.10206933467672663, 0.9642676958043591, 0.956397119335844, 0.963332946687766, 0.9625907923609098, 0.9635758064155585, 0.9528933058440141, 0.9659780889263162, 0.9703253211431169, 0.9535996124692208, 0.45779896986692836, 0.4651964054778378, 0.40871475132037727, 0.48441682070906344, 0.44791448171272963, 0.42989666436997265, 0.4518096775242376, 0.43804974946320674, 0.42075140097783226, 0.7556472137747428, 0.764905579645497, 0.7309750917608697, 0.19282800303505698, 0.20601664130160757, 0.27273125615328053, 0.23316431392619874, 0.6354049492806734, 0.33102753135833507, 0.17410689017044245, 0.11270499166512382, 0.16561130209757302, 0.11153477790758914, 0.18685740688914754, 0.12286471540662136, 0.1970539301979849, 0.16510275060424595, 0.1864690643528314, 0.1939470644125797, 0.1917086741258458, 0.18510502594491995, 0.12457151147655299, 0.20167772407954254, 0.2131168411992157, 0.12671785825055193, 0.19653230200621308, 0.2119603122046234, 0.03488545588606884, 0.026801055764700488, 0.011896121025823936, 0.01989268410664824, 0.042192887188195916, 0.06772407964404314, 9.999999999998899e-05, 0.0011084494222164398, 9.999999999998899e-05, 0.0973688655061351, 0.07618964698726416, 0.1606089210676861, 0.09450546160802464, 0.10140427263260243, 0.043842384656200384, 0.11627553741087471, 0.11066644834146833, 0.07175363036975635, 0.11577558458344173, 0.12630793078769786, 0.07911988890405008, 0.12480307400353308, 0.06957242802278107, 0.062375286596492385, 0.13336777929264776, 0.09722435563472465, 0.07251691714560127, 0.1512901057382584, 0.060558508203908956, 0.13628800225571736, 0.08105213763170471, 0.14526333209770437, 0.29369696896223607, 0.07502565650068005, 0.07539027873613335, 0.0883807167247529, 0.5093331957209288, 0.5066782238992529, 0.523215548362872, 0.4759704559376359, 0.47342815745736366, 0.48222841529649807, 0.5056861710260651, 0.5389424325875511, 0.5295184625971203, 0.12259094023778239, 0.12460795329495722, 0.07981615486360838, 0.16129545442724702, 0.13965937785370497, 0.1237118898768611, 0.14056798370937795, 0.12258726739844028, 0.16695119896673716, 0.22716049646139624, 0.1690907103010868, 0.20915341543940702, 0.24341633324501377, 0.15679630459554794, 0.1790373183390278, 0.2286670326166821, 0.16902460440559663, 0.22950982113677898, 0.37563270196299414, 0.43123461022886966, 0.3230624085487902, 0.2915636032420561, 0.3090008854140581, 0.2279797938425112, 0.37646800291085725, 0.4026441484432226, 0.4254215228285436, 0.24192403685095698, 0.25821275370946395, 0.23270280003542443, 0.2772437104446155, 0.23548422240944666, 0.29410558349694005, 0.2692470595299641, 0.26302020723200426, 0.20782300668463927, 0.21196721706416743, 0.2249965145186078, 0.2327502126244283, 0.20091810280976097, 0.20429164760977137, 0.22123455433326378, 0.2079936584803389, 0.21809183039255609, 0.2051852439312013, 0.19151042116567019, 0.23506914882445018, 0.180124569864612, 0.20920465268437616, 0.19719213982489348, 0.21373580561135141, 0.24095331168360035, 0.19980695286383565, 0.20352566256442894, 0.17502331568477925, 0.18702078672118205, 0.18442357328165615, 0.8433958038474119, 0.19898482116563343, 0.1682554127692507, 0.14168879008039725, 0.1638745036867043, 0.8384551348149004, 0.6663470852247737, 0.20908381898665773, 0.6258921691977954, 0.5903166254975185, 0.16775234999011868, 0.15180961053458764, 0.5900926198937683, 0.10306781809691601, 0.3142953279801116, 0.18656528893156143, 0.19483750174459913, 0.1906480817746985, 0.21698739065972095, 0.17919250642485618, 0.17711379049170206, 0.1931526954059518, 0.20297586557224, 0.19620273911176778, 0.10757489916788077, 0.09338475914522604, 0.08439470160329543, 0.08623311926356603, 0.09533966733446708, 0.08498338753066581, 0.0854725203628981, 0.09840410084589801, 0.0920643988681199]}, "mutation_prompt": null}
{"id": "8c8c6f47-f3b0-4c0f-8be0-4a094b3a2c3a", "solution": "import numpy as np\n\nclass HybridPSO_ADM_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  \n        self.inertia = 0.6  # Increased inertia for better exploration\n        self.c1 = 1.5  \n        self.c2 = 2.0  # Increased social component for better convergence\n        self.mutation_factor = 0.9  # Enhanced mutation factor for diversity\n        self.crossover_rate = 0.85  # Slightly reduced for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  \n\n    def chaotic_sequence(self, size):\n        x = np.random.rand()\n        seq = np.zeros(size)\n        for i in range(size):\n            x = 4 * x * (1 - x)  # Logistic map chaotic sequence\n            seq[i] = x\n        return seq\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = self.chaotic_sequence(self.pop_size * self.dim).reshape(self.pop_size, self.dim)\n            r2 = self.chaotic_sequence(self.pop_size * self.dim).reshape(self.pop_size, self.dim)\n\n            self.velocity_clamp = 2.0 + 1.5 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_ADM_Chaotic", "description": "A Hybrid Particle Swarm Optimization with Adaptive Differential Mutation using chaotic sequences for enhanced exploration and convergence.", "configspace": "", "generation": 20, "fitness": 0.2353574143485505, "feedback": "The algorithm HybridPSO_ADM_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.5158230055405282, 0.5886946728138764, 0.5340980440201974, 0.5115566164522115, 0.5468393127155949, 0.5506247390394916, 0.5185327411539993, 0.5580760242767532, 0.5363261067167322, 0.18520525905814322, 0.19610518491059714, 0.1978154017496877, 0.2334868391087258, 0.19351993004387957, 0.18449671800219736, 0.21242398946098795, 0.14325002753262783, 0.1836328219134271, 0.12994791696728003, 0.12007264217966762, 0.12100426040883994, 0.11762468175318319, 0.10895296953972833, 0.11948502874675992, 0.09567538312352264, 0.13451335939818454, 0.11484521241420953, 0.10258746816309616, 0.10069426633011813, 0.11355401085362105, 0.08102684755007872, 0.11819512985640412, 0.09867993114091511, 0.1352514224150385, 0.0992087743813912, 0.1019957676565878, 0.9629695840115516, 0.9614096707381852, 0.9609674937097217, 0.9546172497622677, 0.9669662514125166, 0.9548251465906431, 0.9596378474967082, 0.9588301673163455, 0.9608062051183024, 0.28079341964191207, 0.25577965473116226, 0.2560513889386109, 0.26096755458795406, 0.299835735667766, 0.2768287551774936, 0.3030224969137564, 0.23982800917594138, 0.2880527825340863, 0.2362753565715977, 0.2260078589180725, 0.3355032404917734, 0.20720913237384142, 0.344855797158065, 0.25316963166953865, 0.25266208427958514, 0.3366972037430983, 0.23644504705393454, 0.1490788155460514, 0.12377609714038462, 0.18165507444418272, 0.14679692917922638, 0.141895803728727, 0.15524506013237915, 0.14195774024641195, 0.14444258429687762, 0.14838330421221724, 0.15579979674065125, 0.1853197086880517, 0.14205286095113967, 0.15293016489300804, 0.19262558754929038, 0.14280788651732468, 0.15475840052996792, 0.15203454542699602, 0.19209975588073414, 0.016443986360237584, 9.999999999998899e-05, 0.0364165792847172, 9.999999999998899e-05, 9.999999999998899e-05, 0.0024907208767454003, 9.999999999998899e-05, 9.999999999998899e-05, 0.022000942497750975, 0.178680385737904, 0.10139079999123735, 0.1351699038757863, 0.04826429404139676, 0.05511554928866791, 0.050172482963128484, 0.07999714000793101, 0.08968407538213052, 0.0899925727641594, 0.032270970781948405, 0.04708131767359025, 0.020944814040039672, 0.021955357697829303, 0.04297523839001205, 0.041469333354407945, 0.055791541852591386, 0.02277301687654798, 0.04914526725632473, 0.0818329565594269, 0.15441849840143018, 0.07253978068358424, 0.13486953504655608, 0.12836185079053797, 0.11342299244928367, 0.07475380943285981, 0.12229890780706787, 0.07333309113252184, 0.4448034237497672, 0.40345462633797846, 0.431375961341823, 0.4329832910465171, 0.4269201990452547, 0.40495991752644933, 0.43119923720614384, 0.4475973945707318, 0.4413955085852781, 0.08871529663340194, 0.1286089494953525, 0.08467133126892223, 0.09298785126027509, 0.11144106989924263, 0.09322886281910414, 0.1279699078156653, 0.10909160019092556, 0.09524992941832622, 0.16729445199597337, 0.305129715803898, 0.16098686799513362, 0.2274535282643776, 0.21010695234205046, 0.19094327587237814, 0.23391009355741454, 0.18247576622360995, 0.25143801207073235, 0.34397695445670207, 0.29742811099236777, 0.2503710716769839, 0.2860905507774032, 0.34471555529816367, 0.3209604583873067, 0.3285223269284745, 0.33146178013697414, 0.2972114873527131, 0.22362314370539604, 0.2383316766496465, 0.17747709657303545, 0.22895849278439562, 0.20507497316565793, 0.2254898455062293, 0.2747805701726692, 0.24671455896134642, 0.21225001172837832, 0.21431341483625366, 0.21408433653954972, 0.2031742349580875, 0.23601244573628333, 0.21646060019340407, 0.2039775776520204, 0.23412798737163942, 0.2093685769503565, 0.19390616188936005, 0.1826912313207485, 0.23384470244525413, 0.19663790638940604, 0.22618773216608945, 0.20509226062278962, 0.1953498026450735, 0.2692628386798862, 0.21120716168695697, 0.19817304831379312, 0.18464295784669582, 0.17393475093207944, 0.15156729544420655, 0.6677147433617077, 0.19714665394076825, 0.1966189715812433, 0.40727180468744284, 0.16185989961033742, 0.7583015056283446, 0.4186335570137186, 0.5279702852397755, 0.5335452176545713, 0.206941705227646, 0.4009591903291645, 0.1520124959261011, 0.10393788686412408, 0.20468871378101539, 0.3710535850350889, 0.18052401039548427, 0.20541721103325472, 0.17524340054933363, 0.18262557646534505, 0.20943720001405286, 0.18764015712024162, 0.18260374334931206, 0.194294619023896, 0.17895709260721504, 0.10302681883746734, 0.08869575451547496, 0.07899487331079258, 0.09973828761974435, 0.0936818315362643, 0.0791520309372834, 0.07431106796387599, 0.08174998022485802, 0.08354781311676929]}, "mutation_prompt": null}
{"id": "a42f6fa9-888a-4e47-b751-febb616af089", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly increased population for better diversity\n        self.inertia = 0.7  # Increased inertia for enhanced exploration\n        self.c1 = 1.2  # Adjusted cognitive component for fine-tuning\n        self.c2 = 1.7  # Slightly increased social component\n        self.mutation_factor = 0.9  # Enhanced mutation factor for more diversity\n        self.crossover_rate = 0.85  # Adjusted crossover rate for balanced exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Initial clamping value\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Adaptive velocity clamping based on performance\n            self.velocity_clamp = 1.5 + 2.0 * (1 - (global_best_fitness / np.max(personal_best_fitness + 1e-10)))\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Adaptive Differential Mutation with dynamic factor\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutation_factor_dynamic = self.mutation_factor * (1 - eval_count / self.budget)\n                    mutant_vector = (particles[a] +\n                                     mutation_factor_dynamic * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedHybridPSO_ADM", "description": "An Enhanced Hybrid PSO with Adaptive Differential Mutation and Velocity Clamping utilizing dynamic inertia and mutation adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 21, "fitness": 0.2493523888664868, "feedback": "The algorithm EnhancedHybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.6661051870207613, 0.6325896431095044, 0.6192735505546901, 0.6536117038148921, 0.6351216535172508, 0.6509571931581533, 0.6569112603709972, 0.620259951404098, 0.59630833749926, 0.09910950951387965, 0.047710795488295155, 0.14065832840036996, 0.14455464767972082, 0.11975877614822783, 0.1910607522292468, 0.04372694570706448, 0.11202027057433694, 0.15132527882861246, 0.1965248721974554, 0.11930226491271567, 0.022781550611222556, 0.11680436347004908, 0.121392028749432, 0.1736093147757536, 0.12124555084025601, 0.16066602010445408, 0.1340631280812693, 0.039628143592825515, 0.055363535020594656, 0.12934699096570967, 0.10841166212073039, 0.10424171438386598, 0.13369411666876208, 0.09798472876603104, 0.14251085065078029, 0.12141274582613637, 0.9692291173353004, 0.9646538261636277, 0.9636069679815542, 0.9540438252851364, 0.9230861216822341, 0.9271314343618196, 0.9730662146148785, 0.9699642202831988, 0.9446852921912955, 0.3327874075339422, 0.3385363766793379, 0.29829809673433605, 0.33350717110192074, 0.3709347286151665, 0.32811909584684984, 0.375079017015158, 0.14308316644552888, 0.35581304315976303, 0.6748418459970728, 0.22657043625953188, 0.636432380744723, 0.2123631486649118, 0.2161663478622169, 0.2010642600725191, 0.5601247652601764, 0.5813581059389245, 0.4931706272855344, 0.18475519663645612, 0.15892560159081226, 0.23401496123857224, 0.08101112269711941, 0.10454333790536186, 0.0495934478000396, 0.1145406966634368, 0.1167003083967213, 0.15309902169760148, 0.1840271463607981, 0.11759190305746359, 0.18577517428883517, 0.14823227349023205, 0.1825735128605256, 0.16430546636464882, 0.2047285464937444, 0.18079098973103502, 0.11800694128249056, 9.999999999998899e-05, 0.007095490436921703, 9.999999999998899e-05, 0.031214784113033023, 9.999999999998899e-05, 0.013021471834404275, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08326059974835098, 0.031274265747463725, 0.17724869334636206, 0.11731897809709424, 0.08294173194761811, 0.0856081984532231, 0.06750574403498721, 0.0716376415955694, 0.056140128357075825, 0.028338404071839074, 9.999999999998899e-05, 0.10580300671443421, 0.09042252655432292, 0.10497485360659542, 0.05172593538958792, 0.13289520055882642, 0.054854483160812206, 0.13033969442922821, 0.20011031918897648, 0.05403908751165454, 0.16913987210464765, 0.0479518978326674, 0.1084296242415137, 0.12183202589549891, 0.02384796965227165, 0.035931510441478576, 0.03207434436810397, 0.4537588800258089, 0.49248949871848124, 0.44884285551304115, 0.4578915272489049, 0.4508653667642394, 0.45079256746869745, 0.47766020855508606, 0.4590566006545189, 0.4649375496158876, 0.11933973985700252, 0.097870094429374, 0.0912791031957666, 0.1042461084824301, 0.11136897609158403, 0.10709663075466691, 0.06374351548516699, 0.08680082609532291, 0.08773055529317775, 0.24437944990224614, 0.25168875804474333, 0.23364339425097225, 0.19065896513084613, 0.18266039412245738, 0.31757871761315026, 0.3446737232330028, 0.206970137446561, 0.23411212686147786, 0.16836171316870163, 0.15936298313525643, 0.17174648650497837, 0.3575703701800441, 0.2694620694390497, 0.3293970122696235, 0.32755843378937644, 0.36483782494561934, 0.27392665958786844, 0.179586520252485, 0.1715235565730745, 0.15198356548515024, 0.2617970273214222, 0.2582743916392537, 0.25218843128978063, 0.22420705903183025, 0.21675950682933853, 0.20472632500802423, 0.22860467568886655, 0.22022784321046307, 0.2157838790528629, 0.24722334697444093, 0.22581548640436577, 0.24040871885146875, 0.19467697705846376, 0.210430043491051, 0.2184187986344419, 0.1561214333606089, 0.15948898343647344, 0.17890773185457487, 0.20924356252725518, 0.19066605231215616, 0.20039735363831446, 0.22760421123729635, 0.2036118373670287, 0.19183973673937293, 0.7764743611220978, 0.18538350649474244, 0.18403681430545893, 0.7937668864826561, 0.1984321978352479, 0.19567613493503544, 0.7159050631105528, 0.16623556803936668, 0.7998250866593957, 0.5523238857055284, 0.20993695275239532, 0.49686203678883023, 0.20790411668189834, 0.16802062679868213, 0.6520542105169953, 0.17868211976904602, 0.17349562654557726, 0.2780211902077844, 0.18333063978010733, 0.1837611462192832, 0.18956173629661455, 0.19595840900908723, 0.193030057782826, 0.18740290521545433, 0.1759124308324208, 0.18415495872128962, 0.19391837537010292, 0.08655361074097145, 0.08109654787538434, 0.08502609787921678, 0.09077182567507758, 0.08975758489527053, 0.0956224330384563, 0.08634666884524778, 0.1006435359355613, 0.0806952272879744]}, "mutation_prompt": null}
{"id": "f2720c59-c2ce-416b-9ed9-0c68bd059631", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_max = 0.9\n        self.inertia_min = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor_base = 0.8\n        self.crossover_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_base = 2.0\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Dynamic inertia adjustment\n            inertia = self.inertia_max - (self.inertia_max - self.inertia_min) * (eval_count / self.budget)\n\n            # Adaptive velocity clamping\n            velocity_clamp = self.velocity_clamp_base + 1.0 * (eval_count / self.budget)\n\n            velocities = (inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            mutation_factor = self.mutation_factor_base + 0.2 * (eval_count / self.budget)\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_ADM", "description": "A hybrid Particle Swarm Optimization with Adaptive Differential Mutation enhanced by dynamically adjusting inertia, velocity clamping, and mutation factors for optimal convergence in diverse problem landscapes.", "configspace": "", "generation": 22, "fitness": 0.26040728327568285, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.6322901694509088, 0.6267600628409784, 0.6113906774667739, 0.6117631530592587, 0.6018088378316551, 0.6583174234573733, 0.6158143150325264, 0.6006756197494936, 0.6022578906577731, 0.23318260456424855, 0.2653762619083907, 0.23722832835253327, 0.2479970873602021, 0.19456319009768008, 0.2495963126483579, 0.24141845886863933, 0.21353844351814188, 0.2498334294005473, 0.1446247135587162, 0.14640042764116334, 0.1753492610370273, 0.13537603748963334, 0.13211064246128845, 0.1411277861224538, 0.16466430446199343, 0.14783065796540795, 0.12146181628801445, 0.11457807723534952, 0.11107486823099921, 0.12120008356142975, 0.1068594421341782, 0.11774925393766789, 0.1288732219361446, 0.1253062064456868, 0.1306878483792836, 0.10573769297824342, 0.9607246527630976, 0.9445703613804384, 0.961615754194234, 0.954336567824303, 0.9596398371231765, 0.9525189983420347, 0.9610408162583397, 0.9360546023872947, 0.9520786269497807, 0.3448565508496235, 0.36682046242078326, 0.3091161163117936, 0.3560913032323265, 0.3323577937616795, 0.34705640006021043, 0.32971159571243713, 0.3509435458349962, 0.328305119223385, 0.6829742526316669, 0.17047242755883674, 0.21801130822951198, 0.4503578588528041, 0.1883003137926046, 0.42711064006104416, 0.43625289160415515, 0.473722175103667, 0.3819522039748343, 0.1536650572304925, 0.10324583388409192, 0.12876142414574787, 0.09701399687091761, 0.14589738227828108, 0.14987298703148122, 0.1597078486431216, 0.16825303157873295, 0.15042429999954476, 0.12211148176579734, 0.1760245153470762, 0.1593289520119997, 0.17114951968940018, 0.16801224119761515, 0.15759334647851897, 0.1956780722710133, 0.19302871073797323, 0.19306084918426725, 0.04738628717399751, 9.999999999998899e-05, 0.021247901831155325, 0.03657172189111901, 0.046360655189971456, 0.0006208003633226822, 9.999999999998899e-05, 0.0060902286927162486, 0.019524130691303654, 0.11216842752545286, 0.060347632504363036, 0.13855454476938578, 0.10761093600126148, 0.04084450884971702, 0.10245997344742186, 0.08345750577268995, 0.09520736000462315, 0.16167138280407511, 0.14281751205261173, 0.07236136248733871, 0.0704208054985831, 0.057937707229237634, 0.042700301944882946, 0.10675600172869693, 0.05583056441360712, 0.1462856248069211, 0.12057893962126631, 0.09714958999235201, 0.09308795755473143, 0.1940125450894279, 0.12846897120831913, 0.1048613572088507, 0.08844602786397504, 0.04441028669579905, 0.04849365019846097, 0.06619748593681984, 0.43664249025913127, 0.42674195175983975, 0.4432406510721777, 0.474494774476627, 0.42548546857567626, 0.44966368584241423, 0.4583524998340812, 0.43042928170344685, 0.44846956248846126, 0.10084969779971475, 0.12544819261714424, 0.10719776919376878, 0.09970627607980131, 0.11026008436276802, 0.10696024529829085, 0.10140898910130036, 0.09390560181342844, 0.13065798723956923, 0.15977297980342642, 0.24738282469994366, 0.16629139584264452, 0.17112087043968005, 0.21140210926362357, 0.15183344770734875, 0.2733997996136963, 0.22053187758725645, 0.2248926153364813, 0.28063647467634323, 0.32726763085201105, 0.2409747876411783, 0.31413553373158853, 0.3396342554143291, 0.33794821059537883, 0.34527633251093004, 0.35373111155000214, 0.32452370730922653, 0.23533222927388608, 0.22087524372744438, 0.21217850769076574, 0.2457033526124247, 0.2787957509141761, 0.24780221229376043, 0.2441190323017729, 0.2537086353506839, 0.19537692522492356, 0.24105960962353978, 0.22179764359272502, 0.17757364082007276, 0.22401571508708595, 0.19563215986808324, 0.23120901504054903, 0.2338475727243784, 0.20116872097333238, 0.206520516265577, 0.20146998099477031, 0.1952928607775073, 0.18630018693296946, 0.22001083559337486, 0.22034334959748159, 0.1889302714503066, 0.4044858828972434, 0.19476108229247413, 0.2343870158863378, 0.7411964147953304, 0.18294490239380634, 0.16272457161877119, 0.7178075067022285, 0.19559598108867093, 0.1968128437602199, 0.15903440425228454, 0.6659706625563181, 0.7515707186350309, 0.5927170096117169, 0.20842208244807758, 0.5258763611292285, 0.20225239007037554, 0.638607564545494, 0.16578933011770292, 0.152695646105256, 0.5224199013386647, 0.48839123880965685, 0.18647657077353708, 0.20080636250661077, 0.18882331672035257, 0.19970180544900473, 0.19767201903367015, 0.18532984420711396, 0.18549436994897273, 0.2092068817602275, 0.18049008283017032, 0.08126701158444771, 0.08364701164544763, 0.10320859670413152, 0.07326864125041466, 0.08588625412371731, 0.08466297045037374, 0.08729468141546837, 0.08348787357095588, 0.09126221573390447]}, "mutation_prompt": null}
{"id": "9f4b6171-3309-4b5b-a752-9e892d0e203f", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for better exploration\n        self.inertia = 0.7  # Fitness-based adaptive inertia for dynamic balance\n        self.c1 = 2.0  # Enhanced cognitive component for faster convergence\n        self.c2 = 1.5  # Reduced social component for diversified search\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_rate = 0.8  # Balanced crossover rate for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0  # Increased clamping for broader movement\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Fitness-based inertia calculation\n            self.inertia = 0.7 - (0.5 * (global_best_fitness / (global_best_fitness + 1)))\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedHybridPSO_ADM", "description": "An Enhanced Hybrid PSO with Adaptive Differential Mutation and Fitness-Based Inertia for improved convergence and robustness.", "configspace": "", "generation": 23, "fitness": 0.3230082489617089, "feedback": "The algorithm EnhancedHybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.8857660201219099, 0.889487252584947, 0.8869175120585923, 0.8783092588396174, 0.8877853076383762, 0.8786261273722797, 0.868633331509602, 0.8642359323019995, 0.873406168501601, 0.7452806739591633, 0.7381280200258529, 0.7431539449417642, 0.7238255965164724, 0.6878737654292879, 0.7125629644141406, 0.7476202424755409, 0.7185369701994315, 0.7646512168031014, 0.17377691047142707, 0.1466697342122696, 0.14441587569744352, 0.15350379727822405, 0.13983030098377458, 0.15200804414466618, 0.17287730647776134, 0.15477363312072612, 0.17787460963161317, 0.17071638399745226, 0.14155647883480016, 0.13560999622281178, 0.13606015097983493, 0.1612973578428184, 0.12568743290094841, 0.11960985227100229, 0.13540071440618906, 0.13669061332708965, 0.9642885964858413, 0.9389922523527277, 0.9542902780553314, 0.9468567673254661, 0.9425938489390975, 0.947392002666199, 0.9560477961947138, 0.9482305902251764, 0.9542194144222239, 0.6512742149691755, 0.5652828399797014, 0.48666989782078995, 0.6019508443141401, 0.4731587354299218, 0.14937215578925866, 0.48652412607240936, 0.5192666365257846, 0.5875710270334153, 0.2131451329570797, 0.34061902024563173, 0.756261898349766, 0.8262579883520533, 0.8770328972035517, 0.27836212019681994, 0.5870784372734535, 0.23582153169478037, 0.23349994153547837, 0.44102832929394087, 0.18178799574084203, 0.28924062509042925, 0.12087213623291881, 0.1906638966987041, 0.1843953426815237, 0.17955618449052313, 0.11684357908061616, 0.17829067634660456, 0.18750831129686818, 0.21696028353621222, 0.1881472002939668, 0.22066730754233532, 0.21170039168537824, 0.21830143882084996, 0.14530198788172433, 0.23158989697404708, 0.1257597923444862, 0.00951333823279732, 0.021257635331343727, 0.15184423222051924, 0.04085503103938959, 0.052334178302588574, 9.999999999998899e-05, 0.026410821140237073, 9.999999999998899e-05, 9.999999999998899e-05, 0.10865303915717739, 0.07315907265042365, 0.06348476036279538, 0.11009735477170612, 0.09699145084870886, 0.044700930248090076, 0.12749966038151817, 0.0722342970338059, 0.11962397126477031, 0.154506416190621, 0.10127245730612688, 0.1467875388487493, 0.08210292622490578, 0.3477152549972494, 0.09513126483211687, 0.10024656790587194, 0.20622394681118772, 0.14459770043309594, 0.15589140161783688, 0.13120605688662967, 0.09175235358674616, 0.03664709730351079, 0.11572022506195279, 0.3318504630879644, 0.1454113894755621, 0.17937783464961032, 0.35344750777931544, 0.5555830689978387, 0.5023161249106163, 0.56722200966076, 0.5393506775076695, 0.5587476397162802, 0.5689275232086565, 0.5653318782473428, 0.5579788135983026, 0.5635109129456446, 0.1409072104695822, 0.09580064404555722, 0.0911187632964251, 0.11177786728117356, 0.13504861822237002, 0.09874966746918601, 0.12701728187003536, 0.0998594428662074, 0.14554654268804512, 0.4019088730010105, 0.16812398656276584, 0.19675940509353518, 0.20185701445410076, 0.27964963213431293, 0.2724991726246301, 0.22422553457759375, 0.1871020375713367, 0.2012359192253994, 0.3610416661299062, 0.3108268779028073, 0.29183302271735145, 0.29373078763591054, 0.32679675171174893, 0.332804541316137, 0.26303357149772577, 0.3516532465279041, 0.37425666680814307, 0.19996838437992903, 0.3333717726366272, 0.2982417285887774, 0.2521831836059847, 0.23276071415743627, 0.2126015386286333, 0.2367036970873111, 0.30025924081266775, 0.2163448685877556, 0.22180166202972074, 0.24057129537494837, 0.19457781520477702, 0.21722390108998813, 0.20959476832553958, 0.21843524116997826, 0.20716815437547165, 0.22299046798210675, 0.20226099932981356, 0.24092214303861204, 0.22286331398535908, 0.19331394101826493, 0.21047387482031799, 0.24844876645985325, 0.2066491056398675, 0.22067521355595898, 0.7476140570716739, 0.20957215311051147, 0.8588178373572207, 0.5732264122471676, 0.16781090269421495, 0.22821142295874608, 0.19508150852561823, 0.23469892510906443, 0.792360557277347, 0.1676688037040731, 0.8988021140149506, 0.6445811842352305, 0.21012392592588436, 0.07344647647080149, 0.5839474387169579, 0.1684489663251577, 0.16792946770003803, 0.10447717519438249, 0.1649599294747195, 0.8040678995319006, 0.1805146596382312, 0.18906499458073844, 0.19311324383762607, 0.20205750763731445, 0.19467157923206446, 0.19830747458136166, 0.19100696397872985, 0.21106948758242938, 0.2559190114607671, 0.10724134767826221, 0.09331687708351033, 0.09325044934276105, 0.08644496173122429, 0.08095637542524436, 0.09307942754090914, 0.12971107222473188, 0.09356834686159432, 0.09341760836481594]}, "mutation_prompt": null}
{"id": "2e0335fd-5654-4d92-a22a-707320f34291", "solution": "import numpy as np\n\nclass AdaptivePSO_DDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Sufficient population for diverse sampling\n        self.inertia = 0.6  # Initial inertia for exploration\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.7  # Enhanced social component for convergence\n        self.mutation_factor = 0.9  # Increased mutation factor for exploration\n        self.crossover_rate = 0.85  # Balanced crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Initial velocity clamping\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Dynamic inertia adjustment\n            self.inertia = 0.4 + 0.2 * np.exp(-10 * eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Dynamic Differential Evolution\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptivePSO_DDE", "description": "A sophisticated Adaptive Particle Swarm Optimization with Dynamic Differential Evolution integrating stochastic perturbation and variable inertia for enhanced optimization performance across diverse problem scenarios.", "configspace": "", "generation": 24, "fitness": 0.32052759665630637, "feedback": "The algorithm AdaptivePSO_DDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.8328975964618603, 0.811520723344756, 0.8190095511796236, 0.8256381484378648, 0.8113884746373451, 0.8088731013626065, 0.8166254269900253, 0.8189339636747759, 0.8093065083524223, 0.6074673967700621, 0.6404701389053291, 0.6348087621249179, 0.64309303388123, 0.618943117927054, 0.6522933489941607, 0.6071726819544108, 0.6157423789536848, 0.6307656720193346, 0.14849119670048128, 0.1598983332814069, 0.11768828302848577, 0.14615430043873034, 0.13248726378375308, 0.14828869694113112, 0.16438200213908805, 0.1772833792744144, 0.13580311567195336, 0.11794640621367802, 0.10721869700941589, 0.12857231348064702, 0.12624750312459276, 0.11074631370331278, 0.11651695606329049, 0.13247685305256585, 0.10979107843571523, 0.1053280533734493, 0.9597691599193179, 0.9445626075148439, 0.9602301115269464, 0.9614290008949432, 0.9678649253658858, 0.9616407739341739, 0.9703189693326003, 0.953120888970584, 0.9562447781560781, 0.6497776476826782, 0.5543902811935997, 0.5527713494391417, 0.5892698110167245, 0.5573904756136407, 0.6176972368752265, 0.6069345330809752, 0.536615973687913, 0.6371813531138748, 0.7918723511925797, 0.3730511621491098, 0.37409401838691625, 0.8398156287275413, 0.1928575791605721, 0.2750957214877946, 0.6789178422571687, 0.771442993678146, 0.22864469213230842, 0.20775177574776893, 0.1304817845570746, 0.19517127422667668, 0.19382912209917635, 0.20454532976771522, 0.1607152495952161, 0.20829422142713072, 0.1963931417731224, 0.20718192697407534, 0.207587367403138, 0.2047485862773466, 0.18908223104606148, 0.22495818334622997, 0.2422544300632692, 0.22201209812981892, 0.21181442027107988, 0.10216928973361938, 0.2345189403243545, 9.999999999998899e-05, 9.999999999998899e-05, 0.027568604172564126, 0.02694942248384191, 0.19407550010207053, 9.999999999998899e-05, 0.00949056015627936, 0.07085252285589883, 0.10146637992903285, 0.13926600619807283, 0.07190695311660766, 0.12368695180215727, 0.05502753588983067, 0.039760050993810525, 0.06954537045786802, 0.0809821336113935, 0.20737544315499412, 0.09965925494041983, 0.04466231879083238, 0.09796772106708829, 0.16406929803482306, 0.1832092965286729, 0.07947702189108752, 0.1240231560438757, 0.08705532310536779, 0.0899957022690987, 0.06613947359372174, 0.2651334102799312, 0.12381290526938793, 0.09735590058247545, 0.006156703765267446, 0.08686114598707295, 0.16757134492843984, 0.0472320211499615, 0.04678454046392777, 0.08098411290101826, 0.5665815359206003, 0.585248724021944, 0.5539204043318184, 0.5616913007617248, 0.5339341761839805, 0.5340653895708642, 0.5682382535593848, 0.5423868476775806, 0.5410969332210772, 0.1262782106687329, 0.08841427232381849, 0.12803967674478955, 0.13557926992589997, 0.11236392581382548, 0.11222875903686858, 0.14522697815314656, 0.12379988000951125, 0.15378984462849343, 0.24127105781972613, 0.24965355698866598, 0.15155956490675493, 0.6213015248920887, 0.23639140462127817, 0.2626316439119456, 0.21412372199482077, 0.4642172217681494, 0.1893958733889023, 0.3904882461524337, 0.3898912590682797, 0.4149004446104334, 0.44415691499692733, 0.36833399492215035, 0.3349852911174185, 0.5369215875385593, 0.45187381542568816, 0.25228309429274, 0.3099163415540437, 0.21854213697056746, 0.25134651993687795, 0.28100106845791617, 0.20280585440362386, 0.33031104683539647, 0.40518978030974695, 0.2681467910887655, 0.21505240271275472, 0.24175454487861003, 0.18494005938559877, 0.23882539161868188, 0.20783075741465096, 0.2206792822228072, 0.3074050821654357, 0.22113382750413668, 0.2083927567393814, 0.283013602048902, 0.20992201231963037, 0.2334215105044961, 0.244897613398379, 0.20524203851012146, 0.1964595572550405, 0.18500671990402717, 0.225581093716005, 0.19375679779380584, 0.2038173934178371, 0.16403722779258934, 0.17668037747102494, 0.16447937201838791, 0.8769001980681648, 0.19918166997707754, 0.1994724633458761, 0.1746021982678181, 0.1668613208731513, 0.8815529762142725, 0.6451120240895184, 0.20760307775533637, 0.6321237348196848, 0.20858716166366886, 0.15475562669034626, 0.15286626320150432, 0.735068373972015, 0.7164144673051718, 0.7539063646571312, 0.20951459171091835, 0.18570245310065925, 0.22223073885021238, 0.19111238878692716, 0.1815351326503375, 0.21115276497297064, 0.18700814988342518, 0.18737954533621815, 0.20034211261217383, 0.10441801965176911, 0.07705979665057383, 0.11039717544095529, 0.09220923283772131, 0.10313647267945503, 0.10038928447751272, 0.09855820210328148, 0.08887485590958333, 0.0778923804278504]}, "mutation_prompt": null}
{"id": "9ffc8938-de13-41d3-8414-e6b2fb89e168", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for better diversity\n        self.inertia = 0.6  # Slightly increased inertia for improved exploration\n        self.c1 = 1.4  # Adjusted cognitive component\n        self.c2 = 1.6  # Adjusted social component for enhanced cooperation\n        self.mutation_factor = 0.9  # Enhanced mutation factor for diversity\n        self.crossover_rate = 0.85  # Adjusted crossover rate for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 1.5  # Reduced clamping for finer adjustments\n        self.inertia_decay = 0.99  # Introduce inertia decay for dynamic balance\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Decay inertia to enhance exploitation over time\n            self.inertia *= self.inertia_decay\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply hybrid mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedHybridPSO", "description": "An enhanced adaptive PSO with hybrid mutation strategies and dynamic parameter tuning for improved convergence and solution diversity.", "configspace": "", "generation": 25, "fitness": 0.3121804634663187, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.7898406700442479, 0.7936576574315958, 0.7751631542931865, 0.7765866271733771, 0.7875645301453278, 0.7993846206276018, 0.8053149903073623, 0.7809874619705572, 0.792246577070238, 0.5703762217232773, 0.5489212034985704, 0.5476777770835923, 0.5650108742810082, 0.5472072156550192, 0.5345625516316952, 0.5165100442954431, 0.5389172009646994, 0.5418081981379604, 0.16293772096522685, 0.15771678806272793, 0.16720962402330464, 0.15547802040611802, 0.15082964353699413, 0.12713006504953317, 0.14286128141025367, 0.12638727371076053, 0.16692347942844643, 0.10515155186031477, 0.10974680315192387, 0.11203449760066053, 0.1440423316725955, 0.15488005527686655, 0.13226125981894676, 0.4239414049821716, 0.12539237073785658, 0.10666685779634588, 0.9515093780152595, 0.9327586441670537, 0.9218097776919267, 0.9373192643884354, 0.9166765361608558, 0.9246670826340103, 0.9361116370921034, 0.9461732030945974, 0.9260068406789874, 0.5750018831402046, 0.5983902975100579, 0.5877120080541546, 0.5719501570551544, 0.5979302628142508, 0.5955712527771743, 0.5741193550237884, 0.5927961178278025, 0.5563464823361377, 0.7967414397264778, 0.7492145891952748, 0.7867827578299721, 0.2740634357906281, 0.21347895314822785, 0.26626449213784176, 0.22706351467700303, 0.23629217426656612, 0.5875178730469327, 0.19513798094415513, 0.18890704139552805, 0.19037425263025376, 0.1786807253918965, 0.18438160329190345, 0.17940457257696485, 0.21346709233087424, 0.1919490726030757, 0.1276310154708009, 0.20697786199933965, 0.10379985016895155, 0.1838484546194279, 0.20600517933678963, 0.20887259563757676, 0.19980744470395717, 0.22945690318159384, 0.2769548448885787, 0.1997329967816438, 9.999999999998899e-05, 0.17962419952016717, 0.0432164182798318, 0.0008570931649859448, 0.005132732734671852, 0.05758447459709093, 0.03582116229924337, 0.010328784374885824, 0.002278544166788188, 0.13446365315586895, 0.04854359815883491, 0.1759648709663516, 0.10750699857694579, 0.06486583976817839, 0.07689269330419468, 0.15320481326105384, 0.11703057856933141, 0.10307485314707576, 0.11238209587341685, 0.10272677669288022, 0.15563942661721086, 0.23127575142576784, 0.14486714862252703, 0.2680625738567576, 0.08636961732912318, 0.1951711470513905, 0.10918448323860919, 0.19273890306652097, 0.04032248691647511, 0.11870498904093507, 0.0875321011914677, 0.23375460877976062, 0.20950041984875856, 0.18861695682502677, 0.05288799936860866, 0.1725560882452044, 0.5273826156507224, 0.5231040536421858, 0.5523965463100164, 0.5160080536006354, 0.5309527638433613, 0.5757818485544308, 0.5396865433514311, 0.5478008722450487, 0.5490415611547887, 0.10584768249290266, 0.10700519299916722, 0.10681898895051067, 0.09362669024864245, 0.11481641075520943, 0.11731852203590876, 0.09170304336303237, 0.11612150392869847, 0.12303363533975387, 0.24371291245503002, 0.24140321414906563, 0.17598785969976904, 0.1726322207951282, 0.40701373979966715, 0.2610114347467317, 0.17361139743159548, 0.23509681507786717, 0.27907679559145115, 0.31294163883690496, 0.37330029110388996, 0.39426315802755785, 0.373863877994296, 0.32228544825673544, 0.44891937697863793, 0.4532630989173978, 0.5445224193778826, 0.4945628380442535, 0.24935106101277726, 0.1647906827524679, 0.3117475572274584, 0.3095259110124323, 0.26880274154466877, 0.30226661411507993, 0.22756639994769656, 0.26165729638749435, 0.2547800960705857, 0.20294033205709516, 0.23275994504531505, 0.24048111460607446, 0.23654501470393474, 0.2320260809659037, 0.20158046380560302, 0.21280552017714494, 0.2781830255029428, 0.22941855944014522, 0.20257657097285742, 0.21047650781060523, 0.19426592743416948, 0.6676201432656499, 0.6430089917962978, 0.18278655380932118, 0.21939453959513344, 0.1860720247395813, 0.2337293254778875, 0.18573571304017833, 0.18614842620587368, 0.18631976246152493, 0.8985435191201474, 0.167883501081454, 0.16910308039302113, 0.14190677865502166, 0.16584011940179133, 0.8463125172244581, 0.7252702448540124, 0.2106279722219514, 0.5189228028459196, 0.20880304563992025, 0.1680515940002919, 0.20402619149804269, 0.6613250888102234, 0.10412391286657108, 0.16355829445385972, 0.19496893079727973, 0.19633269576937307, 0.18725323429464724, 0.18162479927651443, 0.18951741708558434, 0.18745163694418265, 0.20275531510006195, 0.18916621566671477, 0.20242085642264773, 0.09341324742798895, 0.09869734594524582, 0.07814993649301727, 0.09365008593991919, 0.08625399413295731, 0.09839621755539207, 0.11815191466419361, 0.08415034648693231, 0.08527690082535266]}, "mutation_prompt": null}
{"id": "8fd471b6-b33e-4426-bf21-15c8802a5823", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly increased population for more diversity\n        self.inertia = 0.5\n        self.c1 = 1.4  # Adjusted cognitive component for enhanced local search\n        self.c2 = 1.6  # Adjusted social component for enhanced global search\n        self.mutation_factor = 0.85  # Slightly increased mutation factor for more exploration\n        self.crossover_rate = 0.8  # Reduced crossover rate for better refinement\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Stochastic inertia adaptation\n            self.inertia = 0.4 + 0.3 * np.random.rand()\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = particles[a] + self.mutation_factor * (particles[b] - particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedHybridPSO_ADM", "description": "An enhanced Particle Swarm Optimization with Adaptive Differential Mutation, incorporating stochastic inertia adaptation and diverse mutation strategies for improved exploration and exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.3054522060048131, "feedback": "The algorithm EnhancedHybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.7932972263278135, 0.7823889921788602, 0.7727236668099777, 0.7821323841778421, 0.7775364297358488, 0.7697876210587384, 0.7910646729638329, 0.783997755689486, 0.7837415263408283, 0.494457586936076, 0.5122893905470651, 0.4820402425601258, 0.4781133108324591, 0.5122601231555876, 0.5206864124603756, 0.47283093464494896, 0.4991946822508586, 0.4198869161801263, 0.10996984890972472, 0.14913280807932883, 0.13296839752101752, 0.13797083764614926, 0.16186390986014343, 0.10063725885001773, 0.1411915010042607, 0.1437721655691826, 0.1654035312059977, 0.11493748023669381, 0.11209313729608184, 0.11875572381266808, 0.12628181728613586, 0.12793469532631951, 0.10870733796097864, 0.14255681157452016, 0.15961498859764356, 0.13750676749884327, 0.9540439721116959, 0.9529403006697581, 0.9538225059384126, 0.9376221178562387, 0.9382229120348163, 0.937187100856178, 0.9574547852881764, 0.9575210847950896, 0.945729962598632, 0.5602257976019118, 0.5083576426447514, 0.5073199189300812, 0.5238698453140951, 0.5223388615641371, 0.5357979636382246, 0.4797839069877232, 0.48142524397304154, 0.4816475521813941, 0.2243919651908477, 0.5421977358067466, 0.5945922166898482, 0.2731128110504816, 0.2780663294969431, 0.19911436594491538, 0.22795642480660572, 0.2324431328552986, 0.3558755959329697, 0.21082125391163076, 0.10890887288496465, 0.18597126257980812, 0.10811097380820323, 0.22295545053494248, 0.22496662282590674, 0.19027948963811736, 0.19426170930242892, 0.18417716439922527, 0.2058173315906242, 0.1312320702210119, 0.18040798537782177, 0.18665718762367645, 0.216010396997536, 0.19723440235209688, 0.22219315764244807, 0.21855012941015162, 0.23214231119044526, 0.04451761690052658, 0.0001894087128277988, 0.05193241251448821, 0.044597502402183964, 0.01674893632248753, 0.004136905483075326, 0.001094966513077944, 0.008646240289458929, 9.999999999998899e-05, 0.10868553424061933, 0.1421150097761381, 0.1727746328766987, 0.1285873934464542, 0.16531816942320787, 0.0473913314536365, 0.1045750454533887, 0.11675391335320529, 0.1138336157470079, 0.11512070810010899, 0.1016648494268464, 0.19539359406049583, 0.10333813738414532, 0.258418737895624, 0.21660705149722226, 0.1933147232849629, 0.1744831216203403, 0.22631506470350382, 0.12367673014362102, 0.07457531853180188, 0.058136886173608016, 0.12691641136940657, 0.09036461719229827, 0.2543534472652357, 0.07819135176075942, 0.07787700148789045, 0.07839018667971065, 0.5352919332100656, 0.5180294591550799, 0.5046708841378433, 0.5268493922790631, 0.5426431332496439, 0.5092995010436243, 0.536861582372446, 0.5506538197963271, 0.5194162145478444, 0.12300207548664421, 0.4042665058167916, 0.08999620279309073, 0.14903144963339743, 0.07412547985007967, 0.1272868551260774, 0.13641062823791794, 0.1394015557818049, 0.4264276211924426, 0.2676878594767821, 0.2046067288571799, 0.2084657125622592, 0.1903774920318887, 0.4744689193659396, 0.33363796597434503, 0.19723870307864866, 0.42023099684926024, 0.286556915733719, 0.42917674866266353, 0.3202395795394366, 0.3891242658942604, 0.34137374251633434, 0.3391369604345911, 0.39213069107779197, 0.44347023665780416, 0.44144249085033094, 0.43538574776190264, 0.23389414672206765, 0.3365796241384623, 0.34359090809093173, 0.2637834153525801, 0.3028338643409243, 0.24932037717636213, 0.24227096927528335, 0.27833928818318454, 0.20982684247849115, 0.21222838224969465, 0.2370490814505808, 0.20064101235629228, 0.2126687613511502, 0.18982332020354797, 0.23236099792141052, 0.2609809286796958, 0.21361247597323685, 0.21968858425152282, 0.20123582818661157, 0.21754548242561544, 0.1911465462907732, 0.20521770328398048, 0.579369181969111, 0.2008096763184254, 0.2395557646554629, 0.24075185826376522, 0.21200041559553062, 0.16415264447192257, 0.18744063826512525, 0.18715461715497628, 0.9024791322358197, 0.19953657271242053, 0.16919501104908763, 0.8035674894276847, 0.16657820220790998, 0.8390007439568156, 0.6580077401309015, 0.20986306977623448, 0.6034650425831685, 0.2094507761711195, 0.551767154463991, 0.15285645109823476, 0.10473596188665124, 0.1663594076133913, 0.8079641081048019, 0.17392886861154766, 0.18589376913630173, 0.20834952175020383, 0.19459554089776554, 0.18864587860323634, 0.20058475604679382, 0.18022768082474283, 0.1727623415161721, 0.18340384438690138, 0.0975490741449987, 0.0878154366177254, 0.08155670722690012, 0.09778118556689208, 0.09713093295144881, 0.08403436689346422, 0.10582595822961371, 0.08442305479454426, 0.09142603568741048]}, "mutation_prompt": null}
{"id": "5d011b75-a70d-427f-b833-d7d2118b61fa", "solution": "import numpy as np\n\nclass EnhancedPSO_SVA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly increased population size for better solution diversity\n        self.inertia = 0.6  # Modified inertia for improved stability\n        self.c1 = 1.4  # Adjusted cognitive component for better personal exploration\n        self.c2 = 1.6  # Adjusted social component for better global exploration\n        self.mutation_factor = 0.85  # Slightly increased mutation factor for diversity\n        self.crossover_rate = 0.85  # Adjusted crossover rate for exploration-exploitation balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for balanced movement range\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedPSO_SVA", "description": "An enhanced Particle Swarm Optimization with Adaptive Differential Mutation and Stochastic Velocity Adjustment for improved exploration-exploitation balance and convergence.", "configspace": "", "generation": 27, "fitness": 0.31059314992029563, "feedback": "The algorithm EnhancedPSO_SVA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.7424434645657427, 0.7172969830647316, 0.696947530108787, 0.7266445744171364, 0.7057521202275739, 0.7388159945158537, 0.7296837737119697, 0.7398394617541568, 0.6858126133145321, 0.36107187001733665, 0.38104939642253255, 0.3475844399608716, 0.3870416128396986, 0.3917002364797667, 0.3712080876840459, 0.3920831756620735, 0.37638928817926975, 0.38568781399829566, 0.14634883252501718, 0.13168935027592965, 0.2467373230543718, 0.1475752075704011, 0.2606225867142502, 0.2770038478882251, 0.14041129025231258, 0.13898600104395953, 0.19774211164960065, 0.12432183916252726, 0.1245060040044238, 0.1394234319066756, 0.12194926560528496, 0.12677760007414163, 0.12221507546557098, 0.1325803892334212, 0.11736865793932572, 0.13542946022155977, 0.969992881039629, 0.945650593740826, 0.9458233437498923, 0.9593190182804738, 0.9467188631309501, 0.9611318979737942, 0.9524202004261362, 0.9612959841376675, 0.954509933217588, 0.4201885818076151, 0.4224575206671578, 0.4548020149058227, 0.4497929297799155, 0.35901291506297506, 0.39467692373582064, 0.3947382277401793, 0.4002710320038303, 0.426133345087114, 0.7331415612868217, 0.6316791315302881, 0.70539535629706, 0.7025099624779019, 0.6017808106810616, 0.6207579018694356, 0.697554119730013, 0.7716269357136494, 0.627394674818631, 0.18448579289535083, 0.11674968031153166, 0.21895987586770138, 0.2133945720774505, 0.21603354564737953, 0.2026272893427261, 0.20713552549558223, 0.20102771861065472, 0.19020465942897458, 0.2023716094620609, 0.2341502797489209, 0.11389974092921473, 0.22867866034944118, 0.22921875390012425, 0.20987351602479876, 0.23516536157646584, 0.20812294996202896, 0.2118728934058206, 0.05016908999010172, 0.030572142104211886, 0.07515457534902947, 0.015504107223917929, 0.022667587391991928, 0.030728237932429847, 0.03106335396952198, 0.03245012669108038, 0.035030675001440637, 0.20329988847480385, 0.12002126058584583, 0.12889963191823262, 0.1319361182102744, 0.1406007105148872, 0.1194190689477802, 0.16729676075598054, 0.1535800778006351, 0.1463841140746519, 0.09708334960497977, 0.04331159650972438, 0.14419705181397569, 0.06958560279755166, 0.06589261264537194, 0.06906485455289946, 0.13736370569040368, 0.0761829808519422, 0.07756414161204794, 0.15110252466507812, 0.15039797454134274, 0.19238543707109879, 0.12762896091405818, 0.1440801962604894, 0.14148769430881747, 0.1750118785197623, 0.09675363652896662, 0.16022830490401707, 0.48518947533123236, 0.5045075310000862, 0.5110584422510818, 0.48069419985936634, 0.5126285884458803, 0.529119026485903, 0.5325652290159003, 0.516367343478205, 0.5292061824529753, 0.16918714714782257, 0.11521677721662782, 0.11107400413159363, 0.10694556133773536, 0.10733013325122864, 0.1396818379926088, 0.3979627408131706, 0.1627336465107957, 0.12739005249174407, 0.19388332339896663, 0.22211665583565343, 0.3380792980486764, 0.38450855057394995, 0.19789576285374078, 0.2044825790835464, 0.21838116305165822, 0.2416248137886733, 0.18440873280993886, 0.37798280844979504, 0.40042098113381774, 0.3506746583181918, 0.38546355438769253, 0.39590311416861945, 0.36425341550740675, 0.4279472439483044, 0.41565738982249134, 0.39632792164924013, 0.2651296707382549, 0.2422784710462199, 0.2243401399606718, 0.28932423885229974, 0.30296337519013505, 0.2339212268431643, 0.35179309880368603, 0.2985515189036161, 0.2373699783164418, 0.21464350855533243, 0.20541013628172233, 0.2137755122954047, 0.2047198727489039, 0.2081747358212489, 0.2119936930588413, 0.2058767816013507, 0.20512170441937905, 0.21311549014087994, 0.2147065085700406, 0.4396602493826305, 0.40394989503532375, 0.45792353284526155, 0.3760739627178259, 0.23130153058094716, 0.2294407836984459, 0.20063750328761953, 0.23986962701447734, 0.18119471392861553, 0.18692912983516796, 0.18319786331444132, 0.8341674395302336, 0.1981798603307754, 0.16795549536290144, 0.735326560507167, 0.701364574203668, 0.8173638355722564, 0.7576991130232342, 0.21100074087108356, 0.2052833842353885, 0.20909790362944014, 0.5963356933894693, 0.1508048372419526, 0.10468820813209456, 0.19547043951047538, 0.6506247187701559, 0.19420283962770657, 0.1820760578156202, 0.2050075771109907, 0.19736397480315626, 0.21614678978773605, 0.19403787531268013, 0.20243368196329636, 0.1969425360579008, 0.19848324815896845, 0.09941752448178232, 0.09514334413732906, 0.11598328857070428, 0.10183449956708046, 0.08225005258044549, 0.08586965225116638, 0.08304520159458584, 0.09033932368980735, 0.10233194296074433]}, "mutation_prompt": null}
{"id": "1b76a162-1323-496d-b522-49fb580e2e9e", "solution": "import numpy as np\n\nclass DynamicHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for better sampling\n        self.inertia = 0.7  # Adjusted inertia for enhanced exploration\n        self.c1 = 1.0  # Adaptive cognitive component\n        self.c2 = 2.0  # Adaptive social component\n        self.mutation_factor = 0.9  # Mutational diversity enhancement\n        self.crossover_rate = 0.85  # High crossover for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Adaptive clamping for refined movement\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Adaptive velocity clamping\n            self.velocity_clamp = 2.5 - 1.5 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "DynamicHybridPSO", "description": "A dynamic hybrid PSO with adaptive learning rates and dynamic social balance for improved convergence and robustness across diverse problem landscapes.", "configspace": "", "generation": 28, "fitness": 0.25674510143676504, "feedback": "The algorithm DynamicHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.6246003707566251, 0.6220508558403954, 0.6049952024135944, 0.6367961910660853, 0.650187540040122, 0.6242924944024522, 0.5999377564038246, 0.6341532707098765, 0.6634336322398953, 0.18270851300684732, 0.2717657452779789, 0.25668464472480834, 0.2587263712103328, 0.28470273344590125, 0.27115863805920526, 0.21734301022308355, 0.23416877154886206, 0.30712729040649056, 0.13684412699457027, 0.17447973673683592, 0.1164341282293404, 0.11018194439722762, 0.14257414078088326, 0.12846714839633644, 0.12219925184032077, 0.12283097416966715, 0.14317006194546267, 0.09400764275651896, 0.10412784412289222, 0.12552930859528932, 0.10371260533646143, 0.10143483386720964, 0.10397066020894197, 0.11362779099832243, 0.11058399308185507, 0.10216644051212476, 0.96027996631651, 0.950444847043562, 0.9628207905836009, 0.9672502970708083, 0.9618792502903618, 0.9678170068107036, 0.9705291664925705, 0.953858062694805, 0.9533918329541574, 0.34410774985942416, 0.2945201211098283, 0.3551677366978925, 0.3740597763891651, 0.14993593404427297, 0.36437298986896305, 0.34182882584212204, 0.08848711781142571, 0.31430120998465805, 0.22265913976670915, 0.1712792026610268, 0.5163292545999794, 0.19175426021079367, 0.19180478257801492, 0.19036559737106717, 0.3846526730662496, 0.5320290252844908, 0.7224212264346404, 0.2550039294076548, 0.10516730849773248, 0.20559709349370914, 0.16450764416782115, 0.2763768254355141, 0.17930743329926158, 0.10832484279227361, 0.17169072719616219, 0.16736956810310333, 0.1862172908142321, 0.1847641896344714, 0.12152584965378954, 0.15372916541360426, 0.18020655523851925, 0.18029515684794573, 0.2124434234364858, 0.12250246069837245, 0.2308920560248513, 0.014005704955404541, 0.026551781488172166, 9.999999999998899e-05, 0.008348620886889369, 9.999999999998899e-05, 9.999999999998899e-05, 0.042534308591103076, 0.03182751365874592, 0.006186836841661325, 0.1270065574629613, 0.06324656572742227, 0.06362504453277851, 0.08299311719215952, 0.03749284103132322, 0.05346542075749772, 0.04230799272791297, 0.2043113143351305, 0.06832646801917885, 0.10478893100179176, 0.15982232470517588, 0.05680127912882815, 0.06594220138039708, 0.051342061243894066, 0.0932733001963586, 0.06473840164480293, 0.09025475395553895, 0.06679765031061902, 0.13925483502396763, 0.12264741400667667, 0.14902159932712689, 0.1099264055914928, 0.17176839584089743, 0.13948377012817148, 0.16309194056464926, 0.13254227494891146, 0.07361255632757291, 0.46114830006631924, 0.4642151905802333, 0.46077885167294685, 0.49681320155249475, 0.4293321607008326, 0.4516025499083187, 0.45516586899304456, 0.4694888144599142, 0.4501925138034263, 0.10076667464839517, 0.08933811585414209, 0.08594897671899249, 0.13320103984865161, 0.0759136552012536, 0.15231530728876952, 0.12809480504871695, 0.11825642405169368, 0.08167732630443192, 0.17560183125748063, 0.2303578682335473, 0.20936855442855806, 0.34507281253246447, 0.4161146848695212, 0.1917680510419837, 0.24445679669466847, 0.22168124300856284, 0.14052739692733085, 0.27246277100510896, 0.3392328872812491, 0.35188539152061016, 0.2920584193979935, 0.2015980947808279, 0.3632468713417083, 0.3305964441018493, 0.36591778585283763, 0.3572846466316637, 0.22976184376701092, 0.2587172094847944, 0.2797011011979671, 0.2340722273343785, 0.18377525698020936, 0.29878301477088776, 0.2738308774365176, 0.2570305928117549, 0.2653271844013724, 0.21300333084893264, 0.1914121518526718, 0.20246963873147705, 0.2367651261091701, 0.2644026640396039, 0.19396200562097432, 0.27300413737967033, 0.21231332660388802, 0.2027492819306964, 0.21622876507825484, 0.18911882941362523, 0.2358649502924246, 0.2131747469322357, 0.4023510525479289, 0.2304828547750315, 0.20197590725710324, 0.2252444448747607, 0.21888384076369571, 0.18569170152478987, 0.12433029857188971, 0.1492338440930896, 0.8074024447591718, 0.19987336779399156, 0.19896688687963293, 0.1729085482786652, 0.1715049502131828, 0.8035392838830799, 0.64328209806479, 0.21002827549307168, 0.07330029754233347, 0.20495961096748705, 0.1535768096214124, 0.15388408157445088, 0.48481727680991094, 0.6073357113395532, 0.5405108406028902, 0.19268468239050096, 0.1905044744264932, 0.19874551657641337, 0.18161438661791596, 0.18698241212934819, 0.18048209107357138, 0.18362917644759358, 0.20190703313602132, 0.1810527469247598, 0.08854159451757826, 0.08062903432685053, 0.08241844838468493, 0.09224078168719829, 0.08017267038850018, 0.08500522699985358, 0.09331319652149561, 0.08759889012832622, 0.09329931652800372]}, "mutation_prompt": null}
{"id": "9ba720ee-fe6d-43a2-a2ce-cab3b29e24d3", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly increased population for more diversity\n        self.inertia = 0.6  # Increased inertia for improved exploration\n        self.c1 = 1.7  # Slightly higher cognitive component\n        self.c2 = 1.3  # Lowered social component for more individuality\n        self.mutation_factor = 0.85  # Increased mutation factor for better exploration\n        self.crossover_rate = 0.85  # Slightly reduced for more selective exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 1.5  # Reduced clamping for more precise movements\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            self.velocity_clamp = 1.5 + 2.0 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedHybridPSO", "description": "A hybrid approach combining PSO and Adaptive Differential Evolution with dynamic parameter adjustments and local search enhancement for diverse optimization tasks.", "configspace": "", "generation": 29, "fitness": 0.29385636010743715, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.737884184162169, 0.724256445763116, 0.7431513501631282, 0.7406961287489957, 0.7349673353872921, 0.7195738445917366, 0.7327916588620621, 0.7337211576861028, 0.7323679205295062, 0.4167230089647257, 0.3986985896180011, 0.4133975379722531, 0.4212021698992364, 0.43769931014182417, 0.46337434613867723, 0.38710597662867796, 0.37938242382180665, 0.4358121986807464, 0.17550701083438924, 0.22982889273463525, 0.22725076314889592, 0.1447993922075047, 0.1384777462941913, 0.14455714962335386, 0.1509459419203233, 0.2400980742940486, 0.1337409989803766, 0.1164753131851638, 0.13666442400612122, 0.1157453021551571, 0.15673225677778424, 0.12755361591997283, 0.14780368932148136, 0.11814626166947584, 0.09711661708050401, 0.0990869232439836, 0.9509614136304267, 0.9267390831672826, 0.915927796512161, 0.9438827691128785, 0.9341067276433516, 0.9405876979746841, 0.935454554488377, 0.9467119785406198, 0.9339577817021987, 0.4459988721473045, 0.4255964189430178, 0.4857297367210893, 0.4540151472011402, 0.4195195236788255, 0.4477425205404205, 0.4472609713576491, 0.42031759480956266, 0.4349909786083357, 0.224542416416588, 0.6635925749306946, 0.37026961363342403, 0.2748566698023158, 0.2749724231876082, 0.5822551487909063, 0.540518295929973, 0.664972897308594, 0.46532213878438244, 0.17878565328846252, 0.12387608436597797, 0.18062986089192568, 0.17145276860071212, 0.18651361672925537, 0.16504968913943086, 0.17206077454127466, 0.16193614722370853, 0.19095834345217377, 0.19745016586576525, 0.1714173623858214, 0.16476154931151687, 0.17189243754328076, 0.17479566803024005, 0.12672938805903, 0.2188621981503004, 0.21222017410473026, 0.10809070572220736, 0.0038623223384789407, 0.10875363914119984, 0.004743569910155787, 0.00034499785038621944, 9.999999999998899e-05, 9.999999999998899e-05, 0.04164242939014917, 0.004550092257803229, 9.999999999998899e-05, 0.14680643757430267, 0.09731874765915816, 0.11337707352992388, 0.12272531273866549, 0.10874808146287629, 0.05260470083622315, 0.09600988368163366, 0.13869417517144234, 0.135641485028971, 0.10366052012655236, 0.09497009218947605, 0.17242193170924824, 0.06975930198562186, 0.20784622981080725, 0.15098574110879603, 0.07814571610272292, 0.1688012741197965, 0.11672221248762016, 0.18404415507458038, 0.06809322023193742, 0.11740550672395134, 0.19707587584452235, 0.08610576285791505, 0.13274931968541237, 0.07567214721073068, 0.14685189332796, 0.08322248034065849, 0.5096599026015312, 0.5257340455056684, 0.5168637317977824, 0.5150100401225868, 0.5202855945216611, 0.5076786568493049, 0.505985417195919, 0.5298718495445602, 0.4911356018954083, 0.10800760419778488, 0.12562438146685617, 0.1269363288439357, 0.13361006954967802, 0.14548275146789802, 0.1315070272255653, 0.12361335703571308, 0.11713326765904752, 0.21573324413038575, 0.22873418629483933, 0.37309064057961616, 0.24311899037028228, 0.26514188061389876, 0.36687353712014914, 0.21769489788373098, 0.33438487025425156, 0.25270803328738556, 0.1762100002224033, 0.34212186877030626, 0.4081606275050188, 0.39040951578184224, 0.39723960668198, 0.3829180142865777, 0.32550150468485584, 0.26393846709157764, 0.3972152500541296, 0.44457230367690304, 0.31854933883501, 0.2704820119089041, 0.29416458021020486, 0.3017987015956787, 0.2787981110051905, 0.2406509318346015, 0.2199284569290716, 0.2994964442484995, 0.22028768725893488, 0.23278323673159307, 0.23283091723904203, 0.24017915814720336, 0.21942750382223997, 0.2021736431690242, 0.2331764802853551, 0.23164682229827294, 0.209800104007145, 0.23085481126670326, 0.21600809246876262, 0.32645088091215946, 0.20328298568984182, 0.2133707222349226, 0.4053266641160347, 0.2023117820067456, 0.2427596942447593, 0.23671750148945858, 0.2161324228679371, 0.8364806581394236, 0.19498208568706032, 0.18560443390522297, 0.8521261338797881, 0.16659195468185517, 0.1689634565297352, 0.1417509483832926, 0.160738434413227, 0.8331163105859041, 0.6945918403144085, 0.20817006116950598, 0.07332805093079953, 0.20849985247604208, 0.1682834689690822, 0.15198945684665488, 0.10453426828258106, 0.5950925952079826, 0.7151309782988747, 0.19492927813571437, 0.1787223138467764, 0.19451377518839674, 0.18319650953387367, 0.1967315599187489, 0.18699059786648264, 0.1993633697002951, 0.1880025778309521, 0.1990251764954103, 0.08996582103931283, 0.09346876969776752, 0.0956810298698556, 0.08904170057425032, 0.09386128966411778, 0.08493638822442151, 0.13577861776702937, 0.08464076246109575, 0.0925738794594334]}, "mutation_prompt": null}
{"id": "4cf0c597-e46b-4012-a96c-6166c6422f2e", "solution": "import numpy as np\n\nclass AdaptivePSO_DMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.4  # Slightly reduced inertia for faster convergence\n        self.c1 = 1.7  # Increased cognitive component to boost local search\n        self.c2 = 1.3  # Slightly decreased social component for less crowding\n        self.mutation_factor = 0.6  # Lower mutation factor to focus on refinement\n        self.crossover_rate = 0.85  # Slightly decreased crossover for stability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Initial clamping for controlled exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Dynamic velocity clamping\n            self.velocity_clamp = 2.0 + 1.0 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Dynamic Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptivePSO_DMC", "description": "An Adaptive Particle Swarm Optimization with Dynamic Mutation and Clamping strategies to maintain a balance between exploration and exploitation for effective optimization in complex landscapes.", "configspace": "", "generation": 30, "fitness": 0.33900108535624096, "feedback": "The algorithm AdaptivePSO_DMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "bcf3d093-3394-4487-a6e7-6b43b01cfea9", "metadata": {"aucs": [0.8642620984172693, 0.8550724077114447, 0.8611499718581349, 0.85183610655735, 0.8455468620009151, 0.8594085265824328, 0.8596879093942431, 0.8501687817998634, 0.8547283157382198, 0.6815693606744664, 0.7069631297034261, 0.6861413951790973, 0.666570846363159, 0.6863554362646267, 0.6571031377677188, 0.6586780291967242, 0.6826059609232255, 0.6621370861921474, 0.17765891288740787, 0.12679166472434922, 0.18340695876900204, 0.11346154003758058, 0.17690647367525703, 0.11232370986864115, 0.12170265414675685, 0.5548662264562703, 0.16001139882426252, 0.11656799130032125, 0.10946437431067046, 0.13943162255115915, 0.14044038540003512, 0.14246125524880082, 0.5411223989291134, 0.1723987670187782, 0.11377706976819668, 0.11420180221021059, 0.9292645389818154, 0.9327499305760142, 0.9511248504495494, 0.9211244446420335, 0.9501916560276148, 0.9369142263386556, 0.9518168312612998, 0.9283404375335449, 0.9437675178082975, 0.6920302351257055, 0.6959599508510371, 0.6147254997067676, 0.6841385990426325, 0.6784919603959307, 0.6657658531873016, 0.613647157290822, 0.6292182653111013, 0.6427699548997796, 0.22722807965356295, 0.8729058202940838, 0.35485637706199535, 0.27975552909523826, 0.21208631419059565, 0.2098517651662074, 0.3842765182874035, 0.7745924114964686, 0.7587955628240819, 0.21369135923001614, 0.1479524363783865, 0.24430732303649005, 0.20011953818360573, 0.2026532356258467, 0.11023226247887397, 0.13152426964341335, 0.2447304101107045, 0.24715565633463754, 0.20232602424877033, 0.19829377630670664, 0.1986854963768273, 0.24869768664732517, 0.13465478494791827, 0.23101394874243897, 0.13271451653684985, 0.12837279851395866, 0.1315106732190532, 0.0025617963438610003, 0.08571819815614345, 0.12882168155077112, 0.03839780312052843, 0.03281045399164395, 0.07806463795221075, 0.010583686645332047, 0.046138671527159225, 0.10584673047718773, 0.15345455214780668, 0.09000565812062344, 0.07911704834816613, 0.1450095323353544, 0.05122720212193288, 0.057484891217759126, 0.08959958199464113, 0.05644254409246696, 0.06919770482147558, 0.1742454658897039, 0.1586807868788619, 0.10680186940189562, 0.07588014284256483, 0.11410423142654413, 0.25630492246660963, 0.11253481157155343, 0.16265028515849733, 0.11125034521609045, 0.1208192798895763, 0.2612523484432804, 0.2134766511305014, 0.04249827091175662, 0.0656596798344008, 0.17106786147532183, 0.13805763821953354, 0.17251745586334077, 0.08116079451305358, 0.5318948729006782, 0.5631013610795378, 0.5585660049241516, 0.5354045995514827, 0.587530662127898, 0.5501806323371367, 0.5823972796803555, 0.561493924973096, 0.5719416416318528, 0.1306611687094481, 0.08166986548263866, 0.10004542591621102, 0.1087694287665889, 0.1125755912226678, 0.10997896086881809, 0.11017098056741526, 0.1819041161699284, 0.6309586042677409, 0.2090798704289134, 0.2481662461939138, 0.1853453762017715, 0.27074244219153953, 0.18010905722062143, 0.2279710527283737, 0.18186430484274407, 0.2091279074412744, 0.2562576253593939, 0.45396080243575, 0.5430009140291854, 0.25883769311863536, 0.32056392399774436, 0.5980451831355058, 0.5402366624103985, 0.47449158678681846, 0.3283114308291515, 0.5443536603529024, 0.33652242768926766, 0.3097893793556482, 0.2136911897173428, 0.3419955937158987, 0.34892080194017183, 0.2623840027629809, 0.2834449481788429, 0.22696239058998113, 0.22845137893856005, 0.2190252885336712, 0.2176654691344122, 0.21333303648697133, 0.25188063413186446, 0.24600088701096845, 0.22196739520944087, 0.2307664019403436, 0.24698662124287873, 0.21683893200481208, 0.6356929616237703, 0.24021114591863868, 0.21024385642815002, 0.21821873530129443, 0.22191016695651422, 0.20868797899708302, 0.19472459431734235, 0.24666699086143984, 0.22111539049596096, 0.8911622986271367, 0.18612618889304366, 0.18642258698853087, 0.9167368911135153, 0.20079844799586932, 0.1993097680466891, 0.14187574904669487, 0.16762372488625388, 0.8986171932305234, 0.6461411087594726, 0.21258362416257237, 0.669799218992401, 0.8794578517604476, 0.2108095080464759, 0.1681503083289415, 0.6868080788024358, 0.10434979850121451, 0.7828060270377597, 0.19142526451184116, 0.21641600814764028, 0.19041838625842422, 0.20429356108626184, 0.1778392008500932, 0.18507045731503347, 0.2072044412294919, 0.19112216730764542, 0.20576503866056972, 0.0914600268329443, 0.08152961610776999, 0.12653847982920796, 0.0941482398640584, 0.09373610692554213, 0.10634467935472802, 0.12979082223422322, 0.08862330020882414, 0.08766853802645658]}, "mutation_prompt": null}
{"id": "76fd6b99-ef2a-4c35-82e7-4722fdfd31b2", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for balance\n        self.inertia = 0.6  # Adjusted inertia for better exploration\n        self.c1 = 1.5  # Enhanced cognitive component for individual learning\n        self.c2 = 1.5  # Balanced social component for collective learning\n        self.mutation_factor = 0.7  # Enhanced mutation factor for exploration\n        self.crossover_rate = 0.9  # Increased crossover for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Updated clamping for exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            self.velocity_clamp = 2.5 + 1.5 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedAdaptivePSO", "description": "Enhanced Adaptive Particle Swarm Optimization with dynamic parameters and adaptive mutation strategies to improve convergence and avoid local optima in diverse optimization landscapes.", "configspace": "", "generation": 31, "fitness": 0.3061313776732535, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "4cf0c597-e46b-4012-a96c-6166c6422f2e", "metadata": {"aucs": [0.7514842184618375, 0.7713885279821024, 0.7505950767560576, 0.7666114633550049, 0.7794272906889101, 0.7710514863442083, 0.7701289806102815, 0.7577063897401599, 0.7549260628650426, 0.46008584170335465, 0.4576937937055011, 0.42652690178392993, 0.4684446522172815, 0.4672024628216094, 0.45904780426993197, 0.5032121869919599, 0.44307626509823017, 0.44651350462567474, 0.1604383467329108, 0.18798135759064039, 0.15722022688491033, 0.11441430364466632, 0.15001682676357997, 0.13264662614783995, 0.13845025524355647, 0.1659796373321285, 0.15497929372174257, 0.11814139816470748, 0.13346213558498699, 0.12823283645568062, 0.12744199236454823, 0.11864224439797222, 0.1107082815173831, 0.15622262974708878, 0.12570055074159736, 0.11710511107694088, 0.9621125022347222, 0.9580851405571006, 0.9688578727923661, 0.9531819069728464, 0.9612176657436997, 0.9603880237668884, 0.9599353755493618, 0.9354787088064279, 0.9668855969636536, 0.5297096495314497, 0.5122046188340728, 0.453017099367108, 0.47409148338604423, 0.4639546891631402, 0.5058846926196733, 0.48288223844886646, 0.4484044246562444, 0.44749986919732987, 0.21962340926389612, 0.7704028721962273, 0.22533603617287423, 0.19281114167902091, 0.19274766436969548, 0.2704934385684563, 0.6148670565780214, 0.7151161542706217, 0.8334423807263766, 0.1955180053825586, 0.12422858733283315, 0.11634499586901126, 0.17533216419909237, 0.2091176971802764, 0.22314120890264355, 0.19364195856500377, 0.20222752933501853, 0.19353567291934037, 0.18834627656656, 0.19104014228978616, 0.1998425879397172, 0.12748851077221646, 0.3049219809387662, 0.1226860046473015, 0.24616956236755638, 0.22076800761880988, 0.22643712743545197, 0.023676032860611707, 0.04031256853033882, 0.01656291269404031, 0.047401920799181596, 0.03559465921634186, 9.999999999998899e-05, 0.00011004324487273731, 0.0026494902469926807, 0.018278340726672115, 0.11042697527004353, 0.1076435896431025, 0.11720868257664951, 0.05717125584309546, 0.013329671562170908, 0.044436644774774714, 0.057937430770681586, 0.10639787375373855, 0.051940549769617816, 0.07261909510074782, 0.13523932307359665, 0.06538106317401016, 0.061240024772039936, 0.06109348734795017, 0.20495247720434417, 0.07637110354431498, 0.19546808204249266, 0.12557377524098223, 0.08751149255686308, 0.10558285205714113, 0.09772420705987439, 0.080475545676714, 0.13034692317109653, 0.17159259843998265, 0.052143993635983654, 0.05346802891518532, 0.07639770663083967, 0.4817484069874832, 0.5042550377013301, 0.5053914909015114, 0.5385131186158882, 0.5417047855142467, 0.5304002051925338, 0.5133667665512949, 0.5280126863151153, 0.5300559668683518, 0.1386364194436308, 0.1102629668389924, 0.1295987821561284, 0.11258332624109202, 0.13429298482437735, 0.10034001129366843, 0.10878333265688345, 0.11845032562250069, 0.12562290941952103, 0.31376230665629545, 0.2131965425287844, 0.18344556429765435, 0.2189593458186193, 0.25274171544957824, 0.17576604077895586, 0.2820402700348802, 0.19627612450723397, 0.29952763459605636, 0.33203276365993395, 0.2519582453184279, 0.4477276052422494, 0.42256092929969524, 0.3995523580863254, 0.305115666603884, 0.39702125352640183, 0.4235598479538859, 0.42468407936129393, 0.3216511608772368, 0.296494493660283, 0.28186240124588935, 0.21829071245046894, 0.2166743790536414, 0.280246590779476, 0.3136338284714245, 0.3497328424183135, 0.30845790364988435, 0.21725727965862307, 0.2321537358537945, 0.21774215765982685, 0.21522542688741542, 0.21884884179431108, 0.20785279311456362, 0.22674449790795592, 0.22041991826090723, 0.2736987194061983, 0.20768834321750707, 0.20705115833188292, 0.18213242113190808, 0.2427107910553109, 0.6289173173916046, 0.18433315323509036, 0.22571717719035356, 0.21580158246155023, 0.2377216388950082, 0.8321703327672065, 0.17652563454612813, 0.15988505234376282, 0.8649241219676665, 0.1993625551699909, 0.19870119138842124, 0.8270981685787698, 0.8046626532986307, 0.858847724727595, 0.5706847527034138, 0.21094487497487957, 0.7052710114189769, 0.10435066777902524, 0.668617814313833, 0.15422529328211765, 0.6207906001955119, 0.10417700235326355, 0.6305130843573492, 0.19287491346010177, 0.1881239293190129, 0.20330968861350496, 0.18505949198275273, 0.1957909924492709, 0.19478237112983243, 0.18681183695489467, 0.17608355102489892, 0.19338958300686904, 0.09848861053647939, 0.08688227792314573, 0.11215750059478236, 0.08588934704794049, 0.08743407913277357, 0.09713951608703864, 0.089341020839659, 0.08143929248819581, 0.08993083700074944]}, "mutation_prompt": null}
{"id": "d5b75a6b-c88e-43f3-8e22-ac060b9d3227", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO_DMC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia_min = 0.3  # Introduce adaptive inertia for better balance\n        self.inertia_max = 0.7\n        self.c1 = 1.7  # Increased cognitive component to boost local search\n        self.c2 = 1.5  # Increased social component for better global search\n        self.mutation_factor = 0.5  # Adjusted mutation factor for more exploration\n        self.crossover_rate = 0.9  # Increased crossover for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0  # Increased clamping range for enhanced exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Adaptive inertia\n            inertia = self.inertia_max - ((self.inertia_max - self.inertia_min) * (eval_count / self.budget))\n\n            velocities = (inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Dynamic Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedAdaptivePSO_DMC", "description": "An Enhanced Adaptive Particle Swarm Optimization with Dynamic Inertia and Mutation for improved exploration-exploitation balance.", "configspace": "", "generation": 32, "fitness": 0.29328014809082953, "feedback": "The algorithm EnhancedAdaptivePSO_DMC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "4cf0c597-e46b-4012-a96c-6166c6422f2e", "metadata": {"aucs": [0.728219690806654, 0.709663983210546, 0.708372413830563, 0.7105282715727863, 0.7462870551693708, 0.7123885568424642, 0.7398828217235325, 0.7270665121603739, 0.7352384031744106, 0.450492075252825, 0.48744480409751556, 0.4462666460668242, 0.4508826908438145, 0.43977291986696165, 0.44985044753030257, 0.4369232909038201, 0.45231487034059714, 0.45859956097467425, 0.12068207404492137, 0.16219772650518116, 0.3404681628644024, 0.12650062888116376, 0.16930319156890927, 0.1292217611506663, 0.14040772626618725, 0.15712830967674907, 0.12310230007093415, 0.08619698981954993, 0.12239174738669922, 0.13098323543643653, 0.1191526992081976, 0.11827387054406191, 0.11957156974791083, 0.1277346384402357, 0.1291683527495796, 0.127615112964643, 0.9697961605628211, 0.951563463093893, 0.9691655484864619, 0.951883202116113, 0.9639622560500889, 0.9672772809615203, 0.9709199079438962, 0.9591087530574348, 0.9606556020649547, 0.513510872979775, 0.49196742050003583, 0.4647319920090115, 0.48310275421443494, 0.4409248904568035, 0.5084292272260861, 0.1495544589869583, 0.45677262397892215, 0.46956157525377873, 0.35473662299219055, 0.2224753200675137, 0.22094456076875468, 0.26937888870105775, 0.2623498307788904, 0.443695971293818, 0.4840500044969197, 0.22363918797282867, 0.6511763918354232, 0.18589959585297566, 0.16091883995112966, 0.16730492447317136, 0.16762366254092143, 0.12371047941085211, 0.11426841313143055, 0.18306361515160374, 0.1257680146884682, 0.12930428675126027, 0.20543081055249746, 0.19330718683257486, 0.2008062687133052, 0.1950726778737647, 0.17905902131165696, 0.18398367998522447, 0.20087544524014156, 0.21490028060222577, 0.22048887535846207, 0.08064395871235752, 9.999999999998899e-05, 0.011216647680362124, 0.02278327581105133, 0.002289125709220574, 9.999999999998899e-05, 0.0699311970274814, 0.06155775609037906, 9.999999999998899e-05, 0.05930143507196772, 0.06007436510486841, 0.08726558755969205, 0.10148630542078174, 0.013492363956338904, 0.10108348784281385, 0.02458274258406057, 0.14554930631705487, 0.07648574091878813, 0.05420900036716414, 0.19007567807397474, 0.04605977838918918, 0.07598788768427078, 0.07078816706955315, 0.19399400785627274, 0.19471565546332148, 0.12215836285711046, 0.1154751089996695, 0.09959312119766606, 0.20680373089017978, 0.11840953257453601, 0.13800580005978513, 0.22643331984997983, 0.1329352382489929, 0.07602260810983918, 0.17585071611479086, 0.10819834506900916, 0.47062811295517104, 0.5195387557686697, 0.47704674570125516, 0.5107470432768138, 0.48795701876203934, 0.47763424532981835, 0.49331715966006084, 0.514840853680391, 0.5051909710319402, 0.10622113476745743, 0.12805174128773456, 0.09658653654545801, 0.12151101513926499, 0.13622531112405145, 0.10388909112909572, 0.09664155373344807, 0.09057588052309617, 0.08226942961328276, 0.42052526489099973, 0.3082048873777581, 0.20596610820125405, 0.3655310611898205, 0.3858868083315823, 0.26047750306645534, 0.4151941589724759, 0.36213815229234136, 0.18780843856610563, 0.35658781846466203, 0.37068439668048847, 0.36142782662307915, 0.3376783747219193, 0.3414110906464085, 0.32514744585321376, 0.4446786271587633, 0.4420953646671161, 0.4248921842188028, 0.2261720311196881, 0.23342126607101676, 0.2315835294734796, 0.24814237453857335, 0.2451911072158518, 0.25285982038705, 0.25722768739236934, 0.2848175443205858, 0.2273925175688153, 0.23180721398979565, 0.21681365016224574, 0.2289461720483107, 0.21292641425219294, 0.22637974962951235, 0.2083273885048419, 0.2275867537027344, 0.2039053981704292, 0.23248982978703947, 0.17848522600665873, 0.21665995186594433, 0.19175447159278636, 0.4122689309966008, 0.23862390446853032, 0.20020194497965782, 0.22471300951686657, 0.18616915463560346, 0.20621038781273726, 0.7644368502090888, 0.18552503721272318, 0.16486995141514704, 0.8222971741646581, 0.19869737295601753, 0.198425854835517, 0.14110855352987495, 0.7238356770644794, 0.810500576738568, 0.6351910462112781, 0.21020972199062604, 0.7193268515576617, 0.7174882521637445, 0.11098178947334747, 0.1539961802607357, 0.5774360154189997, 0.10417739442334861, 0.16573931017836818, 0.2311558676500839, 0.20118376448601127, 0.17882684779691094, 0.19960046808256326, 0.19051157591929557, 0.199346194439463, 0.19425667974753824, 0.19514968533678434, 0.1950814237705013, 0.08459840634515436, 0.09182048730681014, 0.09716757446370139, 0.10489635989669877, 0.09252088963939531, 0.08634763289724556, 0.10116570745779496, 0.09708277866441417, 0.08609517810337852]}, "mutation_prompt": null}
{"id": "d4bf9e2d-1314-41c5-b34f-0f76686f42ab", "solution": "import numpy as np\n\nclass HybridPSO_AIDM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.7  # Adaptive inertia updated based on evaluations\n        self.c1 = 1.7\n        self.c2 = 1.3\n        self.mutation_factor = 0.8  # Adjusted for increased exploration\n        self.crossover_rate = 0.9  # Increased to intensify search diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0  # Higher initial clamping for broader search\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Adaptive inertia adjustment\n            self.inertia = 0.9 - 0.5 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "HybridPSO_AIDM", "description": "A Hybrid PSO with Adaptive Inertia and Differential Mutation for balanced exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 33, "fitness": 0.2458469987674781, "feedback": "The algorithm HybridPSO_AIDM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "4cf0c597-e46b-4012-a96c-6166c6422f2e", "metadata": {"aucs": [0.5887040019016279, 0.5984769025930808, 0.5954957884156469, 0.5989251397326298, 0.5685388697123026, 0.6180449725180468, 0.6041427518529034, 0.6233291032896342, 0.6174515156838376, 0.2813646880679087, 0.23554782452689038, 0.02998308589759402, 0.24531584352555158, 0.14832727553760183, 0.21538840849366747, 0.2343434909959693, 0.2712341510002143, 0.2026515329074624, 0.1085044936143037, 0.12000462703608539, 0.1112745651705287, 0.11193311785346305, 0.12428011572009712, 0.1259873180840423, 0.11176401280406711, 0.11634124668265722, 0.15059258077411686, 0.1193161485539902, 0.11169463969993398, 0.12002813962522618, 0.11304051309709007, 0.09715117696771702, 0.10970163444567282, 0.11860013552305915, 0.10657055583138186, 0.11457662032900695, 0.975585432483918, 0.9583284958899532, 0.9700029265078455, 0.9672936256941884, 0.9696585023166877, 0.9667232063949175, 0.9698282788417205, 0.9680077593344188, 0.967528691398561, 0.33786438449432377, 0.3270913904091677, 0.34056039443380404, 0.34050685047074136, 0.30167708299815155, 0.20127408580661665, 0.3212542794809622, 0.3290552900780218, 0.33886602132208066, 0.4947242710250249, 0.4654294283562628, 0.6685890860977377, 0.24302994157166158, 0.20085377881431654, 0.2229793619558822, 0.2867184882473064, 0.5216155673719594, 0.3688628899213663, 0.16003926660601187, 0.08221263304416793, 0.15744328141101815, 0.15147640978976684, 0.1431348275054668, 0.14265161998560638, 0.15312667579778427, 0.1442628337805596, 0.1413236627455875, 0.12892553500774084, 0.11116250906202563, 0.1073964003642901, 0.16138449226635732, 0.16914090052361175, 0.12094660413697433, 0.1897878785884488, 0.10646426479073001, 0.16939806564144, 0.017312515044285437, 0.00014037918545695138, 9.999999999998899e-05, 9.999999999998899e-05, 0.000315065697425454, 9.999999999998899e-05, 0.03495875383756464, 0.018157929799726524, 0.07250008490691284, 0.07376258049765583, 0.08121176924974938, 0.1466241259887041, 0.05860443096520607, 0.05979891150862282, 0.07671942203229898, 0.042635283037930405, 0.07211018796185542, 0.1576012548006207, 0.01730560434620454, 0.027508568521742327, 0.024265892252502308, 0.06368698323668864, 0.04194513944277645, 0.07698040333125122, 0.053852643226343755, 0.11847510031503461, 0.07188599534370643, 0.10012130710707157, 0.10729949531186445, 0.06006318241224873, 0.0653484346087485, 0.07722810260369983, 0.10046294812869605, 0.06472155196246154, 0.08710642388533307, 0.06394767491273601, 0.42688270538422657, 0.45025476581633506, 0.4558516810259574, 0.4195206046253006, 0.41148662297961514, 0.40156127737809655, 0.4138633166929603, 0.4443464537702738, 0.42863108686771234, 0.09710692632032192, 0.1039504203351338, 0.11944853118405496, 0.13806667742856538, 0.1169797057903934, 0.1265940981056679, 0.0935219019671707, 0.09808699058762815, 0.13729939177673167, 0.1529720522406104, 0.15054006305379275, 0.1596469817930718, 0.12960937408158146, 0.17471907620543603, 0.19727099995476005, 0.17058592105782833, 0.15992131186508307, 0.24880398200786313, 0.3203625494645097, 0.335342710179519, 0.3090898916856588, 0.2974373307710495, 0.33335538995016745, 0.3163671639441554, 0.25529304960356647, 0.29037251659150776, 0.3323117971244568, 0.20040333389321008, 0.20741452932395577, 0.26763964389911954, 0.25336836889484815, 0.22391710063071613, 0.2788481294458085, 0.2272164941610132, 0.28120977081894394, 0.19994082318594442, 0.21218793980539896, 0.18067441790647187, 0.20832055669038085, 0.20685569797641845, 0.21564951184255066, 0.22190255411650428, 0.21322442053265567, 0.19690994090501568, 0.19634674654823125, 0.20557075086395904, 0.1875952473925333, 0.20930325046968978, 0.2095966819780659, 0.28801609972238595, 0.24671252968902146, 0.35679770302801617, 0.19881718859770936, 0.2088775806524399, 0.6956242422640668, 0.1653368784253656, 0.14525717462780463, 0.6752374619121685, 0.19637339174038826, 0.19521827243481304, 0.18999863700973985, 0.15903221329064543, 0.7288071119940642, 0.49949646915833645, 0.2072464628463011, 0.5008488418757289, 0.3865328001922399, 0.16433008388360626, 0.15848799672437253, 0.46660061369304917, 0.5031478908769049, 0.2012204383526307, 0.19113470849741676, 0.17416217829309932, 0.18503015217274799, 0.18310192043969076, 0.18043097743929315, 0.18238177577582437, 0.21354182025250001, 0.2021707000219275, 0.19766593905426388, 0.09136629647801076, 0.08322517549976671, 0.11008103023284532, 0.07723708984037836, 0.08533959922069168, 0.06904327279618372, 0.07547556571316638, 0.08654764836292561, 0.08767406310721437]}, "mutation_prompt": null}
{"id": "4c59a915-f192-4486-8240-3b47084281af", "solution": "import numpy as np\n\nclass FuzzyLogicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.5\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Fuzzy Logic to Adjust Parameters\n            if global_best_fitness < 0.01:\n                self.inertia = 0.9\n                self.c1 = 1.5\n                self.c2 = 1.5\n            elif global_best_fitness < 0.1:\n                self.inertia = 0.7\n                self.c1 = 1.8\n                self.c2 = 1.8\n            else:\n                self.inertia = 0.5\n                self.c1 = 2.0\n                self.c2 = 2.0\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "FuzzyLogicPSO", "description": "A Fuzzy Logic-Inspired PSO utilizes fuzzy rules to dynamically adjust inertia and coefficients, enhancing adaptability in complex landscapes.", "configspace": "", "generation": 34, "fitness": 0.24440424970682836, "feedback": "The algorithm FuzzyLogicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "4cf0c597-e46b-4012-a96c-6166c6422f2e", "metadata": {"aucs": [0.7117403520624701, 0.7327442768298886, 0.7451131082281692, 0.7306030264047254, 0.6937646390676921, 0.7050286022894676, 0.33768993697604743, 0.3432473579905322, 0.31223626078294775, 0.0792423904153251, 0.038932848269299436, 0.07189197235250921, 0.056772803073391165, 0.10872724023430425, 0.12079531980245173, 0.15280967726387484, 0.11625738477881586, 0.15953469417900412, 0.13846309435909443, 0.09417102418108192, 0.09151239264003286, 0.16677572488081283, 0.15080934430058446, 0.13868890472241113, 0.14877346173434836, 0.14008280741835755, 0.130089103317778, 0.09102972667143827, 0.09937569085830456, 0.08639003403886214, 0.13910428537467834, 0.14251168568057093, 0.11077320605684293, 0.11115896713794304, 0.31264836028324283, 0.11645646107179675, 0.9603886686616082, 0.9498657307584213, 0.9593326266485521, 0.9516690162878145, 0.952128525849113, 0.9518067631402639, 0.9523413737571417, 0.9273817510272319, 0.9504001217003892, 0.3313947794561657, 0.3868119993230855, 0.38936585497077514, 0.4027004666160112, 0.3557445671599575, 0.3901585856878118, 0.1815609685266989, 0.1799829129019186, 0.22135022176219232, 0.328547398373755, 0.22768110180628343, 0.6694339774143918, 0.2714886866559222, 0.21103657648565743, 0.34710345798244113, 0.3493655218558178, 0.5440689471658893, 0.4769650166826822, 0.11118197735920166, 0.10494136378627195, 0.16563584461817793, 0.11100686649114322, 0.10541491667467484, 0.09337372463297766, 0.19325682053062088, 0.17241552080397593, 0.1971365309231521, 0.1838941379864818, 0.19527206749279968, 0.18128579843391812, 0.2022389539170183, 0.17596476280064632, 0.23735484105658766, 0.20339325182691947, 0.19620281391681438, 0.12108971054305495, 0.026008447610583407, 9.999999999998899e-05, 0.0068167201019859736, 0.008487720318938408, 9.999999999998899e-05, 0.016863436696858636, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10165405767147984, 0.1148835947055703, 0.0879122061551667, 0.09894396162418417, 0.02957118481176202, 0.07901271983427138, 0.131276551802754, 0.225733744521725, 0.05493362157196802, 0.050653049886492774, 9.999999999998899e-05, 9.999999999998899e-05, 0.038646254665535174, 0.05945965920842278, 0.03235689820570764, 0.07434666399423695, 0.07164674979636243, 0.14061504769037292, 0.10778615048658158, 0.20330173116075956, 0.11795774119732194, 0.06153707859710156, 0.06156120490602157, 0.0648773472906159, 0.05523921876093807, 0.07214585009570984, 0.044992189281315764, 0.30871171342762793, 0.3293687908055707, 0.3823242122613665, 0.33492632274040124, 0.3574361635747212, 0.3421944580066092, 0.4956914253620902, 0.5208141533435601, 0.4934747855398042, 0.08862082361825319, 0.13915921025080547, 0.12115829986669979, 0.09855467137660656, 0.12413121077881828, 0.12336655870099678, 0.10590637499585298, 0.10128474632315465, 0.08595066932483664, 0.17736970662318452, 0.2532303746732365, 0.22683529574629724, 0.19255326802733364, 0.17304290670862754, 0.15301577301105085, 0.25918250186365543, 0.31216673913233994, 0.31646791611287584, 0.23851875699423108, 0.2410632947099023, 0.22461620741228594, 0.36409906577695605, 0.3820538174291316, 0.3531629453957533, 0.38997338951369753, 0.3915773820303232, 0.36387902427192187, 0.17632709964917725, 0.19544062410199947, 0.16331103729197471, 0.26187283122748983, 0.19313458544301498, 0.22636333818419663, 0.25644740940439437, 0.29820561496616116, 0.2748667629122231, 0.19559549392743236, 0.19478353418164673, 0.21652899973093842, 0.2158841977707866, 0.2616518517045716, 0.22270385498139544, 0.2309626931987382, 0.22026502906552858, 0.23348911353371993, 0.19218587299196044, 0.18266935090938874, 0.1773966344885648, 0.22204772145380902, 0.4510635258895743, 0.19930640597788107, 0.2018179311073105, 0.23926169716773582, 0.19382194149436682, 0.18557272944202186, 0.18523916263974616, 0.17613156482220815, 0.5155260184737542, 0.19663973017977676, 0.1971570588637982, 0.38716757249056644, 0.1589530875302536, 0.4269035823551617, 0.3668538751461339, 0.20695992676766983, 0.4007544109721173, 0.7296186956366422, 0.5325480162932115, 0.47123724816006207, 0.30673832533157885, 0.10386927046203387, 0.35387098813499007, 0.17744699017868593, 0.1892584075236352, 0.19528418456589325, 0.20191709010053405, 0.1801990046200339, 0.18929048335939547, 0.18235444607470097, 0.22151776436638082, 0.18193849670278472, 0.09954190289609632, 0.0871877071051751, 0.11864736585024926, 0.10283834724276386, 0.09635464531054672, 0.10114975908888868, 0.08425031819389173, 0.09703290329231784, 0.08307625718239686]}, "mutation_prompt": null}
{"id": "5be2ae60-5930-40fa-806f-78dd96b3104b", "solution": "import numpy as np\n\nclass EnhancedPSO_AICM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.7  # Initial higher inertia for greater exploration\n        self.c1 = 1.5  # Balanced cognitive component for local exploration\n        self.c2 = 1.5  # Balanced social component for global convergence\n        self.mutation_factor = 0.5  # Set mutation factor for exploration\n        self.crossover_rate = 0.9  # Increased crossover for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Increased clamping for wider exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Adaptive inertia weight to balance exploration and exploitation\n            self.inertia = 0.9 - 0.5 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Chaotic Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    chaotic_factor = np.random.rand() * np.sin(eval_count / self.budget * np.pi)\n                    mutant_vector = (particles[a] +\n                                     chaotic_factor * self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedPSO_AICM", "description": "An Enhanced Particle Swarm Optimization with Adaptive Inertia and Chaotic Mutation strategies to improve convergence speed and solution accuracy across diverse problem landscapes.", "configspace": "", "generation": 35, "fitness": 0.24743562884393666, "feedback": "The algorithm EnhancedPSO_AICM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "4cf0c597-e46b-4012-a96c-6166c6422f2e", "metadata": {"aucs": [0.5912426671108506, 0.5642245195975004, 0.5939373531332137, 0.5821418993761165, 0.6047998647463383, 0.573620878008241, 0.6181048231099205, 0.5957769914935364, 0.5912075369227577, 0.24157906929655937, 0.27292351712872565, 0.23897524541977577, 0.19869332704778575, 0.24642063294051064, 0.24663620752936044, 0.2176600757387367, 0.24870814725026824, 0.03663754767226057, 0.10297924013294069, 0.12095976751872672, 0.12945996645647717, 0.11868175811672643, 0.11734535752603081, 0.1411978700512484, 0.13806854981007477, 0.11632046120933648, 0.13147890072689028, 0.0824070915625047, 0.09558014069027065, 0.10475471141609838, 0.0953583291242317, 0.09433501971668734, 0.11460280693699498, 0.12197582232576665, 0.2147426206975923, 0.11402110552555278, 0.9628128802172436, 0.9560533070643146, 0.9648894081197025, 0.9431215133088338, 0.9528352582174385, 0.9577719392199104, 0.9612256379963958, 0.9532619102428327, 0.9588861130407657, 0.3633055580274146, 0.3440160791229171, 0.33962324802944655, 0.362387996861937, 0.14927901440010427, 0.1897886018542777, 0.34445076201110714, 0.31693531830591537, 0.3176886742311549, 0.5391995048617728, 0.48451981222354157, 0.2229198397751322, 0.197664152784209, 0.2032577120539345, 0.5478446741861163, 0.2180421108650329, 0.5066174311048435, 0.5169821241551622, 0.16855621878021398, 0.07616150035922542, 0.10572116037059043, 0.11727475028291134, 0.20407228730614702, 0.17788823893091, 0.1709497091098514, 0.16292546030978394, 0.16346874412357792, 0.16384904839727732, 0.14246307187897278, 0.15972495614886284, 0.17843089382842992, 0.14935047296276438, 0.15015544727906072, 0.17080809828806653, 0.18161668814096887, 0.2015210050918408, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013656869546287975, 0.02998679261324666, 0.003261956160424795, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10838563838887616, 0.058972030917411766, 0.09630189833120184, 0.12273207510803363, 0.02365653747916363, 0.025044673499711623, 0.07603975945520236, 0.09470127001838413, 0.06652861743016292, 0.01938802317879107, 0.08186928883806033, 0.15455619474983473, 0.04541590261674466, 0.03857840505414245, 0.03186681434154104, 0.07214816400646562, 0.03642765848817431, 0.052624434716499136, 0.09350735399279042, 0.12979664047320094, 0.12499679036900724, 0.06565310681436054, 0.1051113161490026, 0.12514141477380014, 0.1344769408195403, 0.06292215707451543, 0.06492538625719246, 0.4110575609451097, 0.4587953529124632, 0.46169074009803956, 0.4498785192010344, 0.4340256839574267, 0.45792479455875423, 0.49316041295719104, 0.4468769932707144, 0.4540180022321533, 0.10249355710552044, 0.10444803588711926, 0.09807489962132987, 0.10262170786986735, 0.09840500742136193, 0.11435372784602371, 0.11048929195758428, 0.11371997502461706, 0.11518540032054858, 0.30784599335430074, 0.1688852903122604, 0.21517321688245883, 0.23518288787932273, 0.2582668858809408, 0.28769941968011503, 0.21942930077825873, 0.34113833418872075, 0.23473005358979604, 0.3150792920569143, 0.33647463511121334, 0.33371217289210775, 0.3123481617480599, 0.350733781979114, 0.29578928006575855, 0.37238186783386507, 0.3528120960379836, 0.32795899123449634, 0.24859895416712374, 0.2540184963256287, 0.2638971740881615, 0.21959247739635224, 0.21977708231349669, 0.20444648324635195, 0.2549166939795192, 0.25544153303368955, 0.20738037100464446, 0.2194661041631969, 0.23817754277447123, 0.18963094053825014, 0.2176597899064463, 0.22060582093169345, 0.2029968988538109, 0.20789644991253176, 0.21472650674624805, 0.2182815865680484, 0.2153109742203636, 0.18724359507464072, 0.19571577133111528, 0.23034446967018352, 0.18718431548712877, 0.18405075163659834, 0.18822040323653821, 0.20964126457344723, 0.20176472971119142, 0.16283120761752146, 0.17214673651441992, 0.152044715886837, 0.7062411219049033, 0.19480843114072532, 0.19800156064052687, 0.14028579265029306, 0.16674672809223412, 0.688454068133772, 0.4292663539213176, 0.20635174065112438, 0.6529541192343699, 0.20358796888645347, 0.16813945794988971, 0.15160429195854086, 0.604069941397773, 0.10362720652831503, 0.4979600596674445, 0.18497218801997983, 0.2031918636754383, 0.17409058938256095, 0.18110110955016645, 0.192051576173079, 0.17969141053754523, 0.20039941173573583, 0.1809833266536396, 0.2031635412277446, 0.11350958613342521, 0.08715795574315721, 0.0812171999455712, 0.08271357405927027, 0.08511544513024805, 0.08874614078006526, 0.1034235991791973, 0.08537193714651292, 0.08536428084947234]}, "mutation_prompt": null}
{"id": "dcebd969-9fac-4a52-ae3f-9dc82baa92b9", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.5  # Balanced inertia for exploration and exploitation\n        self.c1 = 1.5  # Adjusted cognitive component for better local search\n        self.c2 = 1.5  # Balanced social component for cooperative behavior\n        self.mutation_factor = 0.7  # Adjusted mutation for exploration potential\n        self.crossover_rate = 0.9  # Increased crossover for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0  # Higher initial clamping for extended search\n        self.quantum_factor = 0.1  # Quantum tunneling factor for escaping local optima\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Dynamic velocity clamping\n            self.velocity_clamp = 3.0 + 1.0 * (eval_count / self.budget)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Quantum Tunneling and Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    # Quantum tunneling\n                    if np.random.rand() < self.quantum_factor:\n                        trial_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "QuantumAdaptivePSO", "description": "Quantum-Inspired Adaptive PSO with Enhanced Global Search and Quantum Tunneling to escape local optima and improve convergence on complex landscapes.", "configspace": "", "generation": 36, "fitness": 0.3259965769345929, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "4cf0c597-e46b-4012-a96c-6166c6422f2e", "metadata": {"aucs": [0.8273659545796032, 0.807690122580031, 0.802117243765684, 0.8096400013611125, 0.8290905249310281, 0.7971542136014191, 0.8189756823299823, 0.8006344905877187, 0.8145741561482603, 0.5640033866886072, 0.5575579379690355, 0.4873610463657402, 0.5709154831435186, 0.5544720919007966, 0.5915543474128327, 0.5528599568300302, 0.592924924573061, 0.5922486591296197, 0.16336844431466013, 0.11221195110530202, 0.17805916460954319, 0.16706064040209856, 0.13100296163417602, 0.1608749409794098, 0.14908853612003314, 0.16518899160398137, 0.11701000586222676, 0.16268166252188898, 0.17853091074951533, 0.12264314439961577, 0.09639823549201432, 0.10376054405677315, 0.13065766712006022, 0.14087229694214964, 0.09378821661610326, 0.13118675375602085, 0.9617310980710003, 0.9500570256377425, 0.9680276879013423, 0.9518274761768003, 0.9675581415168533, 0.9677904443855265, 0.9688410885789344, 0.9699869901316496, 0.9527472892836535, 0.6492461688301274, 0.5478448715225761, 0.5156892472397421, 0.6309631380672494, 0.5568651481020239, 0.5974991431705836, 0.5919612939636516, 0.5627388865100451, 0.5333348589176541, 0.8150515886316403, 0.8578454972300699, 0.8347752298628824, 0.21047424459107122, 0.2720021142799325, 0.8029403719023085, 0.2224133623225495, 0.743783251643342, 0.22757640919755595, 0.19882328149729123, 0.4329286263178691, 0.1986504512065539, 0.21413779619497086, 0.26389509726492966, 0.11255560012517785, 0.19541862580786096, 0.2185459014633534, 0.13116110769807054, 0.24054957620369, 0.22064962615836237, 0.2117087481996518, 0.18691241772223932, 0.13128310431739632, 0.28192648280325416, 0.22831967557709476, 0.22022583703731824, 0.25093036377985056, 0.06573589234130739, 0.026554705071642815, 0.06134605517648162, 0.042065045616488494, 0.009961414656412537, 9.999999999998899e-05, 0.0007220004930501567, 9.999999999998899e-05, 0.06341816035346637, 0.09602016638309174, 0.05121262234753754, 0.08584105611261816, 0.10300030811429894, 0.045613360707886574, 0.0373082176520011, 0.08177835100817243, 0.08507106268341702, 0.06594758112695032, 0.03169978095169712, 0.11267801459571747, 0.16690527836832936, 0.0777987016263656, 0.07105618467956465, 0.07269979839630891, 0.10213394607816229, 0.10922963096065341, 0.10856799673912665, 0.07869278201848318, 0.13335502162797586, 0.12496662019284432, 0.11636062614307319, 0.23835004234978496, 0.16583524554615092, 0.11282544070601908, 0.14898804771050345, 0.07941982212894838, 0.5565943813626038, 0.5113019147537601, 0.5563976491415943, 0.5722376137601172, 0.5049430314007463, 0.5564399784018467, 0.5755041699472156, 0.5634568776313384, 0.5670777580476443, 0.09590183643438466, 0.11629016791733915, 0.1359216408931967, 0.15524154452129002, 0.14111344964132533, 0.1257810632656159, 0.1447132341595032, 0.1363072209218199, 0.13330326890872823, 0.2101454692833672, 0.6010976748676964, 0.2119523552571737, 0.24354088785144934, 0.32726584287947036, 0.2540458781349485, 0.4902283861186374, 0.19397865158692507, 0.18503937119511527, 0.3653972370206072, 0.39395702478648786, 0.3468817812840209, 0.43302065098408793, 0.29239368000037047, 0.47777870647188214, 0.5147731441413446, 0.5076559217070833, 0.49487153086304414, 0.24268777353210325, 0.2943798363599025, 0.2834390932485348, 0.1991155586533837, 0.32694482772463984, 0.2134620013341495, 0.2471413545124852, 0.3277914341286313, 0.21632757437626893, 0.21907377821179863, 0.21827954478114842, 0.22025785678586518, 0.2349668526146549, 0.1954406570462386, 0.2065788344945495, 0.24320803302821048, 0.21461305021427313, 0.22836681946686588, 0.19878272237941041, 0.19410998372717891, 0.24369089568627356, 0.24212375989004664, 0.24439905735718448, 0.19658468414819885, 0.204950598921542, 0.2141919184554092, 0.20333401988184574, 0.8552489932772831, 0.8774901622802798, 0.15337039473245329, 0.8884320908129576, 0.19944330650001696, 0.16788503612441452, 0.1617263522806055, 0.1760797984180522, 0.8682049106547367, 0.686016747095294, 0.21021329246322962, 0.7977034060614516, 0.7631238631271572, 0.22211130811606805, 0.15381607186529922, 0.6557583451759488, 0.18677885343663858, 0.16497534694048244, 0.20593720628824597, 0.19135741816178764, 0.19741651561553586, 0.18861820197227763, 0.19544131515671492, 0.20761549528866075, 0.1832258515773637, 0.20021004147882482, 0.20844842928797824, 0.09581573054197545, 0.10294185665338829, 0.10461662188599707, 0.10145528804142834, 0.08929326985522834, 0.09669404610465915, 0.09316927269265307, 0.09243468305792868, 0.08631891845285722]}, "mutation_prompt": null}
{"id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "solution": "import numpy as np\n\nclass MemeticPSO_Hybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.5  # Increased inertia for broader exploration\n        self.c1 = 1.5  # Balanced cognitive component for local search\n        self.c2 = 1.5  # Balanced social component for collaborative learning\n        self.mutation_factor = 0.5  # Slightly lower mutation factor for stability\n        self.crossover_rate = 0.9  # Higher crossover rate to encourage diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0  # Enhanced clamping for widespread exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "MemeticPSO_Hybrid", "description": "A Memetic Particle Swarm Optimization with Hybrid Search and Adaptive Learning for improved balance between global exploration and local exploitation.", "configspace": "", "generation": 37, "fitness": 0.3786421672337464, "feedback": "The algorithm MemeticPSO_Hybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "4cf0c597-e46b-4012-a96c-6166c6422f2e", "metadata": {"aucs": [0.8074610051903414, 0.8207688905683119, 0.797679324129725, 0.814860176296811, 0.7999924538841379, 0.8221909374273466, 0.8054741145080416, 0.7904590805130114, 0.7895582335717839, 0.6063863637941769, 0.5733615736539641, 0.5788291790124744, 0.5862949363895678, 0.571885828600781, 0.6077587799048645, 0.5725197801655374, 0.5862372889286017, 0.5900377871311293, 0.13581695535852434, 0.1458970336207669, 0.1477008490017333, 0.14108417553606123, 0.17093062503700363, 0.17844812828545642, 0.3917768585832446, 0.13976554655830553, 0.12194006468297991, 0.11180296968251224, 0.12524262339112213, 0.13012914241259166, 0.1346961948057357, 0.13624057375204734, 0.10632349268116104, 0.14254055119210918, 0.10586382379836412, 0.11037615505130127, 0.9576190743915736, 0.9424583761312734, 0.9607965796380125, 0.9578733639611549, 0.9596152674213668, 0.9515725908243361, 0.9610080531473729, 0.9556491753931183, 0.9599618169512772, 0.6563515325574378, 0.58804580275137, 0.598015840226553, 0.5866634909279549, 0.5733248417599669, 0.5980081598130582, 0.55365369191393, 0.5850142107433465, 0.5799001130795116, 0.8025447176999644, 0.7629036815888369, 0.6997857111758963, 0.21763743235801924, 0.7632725823361739, 0.8238265841460901, 0.7950195269676368, 0.7889574472977795, 0.7835372071173996, 0.2956367587378913, 0.24553817855364424, 0.30595641936246576, 0.22817130700425237, 0.25770357335363925, 0.12334357611907776, 0.25627005177153894, 0.26434796730376486, 0.34631379388002514, 0.23586437760374745, 0.24162496786579746, 0.24116344435730108, 0.26099155858128376, 0.46369720823676375, 0.32707237904147757, 0.33080563824591624, 0.23667110003856628, 0.2133881946315218, 0.195486718373728, 0.1997765676755564, 0.17418753986104762, 0.05412999384890338, 0.21823988697050467, 0.13674487094646115, 0.17657159631088615, 0.21840093063854715, 0.18581044382075318, 0.296660918779146, 0.32259535546047413, 0.3415224933336233, 0.2698566185195729, 0.30911835352671335, 0.3033054648634711, 0.3117712182120931, 0.3844602431209456, 0.32753836274299797, 0.08508483168270109, 0.11076613125971924, 0.11582420759991296, 0.24672162130159103, 0.16383952398477808, 0.07458579440971769, 0.08253816518600776, 0.11848553362155467, 0.11852197063692516, 0.21036698220093897, 0.24175051047127072, 0.2270320963110607, 0.22618790715489812, 0.2336738452393461, 0.23331046771408004, 0.24625644922133172, 0.19530448353421592, 0.10219758182002259, 0.6231309454165004, 0.5981382014069058, 0.6649738645349488, 0.621134338056615, 0.6330280200560299, 0.6432159427737161, 0.618177216197796, 0.6440918308417349, 0.5994084006158105, 0.12336569972909206, 0.13346907051688373, 0.1286167779508849, 0.11336998719123059, 0.11814331543541379, 0.1529668942341621, 0.13269201882102188, 0.08949091652862484, 0.17967436401558678, 0.21026828741866566, 0.36001762671750326, 0.22371658477786627, 0.4799292782409367, 0.26654729622490425, 0.2767221899524961, 0.5532117741702655, 0.16947192231379649, 0.2335736589499009, 0.4810430787741602, 0.4800353736554577, 0.48455366513413733, 0.46084945348059536, 0.487265973261806, 0.4802300252621793, 0.4993338771362059, 0.5010834670564397, 0.4888558000545651, 0.3253004952675548, 0.35875182791129134, 0.342819893281483, 0.27264542198018227, 0.2747542506283476, 0.31907293875291065, 0.3990461436230487, 0.29947587478471205, 0.38194185892536403, 0.24990456375450731, 0.21664865634206776, 0.23212461263974005, 0.222954999113546, 0.20531000245078668, 0.21955304324158864, 0.22300331604919854, 0.20593387486583214, 0.22087365444099938, 0.19743376533898072, 0.20438333510330275, 0.2281241995132013, 0.20435770272136644, 0.2075652848928099, 0.22115073432355337, 0.21343054488654278, 0.2374679316592896, 0.20998946870818747, 0.8813985887367238, 0.1850222317937561, 0.15287288500565444, 0.8876979682921377, 0.19943606818475157, 0.16814417427899553, 0.1417787842333007, 0.8565702040731089, 0.8625453050566988, 0.7531995589996087, 0.21104536435514032, 0.7063248354516145, 0.7510106547104625, 0.7988385825889909, 0.7335241336773517, 0.725730800257685, 0.6681257473402611, 0.7851974049738832, 0.19558647556438913, 0.20248153022849547, 0.18613844169167182, 0.20056320073959977, 0.19016758838740078, 0.20680781514806545, 0.18426451163125113, 0.19233691934386365, 0.17929749674986528, 0.09292900377838142, 0.09388512270572391, 0.08399775722439318, 0.09441100397783408, 0.1029994369509517, 0.09273374541756962, 0.08659086168241681, 0.09732088309309639, 0.09338295959267595]}, "mutation_prompt": null}
{"id": "ab7bad96-7a28-401f-ae27-75bbb57e88b4", "solution": "import numpy as np\n\nclass MemeticPSO_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.7  # Adaptive inertia for dynamic balance between exploration and exploitation\n        self.c1 = 1.5  # Balanced cognitive component for local search\n        self.c2 = 1.5  # Balanced social component for collaborative learning\n        self.mutation_factor = 0.6  # Adjusted mutation factor to maintain stability\n        self.crossover_rate = 0.9  # Higher crossover rate to maintain diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Refined clamping for controlled exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions with adaptive inertia\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))\n\n            velocities = (inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply hybrid search with perturbation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "MemeticPSO_Adaptive", "description": "A Memetic Particle Swarm Optimization with Adaptive Inertia and Perturbation for enhanced dynamic exploration and exploitation balance.", "configspace": "", "generation": 38, "fitness": 0.28913587819410774, "feedback": "The algorithm MemeticPSO_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6166730787511693, 0.5829472133247371, 0.6604300961343428, 0.5967857913635475, 0.6066969657985235, 0.594187809173202, 0.5861853247008408, 0.569394608548579, 0.5909272698734958, 0.2730264480514234, 0.2639444842844483, 0.30485045290284996, 0.264414308483899, 0.28893487848075394, 0.314751181272634, 0.2795744481033001, 0.29524540766466467, 0.2852134685516384, 0.12020757433612306, 0.11062464945937411, 0.1162004370321098, 0.11529296303365832, 0.14514073230244195, 0.12837201152906985, 0.2409190891695776, 0.12930452836067086, 0.12343192796191582, 0.11681866470491442, 0.11253345046960606, 0.10159410839116223, 0.11526540106432925, 0.10538709906402488, 0.1294834141666137, 0.11357212975008057, 0.10358022014799828, 0.10242661007405363, 0.959615600994883, 0.9553556676442941, 0.959718951076905, 0.9602723457610688, 0.9614881991473327, 0.9505932440115628, 0.9579735389435554, 0.9642355265920016, 0.9650709410778909, 0.34058540164082585, 0.3531458444617237, 0.34600497288376875, 0.33409750929584003, 0.3622643275053935, 0.3485540077038317, 0.3614817939663377, 0.36797465886211644, 0.34064190417697715, 0.5804478953666266, 0.6582874762978945, 0.5001355969881353, 0.5727763933007779, 0.6315873420163884, 0.562317162283403, 0.5933894415885226, 0.6285888107435014, 0.5709634911208527, 0.17120270566882778, 0.17984686247976156, 0.18950570333807892, 0.1675959372362038, 0.19013088965541813, 0.18539527254429433, 0.20324986510302034, 0.20168416059702843, 0.21713884758021207, 0.1772933189652527, 0.19324047964507185, 0.18604644737188347, 0.17574415461669468, 0.1787797748406187, 0.18211817784615303, 0.18600569403917622, 0.18827399997329908, 0.1741143607083281, 0.10290926272638057, 0.128967754899594, 0.10681784972619512, 0.14357846569663857, 0.10876252567844369, 0.11406149617439554, 0.12426948152030459, 0.10180398115629263, 0.09746028124081185, 0.23062561984275576, 0.2504236095568789, 0.25757032459060347, 0.25771604189661923, 0.2244068489821589, 0.19211795678633625, 0.2610092487203608, 0.28308679996558783, 0.28497373116370006, 0.03023056361400689, 0.026726088385024216, 0.021980511738865394, 0.03325138469286726, 0.024811781826269752, 0.03053597963268273, 0.03309208566653521, 0.01737506424663482, 0.034943934402375865, 0.1389081218068806, 0.1506359527519453, 0.13186410001751103, 0.14016727360551107, 0.15303469604803865, 0.14729670876477807, 0.14328719033985615, 0.14791865582967345, 0.12653567552381173, 0.46939192830447973, 0.43348621235625073, 0.46993815696970764, 0.47042500973359025, 0.4844362587508815, 0.4482527922971027, 0.4764586381593148, 0.46209086664030674, 0.48092199878023356, 0.13226532022897897, 0.10289595599387868, 0.10213273683755997, 0.11943969074639138, 0.10794606552690111, 0.10004274283385528, 0.11130513317215396, 0.10376372998737748, 0.12419067847283838, 0.190250283845243, 0.3025922624866042, 0.23094160477879755, 0.17148454994462614, 0.15574251239434522, 0.22345208051806753, 0.13802842799323767, 0.19817795866392984, 0.2044466698423778, 0.33001495883787335, 0.30478071326362277, 0.33764401548549683, 0.33093603705194086, 0.3236433044149599, 0.3127121782494643, 0.3449994419257215, 0.35052303402577034, 0.36005237407901514, 0.24586566191401715, 0.24190723612103038, 0.23893216448681343, 0.2687094545405304, 0.232680592615371, 0.2648766287700054, 0.2702186903880026, 0.27660472123012825, 0.26853524470635437, 0.19896796954636498, 0.22703620592308293, 0.21998117465762812, 0.21549723112036023, 0.23420233002955637, 0.2655405010965758, 0.1894869513869648, 0.2029624765449265, 0.2504440883055138, 0.19912933177120762, 0.31265643620789196, 0.23972772785240937, 0.33718693311674675, 0.29367133295559555, 0.19604140464098896, 0.3176240808411017, 0.24637091321690596, 0.18607019866647567, 0.685449984898127, 0.6517881010661748, 0.15072835762406245, 0.7477198467121633, 0.19595294535650687, 0.19413227749734419, 0.1833542947718343, 0.7509954584072182, 0.7325686064822204, 0.6958473789520869, 0.2088709036418287, 0.6549198799670717, 0.6042319952046835, 0.667716255640003, 0.1595572600679812, 0.19783368986907557, 0.1627533768496704, 0.19916842298208326, 0.18156476792374765, 0.19898604308250667, 0.19198571022367306, 0.19821315953262997, 0.1831419406849213, 0.20317828466656807, 0.18567795010667054, 0.2052592522062041, 0.18130321652505244, 0.08403256898847355, 0.0826802038995782, 0.08302237605883878, 0.08979774372668559, 0.08912062233017837, 0.10615008941075899, 0.08650741180304544, 0.08696336841027574, 0.07901194475104645]}, "mutation_prompt": null}
{"id": "581fc100-9d7d-413d-8533-00ab28c9d641", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for better coverage\n        self.inertia = 0.4  # Reduced inertia for faster convergence\n        self.c1 = 1.8  # Increased cognitive component for better local search\n        self.c2 = 1.2  # Reduced social component to focus on individual improvement\n        self.mutation_factor = 0.7  # Higher mutation factor for increased diversification\n        self.crossover_rate = 0.85  # Moderately high crossover rate for effective recombination\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 1.5  # Lowered clamping for finer control\n        self.alpha = 0.9  # New parameter for adaptive exploration\n        self.beta = 0.1  # Quantum-inspired parameter for probabilistic jumps\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Quantum-inspired Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n                # Adaptive Exploration\n                if np.random.rand() < self.beta:\n                    trial_vector = global_best + self.alpha * np.random.standard_normal(self.dim)\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptiveQuantumHybridPSO", "description": "Adaptive Quantum-inspired Hybrid Particle Swarm Optimization with Enhanced Mutation and Exploration.", "configspace": "", "generation": 39, "fitness": 0.3543921400872755, "feedback": "The algorithm AdaptiveQuantumHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.82468386018387, 0.8324295078342618, 0.8262957972917762, 0.815530559752567, 0.8135942345537545, 0.8287804367134789, 0.8349055039955036, 0.8245357148569006, 0.8284490789252688, 0.5964959047026182, 0.6187858425899864, 0.6008615384591509, 0.6089962421155541, 0.6242572341036311, 0.6501800139309324, 0.6145102130689173, 0.6210514316423853, 0.6046760779658559, 0.1473809837883544, 0.1001143400636052, 0.17009436770878839, 0.15855933429030133, 0.14526627802710113, 0.11810607438320697, 0.14750625801582495, 0.15689373264988293, 0.27451664440190693, 0.1150752579691422, 0.11221388873039728, 0.12417977314413253, 0.12041801576232047, 0.13758287887301068, 0.13746776259053328, 0.1521699899204405, 0.11037843995640506, 0.1381038431791074, 0.9297386955290381, 0.9234362258710387, 0.9400020719303642, 0.9173754914937056, 0.9109577699276437, 0.9182801444994616, 0.9126988635684831, 0.9415792065811037, 0.897412367044635, 0.5767018528403537, 0.5642261480493211, 0.5980309904235719, 0.4740375694656548, 0.5798102205674386, 0.5926096388258386, 0.5553969470178954, 0.5714104145032448, 0.5889583351334065, 0.8433612045141885, 0.8300457342889793, 0.731611570963352, 0.7423450728134601, 0.7038307961732901, 0.8404827042806822, 0.8003360228304361, 0.7568501354771705, 0.7788377789122858, 0.2129472524967908, 0.21246618156773867, 0.22787686587655775, 0.12568228346990196, 0.3713768033915046, 0.20282265422224777, 0.27119306193593673, 0.22741109162862927, 0.21686296415141482, 0.24253157003385928, 0.13180780763097077, 0.256827400959895, 0.26608175508686505, 0.22833688087420245, 0.30145305118088295, 0.2705235495766456, 0.12711335935511103, 0.22549659966374258, 0.042239723803248475, 0.0732089435040898, 0.06536089105740062, 0.11707160468811362, 0.05243171899718013, 0.13088259858427942, 0.11007869503974543, 0.08198895980433374, 0.08381081568955617, 0.17114896246030276, 0.1473518907171938, 0.2061621314574783, 0.17837244018784892, 0.1678181741900605, 0.12842273192584597, 0.1901913087216639, 0.18703856304642963, 0.17480231816792202, 0.19887628684645176, 0.08417377783204594, 0.05668691600126008, 0.12283785015645732, 0.07390486981649225, 0.3641506200294734, 0.09306069636997549, 0.1009566856984091, 0.08096122243205028, 0.32377423804880046, 0.1799854045100332, 0.18712772943139422, 0.22698492134611448, 0.22756490636335858, 0.22888062263446796, 0.304906950415201, 0.07865890457522906, 0.15113418957162306, 0.5759935212419132, 0.5756831492418261, 0.5705588045423194, 0.5698824696556422, 0.5366598515494208, 0.5854483008151847, 0.606155564879397, 0.5892621306307759, 0.5553033928179698, 0.12806439298599492, 0.13606334553441612, 0.1353204721883745, 0.11462662988802441, 0.11980127340769597, 0.1306016002433693, 0.15540399454868836, 0.13608886111899532, 0.15108998894743086, 0.20179963468138062, 0.3877348937526536, 0.20712113850505776, 0.26838355173262485, 0.23747406977445218, 0.2927210065974154, 0.19441966236695551, 0.22667820397900662, 0.19194906456104632, 0.5082131616076974, 0.4912438905546165, 0.47775323455987895, 0.28742737887799974, 0.44091339626683845, 0.36223515498860426, 0.4389152163762656, 0.5234720851885897, 0.26153673655651377, 0.2484194540591067, 0.2768421782542272, 0.33076080940431807, 0.18644292262795836, 0.3538247512418491, 0.3355557772525626, 0.3875158468197415, 0.3574069957923308, 0.16631647250993575, 0.23802615892091528, 0.254018542026737, 0.23732793970260435, 0.26044555884195886, 0.262649395126205, 0.22520797191030772, 0.222749171205893, 0.22724565527942187, 0.1973647707533439, 0.5995889349817872, 0.228855062277043, 0.5205683534621286, 0.18879039689657406, 0.23857148456238975, 0.21135605700871551, 0.1952920534450755, 0.2230236857994573, 0.19712858708695424, 0.18513933283629214, 0.16798350454278366, 0.18737619960458096, 0.8892184162802866, 0.8351636528930213, 0.8404105004880504, 0.6881861529413598, 0.17070965070645783, 0.8933948062046067, 0.7299775191396887, 0.20916086543393042, 0.6976685040927677, 0.20903858868027814, 0.1685859019865451, 0.15284565722361387, 0.7489597248879246, 0.15447630978668547, 0.8097483771480782, 0.19222998963827076, 0.19849525885500086, 0.18250231218810442, 0.18633364323047164, 0.19000026430653083, 0.20199084618069296, 0.1971607036443247, 0.18344187302901438, 0.1925468821090529, 0.12442510805022211, 0.09425071174884292, 0.09035299789395534, 0.089827472909768, 0.09987963871510275, 0.09306303538627358, 0.10826526470180853, 0.08434883651806846, 0.09101811556312256]}, "mutation_prompt": null}
{"id": "fdc170a3-7afb-437d-8f48-a3de0407d588", "solution": "import numpy as np\n\nclass DualStrategyMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for extensive diversity\n        self.inertia = 0.6  # Slightly increased inertia for more exploration\n        self.c1 = 1.7  # Enhanced cognitive component for stronger local search\n        self.c2 = 1.3  # Reduced social component to fine-tune collaborative learning\n        self.mutation_factor = 0.6  # Increased mutation for adaptive exploration\n        self.crossover_rate = 0.85  # Moderated crossover rate for balanced diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for controlled exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search with Multi-Phase Exploitation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "DualStrategyMemeticPSO", "description": "A Dual-Strategy Memetic PSO integrating Greedy Exploration and Multi-Phase Exploitation for dynamic balancing of global and local search capabilities.", "configspace": "", "generation": 40, "fitness": 0.31840654534279644, "feedback": "The algorithm DualStrategyMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.7232736650140688, 0.72246434109512, 0.7059649957893908, 0.7162019512257736, 0.7152108496340006, 0.7025227008093893, 0.7503936949905666, 0.7068226780212364, 0.7054299114876932, 0.3749493752612636, 0.40873326503735996, 0.3962497080003038, 0.4403025403547982, 0.3964701096338439, 0.40820642613856595, 0.3521056650398884, 0.41251923498150966, 0.3821127248839391, 0.13328818346307358, 0.1896980776529058, 0.19034609418974402, 0.15067495046765944, 0.13519618996808547, 0.13898777603317103, 0.2754751526951883, 0.1449371745062421, 0.16409280891925504, 0.11669886980005251, 0.1402334758020778, 0.10582895526720826, 0.1387259822518443, 0.12585516469134217, 0.12228618491528487, 0.14047981819212074, 0.12636242901717687, 0.1279844736295387, 0.9895942797208226, 0.9330716170560643, 0.9435431605625638, 0.9540739834629867, 0.9174864657101869, 0.9237243967232865, 0.9485849838879931, 0.9568213482184096, 0.9315249022123188, 0.4796050851541196, 0.44077355590461753, 0.4438107701258531, 0.475236281946801, 0.44435559596259655, 0.42440471307035, 0.4394566798421592, 0.41515518970876186, 0.42635314668995505, 0.6879300538796564, 0.6648832841950709, 0.677502674470892, 0.7183862247673374, 0.7020719352593766, 0.7492515252470727, 0.687009532586033, 0.6841596969489832, 0.6783144981541407, 0.22689596326803363, 0.23965179788326896, 0.23128745263739958, 0.1906166064489243, 0.19353749390059116, 0.11538886271313276, 0.20570577473976204, 0.11367398032959297, 0.2015687511088512, 0.2099218473666048, 0.22984715616774043, 0.2350923105076923, 0.14083651565272937, 0.2266043758194327, 0.24894753080459464, 0.23132759302908124, 0.2711065688955109, 0.21301151057148804, 0.06437249403669099, 0.060724816809133, 0.058985971113568625, 0.06447153864300748, 0.056126409978441316, 0.05959167126607412, 0.05515539900665789, 0.06530129285347952, 0.047054812927360246, 0.18951972524295702, 0.16537800109683576, 0.21024116867467268, 0.19747029948324812, 0.1920762979842079, 0.1684084211318142, 0.2245311260779611, 0.22422360675870856, 0.2057300125581767, 0.10846362183878722, 0.01966012439490028, 0.07485566998520976, 0.015662095592401837, 0.1415861192885226, 0.06903862935541583, 0.058160558533572604, 0.039547600729527455, 0.022514237957900196, 0.21826057663354603, 0.1715332132191446, 0.21464059595572793, 0.1630738135390497, 0.17314968999861324, 0.17397720825812235, 0.19183212935140348, 0.19888347371520576, 0.11254683015568168, 0.534420064623354, 0.5167061364798871, 0.5006783351187728, 0.5100042237421416, 0.5382179682094395, 0.5107247857026846, 0.5277841373820218, 0.5203590864811307, 0.5189884850197741, 0.10445421720792325, 0.1537566786720458, 0.11315942048988015, 0.1330427229883273, 0.12301775224206957, 0.13139620457642542, 0.10331729334268225, 0.11047173636013907, 0.1569527005011423, 0.17281603807516221, 0.294827295379001, 0.2011382846395915, 0.1914325493737502, 0.29058896312315996, 0.2283474835060315, 0.17415576347842965, 0.2250507494743068, 0.2988450211896291, 0.38290420068627684, 0.36362556868896256, 0.38767506624375303, 0.40661377278025934, 0.398741926576179, 0.387569142029936, 0.4376244391787367, 0.4059239443254271, 0.41970227958544293, 0.28990279054585977, 0.25304700907740885, 0.2722880067168395, 0.27110245751700546, 0.25011556573379734, 0.2879665921340062, 0.30880515392118035, 0.30999079948589614, 0.28591882203683094, 0.22544454661787372, 0.2411285870997938, 0.22168855008606903, 0.21583526367299843, 0.2183794174872583, 0.21131901401921716, 0.21489926905607415, 0.23951440388645073, 0.21045845199199364, 0.22520543927768444, 0.20532898963801005, 0.23296162495937, 0.3414334528983419, 0.22837868139452622, 0.23360859939849843, 0.23912775708899103, 0.21408180585041958, 0.20474091420599994, 0.18643429154197844, 0.1872376916096422, 0.18365194164471144, 0.8616066560693717, 0.19912318084557723, 0.7559602005906649, 0.14128934720759467, 0.7221756623013065, 0.8233855933084201, 0.7243807878646029, 0.2109713427172203, 0.12509314404083738, 0.71504849557541, 0.5426682835565938, 0.16566819882276362, 0.672465222534271, 0.5733124722726525, 0.6892990516684577, 0.18057597555545812, 0.2104578258689639, 0.1777195988473883, 0.18881293240331787, 0.18878428091504407, 0.20927919271623963, 0.19532370747827188, 0.19229597339170668, 0.1766598990096958, 0.08355140911490722, 0.08810842024801713, 0.11668998475858916, 0.08902177121687549, 0.09339749242101458, 0.09055478776815395, 0.09623126910467905, 0.08210573661195997, 0.08282304285014075]}, "mutation_prompt": null}
{"id": "abda8500-fdfa-40b4-b388-0955e4faebae", "solution": "import numpy as np\n\nclass QuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for enhanced diversity\n        self.inertia = 0.6  # Slightly higher inertia for better exploration\n        self.c1 = 1.4  # Tuned cognitive component for local search emphasis\n        self.c2 = 1.6  # Adjusted social component for improved cooperation\n        self.mutation_factor = 0.6  # Increased mutation to introduce new solutions\n        self.crossover_rate = 0.85  # Slightly reduced to maintain solution quality\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for controlled exploration\n        self.quantum_factor = 0.3  # Quantum factor for probabilistic updates\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            # Quantum-inspired update\n            if np.random.rand() < self.quantum_factor:\n                particles = global_best + np.random.normal(0, 0.1, (self.pop_size, self.dim))\n            else:\n                particles = particles + velocities\n\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search with Adaptation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "QuantumInspiredPSO", "description": "Quantum-inspired Memetic Particle Swarm Optimization with Dynamic Strategy Adaptation for improved search diversity and convergence.", "configspace": "", "generation": 41, "fitness": 0.2802547823599872, "feedback": "The algorithm QuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5632853689091701, 0.5586030406367233, 0.5877469232873966, 0.5941267634577112, 0.5900047556322757, 0.5694818286208285, 0.6119790459051729, 0.5595132975431185, 0.5912855200073917, 0.23881419772200874, 0.21716391881062036, 0.23745522396251495, 0.2047094993430888, 0.20364865362809637, 0.19745711559344092, 0.15223326717752916, 0.20496812665112218, 0.22317369620205318, 0.1266610724028756, 0.1610463258037238, 0.08797706433367025, 0.11287376291527185, 0.14669843381526226, 0.22247243501302216, 0.15595952184196282, 0.31600315636022025, 0.13807719927236795, 0.10528746788036825, 0.10846245838837154, 0.11404098727764445, 0.12100053424194046, 0.12344446263840236, 0.09253775944402676, 0.13839555235185796, 0.1609259036956926, 0.11818936871302943, 0.9593831325872141, 0.9416227048925603, 0.9360874966684077, 0.9343389553528022, 0.935131394861544, 0.9334996041993411, 0.9241816760999546, 0.9536475563847925, 0.9255615642169945, 0.37877357527252176, 0.3559377265662832, 0.3617729077291201, 0.36783397512515936, 0.33896537791842307, 0.3644308246921846, 0.36137793615660185, 0.35522339334298947, 0.3543247948683764, 0.2278517802351262, 0.7549708699213421, 0.22833272598214238, 0.24801639109237128, 0.7398519614101395, 0.2724330043752028, 0.7439113322301552, 0.22950984000846653, 0.5504905955781246, 0.30357881827565525, 0.12433627293433169, 0.16549864038148676, 0.24469352651317866, 0.23536519999866035, 0.12727727262637, 0.21930011576451391, 0.20727271488457744, 0.12999281480641656, 0.13178634659075705, 0.20439329630825698, 0.20062872894133488, 0.2179460111332222, 0.1940006044785738, 0.20737048013350312, 0.2182959838385169, 0.16704442830961252, 0.2766681910830413, 0.1075896678833087, 0.17711095523638654, 0.07560205639646833, 0.11487882826704476, 0.06382559420785461, 0.008071408840873984, 0.1118110530446993, 0.11811313390064171, 0.02630838110237932, 0.22582353119451848, 0.19298496726170955, 0.28479843619554157, 0.17606152439890088, 0.184149026096181, 0.1439869580624623, 0.14744005839026153, 0.22525000456161393, 0.2643860478939819, 0.08487774465438347, 0.022187353466087578, 0.053325793109601505, 0.058745402867075414, 0.07214373787182415, 0.07257542751234136, 0.0623263156231505, 0.0702602304554395, 0.03946792119638287, 0.1261966994190823, 0.17636716566955635, 0.1792479305004776, 0.1821788181477325, 0.1470227899760106, 0.19025399849711444, 0.18607095749039737, 0.1515734156847981, 0.1640929881799571, 0.51308124264494, 0.5098837403075624, 0.5154075904696307, 0.4907403890699511, 0.4862655030416909, 0.524999902087276, 0.5328868641914405, 0.5179881061272135, 0.5122620949609431, 0.08332601724162036, 0.13089151685113465, 0.08145035302582415, 0.07723733579394432, 0.09158819176209398, 0.12600212385845244, 0.09856511167663684, 0.11777442214119727, 0.15365156350401799, 0.34285692756450403, 0.31665197274687473, 0.2072404034220059, 0.3065647888284726, 0.289477652338881, 0.20820383801677433, 0.20678133098920248, 0.3362725251882863, 0.22206033666382363, 0.31539247303963835, 0.34975826190119397, 0.32881316937233995, 0.34318680097308296, 0.33711667552061086, 0.3388083775836992, 0.3499893998757929, 0.3347654831250808, 0.3530170707423518, 0.27675574988646234, 0.2734754971970772, 0.22936278762476137, 0.2821166411757343, 0.2865141166206283, 0.22613810145804925, 0.2413962547932812, 0.2772542271485636, 0.23290948494872954, 0.21861804272029484, 0.2799260821020414, 0.22657533707662603, 0.20850728777940075, 0.2197122836504768, 0.20528363147874296, 0.23139610836794866, 0.2393184734388315, 0.225197102855902, 0.19716321266802384, 0.18734381944766088, 0.209633041830096, 0.22167242915242846, 0.1917991051801271, 0.19752485003111453, 0.19814883010648177, 0.37551005607093213, 0.18822698897062773, 0.17596298187380766, 0.1870032808704638, 0.1864790116853089, 0.8508649070087242, 0.19917196316500363, 0.19796321649305126, 0.1417361402836046, 0.1660669714865255, 0.8454717052585387, 0.8165326597604594, 0.20906963891525798, 0.20496341467182633, 0.20809196042423928, 0.7006752891648389, 0.20678985710106257, 0.11245791421750395, 0.7049834992243738, 0.8343044843452462, 0.18339995672015574, 0.18829696285765107, 0.1860331972386463, 0.18573096690498914, 0.20475871021197656, 0.18338958862351207, 0.19451509818673718, 0.1958483327152578, 0.20233432787070393, 0.13420483370180059, 0.09526902223203837, 0.10122500235565801, 0.09210856741526297, 0.0895621077829466, 0.10050870304733872, 0.08473518471193675, 0.09301497761360611, 0.07734687568137966]}, "mutation_prompt": null}
{"id": "ab134d8a-2cd1-4956-b44d-42a1ac5435c1", "solution": "import numpy as np\n\nclass MemeticPSO_Hybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.5  # Increased inertia for broader exploration\n        self.c1 = 1.5  # Balanced cognitive component for local search\n        self.c2 = 1.5  # Balanced social component for collaborative learning\n        self.mutation_factor = 0.5  # Slightly lower mutation factor for stability\n        self.crossover_rate = 0.9  # Higher crossover rate to encourage diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0  # Enhanced clamping for widespread exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "MemeticPSO_Hybrid", "description": "A Memetic Particle Swarm Optimization with Hybrid Search and Adaptive Learning for improved balance between global exploration and local exploitation.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.8074610051903414, 0.8207688905683119, 0.797679324129725, 0.814860176296811, 0.7999924538841379, 0.8221909374273466, 0.8054741145080416, 0.7904590805130114, 0.7895582335717839, 0.6063863637941769, 0.5733615736539641, 0.5788291790124744, 0.5862949363895678, 0.571885828600781, 0.6077587799048645, 0.5725197801655374, 0.5862372889286017, 0.5900377871311293, 0.13581695535852434, 0.1458970336207669, 0.1477008490017333, 0.14108417553606123, 0.17093062503700363, 0.17844812828545642, 0.3917768585832446, 0.13976554655830553, 0.12194006468297991, 0.11180296968251224, 0.12524262339112213, 0.13012914241259166, 0.1346961948057357, 0.13624057375204734, 0.10632349268116104, 0.14254055119210918, 0.10586382379836412, 0.11037615505130127, 0.9576190743915736, 0.9424583761312734, 0.9607965796380125, 0.9578733639611549, 0.9596152674213668, 0.9515725908243361, 0.9610080531473729, 0.9556491753931183, 0.9599618169512772, 0.6563515325574378, 0.58804580275137, 0.598015840226553, 0.5866634909279549, 0.5733248417599669, 0.5980081598130582, 0.55365369191393, 0.5850142107433465, 0.5799001130795116, 0.8025447176999644, 0.7629036815888369, 0.6997857111758963, 0.21763743235801924, 0.7632725823361739, 0.8238265841460901, 0.7950195269676368, 0.7889574472977795, 0.7835372071173996, 0.2956367587378913, 0.24553817855364424, 0.30595641936246576, 0.22817130700425237, 0.25770357335363925, 0.12334357611907776, 0.25627005177153894, 0.26434796730376486, 0.34631379388002514, 0.23586437760374745, 0.24162496786579746, 0.24116344435730108, 0.26099155858128376, 0.46369720823676375, 0.32707237904147757, 0.33080563824591624, 0.23667110003856628, 0.2133881946315218, 0.195486718373728, 0.1997765676755564, 0.17418753986104762, 0.05412999384890338, 0.21823988697050467, 0.13674487094646115, 0.17657159631088615, 0.21840093063854715, 0.18581044382075318, 0.296660918779146, 0.32259535546047413, 0.3415224933336233, 0.2698566185195729, 0.30911835352671335, 0.3033054648634711, 0.3117712182120931, 0.3844602431209456, 0.32753836274299797, 0.08508483168270109, 0.11076613125971924, 0.11582420759991296, 0.24672162130159103, 0.16383952398477808, 0.07458579440971769, 0.08253816518600776, 0.11848553362155467, 0.11852197063692516, 0.21036698220093897, 0.24175051047127072, 0.2270320963110607, 0.22618790715489812, 0.2336738452393461, 0.23331046771408004, 0.24625644922133172, 0.19530448353421592, 0.10219758182002259, 0.6231309454165004, 0.5981382014069058, 0.6649738645349488, 0.621134338056615, 0.6330280200560299, 0.6432159427737161, 0.618177216197796, 0.6440918308417349, 0.5994084006158105, 0.12336569972909206, 0.13346907051688373, 0.1286167779508849, 0.11336998719123059, 0.11814331543541379, 0.1529668942341621, 0.13269201882102188, 0.08949091652862484, 0.17967436401558678, 0.21026828741866566, 0.36001762671750326, 0.22371658477786627, 0.4799292782409367, 0.26654729622490425, 0.2767221899524961, 0.5532117741702655, 0.16947192231379649, 0.2335736589499009, 0.4810430787741602, 0.4800353736554577, 0.48455366513413733, 0.46084945348059536, 0.487265973261806, 0.4802300252621793, 0.4993338771362059, 0.5010834670564397, 0.4888558000545651, 0.3253004952675548, 0.35875182791129134, 0.342819893281483, 0.27264542198018227, 0.2747542506283476, 0.31907293875291065, 0.3990461436230487, 0.29947587478471205, 0.38194185892536403, 0.24990456375450731, 0.21664865634206776, 0.23212461263974005, 0.222954999113546, 0.20531000245078668, 0.21955304324158864, 0.22300331604919854, 0.20593387486583214, 0.22087365444099938, 0.19743376533898072, 0.20438333510330275, 0.2281241995132013, 0.20435770272136644, 0.2075652848928099, 0.22115073432355337, 0.21343054488654278, 0.2374679316592896, 0.20998946870818747, 0.8813985887367238, 0.1850222317937561, 0.15287288500565444, 0.8876979682921377, 0.19943606818475157, 0.16814417427899553, 0.1417787842333007, 0.8565702040731089, 0.8625453050566988, 0.7531995589996087, 0.21104536435514032, 0.7063248354516145, 0.7510106547104625, 0.7988385825889909, 0.7335241336773517, 0.725730800257685, 0.6681257473402611, 0.7851974049738832, 0.19558647556438913, 0.20248153022849547, 0.18613844169167182, 0.20056320073959977, 0.19016758838740078, 0.20680781514806545, 0.18426451163125113, 0.19233691934386365, 0.17929749674986528, 0.09292900377838142, 0.09388512270572391, 0.08399775722439318, 0.09441100397783408, 0.1029994369509517, 0.09273374541756962, 0.08659086168241681, 0.09732088309309639, 0.09338295959267595]}, "mutation_prompt": null}
{"id": "ee032362-97ec-4d64-809b-1cd908c191a9", "solution": "import numpy as np\n\nclass QuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for better diversity\n        self.inertia = 0.4  # Lower inertia to enhance convergence speed\n        self.c1 = 1.7  # Slightly higher cognitive component for individual learning\n        self.c2 = 1.3  # Slightly lower social component to reduce herd behavior\n        self.mutation_factor = 0.6  # Increased mutation factor for higher adaptability\n        self.crossover_rate = 0.8  # Lower crossover rate to stabilize exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Reduced clamping for finer adjustments\n        self.quantum_prob = 0.2  # Probability of applying quantum perturbation\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search with Quantum Perturbation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    if np.random.rand() < self.quantum_prob:\n                        quantum_vector = global_best + np.random.normal(0, 1, self.dim) * 0.1\n                        quantum_vector = np.clip(quantum_vector, self.lower_bound, self.upper_bound)\n                        trial_vector = np.where(np.random.rand(self.dim) < self.quantum_prob,\n                                                quantum_vector, trial_vector)\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "QuantumInspiredPSO", "description": "Quantum-Inspired Cooperative Memetic PSO integrating quantum behavior for diverse exploration and local refinement.", "configspace": "", "generation": 43, "fitness": 0.3513268651757811, "feedback": "The algorithm QuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.8501031207423784, 0.8369896100261103, 0.8514130931405219, 0.8382057061406356, 0.8338210571081918, 0.8440451394495301, 0.8266453285557094, 0.8406062833545666, 0.8306957486147788, 0.6388742396627511, 0.6206873272599815, 0.6112940909989182, 0.6511884191467023, 0.6437495307494592, 0.6415219680405908, 0.6517483762924854, 0.6256174649067416, 0.6592517171087322, 0.2961442647969331, 0.6716968996556141, 0.15025555309676297, 0.14520725707433446, 0.1251391569240442, 0.13344836140043936, 0.14622390237789207, 0.15770807593076808, 0.17920800544110893, 0.1342829903159305, 0.14724022096384237, 0.11085721450642327, 0.10515179961566812, 0.12952768319228813, 0.11040154681031966, 0.15424352459215784, 0.1270528843169575, 0.10910457459356437, 0.9381375997177697, 0.935211786983452, 0.9556652813804835, 0.9278881031901332, 0.9136306425996016, 0.9519090971940841, 0.9436486378361968, 0.9359699581172632, 0.9354369375057631, 0.6214607087573047, 0.6275395852386987, 0.5807634772708581, 0.6436571437675321, 0.6126641655522582, 0.6017971395961796, 0.6088110169096015, 0.6165593154313178, 0.6152324580378097, 0.820183402207989, 0.7837515540101497, 0.2275189309178356, 0.2765878180218144, 0.873253077017807, 0.27103808563434306, 0.648275080164147, 0.7427368618292465, 0.8578336443211447, 0.2116411064831598, 0.18699664745860223, 0.20958030245309978, 0.12753526407275295, 0.22544145262989113, 0.33860868149290424, 0.24943882842572485, 0.2194341745931805, 0.2068851442271964, 0.28825756317844575, 0.11812811938277212, 0.19579824016190295, 0.16156844811498372, 0.23511590371026303, 0.2223835020471664, 0.13332417030684096, 0.24461633106850544, 0.25167602734894456, 0.06541626563361647, 0.05539593785497221, 0.07551600899534516, 0.09834110790627859, 0.04436146563824783, 0.04467357623157642, 0.0865210387052433, 0.04695017451675654, 0.09972733019528845, 0.18458228871813076, 0.13069747113770103, 0.1998051488578917, 0.17188168301863282, 0.1341985273950671, 0.1379126924508799, 0.18956494651313494, 0.1796311633162242, 0.1702878487877515, 0.09058488418501764, 0.25026334372637926, 0.16401755836219567, 0.14963972913675827, 0.1008578815724499, 0.08728785523698368, 0.17742123092175677, 0.1362328262449971, 0.2008609167061146, 0.1440354574457, 0.18915288151072396, 0.31429839758120015, 0.294252101244601, 0.12988311361443816, 0.17815673282737587, 0.07496538781461237, 0.203516774576749, 0.09970565323664982, 0.5589307422261808, 0.5719115267862603, 0.6101315002302693, 0.5828295729855633, 0.5516102406782915, 0.5780593288986413, 0.6347392334639905, 0.6181695605738387, 0.5903416899536248, 0.1140400773680087, 0.13711334813690734, 0.07998857455369712, 0.1435704505450207, 0.13843875873667655, 0.13878375555430633, 0.13659889666523506, 0.11961823261970128, 0.13873078111443793, 0.14145245188628686, 0.18752209005312048, 0.17766502368513115, 0.19518091741069277, 0.20715137045989607, 0.2117107617583106, 0.31490907192526163, 0.22230554800623414, 0.32442536878163464, 0.34725308616414696, 0.3817198007065895, 0.42193988082732714, 0.4373924659074181, 0.5002012426319493, 0.5351585781266006, 0.42705593594247016, 0.5394561375165621, 0.48681625911100646, 0.19150490365306816, 0.31049033586556085, 0.28105196872286464, 0.35378042540747223, 0.2891122647922686, 0.32032896053113513, 0.18257172778528974, 0.25763980858936, 0.21207707465531656, 0.22766653131928438, 0.2518078887936822, 0.22603185298131445, 0.22892158818897446, 0.24876126871134918, 0.19690594977765208, 0.21534260591636212, 0.23052414252223397, 0.2413532459258737, 0.22056768260863924, 0.21508183136571446, 0.2105383265383871, 0.7497785350008517, 0.23971926837193658, 0.20631708825125206, 0.21908492017719627, 0.20752052775088126, 0.22647691687218607, 0.8415813985544216, 0.18731328161527705, 0.1858959034915435, 0.9139813316574286, 0.19962530001920142, 0.16940542484631183, 0.8227305944729106, 0.16037058346909694, 0.9021448315053264, 0.8783458928590955, 0.2112701424503144, 0.6133920100755912, 0.20894060600128095, 0.7805494207182049, 0.16487747528071162, 0.7177485140842315, 0.16623866318871783, 0.8294120988897798, 0.18730796740726252, 0.21462090361344732, 0.20914599244604415, 0.18112958185490657, 0.1921612790585997, 0.1945137337062679, 0.20530681556610342, 0.18452375035519009, 0.19813494034442702, 0.08368268078328633, 0.09693852324049679, 0.0902576676430239, 0.094158689172393, 0.09869844099873937, 0.09214754745169629, 0.12075441821433164, 0.09823612252291036, 0.10363949225434355]}, "mutation_prompt": null}
{"id": "bbc8cfcf-0daf-4c38-b34c-067bc133247f", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for better sampling of the search space\n        self.inertia = 0.6  # Increased inertia for balanced exploration and exploitation\n        self.c1 = 2.0  # Increased cognitive component to intensify local search\n        self.c2 = 2.5  # Increased social component to enhance cooperative behavior\n        self.mutation_factor = 0.6  # Increased mutation factor for improved diversity\n        self.crossover_rate = 0.85  # Optimized crossover rate for maintaining diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for controlled exploration\n        self.adaptive_scale = 0.5  # Scaling factor for dynamic adjustments\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n\n                    quantum_vector = personal_best[a] + self.adaptive_scale * (personal_best[b] - personal_best[c])\n                    quantum_vector = np.clip(quantum_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            quantum_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptiveQuantumPSO", "description": "Adaptive Quantum Particle Swarm Optimization with Dynamic Learning and Mutation for enhanced convergence and diversity.", "configspace": "", "generation": 44, "fitness": 0.25000780205551465, "feedback": "The algorithm AdaptiveQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5005896192720556, 0.48157013289141515, 0.5069568336908399, 0.4904336989670042, 0.4856708623846363, 0.5264562709145297, 0.5290926829489813, 0.48062906369154956, 0.5308092809782645, 0.18601869834923435, 0.1855498024989477, 0.16420493142608705, 0.16381593688094254, 0.18455704734655032, 0.19649763158538458, 0.20246788462106047, 0.2147807325729284, 0.1790660547751699, 0.1122882788443128, 0.10988107502245714, 0.09818479004948599, 0.09608042747381973, 0.09771902755301942, 0.10682201782040979, 0.11502104096199706, 0.10317517543191679, 0.1302937886945349, 0.09213407583026112, 0.10289759309886981, 0.09372454564925303, 0.11684924528539198, 0.07953099822633791, 0.1008308233235875, 0.0979408608321275, 0.08754010071727081, 0.08273013173301802, 0.9691304345581742, 0.9457529443669215, 0.9503809789501659, 0.9529613810611828, 0.9345977834176874, 0.9412572263360635, 0.9426054451992042, 0.9608498229500287, 0.9349672081506737, 0.2914048317073893, 0.27783824238423693, 0.2564656867727586, 0.26936700625956, 0.2643267020766846, 0.2806413593453483, 0.24561774185493468, 0.2539038355914528, 0.2644472286607895, 0.5128103715599135, 0.5365476003680201, 0.4945390959951491, 0.4876968714738764, 0.4092353066417429, 0.5268972908489861, 0.47148215542157335, 0.4306860662631925, 0.5431814859607885, 0.19769434480858228, 0.14521123323872198, 0.15459642869284362, 0.13011441838991955, 0.17575001458701522, 0.13468817554286505, 0.14446230158317552, 0.15907357448729964, 0.14639772536183937, 0.16636502025275945, 0.19259333726151617, 0.14876167910409477, 0.14506634493302517, 0.18865859012881558, 0.16154317614701486, 0.15536343266487418, 0.17323879624134664, 0.1810347088798755, 0.06577915762651321, 0.08901758291905881, 0.08962533319170385, 0.04198588392554736, 0.05997502761072826, 0.10138141398441547, 0.08374065633792738, 0.0718297231303775, 0.09202531387368218, 0.20702440732388283, 0.20661229131628045, 0.21488302617993382, 0.21704753216552686, 0.2237843091600752, 0.2106982479436913, 0.2449290316336582, 0.22596633699114588, 0.19785252194870795, 0.013002704990659697, 0.02034167918822527, 0.0254211374307568, 0.014531901535371428, 0.008953392727335974, 0.013564494644752623, 0.017199406795535888, 0.03787495961568843, 0.01372193132083721, 0.12333723855286316, 0.1188363995122792, 0.12773832056267054, 0.11783979285966839, 0.11103762239083304, 0.13119684876171245, 0.1276579332840283, 0.10485323259287693, 0.13700328189352462, 0.435814406136975, 0.44104811581063197, 0.4561104182712483, 0.4307664707165195, 0.4450220550906874, 0.4436473887257819, 0.45240072572577206, 0.4426961549889624, 0.4419478696720689, 0.09352007556932007, 0.11517205264352537, 0.0866976466751006, 0.1008124572233583, 0.09410920100161169, 0.1015797422664706, 0.09136059479209147, 0.11873472978139943, 0.11898182691694315, 0.1658735434338936, 0.23192216053375592, 0.14209544792946305, 0.1851121769303652, 0.26927530832330426, 0.14759543597357572, 0.25267322440152606, 0.262649780937663, 0.14371217627107058, 0.2708911953937858, 0.29014918055409467, 0.2844321747603623, 0.28913889368753964, 0.290593201522096, 0.29386974600613225, 0.3033626461949719, 0.27901732042257954, 0.2823587832830853, 0.23183173582694916, 0.21489827088967395, 0.22086053963835817, 0.23366764558249464, 0.24214729704517024, 0.22821995896054292, 0.22812997130426682, 0.2485076322015901, 0.2005662634595562, 0.19896288724111688, 0.19040024611143824, 0.1953451110191362, 0.2286264364669509, 0.19142515037308971, 0.21319018212752006, 0.20143169249653814, 0.27084698954677877, 0.20981779603167183, 0.19651334068995263, 0.21480738001482513, 0.1801249246943113, 0.19858178356304557, 0.1771014990068699, 0.18560243354636763, 0.21308370752037475, 0.17891200439881072, 0.19351787401212783, 0.1813475038753145, 0.18502416308481207, 0.18431917675393483, 0.6993059406595881, 0.19713896205908576, 0.6076752886716168, 0.14161464982197502, 0.6510006472005678, 0.6835514023409831, 0.6214536377475729, 0.20520753670121883, 0.5180077750310024, 0.2056587229799659, 0.16762386465867662, 0.16391456404837668, 0.15008332077447795, 0.5807020858530029, 0.19682570997642923, 0.20212073517581552, 0.18711481037673194, 0.1900637403391544, 0.18961185354718557, 0.18389254606338923, 0.18240758916118582, 0.1881966162419053, 0.18668778391834162, 0.1845149618066424, 0.10157035567288963, 0.08210934518026847, 0.08733766532769949, 0.09279774472169233, 0.0867693977889612, 0.0958262346321026, 0.07996300615977814, 0.08175486128862308, 0.08493931726472692]}, "mutation_prompt": null}
{"id": "0f81f942-766b-4d09-8c39-6fa14d2031ce", "solution": "import numpy as np\n\nclass QuantumInspired_MemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.7  # Increased inertia for broader exploration\n        self.c1 = 1.8  # Enhanced cognitive component for more pronounced local search\n        self.c2 = 1.2  # Reduced social component for diversified learning\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5\n        self.quantum_prob = 0.2  # Probability of applying quantum superposition\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.85\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search with Quantum Superposition\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_shift = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    particles[i] = 0.5 * (particles[i] + quantum_shift)\n                    particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n\n        return global_best", "name": "QuantumInspired_MemeticPSO", "description": "A Quantum-Inspired Memetic Particle Swarm Optimization leveraging quantum superposition for enhanced exploration and diverse solution landscapes.", "configspace": "", "generation": 45, "fitness": 0.23682033071832342, "feedback": "The algorithm QuantumInspired_MemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.4405467293507219, 0.44546130253001415, 0.4464494463770017, 0.46665440828375526, 0.45839166242425977, 0.45270617343806685, 0.4466416961855799, 0.44174004603927575, 0.4352806200024947, 0.1744239196975259, 0.14646831057045895, 0.16484998769108006, 0.17820905063691483, 0.18005679921973028, 0.14875790293823188, 0.15289389395243091, 0.14406538567767002, 0.15252900160546923, 0.11314530148964108, 0.09601851633647107, 0.0847350539826004, 0.092452136028922, 0.12359107212624731, 0.08503089209013126, 0.09269405356098814, 0.09471334287417466, 0.0952532942883918, 0.09563651229998904, 0.08042925786048782, 0.09573776623077734, 0.09915494700572125, 0.07520581551857308, 0.07742084333777455, 0.10184068522168532, 0.07804313866267476, 0.08310441339569585, 0.9530834935997751, 0.9580380232966538, 0.9546894138274348, 0.9500590703166815, 0.9420313999065413, 0.9422233288760108, 0.9501132474037713, 0.9623824067155909, 0.9531972389485514, 0.24671743243325917, 0.2483060957453691, 0.23938153627702863, 0.2389882412426645, 0.24717659252912993, 0.23418013304073093, 0.2309889974842091, 0.233844790734832, 0.23896979312942246, 0.4908362601354622, 0.3193851356038042, 0.4103139103976622, 0.47746239949500857, 0.4495972449609217, 0.3947805172705596, 0.28372138433275573, 0.3033450435723658, 0.4331610175924918, 0.1598065023876225, 0.1130267627258168, 0.1417377097852146, 0.1557721768213165, 0.14724956495345154, 0.14071959391632394, 0.15668803150231092, 0.17759361363291937, 0.16989967673256579, 0.18627698200755127, 0.1410538203284839, 0.15367473933719034, 0.13795234855650074, 0.13743863492271957, 0.18311416045582707, 0.15451623117046587, 0.14255552679526828, 0.1585808239577462, 0.0819970296495025, 0.08800516850849105, 0.05746292441225631, 0.0712336487774583, 0.08188129467122884, 0.027924050643472254, 0.059321092312733525, 0.07942454163956647, 0.08069851078510837, 0.20419823818535232, 0.23971336364809426, 0.212066222980841, 0.19545476611710566, 0.22031796647226487, 0.17921501319315736, 0.21241005464753548, 0.24312314615546227, 0.19204119413924237, 0.011026485090573801, 0.002552439999596756, 0.0019895428302283413, 0.0031738757976325083, 0.0016591338847942172, 0.00675186295562713, 0.010878070310976207, 0.0006061213936294774, 0.0005403267857851946, 0.12044219825569547, 0.120429676164999, 0.12213064733614032, 0.11472051741096378, 0.12096048373758772, 0.1205906723760174, 0.11652263247470751, 0.1146335082578116, 0.11109704740421744, 0.4164144121518242, 0.39457860378901843, 0.4098752806806054, 0.43251320709541097, 0.4090027285139024, 0.42091832546419194, 0.4071565016083938, 0.4091908339465752, 0.42305957571513586, 0.07986473930947091, 0.08273513436131508, 0.1038815909252746, 0.0909177938557747, 0.09972540396089402, 0.09618250577856857, 0.09559820026142385, 0.10719759847349941, 0.09129850361502889, 0.14019963554525205, 0.16111350943960423, 0.14936352808883913, 0.16441436401883236, 0.1513485354053501, 0.17043249307823194, 0.1654979069446767, 0.1537498146871702, 0.1608111819275524, 0.2724131790182166, 0.284888632671651, 0.266490004024001, 0.2734148447059661, 0.26618452693849937, 0.25733001336676553, 0.2689917081068094, 0.2725679059082844, 0.26894287882161705, 0.21672409346668675, 0.20926155229205845, 0.22037028093094446, 0.202623923077063, 0.2146336302315276, 0.2075857911605501, 0.20531420531896682, 0.21924250650623156, 0.21198641356684833, 0.2069652221134607, 0.2226776086705603, 0.19466388454530992, 0.20107334895089146, 0.19804072358538338, 0.19798715075100104, 0.18581896242090046, 0.18750949755048563, 0.20782472952740383, 0.17392825360119246, 0.180788256030612, 0.18359144702643715, 0.17518269998792657, 0.19152865406164188, 0.1741245395215394, 0.18117987759219822, 0.18248573202116558, 0.17185319765973817, 0.41998588546479054, 0.18369389438588068, 0.18828464156126756, 0.6855131699760103, 0.5355120420740702, 0.185940382814895, 0.27045846017289077, 0.41607871382315553, 0.6902130864402374, 0.5648236332593929, 0.2081855539725509, 0.5629206104284612, 0.20558408593745947, 0.508794964403956, 0.15051600105377272, 0.5428701411360981, 0.43121894119895443, 0.4343672906643803, 0.1858762462918626, 0.1879974410621349, 0.18069659587382414, 0.19754187589300198, 0.18908519817096503, 0.1785992324443718, 0.18288494699377522, 0.18316522827707404, 0.19189089810509008, 0.08409681085047194, 0.07722180429561465, 0.09173188608466676, 0.07725388728372296, 0.07957242090511663, 0.08344644444840432, 0.07363389200897485, 0.0833230111884774, 0.0848224346442581]}, "mutation_prompt": null}
{"id": "b06a1b92-ae6d-417f-8c07-84b8c4f135f4", "solution": "import numpy as np\n\nclass EnhancedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for more diversity\n        self.inertia = 0.4  # Reduced inertia for refined exploration\n        self.c1 = 1.7  # Enhanced cognitive component for better personal search\n        self.c2 = 1.3  # Reduced social component for more personal learning\n        self.mutation_factor = 0.7  # Increased mutation factor for exploratory robustness\n        self.crossover_rate = 0.8  # Adjusted crossover rate for strategic diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Reduced clamping for controlled exploration\n        self.dynamic_neighbors = 5  # Dynamic neighborhood size for adaptive influence\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            neighbor_indices = np.random.choice(self.pop_size, self.dynamic_neighbors, replace=False)\n            local_best = personal_best[neighbor_indices].min(axis=0)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (local_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search with enhanced strategy\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedMemeticPSO", "description": "An Enhanced Memetic Particle Swarm Optimization with dual adaptive learning rates and dynamic neighborhood size for improved convergence and exploitation.", "configspace": "", "generation": 46, "fitness": 0.18450731156918565, "feedback": "The algorithm EnhancedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.4779530896470304, 0.41383385611089685, 0.45341421544847127, 0.43122506565298113, 0.46025809705662035, 0.4780247475840955, 0.4481936076450618, 0.4509379809890486, 0.4439378883636771, 0.15147579851076987, 0.14165645817084094, 0.1678826162170488, 0.14675112842171545, 0.16611726480884537, 0.1424647038857726, 0.18310645013289828, 0.18186159400740887, 0.1500595409587755, 0.0857909146813729, 0.07426300632377147, 0.07560637418007354, 0.07905365110855833, 0.07273969845850192, 0.0883656850532063, 0.08623259826874852, 0.07403283830627738, 0.07458966801397526, 0.05573978604450891, 0.05897190755582593, 0.05565776784449006, 0.06029133954963872, 0.058740239554084805, 0.05865297028582406, 0.05568858615073513, 0.062128813589283016, 0.06129579305938626, 0.7275262215763656, 0.7649719391348395, 0.6205095200013356, 0.8983058614036967, 0.9256338491720246, 0.8020614505114184, 0.9440823644437597, 0.9121982508146178, 0.91810218053194, 0.15317373812839685, 0.13234428699126732, 0.1573044237160437, 0.17040921263914532, 0.15531670266230446, 0.1713753520636706, 0.20873746896397882, 0.1910816284266722, 0.21339714259262788, 0.21773371260043295, 0.21213609476092865, 0.2670696268862255, 0.22951972020684985, 0.22772128944099357, 0.2303434061828361, 0.21649482608348347, 0.23370030739633596, 0.2674005180720407, 0.12202436012440232, 0.12329427707629925, 0.1281210911552273, 0.11954008953736461, 0.12087587165176394, 0.13060193027874734, 0.11701329056819632, 0.11956493125144119, 0.11969403327528183, 0.11096600825448588, 0.07019195244951748, 0.10842606192074322, 0.11307120420651084, 0.09956305990618453, 0.11452438741987281, 0.10831138245091021, 0.11705684074870282, 0.11249403123034918, 0.003694890271739526, 0.012855847875118176, 0.0010508260539929815, 0.009856108433385136, 0.00663798549268102, 9.999999999998899e-05, 0.012837392194901653, 0.031145041590932676, 0.01737106027793811, 0.1362975920765499, 0.11331417387878351, 0.13803063117931236, 0.07921584110584967, 0.07505331292942607, 0.08201994342597696, 0.1351743104536134, 0.10952451808177577, 0.11900475300845992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06083382015666028, 0.07083194747042965, 0.06264169393003305, 0.06795307227135872, 0.0707721464571307, 0.0745022519917331, 0.07571193289041733, 0.06868274130779939, 0.08198918269634181, 0.3623285320183345, 0.37946962302149845, 0.38322962582054465, 0.35940968909247994, 0.36697378572258754, 0.37493441250356296, 0.37524424295143655, 0.3805005237704092, 0.40266740427629266, 0.07162291400846565, 0.07291559248874202, 0.08785685476953498, 0.07744120386103481, 0.06562191365452907, 0.08157860130367955, 0.08288074235768983, 0.08814377223060132, 0.07517397067615517, 0.15386622374316283, 0.13925925211654866, 0.14852638068275104, 0.14107810649692798, 0.15406878378785582, 0.1595425116572029, 0.1763315077624531, 0.16427769639908874, 0.15502095225780466, 0.19702702129436522, 0.1931601764713774, 0.21277720972539482, 0.25759243639348806, 0.22335732538012165, 0.2462457141776364, 0.2376621119780059, 0.23996845631747055, 0.22953850260696762, 0.1579767429249681, 0.1547701312159957, 0.16027475349931974, 0.15114477210035782, 0.16193438722444753, 0.14847418707393933, 0.17801603407762545, 0.17432393068371854, 0.1670134701597712, 0.18463337431730686, 0.17485551491444007, 0.17823511799355451, 0.20102587342129796, 0.17623011384419174, 0.1709746429272453, 0.17110703641351976, 0.1917872906695427, 0.16949319565271326, 0.2148847844718832, 0.18750953630314193, 0.19143776473581042, 0.21623250220959733, 0.24190937268961044, 0.20377776334069309, 0.17802597122386288, 0.18128565339240565, 0.1766184714144332, 0.3716797993031824, 0.15968430869921724, 0.24408687788459993, 0.3109997175134651, 0.21656616232152293, 0.1862680035933476, 0.18619319839315518, 0.15370050786719314, 0.15109614531198856, 0.1370653322065224, 0.14377355384930957, 0.16607074496766894, 0.17466734493919334, 0.17567631695911112, 0.18729283994435675, 0.19018811293745908, 0.22563708559736584, 0.17358703421565858, 0.1843848381556128, 0.170469975334266, 0.1758322836299363, 0.2035150168007046, 0.18113659467565324, 0.19906754052578557, 0.18652667943614698, 0.17173003427474853, 0.18975697870624086, 0.06786943386038491, 0.0683818667517706, 0.06173599886255976, 0.06487898222580224, 0.06269285379268552, 0.06669796771666425, 0.06555635708591778, 0.06373064743726775, 0.06515134244323417]}, "mutation_prompt": null}
{"id": "e51121c3-18d3-4c8d-a8a1-ef0e640e791f", "solution": "import numpy as np\n\nclass EnhancedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly increased population size for diversity\n        self.inertia = 0.9  # Adaptive inertia starting point for dynamic balance\n        self.c1 = 1.7  # Increased cognitive component for local refinement\n        self.c2 = 1.3  # Decreased social component for reduced groupthink\n        self.mutation_factor = 0.6  # Adjusted mutation factor for exploration\n        self.crossover_rate = 0.8  # Slightly lower crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0  # Increased clamping for broader search\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Dynamic inertia adaptation\n            self.inertia = 0.5 + 0.4 * (1 - eval_count / self.budget)\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search with Random Resampling\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = np.random.choice(range(self.pop_size), 3, replace=False)\n                    a, b, c = idxs\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedMemeticPSO", "description": "An Enhanced Memetic Particle Swarm Optimization integrating Adaptive Inertia and Random Resampling for improved convergence and diversity maintenance.", "configspace": "", "generation": 47, "fitness": 0.23500779352632722, "feedback": "The algorithm EnhancedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.49829060739563724, 0.48412689006372, 0.4740075876894806, 0.5032626340447582, 0.4806153538601178, 0.5265720074063358, 0.49851815649025544, 0.5004829076433549, 0.5293505856642574, 0.16648523490771328, 0.1677691327973605, 0.15933678535862927, 0.15407557160784124, 0.1763233333342047, 0.1577441263847168, 0.14050144397677944, 0.17022764812490843, 0.15888895411843007, 0.17066749532015124, 0.10970418808888172, 0.10096465646069841, 0.11498880795459099, 0.11004199589316688, 0.0937773649140421, 0.13505771650145126, 0.11284420647362259, 0.11003235738373474, 0.09565510870267369, 0.09162076315153367, 0.10539877916868867, 0.09597481128837404, 0.10148610848231077, 0.085736234065518, 0.10114315693644493, 0.10065396657734216, 0.10888147284407768, 0.9695079511740403, 0.96639610596789, 0.9703061944280077, 0.9612519156269403, 0.9604592885235496, 0.9604176597216922, 0.9683052086628101, 0.966208381637339, 0.9691958956160207, 0.32425619348752766, 0.28893925958524624, 0.286699879588852, 0.2659123165674333, 0.27169710459850727, 0.26837951154019646, 0.2654226728218321, 0.2846961069428555, 0.2892587968718675, 0.4883431924930194, 0.4255398150109474, 0.38568794631756165, 0.461992493572179, 0.37702383585282073, 0.3562820466108291, 0.46689821434181966, 0.4044153816322342, 0.4835873387529186, 0.15110123662704245, 0.14862151898719422, 0.13699937814191543, 0.11039745511417587, 0.13955687889891433, 0.09368987816817864, 0.13660895595470302, 0.1286089565958073, 0.1627809638359058, 0.13607514714023583, 0.11961112592047962, 0.13814476964060063, 0.16738919967510124, 0.14119408665975697, 0.15293665660084788, 0.14626760763405744, 0.14389943820010975, 0.13404253866826343, 0.026585496740834436, 0.0322276877070502, 0.022471520224905173, 0.041627026375142706, 0.024682224043762857, 0.025693506941405597, 0.020560992665676014, 0.011289885935221178, 0.006412980784309408, 0.12846840802582504, 0.1387061509031957, 0.16221223467633894, 0.11094982419826427, 0.105066312373566, 0.139018329232255, 0.15252855720773384, 0.14530857395083419, 0.12670712174812238, 0.0006103844205932463, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004620011787022538, 0.013611241802210294, 0.01572770611474239, 0.032052329154368064, 0.0031367872636619554, 0.08336573394022684, 0.09211169810950137, 0.07675358664254472, 0.09319752238148049, 0.10866608280931744, 0.10835958276820945, 0.07627513712250844, 0.09864351160549556, 0.07868781658281865, 0.41008762512174146, 0.4009843345143945, 0.4070252535312404, 0.4058039999259305, 0.41730240486576675, 0.42357693981674216, 0.39813591876598786, 0.3887611510163004, 0.4103055580611765, 0.09499798074963073, 0.11046560025072016, 0.0902121061734813, 0.10543544894659773, 0.11305602509729584, 0.09088183698895314, 0.08548477817070765, 0.0869322095468773, 0.10632644818941894, 0.1730742385554771, 0.21995925258523807, 0.1685140544442254, 0.19978817915854585, 0.2580251343481901, 0.15570904133470664, 0.1466047993039007, 0.14073190672486868, 0.1942798670878496, 0.2897426052043104, 0.2822831627889013, 0.2846871636765137, 0.2822891488341216, 0.2883270945237961, 0.28636201730614197, 0.28999570008353504, 0.31066750785733943, 0.29626013614390745, 0.21684762381302036, 0.23425695541543445, 0.2004464211335858, 0.21883725034315493, 0.21874202596640202, 0.2234416525615187, 0.22627626259692202, 0.24137005708671777, 0.231627824885403, 0.20253176416633067, 0.1816923955902343, 0.18926807873161833, 0.20395940486650888, 0.19488258259718327, 0.17868506574165877, 0.24289309513458568, 0.21117567132808435, 0.21229288899246723, 0.18855966720517114, 0.20173207380571734, 0.19697038878204098, 0.19806302221193484, 0.2595530816980678, 0.20297215432915394, 0.19557198370995044, 0.19303179007313087, 0.1842664953656774, 0.6483980825133755, 0.18390005313079782, 0.18380760567824828, 0.6708363893930329, 0.19286760540197734, 0.19336957498819263, 0.5921386295236983, 0.16669298063890636, 0.6228674723788876, 0.47816556641938823, 0.2019460781568636, 0.19761813233204006, 0.30250968357946906, 0.1671851438240214, 0.16300518068494663, 0.204814785951128, 0.393652495258383, 0.5440258142390366, 0.17553472022464922, 0.18692444418751764, 0.18560859111440497, 0.18749738568686336, 0.20078995652471254, 0.1737711653284716, 0.18626208021688861, 0.1842728107021221, 0.18973847511205044, 0.08877895647758582, 0.0762539043320507, 0.07278064110769067, 0.08901325318252162, 0.0904333225461934, 0.0780085820730867, 0.08672823589381728, 0.08597523917024641, 0.07963543816203311]}, "mutation_prompt": null}
{"id": "56a39289-666a-4cfe-bd42-b97e7316646b", "solution": "import numpy as np\n\nclass EnhancedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for broader sampling\n        self.inertia = 0.6  # Adjustable inertia for dynamic exploration\n        self.c1 = 1.2  # Slightly lower cognitive component to enhance social learning\n        self.c2 = 1.8  # Increased social component for improved global collaboration\n        self.mutation_factor = 0.6  # Adaptive mutation factor for flexible search\n        self.crossover_rate = 0.85  # Adapted crossover rate for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Tighter clamping to prevent excessive exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        def adapt_parameters(eval_ratio):\n            \"\"\" Adapt inertia and mutation factor based on evaluation progress \"\"\"\n            self.inertia = 0.9 - 0.5 * eval_ratio\n            self.mutation_factor = 0.4 + 0.2 * eval_ratio\n\n        while eval_count < self.budget:\n            eval_ratio = eval_count / self.budget\n            adapt_parameters(eval_ratio)\n\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search with adaptive mutation and crossover\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedMemeticPSO", "description": "Enhanced Memetic Particle Swarm Optimization with Adaptive Mutation and Feedback Mechanism for Dynamic Balance of Exploration and Exploitation.", "configspace": "", "generation": 48, "fitness": 0.27181912636570305, "feedback": "The algorithm EnhancedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5697879809914173, 0.562943409401535, 0.5627113489349413, 0.5903538325400284, 0.5799671926486072, 0.569015832830104, 0.5838445787497722, 0.5809055113523749, 0.5490299567277339, 0.2164780374572054, 0.23638005790547978, 0.26777603363911506, 0.24656034862136733, 0.2256119033923295, 0.2377706497373363, 0.23263797899262084, 0.2532585223629159, 0.21896246784967932, 0.12105058421072568, 0.10245263478761157, 0.18550788731277768, 0.13821059899565658, 0.13084985820714012, 0.10944935650153442, 0.2209439621212338, 0.11797926130061465, 0.12594922644022954, 0.11150726756338569, 0.1108636751194414, 0.11437323074302752, 0.10876678591544153, 0.09838060775583579, 0.10683371082853865, 0.13267475345295987, 0.09154511657661546, 0.12466702809161256, 0.9664589250231244, 0.9573379905814327, 0.9585198535082269, 0.9586289294239967, 0.9339264385869156, 0.9491664163950185, 0.9587657061665061, 0.9614996923912352, 0.9514689953682243, 0.35266885794162994, 0.3526749962229111, 0.328356235155708, 0.34759379907561916, 0.3575613227074175, 0.3114815687778325, 0.34454058911152974, 0.3076638680312982, 0.32433179508288834, 0.5885025420411132, 0.6376419685168867, 0.4742789084790101, 0.26785467617486847, 0.5594120599838107, 0.6309897007579983, 0.6415172882468017, 0.5700641778174076, 0.512451536842863, 0.1693660948142227, 0.18419824799207019, 0.17426829034810176, 0.16509386467472287, 0.23416495388105507, 0.13956467261145733, 0.19166940180851577, 0.1587115772534884, 0.167449124643536, 0.18522332179923806, 0.16940065128859627, 0.16739617599219658, 0.16650152499781723, 0.17804958524942982, 0.1761367084642287, 0.16643493395780184, 0.19179234508555432, 0.19969017906831532, 0.08110045079355843, 0.0933552631384389, 0.0742878695253325, 0.10965644609592129, 0.07207205228009084, 0.07027927083656627, 0.11140163458276042, 0.0795031179927369, 0.0795859074427222, 0.20892340726823966, 0.21198470489957222, 0.2421530063934696, 0.19781881644595845, 0.21943825412395768, 0.1902858544865066, 0.23715430170156337, 0.21727380325480727, 0.2286500468867939, 0.01110004497171535, 0.015847494593130618, 0.022033812922875762, 0.02428793672666929, 0.004686573149010997, 0.011548696151216786, 0.030670726696147566, 0.009297813948271116, 0.011204626564468745, 0.12669738351009419, 0.12131059094554508, 0.1334273221904707, 0.0991316559241775, 0.13348657585843504, 0.13243693685729063, 0.13114566497154678, 0.12619611308395928, 0.13695265994805472, 0.4720654858970713, 0.45645923221288953, 0.4440813209736395, 0.45397007391788324, 0.4438147584978246, 0.44928704906856287, 0.4408213180596985, 0.4813912872078887, 0.46532701242864827, 0.11987430118028897, 0.11360189721466174, 0.08944139491567238, 0.13521688618136518, 0.09932367310957702, 0.1300195471822928, 0.12050979763968539, 0.10036761427648966, 0.14882863079606612, 0.16985385660486296, 0.20119180501772238, 0.1611939660219075, 0.1942719275875957, 0.17029145455631367, 0.21774127656426068, 0.18220831905437607, 0.19269173581540877, 0.18396303245925305, 0.33681574437461936, 0.3064387057835013, 0.3351093521007893, 0.33863455455530034, 0.3274223058399379, 0.3227380372200265, 0.3479379803651669, 0.3381757871349983, 0.32074822039799833, 0.25622354161780436, 0.23378360797687925, 0.248636332206998, 0.26436410332713445, 0.23641790888571224, 0.2485493726634792, 0.2627825788371634, 0.25331615277157193, 0.2395194408398048, 0.21244164643772379, 0.220805771248078, 0.22656945574142584, 0.20410369374799076, 0.2154147601311318, 0.21056860272418876, 0.19838875087283991, 0.21907408668317108, 0.20848592693607193, 0.1981445034237994, 0.22209801470415136, 0.18545360288873747, 0.3390403312688335, 0.2170810998956506, 0.24955934968064963, 0.23620640793079484, 0.2827225244448279, 0.18884780024529635, 0.18331618590113008, 0.18507755667148917, 0.6065386482219403, 0.7396018569471772, 0.197895102145502, 0.1918132213350564, 0.14028211899091714, 0.6405724841025313, 0.7053765314751299, 0.6416269193806436, 0.2075647874369534, 0.5565339108155714, 0.2044421366996939, 0.5392691004008211, 0.15195702458479732, 0.10449314058758397, 0.20349257512059626, 0.6525877000787343, 0.19321533327182194, 0.1952398759429037, 0.18498125990031422, 0.19781561279111481, 0.18937874547375855, 0.20064225172731576, 0.17907383817706868, 0.18810679998719404, 0.1963956565263104, 0.12482366068459672, 0.09351033494917715, 0.08661163708293229, 0.0906688069101711, 0.08342464808430827, 0.0795442469041211, 0.08182801818306196, 0.08986999293173015, 0.08207234465788404]}, "mutation_prompt": null}
{"id": "d1fd6d6b-83e3-4482-99b8-e3fdd5a1f73f", "solution": "import numpy as np\n\nclass QuantumMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintaining the population size for diversity\n        self.inertia = 0.7  # Increased inertia for broader exploration\n        self.c1 = 1.2  # Slightly reduced cognitive component for better global search\n        self.c2 = 1.8  # Increased social component for enhanced collective learning\n        self.mutation_factor = 0.4  # Reduced mutation factor for stability\n        self.crossover_rate = 0.85  # High crossover rate for maintaining diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Slightly less clamping for more controlled exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "QuantumMemeticPSO", "description": "A Quantum-inspired Memetic Particle Swarm Optimization using Entangled States for enhanced global exploration and local exploitation.", "configspace": "", "generation": 49, "fitness": 0.31190653657377837, "feedback": "The algorithm QuantumMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6545695542682999, 0.6740961484247192, 0.6591111975465023, 0.6743096036750323, 0.6436981633809267, 0.7023604760746769, 0.670623752223428, 0.66184800965596, 0.6503902192879533, 0.3216167936604879, 0.3387680981844208, 0.3248522287518887, 0.324974274056704, 0.3062572354327079, 0.30908722538370403, 0.3399218811443375, 0.3429351537049883, 0.27872144304021196, 0.17846574103078905, 0.1311850957636116, 0.15719393746533772, 0.11514684379210416, 0.14875064888515876, 0.12224724812612764, 0.13459605797903385, 0.1512789734503267, 0.15638110076783474, 0.10282573834031139, 0.1312145468717757, 0.12198985368488724, 0.1243667745446222, 0.10886223975764364, 0.1134611092135106, 0.11292591549678255, 0.15245699434405302, 0.11036270765931055, 0.965025269628523, 0.9522584018562144, 0.9654968405481631, 0.9504253955976045, 0.9629888017326942, 0.9489425664805773, 0.9585999934228533, 0.9439177993881175, 0.9580331030514946, 0.3830715826700425, 0.4206324766361308, 0.3912491032798915, 0.3868596525085679, 0.32103018954017193, 0.40930655105700486, 0.4172643641018746, 0.38057907148169057, 0.4150238031049627, 0.7445580424810476, 0.7514507701065651, 0.6669016408980597, 0.7488181875786766, 0.7585007740511985, 0.6695996732460636, 0.6573385665856446, 0.4144812989486566, 0.7275297535636739, 0.17543093446142144, 0.1963549023156963, 0.17390598135243251, 0.1975811572175762, 0.22037067508671404, 0.20331743620366027, 0.18105421442995995, 0.23150377452262472, 0.1821305671900112, 0.23634072331778055, 0.19653755771967474, 0.240601203897857, 0.20674790866956072, 0.2295928614390983, 0.2138373923768152, 0.21663240139458007, 0.20515798039749666, 0.19791984735559742, 0.14516036693883538, 0.14971010198561674, 0.09583448663278782, 0.06673840880656212, 0.07261999465377356, 0.11117146495800023, 0.1121732881491142, 0.051879916260018755, 0.13711148279260177, 0.2661240521774729, 0.26537443050127185, 0.23086237002641352, 0.3222820033634194, 0.26227137919823085, 0.14658287461655506, 0.33773098508437405, 0.30251189505938214, 0.29709927829959626, 0.0557191280098992, 0.07939175717935709, 0.07360065570697694, 0.05756707403930361, 0.05201821301477427, 0.07036919443406786, 0.07230347291235173, 0.0774904155435514, 0.04498787037278107, 0.1704280446738763, 0.18146110578508023, 0.19450738701329862, 0.2027452183392977, 0.20570553422278148, 0.1699580393962209, 0.17666833238321356, 0.17795611339782103, 0.09347923600728503, 0.5373830639150714, 0.559734971137541, 0.5365475363638643, 0.5343268320772427, 0.5381270167293589, 0.5245394950919938, 0.5483886454740909, 0.5107805619683496, 0.5103614486102945, 0.11599733340328244, 0.11039464328854265, 0.12853107653521256, 0.09759772171538694, 0.12251070504679773, 0.1248270024991589, 0.13052773318436373, 0.11857524723162038, 0.12022041524844684, 0.19012085218607022, 0.2204652638935598, 0.3465385403219873, 0.3954164966183028, 0.30068309588168163, 0.4133951679298058, 0.2410285504285291, 0.3170604799757806, 0.20724405140035485, 0.34094963695802727, 0.36099177363654633, 0.35663539433493474, 0.38796666755082054, 0.35160746449347, 0.33103728368811003, 0.3885419148103636, 0.3580371403337619, 0.39087459824239845, 0.2784366433788641, 0.28812192841266704, 0.28060706056226203, 0.29998096714618094, 0.25934692165922346, 0.30356128919279934, 0.3042621491654298, 0.30781568269014203, 0.292684246511384, 0.26312988481174593, 0.22068005423275794, 0.2239682064020625, 0.21809292275479275, 0.2327687877936666, 0.20285514663254756, 0.23196708446668468, 0.20271775462789898, 0.2357745264531116, 0.29160533510135334, 0.2271401560466213, 0.4442468228312235, 0.2895564130367315, 0.22937173680739442, 0.20958621239128072, 0.22074978580265903, 0.29052067551300753, 0.20194432758473546, 0.1861098856270944, 0.1823423800509527, 0.18436169024721238, 0.8078382404171861, 0.19910084737916922, 0.1688039405659021, 0.6874586458491316, 0.7522108203174047, 0.848458424929292, 0.7509129525637812, 0.20841161093281846, 0.20209195212019815, 0.204640340680328, 0.20681631204797057, 0.15523994274179653, 0.7279623629403432, 0.10403380391531936, 0.6894681940110516, 0.18179244646880577, 0.2013953013569233, 0.18411443424735685, 0.18449699102522177, 0.20465109099491374, 0.20174708658871765, 0.2029621848837344, 0.19059970221838995, 0.1860816646651231, 0.08581668558065336, 0.08483556058729569, 0.07817655984738758, 0.0860996668483891, 0.08400790627067167, 0.08609768085907288, 0.08586453468630373, 0.10487429234700263, 0.0961274690080085]}, "mutation_prompt": null}
{"id": "9666db12-ca2e-42e2-a002-357edb102f7c", "solution": "import numpy as np\n\nclass ModifiedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.6  # Modified inertia for improved convergence\n        self.c1 = 1.7  # Slightly increased cognitive component to encourage local search\n        self.c2 = 1.3  # Slightly decreased social component to maintain diversity\n        self.mutation_factor = 0.6  # Increased mutation factor for enhanced exploration\n        self.crossover_rate = 0.8  # Adjusted crossover rate for diverse search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0  # Enhanced clamping for widespread exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "ModifiedMemeticPSO", "description": "A Modified Memetic Particle Swarm Optimization with Enhanced Diversity Control and Adaptive Parameters for Improved Convergence.", "configspace": "", "generation": 50, "fitness": 0.32384414130204614, "feedback": "The algorithm ModifiedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.76868545707742, 0.7927534694148295, 0.7599219917095419, 0.7556316238883283, 0.7735869713973531, 0.7605869864094323, 0.7702763466295304, 0.7739229204302986, 0.7595203647842467, 0.4654586557672642, 0.4677809033248126, 0.4314144028286929, 0.46884978958799495, 0.4731286735377639, 0.4877531306801055, 0.5240102322831, 0.4754821957093941, 0.5176562867825995, 0.14768393886816156, 0.14189824680050223, 0.1372691732914052, 0.1474020603614835, 0.14060299972507873, 0.3271708274574354, 0.1571464890225439, 0.13682547535403722, 0.13963968876973465, 0.12908065591588458, 0.10952452081589015, 0.12470636799391377, 0.1698828795246602, 0.15084433676796594, 0.12896679298404945, 0.12969978238337065, 0.12758501219298068, 0.10844331117443284, 0.9686258822364535, 0.9579374512128317, 0.9675917825627502, 0.9544970919737782, 0.9731190665240477, 0.9516533531560598, 0.963939393195909, 0.9666367960943127, 0.971475574247545, 0.5246693032941033, 0.48426935052129794, 0.43250708481801836, 0.5274310169805745, 0.46097196239304916, 0.5065407129034787, 0.4863733487761699, 0.4793998635210657, 0.4962461537476749, 0.7217716560004087, 0.7092634733257814, 0.7103843903406251, 0.7056080006973025, 0.648760041374207, 0.5775714122278299, 0.6343091932191065, 0.7735932486747553, 0.7924079759150731, 0.19756490946517313, 0.1712929955621516, 0.1969163801265731, 0.12053745442448127, 0.23024616160673106, 0.2233393576371726, 0.20157665889155085, 0.21367457025652958, 0.19435019406632337, 0.2226281313181112, 0.1889156746634264, 0.2382691990448228, 0.24117515104681564, 0.22078430777378433, 0.2147378257431476, 0.24770186436671393, 0.2968534745481354, 0.12652322626490464, 0.07404232850303305, 0.05935855771127496, 0.07404078236274014, 0.0840435824944199, 0.04356786415576319, 0.03124223084148503, 0.05995946529998797, 0.068334917360245, 0.09257616570960914, 0.18887898274337955, 0.2050311232439932, 0.2179618313728886, 0.16805648135551365, 0.15399695041909545, 0.15932689779667786, 0.1767682316866781, 0.1883086010610575, 0.18707742950050166, 0.060906235159329136, 0.031870900270613456, 0.03962933384328293, 0.17002573950001465, 0.08287254234921981, 0.0660265321380048, 0.08025472057180727, 0.1177646771862153, 0.05907264155083958, 0.1895581500965915, 0.17316419946594674, 0.16991976533411712, 0.16037283749434916, 0.21404960321600597, 0.20140029064604692, 0.15429155906993797, 0.13082282322595584, 0.07851810319605279, 0.5285976712897195, 0.5462277187288516, 0.545328031185212, 0.5485807333963312, 0.5229161810303898, 0.5382618782758545, 0.5322468793923743, 0.5458890313849869, 0.5137452775799638, 0.09838698877802676, 0.12125946484799899, 0.11218738503820735, 0.15778510584692573, 0.12071079880744895, 0.10792733035709845, 0.10618434647844466, 0.11573657334911147, 0.1717601459723277, 0.22275249442987155, 0.24374261771000527, 0.21798142061159576, 0.2302361386008357, 0.4169846653535868, 0.40439687546803316, 0.40557772048281426, 0.20478510578691944, 0.1821446118998491, 0.40135986095147935, 0.46261619171558843, 0.39358879486170373, 0.4429327900773191, 0.3644158675799366, 0.45293495585699206, 0.45448348077940437, 0.4772294879067346, 0.43657921755125517, 0.3435130432078589, 0.2982187757956831, 0.2534717110756789, 0.2550500369280776, 0.2613515559842162, 0.30885368212359954, 0.3148411686030267, 0.2923732008299401, 0.2439417446881561, 0.2194549945498564, 0.18566783370543294, 0.19663367152101852, 0.2559053161648748, 0.23392986794121962, 0.22484862312800247, 0.2320057964008494, 0.20790866051567602, 0.21489372107665372, 0.2078545502915704, 0.20062994822164493, 0.21562571090479665, 0.48707238242690787, 0.48119687278865286, 0.19785130055369626, 0.2106026585312597, 0.21167163982905124, 0.23019916847649013, 0.8262141276226374, 0.16584798216222785, 0.15117552381498356, 0.7151765522074913, 0.19928691144408017, 0.1980095298766209, 0.18080510111122716, 0.16247596037223744, 0.8423521699713522, 0.7428102960905358, 0.21147893222804925, 0.7677545671920498, 0.7535940913547435, 0.2085710855713261, 0.1546766523309403, 0.10457134064545137, 0.104605822719127, 0.15340407462441386, 0.19016139323157, 0.18626204369739208, 0.18719969026930983, 0.19181308004709696, 0.18108011896719622, 0.18056353076833764, 0.20897818548102698, 0.2071149065193033, 0.17920646838265475, 0.09312537180531744, 0.09114154349691128, 0.09577268872939781, 0.08425401294202162, 0.08934784757300318, 0.10474865560457802, 0.12336846969685034, 0.09514842335218543, 0.09566773739156542]}, "mutation_prompt": null}
{"id": "45d5a994-9647-46a2-9e7a-cd5a7c488fd3", "solution": "import numpy as np\n\nclass FusionPSO_Hybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.9  # Start with high inertia for exploration\n        self.c1 = 2.0  # Increased cognitive component for faster local adaptation\n        self.c2 = 2.0  # Increased social component for stronger global influence\n        self.mutation_factor = 0.4  # Slightly reduced for stability\n        self.crossover_rate = 0.85  # High crossover rate to encourage diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Reduced clamping for controlled exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            self.inertia *= 0.99  # Dynamically adjust inertia to improve convergence\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "FusionPSO_Hybrid", "description": "FusionPSO_Hybrid: An enhanced Memetic Particle Swarm Optimization incorporating dynamic inertia adjustment and elitist crossover for improved convergence speed and accuracy.", "configspace": "", "generation": 51, "fitness": 0.29838768368800783, "feedback": "The algorithm FusionPSO_Hybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6251025665191448, 0.6293906368806754, 0.6149278197594796, 0.5792067268563225, 0.6255722538868917, 0.6310851270207516, 0.6483309751828575, 0.628992966353824, 0.615418362007822, 0.3278162992244852, 0.356797370727147, 0.318995108074545, 0.28173122097304715, 0.3846355870576401, 0.34983545357712087, 0.31374958408269327, 0.3189987416225766, 0.3105544590272957, 0.11257173854058622, 0.1070320148308258, 0.14467384537167838, 0.1081060334415761, 0.1596228046333521, 0.13849204058479592, 0.12514814866547674, 0.12928295885338592, 0.1437945199330588, 0.093423549849729, 0.11928583078513788, 0.12047048206281596, 0.11344527422863138, 0.10993468237305204, 0.10019623867326377, 0.10865823429676569, 0.12469381407129876, 0.12048130091587594, 0.9552583229695937, 0.9525231559024945, 0.9577497130623362, 0.9558553170328021, 0.957598233749838, 0.9503494631323764, 0.9588030997985707, 0.9322502096326752, 0.9501353184843625, 0.3685422143648347, 0.33257753743647334, 0.34325107083773565, 0.370561278689272, 0.3561985128458993, 0.3716015975826368, 0.3366464399237872, 0.34090224960664905, 0.36475823201588087, 0.6416360595845363, 0.6080504188005997, 0.6870142497473224, 0.618875155490987, 0.6105805877834383, 0.7355968237122132, 0.5363223872911573, 0.7050780579077516, 0.615575557719261, 0.18119003167514014, 0.17576264209656878, 0.1600199453204728, 0.176637931655112, 0.12188383185361706, 0.17216206712557847, 0.17418149937279281, 0.1927482709995968, 0.22475146656552647, 0.17912459765328914, 0.1973651620211313, 0.18136921489802083, 0.18426115935419796, 0.20637951246755404, 0.16423946900679243, 0.19832820989054256, 0.1819796463273553, 0.20641344221917046, 0.12412800993374473, 0.08091475490042233, 0.11923119931719106, 0.14621543928963132, 0.0962972012220431, 0.10802640110074624, 0.11203489497440955, 0.11473218008020392, 0.1690494076180883, 0.2933573044724751, 0.1913017508558018, 0.3099396715010201, 0.24873921778673358, 0.11272459666850121, 0.10754397354052359, 0.15547978504810167, 0.2784491423251715, 0.2417815935120461, 0.043633419207709134, 0.04469582198423849, 0.03876423594711864, 0.06979880690589013, 0.04927824698145411, 0.04512600150521362, 0.04675941120234006, 0.050299826437270156, 0.07495251426741212, 0.15847117615177808, 0.1727416583606859, 0.13981882526565592, 0.17399992922775076, 0.1877583278234508, 0.15914470149262194, 0.16109900259140686, 0.09553739146154971, 0.09352407912159655, 0.5128369787864719, 0.5359939733990289, 0.5016240129257272, 0.4817335311747294, 0.5101479497559773, 0.5180405115206025, 0.5011861052770967, 0.5556653068913024, 0.5127624375890787, 0.11708151609330342, 0.09312550841301381, 0.11176968601169734, 0.12268612815950586, 0.11650993773935003, 0.10891611586398708, 0.11359900695091552, 0.11956855101543074, 0.1362432960191936, 0.25155361575670454, 0.21216676945547353, 0.1757892660897611, 0.167964864008473, 0.2903188280692539, 0.20720781733381854, 0.21160048337301618, 0.23278860560791936, 0.22837661156710376, 0.3559002410653582, 0.33640873768027135, 0.34316720680335744, 0.3398677659303093, 0.35767725684294915, 0.3481207308501305, 0.3683152196591959, 0.35613676196303656, 0.3441953294900748, 0.2514552431665138, 0.239994244368534, 0.27048577586961076, 0.25452900831463177, 0.258166705212456, 0.26619610693666795, 0.27597677935731557, 0.28224226758300097, 0.27650321430677127, 0.2143283613855015, 0.2123219014896719, 0.22626876995435297, 0.2244551904292642, 0.22746919303228375, 0.18098223141497705, 0.23237038474103855, 0.2091919168247296, 0.2197467171997901, 0.21453905930271266, 0.206182497151302, 0.2637149150099283, 0.19609318838964418, 0.3499577052744217, 0.29210179015395354, 0.24482515163144858, 0.22132558775967714, 0.3184649864348681, 0.1850105077741373, 0.7192300956245545, 0.18503473264986547, 0.7672365765295098, 0.19812888730159117, 0.19638769441922244, 0.16969248864068598, 0.16463309138306526, 0.7953863178815495, 0.749588219035239, 0.21027671234185707, 0.715746266730918, 0.6530564704807267, 0.20521943378647278, 0.16146041573376457, 0.6926073913120584, 0.7022919772518889, 0.6763863091682591, 0.18552984517196247, 0.18662667089887508, 0.23464575091294593, 0.1833482413386801, 0.21614503412570496, 0.19345179388122813, 0.18247689298026093, 0.18809668369340837, 0.18642756920429937, 0.08215044569762808, 0.09502070721849465, 0.08098389416472151, 0.08012567459250863, 0.09104661720784657, 0.0893296874311389, 0.07877150983458725, 0.08322020881159664, 0.09113926693518093]}, "mutation_prompt": null}
{"id": "50b4d537-5299-4df9-9ece-9ebc10c427ca", "solution": "import numpy as np\n\nclass EnhancedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly larger population for increased diversity\n        self.inertia = 0.9  # Adaptive inertia for dynamic exploration control\n        self.c1 = 1.7  # Increased cognitive component for refined local search\n        self.c2 = 1.3  # Reduced social component for emphasis on individual learning\n        self.mutation_factor = 0.6  # Enhanced mutation factor for better exploration\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate to maintain stability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping to prevent excessive wandering\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions with adaptive inertia\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)\n\n            velocities = (inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedMemeticPSO", "description": "An Enhanced Memetic Particle Swarm Optimization with Adaptive Inertia and Dynamic Learning Rates for superior exploration-exploitation balance.", "configspace": "", "generation": 52, "fitness": 0.2647012473338163, "feedback": "The algorithm EnhancedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5987847595989346, 0.5604045545186538, 0.5421152769876308, 0.5816833997921853, 0.5515957806129678, 0.5729048031345544, 0.5535307838279512, 0.5506253114876504, 0.5559065575431756, 0.22767716107224556, 0.242585090012443, 0.20380700730882229, 0.2387830887179624, 0.22249686968313565, 0.2387786183427354, 0.21585023842254947, 0.20616746702839006, 0.21443372378167824, 0.182764408564695, 0.12068814040932141, 0.2241112257381741, 0.15450853153105293, 0.11188419020704077, 0.12098831038147873, 0.11371346729211385, 0.1316793594027884, 0.11964839053788912, 0.09915890008190731, 0.101441203500658, 0.12098923024727826, 0.12979124258975405, 0.11097805836283858, 0.10973845099569968, 0.09974225788144464, 0.09354384122618398, 0.091443915796806, 0.989593401705775, 0.9570632696757312, 0.9584991980912679, 0.9559061404659156, 0.9456451632766137, 0.9247813899388547, 0.9502679033008055, 0.960381364751274, 0.953479606488759, 0.34515353668868143, 0.3256653583282386, 0.3177282606789167, 0.315174760036227, 0.2936915252605129, 0.3204586196629331, 0.31967381849635423, 0.30574100204618615, 0.3237425992062486, 0.42779230816627345, 0.5204398005635278, 0.5214347391776722, 0.5571362397092642, 0.5556448439571846, 0.5213938703754339, 0.664625262320659, 0.5391439945344643, 0.5220513729642693, 0.1823922928700592, 0.14927252630775745, 0.1569949900595098, 0.11063849376785928, 0.16295172844549455, 0.1284366311205304, 0.15365861339318287, 0.1540616425288397, 0.15060457213369915, 0.16336237918761365, 0.19267576427095645, 0.17923521561983402, 0.16018085575716146, 0.16330541211734162, 0.16324748798904476, 0.1651907516515999, 0.17680173305224234, 0.16001647609085945, 0.05218670668704217, 0.038586144467426364, 0.05096552644816876, 0.06278476370529296, 0.046228288545065666, 0.02132137914753618, 0.048112088859083246, 0.08422016007992439, 0.06844898672082766, 0.17333707613370786, 0.15682608565726586, 0.18895898367376562, 0.1607423856554404, 0.17039539968127282, 0.1653766042171947, 0.20962659526610583, 0.1800708233494528, 0.17125083210425984, 0.0036180390611271207, 0.002427397563794287, 0.012326125987280112, 0.0030490253168518056, 9.999999999998899e-05, 0.011183228526301492, 0.005108952475326056, 0.013511678491937129, 0.0028487878598921768, 0.13308059817302942, 0.10664353991497721, 0.10414686000431705, 0.10816527839251688, 0.1157875150953761, 0.12165132784338262, 0.11010814756526266, 0.11503383289398139, 0.11684973435318913, 0.47112342788588424, 0.4405754635711472, 0.4363055503324259, 0.4307376199028602, 0.4524372205197189, 0.426185213652027, 0.4514413867458128, 0.42267486593606696, 0.4562548869757307, 0.11151816996173691, 0.09270121429122868, 0.11595090138342634, 0.12064452528896852, 0.12958263419342164, 0.10507580927239446, 0.11499506362472534, 0.10073770451680852, 0.12044001489201694, 0.15814401353818086, 0.16823795116688967, 0.2869471942703593, 0.1706659235002882, 0.25385248071815125, 0.2119102396238629, 0.19010169835813373, 0.1973277211015837, 0.1596876219144635, 0.3116158676817543, 0.30938517331728876, 0.3229306358576377, 0.32484673287571575, 0.31483435336758203, 0.3133547171676746, 0.32297611844558016, 0.32808215454323486, 0.32771537988467025, 0.21394527701636679, 0.2348686563593506, 0.23641518200804956, 0.23342482834468126, 0.23422490479697344, 0.21467491698901453, 0.25677447442144685, 0.24326318326233665, 0.21904527987208744, 0.21422702172529562, 0.22616874182721647, 0.1969748094682895, 0.2218813396484296, 0.21874838010143394, 0.242967515914559, 0.20594732527663862, 0.21260184841200325, 0.22534265999502323, 0.19442427329844025, 0.20851438418026957, 0.1989396940132372, 0.37515487167479145, 0.1851859197666147, 0.18606412527009197, 0.18888213957990452, 0.19817905482135956, 0.2518679208133624, 0.1820940856293617, 0.18457675693324782, 0.18353628316976411, 0.7113550320596735, 0.19554685254606907, 0.5960811641009656, 0.5444402402017366, 0.5832706042617254, 0.7091892022277512, 0.5228270962613903, 0.20413360317341467, 0.5188064463325337, 0.20142824471438436, 0.49094265875862886, 0.16435849560219318, 0.6080083159725582, 0.20340532239512532, 0.5714149525416391, 0.18574236613992456, 0.18646041541715785, 0.1738307633242515, 0.17269147692946774, 0.1954905343564064, 0.2133627166464147, 0.1823827338218711, 0.20301910459689843, 0.1900521173976829, 0.08661369687830733, 0.07752792644340656, 0.09107935466564343, 0.08252288778803363, 0.08532303105972405, 0.08692711218796467, 0.08088167957126202, 0.0938576927970235, 0.0862226452942032]}, "mutation_prompt": null}
{"id": "fc3d3131-05d8-43a8-811a-4e4de0b6ab22", "solution": "import numpy as np\n\nclass AdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for diversity\n        self.inertia = 0.7  # Adaptive inertia for dynamic exploration-exploitation balance\n        self.c1 = 2.1  # Higher cognitive component for focused local search\n        self.c2 = 1.3  # Lower social component to reduce premature convergence\n        self.mutation_factor = 0.8  # Increased mutation factor for exploration\n        self.crossover_rate = 0.85  # Slightly lower crossover rate for focused search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0  # Increased velocity clamp for extended search range\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))  # Dynamic inertia adjustment\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptivePSO", "description": "Multi-Phase Adaptive Particle Swarm Optimization with Enhanced Mutation and Dynamic Parameters for robust exploration-exploitation balance.", "configspace": "", "generation": 53, "fitness": 0.22955756084680942, "feedback": "The algorithm AdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5106188334260248, 0.4435274783010892, 0.4713409037586409, 0.48927467450267015, 0.5010807936241708, 0.5020705156497389, 0.5641449028010366, 0.504985693507625, 0.47979944115431017, 0.14592891654041873, 0.15874648872700292, 0.1666407630192538, 0.1275511574137549, 0.14004899862213205, 0.15615571490012103, 0.1457183969830962, 0.16486042240238497, 0.14206741936493128, 0.09458496355404367, 0.10778762317342028, 0.10028853888902445, 0.10644712278128698, 0.11108005078003313, 0.1176341743196403, 0.13746990949475624, 0.10511317402157638, 0.11627295601666843, 0.09645058618392999, 0.07986832610616201, 0.07991372136388708, 0.12022991657974413, 0.11777259861158795, 0.099885099579607, 0.1049758298726623, 0.08994546996442043, 0.10280855409731116, 0.9732851064491668, 0.9664404026225966, 0.9679635799795766, 0.9658455711236912, 0.9660015690665407, 0.9658097872755969, 0.9635746117914679, 0.9701024942597016, 0.9678017573436659, 0.2679934992584173, 0.24640375268834103, 0.2375873568234219, 0.26246130392947953, 0.2657162128113131, 0.2482385849972052, 0.27884634196690783, 0.21019624557585304, 0.25362356350176773, 0.3602641723552855, 0.37131612790739366, 0.41752888375677144, 0.3966696103399451, 0.37212527976505494, 0.4354454368670777, 0.38328723096237427, 0.2776484551046441, 0.37132110296602105, 0.14718302375305137, 0.0982769050522394, 0.11759825388005518, 0.12125746260797643, 0.13081148039443447, 0.12526028281533597, 0.1283842137055855, 0.11710382481656711, 0.15874523885778158, 0.13032607645263705, 0.04616847448315853, 0.14275800139790862, 0.13381901622037984, 0.13220522185699468, 0.13453217799192863, 0.13741016761876856, 0.14792797316759387, 0.1421132050407783, 0.0034881238638968526, 0.006619741559478087, 0.0028869765693576577, 0.013373042955262426, 0.012326581574758855, 0.0026244126016812253, 0.017921924839313208, 0.0157843980306408, 0.015620184604481446, 0.1182081866031156, 0.07996987967307012, 0.09871710878515405, 0.11711152617152087, 0.15918801173913766, 0.10981027991026038, 0.13462732305806024, 0.13578707295536097, 0.14613949620857947, 9.999999999998899e-05, 9.999999999998899e-05, 0.021460580327038792, 0.012429260034855338, 0.04675144213516591, 0.043289003740099696, 0.00950543573142748, 9.999999999998899e-05, 0.05990457785952952, 0.1262892356751496, 0.08868975634196408, 0.11184128009960403, 0.07828282549146537, 0.08658990599338556, 0.09685810402565675, 0.09708560264436106, 0.10755782163005678, 0.07236529090992028, 0.39643337099732756, 0.3916566924055508, 0.38691767252981346, 0.3837247420587919, 0.38178776673643444, 0.3910061681435163, 0.4158818426445018, 0.38922903500780104, 0.38566293003954577, 0.08837942139286481, 0.10594214431216475, 0.0853015824548713, 0.09990196342468749, 0.09060647838438451, 0.11108641983065104, 0.0939996458518304, 0.1111194582611964, 0.0806321161557707, 0.1535660358044315, 0.16917987844327076, 0.20895840035992586, 0.15922182478785707, 0.21209490323273417, 0.1812727084987904, 0.16942524382859225, 0.17988514420767387, 0.1639176948629778, 0.2745550258912399, 0.2780786276629882, 0.2623829768017485, 0.2684849517523983, 0.2991645351099481, 0.258122957372521, 0.2805883053082703, 0.3111450999081897, 0.27553832141800194, 0.1978761432229419, 0.19377687369961805, 0.19783091985646117, 0.20420053459864007, 0.2132660569024778, 0.22620641605538716, 0.22631894660495955, 0.25269627130665673, 0.21982969008638975, 0.21184944705269104, 0.2057116988495291, 0.19639775298526008, 0.20716793186969562, 0.18848205799615547, 0.1799775722694732, 0.21011469042014497, 0.18461931835771384, 0.24858485814714304, 0.18919847699255254, 0.17672759904679647, 0.19874717321196844, 0.2820686714696059, 0.18693452138431654, 0.22435748321567084, 0.19329486312640487, 0.18539567877640128, 0.17826733769577097, 0.5797349817183493, 0.5879135657076309, 0.1784715803797834, 0.6692463137582026, 0.19290193494681385, 0.19258353266970907, 0.17694977194590955, 0.4068838884404099, 0.6052336892022017, 0.4621136814561658, 0.19658346900247137, 0.18654362998701335, 0.47000792526988755, 0.3441098362986048, 0.3535707143419934, 0.18798840082919643, 0.20329799985259556, 0.47561963077799396, 0.18007014148536926, 0.18177839634528403, 0.1901990079908843, 0.18677326922341142, 0.19208851129280968, 0.18619010583850681, 0.18512094961167247, 0.18912138352529628, 0.19151474576268757, 0.09447914241284361, 0.07307479873155442, 0.09134535339738925, 0.08095194567616204, 0.08317122081148576, 0.102029379514876, 0.06982215866357311, 0.08077995230709334, 0.07354349661748238]}, "mutation_prompt": null}
{"id": "5637c37a-17d2-4a17-8777-200aa1b69da3", "solution": "import numpy as np\n\nclass MemeticPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.7  # Increased inertia for broader exploration\n        self.c1 = 1.4  # Slightly reduced cognitive component for wider exploration\n        self.c2 = 1.6  # Slightly enhanced social component for better convergence\n        self.mutation_factor = 0.6  # Higher mutation factor for increased adaptability\n        self.crossover_rate = 0.8  # Lower crossover rate to maintain some stability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0  # Enhanced clamping for widespread exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (particles[a] +\n                                     self.mutation_factor * (particles[b] - particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "MemeticPSO_ADE", "description": "A memetic optimization approach combining Particle Swarm Optimization with Adaptive Differential Evolution for balanced exploration and exploitation.", "configspace": "", "generation": 54, "fitness": 0.26770372973456474, "feedback": "The algorithm MemeticPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6948594984378647, 0.6651686367549158, 0.6473941671313255, 0.680082379289515, 0.7064823689995758, 0.6913104251342203, 0.6615524747362853, 0.6865175147875107, 0.61746091750025, 0.2033057604507006, 0.2755054180137845, 0.2522972021328196, 0.28007013157504124, 0.2683066537120119, 0.27517819882009165, 0.28033591762913, 0.2439189273158946, 0.28232189965413723, 0.1300953010278827, 0.12839006813922893, 0.13978018227861577, 0.34367229896074636, 0.121396717831177, 0.123591771177478, 0.11633134296258485, 0.12852520783684573, 0.14420598262705175, 0.12282179239644642, 0.12195647109406749, 0.13981581191222525, 0.1329543699782293, 0.12270097400364488, 0.12346067431544583, 0.11742259904226482, 0.11346808900253091, 0.12961131186772967, 0.9695929324672158, 0.9614277827862715, 0.9697714115922346, 0.9639608227568064, 0.9696728717137302, 0.9523767386025769, 0.9713732304333164, 0.9563095132073333, 0.9780862386310376, 0.3673857174129236, 0.36247981841698107, 0.29465164564652846, 0.4022909389972523, 0.37911514099699584, 0.3518612469615414, 0.3642494452152242, 0.3519084902578701, 0.3729878302318591, 0.6921739028827917, 0.3358658725448601, 0.21038068327275927, 0.21070050112891292, 0.191609908452807, 0.5953023990879992, 0.6686475391406967, 0.22532999051511005, 0.7094128029712132, 0.17142187475084159, 0.11358297023660557, 0.15888042731606233, 0.11908462114760054, 0.16849744574842096, 0.16357488925117492, 0.16886647860878856, 0.19573759066495722, 0.12394912486681386, 0.15977701515934017, 0.1521781233348023, 0.17658873099422945, 0.14646071223539925, 0.17381033300476123, 0.164695031317722, 0.20301841628690898, 0.09405943282269125, 0.3333879527569841, 9.999999999998899e-05, 0.04282885245265422, 0.009438762893260177, 0.03146175664061679, 9.999999999998899e-05, 9.999999999998899e-05, 0.05111077709800904, 0.0017895924419466525, 9.999999999998899e-05, 0.09206533217072288, 0.10378463129281024, 0.12269578349523746, 0.07498579823526108, 0.0566381346980801, 0.024200255483338484, 0.058048609363552495, 0.090858533327969, 0.06685514781713131, 0.033792907178119225, 9.999999999998899e-05, 0.03340594239323802, 0.05885639325932657, 0.11281500345962081, 0.10523133352410163, 0.16008808816192455, 0.08578211252265189, 0.06764253827280486, 0.10670146893837607, 0.13323846232861558, 0.13779238620029577, 0.08225627995707763, 0.22641630614838182, 0.12571749258326703, 0.09647421787444532, 0.0743812612908541, 0.07293784800009817, 0.4741656409306523, 0.5073056708949828, 0.4907754913087726, 0.5039924469049681, 0.46452076307242784, 0.47967751627668775, 0.4743514708789106, 0.4763603209394206, 0.45357938833032596, 0.07093724429178838, 0.11746030377873251, 0.1255608454139261, 0.10899978428971535, 0.11879959824876674, 0.1030141529215316, 0.09133158102415984, 0.0948413827596023, 0.11932085802505876, 0.19623037811432387, 0.21251630530551213, 0.19174779183370838, 0.359403558991378, 0.24128851612046043, 0.18347824772968924, 0.410026904148899, 0.20807882767739727, 0.2045479796274673, 0.36140236643660495, 0.3359922058075373, 0.3339700662185978, 0.38319178753801275, 0.3447214084732707, 0.3430657134828533, 0.35420223669784856, 0.3860296107907618, 0.37748945133392053, 0.26961545401029563, 0.23696739379521536, 0.218265978461185, 0.15399381249317434, 0.21506836357744485, 0.28065094397579693, 0.23755745679741957, 0.2923695555519724, 0.2155388298598525, 0.2134893304338088, 0.20061879300945495, 0.20834922920058685, 0.19745785475705457, 0.21997995861120212, 0.20336067078375342, 0.2093911776207964, 0.21811991512117435, 0.23299201888105803, 0.2401526018077178, 0.2367185155910222, 0.1948130019663601, 0.2311111467120608, 0.3361850051193285, 0.20080721221560116, 0.2743307709048909, 0.22882302676263555, 0.19009583288419085, 0.7960661895730392, 0.1867140000499521, 0.15311130300984244, 0.8290242543571892, 0.19942481657151534, 0.16751046060226216, 0.14141805736206203, 0.16132971215146086, 0.828793629189621, 0.45382499670350085, 0.2084825064228274, 0.20491294865040965, 0.5795986532638524, 0.16738976701863795, 0.1539013972779858, 0.48619939342908036, 0.10319668139294025, 0.4411527194525421, 0.18539226372455497, 0.1848529990873844, 0.18179923051159885, 0.20632746190610074, 0.18265819227378166, 0.17140726596890377, 0.18609893259268295, 0.18685101265913073, 0.18294519104936335, 0.10131414494864677, 0.08043879027413736, 0.09016048757932582, 0.09181914220695053, 0.08324006618647095, 0.09116737175668532, 0.11645890830507322, 0.08919066004706655, 0.07107229272366478]}, "mutation_prompt": null}
{"id": "f0d2dff8-0a3d-4318-bb19-9014542b16b9", "solution": "import numpy as np\n\nclass DynamicMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly larger population for diversity\n        self.inertia = 0.7  # Dynamic inertia for adaptability\n        self.c1 = 1.4  # Slightly adjusted cognitive component\n        self.c2 = 1.6  # Slightly adjusted social component\n        self.mutation_factor = 0.6  # Modified mutation factor for exploration\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for refined exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            # Dynamic inertia update\n            inertia_weight = 0.9 - (0.5 * (eval_count / self.budget))\n            velocities = (inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search with Differential Evolution Concept\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "DynamicMemeticPSO", "description": "A Differential Evolution-inspired Memetic Particle Swarm Optimization with Dynamic Parameter Control for enhanced adaptability and convergence speed.", "configspace": "", "generation": 55, "fitness": 0.26414013874312314, "feedback": "The algorithm DynamicMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5399721354087268, 0.5365590738474255, 0.5692070604064867, 0.5782836901677519, 0.564554391268141, 0.5693266191528465, 0.5861274817391764, 0.5544988459359795, 0.5662005370363176, 0.23469019848619843, 0.20082148492011853, 0.20766926546987097, 0.23141053863174643, 0.23352561487437284, 0.22014665725472726, 0.2290104727718112, 0.23290568877877793, 0.21814290478151244, 0.12150555274645247, 0.1487780483686023, 0.10485527402756945, 0.13385118670893248, 0.11852264181552341, 0.10744758258449183, 0.1268469719150338, 0.13053971650049423, 0.11771903708341647, 0.12897200667565378, 0.132903879917188, 0.11667916645819221, 0.09932026117543269, 0.10579384028109473, 0.11005150665437591, 0.10133890964657477, 0.10172813659971347, 0.11302843413661134, 0.9895945598233893, 0.9451784354922851, 0.9585132547937484, 0.9586035060099471, 0.9501129949121243, 0.9306004275742051, 0.9546284492104089, 0.9612551384897116, 0.9504320216742594, 0.32957782112370626, 0.3219594295261129, 0.31944378401098517, 0.3296504720281671, 0.30625368912110296, 0.33413122611140744, 0.3222108425262016, 0.3049040304535271, 0.3221975774758111, 0.4775422673396553, 0.504344582182459, 0.47038437167599434, 0.6276033096513268, 0.5566113996542109, 0.48435366977648187, 0.4579419965713767, 0.5437967514335753, 0.5455044368107607, 0.1756073348050512, 0.15330705306301318, 0.1578805032819528, 0.1592354403917381, 0.14148210860191612, 0.14821932916945058, 0.17150233580053487, 0.151878793054404, 0.17676775218254004, 0.17297377727308305, 0.18786759770738637, 0.17306029162399805, 0.1597686086130552, 0.1687760628091617, 0.18823314810760816, 0.16101399905869762, 0.18377522522476009, 0.19021983114622076, 0.05974561263146949, 0.06561405308894319, 0.03556791265976722, 0.0794985810770138, 0.04459214375125864, 0.04537988132664994, 0.07175976142180285, 0.05136350001109391, 0.04022071993643639, 0.19414189389055103, 0.14848979288256958, 0.18040417378290496, 0.18643976084996206, 0.17578307371387258, 0.18180002684303231, 0.2026641727728471, 0.17954758007887883, 0.20560668499691526, 0.02342669500225969, 0.017309751907794824, 0.012812198358690519, 0.05898907370567741, 0.04874349637215014, 0.007551212594478107, 0.01609604284230659, 0.022252893352982195, 0.0008648620099808157, 0.1075742999887832, 0.11567969592262084, 0.13917437512636188, 0.1319105923086208, 0.13843718336387134, 0.14091643120050834, 0.11845439234518385, 0.09731566752201648, 0.127290523251814, 0.44577237203011866, 0.42355854335076704, 0.45237126126452987, 0.4372819102509987, 0.4287501475895268, 0.43897327233794725, 0.4664949421669591, 0.4299995656078295, 0.43209726857563924, 0.1282770457219533, 0.10173701629458232, 0.10588143848291798, 0.10163140910975232, 0.10657480378618289, 0.11910610395003474, 0.11954965325676381, 0.13074611610828268, 0.10902850070976255, 0.15380103345922158, 0.2808134165292615, 0.20045366143359877, 0.23925711287855966, 0.21995199270769195, 0.14123632382982887, 0.25227012285580264, 0.19018235510675496, 0.17485931058644832, 0.31058145850470975, 0.28535033869339754, 0.3203076055956965, 0.326504309989854, 0.34113977557716957, 0.304655191279547, 0.3197637217386017, 0.3238728148346941, 0.3221552904596018, 0.21844558363738265, 0.22876886081024272, 0.22441172724610492, 0.2233695685703566, 0.22692898759684, 0.24588558456489518, 0.2403012340034253, 0.24589457097747291, 0.22890242625628676, 0.22301613328896464, 0.21240152478131646, 0.19434014150402434, 0.20731097913966257, 0.20056374532283627, 0.22215823988854944, 0.23646972764392893, 0.2136306442949012, 0.2216916553257493, 0.20651730056921636, 0.19338323553918502, 0.20869704583959137, 0.203001573669766, 0.24670348673152598, 0.26371015474110726, 0.2037032521655584, 0.19464525704631996, 0.2130694656060549, 0.1831996773403607, 0.6849537279169002, 0.1846042150999505, 0.7001917570008022, 0.19781621538416028, 0.16734706266564592, 0.14196612835193445, 0.16490221831958807, 0.7029077198074665, 0.6215454000279075, 0.20880509464052188, 0.5026747685349687, 0.20545094741720904, 0.4591268752732218, 0.5456416793830259, 0.6240637974397089, 0.19460711469659164, 0.5902124929672794, 0.19652727813923276, 0.18017985652367274, 0.18618917046035088, 0.1984621403865373, 0.18848566461917493, 0.19653401975826823, 0.20112621448135282, 0.1940086309543575, 0.19357002543487234, 0.08792028608383695, 0.084105402864745, 0.08436583956086874, 0.07933663748866893, 0.08318949870590986, 0.08600496760867049, 0.08525581007182315, 0.08421004496452567, 0.08661911023731605]}, "mutation_prompt": null}
{"id": "b20b569a-4f4d-44b2-872d-734e4eaa2ed3", "solution": "import numpy as np\n\nclass MemeticPSO_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_max = 0.9  # Dynamic inertia for adaptive exploration\n        self.inertia_min = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.8  # Altered crossover rate for better blending\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Modified clamping for refined control\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        while self.eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                self.eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if self.eval_count >= self.budget:\n                    break\n\n            if self.eval_count >= self.budget:\n                break\n\n            # Calculate adaptive inertia\n            inertia = self.inertia_max - ((self.inertia_max - self.inertia_min) * (self.eval_count / self.budget))\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search with dynamic crossover\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    self.eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "MemeticPSO_Adaptive", "description": "A Memetic Particle Swarm Optimization with Adaptive Inertia and Dynamic Crossover for enhanced convergence and stability.", "configspace": "", "generation": 56, "fitness": 0.287388804122637, "feedback": "The algorithm MemeticPSO_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.620027494126937, 0.6092959820671449, 0.5900652629600733, 0.6055421023010793, 0.6082427588001987, 0.6006450892394453, 0.6004650552798809, 0.6031016090338417, 0.6045674294575002, 0.30899476816677385, 0.28540581031415113, 0.2944995528147236, 0.2993248865142929, 0.28809721993243187, 0.3032530064191368, 0.2605431083185562, 0.2986816637797114, 0.2814470181990434, 0.127094866791996, 0.1154876967215257, 0.14301925520976877, 0.17644384684483194, 0.11995618221653892, 0.12361023604999266, 0.12497419968754353, 0.1242851139012866, 0.12733117263694516, 0.12072788894516107, 0.11443612695908068, 0.11159952160844733, 0.12092829204725386, 0.11067028421211522, 0.11414963887679519, 0.09825021860378691, 0.1392313929389426, 0.11712943724874492, 0.9681236435073334, 0.9565349152903867, 0.9658093247960653, 0.9537564201169515, 0.964656502518629, 0.9549311880215199, 0.968082244237865, 0.9517261700177645, 0.9581441312300942, 0.3590429079899099, 0.3659374508994433, 0.36117924311848937, 0.395309525814835, 0.3645544594081579, 0.3821554278397786, 0.35598985148631657, 0.379179118079658, 0.37499564746103875, 0.553515652531475, 0.5487552596363346, 0.5755592229385587, 0.5786180342070388, 0.6309479240076825, 0.6390521442956534, 0.622900232118216, 0.5190075428050698, 0.543145401335186, 0.1959733481008371, 0.2064793104941116, 0.16379915527783417, 0.16751001031834234, 0.18791468341915674, 0.17503665098498677, 0.171941289195768, 0.19843620363605252, 0.1764863811128038, 0.18702549568498705, 0.18347187454952263, 0.18932257026039911, 0.19522444464578093, 0.17940375029906952, 0.18560596138925178, 0.19235127709139566, 0.19559106432216855, 0.17866682780475307, 0.06653605381019168, 0.058190230794335385, 0.0518543205040618, 0.0714129763133109, 0.07837403382915364, 0.047627955050861925, 0.07170207741887902, 0.08917395004990325, 0.043836738810511866, 0.19552467247186323, 0.18444974071195497, 0.23116789629132783, 0.17768748484764674, 0.16735348726043997, 0.14271873999497564, 0.21333079211006178, 0.21082103914986783, 0.22632853757286564, 0.024260122735857426, 0.03995873283006235, 0.021910388376657153, 0.0017307079135810977, 0.027938476234615317, 0.019749953568913403, 0.027753865355476415, 0.0456141368136872, 0.028398477245032527, 0.14455696683582575, 0.11421765746044943, 0.14757012394003455, 0.12923313758792587, 0.13472876327292782, 0.1716397757963537, 0.14970493062852586, 0.10622683863494609, 0.12510835119615715, 0.4788925364213896, 0.45411181980273563, 0.4511580372405086, 0.4560384056574167, 0.46086548322321463, 0.4646894833183899, 0.49728691466147357, 0.467105771672221, 0.4579538112674929, 0.10564616776459257, 0.11977144304670306, 0.11789928453789611, 0.1131429003115274, 0.1165916751666598, 0.11549885621731626, 0.11970678898506337, 0.1606829131806884, 0.11617681546671665, 0.19538334355542797, 0.16506783641421297, 0.2864367550580158, 0.1970098730231874, 0.17672446339827474, 0.15597541402035386, 0.18490593288035628, 0.2412714621361861, 0.2731805097393363, 0.3244962850812594, 0.3114923805981179, 0.3318564205738408, 0.3680773988718994, 0.33019927787599257, 0.35708332494217077, 0.33945308541312647, 0.32986661121248284, 0.35789687053352137, 0.24873213618880485, 0.25941334029110186, 0.24080581412660285, 0.28245040083821427, 0.2423928921251539, 0.2820397847582117, 0.2860889611320968, 0.26886876148513905, 0.2827476649884295, 0.2124248880187628, 0.20333296958907798, 0.18539206787442142, 0.22460502359495926, 0.21193262900565368, 0.23091636847694286, 0.20773069339987982, 0.2035944744677628, 0.22131030872656499, 0.20750095228651277, 0.3398263159555144, 0.2058420719226196, 0.27914503820069336, 0.3424182998607376, 0.2073067177048139, 0.1924780488719201, 0.3741278483026358, 0.19063694419642885, 0.18494706517277926, 0.6349558941471232, 0.15236079310616701, 0.7304218060048017, 0.19854254396766113, 0.1678353511729862, 0.6821258114694662, 0.7486126101850971, 0.7145211841441763, 0.6237014065504425, 0.20837742389273828, 0.6630593071769479, 0.20455446742795924, 0.5975927911591455, 0.15800827786150717, 0.6553284351868349, 0.5955885951143851, 0.20941520249787615, 0.1856357596567495, 0.1895872135895338, 0.18840915464060537, 0.20240093859155972, 0.21223876216443172, 0.1856340774212114, 0.20415978865618167, 0.1787050189489413, 0.18684157877949703, 0.0868667305524552, 0.08193431435641252, 0.08769250971999554, 0.08176787949133502, 0.08148700988595614, 0.092074124766653, 0.0979412314029785, 0.08313262086494455, 0.08409903416104259]}, "mutation_prompt": null}
{"id": "ad517591-e054-4967-9980-9b4721f0077d", "solution": "import numpy as np\n\nclass AdaptivePSO_DiffMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.initial_inertia = 0.9\n        self.final_inertia = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update inertia\n            inertia = self.final_inertia + (self.initial_inertia - self.final_inertia) * (1 - eval_count / self.budget)\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptivePSO_DiffMutation", "description": "A Particle Swarm Optimization with Adaptive Inertia and Differential Mutation for enhanced balance between exploration and exploitation.", "configspace": "", "generation": 57, "fitness": 0.281094155956818, "feedback": "The algorithm AdaptivePSO_DiffMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6345666048934736, 0.6364386923776986, 0.6260078264502968, 0.6441611376197196, 0.6456483680333761, 0.6388402308070764, 0.6200182987552536, 0.6244230349399367, 0.6268047242899379, 0.2878863195662592, 0.3183449253946832, 0.2779879689486535, 0.30191754169634566, 0.31671904519144334, 0.278196208697443, 0.28629952870040776, 0.2762791957647628, 0.2959723346916098, 0.1897515929129745, 0.15521881962485662, 0.14015297473001664, 0.17608333839299817, 0.14938355365243938, 0.12258837560687608, 0.324266420652368, 0.11925938056869256, 0.15380480466984903, 0.11324802960990032, 0.1475732881048678, 0.1259675129101857, 0.10390076637007772, 0.14045658040532727, 0.11864294200625958, 0.11829360404766154, 0.18877683910546117, 0.1374667277899949, 0.9648509321921975, 0.940546887464412, 0.961072928921551, 0.9646988758557931, 0.9506199903768284, 0.9458733613239391, 0.958706352304478, 0.961852085055525, 0.9613970888842834, 0.4011981738913537, 0.36935225984906805, 0.3695246993924709, 0.3823028964950932, 0.38015636511264406, 0.34992490802458953, 0.40242928646886755, 0.37235060327013236, 0.38395991898263515, 0.613851187522688, 0.34280879146254406, 0.5606263690438333, 0.5397103538774627, 0.20602717635515366, 0.4922991994931276, 0.5913335008763212, 0.6009689120675642, 0.46254642064486107, 0.16868527872911543, 0.16440124045939353, 0.1635731995677776, 0.17465302406897132, 0.14742586883195907, 0.15934869714660194, 0.18010616147203273, 0.1728764231279003, 0.1603986372841435, 0.18018308905779357, 0.189666100248447, 0.2013788652018179, 0.17614728063964236, 0.188609617672024, 0.18111896587344467, 0.17933722251173456, 0.17337308192874246, 0.18484101095194172, 0.02255864298957999, 0.03991495093668396, 0.033847433284533324, 0.039977978283283866, 0.0023195791381179776, 0.01666855803576961, 0.005037393503165233, 0.013477392639699937, 0.020522144142837484, 0.12376946666217359, 0.11582710160633491, 0.13668600500930495, 0.11561824449817393, 0.12050447573685452, 0.09414203315049441, 0.16836920515233866, 0.1492987373159127, 0.11814393988480609, 0.08162006320345394, 0.048605415666265084, 0.030046870272855464, 0.11148784410355561, 0.04418666956253181, 0.15388336427852978, 0.05616094764341617, 0.03994821854244068, 0.10557715614950525, 0.11958038481102062, 0.18456407539704633, 0.13025446169299704, 0.186669699588764, 0.13217462221553855, 0.13446071113359048, 0.09473422022066513, 0.15920952962196755, 0.09041535953010349, 0.4625971771832791, 0.43786690416815754, 0.4763754530997447, 0.471110743114608, 0.4533087919154445, 0.48239267923344986, 0.4932026556058139, 0.4550203886711721, 0.4770674770084089, 0.1093477813890057, 0.12526707871714948, 0.11393787460906057, 0.11943192419609672, 0.1034460204887464, 0.09366071648676788, 0.11937557474557248, 0.13940618783953673, 0.10061520465297724, 0.18697090790681425, 0.21275426271349207, 0.17836507341099972, 0.21899071728879294, 0.31277715716288734, 0.18276508940861602, 0.3002351061775015, 0.27130000394353215, 0.17641977968561529, 0.3311187994006427, 0.3359854970165579, 0.3916703409759008, 0.339847900967129, 0.35450354644050075, 0.2895147676226717, 0.3938676734274077, 0.3800580340813291, 0.3795345273677029, 0.24274324298032945, 0.25806004999178744, 0.19716836604629895, 0.22896108417374028, 0.17223424719789293, 0.2660990902429978, 0.2537735228564659, 0.26017926275664527, 0.24448263032691375, 0.20206600372257666, 0.19147835722922113, 0.2003376543067662, 0.21137911182448466, 0.21673823847252738, 0.21751028229960978, 0.2125649449207907, 0.19355662406455731, 0.19143931868219266, 0.19600364649267887, 0.22161981787719298, 0.21006447258002825, 0.24974411627792759, 0.4024593144616858, 0.20177534447062484, 0.20206803746102608, 0.20918990608016141, 0.20436345012704338, 0.734606750376595, 0.18290794274247268, 0.1693942384270789, 0.7341085635128806, 0.19669308494780113, 0.16834136108409836, 0.7369291575298363, 0.6797390344577714, 0.7524243213367413, 0.6085350694673655, 0.20943602128958494, 0.1930139592344261, 0.20669476977681633, 0.5618843084139054, 0.1511062130061246, 0.20912036713847426, 0.5044042390993104, 0.6725616780680035, 0.20984722248186582, 0.1927002021436679, 0.2068282709800754, 0.21527307481920244, 0.20438648234064472, 0.188642731959775, 0.21837355502126976, 0.20452083964297108, 0.22576702659888692, 0.09783148529544028, 0.08046943349476732, 0.08755683240943146, 0.07928250517493074, 0.08405776533158182, 0.09595685052272163, 0.0795762010032317, 0.08667877399446511, 0.07979367393481007]}, "mutation_prompt": null}
{"id": "ec8644fa-52e7-4d61-9e15-5f96f3f30367", "solution": "import numpy as np\n\nclass AdaptiveMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for enhanced exploration\n        self.inertia = 0.7  # Adaptive inertia weight for dynamic balance\n        self.c1 = 1.2  # Lower cognitive component to emphasize collaborative search\n        self.c2 = 1.8  # Higher social component to foster information sharing\n        self.mutation_factor = 0.6  # Moderate mutation factor for variation\n        self.crossover_rate = 0.85  # Adjusted crossover rate for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Tighter clamping for controlled exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions with adaptive inertia\n            inertia_weight = max(0.4, self.inertia - (eval_count / self.budget) * (self.inertia - 0.4))\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptiveMemeticPSO", "description": "An Adaptive Memetic Particle Swarm Optimization with Dynamic Parameter Adjustment for Balanced Exploration and Exploitation.", "configspace": "", "generation": 58, "fitness": 0.309588182712818, "feedback": "The algorithm AdaptiveMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.7069476228176407, 0.6817265063128759, 0.6904474845313995, 0.6678312414805077, 0.6923566037068196, 0.6759141773843309, 0.7046956768888946, 0.6777693358453303, 0.6514852750303621, 0.35967482005303564, 0.361744124620221, 0.38967017041589747, 0.38282502379659766, 0.38155388987643013, 0.4105219959750609, 0.3852648644811071, 0.3997669799591166, 0.38452497806310026, 0.2700971086459878, 0.14016778666163188, 0.16081260201965275, 0.13339165846427092, 0.12904468662026736, 0.14748705374544646, 0.13543755356797482, 0.12782570230306534, 0.13550439908195167, 0.13293913035584226, 0.12810298512801144, 0.115699788461466, 0.13581678940161745, 0.11453389890921939, 0.15528837121212458, 0.14318484049970903, 0.13764475535835063, 0.11017472229812542, 0.9895947940477353, 0.9512170766464516, 0.9497307931146031, 0.9546562864922585, 0.9442413377289214, 0.9489082223030724, 0.9451442288125343, 0.9610897408811182, 0.9407422451498404, 0.45368762512412175, 0.44701328892904724, 0.42896344885390814, 0.4214933745639402, 0.4431753780924562, 0.4461490457010213, 0.4316812348545118, 0.41392230372932726, 0.42172209839859875, 0.69594169987962, 0.6436319265559859, 0.6560733422863176, 0.714118563087063, 0.6237356632119123, 0.6801383308410787, 0.6228464637150577, 0.6568948743395173, 0.6053621267144966, 0.19535583650253607, 0.16506541792994012, 0.18426893992618232, 0.19771890046692953, 0.20369371178501772, 0.18659118100697858, 0.18809805076789865, 0.18899035463079117, 0.21859348618835617, 0.20043476197082433, 0.16998981282282621, 0.25726382400992065, 0.22046645165803325, 0.20498068096465827, 0.20923766499930052, 0.22132521151334417, 0.21729710294421412, 0.21781740825939278, 0.04908995638039815, 0.07286736243115788, 0.05007196277512216, 0.05172741515496815, 0.0789473815320687, 0.018069491256174297, 0.05538241298523894, 0.05033960790039105, 0.07045861759799443, 0.19813040828923978, 0.19339819887484644, 0.2147176859675699, 0.1905523375661783, 0.21238291771431084, 0.19931749885850614, 0.21508203907886125, 0.23865413622994658, 0.17950502320732464, 0.032243851182950145, 0.025210877024004374, 0.014203600755937296, 0.10976357702199857, 0.05749957937946548, 0.07660093569374749, 0.12284283756400505, 0.06923232153078551, 0.0667584987146429, 0.14074654876173842, 0.13690851430561268, 0.15205556463608116, 0.1793921316510152, 0.1604488225100651, 0.18203316135595915, 0.17770678868455614, 0.1344205563998705, 0.10467777993248473, 0.5026287665213491, 0.5142611583033878, 0.5443781936435574, 0.5047750344029025, 0.5003757378285284, 0.5087763132851705, 0.503922870505201, 0.5051296356930426, 0.5141786657090892, 0.12144982733593535, 0.1078230145953194, 0.09751826845262335, 0.10366727219430028, 0.13301730254835842, 0.13466833491744, 0.10734486333556392, 0.12063244292109643, 0.13011930556699536, 0.23260945692881785, 0.1654099656708269, 0.18813474843322797, 0.18302637570277192, 0.39146891397705685, 0.15956456194997048, 0.3648577022108137, 0.17774424911341125, 0.18965566253684385, 0.36276886582808676, 0.3697534318568356, 0.36683242578457675, 0.38709274913133884, 0.38255201962164487, 0.4012885958464947, 0.42514130563014474, 0.42670728695602633, 0.433897475047725, 0.280992811172999, 0.24822834681793782, 0.27226487559343715, 0.21310630300806455, 0.3290105952550053, 0.29675640451123386, 0.3108897935386974, 0.3156096307189401, 0.3170445774469002, 0.23249128885767256, 0.20796656212402653, 0.2314415859330038, 0.2126037471331329, 0.2201849237650071, 0.2286827501692803, 0.2099147546564475, 0.23331453102822175, 0.21747230704995257, 0.1847872040336811, 0.20467943847371284, 0.3448255892954135, 0.2056189880298268, 0.23297569766760529, 0.2102658388601627, 0.516373873607579, 0.46650997602281186, 0.2147702594237919, 0.18454413610395504, 0.1869948108030982, 0.18568194533173232, 0.7973183770792717, 0.19808060740878675, 0.19557984603272627, 0.16401356712656978, 0.16651512309123406, 0.817150880446389, 0.6841612291538552, 0.20991077841132044, 0.6264682401935847, 0.20690890932172745, 0.1684645900683891, 0.6101437725370897, 0.6642111379560298, 0.6799920171151325, 0.7108127014699571, 0.1796668751988324, 0.18511859564034305, 0.18168102934295938, 0.1840666670551181, 0.17925851282402894, 0.18977395190424418, 0.2001837565271729, 0.19215641308000675, 0.18214725374468932, 0.10241287463026105, 0.09998954598326748, 0.09052976083297304, 0.0966415567177592, 0.09844196158211926, 0.089253266973648, 0.08545840559190399, 0.08657420100809488, 0.09040539621908206]}, "mutation_prompt": null}
{"id": "0ae40a91-41fe-46c3-937f-1f65ad8376e6", "solution": "import numpy as np\n\nclass MemeticPSO_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.7  # Adaptive inertia factor for dynamic balance\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.7  # Dynamic mutation factor for enhanced exploration\n        self.crossover_rate = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Adjusted clamping for controlled exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            self.inertia = 0.9 - 0.7 * (eval_count / self.budget)  # Decrease inertia over time\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    dynamic_mutation_factor = self.mutation_factor * (1 - eval_count / self.budget)\n                    mutant_vector = (personal_best[a] +\n                                     dynamic_mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "MemeticPSO_Adaptive", "description": "A Memetic Particle Swarm Optimization with Adaptive Inertia and Dynamic Mutation for enhanced exploration and convergence control.", "configspace": "", "generation": 59, "fitness": 0.3140537356965982, "feedback": "The algorithm MemeticPSO_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.67481014178145, 0.6547546256068884, 0.6630458790807874, 0.6600035535819642, 0.6531579548989048, 0.6584444298280834, 0.6620682691465195, 0.6706812305303091, 0.6809549383198479, 0.37643956012180824, 0.39505048436761847, 0.3765453274831675, 0.40104165336837017, 0.3905053886238399, 0.38701555726714376, 0.37825106615879855, 0.3937815216018642, 0.38298413431449874, 0.14842226028157346, 0.1356177640559274, 0.1590526399579245, 0.1120030940978306, 0.13126830488177876, 0.15090636978682848, 0.1398544730447746, 0.1407491797132414, 0.11688169033544527, 0.12145216934470715, 0.12077367780674286, 0.10002594758853889, 0.12671164908339072, 0.1382735599664402, 0.12133076115919517, 0.11280252698974436, 0.13828112360362443, 0.11945161779831992, 0.9649043482532533, 0.9526947854243631, 0.9577653132053997, 0.9511280131167203, 0.9595373066189101, 0.9452700184155065, 0.9609853169322692, 0.947926185944687, 0.9608074022227077, 0.46846702672140317, 0.4752025563214929, 0.47004196235438844, 0.4534357221898646, 0.4692202344365357, 0.4580969788625815, 0.464097979143722, 0.45003333999584083, 0.43593335486695983, 0.6976513394974214, 0.5901422987071235, 0.6221158419799747, 0.6987037595615614, 0.5799511734396763, 0.6802737549930922, 0.6550054869937991, 0.66498084082075, 0.7095645256332193, 0.18093601646446988, 0.18051272370578642, 0.17124530895360024, 0.17561704857112403, 0.21463602143254146, 0.16621653541240122, 0.19346912020591633, 0.18222551909409612, 0.17457562693613582, 0.18325283495425593, 0.16687315813520853, 0.1733521269662004, 0.1812308311513796, 0.17863750850342552, 0.18321071721539217, 0.23223160171675827, 0.20172801635504678, 0.20806314596793696, 0.059690117309100565, 0.1119104047110917, 0.13919603269035052, 0.051867664654559276, 0.050735917452750634, 0.10435048067969765, 0.11262342695897187, 0.08445363981791865, 0.1432704394509957, 0.2262296557759228, 0.21852499005809145, 0.19257424522123778, 0.15658637404660436, 0.145808132208732, 0.14697979104947623, 0.25583334807461355, 0.2762891310096235, 0.2202846111680271, 0.06505316401356598, 0.049788280872582025, 0.029490285798722704, 0.043151827954610034, 0.019748402145976285, 0.03125969498501513, 0.07542425269213582, 0.11022474397459048, 0.07904291829273602, 0.15642798481180964, 0.18777711859298796, 0.148790076753487, 0.18285225313949216, 0.15310848658305498, 0.17597933660654141, 0.1358372195295111, 0.14927506190709827, 0.08228799373786766, 0.4976985473519421, 0.5032400771541251, 0.48834208033245163, 0.5028074612133919, 0.4805278656460633, 0.5239011432870269, 0.5132477458532071, 0.5144663213488487, 0.5099111849357845, 0.101167994002209, 0.10535711412896998, 0.13354098373145462, 0.1136820666291809, 0.12476053537340392, 0.13288695004992024, 0.14319333533585865, 0.11328566692693698, 0.11387170524548584, 0.26523659454393256, 0.3511647263719191, 0.41777235341933705, 0.1873599140180825, 0.47244470689162543, 0.24372106161590534, 0.4272993823447746, 0.1704120998195684, 0.14914794575710222, 0.36574214686940953, 0.2919803467271007, 0.40636050203415497, 0.3852336975239864, 0.3934428959261018, 0.3978781982966719, 0.4089232720649335, 0.41979004647070794, 0.4189032107881522, 0.3052323424018637, 0.2648581188341683, 0.28739339910275863, 0.28415576326922776, 0.268335115423866, 0.2556456357239012, 0.29765190503355243, 0.32982448433276434, 0.30134500902714156, 0.20913564993692424, 0.21041067573924288, 0.2114412038733886, 0.2221591565258776, 0.21976084716558275, 0.20093389541293027, 0.20778868640385428, 0.21853196857726997, 0.21100455367576365, 0.38382121456066065, 0.22712738400463361, 0.19365573946809478, 0.5013416837947802, 0.21153142709278416, 0.2025617070614698, 0.2186542270561207, 0.4371576299942488, 0.20917429313617375, 0.1843669398693064, 0.18213238678072008, 0.6571821143182017, 0.7585899860141343, 0.1976837598585517, 0.16736821321892548, 0.6971465649399409, 0.7734694584836719, 0.7741695798752296, 0.7002816652496521, 0.20949383145609823, 0.6718680856748085, 0.20368250434637236, 0.6816536590474194, 0.15343133477273696, 0.1831842033549297, 0.2022685174201898, 0.6596996256916248, 0.18621460050031013, 0.2077595644485426, 0.19202518648964773, 0.1869093630908405, 0.1967633057328917, 0.21944775185229215, 0.1885166454538013, 0.18944166338913615, 0.18463591920543398, 0.08418210342401344, 0.07657071620705214, 0.0845714479349704, 0.09349679348591766, 0.09361657924544198, 0.08958770722564091, 0.09443944857934528, 0.08183226603429283, 0.0905150624320189]}, "mutation_prompt": null}
{"id": "ef5df81c-ba56-45e9-8a14-7fe78118dcdc", "solution": "import numpy as np\n\nclass MomentumEnhancedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly larger population for increased diversity\n        self.inertia = 0.7  # Higher inertia to maintain momentum during search\n        self.c1 = 1.2  # Adjusted cognitive component for fine-tuning personal search\n        self.c2 = 1.8  # Increased social component to enhance group learning\n        self.mutation_factor = 0.6  # Higher mutation factor for greater exploration ability\n        self.crossover_rate = 0.8  # Adjusted crossover rate for controlled diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Moderated clamping for balanced exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions with stochastic perturbation\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            stochastic_perturbation = np.random.uniform(-0.1, 0.1, (self.pop_size, self.dim))\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles) + \n                          stochastic_perturbation)\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] + \n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "MomentumEnhancedMemeticPSO", "description": "A Momentum-Enhanced Memetic PSO with Stochastic Perturbation for improved global search capability and local refinement.", "configspace": "", "generation": 60, "fitness": 0.2431188460840032, "feedback": "The algorithm MomentumEnhancedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.4800849325734414, 0.4581030124115699, 0.48089364962759096, 0.47593124749015137, 0.46495722645232507, 0.48566689528745255, 0.44827157341732304, 0.4680868674949792, 0.4727181833232994, 0.12988061205352863, 0.15673791832157913, 0.14515647150729705, 0.14825730994848219, 0.1351920413823584, 0.1616880552503167, 0.1431048874749311, 0.15026894953736425, 0.14632914981450817, 0.10879683797479411, 0.1094395349470002, 0.1098058452699775, 0.1257578829299718, 0.130893673703796, 0.11321877178757367, 0.12721067927402874, 0.09560789486701082, 0.1096409662578921, 0.09787033668809231, 0.1003658457747666, 0.08990460036973835, 0.11381533647868369, 0.10147782374647796, 0.08765390537593609, 0.09948758482576991, 0.09711586228108204, 0.09921216916237374, 0.9528812786945815, 0.9505798607075664, 0.9602135383073714, 0.9555084924754611, 0.9452713794221164, 0.9511452185279597, 0.9552696857905607, 0.9583598674440847, 0.9590240658084026, 0.27684014726934336, 0.2757725397424967, 0.2613100716378919, 0.27307383230703886, 0.26511764423681994, 0.2907751639651177, 0.2739661567494214, 0.28043544134838316, 0.28506304343107103, 0.5155371053219404, 0.34329578912819536, 0.6577312803296853, 0.5749774672822494, 0.5581219817691617, 0.6691006800036089, 0.37889431879063773, 0.4786006809954706, 0.5011514629019056, 0.1846935962479498, 0.14708949069473964, 0.1750820610054732, 0.17723479294062394, 0.158423837817519, 0.1497868026050514, 0.16363457880676802, 0.19308848334145812, 0.1689070456726085, 0.17189467729262597, 0.19753634818708254, 0.12414623083409115, 0.1504510779699807, 0.17134945495983445, 0.19042705050748732, 0.19985118082400743, 0.16509365929327557, 0.182373496711426, 0.02935861503376691, 0.04637029567526929, 0.027154965105435025, 0.01961131095023083, 0.03924510334084719, 0.03474308873252652, 0.0309170929749929, 0.042882191786570045, 0.03336345372327487, 0.1819732879924616, 0.1652222020891777, 0.13900333237864182, 0.18273162475984073, 0.1442899879895504, 0.16151710906600014, 0.1777890938295792, 0.12014131224129254, 0.1613679054812457, 0.005780277772949538, 9.999999999998899e-05, 9.999999999998899e-05, 0.011629373389190012, 0.002520568669566292, 0.006013567008792409, 0.006576080137951301, 0.00045735962806647823, 0.0002853352079255078, 0.10956989212653512, 0.11507141058010184, 0.11899091105079673, 0.11741048181522906, 0.12288506228878815, 0.12200274843308911, 0.11670251326411907, 0.11445152137211767, 0.10714602593640066, 0.4248084425284858, 0.42273304516164345, 0.425503043921176, 0.4376909649507257, 0.4349776767053629, 0.45007234355727943, 0.42254512767918273, 0.42807767670106034, 0.43775939889362014, 0.11801406756395916, 0.11258672452658536, 0.12504465893133965, 0.10875643008891278, 0.09036666493620282, 0.09937483695734195, 0.12478063162121111, 0.11412602321331855, 0.1119042733678034, 0.1924229879724999, 0.13973889186824617, 0.17483377852675053, 0.1735319756562771, 0.18844449929284457, 0.25585056967521946, 0.13773318339631346, 0.18892250193110827, 0.209015980809949, 0.2855093853695567, 0.2898249141875986, 0.29507177574048293, 0.30411118945684434, 0.29817776902299864, 0.29124795048556495, 0.2929025376982116, 0.29177342366343995, 0.289773425927762, 0.20987823916325743, 0.22552217793493157, 0.23488916032848095, 0.18286124086792976, 0.24340263511793714, 0.203847604394236, 0.21917604818593495, 0.23588514910718106, 0.21497136449961185, 0.22947311030582052, 0.19927614169846553, 0.20490437864033972, 0.20473353505794156, 0.20856965407691008, 0.20317734241778174, 0.22714369157679848, 0.20728221462204854, 0.20823340262429468, 0.20107161889539926, 0.20118497777775013, 0.19336493913758546, 0.1899730264414623, 0.2585471771505642, 0.19815381486769235, 0.1992859093891327, 0.19518487552695218, 0.21211480503222813, 0.1835854522384066, 0.1856020317364674, 0.18536957234898677, 0.7129696114368179, 0.1977870903889346, 0.16590210723948917, 0.14108589789740456, 0.16211030446174735, 0.7133797855763692, 0.4799921432806885, 0.2078339512065437, 0.07319744282115703, 0.20437577574495047, 0.5493089002207119, 0.15259479967161582, 0.4656057421631704, 0.6542501872653602, 0.5886617837024624, 0.1789715474339464, 0.2011720768363201, 0.1809934035946108, 0.1816370043840253, 0.1938434185420338, 0.19455932956048394, 0.1974127719352038, 0.18505069719275935, 0.1793241226477107, 0.0929073033772998, 0.09359673088918441, 0.09587765224899936, 0.08127716594402024, 0.08920964758337557, 0.08841886186126247, 0.09109876020433949, 0.07757244022231846, 0.08395653644362933]}, "mutation_prompt": null}
{"id": "f85d28e5-eace-40d3-a88d-75e507725ab9", "solution": "import numpy as np\n\nclass CooperativeMemeticPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for enhanced exploration\n        self.inertia = 0.7  # Increased inertia for broader exploration\n        self.c1 = 1.4  # Slightly reduced cognitive component for global search\n        self.c2 = 1.6  # Slightly increased social component for better convergence\n        self.mutation_factor = 0.6  # Increased mutation factor for enhanced diversity\n        self.crossover_rate = 0.85  # Adjusted crossover rate for balanced diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0  # Increased clamping for wider exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "CooperativeMemeticPSO_DE", "description": "A Cooperative Memetic Particle Swarm Optimization integrating Differential Evolution for improved balance between exploration and exploitation.", "configspace": "", "generation": 61, "fitness": 0.2700552109460764, "feedback": "The algorithm CooperativeMemeticPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6120343985727462, 0.5610821647093301, 0.5621002650134108, 0.5836449325940305, 0.5636473646316946, 0.5872404214633433, 0.5952274927395798, 0.562750765080797, 0.5641191643007726, 0.22236676460284066, 0.20049282281992054, 0.23444987473518553, 0.22811253154443267, 0.20085000862332225, 0.217065254073478, 0.21365702130225306, 0.2174291423546294, 0.2158206524071763, 0.12319037505406027, 0.13184640244185097, 0.11290247841571122, 0.1237799571089363, 0.1179363776486071, 0.1166822037198455, 0.22585082966372305, 0.11439175637215226, 0.12746087737598633, 0.1096793332859759, 0.11921587446791615, 0.125755068009348, 0.11815761691630156, 0.1029469956530924, 0.13175041341433968, 0.10418366495317366, 0.11155358040410623, 0.1288910075221058, 0.9896014755514863, 0.9606689490846094, 0.9666403144995701, 0.9651598408143709, 0.9529572097853952, 0.9583127189610342, 0.9593289984388516, 0.970788296800549, 0.9621954329767266, 0.3300799724173096, 0.32282820727091643, 0.2890722734142319, 0.358035941631036, 0.31823691957322886, 0.31971635622174244, 0.3261807158268195, 0.3335444170038784, 0.3288772136984195, 0.49773398500487287, 0.582932958657906, 0.7330655066899361, 0.6057455435447392, 0.5274030141478414, 0.6243621061055618, 0.47309829088664523, 0.5642202433566303, 0.6171140878513997, 0.17872692925411593, 0.10073943516305994, 0.17043780464665093, 0.11590161176259406, 0.1813770668243817, 0.12213575144816768, 0.22623339481860394, 0.16795673341164197, 0.17721215561904824, 0.18224474384505018, 0.18418982488827118, 0.16671119373178478, 0.1817150856992602, 0.19658609899626633, 0.19305637093254036, 0.18347420537103643, 0.2023269480726818, 0.17268296626209267, 0.03414233252666077, 0.050791216322841115, 0.04438461926220283, 0.03633844659048824, 0.007366615063352011, 0.05025699230072356, 0.03281488836648827, 0.04613071485220788, 0.03893898100554083, 0.16284131672554936, 0.1774636187229125, 0.1801267248422559, 0.16074743335807995, 0.17343672505212382, 0.13744553194341347, 0.2166362374735703, 0.22252825443072344, 0.16989932186566947, 0.019794945083428273, 0.020809675738147404, 0.01782559165243003, 0.026789716347984882, 0.05524253214244268, 0.023974915932895913, 0.002181196001316499, 0.007318741131439821, 0.04775779683128545, 0.11630690880588757, 0.11721161645809275, 0.120188098081775, 0.11925592228902715, 0.11618813002315564, 0.12600137001026723, 0.11652558498970556, 0.11615201309017753, 0.09831760458848038, 0.44128020369937304, 0.44520367489224244, 0.44736800756848405, 0.44805784823761874, 0.4708350700070708, 0.45452831863117216, 0.4776284700912321, 0.4522736884892069, 0.4798059048485749, 0.09225158193166294, 0.11524646141466999, 0.0970411560551081, 0.12673744991029867, 0.09513756299937082, 0.12008772435489679, 0.1006080217149854, 0.12293502495217412, 0.12454583935468222, 0.1868966997327267, 0.1737402566363151, 0.3560720075672873, 0.19472590563383496, 0.2425409058771697, 0.20879326846150548, 0.2265254838952213, 0.17270555376551344, 0.13626253561660984, 0.29557886944775413, 0.28020912256283625, 0.3067758429646794, 0.2860615704599122, 0.31926800858118287, 0.3148357386806908, 0.34154330186889614, 0.334011827588954, 0.3329032565681339, 0.2424855701373816, 0.2025946836163467, 0.2199579404302211, 0.25013172024215624, 0.22637918824087433, 0.24688342639977012, 0.25775673307496283, 0.26823915717289804, 0.24733186573994692, 0.2121484572826735, 0.2019628754301681, 0.2001824677332834, 0.21631490426471678, 0.2018319199697779, 0.19374928001441094, 0.2001082251707922, 0.20525304204193584, 0.23516561771106537, 0.20768549409942638, 0.23158968812136704, 0.1786211871913509, 0.2034092316320203, 0.21136429279131586, 0.2336689836854643, 0.20600548765121207, 0.2879010301557121, 0.17964961478321673, 0.7814341965636661, 0.18477922303910432, 0.392565669312848, 0.796169086943019, 0.19870025352945864, 0.19831530613470572, 0.6852344679279259, 0.16595463974396119, 0.7335170995520748, 0.5599766614526704, 0.2073452888450562, 0.07336616299973264, 0.7020196223849198, 0.38231948080069, 0.15335543791116102, 0.5896179876925021, 0.10393076282594449, 0.5989398832480817, 0.19498972006076776, 0.1849160339726098, 0.19575462080159967, 0.19386701788746274, 0.20282497168439395, 0.17001003684218718, 0.1774688516813192, 0.18669628082192635, 0.1967998494372264, 0.1008745046267755, 0.08573912962321006, 0.08467964800320293, 0.09686213824418921, 0.07838235059570309, 0.078568023195012, 0.08355311142892041, 0.09889061602129878, 0.0841056838087838]}, "mutation_prompt": null}
{"id": "f519a122-b6dd-4716-9ca1-d6f918b4fb91", "solution": "import numpy as np\n\nclass EMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for better exploration\n        self.inertia = 0.7  # Dynamic inertia weight for adaptive exploration\n        self.c1 = 2.0  # Increased cognitive component for enhanced local search\n        self.c2 = 1.2  # Reduced social component for maintaining exploration diversity\n        self.mutation_factor = 0.6  # Slightly increased mutation factor for better exploration\n        self.crossover_rate = 0.85  # Balanced crossover rate to maintain diversity while stabilizing convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Reduced clamping for controlled exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EMemeticPSO", "description": "Enhanced Memetic Particle Swarm Optimization (EMemeticPSO) with dynamic parameter adjustment for improved adaptability and solution precision.", "configspace": "", "generation": 62, "fitness": 0.2655542351327774, "feedback": "The algorithm EMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5416114600844186, 0.5307465755468953, 0.5829142145090447, 0.5780944248867639, 0.5884419760623611, 0.5515532625550548, 0.5422481061932027, 0.5437562155396299, 0.5339968449746024, 0.20265026794593965, 0.18060034130203073, 0.1848399711963009, 0.193966016272351, 0.18585989466415487, 0.186709593170872, 0.20807714006362965, 0.23852551729330207, 0.22345893677994122, 0.13245649500613232, 0.13945498793126831, 0.13497760347004328, 0.12578308062567922, 0.12228886025097652, 0.10518939693162555, 0.15272710140831713, 0.13953995514695072, 0.13638784874616516, 0.0963164827600469, 0.11655810616627893, 0.10177050893045003, 0.11329514156007914, 0.10461198037165009, 0.09252978534179201, 0.11149226599546569, 0.11797413484773989, 0.12005593298499884, 0.9895942797208226, 0.9410042816203787, 0.9510847087874006, 0.9538771451663122, 0.9362276783197239, 0.9282512724475428, 0.9499819268598493, 0.9567444620384966, 0.9426526124433416, 0.32388341552387123, 0.317035508256156, 0.3104344015232471, 0.3405907819830237, 0.3041218110524836, 0.32286294862279175, 0.33267898218489933, 0.3038287770127549, 0.29762973772821955, 0.5625181765262026, 0.6232583475305301, 0.5753525451810654, 0.5469274113232335, 0.5368956397718204, 0.5160878624587055, 0.5249201468241982, 0.5629556253815756, 0.5086360613906472, 0.19807203357655367, 0.16175549906769704, 0.16751727043155074, 0.11849692689319358, 0.16948614735443357, 0.13454948602097572, 0.194347458373325, 0.15017185653281828, 0.16465923697522267, 0.1913469216097663, 0.1703015383721438, 0.17541235509187625, 0.18308450295614442, 0.18782745359402842, 0.1848105434818974, 0.17283054033072076, 0.193306952821636, 0.15503874412259733, 0.05177557738542238, 0.05163452136830182, 0.04134973968161426, 0.07848225101818773, 0.046627555153282985, 0.059977244808944286, 0.0873499992904021, 0.06953603356563776, 0.07488589940215429, 0.2028745326800766, 0.17157339420171103, 0.18735330164271058, 0.21497014890502897, 0.17219068177914687, 0.16593267562346503, 0.2003187117394064, 0.2035720856618478, 0.21199792935373718, 0.035912196674970476, 0.010847360627354807, 0.0022743007606575993, 0.01556571974437515, 0.016069805127912895, 0.012182781726234881, 0.013607358528376023, 0.005306947633797243, 0.004574732065546927, 0.13319163238087972, 0.14038323921849571, 0.11796070531275893, 0.1436784426012897, 0.13245518842388415, 0.11610864432640533, 0.11652892996287267, 0.13527939399343214, 0.13655298812489347, 0.438785496047307, 0.4566609978474454, 0.45943746387715123, 0.4550124508982193, 0.44278407083664195, 0.4499991038733405, 0.47818300658880053, 0.45276848968205763, 0.4639508885699244, 0.13087895335887, 0.10813213986277403, 0.10658342817937805, 0.11636290776504887, 0.11948184397874373, 0.11992889952615826, 0.09175527754929369, 0.12024831853280393, 0.08697346632953562, 0.1695706613225446, 0.17767992086550133, 0.1518357111515033, 0.19240470758175932, 0.26806845183369443, 0.2240868939194538, 0.160876666565947, 0.20018868018752722, 0.18101483627588688, 0.32497620573050323, 0.3195261530127841, 0.31980621701104583, 0.32449559059004796, 0.28768977398628226, 0.3402760414639142, 0.3163226763891466, 0.3219970288615567, 0.3150898496221305, 0.2263093905547766, 0.23047237365105844, 0.24497523169721325, 0.26561439396080455, 0.2191075936590101, 0.20344944167030588, 0.25492721380108696, 0.23884378017137697, 0.23104796185362608, 0.2150078872502087, 0.21627208303545487, 0.19805362383418323, 0.236030743637059, 0.19861200920607802, 0.20776097300985596, 0.21170322614184922, 0.20296279239786774, 0.20237015766687005, 0.2037784334456959, 0.20283898855212978, 0.22439093157212342, 0.2075266192126466, 0.20434499890654934, 0.19961233017654145, 0.3601109777712571, 0.22703117251562432, 0.19983824736152733, 0.183251758803901, 0.18715418271996298, 0.18450760090337592, 0.748880350614733, 0.19725769626514034, 0.16858964839972068, 0.6594052351296403, 0.16108753858454383, 0.7722665329402278, 0.5811983539197636, 0.21112835758032222, 0.4855131670017143, 0.653730219919016, 0.523545343556207, 0.16551896614726336, 0.5918893011124324, 0.10432263361438676, 0.6464522595264466, 0.17858061664883573, 0.186267839631179, 0.19210756390571593, 0.1912737630750876, 0.1812251996273414, 0.1959772979452329, 0.18031736125455378, 0.18027272541511996, 0.1813060370111157, 0.08920769927213079, 0.08689968981629503, 0.08301967445690883, 0.0778209937114962, 0.07517340952574036, 0.08912233810522963, 0.09099473518822032, 0.0861928305077585, 0.08603392715841929]}, "mutation_prompt": null}
{"id": "1d3d7964-99e2-457a-b46c-d6d574515dad", "solution": "import numpy as np\n\nclass EnhancedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size to enhance diversity\n        self.inertia = 0.7  # Adaptive inertia for better convergence control\n        self.c1 = 1.7  # Higher cognitive component to increase individual learning\n        self.c2 = 1.4  # Slightly lower social component for robust group dynamics\n        self.mutation_factor = 0.8  # Increased mutation factor for diversity\n        self.crossover_rate = 0.85  # Balanced crossover rate for stability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for controlled exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedMemeticPSO", "description": "A Memetic Particle Swarm Optimization with Enhanced Adaptive Parameters and Differential Mutation for Robust Convergence Across Diverse Landscapes.", "configspace": "", "generation": 63, "fitness": 0.26457726390398434, "feedback": "The algorithm EnhancedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5815086102419718, 0.5885517868858904, 0.5829571224795336, 0.5787019081045204, 0.6123442245073158, 0.5544411383597461, 0.6039436912498591, 0.5964880434181755, 0.5809576019985947, 0.2243490067221039, 0.21682001979234822, 0.185530005236218, 0.26707352073858437, 0.18924755547113126, 0.2032898897435601, 0.1849303077815886, 0.20188991318201466, 0.1907887245245098, 0.11515653704924311, 0.10368221075148554, 0.130768991043005, 0.13757035466269485, 0.12719392347231295, 0.12464050699626028, 0.13456290898809653, 0.11650734706871135, 0.1314579155733574, 0.12655944940025887, 0.11565170188021656, 0.11100732068548436, 0.11589224911148033, 0.1292153571076824, 0.11879704142858805, 0.11471043907082235, 0.10942577956334187, 0.104882031751656, 0.9645116490297616, 0.9500235512425445, 0.9491428831979654, 0.9597379731800618, 0.9501785840022072, 0.9609808737336124, 0.9527691060734481, 0.9572848139283054, 0.9607014778024405, 0.32785143877589007, 0.34016000515577427, 0.3100351540964894, 0.3311967271811844, 0.3329988578790868, 0.3431248119454212, 0.3444667126529357, 0.2959287041551696, 0.3060014894416129, 0.48296661343182856, 0.6332838869058517, 0.6123118486501888, 0.47603224409492395, 0.6091924812454735, 0.448988186175431, 0.4494406295980069, 0.5224776558174997, 0.5437596401550817, 0.14624216632921383, 0.25933424791513937, 0.19469992906141242, 0.15750414638002896, 0.17006258874091018, 0.1757123164236114, 0.1704181577400835, 0.16435279896921728, 0.1765045792741079, 0.18222037330702878, 0.15953097971303687, 0.18480711718280418, 0.24937084434794143, 0.19709135219452034, 0.17141417169522832, 0.17450698065305315, 0.16235080411657055, 0.1978163336262837, 0.02955290313106107, 0.038523061656595026, 0.024809275642201256, 0.03213346187177324, 0.01082017374940647, 0.01934126271134995, 0.04538322038994558, 0.005314328519300804, 0.014469296700716616, 0.1684692890551518, 0.16040379673648208, 0.15440641275799827, 0.14614807714298672, 0.10215883271519999, 0.10530038673117958, 0.1605479687994954, 0.1508906759119505, 0.13170518395414232, 0.033865464669624035, 0.06509977311363979, 0.05471123996937677, 0.04606568130886668, 0.05996325918093304, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13236496699983813, 0.10015247874440991, 0.14056468781632592, 0.18349869121338036, 0.12941852751675598, 0.11738713921798771, 0.12278336072017171, 0.0954171471932137, 0.09638894607196669, 0.44131780956782585, 0.4740678935551357, 0.4608452983766609, 0.44013199153576155, 0.42784897786724463, 0.43930213677802776, 0.4779996730900532, 0.4336043495061699, 0.45272391869587614, 0.10667636915150669, 0.12732309055333058, 0.11982543676715829, 0.1261659115606799, 0.11877626632863125, 0.1124364634591064, 0.1008871330536224, 0.11721347302561824, 0.09184510746551111, 0.2040231219482357, 0.18235440873644926, 0.1940359289014525, 0.17161434061233272, 0.28044824800780155, 0.17754962190088186, 0.21419376348986396, 0.16777851870834604, 0.13100898656359805, 0.32352969663075404, 0.308553704499678, 0.3505045679684705, 0.3080430045228988, 0.2955936775137228, 0.35588490304623344, 0.32329927039075024, 0.33277882071054676, 0.3445027074765886, 0.2400604343584105, 0.21532516909680666, 0.24334230887898234, 0.2659465581093433, 0.2666268476743281, 0.23881939594099177, 0.2627883730049029, 0.24803647567247977, 0.2188182848405419, 0.23531726252437635, 0.20355604248934267, 0.2036620692316804, 0.20882245065668525, 0.19162538636000914, 0.20632274141896612, 0.232634708943395, 0.19650029616487708, 0.19453138575862405, 0.20511145779157458, 0.22104646826186003, 0.20433554344527727, 0.29798011930238466, 0.19613518732132984, 0.20137933928356377, 0.2183515779456232, 0.2262289605090163, 0.19806740223010266, 0.7041405427240441, 0.7685422804624289, 0.18278850099140886, 0.83333990187658, 0.19752303660484805, 0.1684116798258778, 0.14161992610248475, 0.19230473014528027, 0.8027043198851689, 0.7577027610438458, 0.20905336464192492, 0.5246586139836436, 0.2058559205194488, 0.16728155485293628, 0.4344802826971601, 0.10450464072767862, 0.2035792096528829, 0.5820780742780043, 0.17556255120737696, 0.18091011879415797, 0.1729776585595597, 0.18416685143782818, 0.1781704592316793, 0.18502973338974438, 0.18748003829451898, 0.1876003706857462, 0.18905024043232677, 0.0872348582856084, 0.0795127633834658, 0.0955550490527114, 0.08287212239378805, 0.08077020548543934, 0.07777182618340395, 0.0708197133832209, 0.08821408051451018, 0.0889181871737037]}, "mutation_prompt": null}
{"id": "dd187b97-d963-4549-aaea-bac31d0aabc5", "solution": "import numpy as np\n\nclass EnhancedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly larger population size for better exploration\n        self.inertia = 0.6  # Adaptive inertia for dynamic exploration-exploitation balance\n        self.c1 = 1.7  # Increased cognitive component for enhanced local search\n        self.c2 = 1.3  # Reduced social component to prevent early convergence\n        self.mutation_factor = 0.7  # Adaptive mutation factor for diverse search strategies\n        self.crossover_rate = 0.85  # Balanced crossover rate for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Moderated clamping to refine exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedMemeticPSO", "description": "An Enhanced Memetic Particle Swarm Optimization with Dynamic Learning using Adaptive Mutation and Reinforced Convergence Strategies for improved performance.", "configspace": "", "generation": 64, "fitness": 0.3174427014151575, "feedback": "The algorithm EnhancedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.7245714077695791, 0.7357320219564538, 0.7111786116411201, 0.7412005457099209, 0.7242810046782477, 0.7423974138575071, 0.7246118210438288, 0.7089480754121289, 0.7011697900540742, 0.40395782896424925, 0.39167448839718066, 0.3698821696492287, 0.43992894537972815, 0.3493911451634414, 0.384235252293775, 0.38399678749080357, 0.42764177421967065, 0.43128804989806735, 0.15679076519009938, 0.14332758290949243, 0.13080207018421175, 0.1352130137035643, 0.12255893181276589, 0.1485398561274347, 0.13551777343001414, 0.1526595957298561, 0.1357771169038846, 0.11986036633657748, 0.10781931857169524, 0.1235139856265225, 0.1396073317277895, 0.1511827249185369, 0.1276873230176394, 0.13489161184374754, 0.10809442319512397, 0.13545334339456527, 0.9644543634686171, 0.9468237391069647, 0.9456816151205231, 0.9585591650151652, 0.9336388056269453, 0.9219798635887324, 0.9403333271860939, 0.9523042937211625, 0.9536185200595124, 0.44339914443528694, 0.4307348323724183, 0.39610201377174403, 0.48233430788311915, 0.4057150456700255, 0.40614832468597684, 0.4162021801487532, 0.39510166242434497, 0.446410769028487, 0.7206608355052394, 0.6922197217523762, 0.6206312157430697, 0.7544861494486609, 0.5511796896695982, 0.6290200993751502, 0.6897781238555045, 0.6139998451596864, 0.6664725012510642, 0.18808479993606753, 0.12388908428271683, 0.1879305242547331, 0.16606336569149516, 0.2046485556469313, 0.11121860207180634, 0.18598641556398, 0.18601320425297885, 0.21105811958927523, 0.21996995557733, 0.2283169075859185, 0.1686582068545609, 0.12905272201664797, 0.19659937089085378, 0.12895170199539807, 0.2200029312088907, 0.23049298025423948, 0.1865087127381846, 0.05140586282624593, 0.04353335771089184, 0.04773501585538198, 0.04054564349794543, 0.06711810628834769, 0.038465853644159664, 0.07025721336950208, 0.039736525373378795, 0.0533992616594976, 0.16921774849141746, 0.11851233397136784, 0.17135426812804289, 0.13042598098977687, 0.14998054756999046, 0.1257318955426754, 0.15922138424739674, 0.18093031650526248, 0.18079352569914586, 0.05614314285314137, 0.027571813390414146, 0.03785369821819362, 0.1248729164902721, 0.03988662215235195, 0.17631308853598093, 0.07694495757636377, 0.02845260230463187, 0.17649194299225401, 0.14343494661828393, 0.1470015256896342, 0.22540895465958632, 0.14132507382271853, 0.16690455387063774, 0.2408932835200488, 0.13542078628094145, 0.16988164692408414, 0.134404369482077, 0.5287299314568588, 0.5051536973869952, 0.5261123970087767, 0.4959178178628638, 0.5043749443619524, 0.5205660686373696, 0.535121272450391, 0.510408220956448, 0.5322684035225982, 0.12582615207140502, 0.13533488246987324, 0.0945607820800376, 0.14217676994265405, 0.0947792613932299, 0.1341076469362018, 0.10867409475525891, 0.10187265638422938, 0.10342792003571155, 0.16918282088445036, 0.2074228403841244, 0.3212087970206564, 0.23411277533969455, 0.43673089069669824, 0.1872701448833276, 0.28255267373400617, 0.32969687622323984, 0.2641374945149316, 0.33845531346967983, 0.3930215338470425, 0.40432867854794596, 0.3851267621883051, 0.36171645289658294, 0.3635731989100828, 0.4057450215352908, 0.38931126200365396, 0.40269012428198125, 0.24384130987481245, 0.3016022902289476, 0.2528723100486513, 0.2835040440052494, 0.31608573366119275, 0.26554921396193243, 0.28997074756892394, 0.2733038261405045, 0.2659140052025488, 0.21393125616788933, 0.2295065430058899, 0.2152207346505366, 0.2156738799634912, 0.18996218244614305, 0.200960299959966, 0.22296413198791865, 0.24006030025424285, 0.24886339673209945, 0.25764789949011024, 0.4094927259123088, 0.5264359758941086, 0.4924786522244168, 0.3526293802775895, 0.21160619348228948, 0.39763757350508744, 0.20409017448058142, 0.23321788404193844, 0.1854110765366065, 0.186891619921296, 0.1831273027271636, 0.8611261699526556, 0.19820615808138586, 0.7783922983312824, 0.7869564764771697, 0.16138795761885116, 0.8379222545362427, 0.6596691717342854, 0.20303543077268427, 0.5477729188669618, 0.6568215754603253, 0.6984919674880139, 0.16635925479303804, 0.48938507457212954, 0.5930389125311079, 0.6433336778743942, 0.1842513328066565, 0.18266034252995422, 0.18708227721824033, 0.17850812921046455, 0.18586905894533712, 0.19953175597388995, 0.1800833700780009, 0.1849990198755047, 0.18451185230811284, 0.09154862466226932, 0.08673555122601051, 0.07989093257544044, 0.09428233239116923, 0.08886265189150544, 0.0927433771048316, 0.0843915171503733, 0.08305316223467385, 0.086178322531278]}, "mutation_prompt": null}
{"id": "b84efb32-f311-4fcc-a2d2-fd6aa2fb0b52", "solution": "import numpy as np\n\nclass MemeticPSO_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly increased population size for more diversity\n        self.inertia = 0.6  # Modified inertia for improved exploration-exploitation balance\n        self.c1 = 1.8  # Enhanced cognitive component for refined local search\n        self.c2 = 1.3  # Slightly reduced social component to prevent premature convergence\n        self.mutation_factor = 0.4  # Lower mutation factor for increased stability\n        self.crossover_rate = 0.85  # Crossover rate adjusted for better performance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for improved exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))  # Reduced initial velocity range\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Enhanced Local Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "MemeticPSO_Enhanced", "description": "A Memetic Particle Swarm Optimization with Enhanced Local Search and Adaptive Mutation for improved convergence and solution quality.", "configspace": "", "generation": 65, "fitness": 0.31684522874979054, "feedback": "The algorithm MemeticPSO_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.7131729518598029, 0.6933709521408473, 0.7043996919765463, 0.7230364925294199, 0.7140402254767588, 0.7153621786679668, 0.7289798722359355, 0.7057983720470666, 0.7212910277816211, 0.41054310711064923, 0.3401846516927548, 0.36221954643607746, 0.41522882387378646, 0.3694544708027929, 0.3345678551942074, 0.365414020676879, 0.36895371359946705, 0.3917873363624179, 0.19015714126334282, 0.14717241220117705, 0.1392528678422843, 0.12942904267736177, 0.15080925225666852, 0.12897077237931276, 0.13856586880680277, 0.1418760042254642, 0.2510444064242383, 0.1211350374448209, 0.13137336561329227, 0.12892822089223865, 0.12229191927056215, 0.13558091647894033, 0.11031546345083187, 0.11643106039992146, 0.13240336649414075, 0.13149216658525587, 0.9540581253183279, 0.9357707442880991, 0.9413275090873616, 0.9540040555928645, 0.9333285907955421, 0.9374009183195238, 0.9325632652875615, 0.9569907935631022, 0.9299226388389341, 0.4515747224824147, 0.4532558421144105, 0.4094722214767891, 0.4587906423306003, 0.4336285147903314, 0.4180927052460266, 0.4289319569419482, 0.42613072149078657, 0.4663523249423299, 0.6859838708112906, 0.7094604221076712, 0.7148329625565795, 0.76314451174177, 0.6416699019903784, 0.6953839615936763, 0.6720555468884195, 0.6540165798907868, 0.7073510320557292, 0.22504811548052472, 0.1860240621063597, 0.24749308738853892, 0.1254727595742039, 0.16113541531248643, 0.3085429057167375, 0.18957958260127494, 0.1797676232806018, 0.1874252831980432, 0.21537153108647467, 0.2735176205138189, 0.2203531481962775, 0.18107366295201088, 0.1871243101287694, 0.20566278096703483, 0.22318670380641892, 0.2164665255774424, 0.2409679343170017, 0.087425682720352, 0.12564542917228283, 0.192971139404173, 0.0742127258656996, 0.10592292538101722, 0.04537690421648055, 0.09338068527842402, 0.12547539417412845, 0.04392430470367892, 0.2371048159580892, 0.2377046261766168, 0.2572063862168371, 0.24894216967038252, 0.26283653647622607, 0.23689641020803764, 0.24565091639072612, 0.28106560376142653, 0.25445698449086873, 0.08917660911695546, 0.036087043097658866, 0.052316230626669125, 0.09571700155054919, 0.07623678823307778, 0.07790408743088506, 0.07951752170171167, 0.0667682520851356, 0.07416116894273439, 0.16017253317404634, 0.18428466920024267, 0.1631970907232455, 0.18457087547080941, 0.16589552818779885, 0.17789762856271119, 0.15055783034283599, 0.17146987067490627, 0.1649746953475003, 0.5640528339679285, 0.5473360013034954, 0.5325959511000289, 0.5141226644484003, 0.5285316968679734, 0.5208697747858833, 0.5745260270179722, 0.5472595225976216, 0.5771796185541174, 0.12169257015978452, 0.1564502932496773, 0.10336439260062813, 0.11204455842959271, 0.1043787867665602, 0.12921327532609106, 0.12302788648218899, 0.15608645523374143, 0.1390292410844124, 0.38435791341127645, 0.2793821196065961, 0.22756167478126343, 0.2465543828332356, 0.30410806306359484, 0.35628776241635496, 0.20078217564800194, 0.255273372833143, 0.20092669007025044, 0.3905456692291154, 0.40060554187280417, 0.3874671452540358, 0.40698814435029684, 0.4078680473261108, 0.385478181593942, 0.39992589822604874, 0.40257146646106146, 0.4116893784971043, 0.29979741195082577, 0.19677010853573162, 0.29927273027863766, 0.3138662424235624, 0.27109536199953976, 0.25226698813951853, 0.31480582220257514, 0.3056703489538968, 0.2690529032067859, 0.20754052248687072, 0.22742409009376685, 0.20692380852020542, 0.24485044672226808, 0.22933854469986903, 0.21906123963272617, 0.21169820043686027, 0.21825884273182317, 0.2255982060248587, 0.2069655158038297, 0.22667655056086167, 0.39836295246256115, 0.2010196736011407, 0.19777197791851908, 0.4880063839748343, 0.22855214508934063, 0.22716043124796648, 0.1956124695921031, 0.18564334138119998, 0.18726372839215377, 0.1808585182575546, 0.8564805886896694, 0.19931235315082796, 0.1953003860241458, 0.14100115949461356, 0.17104365466960025, 0.8054792357844982, 0.7454168036086368, 0.2090075949938991, 0.07342313217757179, 0.7100420507968845, 0.5713624489741362, 0.1664121570783469, 0.10476635179190996, 0.592975965752999, 0.7376086539978317, 0.1825040141057369, 0.18637868989923123, 0.2035625820538055, 0.18863971749291508, 0.2003458768112263, 0.18611504656413747, 0.19418681284931705, 0.2079066024471833, 0.1825910309065315, 0.07993335684302671, 0.09609807941252968, 0.0765746889142005, 0.10554320853559862, 0.08389094010191889, 0.09293205914568847, 0.09051767418772128, 0.08520658739585396, 0.08684144587598475]}, "mutation_prompt": null}
{"id": "51b34923-c53c-4c97-b9f7-90e0ec24b228", "solution": "import numpy as np\n\nclass DynamicMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for deeper exploration\n        self.inertia = 0.7  # Dynamic inertia for adaptive exploration\n        self.c1 = 1.7  # Slightly heightened cognitive component for improved intensification\n        self.c2 = 1.3  # Decreased social component for controlled convergence\n        self.mutation_factor = 0.6  # Enhanced mutation factor for diversity\n        self.crossover_rate = 0.8  # Reduced crossover rate to maintain structure\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Tighter clamping for refined search space control\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-2, 2, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] + \n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "DynamicMemeticPSO", "description": "A Dynamic Memetic PSO with Adaptive Velocity and Self-Adjusting Parameters for Enhanced Performance Across Varying Landscapes.", "configspace": "", "generation": 66, "fitness": 0.27311683659916497, "feedback": "The algorithm DynamicMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6149238052421037, 0.5937051903977386, 0.5960171650676327, 0.6419430594012954, 0.6673560476255325, 0.5920618984153501, 0.6070044138261792, 0.6485745499180016, 0.6300976816232269, 0.24076752644473953, 0.23897133675981008, 0.2556939561455528, 0.21216709415096202, 0.22657072852326798, 0.24968369899694964, 0.20675972946749, 0.20018161066276452, 0.21709895088912823, 0.13769629028355246, 0.16117659632174341, 0.1375949606867758, 0.14913672544020884, 0.12640465370099796, 0.12917449804969838, 0.16107893497207948, 0.15266346322601498, 0.16324620340590623, 0.1451082254922922, 0.11736339969246834, 0.1270344947022246, 0.10482021601406, 0.10031945794864405, 0.12173233699539976, 0.1346078112226311, 0.11264655581788652, 0.10165496031754395, 0.9629871971440948, 0.9530798341636171, 0.9632491595907969, 0.9518590288469218, 0.9502112500063717, 0.9457868349279354, 0.9614820920089937, 0.9595243747744121, 0.9592518982853739, 0.3268424827906523, 0.33995856787077705, 0.3420606425120579, 0.361993671639504, 0.330484089653984, 0.34757399629224073, 0.3335902191232881, 0.3236232760278248, 0.3435492985134444, 0.6570113940433833, 0.607379001038364, 0.495566463262753, 0.5390124158219547, 0.5336974639249472, 0.6931365574624633, 0.48981038222840356, 0.39662015297866937, 0.5979388607688564, 0.18349941545395487, 0.14605237675955485, 0.17823131450650964, 0.1125116160789319, 0.1954144159643748, 0.16873303612155632, 0.17464374497443846, 0.16736709846661812, 0.1581413791826939, 0.20147191696060096, 0.17465912805239514, 0.18214978020200634, 0.19751212545558183, 0.1909690552311748, 0.18729703098620964, 0.20723008476196048, 0.20581189885127593, 0.17784381229221313, 0.034856528567418166, 0.034235181840010176, 0.04056204050871859, 0.0669913843711265, 0.04123018847005844, 0.025351606565980567, 0.044748642040268405, 0.03496913062196494, 0.02651248529171646, 0.17693816169441523, 0.15347464585550497, 0.1796448805848989, 0.15368404159213156, 0.14737180998040933, 0.11182429522708703, 0.17487214847654964, 0.2085385185502483, 0.1636726241555152, 0.00453974799882273, 0.0023274939636248604, 0.01199606166148548, 0.060790614627746264, 0.09753421498855552, 0.09405207286267647, 0.051417698870651285, 0.06213018874025111, 0.017406138816778216, 0.11950134624767272, 0.1205812130266748, 0.1207972155112591, 0.11917783054738351, 0.1431047611071814, 0.14921660184025554, 0.1315637667831575, 0.13371036104194023, 0.14675178080016216, 0.46154955938784603, 0.4514064121955962, 0.45483755596778686, 0.4688950217303838, 0.4527197005594178, 0.47230872240607014, 0.46784997359158387, 0.458555046742257, 0.46407197270782374, 0.11185843050185618, 0.1309082048781125, 0.1236240202095712, 0.14040975248207888, 0.11267026547545977, 0.13935898613593056, 0.09846432138005767, 0.11008911336375637, 0.13793744683654463, 0.18263646527407595, 0.1574823783507101, 0.16194017043378894, 0.16764985071776373, 0.1592696590446845, 0.12608708463216334, 0.21477619856987185, 0.20127474476469376, 0.1424793044076671, 0.3589471093636527, 0.3199078135428143, 0.3181818993092047, 0.32374821123701847, 0.3381645218053242, 0.33902667339189585, 0.376514501737665, 0.36960042993096076, 0.3359697059097152, 0.24847384579247422, 0.20474093067483967, 0.21679716848038955, 0.23735342349358612, 0.2822250651736845, 0.19933059585942003, 0.23573205811799913, 0.26354173929740987, 0.2291076565177096, 0.20788160968660707, 0.2029136324542513, 0.2055524958762176, 0.23627143549793495, 0.21130874900017094, 0.20080543881610824, 0.1891701250379546, 0.20391034670587926, 0.21945568661600834, 0.1918308366885083, 0.22521206247287406, 0.2161371694660611, 0.18154695559079848, 0.22539216116678995, 0.20370231994800803, 0.3196041115476257, 0.2301568822055392, 0.3658489217306371, 0.184206533059861, 0.18567146357994901, 0.20642367200764222, 0.7819894738938044, 0.1978788243107611, 0.191529787507964, 0.6737109300177087, 0.5253788426089303, 0.8141755735980344, 0.6788335944521114, 0.20830976745408392, 0.29794600499845614, 0.20721823178429366, 0.16724459789863666, 0.16493736831979855, 0.5392899785676479, 0.5622489079695161, 0.579529930718039, 0.18023056601885745, 0.18953520238291366, 0.19315637800587981, 0.20034321861869842, 0.1938850246429571, 0.19112568947771058, 0.20229503737145094, 0.1835939583799011, 0.18147071814957672, 0.08864925568721915, 0.08508589707856495, 0.10265259043124275, 0.08878009811445287, 0.0925872410722095, 0.07253815813948128, 0.0972161123073807, 0.07880902161478387, 0.09364891460553304]}, "mutation_prompt": null}
{"id": "09a561ad-5b8c-4948-8583-e135520013e0", "solution": "import numpy as np\n\nclass HybridAdaptivePSO_DE_VNS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Slightly increased population size for diversity\n        self.inertia = 0.4  # Lowered inertia for quicker convergence\n        self.c1 = 2.0  # Higher cognitive component for local attraction\n        self.c2 = 1.0  # Lower social component for focused exploration\n        self.mutation_factor = 0.7  # Increased mutation factor for diversity\n        self.crossover_rate = 0.8  # Optimized crossover rate for robustness\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for moderate exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Differential Evolution and Variable Neighborhood Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                # Variable Neighborhood Search\n                neighborhood_radius = (global_best - particles[i]) * 0.1\n                neighbor = particles[i] + np.random.uniform(-neighborhood_radius, neighborhood_radius)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n\n                neighbor_fitness = func(neighbor)\n                eval_count += 1\n\n                if neighbor_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = neighbor_fitness\n                    personal_best[i] = neighbor.copy()\n\n                if neighbor_fitness < global_best_fitness:\n                    global_best_fitness = neighbor_fitness\n                    global_best = neighbor.copy()\n\n                if eval_count >= self.budget:\n                    break\n\n        return global_best", "name": "HybridAdaptivePSO_DE_VNS", "description": "Hybrid Adaptive PSO-DE with Variable Neighborhood Search for enhanced exploration and exploitation through adaptive strategy and neighborhood perturbations.", "configspace": "", "generation": 67, "fitness": 0.306763864097521, "feedback": "The algorithm HybridAdaptivePSO_DE_VNS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.7672347591586997, 0.7559498172148352, 0.7523535221344912, 0.7484834557945796, 0.7784695778909961, 0.7491249786350722, 0.7561176250615576, 0.7570427697941363, 0.7754002414853473, 0.45233876430526876, 0.4934992219536952, 0.4367683983488504, 0.45172013636030983, 0.4879463590260341, 0.4518360737431112, 0.4535605831782439, 0.48112890611382, 0.4997374604244075, 0.15655950866916324, 0.12673815517576636, 0.30431154386112125, 0.18917813180960208, 0.15419396300340682, 0.1898224350775215, 0.17926415619051894, 0.13585779760887395, 0.15370028325089302, 0.11603477327447309, 0.11604475141320669, 0.13113040638291384, 0.12770805006430397, 0.11753654837882099, 0.10585425686846484, 0.13513727519777863, 0.1200365425960217, 0.13740958734549746, 0.8994562376619328, 0.9336342125236523, 0.920121460930416, 0.9319543722526462, 0.8990408899882898, 0.9374460169303939, 0.9067654491278028, 0.930766888944706, 0.9054525668830973, 0.4955117273505717, 0.4549609406436449, 0.41510691606349637, 0.4419477065273093, 0.48384100873546676, 0.47204397257566366, 0.38426193897361627, 0.44990529019353753, 0.43456803395046995, 0.7320318617642244, 0.7721688935799971, 0.5412054340493335, 0.6852355439804347, 0.5855127574997674, 0.20937719289723578, 0.6112106288630723, 0.5127023050827739, 0.6668855891169716, 0.166639365834801, 0.17656414504275764, 0.20657083024770462, 0.12126757443697422, 0.361606182783924, 0.12629852635054561, 0.19113627263678945, 0.18126470671715, 0.20466169040127968, 0.19371793346907173, 0.22245172180336836, 0.1354367850511924, 0.19513522580071274, 0.12589680116018243, 0.2063860467339268, 0.2434102302416602, 0.17718752883692956, 0.12462044457683719, 0.032227796937654096, 0.057005061757087194, 0.12724175346971245, 0.03712372832454969, 0.03328317098655642, 0.01805863913639283, 0.04659370966993959, 0.03348839430811057, 0.002899456343349982, 0.15118177210538963, 0.1063010726566852, 0.14288614311546777, 0.1332412000636034, 0.14039057434668434, 0.08862622406029463, 0.13482042092084157, 0.17408616619089556, 0.1239622673468137, 0.19325920251212914, 0.13133576506482436, 0.08001180040264189, 0.08371385770835937, 0.2211423337313836, 0.1094885048106069, 0.12213394952046563, 0.2547112375840399, 0.11989180138420108, 0.15001131408897306, 0.1641853329457843, 0.11518344629567201, 0.11142985675498895, 0.17294784401609853, 0.1175888864808754, 0.15129072632018703, 0.07560456388506975, 0.08699328400810502, 0.5360336331657839, 0.5033942103918603, 0.5160174255925083, 0.5168407828663713, 0.5268716104489646, 0.519768036943629, 0.5283909990843745, 0.5381721675559814, 0.5424621976141055, 0.113502860415999, 0.0952816929090532, 0.10020200764332421, 0.12023393378155611, 0.11676804147664521, 0.09508808005049618, 0.14572215945303957, 0.12716715131007528, 0.1226583328776002, 0.2082064463003207, 0.18201790906338622, 0.17369294317004536, 0.17237960277655873, 0.18451464020339214, 0.2065491266092141, 0.16374747986992677, 0.24012958706704002, 0.1948122364761281, 0.36859059419975015, 0.34375511167718964, 0.3740878579170348, 0.36260847468673696, 0.42040821813286977, 0.3762495802934338, 0.4162806414674409, 0.44526563224149396, 0.4464116464773956, 0.29836304870181185, 0.2909354154179957, 0.27166297466077827, 0.31233285282828693, 0.26576470048550793, 0.26463971622237237, 0.2672643554429168, 0.3192306033539335, 0.21386571678101007, 0.21871869994166615, 0.21483763503665299, 0.24655339650105002, 0.24224200456560496, 0.20941406242508065, 0.20920432079078133, 0.22393802511939198, 0.25076803371334777, 0.23309903941840115, 0.22090322307713062, 0.417473196546587, 0.20912093083723504, 0.22186853593353317, 0.22574740897538537, 0.21191384855453643, 0.22025890555037597, 0.2349454752234884, 0.22315845852203486, 0.18210649125639466, 0.18594840765424991, 0.741766453472435, 0.8689154184900594, 0.199837419640298, 0.16836998794551095, 0.1418478771695989, 0.16990644919377862, 0.8586779518657088, 0.6991716942287749, 0.20924743119005784, 0.461835866398407, 0.200909277063395, 0.45665852416286445, 0.1514629481232307, 0.10421077372160104, 0.6255416055091332, 0.685936621589009, 0.19305946127405849, 0.21526613289575358, 0.18404371256687369, 0.1981188002060893, 0.18959623119726798, 0.1959297201712702, 0.20407237449594273, 0.1838797112189673, 0.19141775138020867, 0.09098962092607366, 0.09872371048055517, 0.09153135640292043, 0.0888361266191694, 0.09751794355522869, 0.08071894024809623, 0.12203604619027641, 0.08527307561917441, 0.09218516884191175]}, "mutation_prompt": null}
{"id": "c837b17c-5f75-4643-a87e-dc36bef2c928", "solution": "import numpy as np\n\nclass EnhancedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.7  # Increased inertia for improved exploration\n        self.c1 = 1.3  # Slightly decreased cognitive component\n        self.c2 = 1.7  # Slightly increased social component\n        self.mutation_factor = 0.6  # Increased mutation factor for better exploration\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Reduced clamping for controlled exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedMemeticPSO", "description": "An Enhanced Memetic Particle Swarm Optimization utilizing Dynamic Differential Evolution for adaptive exploration-exploitation balance in black box optimization.", "configspace": "", "generation": 68, "fitness": 0.29632557615729593, "feedback": "The algorithm EnhancedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6447637649280923, 0.6508481111995159, 0.6588290833638798, 0.6695433519369838, 0.691914366978536, 0.6708453464877573, 0.6576348737959983, 0.6593378858060112, 0.6338035742482859, 0.25034903816125254, 0.28146202905468176, 0.2876642297848103, 0.30871493708945996, 0.28477314150613087, 0.26263150280576986, 0.29234297174359614, 0.33207202288822935, 0.29516097939308417, 0.15479670498745013, 0.20060188269911705, 0.13816966604029657, 0.14821286679762502, 0.1306819500826577, 0.1310187506476912, 0.13307312026848828, 0.15871020037320127, 0.13822514858418522, 0.12421287895589428, 0.13972498341310913, 0.11452172832258545, 0.11904288937145846, 0.1011219368396683, 0.12102032171136556, 0.11097467700820218, 0.12066955522917655, 0.11366057004478769, 0.9616969551345986, 0.9522215795503504, 0.9653238813903007, 0.9581252782833186, 0.9679832522459011, 0.9581457701312152, 0.9621208814361853, 0.9596157355500653, 0.9582923074531495, 0.37925145605470445, 0.3557888242487529, 0.3689367366203673, 0.3803458297474458, 0.3947950240794712, 0.40203439469020863, 0.3466294619020599, 0.35030620723359174, 0.34382926037360995, 0.7067254240995617, 0.6578806932220695, 0.6198920184915666, 0.6216644511950377, 0.6301328535018857, 0.7349836170245247, 0.589627834655725, 0.6337141588980515, 0.5717685989365588, 0.20698757768112386, 0.17089395648894845, 0.18731769502434692, 0.20090260628100332, 0.20599069670793724, 0.23454110841280107, 0.21540647024785586, 0.19949597290596566, 0.21103908160871876, 0.2178300827070222, 0.21549561092712288, 0.18662217412054793, 0.18353195481292262, 0.23575168275092306, 0.19296767918093316, 0.21401624397064867, 0.18974377368052897, 0.21604165171193923, 0.08636049960719905, 0.10030922743780468, 0.10704816222392621, 0.10938047917512672, 0.0624137030536438, 0.10748370019768971, 0.07978021780494549, 0.06674381506838745, 0.07796228982054687, 0.21574153743167535, 0.19663642719509067, 0.19323347087567866, 0.23711440150296814, 0.17751804829187245, 0.20040545298190782, 0.236542400506479, 0.23909451896328615, 0.21386053135015104, 0.0887348399471124, 0.015708770035401942, 0.01630697333511466, 0.045055442333596485, 0.015716379583478934, 0.03930423458552157, 0.0643827520106961, 0.03350451720319958, 0.02102212144420157, 0.1456587591192341, 0.14818542844652915, 0.13104341521878138, 0.13364940730317243, 0.1515949316141456, 0.15411926231690753, 0.13564974273885777, 0.19296042711276773, 0.14494921807349148, 0.47735398188412803, 0.47397367967306514, 0.47825834063126804, 0.4948005528897004, 0.5088321983207433, 0.48942733077726674, 0.5218087164689235, 0.47517114811830885, 0.4872531038880936, 0.11532322107403903, 0.11586848754583223, 0.11984590512073046, 0.1296177939236468, 0.11479967571089311, 0.10321778930150705, 0.13100332318976438, 0.12464954207090073, 0.14961358276843661, 0.2792276764111614, 0.15828524291515644, 0.20634433784630568, 0.3639772387451412, 0.15964641917283973, 0.18622599106333715, 0.20218929983771883, 0.19152897375758915, 0.29041849330611, 0.3236800819806287, 0.3139800358277717, 0.3576706864814996, 0.36689096547065925, 0.3404316556056646, 0.33554278681329963, 0.3404962776088343, 0.34751300974311816, 0.35825002189679855, 0.25372779452424554, 0.28327070122338727, 0.25648779974987956, 0.2602653163594365, 0.1890272886363218, 0.2674091487635164, 0.2598676564588309, 0.2732706606998444, 0.29849418175960274, 0.20724796735444473, 0.20938264312270072, 0.21998835908889136, 0.209955890961804, 0.19089721149481442, 0.21747428186752082, 0.20471069038343026, 0.2214780024575541, 0.2915468765276201, 0.38351632981208317, 0.2758169644066566, 0.29966481848208026, 0.2143237302829143, 0.21020108759044243, 0.19677733634160122, 0.3094970724127414, 0.21562482403391725, 0.2228424935538218, 0.7462592374650758, 0.17413219761267884, 0.1520225026104257, 0.8416878217472066, 0.19905504521484108, 0.1963107217276474, 0.19463299533159895, 0.16715766941285615, 0.7993245568976294, 0.7404350262994575, 0.20938801314751343, 0.2053119666677865, 0.6306028060884752, 0.208270901651335, 0.16570177694704924, 0.5484841866612509, 0.6189170160393948, 0.6439042741529586, 0.1872299778183203, 0.18994686952486461, 0.186058866444747, 0.18032701736692036, 0.18547979405729964, 0.17745556630017112, 0.2281119567292632, 0.20612192033569132, 0.23062303932872052, 0.08217775093875412, 0.07996791859024066, 0.08741382625337157, 0.07698035978742823, 0.09671000253204542, 0.09791155537671947, 0.08993054686014479, 0.08576513903485139, 0.08791387699899711]}, "mutation_prompt": null}
{"id": "02648e3d-fef6-4450-a789-0a5c73a970bd", "solution": "import numpy as np\n\nclass MemeticPSO_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for diversity\n        self.inertia = 0.9  # Dynamic inertia for adaptive control of exploration-exploitation\n        self.c1 = 2.0  # Increased cognitive component for enhanced local search\n        self.c2 = 1.0  # Reduced social component for focused exploration\n        self.mutation_factor = 0.8  # Adaptive mutation factor for controlled diversity\n        self.crossover_rate = 0.7  # Lower crossover rate to focus on promising regions\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for controlled exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * np.random.rand() * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n            # Adapt inertia over time\n            self.inertia = max(0.4, self.inertia * 0.99)\n\n        return global_best", "name": "MemeticPSO_Adaptive", "description": "A Memetic Particle Swarm Optimization with Adaptive Mutation and Dynamic Inertia to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 69, "fitness": 0.2967886345390593, "feedback": "The algorithm MemeticPSO_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6434691727625501, 0.6259827258846005, 0.6265900310814294, 0.6513190856307847, 0.6489127179219627, 0.6436634582756153, 0.6598295389763399, 0.6291111643387485, 0.622038866850688, 0.3410562681075485, 0.34537005176154745, 0.3342701275749167, 0.3185304819596807, 0.3212154412701075, 0.35869932848730135, 0.3410764628772187, 0.3068669223432654, 0.3406618367509404, 0.25472589230062337, 0.22591244929331833, 0.14301239510014552, 0.14405650943624548, 0.129706760373675, 0.12492982501493732, 0.2124988802984854, 0.1417624741487169, 0.1454261760109179, 0.10931346744921389, 0.13259753244366346, 0.13542438688849057, 0.11569391332074086, 0.14146911854214284, 0.11004292240215541, 0.12150390994146187, 0.11223157539371242, 0.10472988735247613, 0.9599812535821572, 0.9570450343880458, 0.961058951423693, 0.9567685994557797, 0.9476366496354635, 0.961542504830256, 0.958261939109162, 0.9627059656009658, 0.9607830833956797, 0.3952248890164123, 0.38211782853097, 0.3878651445760317, 0.3959008673986869, 0.38595769652658196, 0.4057405504304865, 0.3794720816079412, 0.38264217413923307, 0.38229313200353, 0.6784122877051528, 0.5671401082719848, 0.577475706403771, 0.6161550245151122, 0.6258991769092821, 0.5902561514716089, 0.5968555011769214, 0.5896426766000323, 0.6160079846794984, 0.16015683648934087, 0.16138188162562705, 0.16195049283342355, 0.26253005405456464, 0.14916028581698015, 0.14816858548033818, 0.15629712920010497, 0.15201836857365802, 0.16087861637394563, 0.18812354231935846, 0.1569857147111655, 0.1767989858034984, 0.17621919294420718, 0.18091954803497434, 0.19953173394331103, 0.1994027748764885, 0.20415139531653492, 0.16371909178286748, 0.018508892867678872, 0.05969814744488633, 0.030917065202013094, 0.016916561451953416, 0.03146263064257293, 0.030622477421233474, 0.03584796393958045, 0.0319558032407562, 0.009195003210436536, 0.1464580916092395, 0.09083757103700352, 0.13999160567081304, 0.09999137570878536, 0.13913002279130304, 0.07364118297241273, 0.14755378450299905, 0.13208663817227861, 0.1663169301222348, 0.10011283763392853, 0.0942628579731909, 0.09432412562784398, 0.07211706418425112, 0.05509459539194306, 0.18546637647684638, 0.07396149123320772, 0.08031324109231242, 0.03978334752900936, 0.18774816330288024, 0.19971071084184422, 0.14131068605674968, 0.16646153528566587, 0.1916564153310868, 0.13248088450214923, 0.07034216045697517, 0.14569454281513428, 0.06989360004200407, 0.47614857400691424, 0.4490952673087364, 0.46973209856564446, 0.48564864761640036, 0.46723204726570366, 0.4732174783720239, 0.45524026347425794, 0.4759654176444513, 0.49353989904059326, 0.11982519123684054, 0.0993199907534863, 0.1001329529843562, 0.11718419490004528, 0.1174113870168152, 0.132703573656345, 0.12163636177157555, 0.13572762627392276, 0.11825485957106485, 0.28362797659020567, 0.21768515514483178, 0.18279939401957956, 0.278754772661314, 0.17354125649430552, 0.1766756688682123, 0.21512535135489497, 0.20261436195488602, 0.20113402786919177, 0.37014274679879144, 0.3375023820976105, 0.37622633259231675, 0.3196956650098465, 0.3400636653499046, 0.34134559444658163, 0.40802463974783787, 0.38695519786885113, 0.37812843002974283, 0.24802182133725414, 0.24201601917775428, 0.2587721432557146, 0.2411704369684442, 0.23233694778509217, 0.25202976432510116, 0.25811401988064075, 0.2823881849137434, 0.23891631622383824, 0.21238797037292356, 0.22318069576316324, 0.21520932046831553, 0.21133675710074318, 0.21632469904740725, 0.23186003058058102, 0.2323478829588863, 0.20816981778158927, 0.2271861893683842, 0.3544553219393982, 0.21666900820803614, 0.2038699262166569, 0.33348499067251136, 0.485734246831257, 0.19564598279354461, 0.20401901881895101, 0.21398129907041064, 0.4675634080290315, 0.6645317987865205, 0.18456892944248993, 0.685266566107092, 0.7566887363607957, 0.19710113289676923, 0.1671478967692066, 0.7029466767456471, 0.1682947734120962, 0.7582385718837195, 0.5703687161632516, 0.5651827282224537, 0.5636381419542553, 0.61320465426169, 0.5028359235791299, 0.16483768303152158, 0.19806587432301737, 0.5629177337191111, 0.6035327229985159, 0.180078212554604, 0.19437393587553342, 0.17962051145958924, 0.18336688120996703, 0.18838613730030496, 0.1886100819504194, 0.18301617836107753, 0.18647860483010337, 0.1864041521748846, 0.08024341903934651, 0.0857593855483505, 0.08145072095972827, 0.07928287070185758, 0.10555023865506319, 0.08870175094605837, 0.0852524288912575, 0.09700980266494696, 0.09333448049256676]}, "mutation_prompt": null}
{"id": "89236c2f-fb9d-4caf-ae37-b99d3a047def", "solution": "import numpy as np\n\nclass ImprovedMemeticPSO_Hybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia_max = 0.9  # Start with high inertia for exploration\n        self.inertia_min = 0.4  # Gradually lower inertia for exploitation\n        self.c1 = 1.5  # Balanced cognitive component for local search\n        self.c2 = 1.5  # Balanced social component for collaborative learning\n        self.mutation_factor = 0.8  # Adaptive mutation factor for dynamic exploration\n        self.crossover_rate = 0.8  # Slightly reduced crossover rate for stability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0  # Enhanced clamping for widespread exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        while eval_count < self.budget:\n            inertia = self.inertia_max - ((self.inertia_max - self.inertia_min) * eval_count / self.budget)\n\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "ImprovedMemeticPSO_Hybrid", "description": "Improved MemeticPSO_Hybrid with Dynamic Inertia and Adaptive Mutation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 70, "fitness": 0.26096522421169266, "feedback": "The algorithm ImprovedMemeticPSO_Hybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5957558543693218, 0.5596778203669093, 0.5986428284188818, 0.5892104408898957, 0.6062963734661413, 0.5944203807557644, 0.5916670791139595, 0.6012013335424903, 0.6014601669545943, 0.23477299420056574, 0.25708288699102155, 0.2708962840884467, 0.2549628476180281, 0.23377726110906227, 0.2598791215304411, 0.2734246432256776, 0.2373014849336026, 0.2539828243946871, 0.10703122707593427, 0.11774442926174888, 0.11703096544108904, 0.17276244479957348, 0.15590652496621316, 0.1284062436628084, 0.13939014516853676, 0.1967792467241073, 0.13270584793019335, 0.10315374457298399, 0.11227708661461255, 0.12513837785984527, 0.09489577851531084, 0.1364696696076496, 0.1392795217331423, 0.09298067867329574, 0.11038497355084909, 0.11211814203814208, 0.9697134783746624, 0.9571001427086867, 0.9731428490734294, 0.9549186769057159, 0.9696438394683539, 0.947690396105719, 0.9685771204859565, 0.9674116327431432, 0.9697053826137733, 0.3426820054155424, 0.3304364865332715, 0.30647740739094265, 0.3274640490013635, 0.3583102298365807, 0.38552162093709963, 0.3457103575088879, 0.32993408078019737, 0.31725437594290773, 0.40655279006650735, 0.5271372768368026, 0.4161035298957856, 0.6502593765143008, 0.4831499660502949, 0.47988686763184896, 0.6018865974758876, 0.4740358576438065, 0.48292439477383886, 0.17245330501178557, 0.13739455370277154, 0.17302945239771383, 0.10369667656342774, 0.1700758023309118, 0.1667823369633059, 0.17849299382335815, 0.17328613910814472, 0.17741557045120082, 0.16108527878707224, 0.14618305415042776, 0.16543688046399163, 0.16577670590288762, 0.17071568467155207, 0.16933561552163268, 0.17833454058893372, 0.17572648173384076, 0.19391408379701303, 0.021624665179000857, 0.015026218670691427, 0.03639299200825208, 0.005340182210175182, 0.00587166695596697, 0.007736694373723041, 0.011338464257935943, 0.0029099061214789, 0.0015314522195502, 0.13491696690761068, 0.10834626772887257, 0.15511661373608165, 0.12434089039591711, 0.10952330844944302, 0.1218022039929072, 0.13533996802904347, 0.15483751206866603, 0.1136936578768094, 0.018005684126323307, 0.016647991504640247, 0.08855425755829327, 0.10299668917220528, 0.039123827882875606, 0.037391488158228126, 0.10506607217021369, 0.12792168963881922, 0.05369237566956653, 0.14685320982719663, 0.08954914100313294, 0.10988029298772728, 0.12878392622407442, 0.1808800074824174, 0.17436668803201627, 0.1347369725690547, 0.1275533080113913, 0.09203125496972298, 0.4351599542897503, 0.435472121275743, 0.43123156747107316, 0.44707749323793144, 0.42394811735669435, 0.4597213751337561, 0.44443968845150583, 0.43219068942000904, 0.4175661604017862, 0.13422782039378167, 0.09579184639377414, 0.12164691859921872, 0.1189201974805012, 0.10533820429543106, 0.10419957965455173, 0.1317135685497467, 0.10936271724324742, 0.13324235659728112, 0.17199267556603515, 0.17812994257394088, 0.20276168829478558, 0.29105922513022164, 0.2761706697766759, 0.18989688270503458, 0.16831252427857468, 0.1570301919296615, 0.20722476926926114, 0.32778066119462135, 0.325152368358793, 0.3296169362600574, 0.3384709108350751, 0.3146321603179716, 0.3357023923823863, 0.3745326546432881, 0.35315864737380886, 0.3432881854154193, 0.225910740441004, 0.22382216188485737, 0.2224475442555971, 0.22826407418044858, 0.17445159809387656, 0.21262754963305186, 0.25197846753404984, 0.2678302726994991, 0.24643117893320932, 0.23768411521683364, 0.20754721313074076, 0.2016488197929055, 0.2030490231396559, 0.22205209798723058, 0.19309186500766162, 0.20799997694435102, 0.21343316606230633, 0.18970259167738446, 0.22570558297848697, 0.21731982241761527, 0.1892559947950565, 0.1962198564127895, 0.20079074768976424, 0.2998012082150917, 0.24142434927665568, 0.3186455604532621, 0.19597228012234746, 0.17180896462597506, 0.18326560536734615, 0.6119839227356982, 0.6994444711675736, 0.19667298593146365, 0.16767886557043454, 0.14058039672583833, 0.17118877350108086, 0.687923773448434, 0.5461412749046606, 0.2001209082852381, 0.5088236478355945, 0.1999204332062442, 0.1920336501731651, 0.16480571166163172, 0.5502760225429727, 0.2044281634432371, 0.20449188983295497, 0.21180037617097824, 0.18805367219206948, 0.1821081645030983, 0.1778338827145235, 0.19038902729567508, 0.20031473054261295, 0.19420170729268071, 0.1861809711964434, 0.19785627631726244, 0.11183155547184764, 0.08360484057693485, 0.08869815361187139, 0.08522904012809518, 0.07989599066593578, 0.08541145459286548, 0.08661726559414851, 0.08126346923773453, 0.08297854211333267]}, "mutation_prompt": null}
{"id": "b7874b17-576d-45ee-985a-c95678a04a2c", "solution": "import numpy as np\n\nclass AdaptiveMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for enhanced diversity\n        self.inertia = 0.6  # Slightly higher inertia for improved global exploration\n        self.c1 = 1.7  # Increased cognitive component for enhanced local search\n        self.c2 = 1.3  # Decreased social component for fine-tuning collaboration\n        self.mutation_factor = 0.6  # Increased mutation factor for greater diversity\n        self.crossover_rate = 0.85  # Adjusted crossover rate for balanced exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Reduced clamping for focused exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        inertia_decay = 0.99  # Decaying inertia for dynamic balancing\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Decaying inertia\n            self.inertia *= inertia_decay\n\n            # Apply Local Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptiveMemeticPSO", "description": "An Adaptive Memetic Particle Swarm Optimization with Dynamic Parameter Tuning and Local Search to Improve Global Convergence and Solution Refinement.", "configspace": "", "generation": 71, "fitness": 0.34150418350929884, "feedback": "The algorithm AdaptiveMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.7768863407339792, 0.793244195038785, 0.8005951083181613, 0.8066725363322846, 0.784811801712055, 0.7834957957430938, 0.7810259061792062, 0.7933330333739389, 0.7851266748110661, 0.5570459699409538, 0.53048109535712, 0.5536419520557365, 0.5357618137154925, 0.5536671806067531, 0.5498312887103436, 0.5211697038896954, 0.5547403155483397, 0.5500135639538183, 0.13506626518756326, 0.1642601367903982, 0.13440250000163012, 0.16310454905164373, 0.16304853540849673, 0.1145581825597013, 0.14573406600472516, 0.14089908582770672, 0.13659512341191515, 0.30292658966556296, 0.12079827418625555, 0.10332833773196892, 0.13059102192584482, 0.11336786670946297, 0.11693295567510209, 0.12538179352011136, 0.10803408359088007, 0.12979882105516172, 0.9895931159463922, 0.9453883198354445, 0.9344131772517953, 0.9460053749050866, 0.9238982679429097, 0.932565514765735, 0.9413432715833017, 0.9519153074742983, 0.9325152297623263, 0.5415061389919049, 0.5653336516056702, 0.5475727606415539, 0.5722988327663077, 0.5603576888427537, 0.5760592391439185, 0.5628638658101094, 0.545516863844272, 0.566354646677742, 0.7179745233961576, 0.6869680412287964, 0.7473760234678454, 0.21222679504292696, 0.6078011323618238, 0.7973072104845162, 0.7755709598389544, 0.7212345369077997, 0.727904517744448, 0.19984286697833153, 0.11958457354046381, 0.24501464586308552, 0.24630476997669948, 0.22239423496218647, 0.19911819588687363, 0.2544342999725483, 0.33422509972382974, 0.2179521477872397, 0.228019309417968, 0.1242540325006376, 0.23294319851581002, 0.25959833009030364, 0.20381555701872212, 0.24970541547321, 0.23723593212821714, 0.33619957317693183, 0.2544188489606213, 0.0752706102923717, 0.055565826232656046, 0.06364209483400607, 0.08869100593924029, 0.09843843209244829, 0.059421742385882714, 0.06388158815986333, 0.05943686564559392, 0.1201925653799113, 0.17955164797673573, 0.19190593408772816, 0.17916014741280362, 0.21739454611544518, 0.23965649313107706, 0.20232549233992592, 0.20766548234157534, 0.18202885477393116, 0.22011077470564155, 0.14225004655842188, 0.1143947777133042, 0.042145092173274, 0.1280890190287548, 0.1205091284923363, 0.16088820522959846, 0.08775500177481665, 0.08872825517833394, 0.10402539321213466, 0.181192591050216, 0.19173996559606565, 0.1714901050627684, 0.17393664959228117, 0.1798236206170788, 0.23034186485383645, 0.16304717671765923, 0.279410782119733, 0.17927216039619676, 0.5223606279109422, 0.560797373984165, 0.5452789430706708, 0.5346069469076384, 0.5529977172604215, 0.5286381258568064, 0.569659160786187, 0.5328578476777941, 0.5409990995336642, 0.14275724088446007, 0.1511265517127497, 0.125121324808934, 0.13128464072233348, 0.1305453005343008, 0.1301949168173262, 0.13681736170655678, 0.09556051876544625, 0.12313965994516352, 0.22433043605605896, 0.22607001731901044, 0.18296109287844442, 0.22601665644472269, 0.20606477435476866, 0.15881840910212264, 0.17040515091021313, 0.2979767446285815, 0.2791026909738116, 0.4497093301160048, 0.36875509572745124, 0.48606701298008315, 0.5024196406390504, 0.44686790659825193, 0.37691347860170665, 0.510004012486406, 0.4433880818723578, 0.44819406118415306, 0.3241545499335252, 0.3423499909238157, 0.2438820211963817, 0.24275413726683548, 0.28593211363498905, 0.303698012582175, 0.34669419248117705, 0.30552618090207484, 0.2728927638540517, 0.2150964895654235, 0.238493800245422, 0.2285306911913375, 0.21682245644789522, 0.21534090030558728, 0.202038754483011, 0.22282065206729662, 0.21729258668788154, 0.20269192974279615, 0.19756392628169328, 0.5717818656990976, 0.20970616786970675, 0.5939640269712865, 0.6025262011863102, 0.19916212188912152, 0.20518998346694406, 0.20259439998649043, 0.23843643861467045, 0.1858701460674418, 0.18635726325339685, 0.1857913442882102, 0.8880858791422116, 0.19850051020101556, 0.16906688750830057, 0.1847288375759366, 0.1586011765025731, 0.8571718500086039, 0.7763313357271471, 0.20841375808688722, 0.2053725124339555, 0.20904566734722674, 0.6479523268956078, 0.6628665525489982, 0.76894005937335, 0.6827467788252192, 0.7738102870189476, 0.19091264863406732, 0.20470440496649844, 0.18638011425753265, 0.1950164553876259, 0.2034652549876117, 0.19539354468403158, 0.1963269637502465, 0.19984795449581583, 0.1864732649681008, 0.10169764192731368, 0.09455754392969518, 0.10586928565587062, 0.08713082711528586, 0.08760483571920163, 0.09203065982279646, 0.09460011672001711, 0.09732948184842005, 0.09048571532054683]}, "mutation_prompt": null}
{"id": "1c49e2aa-bdcb-4b49-89d1-8fb9aad073f1", "solution": "import numpy as np\n\nclass SynergisticMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.7  # Increased inertia for broader exploration\n        self.c1 = 2.0  # Enhanced cognitive component for local search\n        self.c2 = 1.5  # Balanced social component for collaborative learning\n        self.mutation_factor = 0.4  # Slightly lower mutation factor for stability\n        self.crossover_rate = 0.8  # Balanced crossover rate to maintain diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Enhanced clamping for widespread exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Differential Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = np.random.choice(list(set(range(self.pop_size)) - {i}), 3, replace=False)\n                    a, b, c = idxs\n\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "SynergisticMemeticPSO", "description": "A Synergistic Memetic Particle Swarm Optimization utilizing Adaptive Velocity and Differential Mutation for enhanced convergence and solution quality.", "configspace": "", "generation": 72, "fitness": 0.28481391599419215, "feedback": "The algorithm SynergisticMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6186810213685743, 0.5762054008304973, 0.5859620418542385, 0.5662958378353286, 0.6097014347812835, 0.5798773397568731, 0.630484171361311, 0.6178783794555283, 0.6264521937871922, 0.28001991281918603, 0.25631358650899005, 0.24017853151726032, 0.26928906162992594, 0.26268347281956317, 0.24454760133630293, 0.25202617669898386, 0.28324346999864636, 0.22989352905434002, 0.11968101029756217, 0.14788638823618439, 0.11386886795556184, 0.10514119309760239, 0.11760039917287379, 0.18343964367431576, 0.1284960554624951, 0.15734666655803686, 0.15197482044123556, 0.132255104896147, 0.11024649211372939, 0.11547572006988338, 0.12594752944142218, 0.12865562189882607, 0.11075330881435963, 0.11573437106352724, 0.11115615117783906, 0.09640455753550925, 0.9678388612823142, 0.9475142065789177, 0.9574188056206162, 0.9441557980740247, 0.9625300031425688, 0.9531043178102316, 0.9607930879003201, 0.9509368029530348, 0.9575132665824141, 0.36063460690799953, 0.3447118203895321, 0.3116274605564515, 0.33727760120278905, 0.3660075042941272, 0.31708339754056036, 0.3463472950477632, 0.32685912323476163, 0.33779948977347685, 0.614381098449521, 0.6205476279116595, 0.6092184260980642, 0.5939472065845987, 0.6272504598500641, 0.6805612992322043, 0.22406669892988884, 0.6229246395719771, 0.5659860745293918, 0.2180598635052352, 0.14482075182782828, 0.21537724040861994, 0.1704170432193699, 0.16206231029104312, 0.1585747950758163, 0.17783878795899166, 0.1788913893807157, 0.18372456640898294, 0.17799546538608024, 0.18402637583274373, 0.15279940291545535, 0.16561563401106472, 0.22720336128555363, 0.18474421035927246, 0.20013513724449183, 0.16450359980133367, 0.19524648911470854, 0.091426944531948, 0.0814824884261045, 0.08302029396460053, 0.02529925675304423, 0.07833069354732292, 0.07539503040507278, 0.03193164642961188, 0.10150083637068275, 0.08964753107056511, 0.2630631198254154, 0.1996028975612094, 0.2321062777341819, 0.24772443976975578, 0.1497232021393725, 0.19805231329906103, 0.20549767667815377, 0.2457037182109122, 0.25588945374015093, 0.030801059331565517, 0.04776539248021505, 0.04029681737202373, 0.06047345821734451, 0.0428377116596399, 0.02124847621468884, 0.06281274811362325, 0.021425943470403053, 0.03828647273953467, 0.16488949472303083, 0.16288911132731188, 0.1271749642797747, 0.1496458503392034, 0.15147424399846698, 0.16271794043257848, 0.1331672769529325, 0.07492945096881543, 0.08020476729178116, 0.48806781377688135, 0.4966253411882058, 0.5049840064309932, 0.5062025638058611, 0.5015365787913808, 0.4879132136263834, 0.5108332910947302, 0.5056103097387966, 0.498634975233894, 0.10588818686845547, 0.09813777606697671, 0.11522417572729315, 0.09088861460300868, 0.08512874110570501, 0.11014240805836284, 0.10596596863538543, 0.10869195280350763, 0.12839466598122073, 0.16389595109207222, 0.16938502435523972, 0.1666686995874025, 0.13328493745752745, 0.1768680222406922, 0.14332036224142353, 0.384362435992492, 0.22515048359434786, 0.16871269450212367, 0.32531518236051205, 0.33412397944397554, 0.3296299425455149, 0.33248888497326423, 0.323899510662666, 0.33071940384299026, 0.33917994484424063, 0.345925342532421, 0.3468050126351885, 0.2571914907970073, 0.25577351405382964, 0.24228441228304454, 0.2675177077979263, 0.25125308670845026, 0.2764196497010596, 0.2661710210165986, 0.2710003057783076, 0.24673521457619896, 0.19923180005694752, 0.20243340467564575, 0.20978286742866914, 0.21061290866986826, 0.2189816822013635, 0.20000242330868656, 0.214793772904588, 0.20040685778307177, 0.19009712716624882, 0.21460418899707512, 0.227094317613042, 0.208725959132675, 0.21399769227393683, 0.2953719200090078, 0.22113289388571955, 0.2084431694593083, 0.2584169433054806, 0.20328611366944993, 0.7547684411726541, 0.5614951418454803, 0.15218878708937078, 0.7716239960104686, 0.19851680393368776, 0.1680091163043944, 0.584652987946828, 0.7337920086436763, 0.7618164038186299, 0.6914791783216507, 0.2074410060648454, 0.6189498419516752, 0.6139676492668069, 0.38555853836329257, 0.15389970661009067, 0.5946362566086048, 0.1661969469746415, 0.20964757630293118, 0.18092672767611184, 0.18312022593131771, 0.17982528365196482, 0.18168410645145683, 0.17945955562864235, 0.17588372857208978, 0.19047783114040473, 0.21618271006019818, 0.17616383381575929, 0.0875020108626492, 0.09218892759550967, 0.0865365365903139, 0.09341483907084402, 0.0893025855834354, 0.09299528408686275, 0.08626075084111695, 0.0854994934292237, 0.09206272306570407]}, "mutation_prompt": null}
{"id": "de7bde41-facf-49b1-93d3-73b90f60a7a7", "solution": "import numpy as np\n\nclass AdaptiveMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.7  # Adjusted towards dynamic inertia\n        self.c1 = 1.4  # Slightly altered cognitive component for adaptive learning\n        self.c2 = 1.6  # Slightly altered social component for adaptive learning\n        self.mutation_factor = 0.6  # Enhanced mutation factor for diversity\n        self.crossover_rate = 0.7  # Reduced crossover rate for better local search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for controlled exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions with adaptive inertia\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Iterative Learning Process\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptiveMemeticPSO", "description": "An Adaptive Memetic Particle Swarm Optimization with Iterative Learning and Dynamic Component Control for enhanced convergence efficiency in diverse optimization landscapes.", "configspace": "", "generation": 73, "fitness": 0.2778893719954734, "feedback": "The algorithm AdaptiveMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6049675695472243, 0.5936093268456399, 0.5916505986934597, 0.6056275405109741, 0.6205581704302943, 0.616802395631691, 0.6190881365225709, 0.6018527146226524, 0.6315969721193113, 0.2876416282572162, 0.2752417620207821, 0.27853959399628125, 0.2776167200015307, 0.304829711509626, 0.2804411202337739, 0.2701553667813802, 0.3024563742930537, 0.299381798920183, 0.11419467160266117, 0.11765936276709621, 0.13684013301020148, 0.1337945994047559, 0.1346707183640925, 0.2547119825503986, 0.20639693932872782, 0.164782729582171, 0.15395841272148625, 0.12361090336444847, 0.10864586841558976, 0.12163845666027495, 0.11985477239024056, 0.09701346161828384, 0.15389597855834358, 0.11276531127583134, 0.10953201878565055, 0.10131249815706977, 0.9691463504772462, 0.9553227648729926, 0.9675123581998248, 0.9644142778417413, 0.9505310775907378, 0.9538935175975065, 0.963828484414616, 0.9726170085777629, 0.9709604191687682, 0.3740371401292705, 0.3561435019613677, 0.3480039727429678, 0.35949739012108717, 0.35152554215357, 0.39194765049581903, 0.3492829516075764, 0.36736591717386224, 0.3558189437101209, 0.5310808621583545, 0.444020346753187, 0.5924260375719912, 0.6047785025605334, 0.5571546924649722, 0.6504723885973382, 0.5959780553464307, 0.5361222208687313, 0.5933856717893815, 0.19696910831069003, 0.15173519030128424, 0.1664793008060036, 0.10921497873552743, 0.15967540856223672, 0.11569280827801998, 0.16724219808332852, 0.1652363685827659, 0.12173063218452318, 0.16491522294653083, 0.19090770527169865, 0.1730421646601239, 0.19905715513266498, 0.16605045911073757, 0.16504345649532592, 0.18619948775278594, 0.17106930751031946, 0.20476295037992276, 0.017834666326098203, 0.010071929841882765, 0.036197989172691236, 0.028353628684381516, 0.022700909684149284, 0.003323888767225447, 0.014168864884970933, 0.013886146349851303, 0.027636229020521985, 0.1381256759247621, 0.1406642627965219, 0.13989339771737908, 0.13962183052372457, 0.10075124286741688, 0.051060394168189305, 0.12012188090125586, 0.12725782583304712, 0.17131094165547345, 0.014292870220442788, 0.06392185541524831, 0.09086071333467083, 0.004019466162203167, 0.04417550190238473, 0.04225194173465374, 0.05699189226485346, 0.06760585433144173, 0.04140292537325352, 0.13773847270491912, 0.12066868061665659, 0.10582399563898359, 0.1262213781616398, 0.13578298290646384, 0.19490099587570953, 0.10357078165099742, 0.0711661042186037, 0.07771274187311572, 0.44072638421248, 0.44628718375416954, 0.4632842111264719, 0.44883266326277915, 0.44772964144344274, 0.4551925237322698, 0.4702285214333639, 0.45673359533470936, 0.44766216744146925, 0.11913025020607781, 0.12302836173531562, 0.11652160983460547, 0.13428421322958695, 0.09544428855974552, 0.13168200291146348, 0.14575109348784843, 0.13876411170716596, 0.10513822814015839, 0.21763099929214902, 0.1652406610964794, 0.19168445778248255, 0.16072305124376507, 0.2782322307228553, 0.1562230290137122, 0.1898644520093694, 0.13433314529130524, 0.1678233517346891, 0.329159113914123, 0.3728735350773448, 0.37202625054394745, 0.33953112661891316, 0.3481451407274748, 0.36720111737387373, 0.3457527941514772, 0.36918857371313574, 0.3341894600706675, 0.25989132903222567, 0.27104296403094086, 0.26223732749345796, 0.2529925332327332, 0.2405199322301852, 0.273727104291939, 0.2807735401350119, 0.24643788241115827, 0.25415061119407545, 0.2114275527680899, 0.21586964385606922, 0.19967230302719774, 0.20792322281981046, 0.20333620321092827, 0.19323292672089076, 0.265786436520282, 0.23091374825239586, 0.21565437586099856, 0.20067721633308888, 0.20269980290440348, 0.22030894457222228, 0.41385228140578134, 0.3659588932924136, 0.4011740956431864, 0.19526589660434712, 0.33019685792180264, 0.2058417706598712, 0.7250222835647359, 0.18360597737507756, 0.6570249186634736, 0.758819039965871, 0.19656463810403213, 0.16805984751169822, 0.16981897149702052, 0.16579510635960737, 0.7429899541934825, 0.5904253810680686, 0.20790473853592317, 0.6517661607448426, 0.20441992790896413, 0.4858475155358817, 0.16109356081195803, 0.6255940372810244, 0.10411195301968634, 0.5413087734756471, 0.19621861148739173, 0.1909245839512107, 0.19453735375059156, 0.1788253779795076, 0.19603431263793558, 0.18697156010977878, 0.18402910238937964, 0.18813111512831782, 0.18555574648567152, 0.08134367075965732, 0.09337260224391397, 0.11231349393428824, 0.09117238192150778, 0.08461347051920876, 0.08321754598356579, 0.08749342541731198, 0.08737884634886928, 0.08227029694775534]}, "mutation_prompt": null}
{"id": "7b4104cf-23e0-4cfa-a213-185c5209e4f2", "solution": "import numpy as np\n\nclass EnhancedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 45  # Adjusted population for better convergence\n        self.inertia_max = 0.9  # Dynamic inertia to balance exploration and exploitation\n        self.inertia_min = 0.4\n        self.c1 = 2.0  # Stronger cognitive component for intensified local search\n        self.c2 = 1.5  # Maintained social component for global collaboration\n        self.mutation_factor = 0.6  # Increased mutation factor for enhanced diversity\n        self.crossover_rate = 0.8  # Balanced crossover rate for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for more precise exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            inertia_weight = self.inertia_max - ((self.inertia_max - self.inertia_min) * eval_count / self.budget)\n\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Targeted Mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedMemeticPSO", "description": "An Enhanced Memetic PSO with Adaptive Inertia and Targeted Mutation for Improved Precision and Convergence.", "configspace": "", "generation": 74, "fitness": 0.2668224262194337, "feedback": "The algorithm EnhancedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5752971560357611, 0.5218733267317164, 0.5838110171810178, 0.5724659699406021, 0.5421094533517085, 0.5668186480716714, 0.552471902781001, 0.5628868230739345, 0.565408990688912, 0.24907282314330637, 0.23380946552064563, 0.2387222981358249, 0.23528710048223278, 0.22011623186298324, 0.26960661848393996, 0.242643217471449, 0.22845398861310173, 0.27281278067384973, 0.12129944666933079, 0.14558629605026507, 0.181239513326101, 0.13313244239057276, 0.12471718922178754, 0.1500479412451492, 0.10537359211598019, 0.11438209461716164, 0.11767015172618323, 0.10815251219915445, 0.09986439713067663, 0.10075863393995133, 0.10733979231100677, 0.10254992843606725, 0.10384204314481926, 0.1081425190315023, 0.1136705610837504, 0.12614350529211238, 0.9702430367184689, 0.965813363879294, 0.9614399958376124, 0.9617015836460782, 0.961442742293912, 0.9694050109821911, 0.9607844140497889, 0.9650938849541997, 0.9663888244245826, 0.31509482723096105, 0.31300065861520765, 0.30505964547825826, 0.3154587119836869, 0.3387962245704691, 0.3237649159467595, 0.3265075233491319, 0.3012406069255684, 0.3259855694873721, 0.46279491617716717, 0.5461500190814097, 0.5406506547372283, 0.6590194869248998, 0.5031750172093301, 0.573437995728195, 0.44708758152397554, 0.5588278517234648, 0.5150589616481708, 0.2031159145651954, 0.1557574824204383, 0.16710677697949872, 0.15393974931905108, 0.1653654418115328, 0.1674946720603646, 0.18988792419297473, 0.1719345879521268, 0.1596746710453283, 0.16575011121680927, 0.16258710007538435, 0.17447112072457172, 0.18171487096916716, 0.15309005203681314, 0.16467027402837042, 0.1772735530010079, 0.16512638822911563, 0.1682331541777905, 0.06681059765753217, 0.036800671673550056, 0.04436710255185117, 0.09276737580156136, 0.02313732199627916, 0.04911850796302153, 0.06458986787464094, 0.07920193969421885, 0.08552188223836654, 0.17033132949192153, 0.21433508131875467, 0.18189159729477733, 0.1906377674533839, 0.14520405224889432, 0.09751131031691329, 0.20711596305608193, 0.199011270342366, 0.20926255200109467, 0.03253360173554687, 0.021489282010380695, 0.0006558039622470702, 0.02717630119800729, 0.016627322076517514, 0.02320765668574387, 0.028812602111006114, 0.010751986831003868, 0.027987216434100848, 0.09479671301763593, 0.10360627869107064, 0.11857245023870833, 0.11428097858912845, 0.11511581862814435, 0.1411817679563444, 0.1082947259726943, 0.07244761022152946, 0.12749140483726407, 0.42208405679076644, 0.44613089532077455, 0.4368252780338845, 0.44187345200685646, 0.42264745963827477, 0.4555823412846115, 0.4388220508135039, 0.4549596995875619, 0.431061226209995, 0.11721255711947065, 0.11027635603419095, 0.1365208930174716, 0.11662045695344603, 0.12366203275918919, 0.10933600670015653, 0.08936177978243853, 0.10651118948664129, 0.10758668483084366, 0.21066004834646013, 0.14402549104533569, 0.15011219165644474, 0.2326985674576082, 0.19161460228773075, 0.17919361273436296, 0.3442518316534998, 0.13627568675606672, 0.1413914010432904, 0.3009281900083076, 0.3182174462399522, 0.32963778804688615, 0.3162010912175175, 0.31060847945502357, 0.3383029904947715, 0.33270095035582803, 0.3425498133831537, 0.33858442810069067, 0.2353793530534536, 0.22639194758897452, 0.23528264332891957, 0.24270307954198034, 0.20826359858686305, 0.22358696298634528, 0.23919222287167552, 0.24992037340215023, 0.24123673472815899, 0.2005510092040821, 0.18803652463612164, 0.22330412416038947, 0.19359863674907007, 0.20413311053621697, 0.19850319415606066, 0.21495574146318586, 0.19252435823081004, 0.2060754787264606, 0.19674485332690106, 0.2408304786875285, 0.20202564022427683, 0.20387695111034354, 0.20540068512694132, 0.18747973368214987, 0.19046752413379653, 0.2066877426658652, 0.2085931621010051, 0.18271571295191957, 0.182683508286692, 0.5807641525916365, 0.7039477585557183, 0.19798718020332362, 0.7004623597030406, 0.656032987416389, 0.6059537875330308, 0.7310225847556506, 0.6807220397285408, 0.3906262861427189, 0.20156176217821598, 0.5773910532965738, 0.19846360920187667, 0.144721553628525, 0.1508147327955901, 0.1965098555165763, 0.5738296560785764, 0.18604454526636027, 0.18060031024598333, 0.1978243068215565, 0.17701965597586766, 0.22325817558397343, 0.17185960767142028, 0.17937634491167231, 0.19072985901767325, 0.1921267209494425, 0.07645260205001081, 0.07896451421471862, 0.09007311489227465, 0.07851580464689034, 0.08530860284481312, 0.08226497962396684, 0.08855330692717112, 0.08035261116472425, 0.08648957408139235]}, "mutation_prompt": null}
{"id": "89fa189b-57c9-4a22-b5db-5b56436ca337", "solution": "import numpy as np\n\nclass MemeticPSO_Hybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for better diversity\n        self.inertia = 0.9  # Dynamic inertia for better exploration-exploitation trade-off\n        self.c1 = 2.0  # Increased cognitive component for improved local search\n        self.c2 = 2.0  # Increased social component for better global guidance\n        self.mutation_factor = 0.4  # Lower mutation factor for enhanced stability\n        self.crossover_rate = 0.85  # Adjusted crossover rate for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Reduced clamping to refine exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Adaptive Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n            # Update inertia dynamically\n            self.inertia = 0.9 - 0.5 * (eval_count / self.budget)\n\n        return global_best", "name": "MemeticPSO_Hybrid", "description": "A Cooperative Memetic Particle Swarm Optimization with Dynamic Inertia and Adaptive Hybrid Search for enhanced exploration and exploitation balance.", "configspace": "", "generation": 75, "fitness": 0.26382554549748627, "feedback": "The algorithm MemeticPSO_Hybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5125223005365422, 0.483863566332683, 0.540756831283262, 0.5046827531069729, 0.5299124690433525, 0.5309499160309239, 0.5460335873126687, 0.5497272254791246, 0.5081845257262738, 0.19211088748054195, 0.2065420951403375, 0.1960202582497632, 0.1898084159108271, 0.2187123769901952, 0.21903828178836793, 0.19651021796256873, 0.22747599487881076, 0.20288495256316008, 0.1101328725871048, 0.10941497506781284, 0.1278717541881097, 0.10319928309074855, 0.1057259647807014, 0.12160540908149009, 0.12838277889257843, 0.12174429344200466, 0.11788784468761637, 0.09359667409558536, 0.10628533686982133, 0.10352407955012533, 0.10531764270946364, 0.10953738459081264, 0.09168817122396544, 0.11563922108248315, 0.08558927749079337, 0.11407187062693536, 0.9581325754102442, 0.9505147095020537, 0.9490729445784016, 0.9421795642515234, 0.9152262843925599, 0.9406960297962144, 0.9495951345477696, 0.9466874779715734, 0.9428644208459315, 0.31165265636011685, 0.28589652327023274, 0.28357553826708004, 0.28839338435285367, 0.29387712533430355, 0.2876010430597361, 0.26597700042078354, 0.28064394330591147, 0.2836192719586348, 0.6623770844064117, 0.5928343377481569, 0.6810652712828914, 0.42583754961901477, 0.5115711849728006, 0.5705017831373222, 0.5519926056462983, 0.578844720457218, 0.4928743633891397, 0.17141035379278202, 0.15047182063718334, 0.15595363394128559, 0.14553848490670884, 0.11908881814326122, 0.1013129086020712, 0.17488699406180863, 0.21718426213392505, 0.18563121144801287, 0.16964332656084757, 0.15360661575857526, 0.13547402892664717, 0.16337820575763617, 0.18030477666801525, 0.17932685205797694, 0.19946417587501597, 0.16350979343677607, 0.1753124383371305, 0.08053935898974307, 0.11756386635456906, 0.11705946452573612, 0.09971759528968582, 0.08494643539999758, 0.09341445598399678, 0.1409646308780642, 0.11433778434019715, 0.10486912292225714, 0.2672340918611458, 0.1991156901291533, 0.294426249459547, 0.20251943233814595, 0.16058336656862304, 0.21626339583787269, 0.26722417793040487, 0.2899941389483488, 0.255747808981413, 0.025805127304978526, 0.02876166651681067, 0.04872425421473203, 0.04419301312468216, 0.034440968862434196, 0.04382948816091736, 0.029169168194628226, 0.032614528614855254, 0.03883848409196855, 0.14949529900761505, 0.13509360402299408, 0.13761262460965518, 0.13200659000172343, 0.15337307819158597, 0.160774618167968, 0.1271338118512142, 0.1432206028098162, 0.10302952271612376, 0.46422179076852477, 0.4341503512310444, 0.4567353707077507, 0.4578089237171472, 0.4521000384170828, 0.48068425734880216, 0.4835299554611161, 0.4525049731746188, 0.4503283907462038, 0.0907032547824621, 0.10173901393911078, 0.11920878126230605, 0.10036341876599308, 0.09698026062501908, 0.1095138608587869, 0.09413675506643504, 0.09998000514699545, 0.11283582826665572, 0.24712094916547134, 0.12542964696446923, 0.21798212000841766, 0.20781308646792118, 0.17340194389720565, 0.17577494167276841, 0.2045648055256405, 0.17197799312524353, 0.19612333784535108, 0.29960541461531, 0.30349482071748957, 0.3131130767338227, 0.3123477035631229, 0.3128275032562371, 0.28843425740127937, 0.2973449156304637, 0.2956399836222462, 0.3109469668540047, 0.2479799039844779, 0.22907350661419168, 0.25520648715155403, 0.24541187434335088, 0.2540073149431583, 0.23322807442362659, 0.25623956067484244, 0.2616230719918653, 0.2033610747372524, 0.22582835724972006, 0.22628033492595168, 0.18442016454007792, 0.21105092689881355, 0.20251005707909575, 0.1998130466267133, 0.22914676123780586, 0.2021271311515186, 0.2386973632681173, 0.19777404804388343, 0.18448934238129633, 0.23283133536136302, 0.22361934812691353, 0.22416865931633823, 0.1885955501495863, 0.20249584588165515, 0.20173035403331518, 0.18396052918689387, 0.6591624285601192, 0.18584732507619706, 0.1836233172498113, 0.7301868346653727, 0.19873741962229907, 0.19532184350701443, 0.6982925952378668, 0.35142857399448335, 0.7353903992543629, 0.6899046526200385, 0.2066744676797141, 0.19824539238139127, 0.20544829424124855, 0.16907300034777928, 0.5525962186140696, 0.1107347130712284, 0.16615065351026292, 0.5970721711327593, 0.1800497520071347, 0.1837211699613741, 0.19256035934285476, 0.18209033184216628, 0.1871811385877733, 0.18741295858859164, 0.18721446032865519, 0.18596468465935512, 0.18582369898439355, 0.09124670752134822, 0.07209771998625691, 0.07341065924993095, 0.08428536057367253, 0.07975599182224302, 0.08601113253535131, 0.0886166155268675, 0.08346929076563214, 0.07718453632254352]}, "mutation_prompt": null}
{"id": "d594de5a-5ca5-4d3d-ae47-77eb0d55f203", "solution": "import numpy as np\n\nclass AdaptiveMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.7  # Increased inertia for broader exploration\n        self.c1 = 2.0  # Enhanced cognitive component for stronger local search\n        self.c2 = 1.5  # Balanced social component for collaborative learning\n        self.mutation_factor = 0.8  # Increased mutation factor for intensified exploration\n        self.crossover_rate = 0.7  # Moderate crossover rate to balance diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 4.0  # Enhanced clamping for widespread exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            inertia_weight = max(0.4, self.inertia - 0.1 * (eval_count / self.budget))\n            velocities = (inertia_weight * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptiveMemeticPSO", "description": "An Adaptive Memetic Particle Swarm Optimization with Improved Mutation Dynamics and Self-Adjusting Parameters for Enhanced Convergence and Exploration.", "configspace": "", "generation": 76, "fitness": 0.2577020675454167, "feedback": "The algorithm AdaptiveMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.622252235764053, 0.6385780617613969, 0.614274864429361, 0.635448603471533, 0.6272566603494293, 0.6536447510411731, 0.6510390810979766, 0.6334903886079635, 0.6568191693888332, 0.26548400213089596, 0.2829403470847248, 0.29111862794583465, 0.24846385597820808, 0.28732733028826873, 0.3334855061872404, 0.2870641001634884, 0.27484999746731587, 0.28539798847534226, 0.14687081513719347, 0.12168076635325564, 0.11654793229301208, 0.18685273377739497, 0.12242019418351135, 0.12691041018262605, 0.11982780869491216, 0.13510119545439758, 0.1257849054459288, 0.12136361287097475, 0.10514930299698211, 0.10459037413200645, 0.11550378622838675, 0.12425570803711794, 0.1180394146669147, 0.11984781804783962, 0.1340601293956617, 0.1417279704817498, 0.9765305748926992, 0.9578949704980262, 0.9750052086190096, 0.964821620128034, 0.9760436749068315, 0.9646586645377244, 0.9726402629030172, 0.977618867258625, 0.9736396815958629, 0.3298901482988452, 0.30740594521934805, 0.30326087659361844, 0.30166265138713577, 0.34168749621729355, 0.35081387201648506, 0.3751121886492139, 0.3074685192909785, 0.334750471757569, 0.5018130459558862, 0.6378177719488065, 0.4217666102641483, 0.5988111981100988, 0.30689405335265896, 0.5472822940762969, 0.5118109065795071, 0.3782355450318181, 0.40823745853032056, 0.15284240695874318, 0.13941619995318943, 0.2697974665849445, 0.2064160291534759, 0.1631427101405054, 0.17930895649395828, 0.15644880649158255, 0.16593021219178905, 0.17301203163580048, 0.16279199567364544, 0.15361289681802426, 0.16692817581027908, 0.16051568038474617, 0.14750779684230897, 0.16749061990368974, 0.17838030021543438, 0.09184440746179101, 0.18995136478966734, 0.03961379427120759, 0.009278273063440756, 0.014662017620725054, 0.029125702911926954, 9.999999999998899e-05, 0.003257862693796465, 0.012460954753486853, 0.0029123575373747324, 0.06012019216137232, 0.10245097878864362, 0.08027072179132066, 0.10534569903919833, 0.08935472069716854, 0.09988705779133122, 0.04452005944202497, 0.09528123686088108, 0.12653640914151165, 0.12160400558632822, 0.019385195132644584, 0.021435743660307205, 0.040859372426869545, 0.1597371685623229, 0.05512679993574188, 0.04681432190093893, 0.052216839560274675, 0.08276459147054571, 0.04347061158093435, 0.09583743610394557, 0.11715307395984398, 0.0985026034935712, 0.14398880706077288, 0.11282050142753719, 0.12415967730476618, 0.07492124710943548, 0.09913510101552059, 0.07237308705661105, 0.4287728729838458, 0.4409073136082867, 0.45575334351743135, 0.48039566240141274, 0.48119443828231034, 0.46150076202336854, 0.452306334021509, 0.4269737146414232, 0.44156043102569387, 0.1062108698560309, 0.10920284295506821, 0.11890479947776789, 0.12731678038827743, 0.08700408619402, 0.09938177277727123, 0.11792736592052677, 0.10715014964888359, 0.11533099288062731, 0.1509970373111631, 0.18242231097550965, 0.17997566039116442, 0.21853739201718725, 0.13006645725374588, 0.19244128671677185, 0.201316029219761, 0.218374911455127, 0.25982174508547906, 0.3070421335233152, 0.30922694424786845, 0.3279085749597689, 0.30780236791053883, 0.2910384268621595, 0.26379988685874467, 0.3393906000430009, 0.3385701274257612, 0.3446588365050056, 0.24370423130054042, 0.24679549774530374, 0.21450217574955133, 0.1721496594451628, 0.2104371080794033, 0.242121415828344, 0.26267890580660436, 0.2798727574583909, 0.2406535950909059, 0.24738196051620398, 0.19494576140290643, 0.19453183557435594, 0.24358326263803298, 0.20508223647076074, 0.20769451801809224, 0.19919442096073403, 0.19660163937631359, 0.24875198292415224, 0.2041308287932797, 0.32844141077901023, 0.20941112516155003, 0.20512377790715186, 0.19619210661397013, 0.1934643860298354, 0.22771091114938247, 0.20668758591605596, 0.20447283096408153, 0.6907473483552782, 0.18034850433822125, 0.16566962104081717, 0.7348369197274811, 0.19662902011960337, 0.16599497541807728, 0.14118967429416485, 0.1712452881462776, 0.7757334676750914, 0.5709230037778421, 0.20791689321637719, 0.11241514705615041, 0.5942419797586989, 0.16532984997244926, 0.1572846392207875, 0.20973768198382625, 0.10460760741334829, 0.15266112876779003, 0.18157193918914027, 0.16800575443875754, 0.18161572807387782, 0.17364917923523082, 0.1889043396102309, 0.21078787794633858, 0.1904739607780188, 0.1864330985110697, 0.19357102308363416, 0.07238966020004667, 0.08592180068428112, 0.08803948474277656, 0.07529548803867891, 0.0804293707280953, 0.08549944479072003, 0.07841428703294495, 0.08968594915091455, 0.0860749551764004]}, "mutation_prompt": null}
{"id": "bc3ede12-e692-466c-b1e2-6d98dd904d5e", "solution": "import numpy as np\n\nclass QuantumMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.7  # Dynamic inertia for adaptive exploration\n        self.c1 = 1.7  # Enhanced cognitive component for improved local search\n        self.c2 = 1.3  # Reduced social component for diversity control\n        self.quantum_factor = 0.5  # Quantum-inspired position update factor\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for refined control\n        self.eval_count = 0\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                self.eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if self.eval_count >= self.budget:\n                    break\n\n            if self.eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            # Quantum-inspired update\n            quantum_positions = particles + self.quantum_factor * np.random.randn(self.pop_size, self.dim)\n            quantum_positions = np.clip(quantum_positions, self.lower_bound, self.upper_bound)\n\n            particles = np.where(np.random.rand(self.pop_size, self.dim) < 0.5, quantum_positions, particles + velocities)\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Adaptive parameter adjustment\n            self.inertia = 0.9 - (self.eval_count / self.budget) * 0.4\n\n        return global_best", "name": "QuantumMemeticPSO", "description": "Adaptive Quantum-Inspired Memetic PSO with Dynamic Parameters for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 77, "fitness": 0.1724293020185084, "feedback": "The algorithm QuantumMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.2903678187589519, 0.27378080689909035, 0.3090059318754297, 0.2829368313835531, 0.2632319286170186, 0.29042854926520256, 0.273089374060966, 0.2877955091612695, 0.2717292626349792, 0.005907034136292122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013410247253151653, 9.999999999998899e-05, 9.999999999998899e-05, 0.07582324161682263, 0.07858388045316356, 0.08490854142358495, 0.09223239212481182, 0.09691915104969062, 0.08327441463573249, 0.09860776470079125, 0.07824680278629437, 0.10714068022483225, 0.06125667907335175, 0.06989556198754343, 0.08999974146016798, 0.065228379075289, 0.07485182033136373, 0.0726589072390934, 0.0850093485865655, 0.06552719429875775, 0.08928464878458175, 0.9680354733430574, 0.9538165918144844, 0.9619365097702515, 0.9526610446835756, 0.9537721218260403, 0.9556264182565231, 0.9705531948970814, 0.9526557088162237, 0.9589507612271477, 0.1797174843720355, 0.1668998464664364, 0.17103712360523682, 0.1638271251967861, 0.19696114641377793, 0.18735117976099258, 0.1812261488157535, 0.1707447970681324, 0.15349072965215327, 0.20429098584373284, 0.2154171407421166, 0.22579181917631852, 0.22322437249273364, 0.1968209244729343, 0.22302729924453235, 0.19534323673924925, 0.21832838940408894, 0.19571159847256325, 0.09093890061588905, 0.09615986664282916, 0.07999798082524212, 0.08411069518059866, 0.09036894793967354, 0.0959316278662663, 0.07945597619218481, 0.09665281703262774, 0.08988023013429614, 0.10066656148113706, 0.10563980028643638, 0.07620427623987402, 0.10967916643380937, 0.08293793971835439, 0.07561476160819436, 0.09975869018695249, 0.08513831249470372, 0.07759825573397716, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03416622499345212, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07000216431436257, 0.07709638029252219, 0.12586044713098454, 0.09134292722070037, 0.05012198955436742, 0.05115437174010351, 0.08841816124734336, 0.09611415932620071, 0.08980922915918454, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03560331144791562, 0.03613029265834633, 0.03584554200310919, 0.021589012446518563, 0.029878683177836485, 0.06816661329869789, 0.03072856601530638, 0.025946014545148, 0.031311532518640495, 0.2821527550552171, 0.29209183511862125, 0.30383811670787797, 0.2827409884456117, 0.2928272178028989, 0.29718448487267357, 0.29143984745290674, 0.273806652095976, 0.28293799098527683, 0.08595375753980572, 0.09215646969891844, 0.0823856413997488, 0.07938973751228873, 0.08299503094046945, 0.08607850985566678, 0.08720869339233484, 0.07021637623282728, 0.10006975424024045, 0.1378421074080658, 0.15101915917156072, 0.14862224410018443, 0.14495490073656625, 0.15953562251163933, 0.1457337204554855, 0.15527312633066614, 0.1320468877305786, 0.13499802776011205, 0.21650636715744576, 0.21968898264718417, 0.2207142877988566, 0.22406290967300035, 0.21345729704872518, 0.21976610266512597, 0.23635011826154873, 0.2256810776425502, 0.22044451936928722, 0.1486163025853271, 0.15515043216422653, 0.17793276621168497, 0.16420050023872557, 0.16556640883958007, 0.15351330831877052, 0.162389486712598, 0.18141550808348128, 0.18157614132477629, 0.21650077041207605, 0.20233641446061157, 0.20713317917069596, 0.20087474461902122, 0.20910531452522851, 0.19241257450997928, 0.19595406027590112, 0.20803760969345797, 0.2007942018063381, 0.17787032020476234, 0.18034485324965976, 0.18534297353625184, 0.1846638017696861, 0.17818395831038647, 0.17473264739361416, 0.17110288253702943, 0.17376245557148962, 0.17461492730828576, 0.35583625045134504, 0.18347547311695167, 0.14916655551141467, 0.35143577463644626, 0.18605858736527914, 0.15507480430861575, 0.23255235185991652, 0.15770181254555193, 0.3532880487011901, 0.34280077689928845, 0.18468071995530633, 0.3385858750028762, 0.32500076686697643, 0.3107890166109255, 0.18977509181993168, 0.17617416959955512, 0.10249054481122999, 0.31972045022309503, 0.18956735192636975, 0.17076952063635276, 0.1862910081586382, 0.19336397641097514, 0.21144435225444624, 0.18425011479015463, 0.1868674554999844, 0.18460918029537388, 0.17021819079424527, 0.0812138420061489, 0.07852548745327681, 0.07673058173389258, 0.0762044055539618, 0.0967557948679878, 0.07729172346724067, 0.09863787860625128, 0.06939651235661581, 0.07698210360016422]}, "mutation_prompt": null}
{"id": "768a42a8-24a4-4562-ada7-8b1adadeebac", "solution": "import numpy as np\n\nclass QuantumMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.7  # Adjusted inertia for better exploration\n        self.c1 = 1.6  # Tweaked cognitive component for local search\n        self.c2 = 1.4  # Altered social component for improved communication\n        self.mutation_factor = 0.7  # Higher mutation factor for increased diversity\n        self.crossover_rate = 0.85  # Adjusted crossover rate to balance diversity\n        self.tunneling_prob = 0.05  # Probability of quantum tunneling\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # More controlled clamping for precise search\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n                if np.random.rand() < self.tunneling_prob:\n                    quantum_jump = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    q_fitness = func(quantum_jump)\n                    eval_count += 1\n\n                    if q_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = q_fitness\n                        personal_best[i] = quantum_jump.copy()\n\n                    if q_fitness < global_best_fitness:\n                        global_best_fitness = q_fitness\n                        global_best = quantum_jump.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "QuantumMemeticPSO", "description": "A Quantum-Inspired Memetic Particle Swarm Optimization with Adaptive Learning and Quantum Tunneling for enhanced global exploration and local exploitation.", "configspace": "", "generation": 78, "fitness": 0.2915311031061364, "feedback": "The algorithm QuantumMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6329153434827108, 0.614906815221115, 0.6431670765268598, 0.6587938608289011, 0.6474874723354523, 0.6568239106313489, 0.6119302841957839, 0.6450393756947035, 0.6299778294135068, 0.24180362628177177, 0.29376760201042573, 0.24067331063127817, 0.2435281816326963, 0.30050121088073367, 0.25740753848987064, 0.23748902586612353, 0.2367399296023911, 0.2998565959977253, 0.12506978323165985, 0.12683850548188713, 0.21416192243957122, 0.14530874871639954, 0.16032732317043774, 0.13490683561454664, 0.1179763083925045, 0.12157640116014623, 0.17212807486999004, 0.10847919921178673, 0.1206401613153314, 0.15303201473590966, 0.11740528544679396, 0.11670817818347023, 0.10391876791468546, 0.11227549967958039, 0.09965392409321594, 0.13530246606604746, 0.9663769586379362, 0.9454651521518392, 0.9553058442168119, 0.9603826174717917, 0.9472849824486095, 0.9586179243333649, 0.9684212334780006, 0.9512328036609408, 0.9519808967459831, 0.3577478040103097, 0.3539164248257177, 0.3664028436090775, 0.4087851233157712, 0.30746406155252637, 0.33864132348345055, 0.379211218449522, 0.36158328507075743, 0.3381025377137131, 0.655670531299793, 0.5997285220273236, 0.562548654667334, 0.44055216614368975, 0.5594824951726518, 0.6282674949376942, 0.539881698123269, 0.6556466730670668, 0.6763578377572719, 0.1886686280537927, 0.2477889894822517, 0.21428897296195548, 0.11910452226338442, 0.17277362282921427, 0.19576855163418783, 0.18226583168857546, 0.19379462196041009, 0.2086647022217737, 0.20307391157571997, 0.19131231548861727, 0.3305930286726808, 0.20670374795474655, 0.26356618167135615, 0.18834658429435813, 0.20185410521247826, 0.1791496851570764, 0.24082105575709134, 0.036687500865871914, 0.05617537014142071, 0.05028756470029516, 0.06096435839049541, 0.03233194238476367, 0.005753022207784841, 0.05773385697855993, 0.06314733383538373, 0.06653036868143958, 0.19244116507012188, 0.17353802556145348, 0.1839948134570073, 0.1617359209722119, 0.15945528887358518, 0.13768842015033023, 0.19163643345657588, 0.20382671544570863, 0.20528517780062894, 0.0363156945299723, 0.020662309755050234, 0.009909152690078415, 0.036097717692037845, 0.06903581618580534, 0.04510867541749719, 0.00015436466553908623, 0.0024456436409046045, 0.005507470732890929, 0.11829286749802015, 0.14677295101776056, 0.13617590737974006, 0.17498020139083525, 0.12625329260323848, 0.1372647937910949, 0.1287470918881234, 0.10935464328739453, 0.07575091893432107, 0.48844572868330793, 0.4842785044032786, 0.47474786364583677, 0.49682226200542845, 0.501469222537342, 0.4568458156419931, 0.4982408228106695, 0.49118091051190504, 0.5001200542093692, 0.11664546337225967, 0.10570838946784422, 0.13883596315834223, 0.10461530969205468, 0.1174360252650598, 0.1013604153150478, 0.16197784352250832, 0.10592844754175168, 0.16918126969406877, 0.2073252592406759, 0.26146421875502923, 0.16192377207758513, 0.18764299400199647, 0.34093021411096724, 0.19815890271855563, 0.3373363259639426, 0.19338140643068924, 0.1957161017685185, 0.32448051371871056, 0.3222614627219166, 0.35291302386450163, 0.3367347381655814, 0.3321603911507901, 0.36635747568599697, 0.3452503428617434, 0.35171378126860153, 0.3462041263867607, 0.25285116979267896, 0.20946386407588102, 0.27436500977555023, 0.2756196326502993, 0.24678175174009576, 0.25319470059805016, 0.26475967258533406, 0.2698423420553906, 0.26722927739617464, 0.1983484394745454, 0.1986302952877017, 0.20621998964687838, 0.2126635036110449, 0.2323383980258965, 0.23954809440055858, 0.209625799707158, 0.23137090453578113, 0.20544621497510485, 0.2014276414901489, 0.22921608021000006, 0.2249169569163345, 0.36413927030682813, 0.21912467540448288, 0.2722546771837244, 0.19547008919386555, 0.28392400089157777, 0.19687852390653493, 0.705013407051771, 0.1674859867898807, 0.36625930878761304, 0.8004374404705619, 0.1981238465240569, 0.6781815896334442, 0.7763653335907224, 0.4531464609013284, 0.769393360874386, 0.5823562050326123, 0.2103769548912715, 0.5607147348607144, 0.2066849140119259, 0.16780764280012994, 0.27048815087803146, 0.5987764816874735, 0.48108262002758095, 0.5844976277397937, 0.1910930704664503, 0.17474937684085234, 0.19107288256377464, 0.23803042501802363, 0.18977530605526705, 0.18389082093208042, 0.19984008019718225, 0.1751342684595496, 0.1929718889384805, 0.09162487782003359, 0.0826219832543651, 0.08103009019668439, 0.07949443055551941, 0.09215156078328823, 0.09254172466530342, 0.08911534194737813, 0.08784950416700443, 0.08893288452948112]}, "mutation_prompt": null}
{"id": "7cbdfea5-2e09-4d71-a84b-ff6b119bf29b", "solution": "import numpy as np\n\nclass EnhancedQuantumMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.initial_inertia = 0.9  # Adaptive inertia start\n        self.final_inertia = 0.4  # Adaptive inertia end\n        self.c1 = 2.0  # Enhanced cognitive component\n        self.c2 = 2.0  # Enhanced social component\n        self.q_influence = 0.1  # Quantum influence factor\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0\n        self.eval_count = 0\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n        \n        while self.eval_count < self.budget:\n            inertia = self.initial_inertia - (\n                (self.initial_inertia - self.final_inertia) * (self.eval_count / self.budget))\n            \n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                self.eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n                \n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if self.eval_count >= self.budget:\n                    break\n\n            if self.eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocities = (inertia * velocities + \n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles) +\n                          self.q_influence * (np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim)) - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n            \n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.q_influence:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = personal_best[a] + self.q_influence * (personal_best[b] - personal_best[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.q_influence,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    self.eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if self.eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "EnhancedQuantumMemeticPSO", "description": "Enhanced Quantum-inspired Memetic PSO uses quantum particle dynamics and adaptive parameter tuning to improve global exploration and local convergence.", "configspace": "", "generation": 79, "fitness": 0.17936768664087743, "feedback": "The algorithm EnhancedQuantumMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.2835256497915746, 0.2860212882947121, 0.28877580236342304, 0.28151538154621325, 0.29892376764429884, 0.28749959712962025, 0.327969485446017, 0.29975117368613213, 0.2834917861118551, 0.023275428758222416, 9.999999999998899e-05, 9.999999999998899e-05, 0.0051791796409424995, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08255253409632202, 0.08804478372884783, 0.08601799170166835, 0.08414117884462069, 0.08023000245844791, 0.08852228430284637, 0.09626547715016454, 0.09400367942128429, 0.09703144075957681, 0.07709269026178067, 0.08918923288718794, 0.07713308698011989, 0.07684760242167576, 0.0796494136414323, 0.06891710405359941, 0.06880222986854279, 0.08471262510353661, 0.09902563380869434, 0.985077942026694, 0.9733446656510583, 0.9786108548170407, 0.9723623347671309, 0.9731162236327361, 0.967927166560645, 0.980603662377871, 0.9755480477390309, 0.9804443696709837, 0.1823425602624159, 0.176568927058259, 0.20734612318416512, 0.185571748017062, 0.1694091119912733, 0.1806556947680178, 0.1752831126262645, 0.15988294389460111, 0.1741156067647165, 0.2118085626192482, 0.22339655853459928, 0.19312169470327623, 0.23613495339778334, 0.21003236666984382, 0.19737237850323786, 0.24999732093185068, 0.21690819675283313, 0.2165235339226962, 0.10853680260642429, 0.09448204069648292, 0.1010904573228889, 0.11320560035131244, 0.1066934793292279, 0.08455271352431304, 0.14026938847826875, 0.10743570563586369, 0.09708005534771325, 0.09787081093889716, 0.10508985645788138, 0.09218811269771299, 0.09147948479808454, 0.10924881697909572, 0.10412310438656347, 0.10100098907735955, 0.09200619689159084, 0.10995558557691854, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10241791473389716, 0.09059754900728734, 0.12130132144699912, 0.13434158423549902, 0.11364003642569409, 0.04086723330435649, 0.11878399252960514, 0.10279178704863057, 0.08759859074802279, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024981222363189448, 0.01650163521087966, 0.036224395684277266, 0.03359176123097074, 0.05586557531865799, 0.048521938206719684, 0.03766660252103482, 0.04878295863075943, 0.04482150575804622, 0.2744298524751866, 0.28754652861131225, 0.3085445066798813, 0.3086350572434684, 0.29057073296774993, 0.30171144356499313, 0.30286978373866014, 0.29837635982412736, 0.29398448454254156, 0.07978891704371616, 0.08604261239417921, 0.09411207914024144, 0.09441685255025989, 0.08185882752936413, 0.09748686505788862, 0.0862602069380548, 0.08543001959617669, 0.09589523735013916, 0.18777893189251083, 0.13501190191590828, 0.2194152076091641, 0.1588145126364625, 0.15039869269613937, 0.15642816104163615, 0.18671821941935574, 0.14803438056203044, 0.16832509099311066, 0.21778494156844486, 0.21590848479262292, 0.2227512843285474, 0.22229917688594136, 0.256307527020029, 0.22933737970981427, 0.22462952796556068, 0.2443018496263999, 0.2331768177968725, 0.1586682474665284, 0.1700049708264627, 0.19533661935602764, 0.15722599443046348, 0.16374455402989896, 0.16966583600768104, 0.17685845372098175, 0.16916909672092828, 0.16663140058625847, 0.19760211621928714, 0.19331942394915147, 0.2192974937791139, 0.20035478027785036, 0.19623800043559436, 0.18413696555985448, 0.18695443365955733, 0.19814055432773225, 0.23219269510093576, 0.1795382312197562, 0.17425622872000424, 0.17871242636739282, 0.19125058850665821, 0.1756703915713148, 0.17227197347174628, 0.17267466115154761, 0.17051807014736264, 0.17881714867507492, 0.3343325510346443, 0.17902385992765357, 0.14761079622623274, 0.36299111291236796, 0.18540833782072008, 0.1663154432725501, 0.3010968899747477, 0.16075552854867747, 0.369455773549912, 0.37607124131730174, 0.20189025050855203, 0.3052616853826452, 0.3249218676455766, 0.3163441228094196, 0.14229762465199014, 0.3520837251471064, 0.10463141085415517, 0.4600542174166985, 0.17546125171821458, 0.17883738771766455, 0.1837988533593411, 0.18625245594925477, 0.1811261811679099, 0.18181384202454287, 0.16897797569922712, 0.17907692435453992, 0.1756968160949871, 0.07572210980151572, 0.07632734221119242, 0.08714553597530217, 0.08283867175212489, 0.07981197597487366, 0.0788281855400943, 0.07773279367913233, 0.07772399062636925, 0.075346770538813]}, "mutation_prompt": null}
{"id": "ef5c143f-c267-4395-bd8e-4128d385c11d", "solution": "import numpy as np\n\nclass AdaptiveMemeticPSO_EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia = 0.4  # Adjusted inertia for adaptive exploration\n        self.c1 = 2.0  # Enhanced cognitive component for thorough local search\n        self.c2 = 1.2  # Reduced social component for better individual learning\n        self.mutation_factor = 0.8  # Enhanced mutation factor for diverse exploration\n        self.crossover_rate = 0.8  # Balanced crossover rate to maintain diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Adjusted clamping for controlled exploration\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptiveMemeticPSO_EnhancedDE", "description": "A Multi-Stage Adaptive Memetic PSO with Enhanced Differential Evolution for robust global and local search across diverse landscapes.", "configspace": "", "generation": 80, "fitness": 0.35565053050735246, "feedback": "The algorithm AdaptiveMemeticPSO_EnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.8713784466491654, 0.850794735707275, 0.8540740987403649, 0.8690475128224755, 0.8636526026342857, 0.8575806760670993, 0.8562504044437814, 0.8636903189488985, 0.8548150839842157, 0.6921160804531659, 0.6898353161995711, 0.6840515017408515, 0.6789020155766798, 0.6876022066829428, 0.6839039778892699, 0.6784716237925393, 0.6990501043269777, 0.6784447066351835, 0.1793035510087364, 0.5059072337064949, 0.15507803221247218, 0.1579944815920299, 0.1661994714876448, 0.16699412599842112, 0.14426612563851426, 0.5217096195043621, 0.13248164076331903, 0.13811620135602787, 0.1389821844046668, 0.13970857342883614, 0.14017401307603883, 0.12854193221259813, 0.12229244953512952, 0.13438432724605953, 0.11756912297902655, 0.13690117658946488, 0.964222046783537, 0.9272563873036451, 0.9497796440558747, 0.9446982139003307, 0.9634293621122778, 0.9128691168184353, 0.9475959860446138, 0.9449752991356464, 0.9602291756970396, 0.5960362379453321, 0.6651138397557148, 0.5908064527422958, 0.6526250509848702, 0.6360812828307509, 0.5931492898974233, 0.5702899316580345, 0.620415263350295, 0.6062119538346378, 0.7620151844990721, 0.8541165591921029, 0.7118186130331838, 0.6990796585653101, 0.27206433587487777, 0.7668273435790065, 0.62410830455637, 0.7158020445669873, 0.6022359794989909, 0.2434197438047878, 0.20309399457983546, 0.21823900600158896, 0.20170250647868948, 0.2220307703844564, 0.11983251528420913, 0.2483559149914899, 0.22274945001453872, 0.2345216576904936, 0.2281167341167749, 0.37701705222408965, 0.18438585319394407, 0.21500759268965042, 0.28011652214123006, 0.1646394651611527, 0.13273461029390343, 0.18125962224042147, 0.12219612631164545, 0.07029236048237275, 0.04855845165034811, 0.05659655294680799, 0.06628778615641018, 0.04263543250729651, 0.03173581258315661, 0.10836506678274549, 0.05771076028413458, 0.07258186873178729, 0.13837442753590945, 0.1577580922727677, 0.1647820447535402, 0.17156441001402434, 0.11150762478193388, 0.11964092461804288, 0.13436370801169417, 0.19498621936508254, 0.1412423333280276, 0.3045474764510854, 0.29131820565172106, 0.2560198419665035, 0.2625263560720389, 0.07277490066287062, 0.09600202437315364, 0.09601120897945514, 0.17641106719801114, 0.07423814727161826, 0.2656415568019713, 0.1321723756004467, 0.20222665583465582, 0.16477887427008986, 0.11746257707317731, 0.24553587637208496, 0.17798714926804182, 0.19095340715655562, 0.0940221161394913, 0.5476587754976521, 0.57464008165974, 0.5899957356958985, 0.5784466496330367, 0.6097229450314948, 0.595548800097383, 0.5776255054915036, 0.56748526939099, 0.5821429303129615, 0.08629864232602791, 0.11304040318949593, 0.13677206438888911, 0.12679246539573064, 0.0718652126976076, 0.1360073950098718, 0.14231206372121197, 0.12694624887227313, 0.16926981924033047, 0.22659055070580603, 0.20997926633666775, 0.31320872365662533, 0.20738032163149234, 0.3229057373497036, 0.22489216045274563, 0.2576722358256378, 0.21749614314185506, 0.18669249723442072, 0.3143523849911328, 0.2805992516193778, 0.39460239856591883, 0.4214365201829836, 0.4296703163832031, 0.4684341078316705, 0.4737400980469021, 0.5313927248878599, 0.5330228123644085, 0.2661723248354432, 0.29154414056089495, 0.31013941009664603, 0.24444901630663718, 0.19916736001404645, 0.23258894335380542, 0.27136170907825397, 0.40025533998065854, 0.208924291054161, 0.2346074954008983, 0.2031417151283954, 0.22315719520059207, 0.22136706645198945, 0.25738020156876595, 0.2487459318266454, 0.26924490613028684, 0.22352783975824075, 0.21791523196957419, 0.20698960711686298, 0.24746371663048727, 0.2011819587840702, 0.7337759663892313, 0.2084377497104163, 0.19513259546757655, 0.5361622222848933, 0.5497645071515437, 0.20595495652382267, 0.17292575859249826, 0.1873499172753077, 0.6540991490952974, 0.9170111786151374, 0.1998649718244444, 0.16887245916635651, 0.17609187420756567, 0.16729728445590264, 0.8852765108675307, 0.73550770028852, 0.21070056838507267, 0.20297537624783213, 0.8030585084273534, 0.7058583973393845, 0.7262209157342436, 0.7684416069204696, 0.16378403927810414, 0.1642421380804221, 0.19526606776342736, 0.19291644251252282, 0.20602811261095044, 0.19532738278542683, 0.20791526278314598, 0.20286178318363235, 0.21516532270072508, 0.1873145227811236, 0.19679286137771046, 0.08816674967884919, 0.09113481519076772, 0.09517908031029532, 0.09420412187187299, 0.09146927365655211, 0.08138996143393329, 0.12308930495857273, 0.09151061231068636, 0.09686083343793761]}, "mutation_prompt": null}
{"id": "76a2d322-d68e-470e-b74c-0b840c8b3e94", "solution": "import numpy as np\n\nclass QuantumMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.4  # Reduced inertia for better exploitation\n        self.c1 = 1.6  # Higher cognitive component for local search\n        self.c2 = 1.4  # Lower social component for focused learning\n        self.mutation_factor = 0.6  # Increased mutation factor for diversity\n        self.crossover_rate = 0.8  # Slightly lower crossover rate for stability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Reduced clamping for precise exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions using quantum-inspired adjustment\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities * np.cos(np.pi * np.random.rand())\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search with adaptive mutation and crossover\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_factor = self.mutation_factor * (0.6 + 0.4 * np.random.rand())  # Adaptive mutation\n                    mutant_vector = (personal_best[a] +\n                                     mutant_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "QuantumMemeticPSO", "description": "Quantum-inspired Adaptive Memetic PSO with enhanced diversity maintenance using quantum superposition and adaptive parameters for improved convergence.", "configspace": "", "generation": 81, "fitness": 0.23515233926114792, "feedback": "The algorithm QuantumMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.5044823472272372, 0.5102595215435315, 0.46233681157682427, 0.4518397034460794, 0.495464186632141, 0.38540696614417735, 0.47409692020891936, 0.5248701686276829, 0.41094561522195927, 0.17445901985446777, 0.17259290096299829, 0.12858696621116927, 0.16399573729067762, 0.18697562103213328, 0.1573592710883438, 0.16974156111118954, 0.16859865702879362, 0.14466438868668974, 0.10042862024743004, 0.1299197714591146, 0.11120430025198724, 0.10700537731121584, 0.1253229159436462, 0.0951669867268965, 0.12589004148204785, 0.09194661253502767, 0.10371225792521233, 0.098185666714244, 0.09338266842876841, 0.09399276923055344, 0.0929872720820889, 0.09755237730801203, 0.08929984369351984, 0.08682524186840146, 0.07505190633029557, 0.09257967733383154, 0.9602521151598539, 0.8884341846438141, 0.7544390037729078, 0.8365253195175826, 0.8922150562190405, 0.7537338875324939, 0.8372808664218113, 0.8936584669161102, 0.7422173349838102, 0.26872065739045836, 0.2387151928868827, 0.22769521849119712, 0.24671699127513447, 0.29369575139025117, 0.2210799220036036, 0.219539810241545, 0.2700520858335621, 0.21072711970794267, 0.6236755811186622, 0.7618804586302061, 0.3588396971264506, 0.2834804307600264, 0.43661262792330524, 0.3922883128550251, 0.33762902915103865, 0.4800840277297438, 0.3643550288456472, 0.1523928616722784, 0.15038783519503396, 0.12250300473651676, 0.13868133058188126, 0.2225067515461605, 0.15595558129741915, 0.16789729370421758, 0.1429965629001183, 0.12588821150445906, 0.14180092957100765, 0.18636051561769795, 0.14451093053316177, 0.17713921637565233, 0.15882109983842096, 0.121478830843321, 0.23592551865927402, 0.20623283233175593, 0.15850948009442944, 0.10422744162256314, 0.052473351765803145, 0.04389280626343861, 0.09076078930820952, 0.07898406760611854, 0.040718440715221016, 0.050480081019609546, 0.07556217247964381, 0.07474299877009527, 0.18618292628650257, 0.16818502791279466, 0.18528543385639273, 0.14228573090155439, 0.14727152210290184, 0.1506301223376285, 0.17700420684363816, 0.2096812021129989, 0.17298717117268114, 0.022412279384632194, 0.042619958486255216, 0.004855598851544851, 0.004053284387801281, 0.0491912224328962, 0.0019073092430069716, 0.005964140613599178, 0.014567288342629992, 9.999999999998899e-05, 0.11933335126839761, 0.12938377954034952, 0.10457288100649897, 0.11524074901036241, 0.13065786377455113, 0.07672072244708383, 0.08007196382478565, 0.12292304283555078, 0.10856754529922363, 0.4320402407865538, 0.48073934151959474, 0.4185049947078411, 0.4206742764614141, 0.4629116812485713, 0.3769388775951621, 0.44561889477455674, 0.43389397176424027, 0.4241796061749996, 0.0842997228789576, 0.10180864441361281, 0.10930240019646931, 0.09001988140226491, 0.12765233293353218, 0.10304238229182028, 0.11246554545631848, 0.11375434093577319, 0.08192316691299384, 0.16355367072292537, 0.14029355133161348, 0.16195045271885988, 0.1390082633405786, 0.2287111227121813, 0.1278978785011573, 0.2071622179559478, 0.20753617396183577, 0.13007819873856075, 0.27405739575148813, 0.27695136905484496, 0.2492135325704038, 0.28548831952264686, 0.30287014741864227, 0.2900041881778641, 0.27569148837520274, 0.2927760540719059, 0.27182162297490153, 0.2163690810287987, 0.21936557209382368, 0.18835810478293502, 0.1897101871870538, 0.23391172176017894, 0.17730035011755862, 0.2212048058846272, 0.2261778383793468, 0.19891262705332113, 0.2097230882701403, 0.21026906972643478, 0.22964927261385515, 0.211932501504986, 0.20614800387754306, 0.21449114670342406, 0.199244009276628, 0.1956495350439359, 0.19114657380911626, 0.16984046651983353, 0.19249355521528122, 0.1691370553009206, 0.21475164719156237, 0.21032589228752785, 0.17612201866380095, 0.17458630210386095, 0.2419923342554703, 0.18584199243441857, 0.5461983584405433, 0.18000346214298113, 0.29744628667303175, 0.4343200579912261, 0.19403658500823184, 0.48950428106053856, 0.181434890484391, 0.6844181861400536, 0.5083841820394055, 0.5459056915653853, 0.5110836021601697, 0.42268330270628085, 0.5024507238123836, 0.20325292707414933, 0.3235656294222885, 0.1645719205208357, 0.20596382603994146, 0.19061274359520053, 0.18418276394806377, 0.16870803603373474, 0.18415944300528042, 0.19036185243544768, 0.1726785222279945, 0.19017948899865922, 0.18569270423195483, 0.21035696307248042, 0.1809977059113398, 0.07826782168367485, 0.07732036578934876, 0.09404344583529967, 0.10580794911863745, 0.0783405866889898, 0.06905997918401285, 0.08143577347759823, 0.08117727236304795, 0.06864513595754251]}, "mutation_prompt": null}
{"id": "93cc09ba-4e64-436d-8bbf-1cec9504e1c2", "solution": "import numpy as np\n\nclass AdaptiveMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size\n        self.inertia = 0.9  # Initial high inertia for exploration\n        self.c1 = 2.0  # Increased cognitive component for stronger local search\n        self.c2 = 1.5  # Balanced social component for learning\n        self.mutation_factor = 0.6  # Slightly increased mutation factor\n        self.crossover_rate = 0.85  # Balanced crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.0  # Restrained velocity for controlled exploration\n        self.dynamic_inertia_decay = 0.98  # Gradually reduce inertia over time\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions with dynamic inertia\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            self.inertia *= self.dynamic_inertia_decay\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search with adaptive mutation strategy\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    adaptive_mutation = self.mutation_factor * (personal_best[b] - personal_best[c])\n                    mutant_vector = personal_best[a] + adaptive_mutation\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptiveMemeticPSO", "description": "An Adaptive Memetic Particle Swarm Optimization with Dynamic Inertia and Social Learning for enhanced convergence and diversity.", "configspace": "", "generation": 82, "fitness": 0.33600343082154643, "feedback": "The algorithm AdaptiveMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.7356819178895251, 0.7374546204949596, 0.7416854098635454, 0.7290533394937985, 0.7149749320593679, 0.7314640119002827, 0.7337660394041442, 0.7253638092103618, 0.7280974968552216, 0.5207632412873183, 0.5241134471432145, 0.5225993987330684, 0.5069002397909674, 0.5271663982231715, 0.5242377585159794, 0.4994096764897292, 0.5014815046536875, 0.5161250648787383, 0.1283530309781925, 0.11816992000656079, 0.13542314989809456, 0.125807441076495, 0.1318178220650139, 0.13530381002759206, 0.16643661762209827, 0.24039682974016974, 0.40640932681228636, 0.11004283764280776, 0.10932521172276388, 0.11204182557408626, 0.11693682295119812, 0.10448114823505694, 0.14403300057084467, 0.2156743862927819, 0.11727901506723448, 0.11970214479451846, 0.9545869758972578, 0.9547235170283344, 0.9605330723276024, 0.9607945343128887, 0.9595568164474869, 0.9515198206416804, 0.9586439975084474, 0.9280762849389111, 0.9507596324265731, 0.5103670367273575, 0.5156544157661203, 0.5012366307385883, 0.5059983125656777, 0.5133043811800878, 0.47307445999464115, 0.5009177147216113, 0.43717240667796486, 0.5013911108794326, 0.6629384739629101, 0.3641893358014823, 0.7148117554977701, 0.7134170609455457, 0.696977964962973, 0.6858075960860293, 0.6285282064209022, 0.7048653624824335, 0.6574572046335019, 0.2172172567186409, 0.18578130667422177, 0.18638613685036443, 0.1862642764665282, 0.22456617490910724, 0.20010069837273248, 0.21204209975986776, 0.20538019004195462, 0.23229487606843335, 0.21645671327491478, 0.2369096659739417, 0.23148866841192306, 0.2301944420374864, 0.2190582592679371, 0.23639273150121864, 0.22641695895712588, 0.25718878725585037, 0.23606973144190935, 0.08664472185420291, 0.0865101418302473, 0.07827331735919629, 0.09539039414100348, 0.11207005001877957, 0.09005770669523627, 0.08911139802253043, 0.07716862307493322, 0.08951774421039627, 0.23243399987648095, 0.20465026768966255, 0.19366837164920347, 0.21667670557596752, 0.1295129908798781, 0.1709556894394575, 0.22745590084742684, 0.2681511535141393, 0.24272382000954118, 0.03195892262586708, 0.03780819325006468, 0.03847071452219952, 0.05836150236221549, 0.0892914256756725, 0.061461689371662076, 0.07349543632968503, 0.0892076919405197, 0.0823056321191189, 0.14853566761562065, 0.18995641076138714, 0.16647597273078318, 0.19923113473639265, 0.1840422137202803, 0.1939643249676134, 0.2182954452446665, 0.1442765529818354, 0.14728547502396228, 0.5367142546387365, 0.5284414328616307, 0.5249323332714952, 0.5147634018415612, 0.5152987683821966, 0.5052939688223246, 0.5331419192593112, 0.5404040122051316, 0.5434942467826032, 0.12249729179666025, 0.12962331826579598, 0.14084779625739663, 0.1398710439618922, 0.10725250168242695, 0.09824070227815851, 0.13479934566431817, 0.09815873861774149, 0.12055712989540768, 0.16748202194985007, 0.1453416020543551, 0.17327950354857458, 0.24572349297133134, 0.32136658251918027, 0.17317112777076293, 0.1485855854257112, 0.22896020006489626, 0.2720776614821827, 0.4325633332957418, 0.43628993198520916, 0.36578948457185756, 0.3324838285092122, 0.44704953039150297, 0.45041603273819086, 0.4543511841085919, 0.4395084459291442, 0.43737380471692133, 0.28520894802130137, 0.27553264814973544, 0.31910077459849473, 0.2879302198259486, 0.2727324103569455, 0.29307109376681306, 0.3345977623261204, 0.3848385979388166, 0.34093831702741095, 0.23258046148684242, 0.20816411790490197, 0.21342637259105357, 0.23221779674827792, 0.21682546454122908, 0.2033669397164095, 0.20222077832947238, 0.19619363455208116, 0.21835059380769917, 0.22530858816224408, 0.19958605451985656, 0.228579298770486, 0.49263329701669567, 0.22544410059930342, 0.22941966034105066, 0.22596272383934157, 0.585153993519266, 0.23245606256338613, 0.7995354335820359, 0.7821186863166435, 0.15116369522253736, 0.821124248200816, 0.19841826937852425, 0.16846256999190135, 0.7752336353999234, 0.1647402198387946, 0.8040567148099297, 0.7291624640219587, 0.2095286271156449, 0.6773150422094361, 0.20151357280995075, 0.20580424253383256, 0.6571976122069951, 0.7027537376538866, 0.7046614658112925, 0.7586122645158455, 0.193015377431057, 0.18443172564620436, 0.1892347615048735, 0.20932076354603224, 0.1935994549290444, 0.1993393533046205, 0.19444500207713533, 0.19944554160422268, 0.19172124153204706, 0.09177403135224083, 0.10344158246854296, 0.07923484738202946, 0.0939612801625086, 0.09173515824634781, 0.10199975597243682, 0.09145231663292974, 0.08494057883427708, 0.09337640547725146]}, "mutation_prompt": null}
{"id": "82f41b57-0d72-4507-9a0d-9d3d34316b26", "solution": "import numpy as np\n\nclass AdaptiveMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.7  # Increased inertia for broader exploration\n        self.c1 = 1.3  # Adjusted cognitive component for refined local search\n        self.c2 = 1.7  # Enhanced social component for improved collaborative learning\n        self.mutation_factor = 0.6  # Moderate mutation factor for diversity\n        self.crossover_rate = 0.85  # Slightly reduced to balance exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 2.5  # Dynamic clamping for controlled exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "AdaptiveMemeticPSO", "description": "Adaptive Memetic PSO with Strategic Exploration and Dynamic Velocity Scaling for enhanced global and local search coordination.", "configspace": "", "generation": 83, "fitness": 0.29632557615729593, "feedback": "The algorithm AdaptiveMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.6447637649280923, 0.6508481111995159, 0.6588290833638798, 0.6695433519369838, 0.691914366978536, 0.6708453464877573, 0.6576348737959983, 0.6593378858060112, 0.6338035742482859, 0.25034903816125254, 0.28146202905468176, 0.2876642297848103, 0.30871493708945996, 0.28477314150613087, 0.26263150280576986, 0.29234297174359614, 0.33207202288822935, 0.29516097939308417, 0.15479670498745013, 0.20060188269911705, 0.13816966604029657, 0.14821286679762502, 0.1306819500826577, 0.1310187506476912, 0.13307312026848828, 0.15871020037320127, 0.13822514858418522, 0.12421287895589428, 0.13972498341310913, 0.11452172832258545, 0.11904288937145846, 0.1011219368396683, 0.12102032171136556, 0.11097467700820218, 0.12066955522917655, 0.11366057004478769, 0.9616969551345986, 0.9522215795503504, 0.9653238813903007, 0.9581252782833186, 0.9679832522459011, 0.9581457701312152, 0.9621208814361853, 0.9596157355500653, 0.9582923074531495, 0.37925145605470445, 0.3557888242487529, 0.3689367366203673, 0.3803458297474458, 0.3947950240794712, 0.40203439469020863, 0.3466294619020599, 0.35030620723359174, 0.34382926037360995, 0.7067254240995617, 0.6578806932220695, 0.6198920184915666, 0.6216644511950377, 0.6301328535018857, 0.7349836170245247, 0.589627834655725, 0.6337141588980515, 0.5717685989365588, 0.20698757768112386, 0.17089395648894845, 0.18731769502434692, 0.20090260628100332, 0.20599069670793724, 0.23454110841280107, 0.21540647024785586, 0.19949597290596566, 0.21103908160871876, 0.2178300827070222, 0.21549561092712288, 0.18662217412054793, 0.18353195481292262, 0.23575168275092306, 0.19296767918093316, 0.21401624397064867, 0.18974377368052897, 0.21604165171193923, 0.08636049960719905, 0.10030922743780468, 0.10704816222392621, 0.10938047917512672, 0.0624137030536438, 0.10748370019768971, 0.07978021780494549, 0.06674381506838745, 0.07796228982054687, 0.21574153743167535, 0.19663642719509067, 0.19323347087567866, 0.23711440150296814, 0.17751804829187245, 0.20040545298190782, 0.236542400506479, 0.23909451896328615, 0.21386053135015104, 0.0887348399471124, 0.015708770035401942, 0.01630697333511466, 0.045055442333596485, 0.015716379583478934, 0.03930423458552157, 0.0643827520106961, 0.03350451720319958, 0.02102212144420157, 0.1456587591192341, 0.14818542844652915, 0.13104341521878138, 0.13364940730317243, 0.1515949316141456, 0.15411926231690753, 0.13564974273885777, 0.19296042711276773, 0.14494921807349148, 0.47735398188412803, 0.47397367967306514, 0.47825834063126804, 0.4948005528897004, 0.5088321983207433, 0.48942733077726674, 0.5218087164689235, 0.47517114811830885, 0.4872531038880936, 0.11532322107403903, 0.11586848754583223, 0.11984590512073046, 0.1296177939236468, 0.11479967571089311, 0.10321778930150705, 0.13100332318976438, 0.12464954207090073, 0.14961358276843661, 0.2792276764111614, 0.15828524291515644, 0.20634433784630568, 0.3639772387451412, 0.15964641917283973, 0.18622599106333715, 0.20218929983771883, 0.19152897375758915, 0.29041849330611, 0.3236800819806287, 0.3139800358277717, 0.3576706864814996, 0.36689096547065925, 0.3404316556056646, 0.33554278681329963, 0.3404962776088343, 0.34751300974311816, 0.35825002189679855, 0.25372779452424554, 0.28327070122338727, 0.25648779974987956, 0.2602653163594365, 0.1890272886363218, 0.2674091487635164, 0.2598676564588309, 0.2732706606998444, 0.29849418175960274, 0.20724796735444473, 0.20938264312270072, 0.21998835908889136, 0.209955890961804, 0.19089721149481442, 0.21747428186752082, 0.20471069038343026, 0.2214780024575541, 0.2915468765276201, 0.38351632981208317, 0.2758169644066566, 0.29966481848208026, 0.2143237302829143, 0.21020108759044243, 0.19677733634160122, 0.3094970724127414, 0.21562482403391725, 0.2228424935538218, 0.7462592374650758, 0.17413219761267884, 0.1520225026104257, 0.8416878217472066, 0.19905504521484108, 0.1963107217276474, 0.19463299533159895, 0.16715766941285615, 0.7993245568976294, 0.7404350262994575, 0.20938801314751343, 0.2053119666677865, 0.6306028060884752, 0.208270901651335, 0.16570177694704924, 0.5484841866612509, 0.6189170160393948, 0.6439042741529586, 0.1872299778183203, 0.18994686952486461, 0.186058866444747, 0.18032701736692036, 0.18547979405729964, 0.17745556630017112, 0.2281119567292632, 0.20612192033569132, 0.23062303932872052, 0.08217775093875412, 0.07996791859024066, 0.08741382625337157, 0.07698035978742823, 0.09671000253204542, 0.09791155537671947, 0.08993054686014479, 0.08576513903485139, 0.08791387699899711]}, "mutation_prompt": null}
{"id": "a0f56a65-d041-4062-982c-aedd0eca391a", "solution": "import numpy as np\n\nclass MemeticPSO_Hybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Maintained population size for adequate diversity\n        self.inertia = 0.5  # Increased inertia for broader exploration\n        self.c1 = 1.5  # Balanced cognitive component for local search\n        self.c2 = 1.5  # Balanced social component for collaborative learning\n        self.mutation_factor = 0.5  # Slightly lower mutation factor for stability\n        self.crossover_rate = 0.9  # Higher crossover rate to encourage diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp = 3.0  # Enhanced clamping for widespread exploration\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([float('inf')] * self.pop_size)\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n\n        while eval_count < self.budget:\n            # Evaluate fitness\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update velocities and positions\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp, self.velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            # Apply Hybrid Search\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "MemeticPSO_Hybrid", "description": "A Memetic Particle Swarm Optimization with Hybrid Search and Adaptive Learning for improved balance between global exploration and local exploitation.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.8074610051903414, 0.8207688905683119, 0.797679324129725, 0.814860176296811, 0.7999924538841379, 0.8221909374273466, 0.8054741145080416, 0.7904590805130114, 0.7895582335717839, 0.6063863637941769, 0.5733615736539641, 0.5788291790124744, 0.5862949363895678, 0.571885828600781, 0.6077587799048645, 0.5725197801655374, 0.5862372889286017, 0.5900377871311293, 0.13581695535852434, 0.1458970336207669, 0.1477008490017333, 0.14108417553606123, 0.17093062503700363, 0.17844812828545642, 0.3917768585832446, 0.13976554655830553, 0.12194006468297991, 0.11180296968251224, 0.12524262339112213, 0.13012914241259166, 0.1346961948057357, 0.13624057375204734, 0.10632349268116104, 0.14254055119210918, 0.10586382379836412, 0.11037615505130127, 0.9576190743915736, 0.9424583761312734, 0.9607965796380125, 0.9578733639611549, 0.9596152674213668, 0.9515725908243361, 0.9610080531473729, 0.9556491753931183, 0.9599618169512772, 0.6563515325574378, 0.58804580275137, 0.598015840226553, 0.5866634909279549, 0.5733248417599669, 0.5980081598130582, 0.55365369191393, 0.5850142107433465, 0.5799001130795116, 0.8025447176999644, 0.7629036815888369, 0.6997857111758963, 0.21763743235801924, 0.7632725823361739, 0.8238265841460901, 0.7950195269676368, 0.7889574472977795, 0.7835372071173996, 0.2956367587378913, 0.24553817855364424, 0.30595641936246576, 0.22817130700425237, 0.25770357335363925, 0.12334357611907776, 0.25627005177153894, 0.26434796730376486, 0.34631379388002514, 0.23586437760374745, 0.24162496786579746, 0.24116344435730108, 0.26099155858128376, 0.46369720823676375, 0.32707237904147757, 0.33080563824591624, 0.23667110003856628, 0.2133881946315218, 0.195486718373728, 0.1997765676755564, 0.17418753986104762, 0.05412999384890338, 0.21823988697050467, 0.13674487094646115, 0.17657159631088615, 0.21840093063854715, 0.18581044382075318, 0.296660918779146, 0.32259535546047413, 0.3415224933336233, 0.2698566185195729, 0.30911835352671335, 0.3033054648634711, 0.3117712182120931, 0.3844602431209456, 0.32753836274299797, 0.08508483168270109, 0.11076613125971924, 0.11582420759991296, 0.24672162130159103, 0.16383952398477808, 0.07458579440971769, 0.08253816518600776, 0.11848553362155467, 0.11852197063692516, 0.21036698220093897, 0.24175051047127072, 0.2270320963110607, 0.22618790715489812, 0.2336738452393461, 0.23331046771408004, 0.24625644922133172, 0.19530448353421592, 0.10219758182002259, 0.6231309454165004, 0.5981382014069058, 0.6649738645349488, 0.621134338056615, 0.6330280200560299, 0.6432159427737161, 0.618177216197796, 0.6440918308417349, 0.5994084006158105, 0.12336569972909206, 0.13346907051688373, 0.1286167779508849, 0.11336998719123059, 0.11814331543541379, 0.1529668942341621, 0.13269201882102188, 0.08949091652862484, 0.17967436401558678, 0.21026828741866566, 0.36001762671750326, 0.22371658477786627, 0.4799292782409367, 0.26654729622490425, 0.2767221899524961, 0.5532117741702655, 0.16947192231379649, 0.2335736589499009, 0.4810430787741602, 0.4800353736554577, 0.48455366513413733, 0.46084945348059536, 0.487265973261806, 0.4802300252621793, 0.4993338771362059, 0.5010834670564397, 0.4888558000545651, 0.3253004952675548, 0.35875182791129134, 0.342819893281483, 0.27264542198018227, 0.2747542506283476, 0.31907293875291065, 0.3990461436230487, 0.29947587478471205, 0.38194185892536403, 0.24990456375450731, 0.21664865634206776, 0.23212461263974005, 0.222954999113546, 0.20531000245078668, 0.21955304324158864, 0.22300331604919854, 0.20593387486583214, 0.22087365444099938, 0.19743376533898072, 0.20438333510330275, 0.2281241995132013, 0.20435770272136644, 0.2075652848928099, 0.22115073432355337, 0.21343054488654278, 0.2374679316592896, 0.20998946870818747, 0.8813985887367238, 0.1850222317937561, 0.15287288500565444, 0.8876979682921377, 0.19943606818475157, 0.16814417427899553, 0.1417787842333007, 0.8565702040731089, 0.8625453050566988, 0.7531995589996087, 0.21104536435514032, 0.7063248354516145, 0.7510106547104625, 0.7988385825889909, 0.7335241336773517, 0.725730800257685, 0.6681257473402611, 0.7851974049738832, 0.19558647556438913, 0.20248153022849547, 0.18613844169167182, 0.20056320073959977, 0.19016758838740078, 0.20680781514806545, 0.18426451163125113, 0.19233691934386365, 0.17929749674986528, 0.09292900377838142, 0.09388512270572391, 0.08399775722439318, 0.09441100397783408, 0.1029994369509517, 0.09273374541756962, 0.08659086168241681, 0.09732088309309639, 0.09338295959267595]}, "mutation_prompt": null}
{"id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "solution": "import numpy as np\n\nclass EnhancedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly smaller population for faster convergence\n        self.inertia = 0.6  # Adjusted inertia for dynamic exploration-exploitation balance\n        self.c1 = 1.7  # Increased cognitive component to emphasize individual learning\n        self.c2 = 1.3  # Decreased social component to reduce premature convergence\n        self.mutation_factor = 0.55  # Enhanced mutation for exploration\n        self.crossover_rate = 0.85  # Reduced crossover rate to maintain solution stability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_factor = 0.8  # Adaptive clamping based on iteration progress\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocity_clamp = 2.0 * (1 - (iteration / (self.budget / self.pop_size)))  # Adaptive velocity clamp\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "EnhancedMemeticPSO", "description": "Enhanced Memetic Particle Swarm Optimization incorporating Adaptive Velocity Clamping and Dynamic Population Adjustment for improved convergence and diversity.", "configspace": "", "generation": 85, "fitness": 0.3826699962866166, "feedback": "The algorithm EnhancedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "874a5d94-2f1a-4458-bc7d-522c92c94633", "metadata": {"aucs": [0.8215739274618251, 0.7979778805362141, 0.8088872858659285, 0.7986498501855805, 0.8007491565610679, 0.8074264284864634, 0.79195859292286, 0.7902284635947386, 0.8156633877252367, 0.5837133483659607, 0.5698748448648694, 0.580942963384092, 0.5563914583115674, 0.5730598349541753, 0.5468903836561381, 0.5445977491560494, 0.5834604082381821, 0.5719919077133899, 0.1463289779342698, 0.14531618459056939, 0.17071837024273406, 0.15497513857875822, 0.37855891232048167, 0.13741453887125465, 0.15874823590826637, 0.26887108655055025, 0.1379538517140223, 0.128449766187547, 0.15118244220800225, 0.11748309136950774, 0.11220400618068815, 0.16101152716880918, 0.1411616355971721, 0.17112499270836956, 0.14069740249785356, 0.15784156902696522, 0.9534495285586776, 0.9470035090619835, 0.9526661903836772, 0.950340881712089, 0.9549759371956921, 0.9610494123729862, 0.962072258342753, 0.9418993926713234, 0.9414524607721911, 0.5686184321902064, 0.6009927650580655, 0.5861106115473624, 0.5606914288659318, 0.5769020842581678, 0.6226008927858595, 0.5697797770333887, 0.5622202655428121, 0.5846673850393524, 0.7612246916510716, 0.7432281604417549, 0.785289728321352, 0.746703577929325, 0.7586130960007015, 0.6417327518974415, 0.7450819991492494, 0.780790055579652, 0.7826705251308298, 0.2902475022603237, 0.33313122332292633, 0.26004500334593683, 0.28018449248204924, 0.27885842416552187, 0.2397421408071274, 0.26404926686001007, 0.26373645310216565, 0.27653242275770407, 0.2794841180253286, 0.25688691328254076, 0.2687686369567417, 0.2925168586253102, 0.2754305987671112, 0.3430287088719951, 0.27936118937701615, 0.22583976027288422, 0.24413084273955032, 0.16974446895503892, 0.13921175989839885, 0.166780795937422, 0.16790202857979752, 0.18023634875741879, 0.14429573803258278, 0.21045096058172585, 0.1628560326037488, 0.1451042801600152, 0.2732713494521023, 0.2694056700510018, 0.2627536280703797, 0.2881716014177853, 0.2579625950937474, 0.25922150721308135, 0.2981205382912442, 0.3323065400204974, 0.2960489388603209, 0.12729289364524377, 0.06502517139450936, 0.06799248517841316, 0.0797145192038955, 0.07672066485695139, 0.11102121952798094, 0.11408839327644493, 0.0688816802369886, 0.08324247839644139, 0.22472288226555404, 0.21734984944601976, 0.19535400665496072, 0.2310391454334515, 0.2204153505407278, 0.22535128894233458, 0.21581860179572332, 0.21002618837446596, 0.16574717829534324, 0.5687618436093003, 0.6075075441352545, 0.5704709415286896, 0.5833935618690012, 0.6186137652064316, 0.6122835920000301, 0.612733279575228, 0.6335229042692614, 0.5901069959272081, 0.13964109089836907, 0.13127953065628373, 0.10559336188723867, 0.10101921187169627, 0.16203489412015115, 0.1500858619011789, 0.15038113429204736, 0.15408633792792004, 0.1493614982803858, 0.2165969365629018, 0.30247252056976237, 0.21949836901106023, 0.4966689393584134, 0.27958029878316815, 0.45463223663790087, 0.2568718918217354, 0.4389987541098118, 0.24400440088744757, 0.42426430850655283, 0.4174294389086568, 0.4177018929510413, 0.4425525324601355, 0.3547049885188044, 0.4886801092219729, 0.5204633680064326, 0.48783196695724595, 0.4911579921430461, 0.3270427643830027, 0.31170558264817716, 0.34303134514925304, 0.28309881638564927, 0.3034192383181826, 0.36123525882216345, 0.30115155030672336, 0.36404540176512, 0.37587840859435284, 0.21891033066888133, 0.23921689975748073, 0.23184279374672234, 0.21945770977828682, 0.21885689453870671, 0.26705153135544324, 0.21963777079171254, 0.21150467154914632, 0.20827441472845143, 0.20162278937980593, 0.19985943117280647, 0.21626293275721464, 0.24213310397678822, 0.6334400386190986, 0.22853436136166272, 0.21945398310471353, 0.21965203666389932, 0.19830604447243616, 0.8852799859048726, 0.8217816108477851, 0.7587078069745158, 0.8942131928350725, 0.2003710662052126, 0.8673591535050614, 0.8555033854573525, 0.8428913416242199, 0.9000241076844019, 0.7988990628227973, 0.2121895985316561, 0.8076048365752231, 0.7469503988384443, 0.16969994554455203, 0.1546758509026538, 0.10462002284567551, 0.7540984661633787, 0.7916401505175465, 0.22146815164851585, 0.1904404226179831, 0.1906072597042212, 0.18805710387551966, 0.21346568447777836, 0.1841445611624406, 0.1816530877513174, 0.1855357349666027, 0.2039979959871805, 0.08968938295845763, 0.09336598140369279, 0.09017422800049446, 0.08884035163272042, 0.08903392550468148, 0.09526419799790142, 0.0902972321101182, 0.101082779436523, 0.09094599612691012]}, "mutation_prompt": null}
{"id": "9ae046a5-1794-4385-8d6a-1916f2af2210", "solution": "import numpy as np\n\nclass AdaptiveQuantumMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population to enhance exploration\n        self.inertia = 0.7  # Slightly higher inertia for better exploration\n        self.c1 = 1.5  # Adjusted cognitive component for balanced learning\n        self.c2 = 1.5  # Rebalanced social component for diversity\n        self.mutation_factor = 0.6  # Enhanced mutation to expand search space\n        self.crossover_rate = 0.9  # Increased crossover rate for better genetic diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.quantum_radius = 1.0  # Quantum radius for quantum particle update\n        self.velocity_clamp_factor = 0.9  # Increased adaptive clamping for stability\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocity_clamp = 1.5 * (1 - (iteration / (self.budget / self.pop_size)))  # Adjusted velocity clamp\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    quantum_particle = global_best + self.quantum_radius * np.random.randn(self.dim)  # Quantum update\n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, quantum_particle, trial_vector)  # Combine quantum and trial\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "AdaptiveQuantumMemeticPSO", "description": "Adaptive Quantum-inspired Memetic PSO using Adaptive Particle Confinement and Enhanced Crossover for improved exploration-exploitation balance.", "configspace": "", "generation": 86, "fitness": 0.2811281284788954, "feedback": "The algorithm AdaptiveQuantumMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.6986872119349621, 0.6708072778357961, 0.6777817478709871, 0.6788768734892332, 0.6825395337179803, 0.661435971780308, 0.7013137953291626, 0.7002511448261115, 0.6799394974112287, 0.16876122059781118, 0.2601875500802866, 0.2676463040766587, 0.2898817520529229, 0.30032435324133344, 0.2934638317643701, 0.28509980659703604, 0.3205764954099797, 0.29772196970980747, 0.1399144002141266, 0.13642838576459182, 0.10787742334568862, 0.21827772290915104, 0.1198811420501672, 0.1333280154476434, 0.11765360259676605, 0.15104103870324814, 0.1394129171950974, 0.10389249780470033, 0.12257614453402643, 0.13840136494846633, 0.1185270362079256, 0.10519964529621462, 0.13310708895534085, 0.1202794316301713, 0.13881646232841216, 0.10403486592205247, 0.9595543148850229, 0.9791186578688893, 0.9923126454781387, 0.9532477991488617, 0.9862536630164307, 0.9712910870994185, 0.9670108773258713, 0.9792373707709117, 0.9603030037766348, 0.40860214556428454, 0.4141647327002419, 0.38188797083531456, 0.408766195165295, 0.4027349687043066, 0.3871311160170239, 0.3549306276997153, 0.39701044778869177, 0.41566280021111457, 0.6076107899606277, 0.7187611772526639, 0.3434063200875134, 0.26861641535881664, 0.2716534886366879, 0.28001317440469387, 0.31561998390439816, 0.6912312773731588, 0.29758296796853767, 0.19848072445431986, 0.228812436824111, 0.15726317172873638, 0.180475520755222, 0.1602048568506651, 0.11393557806953791, 0.167257300408176, 0.16626620110103907, 0.16377722537960904, 0.17947585152993428, 0.1931507099696198, 0.12339081714170952, 0.17557088995159287, 0.18650132686753151, 0.18183050008527224, 0.19419524764808405, 0.17483902115946826, 0.19202514576135643, 0.012254076674319325, 9.999999999998899e-05, 0.0025216910496351774, 0.0003809280760244116, 0.06135671988708857, 0.00941125738239701, 0.025004046716222028, 0.033644149290337766, 0.06562398658712465, 0.17630650228363176, 0.09323624552345045, 0.06096214894525942, 0.1109031983647697, 0.026503049126245792, 0.03707237099287575, 0.10298780181122857, 0.1103543465388449, 0.06752629145966671, 0.026591723341859552, 0.19768638712396347, 0.17936848974567565, 0.09719200876862721, 0.05254695869588921, 0.12742456340071495, 0.12021031632447943, 0.12185051119225354, 0.15918944790591705, 0.10185703827365866, 0.16274802987803594, 0.12800685288073732, 0.14842223256744003, 0.06962223213430319, 0.11149824513481577, 0.20630148385946545, 0.13197571599009805, 0.07662637431744301, 0.4848303770257886, 0.4905572721217737, 0.48630431299047416, 0.4792861936095756, 0.48428017445389315, 0.48262776919907635, 0.4878146657485677, 0.49241880860090825, 0.4811033429970606, 0.14948150182849407, 0.13217099966761214, 0.13574643591356583, 0.1388203938957755, 0.1160513110523651, 0.1430934858590872, 0.12696685173652367, 0.115798454538108, 0.1102234868862495, 0.2116587930051973, 0.22165897204217977, 0.19024615619888918, 0.1872180165535503, 0.2520731209799062, 0.32211776722404706, 0.23556184542157033, 0.22603551540250133, 0.25933255613621153, 0.29595239434123966, 0.35927497597081903, 0.31981754129987194, 0.32701677771369975, 0.3601725919814124, 0.2513605005221622, 0.3722430363804339, 0.339980081947337, 0.25177113589281164, 0.2732621209492432, 0.25708603505769634, 0.28076820205991804, 0.2714690257736906, 0.20288588970283516, 0.23541794790205384, 0.31241478140756673, 0.20835488715868122, 0.22797324188900125, 0.21962402046403362, 0.22232473956362175, 0.19829638442839748, 0.20035377245606079, 0.1980373711087594, 0.24534996024137645, 0.19635971868138924, 0.24695821724012634, 0.2270926538394824, 0.36806318463293997, 0.30045080898444787, 0.22297536049326627, 0.237767885255729, 0.37940363569676017, 0.19796453379441215, 0.21308593874786952, 0.20365586233412125, 0.20237510947843906, 0.814711474373128, 0.17599984928832857, 0.1523112443323027, 0.842390769825511, 0.19928544239913148, 0.19474733607106365, 0.7861014533928465, 0.1633703462851519, 0.843984582283225, 0.5668620939469069, 0.20992090732836577, 0.45937918705507896, 0.6020129459003438, 0.5993860956787249, 0.1681128619942247, 0.5040759741872907, 0.16737411298587757, 0.16547282592040324, 0.22853030022577514, 0.18407208809024578, 0.1833791936195185, 0.18747235947336072, 0.19019015003051565, 0.1796535626268515, 0.18686841952106037, 0.18641078725006, 0.2004143985979847, 0.08365075184491966, 0.09824913228009813, 0.09180341904145772, 0.09120153733739356, 0.09286370619557094, 0.08926677495071522, 0.13758540587842194, 0.08858762988662805, 0.08675623434874213]}, "mutation_prompt": null}
{"id": "81ea1cd7-37e0-4ee0-b02a-6a4b8c65da9e", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for better exploration\n        self.inertia = 0.5  # Balanced inertia for exploration-exploitation\n        self.c1 = 1.5  # Balanced cognitive component\n        self.c2 = 1.5  # Balanced social component\n        self.mutation_factor = 0.6  # Enhanced mutation for exploration\n        self.crossover_rate = 0.9  # Increased crossover rate for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_factor = 0.9  # Slightly increased clamping for stability\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocity_clamp = 1.5 * (1 - (iteration / (self.budget / self.pop_size)))  # Adaptive velocity clamp\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "AdaptiveQuantumPSO", "description": "Adaptive Quantum-inspired Particle Swarm Optimization with Dynamic Population Scaling and Enhanced Local Search for improved convergence and diversity.", "configspace": "", "generation": 87, "fitness": 0.3594094713733982, "feedback": "The algorithm AdaptiveQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.8262242731270735, 0.7808709563426336, 0.8329849107709221, 0.8217496811312086, 0.8006446617673805, 0.8139773735381584, 0.8359518045459859, 0.8151325164669897, 0.796884374231248, 0.5991961899467559, 0.5881018299545613, 0.6171601902749486, 0.6124079028036507, 0.5875448900489779, 0.6344094172012484, 0.5649982408488946, 0.5738416448650776, 0.5990850385023736, 0.17378085646256225, 0.15663259146629827, 0.16876116015271714, 0.14397244672363463, 0.13084935462421732, 0.11798692373623565, 0.12060445359317618, 0.1369946501800523, 0.5416992844487865, 0.08787855913225107, 0.149731692341999, 0.14028197876996074, 0.1356738075894306, 0.1204691715441617, 0.11304119706268789, 0.1696785800842303, 0.14838724405830694, 0.11099247958153335, 0.9241148433808275, 0.9355211499670308, 0.9143605181340737, 0.9368758389369608, 0.9498683970319066, 0.8946234843223018, 0.9160909382926414, 0.934316415077824, 0.945123807142576, 0.6178560404578917, 0.5653564457423323, 0.6122254651585486, 0.5933643782355198, 0.572775102962604, 0.624503246851148, 0.5766038287046573, 0.5768297155271285, 0.5937153629524956, 0.7852007316081514, 0.22757588155880293, 0.8075612078854841, 0.8079912210799945, 0.2738034050204601, 0.7797592956671892, 0.7710229204063413, 0.7399472787104433, 0.7866216982670617, 0.27953996010714577, 0.11526668556150577, 0.2946150914643517, 0.2227523285556381, 0.27190283931425685, 0.33649929597043393, 0.38810241960494785, 0.3081150602208922, 0.2475549869053706, 0.3547169037369634, 0.29349396243368797, 0.2527344421113238, 0.26148778701149067, 0.2222865140121154, 0.42828373722878865, 0.2985568453727606, 0.26099260883019215, 0.21652134085960673, 0.12970549131974074, 0.1350701388089225, 0.15545280132681127, 0.1570848299220604, 0.16409313484018961, 0.12003220157159722, 0.1759095020864968, 0.12991408905638346, 0.16793813435943228, 0.24533116572386604, 0.2831968523028189, 0.28688639750837486, 0.28567025462017237, 0.22284849467431844, 0.2910423167804008, 0.2922568568362587, 0.3132042492974203, 0.29502682299384775, 0.12938088936442904, 0.13591764566547992, 0.06378957737627156, 0.0905151088647621, 0.06432420563704688, 0.15120425744147925, 0.25109581240569556, 0.08356524432195278, 0.1122956559919085, 0.21830213934116593, 0.20476310363885764, 0.24087942737666013, 0.23963093566526106, 0.24849149608329757, 0.2280687637217106, 0.18142636095089082, 0.21336130967372902, 0.1779722439966046, 0.5845917730624619, 0.5851028987267651, 0.6041221439346665, 0.6009385752335421, 0.5987291833687752, 0.5978068564969299, 0.6332713905463891, 0.6163204447290791, 0.5949382453731796, 0.12600892828223786, 0.13779441264998438, 0.12567394596637327, 0.13416144472605063, 0.13353926553801232, 0.14047769485513395, 0.13197526516347757, 0.12039217117845091, 0.11909880003195372, 0.23594078605669289, 0.22731504568116456, 0.19504213076051735, 0.4562874686051094, 0.31332405817994213, 0.2613598099821445, 0.25030929735405716, 0.2470371807458166, 0.13713948870633919, 0.4653896596833883, 0.48615787565652757, 0.39618385673913725, 0.49882288120465423, 0.44990943811071593, 0.4404282369144167, 0.4865172004029623, 0.5285058263761104, 0.4939801562418702, 0.3048107666058054, 0.2760095103820791, 0.2697160750110129, 0.2813730699606479, 0.2877915471855357, 0.401052595811214, 0.33808551973551526, 0.3525597167409076, 0.2291364876769345, 0.22959399308987571, 0.19258194952447416, 0.21075957590170158, 0.23405587752177914, 0.22353333021872734, 0.21785771936805143, 0.2577835629848805, 0.2317891984635625, 0.23776568254513075, 0.19528347036288052, 0.5848436820810802, 0.2372376280551114, 0.24215055083067483, 0.24503290854597082, 0.20419555856045768, 0.2013310856245213, 0.2022360009113333, 0.2057413410877934, 0.1757419533145569, 0.17667201205204586, 0.1803133755375006, 0.874482882457696, 0.1993171703817206, 0.19855454112245507, 0.1420290426344607, 0.8476792305611994, 0.8781017062002523, 0.8051200080251618, 0.21202107677124227, 0.7591831025627744, 0.771131439063794, 0.16669031061294315, 0.6419014015021158, 0.15451146118004455, 0.16789319654668833, 0.15315508832978864, 0.18547945671450994, 0.18593504438480846, 0.21184087259477458, 0.20038709093935636, 0.2004285088448663, 0.18123438483862664, 0.2227313657111557, 0.18772917239966913, 0.22105106977098155, 0.11239131063902819, 0.09574999961849384, 0.09179469668035423, 0.09340733507607313, 0.09786689270086157, 0.1078064821939606, 0.1020853946109288, 0.10617717382286518, 0.1036866563530543]}, "mutation_prompt": null}
{"id": "14aba19d-25e0-4867-a3ee-869bffb5173f", "solution": "import numpy as np\n\nclass AdvancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Adjusted for balance between exploration and exploitation\n        self.inertia = 0.5  # Dynamic inertia for adaptive search\n        self.c1 = 1.5  # Lower cognitive weight for broadened exploration\n        self.c2 = 1.5  # Balanced social weight to prevent local optima\n        self.mutation_factor = 0.6  # Increased mutation factor for diversity\n        self.crossover_rate = 0.9  # Higher crossover rate for robust exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_strategy_threshold = 0.3  # Threshold for fitness-based mutation strategy\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.full(self.pop_size, float('inf'))\n        best_idx = None\n        eval_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness[i] = func(population[i])\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = population[a] + self.mutation_factor * (population[b] - population[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, population[i])\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    fitness[i] = trial_fitness\n                    population[i] = trial_vector.copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adaptive mutation strategy\n            if np.random.rand() < self.mutation_strategy_threshold:\n                for i in range(self.pop_size):\n                    if fitness[i] > np.median(fitness):\n                        r1, r2 = np.random.choice([j for j in range(self.pop_size) if j != i], 2, replace=False)\n                        adaptive_mutant = population[i] + self.mutation_factor * (population[r1] - population[r2])\n                        adaptive_mutant = np.clip(adaptive_mutant, self.lower_bound, self.upper_bound)\n                        adaptive_fitness = func(adaptive_mutant)\n                        eval_count += 1\n\n                        if adaptive_fitness < fitness[i]:\n                            fitness[i] = adaptive_fitness\n                            population[i] = adaptive_mutant.copy()\n\n                        if eval_count >= self.budget:\n                            break\n\n        return population[best_idx]", "name": "AdvancedDifferentialEvolution", "description": "Advanced Differential Evolution with Adaptive Inertia and Dynamic Fitness-based Mutation for Enhanced Convergence and Diversity.", "configspace": "", "generation": 88, "fitness": 0.2267022009536035, "feedback": "The algorithm AdvancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.5563455297807409, 0.5455733577440385, 0.5152092042729581, 0.5639205396664937, 0.5636984174686316, 0.570926795286502, 0.570386485319677, 0.5486076014311531, 0.5861358183713199, 0.2541578705881984, 0.24430692622355965, 0.31434336417167563, 0.27959357375433325, 0.26965167015694647, 0.25807502109545377, 0.25359131521346645, 0.26242587331222433, 0.2984525946473854, 0.10502939117455623, 0.0760401907449787, 0.08995277389827294, 0.09137083780263533, 0.08431848991043756, 0.08619402715718139, 0.08842456805735, 0.08056444236374549, 0.08739349907530736, 0.0773841883324905, 0.08053791089993534, 0.07000815334168131, 0.08595574449012056, 0.07908168835765883, 0.07719217565394032, 0.06841336428727196, 0.10358155996612273, 0.07721300585450941, 0.8133189721048475, 0.9275594345844861, 0.7485574765655014, 0.7849077475081996, 0.8343880952385699, 0.7748478764598106, 0.7100734921827851, 0.8186100234073845, 0.929979125527842, 0.22392675905734394, 0.20558349452749547, 0.21547712296474408, 0.19126182128468527, 0.18551872106199385, 0.19850655292353114, 0.2754936347604756, 0.27182040561286147, 0.2328736463705141, 0.44368410839424754, 0.49348442847785967, 0.5307634159701804, 0.5632837876223176, 0.42348609560751593, 0.36901395480519594, 0.44735690823467333, 0.4042106551409578, 0.41167329899886596, 0.15002165792864053, 0.14289036271781064, 0.1440420424572858, 0.17798763298186893, 0.12878327964950875, 0.14406883517787805, 0.1517494990783611, 0.1797621598760406, 0.13178338148586022, 0.0808775964801951, 0.11684040551623276, 0.16040999885488094, 0.12763158497988003, 0.12203688618775144, 0.1495507083826324, 0.13554530218399008, 0.13723656222844838, 0.1379253822443849, 0.07578556836394112, 0.13610921021294486, 0.09240736686684281, 0.07707463371303058, 0.09405518390681611, 0.12003008273066373, 0.09704423199445844, 0.12607868674092804, 0.12478266393714899, 0.21844162389905686, 0.21062618061859806, 0.2353961245352174, 0.2675764425981014, 0.2491697159594315, 0.22891505234325638, 0.2543654225685694, 0.29741823707865067, 0.26070288493835414, 0.025172000059638044, 0.023863540065621414, 0.011399610727634402, 0.03364315669644524, 0.009809396905303025, 0.01707265843202055, 0.016727722633863462, 0.015686556379943983, 0.012526678289601634, 0.14418784752230696, 0.13915235455723085, 0.12406981405767659, 0.14489250732921533, 0.13739679590704146, 0.13514739980011803, 0.1332322367996036, 0.14286051265794608, 0.1445617223183583, 0.45122509318907567, 0.45234108455458477, 0.45756178750380716, 0.45416250293708604, 0.4581358096376089, 0.41904792675929536, 0.44069530421148073, 0.4164673135442677, 0.4479707439918732, 0.08252350341010806, 0.0708099113315167, 0.08112147097858358, 0.08330578208404404, 0.08128295430386734, 0.08881469088279359, 0.07670133040886762, 0.08568545029946928, 0.0799171611783056, 0.14712480857891985, 0.1258035107885488, 0.12482399933240373, 0.12091436609245176, 0.14729806687019587, 0.13659305221239915, 0.13509450818719393, 0.11717877590358361, 0.12480782283067693, 0.25009937556668005, 0.25436465825173693, 0.27182978444405814, 0.24452439689010363, 0.2629277853738883, 0.2604089995177862, 0.25875668869746327, 0.25934287330437333, 0.2675632105602408, 0.1868992658839841, 0.2013781105007637, 0.19522286564608193, 0.17153326322287665, 0.17407709365773805, 0.19887488660753894, 0.21706636288010883, 0.19899133967357308, 0.20375918887564126, 0.19188756538364948, 0.17993659810742613, 0.18337133471542189, 0.17850522409283476, 0.17162181385834296, 0.17733866375172747, 0.23289498499075845, 0.17273178479177187, 0.18610785823892828, 0.17260872119782056, 0.16848064137830188, 0.16913463119309402, 0.1706695497822901, 0.165873906645293, 0.16725216276983046, 0.1826812719272436, 0.18783746262567014, 0.17723735303318078, 0.1694510313638804, 0.16811800874929872, 0.3505034637037151, 0.2476791393217116, 0.29232135094928824, 0.23691843631278442, 0.18465422058656766, 0.1534010285480385, 0.3351796337654942, 0.1902544824600072, 0.18721076826093375, 0.17635877937381628, 0.16464171200465805, 0.19279759044458955, 0.23514519141436463, 0.20228127875856838, 0.29145641308389714, 0.20657888873113517, 0.18476336496899204, 0.1792983450154534, 0.1911767064565446, 0.17044552007089064, 0.17936622125216128, 0.19706290339925536, 0.181368852563638, 0.18719638790632176, 0.18323450472531877, 0.06598640383087928, 0.06911658840524326, 0.058566351363848246, 0.07187448833115673, 0.06766456444177915, 0.06694505851062571, 0.08170713141866803, 0.07174676179735484, 0.06375929582117568]}, "mutation_prompt": null}
{"id": "8fea1583-ec6c-418e-a32c-800e83876ddb", "solution": "import numpy as np\n\nclass HybridDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for better diversity\n        self.inertia = 0.5  # Lower inertia to enhance convergence speed\n        self.c1 = 1.5  # Adjusted cognitive component for individual search\n        self.c2 = 1.5  # Balanced social component for coordinated exploration\n        self.mutation_factor = 0.6  # Increased mutation for wider exploration\n        self.crossover_rate = 0.8  # Slightly adjusted crossover rate for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_factor = 0.9  # More flexible velocity clamping\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocity_clamp = 2.0 * (1 - (iteration / (self.budget / self.pop_size)))  # Adaptive velocity clamp\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "HybridDynamicPSO", "description": "Hybrid Particle Swarm Optimization with Dynamic Adaptive Strategy for balancing exploration and exploitation.", "configspace": "", "generation": 89, "fitness": 0.3507314917452593, "feedback": "The algorithm HybridDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.8164022247221193, 0.841628082920419, 0.8076423444945816, 0.820369990709639, 0.819012110388752, 0.824990658428262, 0.8350226299915664, 0.8406694502114159, 0.8246783946415022, 0.60944325476299, 0.6059150389846792, 0.6040750394095058, 0.5927368000192906, 0.6380156233764017, 0.6249772604059061, 0.5988327205028401, 0.640115230380702, 0.627496343394087, 0.1501097731658363, 0.12506492998844965, 0.14502909598867741, 0.11907158950873886, 0.1208128491854622, 0.15269514370822257, 0.1275767125193199, 0.15040985703229415, 0.5919971342270193, 0.10540761716966085, 0.15832077125603194, 0.10913790771432907, 0.13325992690359978, 0.16292098496296148, 0.14306331642735381, 0.11367264297106705, 0.1457693632099064, 0.15102730408521325, 0.9563226249615597, 0.9455161458211266, 0.9432573947996802, 0.9328741377070311, 0.952555536359694, 0.9359457778033028, 0.9456727803918916, 0.9288879878027815, 0.9462514763141633, 0.6071846704783328, 0.6672253629565131, 0.5890589095389138, 0.6237341740709907, 0.6245214781629878, 0.5968002881642447, 0.595759915898542, 0.08757919138968229, 0.5960415436219515, 0.7806494812688827, 0.7628752555430711, 0.8026916428076966, 0.27613603825907973, 0.2117788461092991, 0.2118450165040361, 0.7488982781361753, 0.2315462244677886, 0.7629722687932747, 0.22152867009692367, 0.22315815391790061, 0.27073730443731414, 0.12731306921050944, 0.30318573797050363, 0.12829657339075962, 0.21256002564387533, 0.25929051399158576, 0.35135275790977905, 0.2691112223428125, 0.327061550654163, 0.2565221483889236, 0.26871780178335414, 0.24202348473367885, 0.22705546405454757, 0.27224746009498335, 0.2855936553675297, 0.27935345640249676, 0.07482471814129876, 0.12033974998787433, 0.10322961941463471, 0.036723293242395094, 0.061785283585793827, 0.09049319490025753, 0.05770511546648105, 0.12263559434329396, 0.07784668576844778, 0.1996977159321892, 0.1581278200415558, 0.222280507760518, 0.15014238908710686, 0.13292410917208908, 0.15713253278406902, 0.2349638024154279, 0.23181612617842706, 0.20922014527689914, 0.11958009875226183, 0.1841846147875501, 0.08569008422758251, 0.20255309250140463, 0.07103757171001757, 0.07130181138533898, 0.19326374872860297, 0.10289943209894159, 0.14073607143028133, 0.2045556010802505, 0.16025121784566798, 0.30465278415806374, 0.10878768003173611, 0.20162741406344586, 0.20276519765802414, 0.23963029486175857, 0.04747728013116326, 0.08843186245572121, 0.5843344157124251, 0.5769686349058862, 0.5487182013818356, 0.607614096293738, 0.5692054717428254, 0.602915418951987, 0.5971952798055222, 0.5780067271027607, 0.575835663363506, 0.12154617002805457, 0.10943702549276346, 0.09054297822317947, 0.15392366315396522, 0.11908192692324449, 0.12519618829746848, 0.10406007097319248, 0.10603109362856122, 0.09702173611271958, 0.3856542700892064, 0.23811365400959372, 0.20334911553834567, 0.23893540087179976, 0.2345456606478329, 0.256229717946745, 0.2468038198683684, 0.5770220874076624, 0.3419751834754483, 0.26344806717406377, 0.2613563450792883, 0.3354835026910359, 0.4851105195809168, 0.3776694342715812, 0.42380779561721293, 0.5523180999181884, 0.4956277117915615, 0.49165906632299616, 0.2860002838812611, 0.31678917229490666, 0.28483388242824526, 0.39800684844368284, 0.2727402282723308, 0.31785063253979495, 0.36206440370372595, 0.31631857966902255, 0.321561729973608, 0.21885159734462556, 0.20752801950985345, 0.2049462758455921, 0.2269888070150926, 0.2515516455992314, 0.28656580599977743, 0.2833382478361045, 0.20958408527544836, 0.2152862063381441, 0.20599622313806054, 0.21475067877549503, 0.19542277066670066, 0.2444428816921581, 0.5096107395877312, 0.24798817535780804, 0.18825958102450524, 0.6510477007827724, 0.2400212409615916, 0.1768135187495392, 0.18677798723903127, 0.18263471769619444, 0.898858268587575, 0.19986887811674703, 0.16824666077009076, 0.8220842398810131, 0.16754447077176104, 0.8772081716769092, 0.8256609608875614, 0.21200834831865767, 0.8379720000617272, 0.7984179894230359, 0.21023713089286067, 0.16598635498637426, 0.740774828254489, 0.7213261548957068, 0.7695642815889658, 0.21332059710937, 0.19188558266273426, 0.189397933918675, 0.1745321437038443, 0.1789304812114213, 0.18369199092689115, 0.21653357491630454, 0.18877899468237325, 0.19662843748015013, 0.10082157795181612, 0.08461670233208607, 0.10016520881125102, 0.10093706651148371, 0.10436103937299834, 0.09822149000272506, 0.0970786458990166, 0.08642925374994992, 0.09621999688221328]}, "mutation_prompt": null}
{"id": "cbe33890-fdcc-455b-b3b2-65e2d3284b81", "solution": "import numpy as np\n\nclass HybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Larger population for better exploration\n        self.inertia = 0.5  # Balanced inertia for improved convergence\n        self.c1 = 1.5  # Moderate cognitive component for personal search\n        self.c2 = 1.5  # Balanced social component to avoid premature convergence\n        self.mutation_factor = 0.6  # More aggressive mutation for exploration\n        self.crossover_rate = 0.9  # Higher crossover rate for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_factor = 0.7  # Slightly more restrictive velocity clamping\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocity_clamp = 2.5 * (1 - (iteration / (self.budget / self.pop_size)))  # More adaptive velocity clamp\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "HybridPSO", "description": "Hybrid Particle Swarm Optimization with Adaptive Local Search and Dynamic Mutation Strategy for enhanced exploration and convergence control.", "configspace": "", "generation": 90, "fitness": 0.3666271826016664, "feedback": "The algorithm HybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.819708363721735, 0.8264179807453635, 0.8039006952776854, 0.8025372599545567, 0.812085416382775, 0.8066300870169285, 0.8177871313862727, 0.7875651189029521, 0.8076744701952605, 0.6130342469709121, 0.5618076853706601, 0.5718643100443827, 0.5731712304464425, 0.5623670137295246, 0.5904706898315383, 0.5354340204256403, 0.5805550263796297, 0.6140686878585195, 0.11504090908468079, 0.1214945812787166, 0.1245140312012063, 0.14368598909190133, 0.12009362200678275, 0.16783996315420557, 0.1489519729883697, 0.40018835613128445, 0.13154217601188245, 0.11495029063716844, 0.16448843686575843, 0.11351211938788597, 0.11299050988409731, 0.1332422042960657, 0.1342604118102001, 0.16263258507360967, 0.12617941049349812, 0.14347733695857456, 0.9445510893384272, 0.9484000994041665, 0.9507127561494654, 0.9535363837096865, 0.9519677690374447, 0.935142659761889, 0.9490835917493807, 0.9514265914579338, 0.9553165642685968, 0.6233034849905836, 0.5687920754262206, 0.5297557465231963, 0.5721660256249996, 0.5750008484309496, 0.6002014150660653, 0.560673965821012, 0.600311027968434, 0.5800279789756062, 0.7544012479292506, 0.7502178623650813, 0.8270543747095035, 0.7114630643378652, 0.8416039393743686, 0.8107468599342457, 0.7488052355185756, 0.8563508535693793, 0.7815787526020681, 0.23806594649572566, 0.22380947096521464, 0.255351356538159, 0.2873323613329951, 0.254163562455461, 0.3136957620127476, 0.1312432527695726, 0.2526663569333918, 0.2430177278093113, 0.24827570612259053, 0.30462850533958263, 0.2043262132539032, 0.35505325976028146, 0.27654878484851464, 0.32644666710592196, 0.31170305154939615, 0.29838447153353476, 0.25679143026245654, 0.15570757022823234, 0.13609886161440277, 0.12591286080356334, 0.14979864236405138, 0.15420680018995625, 0.1719450695306456, 0.13891193833431392, 0.14995077550082658, 0.12697301316319776, 0.3235591561580289, 0.25876574767750093, 0.2724416756267465, 0.2577427272211268, 0.24329047441694263, 0.23307392453096532, 0.27539079540432054, 0.3143400639660293, 0.2705633427341345, 0.04358177872320235, 0.226251843233936, 0.05890783714217884, 0.11893820050116233, 0.22874380052189158, 0.10699510867057327, 0.13157735297113538, 0.14757503236253866, 0.11344997104581145, 0.23371108771704463, 0.18472903028961485, 0.2538110985949249, 0.19780062499123385, 0.2754849602140671, 0.21005082916734918, 0.20390568009860222, 0.19647449679624018, 0.08035679193396206, 0.57647115550549, 0.6116832774835101, 0.5889713184143239, 0.5825409331638984, 0.6069992744915471, 0.577162870352202, 0.5891069677442006, 0.6025048758912077, 0.5969689499984391, 0.1282188476380266, 0.14142382512485396, 0.11293014161333736, 0.13631115745061417, 0.11722648661396196, 0.14847661872506346, 0.112876362025922, 0.14126391857698584, 0.09532261150950727, 0.3214969773013501, 0.22865690354589552, 0.45453483798530825, 0.5416859060428858, 0.2560640204950363, 0.3497098571095817, 0.19813454266692065, 0.17787129378839417, 0.4383218473788524, 0.33763501554340225, 0.47133182790266115, 0.5042434050116499, 0.4321231616821759, 0.45809831723301964, 0.40300370046974476, 0.5012826316841493, 0.519149909227682, 0.44421375351237835, 0.30104236477880975, 0.26558495803337023, 0.41628378232855245, 0.27667586634161667, 0.3542749543037874, 0.2902661422972036, 0.31670649799690975, 0.42465252005407617, 0.3595185484559281, 0.21916727788563828, 0.22071274513639227, 0.22934601892075546, 0.20596600632717277, 0.222930644416242, 0.22161629769222824, 0.2162233247362526, 0.20028777548853605, 0.2041406198493697, 0.24707837991497972, 0.23969751299531272, 0.20342616316098705, 0.2181222818717099, 0.22520991494730203, 0.24469350361342423, 0.22333813213699416, 0.20631018573384918, 0.19695632446515354, 0.8912220657728641, 0.17555555359855257, 0.15272486016190234, 0.8896602097950375, 0.20011262131339835, 0.169243964891707, 0.14151135782442548, 0.8746549061287263, 0.8828422446651502, 0.7565447339764776, 0.21140295024717437, 0.7676168200499326, 0.4526297666007877, 0.1524157169291246, 0.15413725000013978, 0.7404117449381695, 0.16735961152772272, 0.7745478085889738, 0.18855986769581534, 0.18557154810927146, 0.19973359653813716, 0.1997840010644737, 0.1873398320786418, 0.19565170633837115, 0.19479701243449732, 0.20814555609351337, 0.21244927947473635, 0.09607256730057723, 0.09283801914430967, 0.08790857822174236, 0.09630577725966472, 0.10538081602951965, 0.10617507345959298, 0.08956000495822936, 0.08778943809420048, 0.09728887929736152]}, "mutation_prompt": null}
{"id": "cf83802c-cc06-4eed-8b12-6a5ae30e3149", "solution": "import numpy as np\n\nclass AdaptiveQuantumMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40\n        self.inertia = 0.7  # Increased inertia for better balance\n        self.c1 = 1.5  # Adjusted cognitive component\n        self.c2 = 1.5  # Equalized social component for balanced influence\n        self.mutation_factor = 0.6  # Slightly increased mutation factor\n        self.crossover_rate = 0.9  # Higher crossover rate for more trials\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_factor = 0.7  # More adaptive velocity clamping\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocity_clamp = 1.5 * (1 - (iteration / (self.budget / self.pop_size)))\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    quantum_rotation = (personal_best[a] +\n                                        self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    quantum_rotation = np.clip(quantum_rotation, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            quantum_rotation, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "AdaptiveQuantumMemeticPSO", "description": "Adaptive Quantum-inspired Memetic PSO utilizing Quantum-inspired Rotation Operators for enhanced exploration and convergence.", "configspace": "", "generation": 91, "fitness": 0.34535535214574875, "feedback": "The algorithm AdaptiveQuantumMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.7372892495428871, 0.7467471762236495, 0.7102275594939013, 0.7205973507889001, 0.7367408416373498, 0.7491453811328947, 0.7242209005819652, 0.7534852932964138, 0.7394412187938463, 0.4116842949526571, 0.40364219977778903, 0.3576199507278367, 0.38557052377117207, 0.41287264295683934, 0.3978458214935455, 0.3664508117500257, 0.3809038470237657, 0.3959734104810334, 0.1342222262047571, 0.1448100316913027, 0.17873165706431648, 0.12476232317104163, 0.13169104185814018, 0.14260571237777186, 0.13615332117943724, 0.17242324115355345, 0.1691234251161875, 0.1375367310407799, 0.12942462025574386, 0.10863574147329202, 0.1302875264253356, 0.15952702021722875, 0.10206625390811974, 0.12590835341832718, 0.11169057594292897, 0.14713511231610865, 0.9381987533580814, 0.960470287515818, 0.95546799529553, 0.9477012789497441, 0.9474296162377677, 0.9550136261071002, 0.9594029325865822, 0.9427233361073919, 0.9682944168440838, 0.4273273192254424, 0.4508341896101845, 0.466804958901498, 0.4314405986065739, 0.4479359938947779, 0.4446571939339775, 0.4714219290999553, 0.4476683349859001, 0.44108966695463836, 0.7398216034318722, 0.7044353114520714, 0.7523888303416597, 0.7120497720666124, 0.762696047438564, 0.19189139055798732, 0.7784386086671489, 0.7567617855679749, 0.7338956369433808, 0.31974189452765955, 0.28257839657199235, 0.24177172719331796, 0.2358753934332064, 0.24652844370878324, 0.26653397929206535, 0.29350903668575246, 0.244103360060001, 0.2778594545750611, 0.2960406386809643, 0.3595177364091795, 0.2244685405508582, 0.29460599083442696, 0.2344141878959607, 0.3136411923826967, 0.307390095337288, 0.32369887977833456, 0.31945423636783854, 0.20844457742587363, 0.15015595822666106, 0.20327900582032365, 0.1816815368450193, 0.22376229643657597, 0.18178384308784712, 0.18565159117806462, 0.2061225637533054, 0.20294326861260725, 0.32981927551328194, 0.2834690899050414, 0.27665707218450286, 0.29781069618047495, 0.2668743017288704, 0.27821229251315294, 0.3843183807130892, 0.3503013654091274, 0.35006019998285365, 0.074077443876016, 0.038462800220542714, 0.05282794184912487, 0.05333793802615494, 0.14813885660533377, 0.03646677506764795, 0.08263781450587071, 0.058736946954540126, 0.06498671150116409, 0.208119971709827, 0.18424641920818507, 0.18401747141066316, 0.21031380723054027, 0.22572637905941206, 0.19275720751349745, 0.20223773395491274, 0.19080677364339482, 0.20882009914174315, 0.6010667005517728, 0.5974453926503214, 0.5849041684959184, 0.5456244143706639, 0.5718906254512733, 0.5837246242458473, 0.622362952712571, 0.5774897775625627, 0.5812286877456232, 0.12084161044725328, 0.12423371340098055, 0.11806070516657019, 0.1667358146826553, 0.12356615114131309, 0.13380152331818684, 0.1212667294960913, 0.1194771948600144, 0.10812332605695263, 0.4003326811804535, 0.2193391117744009, 0.1920750762061294, 0.2377459925784603, 0.18250705738665596, 0.366495810818635, 0.22712652125135213, 0.1660181972422089, 0.21673025683404334, 0.40603711310456925, 0.38464742729744206, 0.3960541511486858, 0.36056721724504726, 0.391399882253578, 0.4135441671796757, 0.39540735055142207, 0.4257953210452311, 0.3901301895610232, 0.28010585084130246, 0.28105778953693294, 0.29787937737984604, 0.3231137588431141, 0.2957260457111498, 0.3101963940635437, 0.30758441746065057, 0.3372502782426656, 0.2890160378018334, 0.22322595238524046, 0.20742712636776506, 0.22775155481293408, 0.2220687655784711, 0.2046544091386696, 0.2255591495906064, 0.20891874403059918, 0.24686919233556248, 0.21689342292697145, 0.20069959904173695, 0.213170283631418, 0.21552450875620466, 0.5108775342671061, 0.48827383205277075, 0.215968730133694, 0.19959270271647545, 0.23942176623527667, 0.23456946573536486, 0.7408315350655211, 0.1754848281778768, 0.19688235078769356, 0.8351525718418368, 0.19802283689518596, 0.19906655273465546, 0.706154547667674, 0.8343964387909993, 0.8579802218537185, 0.7845298287171991, 0.7414746705115508, 0.8363423163084314, 0.2076108107739717, 0.1684029768842723, 0.7730166014633124, 0.10445810992513616, 0.16642112249861696, 0.7291890399447541, 0.17806915253817712, 0.18037842494627965, 0.1788033040622824, 0.18555854131504135, 0.20432204154622424, 0.20537452155962987, 0.18724216611303102, 0.190082155894172, 0.17780695642263222, 0.10120519123333926, 0.10390794746104526, 0.09044900561439462, 0.09327923200152854, 0.07933946026277772, 0.09175876679381689, 0.09488344315452757, 0.08756625867271473, 0.10086341121043785]}, "mutation_prompt": null}
{"id": "db8a63a9-9d93-495b-8797-3b8f37b48935", "solution": "import numpy as np\n\nclass HybridMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for better exploration\n        self.inertia = 0.7  # Balanced inertia for controlled exploration-exploitation\n        self.c1 = 1.5  # Adjusted cognitive component to allow more personal exploration\n        self.c2 = 1.5  # Equal social component for balanced information sharing\n        self.mutation_factor = 0.6  # Slightly increased mutation for wider search\n        self.crossover_rate = 0.8  # Standard crossover rate for diversity retention\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_factor = 1.0  # Fixed clamping for consistent velocity control\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -self.velocity_clamp_factor, self.velocity_clamp_factor)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "HybridMemeticPSO", "description": "Hybrid Memetic Particle Swarm Optimization with Dynamic Learning Strategies for Improved Global Search Efficiency", "configspace": "", "generation": 92, "fitness": 0.31835597866617854, "feedback": "The algorithm HybridMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.7027575060555538, 0.707486694011423, 0.7069022181357869, 0.7101075600953225, 0.6923021865986609, 0.7276751293023405, 0.6894752529353889, 0.7122069779373741, 0.6753735374056411, 0.3661763018394786, 0.335646635552864, 0.3205312448216542, 0.35774983191512433, 0.30416583009256837, 0.29905001206037063, 0.3305048680170668, 0.3125363821383408, 0.29620132091441387, 0.17678456856846603, 0.16908136658825568, 0.08953797631224081, 0.13116340902921597, 0.14247172488032922, 0.1327866312665963, 0.12219011678471325, 0.1591405585189719, 0.14779782864602709, 0.12854280968523835, 0.11775537508791256, 0.13918479327806976, 0.29345314277258217, 0.158295545178184, 0.1184799762029548, 0.0991210258808134, 0.13301119475494527, 0.14246878641373983, 0.9338258434185492, 0.912331345812411, 0.9200255050153253, 0.9324682589012417, 0.9205500152543421, 0.9209580665116697, 0.9249825289697984, 0.9044209810505773, 0.9280943368077736, 0.46648825812321815, 0.4150674354890489, 0.42533213503539813, 0.4027345439181902, 0.4012239993751563, 0.43357803058371247, 0.42627410072806693, 0.44791871866583666, 0.4251814935568986, 0.7932012470149563, 0.6976382456764264, 0.6076837293240546, 0.6765065956919905, 0.7041197700443305, 0.6780538273450037, 0.7326760737668766, 0.537348138384665, 0.6356687235092722, 0.21217899817467778, 0.18711611070966083, 0.19643157658866073, 0.2924756596919351, 0.2115272851668396, 0.20934934544179817, 0.25195863835539056, 0.20742467121478192, 0.21021857301370683, 0.17851815347537536, 0.18446134319614305, 0.2078247539571072, 0.22273656138040976, 0.12540151709774638, 0.2222255181021202, 0.2622086043552676, 0.2640544224280691, 0.2435556569043914, 0.09415830162261751, 0.10821573097312664, 0.07053060943335931, 0.04661684930127763, 0.05413779464281199, 0.06289836429371609, 0.09728242150071564, 0.07176676050298814, 0.06409718349515348, 0.19630032017425336, 0.17494061153202567, 0.23128838837799504, 0.19084973766251379, 0.1537410178326647, 0.1651900800802667, 0.21061364016915518, 0.2135797812533916, 0.208436566884747, 0.04491020551243763, 0.08310189591431938, 0.07820748507635367, 0.04757826055178216, 0.07918393508608823, 0.07691474260390663, 0.07085496925525947, 0.03917611022563783, 0.02635383242481426, 0.14394739010210833, 0.1489492989137272, 0.21044015121571513, 0.12821349845188412, 0.15714300703458906, 0.1722957908069478, 0.1658398201794704, 0.11030075079829516, 0.1293424616638087, 0.5035542193073889, 0.5063421049857415, 0.5156962346388048, 0.4911448469214533, 0.5101821147595185, 0.532712742555731, 0.5139148142223862, 0.5183541092329679, 0.5313219530533051, 0.11397628828217843, 0.10035996948720716, 0.13607839447924963, 0.14562894713383134, 0.12156152801772568, 0.1344589844726677, 0.15306583397069917, 0.13361341501067125, 0.1195614480088365, 0.2400059490419022, 0.2588748934126597, 0.20474995383283867, 0.28479353019467546, 0.3039587183274789, 0.30376111941238504, 0.3559239306267883, 0.18448540250940937, 0.23000883819177187, 0.37639706679491647, 0.37135900290752166, 0.36069093727317136, 0.393824242217896, 0.36099547567365553, 0.3813293177689774, 0.3896147611589851, 0.39993953684596373, 0.3655764329856681, 0.27895607587006166, 0.26303076166895667, 0.24075719804710405, 0.27267338217347303, 0.27229652765652357, 0.29966484944988037, 0.31156807746326476, 0.324813282220887, 0.2926560358619359, 0.23765339237692396, 0.2143000310669433, 0.20535055265768132, 0.21785084295103574, 0.22522155135880917, 0.21985500913673361, 0.22376273108390599, 0.23991972708102416, 0.26345483836618, 0.4134295267163791, 0.19633211207485335, 0.19773205424733664, 0.5329263902348992, 0.20283478367993002, 0.2054021692730924, 0.21537070032787353, 0.22580330258597614, 0.36978688363916645, 0.8397505417660223, 0.1860376990670225, 0.16389697004965254, 0.8757891477015105, 0.198033367046888, 0.8084951350237659, 0.7690572139726709, 0.16594672487556816, 0.8287118454377135, 0.7423899356598067, 0.210238691229361, 0.6362330482584466, 0.20863883823786167, 0.20695737785566282, 0.20646404784307826, 0.7201898525342482, 0.7257843070342043, 0.7413395131043562, 0.19186920005458497, 0.20603487902322548, 0.18670969085368783, 0.19705395266027392, 0.19302091785520126, 0.18181561904183574, 0.19667209203504177, 0.1843304614379393, 0.18371876952052313, 0.09548055851421011, 0.10717929253671987, 0.09423611430864387, 0.09043420377488243, 0.09215166059208424, 0.08614610446172188, 0.08586227547715586, 0.09400447056773786, 0.08346360303596134]}, "mutation_prompt": null}
{"id": "a52c4aa1-71db-4848-8b0e-36a82bb7fe5a", "solution": "import numpy as np\n\nclass QuantumInspiredMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Adjusted population size for better diversity\n        self.inertia = 0.7  # Slightly higher inertia for improved exploration\n        self.c1 = 1.5  # Balanced cognitive component for steady convergence\n        self.c2 = 1.5  # Balanced social component for collective intelligence\n        self.mutation_factor = 0.65  # Increased mutation factor for broader exploration\n        self.crossover_rate = 0.75  # Crossover rate optimized for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_factor = 0.9  # Slightly relaxed clamping for more freedom in movement\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocity_clamp = 1.5 * (1 - (iteration / (self.budget / self.pop_size)))  # Updated adaptive velocity clamp\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles += velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "QuantumInspiredMemeticPSO", "description": "Quantum-Inspired Memetic Particle Swarm Optimization with Adaptive Memory and Dynamic Population for efficient exploration and exploitation.", "configspace": "", "generation": 93, "fitness": 0.3098831080383063, "feedback": "The algorithm QuantumInspiredMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.6892575160619581, 0.6989679308648094, 0.7026168060042036, 0.6978110429348522, 0.7206511633149206, 0.6908883294010083, 0.6787682991965478, 0.6839185891619373, 0.7422807600060655, 0.33331608365777543, 0.3859567046148509, 0.30231384995324184, 0.332798867966397, 0.3537632964351013, 0.3029000921700328, 0.3233266138850075, 0.34519182360055745, 0.3083656691685456, 0.31366676943643257, 0.3227152416708986, 0.16127704275799093, 0.14823905859147812, 0.13071092213793012, 0.1549655474384687, 0.12116947043686666, 0.1438176251939025, 0.1563173196482217, 0.13648201169185015, 0.12653481140235567, 0.12542768477217126, 0.23754805959125413, 0.13282212025331608, 0.12038633422504319, 0.11681469894669938, 0.11368839218568483, 0.10475805790787895, 0.9395308224255879, 0.9315318863839364, 0.9434980765134775, 0.94744252430568, 0.9394603814501192, 0.9177713094594153, 0.9483086532131003, 0.9248327293682969, 0.9338920792285786, 0.42182721070660756, 0.4138626669506228, 0.3950659431019129, 0.4146463278889061, 0.3899003989750709, 0.39416798510228634, 0.4092127219232029, 0.39585365761832325, 0.424632274682744, 0.5717321781560054, 0.5961402391420906, 0.7041212591042918, 0.6959790860179398, 0.5769120236585358, 0.6983538616486777, 0.6680040824924995, 0.6700760726829305, 0.6683268800681694, 0.1713669622527617, 0.3178022177640428, 0.19326537935017463, 0.1854002982657127, 0.1800013352556361, 0.18760291104542803, 0.19450150956434842, 0.21062433044287177, 0.21093224302239033, 0.1841893714032421, 0.16749636524959644, 0.23020311791401638, 0.21777387805477122, 0.21263531142557512, 0.17451843803069755, 0.23631473708354245, 0.23117866138902843, 0.22425074431059455, 0.041040112491612435, 0.04760978168851748, 0.09120645628030821, 0.05778789298637621, 0.03638562311058935, 0.0687558422245329, 0.033227315143919633, 0.04110911484560731, 0.06712631732277663, 0.20441293989455367, 0.14683362026435187, 0.20971452678383395, 0.1573782597207899, 0.10219955028272543, 0.15040530292197962, 0.17555298269115371, 0.15835650894764675, 0.21130113402178663, 0.09133580631948557, 0.07311666034228859, 0.017106080501416376, 0.08990053814418986, 0.08229194750930569, 0.022010113175492396, 0.07611350020388041, 0.08376131763689865, 0.05632462333529442, 0.17397731985131637, 0.12955097079297517, 0.16995779277176792, 0.15263225507574696, 0.21271040629884608, 0.1735924636165913, 0.13187624707110557, 0.08498550506796743, 0.13430083225334033, 0.49010271863638877, 0.49600066541952137, 0.5016504592528135, 0.4872991564893787, 0.5050182124313962, 0.48008877112137127, 0.5062941522790847, 0.49168861151111354, 0.5231677241405126, 0.11214646494337943, 0.12323789462780133, 0.12273673702254706, 0.12102512655077502, 0.11165188482301125, 0.13896524625452, 0.27842214930021325, 0.1144968269679364, 0.11424483095811033, 0.15747592812142341, 0.22744409861880965, 0.15066693076327187, 0.20171899979396435, 0.33763623703918944, 0.32946506344016435, 0.34392622633931924, 0.20184948445655881, 0.26526608227968496, 0.3553359545800344, 0.3458487826281452, 0.39661859577709613, 0.3825852893493811, 0.3481898690979496, 0.3516934342164686, 0.39459772171501906, 0.40088465496044645, 0.42004151254014355, 0.3041613664785954, 0.3055350515117776, 0.26471353175978396, 0.23897005103723445, 0.2219249586398826, 0.31617912655964064, 0.23905704040535725, 0.28372500950531576, 0.22196586512282257, 0.2205559209045086, 0.2073529444514567, 0.20974380467823994, 0.22808869874571913, 0.23376808988862063, 0.2436595107725118, 0.24310888022857458, 0.2406056296617699, 0.24189680735456331, 0.21458113840537063, 0.18713897805524315, 0.2077119104804287, 0.23000782836037748, 0.20268793355456738, 0.19829393018031982, 0.21030880874460234, 0.23428425943177578, 0.23194716193464915, 0.8126150480000329, 0.17672471842556547, 0.1513231443825902, 0.8306185816340395, 0.19902446684378905, 0.1685039578576374, 0.8288858693295346, 0.1661359134573115, 0.8567162540880344, 0.7444594949320347, 0.2088337039969289, 0.7212301385478064, 0.610416296240281, 0.6483819945723907, 0.20222216307995, 0.6874603918440847, 0.16749579688815652, 0.7057979704483364, 0.18345839161938216, 0.20111378518945522, 0.18073967405862879, 0.18601461938062347, 0.19455548663815003, 0.1817292918487462, 0.17661617931347995, 0.19179971756434067, 0.1757617780894689, 0.09373076575708505, 0.08625284091498853, 0.08601189810424403, 0.09047253197782634, 0.09210640704821615, 0.11587483165465451, 0.1301085346793931, 0.08967973418641928, 0.09889881600923323]}, "mutation_prompt": null}
{"id": "749faa5d-f3a7-48c4-8e47-367833178596", "solution": "import numpy as np\n\nclass QuantumInspiredMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for diverse exploration\n        self.inertia = 0.7  # Enhanced inertia for robust balance\n        self.c1 = 1.5  # Balanced cognitive component for better exploration\n        self.c2 = 1.5  # Balanced social component for cooperative dynamics\n        self.mutation_factor = 0.50  # Reduced mutation for stable convergence\n        self.crossover_rate = 0.9  # Improved crossover rate to explore solution space\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_factor = 0.75  # Consistent clamping for steady progression\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocity_clamp = 1.5 * (1 - (iteration / (self.budget / self.pop_size)))  # More adaptive velocity clamp\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "QuantumInspiredMemeticPSO", "description": "Advanced Quantum-Inspired Memetic PSO leveraging Quantum Superposition and Adaptive Strategy for Diverse Global Exploration.", "configspace": "", "generation": 94, "fitness": 0.33249195427539086, "feedback": "The algorithm QuantumInspiredMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.6612486235622985, 0.6762057028505488, 0.6646009688397135, 0.6742188813371551, 0.6681056268646463, 0.7122460547386524, 0.6701317547777599, 0.6629263628819957, 0.7014232987510622, 0.3232461392977096, 0.3382808554868889, 0.31409694451207226, 0.3140058504603196, 0.3553232155040321, 0.33097438716180627, 0.29644897513794655, 0.32548967225914216, 0.36050921447112494, 0.18088030860496662, 0.14843474623508612, 0.2709582006882407, 0.15811747678719767, 0.1691786750022386, 0.12412541938395949, 0.09594055303565563, 0.12927194878625992, 0.1345370305444592, 0.12522437039090817, 0.10799001473335557, 0.12634022371016818, 0.13916831025427379, 0.10391609779316202, 0.12101444463899935, 0.13720824657552344, 0.10820818125792198, 0.13195801365393467, 0.920879960436647, 0.9409613371723492, 0.9463532860109061, 0.9466627346426952, 0.9402612067935452, 0.8991389715496585, 0.9404550355456363, 0.9144586544212527, 0.9237173229673473, 0.42007714022876796, 0.38212453450980555, 0.4105874843679851, 0.42001494683195384, 0.39972600041848805, 0.4292220791115142, 0.42236727637381877, 0.41018488291331656, 0.3894733091456214, 0.7558902121607832, 0.748047895674415, 0.7842601943064922, 0.7152662934614519, 0.7224774399224028, 0.7316114750473184, 0.6136498479037017, 0.6758523349030938, 0.7059629105482863, 0.19600436187882186, 0.18555914157885234, 0.1934849632559955, 0.2110448160536489, 0.19979894196029901, 0.12289415481832167, 0.23556617795747947, 0.2114263056915343, 0.2158828771702025, 0.2369488150366097, 0.17666639133495443, 0.24090455047191228, 0.2655991915465472, 0.22585864064615635, 0.24235703835095568, 0.28933395783633165, 0.2577528138040447, 0.34831811694805526, 0.26752899369048333, 0.2393008532776264, 0.21072709992561645, 0.10118933940691854, 0.18516187651678107, 0.15453964882949145, 0.16726989462884667, 0.1921094632386866, 0.20286270624446812, 0.330696956784861, 0.33545808860034665, 0.3152286541770778, 0.30313663680870195, 0.31661472982358607, 0.27936893373392657, 0.3373319985168949, 0.39005248352624067, 0.3237054999370643, 0.06236561621435399, 0.07069712093727809, 0.11991439866166931, 0.1043138750492395, 0.11488055165927402, 0.095418383085216, 0.08260319628054547, 0.07591223235429811, 0.10222977307770853, 0.19322174495838185, 0.19933146269974567, 0.2073615862432444, 0.2067630931369011, 0.207579588500985, 0.21187696875723083, 0.1778485972512973, 0.18058552046751097, 0.15705101554678003, 0.5722005458497756, 0.5480362110617745, 0.5543166068870264, 0.5394254686784468, 0.5664935053114848, 0.565024359468731, 0.5689538329136155, 0.5672900396860422, 0.5580012304633917, 0.13087067103446515, 0.13507408689123712, 0.14345734544875954, 0.14954326838924714, 0.1309482242248945, 0.12696272248187657, 0.1120214575649181, 0.13247985161360643, 0.1475401275576993, 0.4063749045639684, 0.2559798116405553, 0.2559536224355795, 0.15028183201661127, 0.33070355144385843, 0.1708185344658123, 0.22023612033121598, 0.3761181973514305, 0.27019175342420365, 0.37413746161679895, 0.3638024261032955, 0.35812322868580526, 0.3736172757765861, 0.37220064201041336, 0.38788846287072787, 0.39915578006780483, 0.4107852531866024, 0.39299584250146635, 0.2835274094301887, 0.2882027872975337, 0.28026212882099777, 0.2762900294742452, 0.21919651165739817, 0.27024841994778914, 0.2567125527060602, 0.27960797587698605, 0.3036298989152857, 0.2324537387290786, 0.25912470960934497, 0.21710078449814796, 0.21099018416947246, 0.21060268051015596, 0.23850381493602335, 0.22003829005137332, 0.2531157997202176, 0.2345450270128977, 0.3874303510508179, 0.20198304428938896, 0.24140391686099583, 0.36170918069669555, 0.3216671295350738, 0.20014433210482618, 0.24326791983215024, 0.22085914742052226, 0.21044236433932417, 0.8143697460663559, 0.18627128272796212, 0.17308155238453493, 0.848058037262033, 0.19881136782694453, 0.1680758470177851, 0.7611725153560471, 0.8388166598168281, 0.8318476177136039, 0.793116216056247, 0.21091459045013816, 0.7462724531863973, 0.7845618978919372, 0.7366195498829686, 0.15316712796127718, 0.20852701054575296, 0.16779641197023376, 0.2087173413374609, 0.1953269290715296, 0.19943615925008118, 0.19168215464563587, 0.19600430090051013, 0.19663245417412656, 0.18733048794443474, 0.20026739883385258, 0.1860116125779656, 0.1869852729971473, 0.0899611553406987, 0.08402604005917125, 0.09416026765898511, 0.09598236199420229, 0.09173558221066846, 0.09993653369649314, 0.08342096664075593, 0.09234625438147681, 0.12647518290902904]}, "mutation_prompt": null}
{"id": "9fa62cae-437b-435f-9f25-5091d99f49eb", "solution": "import numpy as np\n\nclass AdaptiveMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population size for better diversity\n        self.inertia = 0.7  # Slightly higher inertia for improved exploration\n        self.c1 = 1.5  # Balanced cognitive component\n        self.c2 = 1.5  # Balanced social component\n        self.mutation_factor = 0.6  # Slightly higher mutation factor for exploration\n        self.crossover_rate = 0.9  # Higher crossover rate to exchange more information\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_factor = 0.9  # Progressive clamping factor\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocity_clamp = 2.0 * (1 - (iteration / (self.budget / self.pop_size))) * self.velocity_clamp_factor\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "AdaptiveMemeticPSO", "description": "Adaptive Particle Swarm Optimization with Dynamic Memetic Mutation for Enhanced Global and Local Search.", "configspace": "", "generation": 95, "fitness": 0.3120476215672667, "feedback": "The algorithm AdaptiveMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.6699639632799076, 0.6533348109130408, 0.6694051860477024, 0.6625223927724222, 0.667562152575581, 0.6464832846672168, 0.691006100741995, 0.6473541074575019, 0.6273600722062223, 0.29126051152290533, 0.31479084534554425, 0.3027648859095924, 0.29611951558131777, 0.314244283313761, 0.3203678240299235, 0.2757509241619335, 0.30682074514799984, 0.3079619781189885, 0.13208501955573426, 0.1304201346280981, 0.1317314638769982, 0.14502605099698507, 0.1458441807583507, 0.1487693978654301, 0.13319061374644248, 0.11996125063314589, 0.14845963831992026, 0.12809704230400476, 0.1511360744398158, 0.13052912702672215, 0.1218774448231108, 0.12379601766018711, 0.12066165427198505, 0.11971756581081738, 0.1284839157844524, 0.12958330092467008, 0.9358808141000848, 0.9358150527642337, 0.9366953854747843, 0.9529780530783935, 0.9480684200803131, 0.9235639184317719, 0.9455298743955073, 0.9426338545600864, 0.9512625205190876, 0.378243892412515, 0.3710515135345209, 0.38722341490120304, 0.4217015320873827, 0.3644864760474459, 0.3883710196084791, 0.37048040495375456, 0.3754424586532906, 0.3700769564319849, 0.7190068817796683, 0.6128217300287709, 0.713711024941947, 0.677757130399659, 0.6313170931849277, 0.6802059276112081, 0.6345335029851968, 0.6762838764480539, 0.6060025909892891, 0.2572818435860865, 0.26247983448117573, 0.22283798716909897, 0.20282949916926218, 0.2429955763881153, 0.17080129471368088, 0.2454062049237269, 0.2391061360047474, 0.20363261609177674, 0.23727727930002696, 0.21176219381751693, 0.173408457454707, 0.2777446634267018, 0.24132992766849726, 0.21782370022510444, 0.22566023302252458, 0.21678420714225544, 0.286480750521375, 0.14039260351401972, 0.16845373020915289, 0.11070635266707174, 0.16198315161477128, 0.1383905034013746, 0.10936925663020991, 0.1715309395029293, 0.14875755077505948, 0.14640899520277695, 0.26923635984971994, 0.23942002753015423, 0.271602807607772, 0.2982123123935939, 0.24593302985155363, 0.25198875214061933, 0.25865752917659524, 0.30723613323376253, 0.28718880625685583, 0.02719829503673321, 0.010994356671816807, 0.06694938332560829, 0.06809699461177465, 0.03896242671317718, 0.05430702785545072, 0.05638348233728396, 0.01409809770400805, 0.02040323532974886, 0.16398026498212492, 0.15361575741365652, 0.16236523133713365, 0.16683308533091, 0.17751590328381173, 0.162568614624365, 0.15864597351909981, 0.15075431406346373, 0.153241656746262, 0.5196365972947297, 0.523884056082516, 0.5113779591391655, 0.5077257708604221, 0.5363402195171905, 0.5107337788176083, 0.5111176220940052, 0.5268269280233747, 0.5224320058225211, 0.12871444726516124, 0.1043737491971164, 0.11259717126527413, 0.12171570530244658, 0.12096950896239611, 0.10891913623190119, 0.14240844182840884, 0.1262788756877382, 0.10541832612031088, 0.16552724720399603, 0.2350365744364753, 0.17986499350301632, 0.2751117254023425, 0.21205531130483446, 0.24190289870693604, 0.2916570853809194, 0.20800471779492213, 0.22426055446964333, 0.36343059884655526, 0.33718875685614413, 0.3402708562954836, 0.37875986761497904, 0.3442192685029434, 0.3534828386698078, 0.37275728271302866, 0.36281879348203516, 0.3540905657947683, 0.28738029165013135, 0.24108092748313714, 0.25142339414799153, 0.2865887550374808, 0.2675732417780117, 0.27615125986775735, 0.2983626547430308, 0.28992112407198345, 0.2512714775249334, 0.20248547986421528, 0.21205734107717866, 0.2173620418422333, 0.2220612325374811, 0.2077307766750337, 0.2189346270935203, 0.25666961430660684, 0.20632502772171024, 0.23687861364687146, 0.1990146102195397, 0.4510548082528417, 0.22481942889393114, 0.22153725748841657, 0.21976768600673158, 0.23677211268256904, 0.22510694456298563, 0.2645770898885713, 0.22787528247183975, 0.8411885080570436, 0.18435552657422616, 0.16025716772152843, 0.8175945076660935, 0.19875394186372664, 0.16712812439444247, 0.7552422255515167, 0.833368560903847, 0.8070076825907586, 0.7846132048723018, 0.2103483044513117, 0.7313539177479342, 0.7203405485934155, 0.16662164594181683, 0.2061807480548299, 0.15267712163427782, 0.6640274397633816, 0.20524747868474702, 0.19250967241016126, 0.18246841947223602, 0.20542554730569595, 0.1770331379268293, 0.19167763039210595, 0.19404225565384747, 0.19311649421559118, 0.2060207517366549, 0.18208518583505118, 0.09214012993809062, 0.08760738486995545, 0.0803813807753957, 0.08998285465287081, 0.09376350570004055, 0.09520258102759616, 0.09891056631537343, 0.08960082360200317, 0.08770379843027054]}, "mutation_prompt": null}
{"id": "d56bc012-b9f5-4371-8df0-d911c0eec2f2", "solution": "import numpy as np\n\nclass ImprovedAdaptiveMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Slightly larger population for better diversity\n        self.inertia = 0.7  # Balanced inertia for dynamic search control\n        self.c1 = 1.5  # Moderate cognitive component for stable individual learning\n        self.c2 = 1.5  # Balanced social component to maintain social influence\n        self.mutation_factor = 0.6  # Enhanced mutation for robust exploration\n        self.crossover_rate = 0.9  # Higher crossover rate for intensified recombination\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_factor = 1.0  # Simplified clamping approach\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocity_clamp = self.velocity_clamp_factor - (iteration / (self.budget / self.pop_size))  # Iterative velocity tuning\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "ImprovedAdaptiveMemeticPSO", "description": "Improved Adaptive Memetic Particle Swarm Optimization with Proximity-based Dynamic Recombination and Iterative Velocity Tuning for enhanced exploration and convergence balance.", "configspace": "", "generation": 96, "fitness": 0.31736828650505877, "feedback": "The algorithm ImprovedAdaptiveMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.7146515016943109, 0.6848616365791342, 0.700400758763408, 0.6941490626428534, 0.7098331977410177, 0.6908857440370048, 0.6726036374188357, 0.6957243787127856, 0.6797013622661542, 0.3322090059916064, 0.34246059182820043, 0.33348164476468545, 0.3276853263394953, 0.3115194610486426, 0.2870768862128621, 0.3213136708994506, 0.3518134925305809, 0.30020436737024747, 0.14313249766122715, 0.12805991960426344, 0.16689451119482202, 0.1441243894721973, 0.14150430610491493, 0.14955877590882005, 0.10434615272375358, 0.15986283520811173, 0.17030042591992045, 0.12133613546182986, 0.11158791735934792, 0.10748601541037184, 0.11418101252864421, 0.1145222795246007, 0.09925132164297845, 0.14958168354387102, 0.11147081863927777, 0.10350175862266131, 0.9113667266350476, 0.934016643638788, 0.9265155157070903, 0.9397294671444286, 0.9431075810514957, 0.8904484624584461, 0.9051180040859124, 0.8909824828844447, 0.9215137648464022, 0.4110576516107919, 0.43279965117050945, 0.4202981744986377, 0.42881733387720544, 0.43859495423762296, 0.40958870204890474, 0.39865657714433167, 0.3942960408929843, 0.3851735446958512, 0.7643150834931084, 0.7659987148587102, 0.7374698897580685, 0.6412489258124465, 0.20796564188459576, 0.6101608080974342, 0.6835643630776834, 0.7118195636443745, 0.7529346809342976, 0.21560987346780003, 0.18678552199644904, 0.2316288374276978, 0.3041642183598974, 0.2667930910336752, 0.24373247528461583, 0.28497984243369245, 0.24635297978146176, 0.21212410928732162, 0.25191731559486696, 0.21017216766314728, 0.20127863722345096, 0.23486800840887256, 0.2311144872262717, 0.2165240652414252, 0.23640275951930578, 0.2642791518439549, 0.21381182100180496, 0.17052489488252998, 0.1517099597851599, 0.15878742138293023, 0.14810405387155312, 0.118072548361291, 0.14144093556769477, 0.15628430012172212, 0.09961360021587973, 0.14029117370655253, 0.3126635808976471, 0.27964417273420994, 0.28705920841193433, 0.2919977941535864, 0.2568993169728352, 0.24064592820445374, 0.27317907929426144, 0.2960658953431069, 0.2897802398012491, 0.07553191514471325, 0.045059994434988426, 0.07311333575285739, 0.07274926245853208, 0.044270889980679184, 0.05953500102077891, 0.05744941843483886, 0.0380058896228076, 0.06780057705515719, 0.19090055111934068, 0.1773849714471013, 0.18011845599331844, 0.1798331242330269, 0.1884288831850831, 0.1914806062376695, 0.1697244883180754, 0.17294668077683073, 0.17061298909890188, 0.5294730841565245, 0.5134731821270904, 0.5283286686421266, 0.5390751997574603, 0.5166559619246558, 0.5314196428994864, 0.5400242289604145, 0.5406933163366043, 0.5518663297107658, 0.1331926537992285, 0.09458609144393104, 0.11427232510764807, 0.12839438938915626, 0.1283753602979275, 0.1369170185002846, 0.15704567910381906, 0.1406620930649215, 0.1324583036939626, 0.2873116409424762, 0.16336264395149358, 0.18227434875206705, 0.19859414166157818, 0.2681712185158056, 0.22417505930585568, 0.3454292238180885, 0.3470585042652998, 0.410637551826328, 0.38311704402885893, 0.3638062691869238, 0.3565902341863588, 0.35643998203791205, 0.3687523834181671, 0.3870740159896058, 0.4284721380725959, 0.39871098899037105, 0.37589899633321966, 0.2442571345814346, 0.26619998676137957, 0.2993117654185973, 0.24307512072687476, 0.27242353147945275, 0.29354911534855754, 0.2844374746076823, 0.30059557798455194, 0.28930285533874134, 0.2429530467877452, 0.21080160817059346, 0.22720444744600643, 0.23636498915893112, 0.22509824883084395, 0.28120725862643314, 0.2532277158211851, 0.2241688364551262, 0.2221182850448472, 0.45804784787509856, 0.23883353029895227, 0.19275870946400053, 0.2283413961696641, 0.19978981548747865, 0.21582777177438406, 0.19917645037204335, 0.23970573705813114, 0.21590228631984876, 0.17529424835967788, 0.18525131915554416, 0.7168701311705701, 0.8554150817233899, 0.19843451682855362, 0.1693150020373425, 0.14043556575806537, 0.16545500946151714, 0.8116775680239695, 0.7332549934558066, 0.21042641256631422, 0.7388549304888037, 0.7638191490643337, 0.67871947298706, 0.19841329097361082, 0.15354894043387868, 0.7470435946118714, 0.20708270454155675, 0.20862501887286278, 0.18505256162319417, 0.1882368314409817, 0.18207015326606657, 0.19340103374530515, 0.18070611854299334, 0.18902545313889285, 0.20319156943755812, 0.18397665970636756, 0.10452694189450362, 0.08574034434435596, 0.08172353700767743, 0.0949547249556617, 0.09037743471841864, 0.07806296067750096, 0.08959591055290983, 0.09137677423676194, 0.09503553329969505]}, "mutation_prompt": null}
{"id": "7f448f83-c4e3-4dee-90f7-aef8545e7217", "solution": "import numpy as np\n\nclass EnhancedMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Population size\n        self.inertia = 0.7  # Adjusted for dynamic exploration-exploitation\n        self.c1 = 2.0  # Increased cognitive component for better individual learning\n        self.c2 = 1.0  # Decreased social component to avoid early convergence\n        self.mutation_factor = 0.6  # Mutation for enhanced exploration\n        self.crossover_rate = 0.9  # Higher crossover rate for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_clamp_factor = 0.9  # Adaptive velocity clamping factor\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocity_clamp = 1.5 * (1 - (iteration / (self.budget / self.pop_size)))  # Adaptive velocity clamp\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities += np.random.uniform(-0.1, 0.1, velocities.shape)  # Stochastic perturbation\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)\n\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n            iteration += 1\n\n        return global_best", "name": "EnhancedMemeticPSO", "description": "Enhanced Memetic Particle Swarm Optimization with Stochastic Velocity Perturbation and Adaptive Learning Rates for balanced exploration and exploitation.", "configspace": "", "generation": 97, "fitness": 0.3167177162744547, "feedback": "The algorithm EnhancedMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.6317750035373876, 0.6346832061317091, 0.6375621159624264, 0.5892410077602768, 0.6169375705673046, 0.5845603731385683, 0.5837627388678996, 0.6131033876670193, 0.5850557699483057, 0.24679371745803824, 0.27520610855644245, 0.27881852419047615, 0.26259755970996157, 0.27081098838909834, 0.3158115155119784, 0.30977009042602566, 0.2590012676081722, 0.25939795587358827, 0.12184177365425963, 0.11110052739492171, 0.11461595984656037, 0.11528097881494237, 0.12203523231051494, 0.13486040200700167, 0.12961786146974896, 0.11836928893792831, 0.13939030171923072, 0.12147524958945088, 0.10326129425849939, 0.10178194901871052, 0.10058690403727322, 0.10066349820696163, 0.11097123217486182, 0.09635314670057282, 0.10496974078395682, 0.10605594663613449, 0.9454388734455986, 0.9447835288795767, 0.9508296448205602, 0.9359659652315245, 0.9217738871906217, 0.9097080545428307, 0.948732240027842, 0.9049582285271982, 0.9571137690390844, 0.35533718355486754, 0.333633805801395, 0.3461737125298381, 0.34713910987473984, 0.33995233215898535, 0.34096404578480854, 0.34782413732617123, 0.3247130559677178, 0.3547222996161238, 0.6898460660554004, 0.7675013737138681, 0.36816300903456334, 0.662923990615319, 0.5720298507530941, 0.7106520111247464, 0.7064048560814763, 0.72821317818732, 0.6125451579152568, 0.21936104666310763, 0.2249980115779482, 0.275065214045185, 0.2039559331902847, 0.21707735971193598, 0.17892479406018447, 0.2506254266080453, 0.20879990051746777, 0.2293136812949682, 0.18570890257897743, 0.2213817080496634, 0.21236761335266374, 0.2277437322750956, 0.1982627510327275, 0.2273633620008314, 0.2132691201378497, 0.22038556306201773, 0.26764530909360673, 0.20294017823599853, 0.16535420389983047, 0.19834694698611133, 0.20935074887032323, 0.20245955687045236, 0.1560125657411522, 0.20253608058558836, 0.1439284283141551, 0.19217509295636004, 0.3237251644233252, 0.27647115385486754, 0.30665769152216626, 0.3455727286079532, 0.2515314583937285, 0.34349350080731555, 0.34153913902403, 0.35020589695629933, 0.3314946652243761, 0.03656387170229625, 0.03998837032464286, 0.07004815548683363, 0.10375360616954732, 0.11684860047519885, 0.0903817855592266, 0.11261048970115939, 0.06486064649738732, 0.05290873844083377, 0.18727427977485978, 0.20645087069401602, 0.21138443922569905, 0.18827464508798464, 0.1905349576589498, 0.19790523930392745, 0.18903604640774885, 0.17991304603220504, 0.18413328476083346, 0.5643811124926039, 0.5453305837204516, 0.5429523805720409, 0.5392609862758624, 0.584370608777451, 0.5317227213487276, 0.5557825686008808, 0.5193281602324615, 0.5340434099671001, 0.11369346354412524, 0.1126609811475513, 0.13115206626412834, 0.12655654156204965, 0.09549675947499514, 0.12030902181076053, 0.09641721473473297, 0.10229382092273731, 0.11494470169325799, 0.14487633493109897, 0.17398571837455912, 0.2342647044856776, 0.18251362845677943, 0.21302115257631926, 0.20504339918611658, 0.21631779880312674, 0.17235610687502778, 0.16838872700205465, 0.3310785272816329, 0.33847856435357515, 0.33665275839383435, 0.3403735897801008, 0.3248959904458397, 0.3177979763123213, 0.33579257635207527, 0.3314197265643626, 0.34132908142596263, 0.27149695623388737, 0.26151621958652504, 0.2711594222944329, 0.2660667956763493, 0.2593832772485356, 0.2789496025399807, 0.2587837189933282, 0.2835009186429033, 0.23579933027334965, 0.23171199706274315, 0.2174646472319527, 0.2150694452887827, 0.20376126346263213, 0.2065192084484273, 0.21039593816033553, 0.2124788559582872, 0.23115456398009093, 0.2633860692543136, 0.21148887524033444, 0.1946369424006028, 0.2105268293710164, 0.25778911681905303, 0.19700659615420724, 0.21047259142484442, 0.22233269901684405, 0.2788793912907467, 0.2878600726120557, 0.7998903162968218, 0.18533197461258222, 0.1858756593740991, 0.8645206912252412, 0.16746023505367758, 0.19892960537403337, 0.7917194590415663, 0.8198361628467252, 0.805969722168241, 0.7776441714478722, 0.6586379273084918, 0.7556824887220724, 0.757815772075022, 0.689499954492776, 0.6110710710139398, 0.6433805043300387, 0.16545483025993202, 0.7099518693206603, 0.18524806784503578, 0.18249480896541637, 0.18552417356536033, 0.18262110223852146, 0.17624691052712738, 0.18241639639555807, 0.18467599900191556, 0.1827483550803366, 0.1864483455230609, 0.0831327884953047, 0.09686648912530704, 0.08608642532044375, 0.08930149574197077, 0.09990057215066717, 0.0791697722864958, 0.08851037128025163, 0.08723670088855018, 0.08977145598147362]}, "mutation_prompt": null}
{"id": "6cfa0d52-b345-45d7-8cc0-06451454e494", "solution": "import numpy as np\n\nclass DynamicMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 45  # Increased population for better diversity\n        self.inertia = 0.5  # Reduced inertia to balance exploration-exploitation\n        self.c1 = 1.5  # Adjusted cognitive component for improved exploration\n        self.c2 = 1.5  # Balanced social component to avoid over-convergence\n        self.mutation_factor = 0.65  # Enhanced mutation for broader search\n        self.crossover_rate = 0.9  # Slightly increased crossover rate for variety\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.velocity_scale_factor = 0.7  # Adaptive scaling based on success rate\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        iteration = 0\n        success_rate = np.zeros(self.pop_size)\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n                    success_rate[i] += 1  # Track success\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            success_probability = success_rate / (iteration + 1)\n            velocity_scale = 1.0 + self.velocity_scale_factor * (success_probability - 0.5)\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities *= velocity_scale[:, np.newaxis]\n            particles = particles + velocities\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n                    \n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n                        success_rate[i] += 1\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n            iteration += 1\n            success_rate.fill(0)  # Reset success rate each iteration\n\n        return global_best", "name": "DynamicMemeticPSO", "description": "Dynamic Memetic Particle Swarm Optimization leveraging Adaptive Velocity Scaling and Stochastic Differential Evolution for enhanced adaptability and convergence.", "configspace": "", "generation": 98, "fitness": 0.3475454953083055, "feedback": "The algorithm DynamicMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.8781028612616455, 0.8855362577272056, 0.8829062319542522, 0.8904704794797811, 0.8899651776225552, 0.8887813664498082, 0.8853613991901432, 0.8736479816492015, 0.8809685377310539, 0.788290438910158, 0.41567792751479404, 0.7314484254333635, 0.6750537012139071, 0.7182424518156207, 0.767524224508884, 0.6731356897284378, 0.7135881198052256, 0.7709009470489111, 0.11600920761623545, 0.14223095513004935, 0.10477712727880695, 0.18297098612191398, 0.11865049298386843, 0.18439391556457518, 0.1376699201572097, 0.15380918071142824, 0.12982333965984705, 0.07759022886639866, 0.12901463133923285, 0.18172309208137705, 0.13434686432498766, 0.17954003500672622, 0.109489538123694, 0.11441088772054919, 0.11454261640402164, 0.13867936835193273, 0.9764938071832426, 0.9952875150750041, 0.9732724601277303, 0.972264602424273, 0.9761344946544064, 0.9569729164518072, 0.97229238572936, 0.9620399292426642, 0.9752893199914433, 0.7639451104377539, 0.638508388412133, 0.30685749884450053, 0.37994174806509495, 0.7602173989208347, 0.7267312372677475, 0.49417052006413653, 0.7110306400561279, 0.2649583271973136, 0.8678466015640609, 0.17158910003564742, 0.21127977197987824, 0.2792208517839525, 0.20862800624976452, 0.21184992221260768, 0.23079474264843725, 0.23074813152888984, 0.15702149213772554, 0.13155054595643745, 0.14863129222447147, 0.12962757829591354, 0.12286393804098239, 0.15229108655679902, 0.14236355202539785, 0.5262510469032823, 0.27051256862069073, 0.1312287976963309, 0.20800147833068794, 0.13554599130007572, 0.19137200312679947, 0.1389856945384974, 0.14681253143647643, 0.1772670922049301, 0.17588520661860274, 0.1307947917592035, 0.1195565160452583, 0.16295286885848204, 0.17856218210063124, 0.19933104352124942, 0.17021354734618055, 0.1583915329905381, 0.1658482416237803, 0.20283946395820251, 0.16537353471184046, 0.1579192279052204, 0.2917849581701435, 0.29956038624572956, 0.3291141727978234, 0.2593705609297233, 0.255101418839776, 0.25779256875475876, 0.27771851646662027, 0.31487311711321586, 0.2902577509326314, 0.2061306534591012, 9.999999999998899e-05, 0.15329497411480209, 0.12096912243031244, 0.07863804806178454, 0.11108213142629975, 0.18420469148723495, 0.16930607225377536, 0.17113646016202566, 0.23085615215811472, 0.12335590666975838, 0.2909177300818061, 0.21767427958447638, 0.2647073332632326, 0.21068210906699847, 0.13075311153133828, 0.11727235607145936, 0.12695961831363967, 0.6949681949866995, 0.7014766090449156, 0.6665923368055098, 0.709666570670195, 0.6744262311312125, 0.6172335115070944, 0.6930058471264933, 0.6909389003948236, 0.6773123630941427, 0.13429321261536498, 0.13235513568709323, 0.10732898540198332, 0.12768777558726674, 0.1453962810881103, 0.12146028384459862, 0.10689561020810756, 0.11343670582670362, 0.09802041213472146, 0.18673060682416776, 0.1536207528912129, 0.18714099750946767, 0.27080385291809184, 0.2246183429873888, 0.29151676635264934, 0.2619397190659484, 0.2206521514633435, 0.29968791362302694, 0.3760741411818288, 0.49429955951308613, 0.37828182686441136, 0.4152630273236817, 0.24664829342203132, 0.5618005228865649, 0.44542524065561984, 0.4920378968841451, 0.5297422402543466, 0.39608120648357714, 0.37988369645237485, 0.23120039444146046, 0.24771619454286198, 0.3615185452278151, 0.323975233019947, 0.3103356331881185, 0.3338984019014579, 0.40666115514529577, 0.1997066315687337, 0.23236033099976028, 0.24969785015144585, 0.2051667787924757, 0.1897554009622483, 0.23033319835041155, 0.2353007918087877, 0.22333567805739107, 0.2777731305541662, 0.20625228186144118, 0.18264718528259938, 0.220767763866628, 0.24730595207506434, 0.2081766706014383, 0.21300146085026483, 0.20664657696967126, 0.1774992443588388, 0.1893466603580628, 0.16303109075060296, 0.1674861692990851, 0.1533753452225708, 0.9083799075389491, 0.19985830716250708, 0.1996116671455197, 0.8070861397901167, 0.9037039316761367, 0.9069997303448547, 0.8527361822396258, 0.21166193402935773, 0.7490830563719653, 0.1678615407600237, 0.6243948414983724, 0.15443669900200696, 0.15517807479469847, 0.8371922096058478, 0.8439629667248081, 0.20556802370267047, 0.1946334699266109, 0.1891345705257027, 0.22328639730279076, 0.19317668037020597, 0.19150485190188848, 0.18234506992265576, 0.18466318364721546, 0.1972883111976821, 0.09275532067900838, 0.098415910623735, 0.09906557068357691, 0.10384148354120204, 0.09355671923351949, 0.08581012737384441, 0.14022504603767427, 0.10815825635924647, 0.08598625010142236]}, "mutation_prompt": null}
{"id": "fb9a0c70-4a8f-4616-a2d3-860f9b1b0929", "solution": "import numpy as np\n\nclass QuantumMemeticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for better diversity\n        self.inertia = 0.7  # Moderate inertia to balance exploration and exploitation\n        self.c1 = 1.5  # Balanced cognitive component\n        self.c2 = 1.5  # Balanced social component\n        self.quantum_factor = 0.3  # Quantum-inspired movement addition\n        self.mutation_factor = 0.5  # Keep mutation stable\n        self.crossover_rate = 0.8  # Maintaining sufficient diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.full(self.pop_size, float('inf'))\n        global_best = particles[0].copy()\n        global_best_fitness = float('inf')\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                fitness = func(particles[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best[i] = particles[i].copy()\n\n                if fitness < global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best = particles[i].copy()\n\n                if eval_count >= self.budget:\n                    break\n\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best - particles) +\n                          self.c2 * r2 * (global_best - particles))\n            velocities = np.clip(velocities, -3, 3)\n\n            quantum_motion = self.quantum_factor * np.random.normal(size=(self.pop_size, self.dim))\n            particles = particles + velocities + quantum_motion\n            particles = np.clip(particles, self.lower_bound, self.upper_bound)\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.crossover_rate:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = (personal_best[a] +\n                                     self.mutation_factor * (personal_best[b] - personal_best[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate,\n                                            mutant_vector, particles[i])\n\n                    trial_fitness = func(trial_vector)\n                    eval_count += 1\n\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = trial_fitness\n                        personal_best[i] = trial_vector.copy()\n\n                    if trial_fitness < global_best_fitness:\n                        global_best_fitness = trial_fitness\n                        global_best = trial_vector.copy()\n\n                    if eval_count >= self.budget:\n                        break\n\n        return global_best", "name": "QuantumMemeticPSO", "description": "Adaptive Quantum-Inspired Memetic PSO integrating Quantum Particle Dynamics and Enhanced Local Search for robust exploration and precision exploitation.", "configspace": "", "generation": 99, "fitness": 0.23484613738109467, "feedback": "The algorithm QuantumMemeticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "3704fc92-7e3f-4b0a-8d5c-39ea779e08dd", "metadata": {"aucs": [0.4450982888356996, 0.473052754384909, 0.44304270586677186, 0.4466414283400515, 0.41583386761388075, 0.4708337655754049, 0.44784322606125626, 0.4286062286727913, 0.4166367822383915, 0.15786999382091182, 0.16009410872490848, 0.14434132611644668, 0.131423705083353, 0.14534286931934526, 0.21505521387661608, 0.13992316663408166, 0.16369593828682394, 0.13677113160039567, 0.10208905125201728, 0.09531989398398144, 0.09793246599500238, 0.09453055889424855, 0.09319923797659957, 0.0894896853676782, 0.09434777211344592, 0.10188824072694702, 0.09903582030028335, 0.07948714097398102, 0.09204974108361352, 0.084442257357488, 0.08592491521010326, 0.09467321274276841, 0.0817068659030068, 0.08031309017580845, 0.09189697357182192, 0.08309474778297421, 0.9609620590437514, 0.9564593293911214, 0.9666085588162376, 0.9705425447138945, 0.950889295887832, 0.9601459022186785, 0.9682761744860457, 0.953770591722213, 0.9572755277025261, 0.23630324473108044, 0.23828562179939416, 0.22341858717044882, 0.23983524180387839, 0.2573134260774851, 0.22089409566150608, 0.22349118416615033, 0.24544699326434016, 0.23836665004721258, 0.5228929150358916, 0.3661449279516299, 0.4260074249853838, 0.45332694389743666, 0.4820712424239334, 0.4744307958959626, 0.3003560270240532, 0.31302210881895476, 0.3833983752151505, 0.14746678070677843, 0.12107160947966078, 0.16334312002433193, 0.17103091030701034, 0.16020164740313414, 0.14718209780667746, 0.1622494993016157, 0.1304634250202984, 0.16139871846298925, 0.13927000385103516, 0.16156826400060054, 0.13112628563490658, 0.1427700929156145, 0.17843697502301126, 0.15805564488956148, 0.15200086604030016, 0.11500101685560038, 0.1575653796107035, 0.05046820109002059, 0.06808292518276338, 0.06920108659752966, 0.09121383877267031, 0.07763505206626031, 0.08723214874632701, 0.07396099975744042, 0.060305120100650145, 0.05825481126563936, 0.16991366342435232, 0.1523087720190146, 0.20804437577810786, 0.20182356637178378, 0.11944262503257941, 0.15626846342813205, 0.18700909462260284, 0.23337853746622061, 0.20522871069510318, 0.005045270185777162, 0.009304163507228957, 0.0027232516612917257, 0.01735419810939598, 0.0167730712299885, 0.01702940168750755, 0.002473591471712777, 0.01099563026255057, 0.006893776970293031, 0.1112134228939673, 0.09915093076363157, 0.10848493722349017, 0.10533801902920714, 0.10210129465187578, 0.09885795974786293, 0.12296625305463471, 0.10774580517943799, 0.11589064238709201, 0.42581071683787863, 0.40669000691213175, 0.41388642046992496, 0.4361290654674099, 0.4249388470693952, 0.4011384339154225, 0.3991937497432678, 0.43645126581285765, 0.4134246726775328, 0.08420452913208498, 0.10013625607427945, 0.08668797170155595, 0.10168400489311424, 0.09907350289552963, 0.09713232758494827, 0.10190647922277352, 0.09452297565801382, 0.10352313286641202, 0.2084287457548022, 0.19693939644106895, 0.13919187191823235, 0.14015743808369774, 0.13942101928477424, 0.1524292163519516, 0.26232457643818863, 0.20402180839800332, 0.15118328329745379, 0.25919666541746533, 0.2776007111698354, 0.2706507977712599, 0.28086345056668593, 0.29190952438657924, 0.26486717149030503, 0.27275778607773093, 0.27784123921103787, 0.2693850766294016, 0.20127369225931357, 0.22525674643403804, 0.2012187316274091, 0.20212469028689684, 0.21770371564036484, 0.21454824563940156, 0.22294878294700138, 0.21862415325802564, 0.23181721707804703, 0.20372151661283877, 0.2050845381737838, 0.1990233647742663, 0.19736718320891733, 0.20098985159890081, 0.21092739250360637, 0.21038897125655176, 0.19365137234329877, 0.19677694087213937, 0.18604679879302244, 0.1861465248029881, 0.18177353919254824, 0.18041951741310824, 0.19062974607610883, 0.17946354570268175, 0.22781269390676306, 0.17958125177057105, 0.1833455184709638, 0.6665769515238951, 0.15603129910511648, 0.15205726600828273, 0.6899859298273241, 0.19611748714658916, 0.1972207408719996, 0.14091791569311352, 0.16204375260686155, 0.63639047741932, 0.6066965373422384, 0.20889134252281283, 0.45257989136134313, 0.5565451676884675, 0.5621607937414987, 0.15227476445793875, 0.5250702069807157, 0.10360862251059921, 0.46115411121554506, 0.17167691431593124, 0.18784229726497126, 0.18730344657132592, 0.18604153057379347, 0.19073820540548936, 0.18635399319063994, 0.19596013987773608, 0.17595377419189084, 0.188476074529503, 0.09186941236558144, 0.08583410188993634, 0.08304407498123323, 0.0824282458574166, 0.07443004449074486, 0.07720591523305209, 0.0847740776829079, 0.08527050956018445, 0.08708936585990612]}, "mutation_prompt": null}
