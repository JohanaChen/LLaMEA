{"id": "8cb9266d-09e5-4144-b032-fff89007a52f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.F = 0.8\n        self.CR = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Differential Evolution strategy for mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n        return g_best_position, g_best_score", "name": "HybridPSO_DE", "description": "Hybrid Particle Swarm and Differential Evolution algorithm leveraging swarm intelligence and mutation strategies.", "configspace": "", "generation": 0, "fitness": 0.22094505580740537, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.5744932163933368, 0.5744932163933368, 0.5744932163933368, 0.6062663047944572, 0.6062663047944572, 0.6062663047944572, 0.5914684971902707, 0.5914684971902707, 0.5914684971902707, 0.23399475701643546, 0.23399475701643546, 0.23399475701643546, 0.13336999583753317, 0.13336999583753317, 0.13336999583753317, 0.14007641687971717, 0.14007641687971717, 0.14007641687971717, 0.11997588981090923, 0.11997588981090923, 0.11997588981090923, 0.08456048185906784, 0.08456048185906784, 0.08456048185906784, 0.18416771080701577, 0.18416771080701577, 0.18416771080701577, 0.08615242757883967, 0.08615242757883967, 0.08615242757883967, 0.09574144859178302, 0.09574144859178302, 0.09574144859178302, 0.08413196669392364, 0.08413196669392364, 0.08413196669392364, 0.9695968806296963, 0.9695968806296963, 0.9695968806296963, 0.9817786267238803, 0.9817786267238803, 0.9817786267238803, 0.9826483802332906, 0.9826483802332906, 0.9826483802332906, 0.30968764060326825, 0.30968764060326825, 0.30968764060326825, 0.13894460002558973, 0.13894460002558973, 0.13894460002558973, 0.24038029623056367, 0.24038029623056367, 0.24038029623056367, 0.3070946703108718, 0.3070946703108718, 0.3070946703108718, 0.20112637440800019, 0.20112637440800019, 0.20112637440800019, 0.2098814340762375, 0.2098814340762375, 0.2098814340762375, 0.15763756677867735, 0.15763756677867735, 0.15763756677867735, 0.1457817485740297, 0.1457817485740297, 0.1457817485740297, 0.15025943103295503, 0.15025943103295503, 0.15025943103295503, 0.14567453582671352, 0.14567453582671352, 0.14567453582671352, 0.1466026964188144, 0.1466026964188144, 0.1466026964188144, 0.1836310013233431, 0.1836310013233431, 0.1836310013233431, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07595864182007861, 0.07595864182007861, 0.07595864182007861, 0.028376847854691967, 0.028376847854691967, 0.028376847854691967, 0.03893505596850022, 0.03893505596850022, 0.03893505596850022, 0.02377090646651736, 0.02377090646651736, 0.02377090646651736, 0.04914088285290219, 0.04914088285290219, 0.04914088285290219, 0.046309275749036205, 0.046309275749036205, 0.046309275749036205, 0.11748888642990951, 0.11748888642990951, 0.11748888642990951, 0.0313269504558521, 0.0313269504558521, 0.0313269504558521, 0.05053708415237257, 0.05053708415237257, 0.05053708415237257, 0.42845781975176245, 0.42845781975176245, 0.42845781975176245, 0.4116999202924475, 0.4116999202924475, 0.4116999202924475, 0.4183082358046125, 0.4183082358046125, 0.4183082358046125, 0.09386278769098155, 0.09386278769098155, 0.09386278769098155, 0.14005139698711133, 0.14005139698711133, 0.14005139698711133, 0.09624383861879926, 0.09624383861879926, 0.09624383861879926, 0.14794022001552332, 0.14794022001552332, 0.14794022001552332, 0.17021091272908073, 0.17021091272908073, 0.17021091272908073, 0.18398469349556523, 0.18398469349556523, 0.18398469349556523, 0.3333899220654334, 0.3333899220654334, 0.3333899220654334, 0.1856935726607264, 0.1856935726607264, 0.1856935726607264, 0.3354891424131907, 0.3354891424131907, 0.3354891424131907, 0.19409741262573055, 0.19409741262573055, 0.19409741262573055, 0.17939059271116597, 0.17939059271116597, 0.17939059271116597, 0.15616553831436397, 0.15616553831436397, 0.15616553831436397, 0.19368615043734394, 0.19368615043734394, 0.19368615043734394, 0.2089866015718792, 0.2089866015718792, 0.2089866015718792, 0.18096050908649786, 0.18096050908649786, 0.18096050908649786, 0.17953056142499513, 0.17953056142499513, 0.17953056142499513, 0.21432178145774516, 0.21432178145774516, 0.21432178145774516, 0.17903982296141585, 0.17903982296141585, 0.17903982296141585, 0.6977031234851354, 0.6977031234851354, 0.6977031234851354, 0.19835013273992508, 0.19835013273992508, 0.19835013273992508, 0.1995300107382636, 0.1995300107382636, 0.1995300107382636, 0.20988877747705814, 0.20988877747705814, 0.20988877747705814, 0.19920422769112023, 0.19920422769112023, 0.19920422769112023, 0.3224501419092928, 0.3224501419092928, 0.3224501419092928, 0.18930806398908506, 0.18930806398908506, 0.18930806398908506, 0.18563716635547045, 0.18563716635547045, 0.18563716635547045, 0.17900240929616806, 0.17900240929616806, 0.17900240929616806, 0.07616681504309653, 0.07616681504309653, 0.07616681504309653, 0.07939620874772169, 0.07939620874772169, 0.07939620874772169, 0.07262597914539604, 0.07262597914539604, 0.07262597914539604]}, "mutation_prompt": null}
{"id": "9f91ce4e-e705-4a2d-84cb-009580a94d16", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.F = 0.8\n        self.CR = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Differential Evolution strategy for mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n        return g_best_position, g_best_score", "name": "HybridPSO_DE", "description": "Hybrid Particle Swarm and Differential Evolution algorithm leveraging swarm intelligence and mutation strategies.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8cb9266d-09e5-4144-b032-fff89007a52f", "metadata": {"aucs": [0.5744932163933368, 0.5744932163933368, 0.5744932163933368, 0.6062663047944572, 0.6062663047944572, 0.6062663047944572, 0.5914684971902707, 0.5914684971902707, 0.5914684971902707, 0.23399475701643546, 0.23399475701643546, 0.23399475701643546, 0.13336999583753317, 0.13336999583753317, 0.13336999583753317, 0.14007641687971717, 0.14007641687971717, 0.14007641687971717, 0.11997588981090923, 0.11997588981090923, 0.11997588981090923, 0.08456048185906784, 0.08456048185906784, 0.08456048185906784, 0.18416771080701577, 0.18416771080701577, 0.18416771080701577, 0.08615242757883967, 0.08615242757883967, 0.08615242757883967, 0.09574144859178302, 0.09574144859178302, 0.09574144859178302, 0.08413196669392364, 0.08413196669392364, 0.08413196669392364, 0.9695968806296963, 0.9695968806296963, 0.9695968806296963, 0.9817786267238803, 0.9817786267238803, 0.9817786267238803, 0.9826483802332906, 0.9826483802332906, 0.9826483802332906, 0.30968764060326825, 0.30968764060326825, 0.30968764060326825, 0.13894460002558973, 0.13894460002558973, 0.13894460002558973, 0.24038029623056367, 0.24038029623056367, 0.24038029623056367, 0.3070946703108718, 0.3070946703108718, 0.3070946703108718, 0.20112637440800019, 0.20112637440800019, 0.20112637440800019, 0.2098814340762375, 0.2098814340762375, 0.2098814340762375, 0.15763756677867735, 0.15763756677867735, 0.15763756677867735, 0.1457817485740297, 0.1457817485740297, 0.1457817485740297, 0.15025943103295503, 0.15025943103295503, 0.15025943103295503, 0.14567453582671352, 0.14567453582671352, 0.14567453582671352, 0.1466026964188144, 0.1466026964188144, 0.1466026964188144, 0.1836310013233431, 0.1836310013233431, 0.1836310013233431, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07595864182007861, 0.07595864182007861, 0.07595864182007861, 0.028376847854691967, 0.028376847854691967, 0.028376847854691967, 0.03893505596850022, 0.03893505596850022, 0.03893505596850022, 0.02377090646651736, 0.02377090646651736, 0.02377090646651736, 0.04914088285290219, 0.04914088285290219, 0.04914088285290219, 0.046309275749036205, 0.046309275749036205, 0.046309275749036205, 0.11748888642990951, 0.11748888642990951, 0.11748888642990951, 0.0313269504558521, 0.0313269504558521, 0.0313269504558521, 0.05053708415237257, 0.05053708415237257, 0.05053708415237257, 0.42845781975176245, 0.42845781975176245, 0.42845781975176245, 0.4116999202924475, 0.4116999202924475, 0.4116999202924475, 0.4183082358046125, 0.4183082358046125, 0.4183082358046125, 0.09386278769098155, 0.09386278769098155, 0.09386278769098155, 0.14005139698711133, 0.14005139698711133, 0.14005139698711133, 0.09624383861879926, 0.09624383861879926, 0.09624383861879926, 0.14794022001552332, 0.14794022001552332, 0.14794022001552332, 0.17021091272908073, 0.17021091272908073, 0.17021091272908073, 0.18398469349556523, 0.18398469349556523, 0.18398469349556523, 0.3333899220654334, 0.3333899220654334, 0.3333899220654334, 0.1856935726607264, 0.1856935726607264, 0.1856935726607264, 0.3354891424131907, 0.3354891424131907, 0.3354891424131907, 0.19409741262573055, 0.19409741262573055, 0.19409741262573055, 0.17939059271116597, 0.17939059271116597, 0.17939059271116597, 0.15616553831436397, 0.15616553831436397, 0.15616553831436397, 0.19368615043734394, 0.19368615043734394, 0.19368615043734394, 0.2089866015718792, 0.2089866015718792, 0.2089866015718792, 0.18096050908649786, 0.18096050908649786, 0.18096050908649786, 0.17953056142499513, 0.17953056142499513, 0.17953056142499513, 0.21432178145774516, 0.21432178145774516, 0.21432178145774516, 0.17903982296141585, 0.17903982296141585, 0.17903982296141585, 0.6977031234851354, 0.6977031234851354, 0.6977031234851354, 0.19835013273992508, 0.19835013273992508, 0.19835013273992508, 0.1995300107382636, 0.1995300107382636, 0.1995300107382636, 0.20988877747705814, 0.20988877747705814, 0.20988877747705814, 0.19920422769112023, 0.19920422769112023, 0.19920422769112023, 0.3224501419092928, 0.3224501419092928, 0.3224501419092928, 0.18930806398908506, 0.18930806398908506, 0.18930806398908506, 0.18563716635547045, 0.18563716635547045, 0.18563716635547045, 0.17900240929616806, 0.17900240929616806, 0.17900240929616806, 0.07616681504309653, 0.07616681504309653, 0.07616681504309653, 0.07939620874772169, 0.07939620874772169, 0.07939620874772169, 0.07262597914539604, 0.07262597914539604, 0.07262597914539604]}, "mutation_prompt": null}
{"id": "23dbd99b-3a57-4944-b213-992993c9834c", "solution": "import numpy as np\n\nclass AdaptiveSwarmMutationOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.F = 0.8\n        self.CR = 0.9\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Calculate population diversity\n            diversity = np.mean(np.std(positions, axis=0))\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation strategy based on diversity\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                if diversity < self.diversity_threshold:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                else:\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n        return g_best_position, g_best_score", "name": "AdaptiveSwarmMutationOptimization", "description": "Adaptive Swarm Mutation Optimization (ASMO) combines adaptive velocity updates with strategic mutation influenced by population diversity.", "configspace": "", "generation": 2, "fitness": 0.22094505580740537, "feedback": "The algorithm AdaptiveSwarmMutationOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "8cb9266d-09e5-4144-b032-fff89007a52f", "metadata": {"aucs": [0.5744932163933368, 0.5744932163933368, 0.5744932163933368, 0.6062663047944572, 0.6062663047944572, 0.6062663047944572, 0.5914684971902707, 0.5914684971902707, 0.5914684971902707, 0.23399475701643546, 0.23399475701643546, 0.23399475701643546, 0.13336999583753317, 0.13336999583753317, 0.13336999583753317, 0.14007641687971717, 0.14007641687971717, 0.14007641687971717, 0.11997588981090923, 0.11997588981090923, 0.11997588981090923, 0.08456048185906784, 0.08456048185906784, 0.08456048185906784, 0.18416771080701577, 0.18416771080701577, 0.18416771080701577, 0.08615242757883967, 0.08615242757883967, 0.08615242757883967, 0.09574144859178302, 0.09574144859178302, 0.09574144859178302, 0.08413196669392364, 0.08413196669392364, 0.08413196669392364, 0.9695968806296963, 0.9695968806296963, 0.9695968806296963, 0.9817786267238803, 0.9817786267238803, 0.9817786267238803, 0.9826483802332906, 0.9826483802332906, 0.9826483802332906, 0.30968764060326825, 0.30968764060326825, 0.30968764060326825, 0.13894460002558973, 0.13894460002558973, 0.13894460002558973, 0.24038029623056367, 0.24038029623056367, 0.24038029623056367, 0.3070946703108718, 0.3070946703108718, 0.3070946703108718, 0.20112637440800019, 0.20112637440800019, 0.20112637440800019, 0.2098814340762375, 0.2098814340762375, 0.2098814340762375, 0.15763756677867735, 0.15763756677867735, 0.15763756677867735, 0.1457817485740297, 0.1457817485740297, 0.1457817485740297, 0.15025943103295503, 0.15025943103295503, 0.15025943103295503, 0.14567453582671352, 0.14567453582671352, 0.14567453582671352, 0.1466026964188144, 0.1466026964188144, 0.1466026964188144, 0.1836310013233431, 0.1836310013233431, 0.1836310013233431, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07595864182007861, 0.07595864182007861, 0.07595864182007861, 0.028376847854691967, 0.028376847854691967, 0.028376847854691967, 0.03893505596850022, 0.03893505596850022, 0.03893505596850022, 0.02377090646651736, 0.02377090646651736, 0.02377090646651736, 0.04914088285290219, 0.04914088285290219, 0.04914088285290219, 0.046309275749036205, 0.046309275749036205, 0.046309275749036205, 0.11748888642990951, 0.11748888642990951, 0.11748888642990951, 0.0313269504558521, 0.0313269504558521, 0.0313269504558521, 0.05053708415237257, 0.05053708415237257, 0.05053708415237257, 0.42845781975176245, 0.42845781975176245, 0.42845781975176245, 0.4116999202924475, 0.4116999202924475, 0.4116999202924475, 0.4183082358046125, 0.4183082358046125, 0.4183082358046125, 0.09386278769098155, 0.09386278769098155, 0.09386278769098155, 0.14005139698711133, 0.14005139698711133, 0.14005139698711133, 0.09624383861879926, 0.09624383861879926, 0.09624383861879926, 0.14794022001552332, 0.14794022001552332, 0.14794022001552332, 0.17021091272908073, 0.17021091272908073, 0.17021091272908073, 0.18398469349556523, 0.18398469349556523, 0.18398469349556523, 0.3333899220654334, 0.3333899220654334, 0.3333899220654334, 0.1856935726607264, 0.1856935726607264, 0.1856935726607264, 0.3354891424131907, 0.3354891424131907, 0.3354891424131907, 0.19409741262573055, 0.19409741262573055, 0.19409741262573055, 0.17939059271116597, 0.17939059271116597, 0.17939059271116597, 0.15616553831436397, 0.15616553831436397, 0.15616553831436397, 0.19368615043734394, 0.19368615043734394, 0.19368615043734394, 0.2089866015718792, 0.2089866015718792, 0.2089866015718792, 0.18096050908649786, 0.18096050908649786, 0.18096050908649786, 0.17953056142499513, 0.17953056142499513, 0.17953056142499513, 0.21432178145774516, 0.21432178145774516, 0.21432178145774516, 0.17903982296141585, 0.17903982296141585, 0.17903982296141585, 0.6977031234851354, 0.6977031234851354, 0.6977031234851354, 0.19835013273992508, 0.19835013273992508, 0.19835013273992508, 0.1995300107382636, 0.1995300107382636, 0.1995300107382636, 0.20988877747705814, 0.20988877747705814, 0.20988877747705814, 0.19920422769112023, 0.19920422769112023, 0.19920422769112023, 0.3224501419092928, 0.3224501419092928, 0.3224501419092928, 0.18930806398908506, 0.18930806398908506, 0.18930806398908506, 0.18563716635547045, 0.18563716635547045, 0.18563716635547045, 0.17900240929616806, 0.17900240929616806, 0.17900240929616806, 0.07616681504309653, 0.07616681504309653, 0.07616681504309653, 0.07939620874772169, 0.07939620874772169, 0.07939620874772169, 0.07262597914539604, 0.07262597914539604, 0.07262597914539604]}, "mutation_prompt": null}
{"id": "b71baa6f-0908-4121-a18f-8ec5f4ed6452", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Increased population size\n        self.c1_initial = 2.0  # Adaptive parameter\n        self.c2_initial = 2.0  # Adaptive parameter\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.9  # Adjusted mutation factor\n        self.CR = 0.7  # Adjusted crossover rate\n        self.elitism_rate = 0.1  # Elitist selection rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Update velocities and positions using PSO with adaptive parameters\n            w = self.w_max - (self.w_max - self.w_min) * evaluations / self.budget\n            c1 = self.c1_initial - (self.c1_initial - 1.0) * evaluations / self.budget\n            c2 = self.c2_initial - (self.c2_initial - 1.0) * evaluations / self.budget\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + c1 * r1 * (p_best_positions - positions) \n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Differential Evolution strategy for mutation with elitist selection\n            elite_size = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(p_best_scores)[:elite_size]\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                if i in elite_indices:  # Skip mutation for elite individuals\n                    continue\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n        return g_best_position, g_best_score", "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid Particle Swarm and Differential Evolution with adaptive parameters and elitist selection for improved convergence.", "configspace": "", "generation": 3, "fitness": 0.194139598411966, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "8cb9266d-09e5-4144-b032-fff89007a52f", "metadata": {"aucs": [0.49537750509203615, 0.49537750509203615, 0.49537750509203615, 0.453484884525592, 0.453484884525592, 0.453484884525592, 0.5109122257589778, 0.5109122257589778, 0.5109122257589778, 0.18136139686447939, 0.18136139686447939, 0.18136139686447939, 0.16523351785410045, 0.16523351785410045, 0.16523351785410045, 0.16744476909667483, 0.16744476909667483, 0.16744476909667483, 0.09035845488218752, 0.09035845488218752, 0.09035845488218752, 0.0930400812819957, 0.0930400812819957, 0.0930400812819957, 0.11192272805796288, 0.11192272805796288, 0.11192272805796288, 0.09710603124649608, 0.09710603124649608, 0.09710603124649608, 0.0716708956979979, 0.0716708956979979, 0.0716708956979979, 0.07776145078083285, 0.07776145078083285, 0.07776145078083285, 0.9800935055616793, 0.9800935055616793, 0.9800935055616793, 0.9844691363631213, 0.9844691363631213, 0.9844691363631213, 0.9842650883988856, 0.9842650883988856, 0.9842650883988856, 0.2508170235836328, 0.2508170235836328, 0.2508170235836328, 0.1544105709210769, 0.1544105709210769, 0.1544105709210769, 0.19551226823825973, 0.19551226823825973, 0.19551226823825973, 0.1729418561337629, 0.1729418561337629, 0.1729418561337629, 0.16102804109409152, 0.16102804109409152, 0.16102804109409152, 0.20098509516628915, 0.20098509516628915, 0.20098509516628915, 0.10730310861056347, 0.10730310861056347, 0.10730310861056347, 0.060161724582120435, 0.060161724582120435, 0.060161724582120435, 0.10856734744862861, 0.10856734744862861, 0.10856734744862861, 0.0974188432963814, 0.0974188432963814, 0.0974188432963814, 0.09208255352585726, 0.09208255352585726, 0.09208255352585726, 0.05313786882397331, 0.05313786882397331, 0.05313786882397331, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06440677172152232, 0.06440677172152232, 0.06440677172152232, 0.04671849385146232, 0.04671849385146232, 0.04671849385146232, 0.05619065093404951, 0.05619065093404951, 0.05619065093404951, 0.046240825209025394, 0.046240825209025394, 0.046240825209025394, 0.03933721189628647, 0.03933721189628647, 0.03933721189628647, 0.041210088051917726, 0.041210088051917726, 0.041210088051917726, 0.031175608523335008, 0.031175608523335008, 0.031175608523335008, 0.029960442427132694, 0.029960442427132694, 0.029960442427132694, 0.04160529510737965, 0.04160529510737965, 0.04160529510737965, 0.3854225745079263, 0.3854225745079263, 0.3854225745079263, 0.41437258131466714, 0.41437258131466714, 0.41437258131466714, 0.3551918988608832, 0.3551918988608832, 0.3551918988608832, 0.061838605925265244, 0.061838605925265244, 0.061838605925265244, 0.0754767881579308, 0.0754767881579308, 0.0754767881579308, 0.08989631001893883, 0.08989631001893883, 0.08989631001893883, 0.18182436571412575, 0.18182436571412575, 0.18182436571412575, 0.16941642889217634, 0.16941642889217634, 0.16941642889217634, 0.1506233395222737, 0.1506233395222737, 0.1506233395222737, 0.2540083092473584, 0.2540083092473584, 0.2540083092473584, 0.1924886910072935, 0.1924886910072935, 0.1924886910072935, 0.27080051739658717, 0.27080051739658717, 0.27080051739658717, 0.1401127785756887, 0.1401127785756887, 0.1401127785756887, 0.15617451459509724, 0.15617451459509724, 0.15617451459509724, 0.13274379336659536, 0.13274379336659536, 0.13274379336659536, 0.16694252612483074, 0.16694252612483074, 0.16694252612483074, 0.18014641618562832, 0.18014641618562832, 0.18014641618562832, 0.17564686102482518, 0.17564686102482518, 0.17564686102482518, 0.15858589506339826, 0.15858589506339826, 0.15858589506339826, 0.15822840170105157, 0.15822840170105157, 0.15822840170105157, 0.18234119771068513, 0.18234119771068513, 0.18234119771068513, 0.5446741651747091, 0.5446741651747091, 0.5446741651747091, 0.11978551048975383, 0.11978551048975383, 0.11978551048975383, 0.17750107429138628, 0.17750107429138628, 0.17750107429138628, 0.4236332669808054, 0.4236332669808054, 0.4236332669808054, 0.18469610065462327, 0.18469610065462327, 0.18469610065462327, 0.1953181507294366, 0.1953181507294366, 0.1953181507294366, 0.18065812183398355, 0.18065812183398355, 0.18065812183398355, 0.1776870589240379, 0.1776870589240379, 0.1776870589240379, 0.18757490553437506, 0.18757490553437506, 0.18757490553437506, 0.06972640517446993, 0.06972640517446993, 0.06972640517446993, 0.06954632434408414, 0.06954632434408414, 0.06954632434408414, 0.07895384600689159, 0.07895384600689159, 0.07895384600689159]}, "mutation_prompt": null}
{"id": "1fd15842-4eb2-4d2a-8188-c9b9c4c4d848", "solution": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F_base = 0.8\n        self.CR = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            \n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Differential Evolution strategy with adaptive F\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                adaptive_F = self.F_base + 0.2 * ((evaluations / self.budget) ** 2)\n                mutant_vector = positions[a] + adaptive_F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n        return g_best_position, g_best_score", "name": "AdaptiveHybridPSO_DE", "description": "An adaptive Hybrid Particle Swarm and Differential Evolution algorithm, incorporating inertia weight adjustment and adaptive mutation strategies for enhanced performance.", "configspace": "", "generation": 4, "fitness": 0.21474721154116877, "feedback": "The algorithm AdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "8cb9266d-09e5-4144-b032-fff89007a52f", "metadata": {"aucs": [0.5850913402979345, 0.5850913402979345, 0.5850913402979345, 0.6096858946573536, 0.6096858946573536, 0.6096858946573536, 0.6000986758841251, 0.6000986758841251, 0.6000986758841251, 0.1511027079313797, 0.1511027079313797, 0.1511027079313797, 0.20202729942011, 0.20202729942011, 0.20202729942011, 0.28319628357946236, 0.28319628357946236, 0.28319628357946236, 0.12374137228512805, 0.12374137228512805, 0.12374137228512805, 0.10544800605733329, 0.10544800605733329, 0.10544800605733329, 0.1184146351465124, 0.1184146351465124, 0.1184146351465124, 0.10261252262151355, 0.10261252262151355, 0.10261252262151355, 0.09008727891707513, 0.09008727891707513, 0.09008727891707513, 0.09186417145517423, 0.09186417145517423, 0.09186417145517423, 0.9762680496600996, 0.9762680496600996, 0.9762680496600996, 0.9954640237244738, 0.9954640237244738, 0.9954640237244738, 0.9869583137049388, 0.9869583137049388, 0.9869583137049388, 0.3299718374178474, 0.3299718374178474, 0.3299718374178474, 0.13683810190675427, 0.13683810190675427, 0.13683810190675427, 0.27792891328347413, 0.27792891328347413, 0.27792891328347413, 0.31826418050916305, 0.31826418050916305, 0.31826418050916305, 0.15183308690736508, 0.15183308690736508, 0.15183308690736508, 0.17369419386392948, 0.17369419386392948, 0.17369419386392948, 0.13458372252466344, 0.13458372252466344, 0.13458372252466344, 0.10264601385131411, 0.10264601385131411, 0.10264601385131411, 0.12367189458155647, 0.12367189458155647, 0.12367189458155647, 0.019263892919481274, 0.019263892919481274, 0.019263892919481274, 0.14636321770944882, 0.14636321770944882, 0.14636321770944882, 0.10296335640044418, 0.10296335640044418, 0.10296335640044418, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08434460419143708, 0.08434460419143708, 0.08434460419143708, 0.016140083043020947, 0.016140083043020947, 0.016140083043020947, 0.06847702866468175, 0.06847702866468175, 0.06847702866468175, 0.02371393162857327, 0.02371393162857327, 0.02371393162857327, 0.036207236433492884, 0.036207236433492884, 0.036207236433492884, 0.040419018491154035, 0.040419018491154035, 0.040419018491154035, 0.07748522227533106, 0.07748522227533106, 0.07748522227533106, 0.004266274195523279, 0.004266274195523279, 0.004266274195523279, 0.03687986841368618, 0.03687986841368618, 0.03687986841368618, 0.40113935234789266, 0.40113935234789266, 0.40113935234789266, 0.4318065203831799, 0.4318065203831799, 0.4318065203831799, 0.42281563780063214, 0.42281563780063214, 0.42281563780063214, 0.08588512267342907, 0.08588512267342907, 0.08588512267342907, 0.10891819819607029, 0.10891819819607029, 0.10891819819607029, 0.08245413161636805, 0.08245413161636805, 0.08245413161636805, 0.1431454838252646, 0.1431454838252646, 0.1431454838252646, 0.15774422760370976, 0.15774422760370976, 0.15774422760370976, 0.22390530357290483, 0.22390530357290483, 0.22390530357290483, 0.24003926896797612, 0.24003926896797612, 0.24003926896797612, 0.3031921381046875, 0.3031921381046875, 0.3031921381046875, 0.29438177291382917, 0.29438177291382917, 0.29438177291382917, 0.1772400752893849, 0.1772400752893849, 0.1772400752893849, 0.1635202966299838, 0.1635202966299838, 0.1635202966299838, 0.2062466040203531, 0.2062466040203531, 0.2062466040203531, 0.18776769277783323, 0.18776769277783323, 0.18776769277783323, 0.18968735389670788, 0.18968735389670788, 0.18968735389670788, 0.20066709999745913, 0.20066709999745913, 0.20066709999745913, 0.17139374395164597, 0.17139374395164597, 0.17139374395164597, 0.19421449467306662, 0.19421449467306662, 0.19421449467306662, 0.18859426400968382, 0.18859426400968382, 0.18859426400968382, 0.6940031115726939, 0.6940031115726939, 0.6940031115726939, 0.16104225289592067, 0.16104225289592067, 0.16104225289592067, 0.17434719838010737, 0.17434719838010737, 0.17434719838010737, 0.15798185050828728, 0.15798185050828728, 0.15798185050828728, 0.35053151609926203, 0.35053151609926203, 0.35053151609926203, 0.14876841027376775, 0.14876841027376775, 0.14876841027376775, 0.1778165708914614, 0.1778165708914614, 0.1778165708914614, 0.19054452862038018, 0.19054452862038018, 0.19054452862038018, 0.1797682559721625, 0.1797682559721625, 0.1797682559721625, 0.0695585728374426, 0.0695585728374426, 0.0695585728374426, 0.06576409709590936, 0.06576409709590936, 0.06576409709590936, 0.08859782800973603, 0.08859782800973603, 0.08859782800973603]}, "mutation_prompt": null}
{"id": "029d2826-4200-4604-9880-903f5e8b1ae0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 40\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.F = 0.8\n        self.CR = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (self.w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Differential Evolution strategy for mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n        return g_best_position, g_best_score", "name": "HybridPSO_DE", "description": "Hybrid Particle Swarm and Differential Evolution algorithm leveraging swarm intelligence and mutation strategies.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8cb9266d-09e5-4144-b032-fff89007a52f", "metadata": {"aucs": [0.5744932163933368, 0.5744932163933368, 0.5744932163933368, 0.6062663047944572, 0.6062663047944572, 0.6062663047944572, 0.5914684971902707, 0.5914684971902707, 0.5914684971902707, 0.23399475701643546, 0.23399475701643546, 0.23399475701643546, 0.13336999583753317, 0.13336999583753317, 0.13336999583753317, 0.14007641687971717, 0.14007641687971717, 0.14007641687971717, 0.11997588981090923, 0.11997588981090923, 0.11997588981090923, 0.08456048185906784, 0.08456048185906784, 0.08456048185906784, 0.18416771080701577, 0.18416771080701577, 0.18416771080701577, 0.08615242757883967, 0.08615242757883967, 0.08615242757883967, 0.09574144859178302, 0.09574144859178302, 0.09574144859178302, 0.08413196669392364, 0.08413196669392364, 0.08413196669392364, 0.9695968806296963, 0.9695968806296963, 0.9695968806296963, 0.9817786267238803, 0.9817786267238803, 0.9817786267238803, 0.9826483802332906, 0.9826483802332906, 0.9826483802332906, 0.30968764060326825, 0.30968764060326825, 0.30968764060326825, 0.13894460002558973, 0.13894460002558973, 0.13894460002558973, 0.24038029623056367, 0.24038029623056367, 0.24038029623056367, 0.3070946703108718, 0.3070946703108718, 0.3070946703108718, 0.20112637440800019, 0.20112637440800019, 0.20112637440800019, 0.2098814340762375, 0.2098814340762375, 0.2098814340762375, 0.15763756677867735, 0.15763756677867735, 0.15763756677867735, 0.1457817485740297, 0.1457817485740297, 0.1457817485740297, 0.15025943103295503, 0.15025943103295503, 0.15025943103295503, 0.14567453582671352, 0.14567453582671352, 0.14567453582671352, 0.1466026964188144, 0.1466026964188144, 0.1466026964188144, 0.1836310013233431, 0.1836310013233431, 0.1836310013233431, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07595864182007861, 0.07595864182007861, 0.07595864182007861, 0.028376847854691967, 0.028376847854691967, 0.028376847854691967, 0.03893505596850022, 0.03893505596850022, 0.03893505596850022, 0.02377090646651736, 0.02377090646651736, 0.02377090646651736, 0.04914088285290219, 0.04914088285290219, 0.04914088285290219, 0.046309275749036205, 0.046309275749036205, 0.046309275749036205, 0.11748888642990951, 0.11748888642990951, 0.11748888642990951, 0.0313269504558521, 0.0313269504558521, 0.0313269504558521, 0.05053708415237257, 0.05053708415237257, 0.05053708415237257, 0.42845781975176245, 0.42845781975176245, 0.42845781975176245, 0.4116999202924475, 0.4116999202924475, 0.4116999202924475, 0.4183082358046125, 0.4183082358046125, 0.4183082358046125, 0.09386278769098155, 0.09386278769098155, 0.09386278769098155, 0.14005139698711133, 0.14005139698711133, 0.14005139698711133, 0.09624383861879926, 0.09624383861879926, 0.09624383861879926, 0.14794022001552332, 0.14794022001552332, 0.14794022001552332, 0.17021091272908073, 0.17021091272908073, 0.17021091272908073, 0.18398469349556523, 0.18398469349556523, 0.18398469349556523, 0.3333899220654334, 0.3333899220654334, 0.3333899220654334, 0.1856935726607264, 0.1856935726607264, 0.1856935726607264, 0.3354891424131907, 0.3354891424131907, 0.3354891424131907, 0.19409741262573055, 0.19409741262573055, 0.19409741262573055, 0.17939059271116597, 0.17939059271116597, 0.17939059271116597, 0.15616553831436397, 0.15616553831436397, 0.15616553831436397, 0.19368615043734394, 0.19368615043734394, 0.19368615043734394, 0.2089866015718792, 0.2089866015718792, 0.2089866015718792, 0.18096050908649786, 0.18096050908649786, 0.18096050908649786, 0.17953056142499513, 0.17953056142499513, 0.17953056142499513, 0.21432178145774516, 0.21432178145774516, 0.21432178145774516, 0.17903982296141585, 0.17903982296141585, 0.17903982296141585, 0.6977031234851354, 0.6977031234851354, 0.6977031234851354, 0.19835013273992508, 0.19835013273992508, 0.19835013273992508, 0.1995300107382636, 0.1995300107382636, 0.1995300107382636, 0.20988877747705814, 0.20988877747705814, 0.20988877747705814, 0.19920422769112023, 0.19920422769112023, 0.19920422769112023, 0.3224501419092928, 0.3224501419092928, 0.3224501419092928, 0.18930806398908506, 0.18930806398908506, 0.18930806398908506, 0.18563716635547045, 0.18563716635547045, 0.18563716635547045, 0.17900240929616806, 0.17900240929616806, 0.17900240929616806, 0.07616681504309653, 0.07616681504309653, 0.07616681504309653, 0.07939620874772169, 0.07939620874772169, 0.07939620874772169, 0.07262597914539604, 0.07262597914539604, 0.07262597914539604]}, "mutation_prompt": null}
{"id": "ecfd95ec-637e-4943-83b1-e7a6409773c5", "solution": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.9\n        self.CR = 0.7\n        self.clone_factor = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n\n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Clonal Selection for mutation\n            clone_count = int(self.clone_factor * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n        return g_best_position, g_best_score", "name": "AdaptiveHybridPSO_DE", "description": "Adaptive Hybrid Particle Swarm and Differential Evolution with dynamic parameters and Clonal Selection.", "configspace": "", "generation": 6, "fitness": 0.239277815980058, "feedback": "The algorithm AdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "8cb9266d-09e5-4144-b032-fff89007a52f", "metadata": {"aucs": [0.6282963055801034, 0.6282963055801034, 0.6282963055801034, 0.6747294052947241, 0.6747294052947241, 0.6747294052947241, 0.6608877957885697, 0.6608877957885697, 0.6608877957885697, 0.3657418348718371, 0.3657418348718371, 0.3657418348718371, 0.27336848376576517, 0.27336848376576517, 0.27336848376576517, 0.2335197693386324, 0.2335197693386324, 0.2335197693386324, 0.10547820491382154, 0.10547820491382154, 0.10547820491382154, 0.10638031332784681, 0.10638031332784681, 0.10638031332784681, 0.15905795497019803, 0.15905795497019803, 0.15905795497019803, 0.08460539441458514, 0.08460539441458514, 0.08460539441458514, 0.1207467398841745, 0.1207467398841745, 0.1207467398841745, 0.1206743687965467, 0.1206743687965467, 0.1206743687965467, 0.9950445067520778, 0.9950445067520778, 0.9950445067520778, 0.9914254271643111, 0.9914254271643111, 0.9914254271643111, 0.9880258631931165, 0.9880258631931165, 0.9880258631931165, 0.328269522059654, 0.328269522059654, 0.328269522059654, 0.4321322323369807, 0.4321322323369807, 0.4321322323369807, 0.35570309005874234, 0.35570309005874234, 0.35570309005874234, 0.49904315998382476, 0.49904315998382476, 0.49904315998382476, 0.18117850806776215, 0.18117850806776215, 0.18117850806776215, 0.14242491647255395, 0.14242491647255395, 0.14242491647255395, 0.18050822107159636, 0.18050822107159636, 0.18050822107159636, 0.11501805425952716, 0.11501805425952716, 0.11501805425952716, 0.16357974432646039, 0.16357974432646039, 0.16357974432646039, 0.18153939693038224, 0.18153939693038224, 0.18153939693038224, 0.15349488653108434, 0.15349488653108434, 0.15349488653108434, 0.032639461613149234, 0.032639461613149234, 0.032639461613149234, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04549005036343312, 0.04549005036343312, 0.04549005036343312, 0.049812256397409826, 0.049812256397409826, 0.049812256397409826, 0.0009406142340998569, 0.0009406142340998569, 0.0009406142340998569, 0.04277532893801839, 0.04277532893801839, 0.04277532893801839, 0.03080520392380781, 0.03080520392380781, 0.03080520392380781, 0.09766661587489911, 0.09766661587489911, 0.09766661587489911, 0.04525969822985698, 0.04525969822985698, 0.04525969822985698, 0.0077462961857632795, 0.0077462961857632795, 0.0077462961857632795, 0.03134920125289098, 0.03134920125289098, 0.03134920125289098, 0.06848273101106739, 0.06848273101106739, 0.06848273101106739, 0.43816515297399716, 0.43816515297399716, 0.43816515297399716, 0.482162391057369, 0.482162391057369, 0.482162391057369, 0.4342437676898093, 0.4342437676898093, 0.4342437676898093, 0.053009327301313136, 0.053009327301313136, 0.053009327301313136, 0.08933938016044651, 0.08933938016044651, 0.08933938016044651, 0.11058840009144866, 0.11058840009144866, 0.11058840009144866, 0.3513628427430805, 0.3513628427430805, 0.3513628427430805, 0.14360131068635706, 0.14360131068635706, 0.14360131068635706, 0.15283594573581427, 0.15283594573581427, 0.15283594573581427, 0.22152164532365715, 0.22152164532365715, 0.22152164532365715, 0.30195175606045765, 0.30195175606045765, 0.30195175606045765, 0.3550831940213971, 0.3550831940213971, 0.3550831940213971, 0.17364207810352095, 0.17364207810352095, 0.17364207810352095, 0.191450308933781, 0.191450308933781, 0.191450308933781, 0.2349683283724323, 0.2349683283724323, 0.2349683283724323, 0.17055573189929052, 0.17055573189929052, 0.17055573189929052, 0.1868419709180852, 0.1868419709180852, 0.1868419709180852, 0.1913741628302309, 0.1913741628302309, 0.1913741628302309, 0.21007892363579783, 0.21007892363579783, 0.21007892363579783, 0.21353055463844495, 0.21353055463844495, 0.21353055463844495, 0.16960410588207375, 0.16960410588207375, 0.16960410588207375, 0.7199968219630907, 0.7199968219630907, 0.7199968219630907, 0.1892371174418469, 0.1892371174418469, 0.1892371174418469, 0.20230717285795496, 0.20230717285795496, 0.20230717285795496, 0.1514767005038935, 0.1514767005038935, 0.1514767005038935, 0.191951006553696, 0.191951006553696, 0.191951006553696, 0.3305628132105818, 0.3305628132105818, 0.3305628132105818, 0.2233722215785262, 0.2233722215785262, 0.2233722215785262, 0.20536044188337865, 0.20536044188337865, 0.20536044188337865, 0.20019657226996423, 0.20019657226996423, 0.20019657226996423, 0.07904760387418974, 0.07904760387418974, 0.07904760387418974, 0.08407548506547047, 0.08407548506547047, 0.08407548506547047, 0.08046595612350482, 0.08046595612350482, 0.08046595612350482]}, "mutation_prompt": null}
{"id": "1b7e3339-b390-496d-b079-31e185a9e7b4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.9\n        self.CR = 0.7\n        self.clone_factor = 0.2\n        self.mutation_probability = 0.1  # Additional mutation step probability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.exp(-3.0 * evaluations / self.budget)  # Dynamic inertia\n\n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Clonal Selection for mutation\n            clone_count = int(self.clone_factor * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            # Random mutation injection to enhance exploration\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Enhanced Adaptive Hybrid PSO-DE using Dynamic Inertia and Random Mutation Injection for improved exploration and exploitation.", "configspace": "", "generation": 7, "fitness": 0.2792181582636953, "feedback": "The algorithm EnhancedAdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "ecfd95ec-637e-4943-83b1-e7a6409773c5", "metadata": {"aucs": [0.8725012748313039, 0.8725012748313039, 0.8725012748313039, 0.8612118986093036, 0.8612118986093036, 0.8612118986093036, 0.8604930944017236, 0.8604930944017236, 0.8604930944017236, 0.5716108184368867, 0.5716108184368867, 0.5716108184368867, 0.46365284743684654, 0.46365284743684654, 0.46365284743684654, 0.4758453302417961, 0.4758453302417961, 0.4758453302417961, 0.1453116961318186, 0.1453116961318186, 0.1453116961318186, 0.1529404035337868, 0.1529404035337868, 0.1529404035337868, 0.14820380115472653, 0.14820380115472653, 0.14820380115472653, 0.11476701318947558, 0.11476701318947558, 0.11476701318947558, 0.10178135747772898, 0.10178135747772898, 0.10178135747772898, 0.1493507948413484, 0.1493507948413484, 0.1493507948413484, 0.98614505843781, 0.98614505843781, 0.98614505843781, 0.9802533983142696, 0.9802533983142696, 0.9802533983142696, 0.9811970025304232, 0.9811970025304232, 0.9811970025304232, 0.42980104367913985, 0.42980104367913985, 0.42980104367913985, 0.501285504376558, 0.501285504376558, 0.501285504376558, 0.5013799114941708, 0.5013799114941708, 0.5013799114941708, 0.1952639378037765, 0.1952639378037765, 0.1952639378037765, 0.2115304707870922, 0.2115304707870922, 0.2115304707870922, 0.2296628939514711, 0.2296628939514711, 0.2296628939514711, 0.18556877079643253, 0.18556877079643253, 0.18556877079643253, 0.183788728099731, 0.183788728099731, 0.183788728099731, 0.21766188946603537, 0.21766188946603537, 0.21766188946603537, 0.20272425578181896, 0.20272425578181896, 0.20272425578181896, 0.2177885437903183, 0.2177885437903183, 0.2177885437903183, 0.23760525582120362, 0.23760525582120362, 0.23760525582120362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0826002768181976, 0.0826002768181976, 0.0826002768181976, 0.01089069812073995, 0.01089069812073995, 0.01089069812073995, 0.045775254898898, 0.045775254898898, 0.045775254898898, 0.05029427997864766, 0.05029427997864766, 0.05029427997864766, 0.08027169010226043, 0.08027169010226043, 0.08027169010226043, 0.09588610612481441, 0.09588610612481441, 0.09588610612481441, 0.04655837060995438, 0.04655837060995438, 0.04655837060995438, 0.18205977005591112, 0.18205977005591112, 0.18205977005591112, 0.0566211826087929, 0.0566211826087929, 0.0566211826087929, 0.5149645561592313, 0.5149645561592313, 0.5149645561592313, 0.5542707490256605, 0.5542707490256605, 0.5542707490256605, 0.5308505906848282, 0.5308505906848282, 0.5308505906848282, 0.15356033046763895, 0.15356033046763895, 0.15356033046763895, 0.140809796634912, 0.140809796634912, 0.140809796634912, 0.11368900300127682, 0.11368900300127682, 0.11368900300127682, 0.15246810855090187, 0.15246810855090187, 0.15246810855090187, 0.15180418256493977, 0.15180418256493977, 0.15180418256493977, 0.1381148317223455, 0.1381148317223455, 0.1381148317223455, 0.3507632995212573, 0.3507632995212573, 0.3507632995212573, 0.38792891181499567, 0.38792891181499567, 0.38792891181499567, 0.2737296386211179, 0.2737296386211179, 0.2737296386211179, 0.16341209859661998, 0.16341209859661998, 0.16341209859661998, 0.23168998960351161, 0.23168998960351161, 0.23168998960351161, 0.13872291163920158, 0.13872291163920158, 0.13872291163920158, 0.20883049313830881, 0.20883049313830881, 0.20883049313830881, 0.19870627482808456, 0.19870627482808456, 0.19870627482808456, 0.24659186334012728, 0.24659186334012728, 0.24659186334012728, 0.6074764415422877, 0.6074764415422877, 0.6074764415422877, 0.2003965809115652, 0.2003965809115652, 0.2003965809115652, 0.198593680928413, 0.198593680928413, 0.198593680928413, 0.9120892446274858, 0.9120892446274858, 0.9120892446274858, 0.15230095905234542, 0.15230095905234542, 0.15230095905234542, 0.14356535311858154, 0.14356535311858154, 0.14356535311858154, 0.20829658387965488, 0.20829658387965488, 0.20829658387965488, 0.21026269754061855, 0.21026269754061855, 0.21026269754061855, 0.15582014182004444, 0.15582014182004444, 0.15582014182004444, 0.19941320503039783, 0.19941320503039783, 0.19941320503039783, 0.18774792369896354, 0.18774792369896354, 0.18774792369896354, 0.18597129093042575, 0.18597129093042575, 0.18597129093042575, 0.09758331633514084, 0.09758331633514084, 0.09758331633514084, 0.0805032349294803, 0.0805032349294803, 0.0805032349294803, 0.08219448599048407, 0.08219448599048407, 0.08219448599048407]}, "mutation_prompt": null}
{"id": "74d192d6-9797-4d9b-9135-7fc394376e31", "solution": "import numpy as np\n\nclass AdaptiveHierarchicalPSO_DE_Clonal:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.8\n        self.CR = 0.6\n        self.clone_factor = 0.2\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear dynamic inertia\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.clone_factor * self.population_size)\n            for i in range(clone_count):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = p_best_positions[a] + self.F * (p_best_positions[b] - p_best_positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveHierarchicalPSO_DE_Clonal", "description": "Adaptive Hierarchical PSO with Differential Mutation and Clonal Selection for Balanced Exploration and Exploitation.", "configspace": "", "generation": 8, "fitness": 0.2313589721991762, "feedback": "The algorithm AdaptiveHierarchicalPSO_DE_Clonal got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "1b7e3339-b390-496d-b079-31e185a9e7b4", "metadata": {"aucs": [0.6433921976735546, 0.6433921976735546, 0.6433921976735546, 0.6464603220413947, 0.6464603220413947, 0.6464603220413947, 0.6620711686820848, 0.6620711686820848, 0.6620711686820848, 0.3460350446870407, 0.3460350446870407, 0.3460350446870407, 0.318955988861795, 0.318955988861795, 0.318955988861795, 0.3700038780944934, 0.3700038780944934, 0.3700038780944934, 0.10061321624327135, 0.10061321624327135, 0.10061321624327135, 0.13558285212343524, 0.13558285212343524, 0.13558285212343524, 0.2382299445190298, 0.2382299445190298, 0.2382299445190298, 0.11150629666429845, 0.11150629666429845, 0.11150629666429845, 0.10205262033684082, 0.10205262033684082, 0.10205262033684082, 0.10717166558766333, 0.10717166558766333, 0.10717166558766333, 0.9872754245944175, 0.9872754245944175, 0.9872754245944175, 0.9913937453222196, 0.9913937453222196, 0.9913937453222196, 0.9876273072432014, 0.9876273072432014, 0.9876273072432014, 0.3805223457321364, 0.3805223457321364, 0.3805223457321364, 0.14244114616561487, 0.14244114616561487, 0.14244114616561487, 0.3465975693666272, 0.3465975693666272, 0.3465975693666272, 0.18151550045570852, 0.18151550045570852, 0.18151550045570852, 0.1565108996336665, 0.1565108996336665, 0.1565108996336665, 0.17299074647085289, 0.17299074647085289, 0.17299074647085289, 0.18003403743237445, 0.18003403743237445, 0.18003403743237445, 0.10680229292049315, 0.10680229292049315, 0.10680229292049315, 0.15696289204326164, 0.15696289204326164, 0.15696289204326164, 0.16219960914941056, 0.16219960914941056, 0.16219960914941056, 0.13898287898580441, 0.13898287898580441, 0.13898287898580441, 0.09570200514944516, 0.09570200514944516, 0.09570200514944516, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026390845973559007, 0.026390845973559007, 0.026390845973559007, 0.0063770203483720644, 0.0063770203483720644, 0.0063770203483720644, 0.0949341236846254, 0.0949341236846254, 0.0949341236846254, 0.018845681848567275, 0.018845681848567275, 0.018845681848567275, 0.061890886975729864, 0.061890886975729864, 0.061890886975729864, 0.030754801424520917, 0.030754801424520917, 0.030754801424520917, 0.11118471182146528, 0.11118471182146528, 0.11118471182146528, 0.06426560232830247, 0.06426560232830247, 0.06426560232830247, 0.07044117775321523, 0.07044117775321523, 0.07044117775321523, 0.03141813200089749, 0.03141813200089749, 0.03141813200089749, 0.0487203121170956, 0.0487203121170956, 0.0487203121170956, 0.409934013793787, 0.409934013793787, 0.409934013793787, 0.44505262388873157, 0.44505262388873157, 0.44505262388873157, 0.4438790361067324, 0.4438790361067324, 0.4438790361067324, 0.08574486891050215, 0.08574486891050215, 0.08574486891050215, 0.08252034562989397, 0.08252034562989397, 0.08252034562989397, 0.07823073007307724, 0.07823073007307724, 0.07823073007307724, 0.1996131767435796, 0.1996131767435796, 0.1996131767435796, 0.15755165912561264, 0.15755165912561264, 0.15755165912561264, 0.27894702002323346, 0.27894702002323346, 0.27894702002323346, 0.2381988698093611, 0.2381988698093611, 0.2381988698093611, 0.3518879839103817, 0.3518879839103817, 0.3518879839103817, 0.2515461741838372, 0.2515461741838372, 0.2515461741838372, 0.13193725813415969, 0.13193725813415969, 0.13193725813415969, 0.17736545673911042, 0.17736545673911042, 0.17736545673911042, 0.15818545733702594, 0.15818545733702594, 0.15818545733702594, 0.18055861211662982, 0.18055861211662982, 0.18055861211662982, 0.19992671084326352, 0.19992671084326352, 0.19992671084326352, 0.19878568073156921, 0.19878568073156921, 0.19878568073156921, 0.183313036644833, 0.183313036644833, 0.183313036644833, 0.21081874264428802, 0.21081874264428802, 0.21081874264428802, 0.22754123780137891, 0.22754123780137891, 0.22754123780137891, 0.7432296394731899, 0.7432296394731899, 0.7432296394731899, 0.16202540040040458, 0.16202540040040458, 0.16202540040040458, 0.16755961136086772, 0.16755961136086772, 0.16755961136086772, 0.16166200093383265, 0.16166200093383265, 0.16166200093383265, 0.20408821072383854, 0.20408821072383854, 0.20408821072383854, 0.20225794782861828, 0.20225794782861828, 0.20225794782861828, 0.19493969339426054, 0.19493969339426054, 0.19493969339426054, 0.18639759297879777, 0.18639759297879777, 0.18639759297879777, 0.17155443671713655, 0.17155443671713655, 0.17155443671713655, 0.08413842843689723, 0.08413842843689723, 0.08413842843689723, 0.07249419010906244, 0.07249419010906244, 0.07249419010906244, 0.08100325833630373, 0.08100325833630373, 0.08100325833630373]}, "mutation_prompt": null}
{"id": "74435989-c661-4b00-aca2-5004a57e26ae", "solution": "import numpy as np\n\nclass AdvancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.8\n        self.CR = 0.6\n        self.clone_factor = 0.3\n        self.mutation_probability = 0.15  # Increased mutation step probability\n        self.precision_factor = 1e-5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        random_walk = np.random.choice([True, False], size=self.population_size, p=[0.5, 0.5])\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear decay inertia\n\n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                if random_walk[i]:\n                    positions[i] += np.random.normal(0, 0.1, self.dim)\n                    positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Clonal Selection for mutation\n            clone_count = int(self.clone_factor * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            # Random mutation injection to enhance exploration\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdvancedHybridPSO_DE", "description": "Advanced Hybrid PSO-DE with Adaptive Precision and Random Walk Initialization for enhanced exploration and convergence. ", "configspace": "", "generation": 9, "fitness": 0.21322982869260287, "feedback": "The algorithm AdvancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "1b7e3339-b390-496d-b079-31e185a9e7b4", "metadata": {"aucs": [0.5511484997083385, 0.5511484997083385, 0.5511484997083385, 0.5749421194815456, 0.5749421194815456, 0.5749421194815456, 0.5748042481151535, 0.5748042481151535, 0.5748042481151535, 0.1652826728846305, 0.1652826728846305, 0.1652826728846305, 0.13726575832927423, 0.13726575832927423, 0.13726575832927423, 0.06495745581388745, 0.06495745581388745, 0.06495745581388745, 0.11972027664827367, 0.11972027664827367, 0.11972027664827367, 0.06115978911228215, 0.06115978911228215, 0.06115978911228215, 0.10232929773506205, 0.10232929773506205, 0.10232929773506205, 0.0818532765958917, 0.0818532765958917, 0.0818532765958917, 0.09598760105696524, 0.09598760105696524, 0.09598760105696524, 0.08463594551332787, 0.08463594551332787, 0.08463594551332787, 0.9895698894660437, 0.9895698894660437, 0.9895698894660437, 0.986534150235359, 0.986534150235359, 0.986534150235359, 0.9928613720370575, 0.9928613720370575, 0.9928613720370575, 0.2543926574949197, 0.2543926574949197, 0.2543926574949197, 0.22558402470078043, 0.22558402470078043, 0.22558402470078043, 0.2715266696593116, 0.2715266696593116, 0.2715266696593116, 0.1880109978915938, 0.1880109978915938, 0.1880109978915938, 0.16887371079974323, 0.16887371079974323, 0.16887371079974323, 0.2655044343503623, 0.2655044343503623, 0.2655044343503623, 0.1320374979030332, 0.1320374979030332, 0.1320374979030332, 0.16110272914267898, 0.16110272914267898, 0.16110272914267898, 0.1155372407449955, 0.1155372407449955, 0.1155372407449955, 0.09614286038616338, 0.09614286038616338, 0.09614286038616338, 0.17731556614572908, 0.17731556614572908, 0.17731556614572908, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008409762922616415, 0.008409762922616415, 0.008409762922616415, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05192372580085758, 0.05192372580085758, 0.05192372580085758, 0.015663939384575443, 0.015663939384575443, 0.015663939384575443, 0.017355219723920845, 0.017355219723920845, 0.017355219723920845, 0.026501029628647976, 0.026501029628647976, 0.026501029628647976, 0.03754436264402772, 0.03754436264402772, 0.03754436264402772, 0.04026152471895239, 0.04026152471895239, 0.04026152471895239, 0.03687540021797764, 0.03687540021797764, 0.03687540021797764, 0.03775577460902191, 0.03775577460902191, 0.03775577460902191, 0.04259495047087347, 0.04259495047087347, 0.04259495047087347, 0.44564627036762117, 0.44564627036762117, 0.44564627036762117, 0.39526159849335085, 0.39526159849335085, 0.39526159849335085, 0.4452591381921909, 0.4452591381921909, 0.4452591381921909, 0.088069545674055, 0.088069545674055, 0.088069545674055, 0.09229133425655256, 0.09229133425655256, 0.09229133425655256, 0.0890384719530164, 0.0890384719530164, 0.0890384719530164, 0.16255748234105283, 0.16255748234105283, 0.16255748234105283, 0.2146893613460068, 0.2146893613460068, 0.2146893613460068, 0.19230620100595552, 0.19230620100595552, 0.19230620100595552, 0.2728558768362235, 0.2728558768362235, 0.2728558768362235, 0.26140280449982733, 0.26140280449982733, 0.26140280449982733, 0.2764802653579741, 0.2764802653579741, 0.2764802653579741, 0.20934686979671546, 0.20934686979671546, 0.20934686979671546, 0.166283702029431, 0.166283702029431, 0.166283702029431, 0.19363833664492036, 0.19363833664492036, 0.19363833664492036, 0.1851976719631817, 0.1851976719631817, 0.1851976719631817, 0.18373266863208104, 0.18373266863208104, 0.18373266863208104, 0.18736220486324273, 0.18736220486324273, 0.18736220486324273, 0.21159639941563568, 0.21159639941563568, 0.21159639941563568, 0.1938368035428878, 0.1938368035428878, 0.1938368035428878, 0.17849377918831322, 0.17849377918831322, 0.17849377918831322, 0.7030828467027717, 0.7030828467027717, 0.7030828467027717, 0.181264526197619, 0.181264526197619, 0.181264526197619, 0.5669178820252325, 0.5669178820252325, 0.5669178820252325, 0.16396930793890463, 0.16396930793890463, 0.16396930793890463, 0.19587799510996406, 0.19587799510996406, 0.19587799510996406, 0.1488322424624101, 0.1488322424624101, 0.1488322424624101, 0.1894542191392139, 0.1894542191392139, 0.1894542191392139, 0.1992497768362569, 0.1992497768362569, 0.1992497768362569, 0.19213458294590313, 0.19213458294590313, 0.19213458294590313, 0.06798402163115858, 0.06798402163115858, 0.06798402163115858, 0.07131101676683016, 0.07131101676683016, 0.07131101676683016, 0.07285602963702953, 0.07285602963702953, 0.07285602963702953]}, "mutation_prompt": null}
{"id": "9f3b8de2-4ef4-4ebe-aae2-1300938acc2a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.8  # Adjusted differential weight\n        self.CR = 0.7\n        self.clone_factor = 0.2\n        self.mutation_probability = 0.2  # Increased mutation step probability\n        self.elite_retention = 0.1  # Retention of elite solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.exp(-3.0 * evaluations / self.budget)\n\n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Clonal Selection for mutation\n            clone_count = int(self.clone_factor * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            # Random mutation injection to enhance exploration\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n            # Elite Retention\n            elite_indices = np.argsort(p_best_scores)[:int(self.elite_retention * self.population_size)]\n            for elite_idx in elite_indices:\n                positions[elite_idx] = p_best_positions[elite_idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedAdaptiveHybridPSO_DE", "description": "Hybrid Particle Swarm Optimization with Adaptive Mutation and Elite Retention for enhanced convergence and diversity.", "configspace": "", "generation": 10, "fitness": 0.2519907876310571, "feedback": "The algorithm EnhancedAdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "1b7e3339-b390-496d-b079-31e185a9e7b4", "metadata": {"aucs": [0.8042184124179973, 0.8042184124179973, 0.8042184124179973, 0.8478433270375477, 0.8478433270375477, 0.8478433270375477, 0.8492499856228863, 0.8492499856228863, 0.8492499856228863, 0.3667919570751116, 0.3667919570751116, 0.3667919570751116, 0.41445971959968597, 0.41445971959968597, 0.41445971959968597, 0.22356205929735284, 0.22356205929735284, 0.22356205929735284, 0.18027373607332486, 0.18027373607332486, 0.18027373607332486, 0.06499266134677095, 0.06499266134677095, 0.06499266134677095, 0.15645564822372438, 0.15645564822372438, 0.15645564822372438, 0.13465445019870437, 0.13465445019870437, 0.13465445019870437, 0.0920037343186112, 0.0920037343186112, 0.0920037343186112, 0.12379983404345007, 0.12379983404345007, 0.12379983404345007, 0.984228890198159, 0.984228890198159, 0.984228890198159, 0.980384546163114, 0.980384546163114, 0.980384546163114, 0.9810583837840736, 0.9810583837840736, 0.9810583837840736, 0.3659847440382227, 0.3659847440382227, 0.3659847440382227, 0.38091808233725744, 0.38091808233725744, 0.38091808233725744, 0.4149861272928227, 0.4149861272928227, 0.4149861272928227, 0.20819122017731329, 0.20819122017731329, 0.20819122017731329, 0.160819972108601, 0.160819972108601, 0.160819972108601, 0.22630512696221672, 0.22630512696221672, 0.22630512696221672, 0.17823875749121065, 0.17823875749121065, 0.17823875749121065, 0.2034992083163849, 0.2034992083163849, 0.2034992083163849, 0.12710217668914314, 0.12710217668914314, 0.12710217668914314, 0.1618995666483536, 0.1618995666483536, 0.1618995666483536, 0.11518145198005636, 0.11518145198005636, 0.11518145198005636, 0.20216313788907758, 0.20216313788907758, 0.20216313788907758, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09316207831956302, 0.09316207831956302, 0.09316207831956302, 0.040930162902062306, 0.040930162902062306, 0.040930162902062306, 0.041045429026845937, 0.041045429026845937, 0.041045429026845937, 0.0475314586781298, 0.0475314586781298, 0.0475314586781298, 0.07661424882932788, 0.07661424882932788, 0.07661424882932788, 0.09503015929945902, 0.09503015929945902, 0.09503015929945902, 0.19177463560531316, 0.19177463560531316, 0.19177463560531316, 0.061890543856618185, 0.061890543856618185, 0.061890543856618185, 0.048592865684589426, 0.048592865684589426, 0.048592865684589426, 0.4963712961872526, 0.4963712961872526, 0.4963712961872526, 0.49091998029198614, 0.49091998029198614, 0.49091998029198614, 0.48340798938501195, 0.48340798938501195, 0.48340798938501195, 0.10833529661989338, 0.10833529661989338, 0.10833529661989338, 0.10437738514699357, 0.10437738514699357, 0.10437738514699357, 0.10298568530080843, 0.10298568530080843, 0.10298568530080843, 0.24133536774282316, 0.24133536774282316, 0.24133536774282316, 0.20573513110091135, 0.20573513110091135, 0.20573513110091135, 0.23932479980387533, 0.23932479980387533, 0.23932479980387533, 0.27081682856362255, 0.27081682856362255, 0.27081682856362255, 0.2646363977563999, 0.2646363977563999, 0.2646363977563999, 0.2297229276890449, 0.2297229276890449, 0.2297229276890449, 0.1298942438437911, 0.1298942438437911, 0.1298942438437911, 0.2074490692157116, 0.2074490692157116, 0.2074490692157116, 0.15939190138302206, 0.15939190138302206, 0.15939190138302206, 0.19814465857320984, 0.19814465857320984, 0.19814465857320984, 0.20364246682038967, 0.20364246682038967, 0.20364246682038967, 0.1884623415665414, 0.1884623415665414, 0.1884623415665414, 0.17718412134909634, 0.17718412134909634, 0.17718412134909634, 0.20269258775676802, 0.20269258775676802, 0.20269258775676802, 0.18862224546927642, 0.18862224546927642, 0.18862224546927642, 0.8580440289735922, 0.8580440289735922, 0.8580440289735922, 0.19690397916196678, 0.19690397916196678, 0.19690397916196678, 0.1951419248085795, 0.1951419248085795, 0.1951419248085795, 0.20708011270817994, 0.20708011270817994, 0.20708011270817994, 0.20951240194241705, 0.20951240194241705, 0.20951240194241705, 0.15680643003014416, 0.15680643003014416, 0.15680643003014416, 0.19699108668848608, 0.19699108668848608, 0.19699108668848608, 0.17430600094595683, 0.17430600094595683, 0.17430600094595683, 0.18314617751536266, 0.18314617751536266, 0.18314617751536266, 0.08125793900901102, 0.08125793900901102, 0.08125793900901102, 0.06601707819382296, 0.06601707819382296, 0.06601707819382296, 0.07853832835907815, 0.07853832835907815, 0.07853832835907815]}, "mutation_prompt": null}
{"id": "558d94fc-64d2-4d15-97bc-fcba7a1347b1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSO_DENL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.9\n        self.CR = 0.7\n        self.clone_factor = 0.2\n        self.mutation_probability = 0.15  # Increased mutation step probability\n        self.learning_rate = 0.1  # Adaptive learning rate for novelty search\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear decreasing inertia\n\n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply Clonal Selection for mutation\n            clone_count = int(self.clone_factor * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            # Random mutation injection to enhance exploration\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n            # Novelty search component\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                novelty_vector = np.random.uniform(-1, 1, self.dim) * self.learning_rate\n                trial_vector = positions[i] + novelty_vector\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    p_best_positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n        return g_best_position, g_best_score", "name": "EnhancedAdaptiveHybridPSO_DENL", "description": "Enhanced Adaptive Hybrid PSO-DE with Adaptive Learning Rate and Novelty Search for Diversified Exploration and Exploitation.", "configspace": "", "generation": 11, "fitness": 0.20180153329764441, "feedback": "The algorithm EnhancedAdaptiveHybridPSO_DENL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "1b7e3339-b390-496d-b079-31e185a9e7b4", "metadata": {"aucs": [0.49279806352239364, 0.49279806352239364, 0.49279806352239364, 0.49078450749045965, 0.49078450749045965, 0.49078450749045965, 0.5166789367760211, 0.5166789367760211, 0.5166789367760211, 0.04463412997900362, 0.04463412997900362, 0.04463412997900362, 0.08441055901793848, 0.08441055901793848, 0.08441055901793848, 0.13363320994025196, 0.13363320994025196, 0.13363320994025196, 0.1286904346328711, 0.1286904346328711, 0.1286904346328711, 0.06739939868019229, 0.06739939868019229, 0.06739939868019229, 0.09523726042991443, 0.09523726042991443, 0.09523726042991443, 0.08491043978651991, 0.08491043978651991, 0.08491043978651991, 0.09677423312106659, 0.09677423312106659, 0.09677423312106659, 0.09625778994519674, 0.09625778994519674, 0.09625778994519674, 0.9950445067520778, 0.9950445067520778, 0.9950445067520778, 0.9914165642527082, 0.9914165642527082, 0.9914165642527082, 0.9796796702013159, 0.9796796702013159, 0.9796796702013159, 0.2736727533755793, 0.2736727533755793, 0.2736727533755793, 0.23123721345137715, 0.23123721345137715, 0.23123721345137715, 0.220664653678583, 0.220664653678583, 0.220664653678583, 0.40640345750313067, 0.40640345750313067, 0.40640345750313067, 0.17687994557800846, 0.17687994557800846, 0.17687994557800846, 0.15056427066743616, 0.15056427066743616, 0.15056427066743616, 0.12231726576535984, 0.12231726576535984, 0.12231726576535984, 0.07335649783800346, 0.07335649783800346, 0.07335649783800346, 0.13391291488828738, 0.13391291488828738, 0.13391291488828738, 0.09572996945657708, 0.09572996945657708, 0.09572996945657708, 0.11886057783316195, 0.11886057783316195, 0.11886057783316195, 0.06356011553070673, 0.06356011553070673, 0.06356011553070673, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08811031582955198, 0.08811031582955198, 0.08811031582955198, 0.011274271009057313, 0.011274271009057313, 0.011274271009057313, 0.028010587827941524, 0.028010587827941524, 0.028010587827941524, 0.025248570741438936, 0.025248570741438936, 0.025248570741438936, 0.0331061893136857, 0.0331061893136857, 0.0331061893136857, 0.03833067505026033, 0.03833067505026033, 0.03833067505026033, 0.024831364247562826, 0.024831364247562826, 0.024831364247562826, 0.03245766888460788, 0.03245766888460788, 0.03245766888460788, 0.0405822519222111, 0.0405822519222111, 0.0405822519222111, 0.37110077132182806, 0.37110077132182806, 0.37110077132182806, 0.37877886011987116, 0.37877886011987116, 0.37877886011987116, 0.37982266775593376, 0.37982266775593376, 0.37982266775593376, 0.06321219245546439, 0.06321219245546439, 0.06321219245546439, 0.1062150504672642, 0.1062150504672642, 0.1062150504672642, 0.08996831529052929, 0.08996831529052929, 0.08996831529052929, 0.2864914511646317, 0.2864914511646317, 0.2864914511646317, 0.14126022128502902, 0.14126022128502902, 0.14126022128502902, 0.156132627296799, 0.156132627296799, 0.156132627296799, 0.22022439260209548, 0.22022439260209548, 0.22022439260209548, 0.27292687979003327, 0.27292687979003327, 0.27292687979003327, 0.26921430557387716, 0.26921430557387716, 0.26921430557387716, 0.16628605515899908, 0.16628605515899908, 0.16628605515899908, 0.1706980042630788, 0.1706980042630788, 0.1706980042630788, 0.19948177546493517, 0.19948177546493517, 0.19948177546493517, 0.1960334410719452, 0.1960334410719452, 0.1960334410719452, 0.18113431200243624, 0.18113431200243624, 0.18113431200243624, 0.1643521882855179, 0.1643521882855179, 0.1643521882855179, 0.17331090665899684, 0.17331090665899684, 0.17331090665899684, 0.20945853681195759, 0.20945853681195759, 0.20945853681195759, 0.18878686811729672, 0.18878686811729672, 0.18878686811729672, 0.580082207848601, 0.580082207848601, 0.580082207848601, 0.22012224177237205, 0.22012224177237205, 0.22012224177237205, 0.1440892852741592, 0.1440892852741592, 0.1440892852741592, 0.19165895094704788, 0.19165895094704788, 0.19165895094704788, 0.190477924620445, 0.190477924620445, 0.190477924620445, 0.3128403496918317, 0.3128403496918317, 0.3128403496918317, 0.18048287092333481, 0.18048287092333481, 0.18048287092333481, 0.19449389813146245, 0.19449389813146245, 0.19449389813146245, 0.19388445473261917, 0.19388445473261917, 0.19388445473261917, 0.07991702142539447, 0.07991702142539447, 0.07991702142539447, 0.06740913642771484, 0.06740913642771484, 0.06740913642771484, 0.10160099775643483, 0.10160099775643483, 0.10160099775643483]}, "mutation_prompt": null}
{"id": "88792103-6f8f-4d42-9d6f-e02c95899747", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.8  # Slightly reduced F\n        self.CR = 0.8  # Increased CR for more crossover\n        self.clone_factor = 0.2\n        self.mutation_probability = 0.15  # Increased mutation probability\n        \n    def chaos_map(self, x):\n        return 4 * x * (1 - x)  # Logistic map for chaos\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n        chaos_factor = np.random.rand()\n        \n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.exp(-3.0 * evaluations / self.budget)\n            chaos_factor = self.chaos_map(chaos_factor)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions)) * chaos_factor\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.clone_factor * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumInspiredPSO_DE", "description": "Adaptive Quantum-Inspired PSO-DE with Chaotic Maps for enhanced exploration and convergence.", "configspace": "", "generation": 12, "fitness": 0.26176594442615375, "feedback": "The algorithm AdaptiveQuantumInspiredPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "1b7e3339-b390-496d-b079-31e185a9e7b4", "metadata": {"aucs": [0.8745944876294144, 0.8745944876294144, 0.8745944876294144, 0.8392749641399385, 0.8392749641399385, 0.8392749641399385, 0.9003197555765351, 0.9003197555765351, 0.9003197555765351, 0.43320676600562047, 0.43320676600562047, 0.43320676600562047, 0.6135107884766067, 0.6135107884766067, 0.6135107884766067, 0.42827317408794907, 0.42827317408794907, 0.42827317408794907, 0.09511336986988406, 0.09511336986988406, 0.09511336986988406, 0.14113486681788123, 0.14113486681788123, 0.14113486681788123, 0.16715697649214323, 0.16715697649214323, 0.16715697649214323, 0.14144061988436585, 0.14144061988436585, 0.14144061988436585, 0.11783081097932424, 0.11783081097932424, 0.11783081097932424, 0.0882083915026819, 0.0882083915026819, 0.0882083915026819, 0.9573959446999152, 0.9573959446999152, 0.9573959446999152, 0.9604266187727754, 0.9604266187727754, 0.9604266187727754, 0.9814445258310105, 0.9814445258310105, 0.9814445258310105, 0.3642617825350901, 0.3642617825350901, 0.3642617825350901, 0.3521939102409861, 0.3521939102409861, 0.3521939102409861, 0.3796600952602728, 0.3796600952602728, 0.3796600952602728, 0.22393942981684523, 0.22393942981684523, 0.22393942981684523, 0.16978804159662975, 0.16978804159662975, 0.16978804159662975, 0.1827273415357421, 0.1827273415357421, 0.1827273415357421, 0.16002417154373738, 0.16002417154373738, 0.16002417154373738, 0.11267246128356168, 0.11267246128356168, 0.11267246128356168, 0.3095657957166862, 0.3095657957166862, 0.3095657957166862, 0.14625924761011722, 0.14625924761011722, 0.14625924761011722, 0.12631867701876742, 0.12631867701876742, 0.12631867701876742, 0.1521959427945292, 0.1521959427945292, 0.1521959427945292, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00629520362443059, 0.00629520362443059, 0.00629520362443059, 0.0036651962040172847, 0.0036651962040172847, 0.0036651962040172847, 0.12649858384513923, 0.12649858384513923, 0.12649858384513923, 0.03446059500933374, 0.03446059500933374, 0.03446059500933374, 0.07885128843224187, 0.07885128843224187, 0.07885128843224187, 0.06530647015087743, 0.06530647015087743, 0.06530647015087743, 0.11821386454965632, 0.11821386454965632, 0.11821386454965632, 0.1489498723840741, 0.1489498723840741, 0.1489498723840741, 0.13237922915267353, 0.13237922915267353, 0.13237922915267353, 0.08878719513370437, 0.08878719513370437, 0.08878719513370437, 0.18765768402774197, 0.18765768402774197, 0.18765768402774197, 0.49888737606802513, 0.49888737606802513, 0.49888737606802513, 0.4680645123812146, 0.4680645123812146, 0.4680645123812146, 0.4846167665071657, 0.4846167665071657, 0.4846167665071657, 0.0925471910757194, 0.0925471910757194, 0.0925471910757194, 0.09257890177868688, 0.09257890177868688, 0.09257890177868688, 0.09215790925948308, 0.09215790925948308, 0.09215790925948308, 0.18686620034404677, 0.18686620034404677, 0.18686620034404677, 0.12702809421527927, 0.12702809421527927, 0.12702809421527927, 0.15850231961056582, 0.15850231961056582, 0.15850231961056582, 0.3466040307681767, 0.3466040307681767, 0.3466040307681767, 0.2742239230044976, 0.2742239230044976, 0.2742239230044976, 0.2087947966655911, 0.2087947966655911, 0.2087947966655911, 0.12908163214666823, 0.12908163214666823, 0.12908163214666823, 0.2582548793492183, 0.2582548793492183, 0.2582548793492183, 0.15324180617758099, 0.15324180617758099, 0.15324180617758099, 0.23282850786264142, 0.23282850786264142, 0.23282850786264142, 0.22168083688058182, 0.22168083688058182, 0.22168083688058182, 0.1764541067293829, 0.1764541067293829, 0.1764541067293829, 0.21251906109892504, 0.21251906109892504, 0.21251906109892504, 0.19813840010861328, 0.19813840010861328, 0.19813840010861328, 0.18447639850799902, 0.18447639850799902, 0.18447639850799902, 0.9224283125249436, 0.9224283125249436, 0.9224283125249436, 0.15820532812012444, 0.15820532812012444, 0.15820532812012444, 0.1376250957821623, 0.1376250957821623, 0.1376250957821623, 0.2500151344184849, 0.2500151344184849, 0.2500151344184849, 0.2115890259492419, 0.2115890259492419, 0.2115890259492419, 0.15556446834098592, 0.15556446834098592, 0.15556446834098592, 0.18274305365136168, 0.18274305365136168, 0.18274305365136168, 0.192034107056954, 0.192034107056954, 0.192034107056954, 0.17447700080541162, 0.17447700080541162, 0.17447700080541162, 0.078190522634777, 0.078190522634777, 0.078190522634777, 0.09592860334329745, 0.09592860334329745, 0.09592860334329745, 0.08069555528236139, 0.08069555528236139, 0.08069555528236139]}, "mutation_prompt": null}
{"id": "77857abd-d43d-4dcf-910e-1975391b9b93", "solution": "import numpy as np\n\nclass FusionDynamicPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.7\n        self.clone_factor = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * evaluations / self.budget\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.clone_factor * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "FusionDynamicPSO_DE", "description": "Fusion-based Dynamic PSO-DE with adaptive mutation and differential scaling for enhanced convergence.", "configspace": "", "generation": 13, "fitness": 0.23858469339584634, "feedback": "The algorithm FusionDynamicPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "1b7e3339-b390-496d-b079-31e185a9e7b4", "metadata": {"aucs": [0.6518486633028093, 0.6518486633028093, 0.6518486633028093, 0.626542525069276, 0.626542525069276, 0.626542525069276, 0.6209568371710557, 0.6209568371710557, 0.6209568371710557, 0.2987145197656975, 0.2987145197656975, 0.2987145197656975, 0.33680746445653587, 0.33680746445653587, 0.33680746445653587, 0.28038282465409015, 0.28038282465409015, 0.28038282465409015, 0.14575825455492197, 0.14575825455492197, 0.14575825455492197, 0.09597326821929164, 0.09597326821929164, 0.09597326821929164, 0.2042147239786164, 0.2042147239786164, 0.2042147239786164, 0.08384388264950116, 0.08384388264950116, 0.08384388264950116, 0.14729406356073105, 0.14729406356073105, 0.14729406356073105, 0.06472665270656852, 0.06472665270656852, 0.06472665270656852, 0.9950445067520778, 0.9950445067520778, 0.9950445067520778, 0.9912421978367735, 0.9912421978367735, 0.9912421978367735, 0.9869866284646909, 0.9869866284646909, 0.9869866284646909, 0.4019799317341761, 0.4019799317341761, 0.4019799317341761, 0.18414643619359672, 0.18414643619359672, 0.18414643619359672, 0.3185039387452311, 0.3185039387452311, 0.3185039387452311, 0.289679145955272, 0.289679145955272, 0.289679145955272, 0.15592271454569895, 0.15592271454569895, 0.15592271454569895, 0.5205226051898112, 0.5205226051898112, 0.5205226051898112, 0.1397529259469149, 0.1397529259469149, 0.1397529259469149, 0.08996514578163228, 0.08996514578163228, 0.08996514578163228, 0.13796171940303936, 0.13796171940303936, 0.13796171940303936, 0.11127545185033272, 0.11127545185033272, 0.11127545185033272, 0.16755948230533868, 0.16755948230533868, 0.16755948230533868, 0.11289437184594686, 0.11289437184594686, 0.11289437184594686, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029195853581421183, 0.029195853581421183, 0.029195853581421183, 0.1582035395540613, 0.1582035395540613, 0.1582035395540613, 0.055037543470686456, 0.055037543470686456, 0.055037543470686456, 0.029612410490656438, 0.029612410490656438, 0.029612410490656438, 0.0305403983971253, 0.0305403983971253, 0.0305403983971253, 0.05269774318256082, 0.05269774318256082, 0.05269774318256082, 0.06636592042825307, 0.06636592042825307, 0.06636592042825307, 0.03308135489007513, 0.03308135489007513, 0.03308135489007513, 0.03052369879612926, 0.03052369879612926, 0.03052369879612926, 0.04286934461075176, 0.04286934461075176, 0.04286934461075176, 0.4167075636070817, 0.4167075636070817, 0.4167075636070817, 0.40182549349430396, 0.40182549349430396, 0.40182549349430396, 0.43859264127398334, 0.43859264127398334, 0.43859264127398334, 0.08091587124381328, 0.08091587124381328, 0.08091587124381328, 0.1162183960903449, 0.1162183960903449, 0.1162183960903449, 0.1092705968287413, 0.1092705968287413, 0.1092705968287413, 0.18500282476288665, 0.18500282476288665, 0.18500282476288665, 0.31546751614512425, 0.31546751614512425, 0.31546751614512425, 0.14653605882577836, 0.14653605882577836, 0.14653605882577836, 0.22321232357052934, 0.22321232357052934, 0.22321232357052934, 0.18853815162724796, 0.18853815162724796, 0.18853815162724796, 0.18942094780156626, 0.18942094780156626, 0.18942094780156626, 0.19800164740381654, 0.19800164740381654, 0.19800164740381654, 0.1758830671007967, 0.1758830671007967, 0.1758830671007967, 0.19683216695271144, 0.19683216695271144, 0.19683216695271144, 0.21189108485327035, 0.21189108485327035, 0.21189108485327035, 0.1874286868121915, 0.1874286868121915, 0.1874286868121915, 0.18686645059676577, 0.18686645059676577, 0.18686645059676577, 0.18804805009712533, 0.18804805009712533, 0.18804805009712533, 0.19262735648759066, 0.19262735648759066, 0.19262735648759066, 0.4774228048800151, 0.4774228048800151, 0.4774228048800151, 0.44849886385206794, 0.44849886385206794, 0.44849886385206794, 0.18132238207798612, 0.18132238207798612, 0.18132238207798612, 0.14397411915248626, 0.14397411915248626, 0.14397411915248626, 0.4138595133543871, 0.4138595133543871, 0.4138595133543871, 0.19912615084878027, 0.19912615084878027, 0.19912615084878027, 0.40587862917014794, 0.40587862917014794, 0.40587862917014794, 0.21720409178039113, 0.21720409178039113, 0.21720409178039113, 0.20989531724119503, 0.20989531724119503, 0.20989531724119503, 0.18255566599517303, 0.18255566599517303, 0.18255566599517303, 0.0781180726216889, 0.0781180726216889, 0.0781180726216889, 0.08612548160795741, 0.08612548160795741, 0.08612548160795741, 0.09600124630164042, 0.09600124630164042, 0.09600124630164042]}, "mutation_prompt": null}
{"id": "7c31ada2-8f35-46a8-b247-2538ab4635af", "solution": "import numpy as np\n\nclass AdaptiveDE_PSO_Collaboration:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.w_max = 0.8\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.9\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia adjustment\n\n            # Evaluate the current population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            # Apply DE mutation strategy\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            # Random mutation injection for exploration\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveDE_PSO_Collaboration", "description": "Adaptive Differential Evolution with Strategic PSO Collaboration and Dynamic Mutation to balance exploration and exploitation efficiently.", "configspace": "", "generation": 14, "fitness": 0.17745036045569, "feedback": "The algorithm AdaptiveDE_PSO_Collaboration got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "1b7e3339-b390-496d-b079-31e185a9e7b4", "metadata": {"aucs": [0.3670194732527753, 0.3670194732527753, 0.3670194732527753, 0.3911759112201769, 0.3911759112201769, 0.3911759112201769, 0.43543397707783926, 0.43543397707783926, 0.43543397707783926, 0.01606870286535722, 0.01606870286535722, 0.01606870286535722, 0.079603842261602, 0.079603842261602, 0.079603842261602, 0.03201429351349505, 0.03201429351349505, 0.03201429351349505, 0.07413372736333135, 0.07413372736333135, 0.07413372736333135, 0.0634323320780319, 0.0634323320780319, 0.0634323320780319, 0.07947472834996516, 0.07947472834996516, 0.07947472834996516, 0.06768207966515294, 0.06768207966515294, 0.06768207966515294, 0.08767221422619698, 0.08767221422619698, 0.08767221422619698, 0.07638994088790008, 0.07638994088790008, 0.07638994088790008, 0.9950445067520778, 0.9950445067520778, 0.9950445067520778, 0.984557561340472, 0.984557561340472, 0.984557561340472, 0.9909675176158543, 0.9909675176158543, 0.9909675176158543, 0.15457151233519895, 0.15457151233519895, 0.15457151233519895, 0.1312100619434694, 0.1312100619434694, 0.1312100619434694, 0.18984697336492617, 0.18984697336492617, 0.18984697336492617, 0.14059657082509547, 0.14059657082509547, 0.14059657082509547, 0.15150651919562985, 0.15150651919562985, 0.15150651919562985, 0.15881001863376443, 0.15881001863376443, 0.15881001863376443, 0.06998163459216211, 0.06998163459216211, 0.06998163459216211, 0.07403600976847269, 0.07403600976847269, 0.07403600976847269, 0.09877138707875166, 0.09877138707875166, 0.09877138707875166, 0.05209950226985072, 0.05209950226985072, 0.05209950226985072, 0.09011846520409184, 0.09011846520409184, 0.09011846520409184, 0.0951385424046517, 0.0951385424046517, 0.0951385424046517, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03451904137802653, 0.03451904137802653, 0.03451904137802653, 0.04381601606666119, 0.04381601606666119, 0.04381601606666119, 0.06455926638859333, 0.06455926638859333, 0.06455926638859333, 0.009600137377902551, 0.009600137377902551, 0.009600137377902551, 0.02936655102138941, 0.02936655102138941, 0.02936655102138941, 0.03467709885046555, 0.03467709885046555, 0.03467709885046555, 0.026411237935219267, 0.026411237935219267, 0.026411237935219267, 0.05168200197498629, 0.05168200197498629, 0.05168200197498629, 0.03688221180036422, 0.03688221180036422, 0.03688221180036422, 0.3444923159862787, 0.3444923159862787, 0.3444923159862787, 0.3504494658387235, 0.3504494658387235, 0.3504494658387235, 0.32144457929417136, 0.32144457929417136, 0.32144457929417136, 0.07213863862202174, 0.07213863862202174, 0.07213863862202174, 0.07142108612314946, 0.07142108612314946, 0.07142108612314946, 0.07305185486644095, 0.07305185486644095, 0.07305185486644095, 0.1353469288432918, 0.1353469288432918, 0.1353469288432918, 0.2345765239923303, 0.2345765239923303, 0.2345765239923303, 0.1804654742615025, 0.1804654742615025, 0.1804654742615025, 0.24844608649812505, 0.24844608649812505, 0.24844608649812505, 0.22498563436268149, 0.22498563436268149, 0.22498563436268149, 0.2436514367704885, 0.2436514367704885, 0.2436514367704885, 0.20159556923564514, 0.20159556923564514, 0.20159556923564514, 0.15952197383001843, 0.15952197383001843, 0.15952197383001843, 0.1878474859299345, 0.1878474859299345, 0.1878474859299345, 0.16794614692234044, 0.16794614692234044, 0.16794614692234044, 0.16904157280184262, 0.16904157280184262, 0.16904157280184262, 0.1693802219735, 0.1693802219735, 0.1693802219735, 0.1714754156633599, 0.1714754156633599, 0.1714754156633599, 0.17617733553948944, 0.17617733553948944, 0.17617733553948944, 0.16880624365180696, 0.16880624365180696, 0.16880624365180696, 0.38472658287581885, 0.38472658287581885, 0.38472658287581885, 0.17094795762527215, 0.17094795762527215, 0.17094795762527215, 0.17543045468549923, 0.17543045468549923, 0.17543045468549923, 0.2479349755470477, 0.2479349755470477, 0.2479349755470477, 0.23525857509113213, 0.23525857509113213, 0.23525857509113213, 0.23277684602527604, 0.23277684602527604, 0.23277684602527604, 0.2240098509962708, 0.2240098509962708, 0.2240098509962708, 0.16811333543344953, 0.16811333543344953, 0.16811333543344953, 0.17892166479303395, 0.17892166479303395, 0.17892166479303395, 0.06564798373223912, 0.06564798373223912, 0.06564798373223912, 0.06773404563819363, 0.06773404563819363, 0.06773404563819363, 0.07349012047940273, 0.07349012047940273, 0.07349012047940273]}, "mutation_prompt": null}
{"id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "solution": "import numpy as np\n\nclass DynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 2  # Non-linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "DynamicQuantumHybridPSO_DE", "description": "Dynamic Quantum-Inspired Hybrid PSO-DE utilizing Rotational Diversity and Adaptive Mutation for efficient global search.", "configspace": "", "generation": 15, "fitness": 0.3059340250074784, "feedback": "The algorithm DynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "1b7e3339-b390-496d-b079-31e185a9e7b4", "metadata": {"aucs": [0.8839678835460805, 0.8839678835460805, 0.8839678835460805, 0.883667893453443, 0.883667893453443, 0.883667893453443, 0.8765690863158029, 0.8765690863158029, 0.8765690863158029, 0.606819360368807, 0.606819360368807, 0.606819360368807, 0.6689968942674251, 0.6689968942674251, 0.6689968942674251, 0.4931010837467208, 0.4931010837467208, 0.4931010837467208, 0.15014813482784617, 0.15014813482784617, 0.15014813482784617, 0.1308138342590155, 0.1308138342590155, 0.1308138342590155, 0.2842506915248665, 0.2842506915248665, 0.2842506915248665, 0.14757283205778293, 0.14757283205778293, 0.14757283205778293, 0.1446074018409006, 0.1446074018409006, 0.1446074018409006, 0.3808296823030376, 0.3808296823030376, 0.3808296823030376, 0.9793245266148687, 0.9793245266148687, 0.9793245266148687, 0.9789861143288495, 0.9789861143288495, 0.9789861143288495, 0.9806301927631291, 0.9806301927631291, 0.9806301927631291, 0.5430825591331535, 0.5430825591331535, 0.5430825591331535, 0.5456013047098315, 0.5456013047098315, 0.5456013047098315, 0.44663599252092867, 0.44663599252092867, 0.44663599252092867, 0.22638360814363645, 0.22638360814363645, 0.22638360814363645, 0.21875981503531294, 0.21875981503531294, 0.21875981503531294, 0.15784388570797891, 0.15784388570797891, 0.15784388570797891, 0.37786989751776123, 0.37786989751776123, 0.37786989751776123, 0.12830748126503988, 0.12830748126503988, 0.12830748126503988, 0.19277304974751241, 0.19277304974751241, 0.19277304974751241, 0.10423546632346226, 0.10423546632346226, 0.10423546632346226, 0.21275719564309337, 0.21275719564309337, 0.21275719564309337, 0.12607984247091442, 0.12607984247091442, 0.12607984247091442, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04710099406154988, 0.04710099406154988, 0.04710099406154988, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050990256450898386, 0.050990256450898386, 0.050990256450898386, 0.00349853822138102, 0.00349853822138102, 0.00349853822138102, 0.05960044604529724, 0.05960044604529724, 0.05960044604529724, 0.04952836270942129, 0.04952836270942129, 0.04952836270942129, 0.27894522819456147, 0.27894522819456147, 0.27894522819456147, 0.09988123083338274, 0.09988123083338274, 0.09988123083338274, 0.21344195177757652, 0.21344195177757652, 0.21344195177757652, 0.16831576718893904, 0.16831576718893904, 0.16831576718893904, 0.04935669210585891, 0.04935669210585891, 0.04935669210585891, 0.5589480175839219, 0.5589480175839219, 0.5589480175839219, 0.5452226167138816, 0.5452226167138816, 0.5452226167138816, 0.6147120181386133, 0.6147120181386133, 0.6147120181386133, 0.11111697180013003, 0.11111697180013003, 0.11111697180013003, 0.123507603055526, 0.123507603055526, 0.123507603055526, 0.09285332342509123, 0.09285332342509123, 0.09285332342509123, 0.25554277324776653, 0.25554277324776653, 0.25554277324776653, 0.20466179832005238, 0.20466179832005238, 0.20466179832005238, 0.1755275196491317, 0.1755275196491317, 0.1755275196491317, 0.24169541595917565, 0.24169541595917565, 0.24169541595917565, 0.2936020896131073, 0.2936020896131073, 0.2936020896131073, 0.42829762774567637, 0.42829762774567637, 0.42829762774567637, 0.15965224668976918, 0.15965224668976918, 0.15965224668976918, 0.11669165422346162, 0.11669165422346162, 0.11669165422346162, 0.19798478479102, 0.19798478479102, 0.19798478479102, 0.18076592934914804, 0.18076592934914804, 0.18076592934914804, 0.22918058928730156, 0.22918058928730156, 0.22918058928730156, 0.24057699757667894, 0.24057699757667894, 0.24057699757667894, 0.20042093094966662, 0.20042093094966662, 0.20042093094966662, 0.20937050744575403, 0.20937050744575403, 0.20937050744575403, 0.2264946318304324, 0.2264946318304324, 0.2264946318304324, 0.9291793062175933, 0.9291793062175933, 0.9291793062175933, 0.15783837899250652, 0.15783837899250652, 0.15783837899250652, 0.160941661215676, 0.160941661215676, 0.160941661215676, 0.8658527213909792, 0.8658527213909792, 0.8658527213909792, 0.5424837291144025, 0.5424837291144025, 0.5424837291144025, 0.2519104638857427, 0.2519104638857427, 0.2519104638857427, 0.1734179406682912, 0.1734179406682912, 0.1734179406682912, 0.18602153614832428, 0.18602153614832428, 0.18602153614832428, 0.19057134593904468, 0.19057134593904468, 0.19057134593904468, 0.09199318363779108, 0.09199318363779108, 0.09199318363779108, 0.085312488739135, 0.085312488739135, 0.085312488739135, 0.09342581916758497, 0.09342581916758497, 0.09342581916758497]}, "mutation_prompt": null}
{"id": "93881ddf-7949-4fd4-9e0e-c3cd8e662bcf", "solution": "import numpy as np\n\nclass EnhancedDualPhaseQuantumPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49445  # Slight change from the original\n        self.c2 = 1.49445  # Slight change from the original\n        self.w_max = 0.85  # Adjusted value\n        self.w_min = 0.4   # Adjusted value\n        self.F = 0.75      # Slight change from the original\n        self.CR = 0.9      # Slight change from the original\n        self.rotational_diversity = 0.20  # Adjusted value\n        self.mutation_probability = 0.20  # Adjusted value\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 3  # Cubic decay for inertia\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDualPhaseQuantumPSO_DE", "description": "Enhanced Dual-Phase Quantum-Inspired PSO-DE using Adaptive Inertia and Differential Mutations for diverse search strategy.", "configspace": "", "generation": 16, "fitness": 0.18082955954272237, "feedback": "The algorithm EnhancedDualPhaseQuantumPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.34691491731729507, 0.34691491731729507, 0.34691491731729507, 0.40901789062016514, 0.40901789062016514, 0.40901789062016514, 0.39547770321746756, 0.39547770321746756, 0.39547770321746756, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05191533614942678, 0.05191533614942678, 0.05191533614942678, 0.012557801295591364, 0.012557801295591364, 0.012557801295591364, 0.1058518962009708, 0.1058518962009708, 0.1058518962009708, 0.059850063778283724, 0.059850063778283724, 0.059850063778283724, 0.09498260807586723, 0.09498260807586723, 0.09498260807586723, 0.06117042004292994, 0.06117042004292994, 0.06117042004292994, 0.07816969912301008, 0.07816969912301008, 0.07816969912301008, 0.09371838096662033, 0.09371838096662033, 0.09371838096662033, 0.9843349337305851, 0.9843349337305851, 0.9843349337305851, 0.9854917507668317, 0.9854917507668317, 0.9854917507668317, 0.9917151131988474, 0.9917151131988474, 0.9917151131988474, 0.18590711868478715, 0.18590711868478715, 0.18590711868478715, 0.20826016999793318, 0.20826016999793318, 0.20826016999793318, 0.21857159658494218, 0.21857159658494218, 0.21857159658494218, 0.17649736755454393, 0.17649736755454393, 0.17649736755454393, 0.15334908109224832, 0.15334908109224832, 0.15334908109224832, 0.13583627618891148, 0.13583627618891148, 0.13583627618891148, 0.12628640253138124, 0.12628640253138124, 0.12628640253138124, 0.07062103235424766, 0.07062103235424766, 0.07062103235424766, 0.1412144982146024, 0.1412144982146024, 0.1412144982146024, 0.06351515469770819, 0.06351515469770819, 0.06351515469770819, 0.11219928757730335, 0.11219928757730335, 0.11219928757730335, 0.08673214477154101, 0.08673214477154101, 0.08673214477154101, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016056442587776054, 0.016056442587776054, 0.016056442587776054, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05290817947365445, 0.05290817947365445, 0.05290817947365445, 0.0009506096343886439, 0.0009506096343886439, 0.0009506096343886439, 0.024020777384034075, 0.024020777384034075, 0.024020777384034075, 0.009764248705763423, 0.009764248705763423, 0.009764248705763423, 0.008992706897609448, 0.008992706897609448, 0.008992706897609448, 0.007516857532640642, 0.007516857532640642, 0.007516857532640642, 0.029486118504673642, 0.029486118504673642, 0.029486118504673642, 0.03793650099867696, 0.03793650099867696, 0.03793650099867696, 0.04219091868936631, 0.04219091868936631, 0.04219091868936631, 0.3875048255693707, 0.3875048255693707, 0.3875048255693707, 0.3487384896132145, 0.3487384896132145, 0.3487384896132145, 0.3314466161710683, 0.3314466161710683, 0.3314466161710683, 0.0756078331745148, 0.0756078331745148, 0.0756078331745148, 0.1016347148203296, 0.1016347148203296, 0.1016347148203296, 0.0701634367930517, 0.0701634367930517, 0.0701634367930517, 0.1527622494929748, 0.1527622494929748, 0.1527622494929748, 0.1614804235204651, 0.1614804235204651, 0.1614804235204651, 0.14987118703080926, 0.14987118703080926, 0.14987118703080926, 0.24750586749112613, 0.24750586749112613, 0.24750586749112613, 0.24446941100157737, 0.24446941100157737, 0.24446941100157737, 0.24093045309917394, 0.24093045309917394, 0.24093045309917394, 0.12914335946248134, 0.12914335946248134, 0.12914335946248134, 0.15707989692582724, 0.15707989692582724, 0.15707989692582724, 0.19789417660532105, 0.19789417660532105, 0.19789417660532105, 0.17154392540833685, 0.17154392540833685, 0.17154392540833685, 0.19473047000912225, 0.19473047000912225, 0.19473047000912225, 0.2100537254833087, 0.2100537254833087, 0.2100537254833087, 0.17278268530964436, 0.17278268530964436, 0.17278268530964436, 0.1734629708018658, 0.1734629708018658, 0.1734629708018658, 0.17546873281926945, 0.17546873281926945, 0.17546873281926945, 0.5376088274426961, 0.5376088274426961, 0.5376088274426961, 0.1612383871369535, 0.1612383871369535, 0.1612383871369535, 0.1662606074705345, 0.1662606074705345, 0.1662606074705345, 0.2562493642575542, 0.2562493642575542, 0.2562493642575542, 0.2154283087143113, 0.2154283087143113, 0.2154283087143113, 0.270587072998865, 0.270587072998865, 0.270587072998865, 0.1746882926518809, 0.1746882926518809, 0.1746882926518809, 0.1798319735597944, 0.1798319735597944, 0.1798319735597944, 0.17946199316474465, 0.17946199316474465, 0.17946199316474465, 0.07224198316302322, 0.07224198316302322, 0.07224198316302322, 0.06314580657894653, 0.06314580657894653, 0.06314580657894653, 0.06842821419122669, 0.06842821419122669, 0.06842821419122669]}, "mutation_prompt": null}
{"id": "cdd40ae5-7b14-4845-a8de-636b6d736706", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 0.5  # Adaptive inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDynamicQuantumHybridPSO_DE", "description": "Enhanced Dynamic Quantum-Inspired Hybrid PSO-DE with Adaptive Velocity Control and Random Mutation Strategy.", "configspace": "", "generation": 17, "fitness": 0.2613455493087125, "feedback": "The algorithm EnhancedDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.7211100861811388, 0.7211100861811388, 0.7211100861811388, 0.6872930925779743, 0.6872930925779743, 0.6872930925779743, 0.7365730646519112, 0.7365730646519112, 0.7365730646519112, 0.38017548196129825, 0.38017548196129825, 0.38017548196129825, 0.1577284281489647, 0.1577284281489647, 0.1577284281489647, 0.33609341285346905, 0.33609341285346905, 0.33609341285346905, 0.12991694353856043, 0.12991694353856043, 0.12991694353856043, 0.0748314019205567, 0.0748314019205567, 0.0748314019205567, 0.14211549685681057, 0.14211549685681057, 0.14211549685681057, 0.1174611376368242, 0.1174611376368242, 0.1174611376368242, 0.1114705038495134, 0.1114705038495134, 0.1114705038495134, 0.09374458817955433, 0.09374458817955433, 0.09374458817955433, 0.984347789679026, 0.984347789679026, 0.984347789679026, 0.9855100646980479, 0.9855100646980479, 0.9855100646980479, 0.991765468666148, 0.991765468666148, 0.991765468666148, 0.3827813286410655, 0.3827813286410655, 0.3827813286410655, 0.2549007630752923, 0.2549007630752923, 0.2549007630752923, 0.4016404015059142, 0.4016404015059142, 0.4016404015059142, 0.3945143187790503, 0.3945143187790503, 0.3945143187790503, 0.19855695781767535, 0.19855695781767535, 0.19855695781767535, 0.3869973554093201, 0.3869973554093201, 0.3869973554093201, 0.17222369938606785, 0.17222369938606785, 0.17222369938606785, 0.08233996683835465, 0.08233996683835465, 0.08233996683835465, 0.149606302736213, 0.149606302736213, 0.149606302736213, 0.11112154275396824, 0.11112154275396824, 0.11112154275396824, 0.16179535771338027, 0.16179535771338027, 0.16179535771338027, 0.03125476848952091, 0.03125476848952091, 0.03125476848952091, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08753118527227455, 0.08753118527227455, 0.08753118527227455, 0.026286276063754666, 0.026286276063754666, 0.026286276063754666, 0.04291451962939041, 0.04291451962939041, 0.04291451962939041, 0.03902952803627091, 0.03902952803627091, 0.03902952803627091, 0.06262404148400003, 0.06262404148400003, 0.06262404148400003, 0.1276181347921771, 0.1276181347921771, 0.1276181347921771, 0.07019026795971273, 0.07019026795971273, 0.07019026795971273, 0.00541894644505081, 0.00541894644505081, 0.00541894644505081, 0.04476004856473825, 0.04476004856473825, 0.04476004856473825, 0.4598207087004005, 0.4598207087004005, 0.4598207087004005, 0.4403732771885559, 0.4403732771885559, 0.4403732771885559, 0.5102326353144945, 0.5102326353144945, 0.5102326353144945, 0.059154341878810524, 0.059154341878810524, 0.059154341878810524, 0.0989120292720983, 0.0989120292720983, 0.0989120292720983, 0.09784532543137936, 0.09784532543137936, 0.09784532543137936, 0.18133961869193893, 0.18133961869193893, 0.18133961869193893, 0.22896093682573504, 0.22896093682573504, 0.22896093682573504, 0.25434190724568295, 0.25434190724568295, 0.25434190724568295, 0.3080438018004996, 0.3080438018004996, 0.3080438018004996, 0.29089039284767537, 0.29089039284767537, 0.29089039284767537, 0.31666586723450185, 0.31666586723450185, 0.31666586723450185, 0.3050504401689391, 0.3050504401689391, 0.3050504401689391, 0.17734760514223402, 0.17734760514223402, 0.17734760514223402, 0.19820432975496238, 0.19820432975496238, 0.19820432975496238, 0.1801113986241173, 0.1801113986241173, 0.1801113986241173, 0.16690153841205735, 0.16690153841205735, 0.16690153841205735, 0.20052836429278909, 0.20052836429278909, 0.20052836429278909, 0.2169351502706267, 0.2169351502706267, 0.2169351502706267, 0.2299521225336394, 0.2299521225336394, 0.2299521225336394, 0.19156095993446265, 0.19156095993446265, 0.19156095993446265, 0.7781329699604251, 0.7781329699604251, 0.7781329699604251, 0.5829136635086738, 0.5829136635086738, 0.5829136635086738, 0.19730271848208525, 0.19730271848208525, 0.19730271848208525, 0.44033572986573966, 0.44033572986573966, 0.44033572986573966, 0.5063830789686531, 0.5063830789686531, 0.5063830789686531, 0.5050504689185067, 0.5050504689185067, 0.5050504689185067, 0.1853169418879237, 0.1853169418879237, 0.1853169418879237, 0.1805577739102857, 0.1805577739102857, 0.1805577739102857, 0.1883801289430399, 0.1883801289430399, 0.1883801289430399, 0.0719949969888718, 0.0719949969888718, 0.0719949969888718, 0.08949294250135664, 0.08949294250135664, 0.08949294250135664, 0.09330271193315043, 0.09330271193315043, 0.09330271193315043]}, "mutation_prompt": null}
{"id": "adf1fbbb-65c2-46fe-8684-8c4cc83061a5", "solution": "import numpy as np\n\nclass EnhancedQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted to enhance exploration-exploitation balance\n        self.F = 0.85  # Slightly increased to enhance differential variation\n        self.CR = 0.9  # Increased to promote crossover\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2  # Enhanced mutation rate for greater diversity\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * evaluations / self.budget  # Linear inertia decay for stability\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)  # Increased mutation size\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedQuantumHybridPSO_DE", "description": "Enhanced Quantum-Inspired Hybrid PSO-DE with Adaptive Velocity, Rotational Diversification, and Stochastic Mutation for Robust Search.", "configspace": "", "generation": 18, "fitness": 0.203907188873332, "feedback": "The algorithm EnhancedQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.22.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.47552893557588916, 0.47552893557588916, 0.47552893557588916, 0.5295675430363801, 0.5295675430363801, 0.5295675430363801, 0.538558699882626, 0.538558699882626, 0.538558699882626, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024167154715351136, 0.024167154715351136, 0.024167154715351136, 0.009221617664253556, 0.009221617664253556, 0.009221617664253556, 0.11743361555968479, 0.11743361555968479, 0.11743361555968479, 0.10598712358627704, 0.10598712358627704, 0.10598712358627704, 0.1257125107064876, 0.1257125107064876, 0.1257125107064876, 0.0872085230232249, 0.0872085230232249, 0.0872085230232249, 0.09363454092621581, 0.09363454092621581, 0.09363454092621581, 0.10067805768713356, 0.10067805768713356, 0.10067805768713356, 0.9842551374648446, 0.9842551374648446, 0.9842551374648446, 0.9846528407280665, 0.9846528407280665, 0.9846528407280665, 0.9905504664266528, 0.9905504664266528, 0.9905504664266528, 0.27029239134715655, 0.27029239134715655, 0.27029239134715655, 0.14169663094318674, 0.14169663094318674, 0.14169663094318674, 0.24731433212655918, 0.24731433212655918, 0.24731433212655918, 0.22492599815332737, 0.22492599815332737, 0.22492599815332737, 0.17903077112282284, 0.17903077112282284, 0.17903077112282284, 0.2803305653575624, 0.2803305653575624, 0.2803305653575624, 0.13868629913617547, 0.13868629913617547, 0.13868629913617547, 0.08182745848375472, 0.08182745848375472, 0.08182745848375472, 0.15068774744871194, 0.15068774744871194, 0.15068774744871194, 0.04614975204581273, 0.04614975204581273, 0.04614975204581273, 0.09610680454335419, 0.09610680454335419, 0.09610680454335419, 0.1370656484134668, 0.1370656484134668, 0.1370656484134668, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07686907479216587, 0.07686907479216587, 0.07686907479216587, 0.027540678704195853, 0.027540678704195853, 0.027540678704195853, 0.013445711900294866, 0.013445711900294866, 0.013445711900294866, 0.019468486368901528, 0.019468486368901528, 0.019468486368901528, 0.03757957114846855, 0.03757957114846855, 0.03757957114846855, 0.04204568723776936, 0.04204568723776936, 0.04204568723776936, 0.00541250933499049, 0.00541250933499049, 0.00541250933499049, 0.028285021254743192, 0.028285021254743192, 0.028285021254743192, 0.041820835260410805, 0.041820835260410805, 0.041820835260410805, 0.4136986795011922, 0.4136986795011922, 0.4136986795011922, 0.3705492269153008, 0.3705492269153008, 0.3705492269153008, 0.37600837873689064, 0.37600837873689064, 0.37600837873689064, 0.07969002157240501, 0.07969002157240501, 0.07969002157240501, 0.10817031450912451, 0.10817031450912451, 0.10817031450912451, 0.07512556141625026, 0.07512556141625026, 0.07512556141625026, 0.13853422552698635, 0.13853422552698635, 0.13853422552698635, 0.17779308897121204, 0.17779308897121204, 0.17779308897121204, 0.14710078766688695, 0.14710078766688695, 0.14710078766688695, 0.2884495111618367, 0.2884495111618367, 0.2884495111618367, 0.29717832647069886, 0.29717832647069886, 0.29717832647069886, 0.2336472386922629, 0.2336472386922629, 0.2336472386922629, 0.1332793868112081, 0.1332793868112081, 0.1332793868112081, 0.17138850172086018, 0.17138850172086018, 0.17138850172086018, 0.21953699741420074, 0.21953699741420074, 0.21953699741420074, 0.17996618323008629, 0.17996618323008629, 0.17996618323008629, 0.1780043930405394, 0.1780043930405394, 0.1780043930405394, 0.17907673451061878, 0.17907673451061878, 0.17907673451061878, 0.1713955084859684, 0.1713955084859684, 0.1713955084859684, 0.18449220127329757, 0.18449220127329757, 0.18449220127329757, 0.21086946919800653, 0.21086946919800653, 0.21086946919800653, 0.6564181636510005, 0.6564181636510005, 0.6564181636510005, 0.16180111599648428, 0.16180111599648428, 0.16180111599648428, 0.37576218236579717, 0.37576218236579717, 0.37576218236579717, 0.5285415236505293, 0.5285415236505293, 0.5285415236505293, 0.19862553279448703, 0.19862553279448703, 0.19862553279448703, 0.14808754474834407, 0.14808754474834407, 0.14808754474834407, 0.19464370410993914, 0.19464370410993914, 0.19464370410993914, 0.18588633052487047, 0.18588633052487047, 0.18588633052487047, 0.19233060976068495, 0.19233060976068495, 0.19233060976068495, 0.07835585158195768, 0.07835585158195768, 0.07835585158195768, 0.06935882026117923, 0.06935882026117923, 0.06935882026117923, 0.10341274050188132, 0.10341274050188132, 0.10341274050188132]}, "mutation_prompt": null}
{"id": "a6726018-f233-457f-b6b1-1fc5197337e5", "solution": "import numpy as np\n\nclass AdaptiveBiModalPSO_DE_Cultural:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.7\n        self.CR = 0.9\n        self.diversity_ratio = 0.2\n        self.mutation_chance = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n        cultural_archive = []\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n                    cultural_archive.append((g_best_position, g_best_score))\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.diversity_ratio * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_chance:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    if cultural_archive:\n                        archive_idx = np.random.choice(len(cultural_archive))\n                        cultural_leader = cultural_archive[archive_idx][0]\n                        mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                        positions[idx] = 0.5 * (cultural_leader + mutation_vector)\n                    else:\n                        positions[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveBiModalPSO_DE_Cultural", "description": "Adaptive Bi-modal Survival Strategy Augmented PSO-DE with Cultural Learning for Enhanced Convergence.", "configspace": "", "generation": 19, "fitness": 0.18733347799826022, "feedback": "The algorithm AdaptiveBiModalPSO_DE_Cultural got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.46374140052478807, 0.46374140052478807, 0.46374140052478807, 0.46217729648065486, 0.46217729648065486, 0.46217729648065486, 0.39712180918503714, 0.39712180918503714, 0.39712180918503714, 0.020865204760403655, 0.020865204760403655, 0.020865204760403655, 0.038494948561597075, 0.038494948561597075, 0.038494948561597075, 0.06645196268419273, 0.06645196268419273, 0.06645196268419273, 0.09352759112781772, 0.09352759112781772, 0.09352759112781772, 0.122394013636976, 0.122394013636976, 0.122394013636976, 0.08840011804522696, 0.08840011804522696, 0.08840011804522696, 0.08858887315044539, 0.08858887315044539, 0.08858887315044539, 0.059734705644357344, 0.059734705644357344, 0.059734705644357344, 0.08281947534868428, 0.08281947534868428, 0.08281947534868428, 0.9843682547019946, 0.9843682547019946, 0.9843682547019946, 0.9855197304724469, 0.9855197304724469, 0.9855197304724469, 0.9917154935720577, 0.9917154935720577, 0.9917154935720577, 0.22569444104527014, 0.22569444104527014, 0.22569444104527014, 0.13083761800913285, 0.13083761800913285, 0.13083761800913285, 0.1779234231408352, 0.1779234231408352, 0.1779234231408352, 0.20126405173134632, 0.20126405173134632, 0.20126405173134632, 0.18883095229762525, 0.18883095229762525, 0.18883095229762525, 0.14991164571211069, 0.14991164571211069, 0.14991164571211069, 0.10628106521731495, 0.10628106521731495, 0.10628106521731495, 0.09919184175270657, 0.09919184175270657, 0.09919184175270657, 0.12685153883405598, 0.12685153883405598, 0.12685153883405598, 0.09253828204013848, 0.09253828204013848, 0.09253828204013848, 0.09501572646517376, 0.09501572646517376, 0.09501572646517376, 0.09677599707561113, 0.09677599707561113, 0.09677599707561113, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04929367039169941, 0.04929367039169941, 0.04929367039169941, 0.06279723223961065, 0.06279723223961065, 0.06279723223961065, 0.06856812299783399, 0.06856812299783399, 0.06856812299783399, 0.010985928202707163, 0.010985928202707163, 0.010985928202707163, 0.015411953226291186, 0.015411953226291186, 0.015411953226291186, 0.016710066022797898, 0.016710066022797898, 0.016710066022797898, 0.01574311832985953, 0.01574311832985953, 0.01574311832985953, 0.045358589405330885, 0.045358589405330885, 0.045358589405330885, 0.039336174102927335, 0.039336174102927335, 0.039336174102927335, 0.38097817655935706, 0.38097817655935706, 0.38097817655935706, 0.32436281550012314, 0.32436281550012314, 0.32436281550012314, 0.324124771485235, 0.324124771485235, 0.324124771485235, 0.08625695386938603, 0.08625695386938603, 0.08625695386938603, 0.0940336761648699, 0.0940336761648699, 0.0940336761648699, 0.09625131787347696, 0.09625131787347696, 0.09625131787347696, 0.15713612490128348, 0.15713612490128348, 0.15713612490128348, 0.16057692067214213, 0.16057692067214213, 0.16057692067214213, 0.16226083109419542, 0.16226083109419542, 0.16226083109419542, 0.2128365046775048, 0.2128365046775048, 0.2128365046775048, 0.24609856131840446, 0.24609856131840446, 0.24609856131840446, 0.24146685133967916, 0.24146685133967916, 0.24146685133967916, 0.17249227324012373, 0.17249227324012373, 0.17249227324012373, 0.15347792882855393, 0.15347792882855393, 0.15347792882855393, 0.14742479844177692, 0.14742479844177692, 0.14742479844177692, 0.17630910993579618, 0.17630910993579618, 0.17630910993579618, 0.1892554985045306, 0.1892554985045306, 0.1892554985045306, 0.1771418499149049, 0.1771418499149049, 0.1771418499149049, 0.18747534036676694, 0.18747534036676694, 0.18747534036676694, 0.17390325725489364, 0.17390325725489364, 0.17390325725489364, 0.17149154046393866, 0.17149154046393866, 0.17149154046393866, 0.5495335079764352, 0.5495335079764352, 0.5495335079764352, 0.16708646696566998, 0.16708646696566998, 0.16708646696566998, 0.17976884223740142, 0.17976884223740142, 0.17976884223740142, 0.2767418340250035, 0.2767418340250035, 0.2767418340250035, 0.29604225073383983, 0.29604225073383983, 0.29604225073383983, 0.24426202612334058, 0.24426202612334058, 0.24426202612334058, 0.1762581798207652, 0.1762581798207652, 0.1762581798207652, 0.19393379790483445, 0.19393379790483445, 0.19393379790483445, 0.17800545246975386, 0.17800545246975386, 0.17800545246975386, 0.07035002754449593, 0.07035002754449593, 0.07035002754449593, 0.08145406395016941, 0.08145406395016941, 0.08145406395016941, 0.07767654757902387, 0.07767654757902387, 0.07767654757902387]}, "mutation_prompt": null}
{"id": "4afaeabc-e809-43d5-b373-f72cc883ea8f", "solution": "import numpy as np\n\nclass EnhancedQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.15\n        self.opposition_probability = 0.35\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        \n        # Oppositional Initialization\n        opposite_positions = self.lower_bound + self.upper_bound - positions\n        for i in range(self.population_size):\n            if func(opposite_positions[i]) < func(positions[i]):\n                positions[i] = opposite_positions[i]\n\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2  # Non-linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedQuantumHybridPSO_DE", "description": "Enhanced Quantum Hybrid PSO-DE with Adaptive Learning and Oppositional Initialization for improved convergence.", "configspace": "", "generation": 20, "fitness": 0.1942385508779968, "feedback": "The algorithm EnhancedQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5101860978346744, 0.5101860978346744, 0.5101860978346744, 0.507236017436288, 0.507236017436288, 0.507236017436288, 0.4904095132294358, 0.4904095132294358, 0.4904095132294358, 0.05937303882196954, 0.05937303882196954, 0.05937303882196954, 0.030214369737993185, 0.030214369737993185, 0.030214369737993185, 0.028359747074114816, 0.028359747074114816, 0.028359747074114816, 0.11886830508225688, 0.11886830508225688, 0.11886830508225688, 0.11472220115562226, 0.11472220115562226, 0.11472220115562226, 0.09738753573883674, 0.09738753573883674, 0.09738753573883674, 0.0736229019811353, 0.0736229019811353, 0.0736229019811353, 0.09652321987901435, 0.09652321987901435, 0.09652321987901435, 0.09159862093772231, 0.09159862093772231, 0.09159862093772231, 0.9674483972019647, 0.9674483972019647, 0.9674483972019647, 0.9730860873227728, 0.9730860873227728, 0.9730860873227728, 0.9694876018594739, 0.9694876018594739, 0.9694876018594739, 0.20503793104410495, 0.20503793104410495, 0.20503793104410495, 0.13227490905047556, 0.13227490905047556, 0.13227490905047556, 0.16636212809563278, 0.16636212809563278, 0.16636212809563278, 0.1676190866363042, 0.1676190866363042, 0.1676190866363042, 0.1702961744172382, 0.1702961744172382, 0.1702961744172382, 0.12489185586593754, 0.12489185586593754, 0.12489185586593754, 0.12715989436998387, 0.12715989436998387, 0.12715989436998387, 0.1013459151412881, 0.1013459151412881, 0.1013459151412881, 0.11851370946289186, 0.11851370946289186, 0.11851370946289186, 0.04283418131407868, 0.04283418131407868, 0.04283418131407868, 0.09345390952104848, 0.09345390952104848, 0.09345390952104848, 0.06286397673543465, 0.06286397673543465, 0.06286397673543465, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10883019257283943, 0.10883019257283943, 0.10883019257283943, 0.05239911837604361, 0.05239911837604361, 0.05239911837604361, 0.04010914115952524, 0.04010914115952524, 0.04010914115952524, 0.07224367671956045, 0.07224367671956045, 0.07224367671956045, 0.027009234824950323, 0.027009234824950323, 0.027009234824950323, 0.0326181374400738, 0.0326181374400738, 0.0326181374400738, 0.035039153206426144, 0.035039153206426144, 0.035039153206426144, 0.025853285779679602, 0.025853285779679602, 0.025853285779679602, 0.05919010503933442, 0.05919010503933442, 0.05919010503933442, 0.3624162437658881, 0.3624162437658881, 0.3624162437658881, 0.43066419352636554, 0.43066419352636554, 0.43066419352636554, 0.39017689230190533, 0.39017689230190533, 0.39017689230190533, 0.09405440205681859, 0.09405440205681859, 0.09405440205681859, 0.11705305124000753, 0.11705305124000753, 0.11705305124000753, 0.07894029527196345, 0.07894029527196345, 0.07894029527196345, 0.14601223387910556, 0.14601223387910556, 0.14601223387910556, 0.17982396841673087, 0.17982396841673087, 0.17982396841673087, 0.1794933520438402, 0.1794933520438402, 0.1794933520438402, 0.2170850916596595, 0.2170850916596595, 0.2170850916596595, 0.27357837701092835, 0.27357837701092835, 0.27357837701092835, 0.30100477308404283, 0.30100477308404283, 0.30100477308404283, 0.18328623912948194, 0.18328623912948194, 0.18328623912948194, 0.16123805272667957, 0.16123805272667957, 0.16123805272667957, 0.11941724292577638, 0.11941724292577638, 0.11941724292577638, 0.16676969728255686, 0.16676969728255686, 0.16676969728255686, 0.17453530093519143, 0.17453530093519143, 0.17453530093519143, 0.18055007783693489, 0.18055007783693489, 0.18055007783693489, 0.1772735617002762, 0.1772735617002762, 0.1772735617002762, 0.1847968396720493, 0.1847968396720493, 0.1847968396720493, 0.1883287353006956, 0.1883287353006956, 0.1883287353006956, 0.629743855622397, 0.629743855622397, 0.629743855622397, 0.1739631815915874, 0.1739631815915874, 0.1739631815915874, 0.16523588770929143, 0.16523588770929143, 0.16523588770929143, 0.3054218708358075, 0.3054218708358075, 0.3054218708358075, 0.3658358219919946, 0.3658358219919946, 0.3658358219919946, 0.18616130234791395, 0.18616130234791395, 0.18616130234791395, 0.18068207370391431, 0.18068207370391431, 0.18068207370391431, 0.178025239589931, 0.178025239589931, 0.178025239589931, 0.18362978385354722, 0.18362978385354722, 0.18362978385354722, 0.07112453948086472, 0.07112453948086472, 0.07112453948086472, 0.07612775725213528, 0.07612775725213528, 0.07612775725213528, 0.06795635540335987, 0.06795635540335987, 0.06795635540335987]}, "mutation_prompt": null}
{"id": "99a3587a-840d-47b1-bbdf-a6ab7946d808", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 1.0\n        self.c2_final = 1.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.8\n        self.CR = 0.9\n        self.rotational_diversity = 0.1\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial - (self.c2_initial - self.c2_final) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + c1 * r1 * (p_best_positions - positions) \n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumPSO_DE", "description": "Adaptive Quantum-Inspired PSO-DE that dynamically adjusts cognitive-social balance and mutation strategy for enhanced convergence.", "configspace": "", "generation": 21, "fitness": 0.19821271357337084, "feedback": "The algorithm AdaptiveQuantumPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.505670312329492, 0.505670312329492, 0.505670312329492, 0.5185448515960722, 0.5185448515960722, 0.5185448515960722, 0.5013751161581663, 0.5013751161581663, 0.5013751161581663, 0.023080623965191616, 0.023080623965191616, 0.023080623965191616, 0.0442225333806171, 0.0442225333806171, 0.0442225333806171, 0.1362964325543995, 0.1362964325543995, 0.1362964325543995, 0.10208323495712301, 0.10208323495712301, 0.10208323495712301, 0.09066211886449105, 0.09066211886449105, 0.09066211886449105, 0.11713167769413813, 0.11713167769413813, 0.11713167769413813, 0.09908042271975359, 0.09908042271975359, 0.09908042271975359, 0.07705117342336143, 0.07705117342336143, 0.07705117342336143, 0.08618856800277186, 0.08618856800277186, 0.08618856800277186, 0.9908065041110893, 0.9908065041110893, 0.9908065041110893, 0.9870570957483338, 0.9870570957483338, 0.9870570957483338, 0.992292862448304, 0.992292862448304, 0.992292862448304, 0.28692615655933906, 0.28692615655933906, 0.28692615655933906, 0.13070632065170718, 0.13070632065170718, 0.13070632065170718, 0.26376060884202257, 0.26376060884202257, 0.26376060884202257, 0.18613256701123715, 0.18613256701123715, 0.18613256701123715, 0.1525217786158931, 0.1525217786158931, 0.1525217786158931, 0.19109741570425642, 0.19109741570425642, 0.19109741570425642, 0.12786807638812947, 0.12786807638812947, 0.12786807638812947, 0.09532471178331103, 0.09532471178331103, 0.09532471178331103, 0.11197729942477197, 0.11197729942477197, 0.11197729942477197, 0.045106316111185873, 0.045106316111185873, 0.045106316111185873, 0.12406313468212049, 0.12406313468212049, 0.12406313468212049, 0.03421419483096355, 0.03421419483096355, 0.03421419483096355, 0.020547611711992486, 0.020547611711992486, 0.020547611711992486, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029665511692248403, 0.0029665511692248403, 0.0029665511692248403, 0.08602878971603534, 0.08602878971603534, 0.08602878971603534, 0.007439359025186776, 0.007439359025186776, 0.007439359025186776, 0.0356206445732834, 0.0356206445732834, 0.0356206445732834, 0.01843216799058378, 0.01843216799058378, 0.01843216799058378, 0.03365798958071009, 0.03365798958071009, 0.03365798958071009, 0.053733256698690224, 0.053733256698690224, 0.053733256698690224, 0.013912585925485055, 0.013912585925485055, 0.013912585925485055, 0.0838965593868739, 0.0838965593868739, 0.0838965593868739, 0.042877022645763097, 0.042877022645763097, 0.042877022645763097, 0.38331357694289936, 0.38331357694289936, 0.38331357694289936, 0.3868286632940713, 0.3868286632940713, 0.3868286632940713, 0.3905167683295031, 0.3905167683295031, 0.3905167683295031, 0.06058858169310044, 0.06058858169310044, 0.06058858169310044, 0.08129278170898957, 0.08129278170898957, 0.08129278170898957, 0.07811570525010592, 0.07811570525010592, 0.07811570525010592, 0.17834483826977998, 0.17834483826977998, 0.17834483826977998, 0.18186279741352895, 0.18186279741352895, 0.18186279741352895, 0.20648495236461506, 0.20648495236461506, 0.20648495236461506, 0.20499677231725177, 0.20499677231725177, 0.20499677231725177, 0.2696226048424435, 0.2696226048424435, 0.2696226048424435, 0.18581413945205172, 0.18581413945205172, 0.18581413945205172, 0.1254721230384901, 0.1254721230384901, 0.1254721230384901, 0.16268833299784624, 0.16268833299784624, 0.16268833299784624, 0.13665437842453287, 0.13665437842453287, 0.13665437842453287, 0.19319157387868258, 0.19319157387868258, 0.19319157387868258, 0.17374008178557576, 0.17374008178557576, 0.17374008178557576, 0.19605333443117656, 0.19605333443117656, 0.19605333443117656, 0.17566166843918596, 0.17566166843918596, 0.17566166843918596, 0.1765054993909172, 0.1765054993909172, 0.1765054993909172, 0.1800378383738076, 0.1800378383738076, 0.1800378383738076, 0.6724079818691855, 0.6724079818691855, 0.6724079818691855, 0.20364186629297965, 0.20364186629297965, 0.20364186629297965, 0.16346490537431835, 0.16346490537431835, 0.16346490537431835, 0.3060789258759571, 0.3060789258759571, 0.3060789258759571, 0.3490618244189527, 0.3490618244189527, 0.3490618244189527, 0.2468943406387294, 0.2468943406387294, 0.2468943406387294, 0.18150940808879767, 0.18150940808879767, 0.18150940808879767, 0.186636559056651, 0.186636559056651, 0.186636559056651, 0.17893965052059024, 0.17893965052059024, 0.17893965052059024, 0.07575880327172413, 0.07575880327172413, 0.07575880327172413, 0.07018817316339288, 0.07018817316339288, 0.07018817316339288, 0.08849127909079324, 0.08849127909079324, 0.08849127909079324]}, "mutation_prompt": null}
{"id": "b249e97b-ec6e-46f6-8eb6-8d1d95ac7399", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO_ChaoticSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.85\n        self.CR = 0.9\n        self.chaotic_search_probability = 0.1\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 3  # Cubic inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < self.chaotic_search_probability:\n                chaotic_position = g_best_position + 0.1 * np.tan(np.pi * (np.random.rand(self.dim) - 0.5))\n                chaotic_position = np.clip(chaotic_position, self.lower_bound, self.upper_bound)\n                score = func(chaotic_position)\n                evaluations += 1\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = chaotic_position\n\n            clone_count = int(0.2 * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumPSO_ChaoticSearch", "description": "Adaptive Quantum-Inspired PSO with Chaotic Search and Enhanced Mutation for Diversified Exploration and Exploitation.", "configspace": "", "generation": 22, "fitness": 0.2678616909609327, "feedback": "The algorithm AdaptiveQuantumPSO_ChaoticSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.757168202692191, 0.757168202692191, 0.757168202692191, 0.6432360820067424, 0.6432360820067424, 0.6432360820067424, 0.8033362742474985, 0.8033362742474985, 0.8033362742474985, 0.25102745615474864, 0.25102745615474864, 0.25102745615474864, 0.2356649357314573, 0.2356649357314573, 0.2356649357314573, 0.348061426845256, 0.348061426845256, 0.348061426845256, 0.13956893568583928, 0.13956893568583928, 0.13956893568583928, 0.1443011781372241, 0.1443011781372241, 0.1443011781372241, 0.10904187304490465, 0.10904187304490465, 0.10904187304490465, 0.12012080262617819, 0.12012080262617819, 0.12012080262617819, 0.10374178428300562, 0.10374178428300562, 0.10374178428300562, 0.1479335508271341, 0.1479335508271341, 0.1479335508271341, 0.98033156690761, 0.98033156690761, 0.98033156690761, 0.9783333342815814, 0.9783333342815814, 0.9783333342815814, 0.9783377937324689, 0.9783377937324689, 0.9783377937324689, 0.35704094630585437, 0.35704094630585437, 0.35704094630585437, 0.36203773285991836, 0.36203773285991836, 0.36203773285991836, 0.3072700309852323, 0.3072700309852323, 0.3072700309852323, 0.20332778954687136, 0.20332778954687136, 0.20332778954687136, 0.2116533258105976, 0.2116533258105976, 0.2116533258105976, 0.21230664883690953, 0.21230664883690953, 0.21230664883690953, 0.1657156527135467, 0.1657156527135467, 0.1657156527135467, 0.11871499148743336, 0.11871499148743336, 0.11871499148743336, 0.16065386700700057, 0.16065386700700057, 0.16065386700700057, 0.12399804928372538, 0.12399804928372538, 0.12399804928372538, 0.1402226058327597, 0.1402226058327597, 0.1402226058327597, 0.14658196689117797, 0.14658196689117797, 0.14658196689117797, 0.023280656564343194, 0.023280656564343194, 0.023280656564343194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039414284904989105, 0.039414284904989105, 0.039414284904989105, 0.036122601050811554, 0.036122601050811554, 0.036122601050811554, 0.06205992941016225, 0.06205992941016225, 0.06205992941016225, 0.05087929453963658, 0.05087929453963658, 0.05087929453963658, 0.045056901671091554, 0.045056901671091554, 0.045056901671091554, 0.20181220040045222, 0.20181220040045222, 0.20181220040045222, 0.09261950325761825, 0.09261950325761825, 0.09261950325761825, 0.1466054623257964, 0.1466054623257964, 0.1466054623257964, 0.09207769515116437, 0.09207769515116437, 0.09207769515116437, 0.11562723367355432, 0.11562723367355432, 0.11562723367355432, 0.5033716216150241, 0.5033716216150241, 0.5033716216150241, 0.5313640922967372, 0.5313640922967372, 0.5313640922967372, 0.5059204890804274, 0.5059204890804274, 0.5059204890804274, 0.09957755160213289, 0.09957755160213289, 0.09957755160213289, 0.10822990372995722, 0.10822990372995722, 0.10822990372995722, 0.08781093456250655, 0.08781093456250655, 0.08781093456250655, 0.18646047870549665, 0.18646047870549665, 0.18646047870549665, 0.2130891041681009, 0.2130891041681009, 0.2130891041681009, 0.18988197386981354, 0.18988197386981354, 0.18988197386981354, 0.3842338490692818, 0.3842338490692818, 0.3842338490692818, 0.40688132558563284, 0.40688132558563284, 0.40688132558563284, 0.39456959488677534, 0.39456959488677534, 0.39456959488677534, 0.344833166229326, 0.344833166229326, 0.344833166229326, 0.21148053956686108, 0.21148053956686108, 0.21148053956686108, 0.15261526189240282, 0.15261526189240282, 0.15261526189240282, 0.20243454144894268, 0.20243454144894268, 0.20243454144894268, 0.19897693021167806, 0.19897693021167806, 0.19897693021167806, 0.2124760775117993, 0.2124760775117993, 0.2124760775117993, 0.18652637604604427, 0.18652637604604427, 0.18652637604604427, 0.18361637468964354, 0.18361637468964354, 0.18361637468964354, 0.22437749556131703, 0.22437749556131703, 0.22437749556131703, 0.8924986636204131, 0.8924986636204131, 0.8924986636204131, 0.157760876503799, 0.157760876503799, 0.157760876503799, 0.9036210134669034, 0.9036210134669034, 0.9036210134669034, 0.40137058241736356, 0.40137058241736356, 0.40137058241736356, 0.20902186983748994, 0.20902186983748994, 0.20902186983748994, 0.15588055327501404, 0.15588055327501404, 0.15588055327501404, 0.20425625203564923, 0.20425625203564923, 0.20425625203564923, 0.19932238184259765, 0.19932238184259765, 0.19932238184259765, 0.17671297590153068, 0.17671297590153068, 0.17671297590153068, 0.08759539781373882, 0.08759539781373882, 0.08759539781373882, 0.09185661576918902, 0.09185661576918902, 0.09185661576918902, 0.1220323166590801, 0.1220323166590801, 0.1220323166590801]}, "mutation_prompt": null}
{"id": "4f520435-7751-4325-b3d8-5269ae6b4a5d", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Modified inertia weight minimum for slower decay\n        self.F = 0.9  # Increased DE scaling factor\n        self.CR = 0.9  # Increased crossover rate\n        self.diversity_preservation = 0.2  # Adjusted diversity factor\n        self.dynamic_mutation_probability = 0.1  # Dynamic mutation probability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 3  # Cubic decay for inertia\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.diversity_preservation * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.dynamic_mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveMultiSwarmQuantumPSO", "description": "Adaptive Multi-Swarm Quantum-Inspired Hybrid PSO with Dynamic Mutation Rates and Diversity Preservation for robust global optimization.", "configspace": "", "generation": 23, "fitness": 0.1793536512995569, "feedback": "The algorithm AdaptiveMultiSwarmQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.3919987630622128, 0.3919987630622128, 0.3919987630622128, 0.4320919403735508, 0.4320919403735508, 0.4320919403735508, 0.39945752514476673, 0.39945752514476673, 0.39945752514476673, 0.013547538717262997, 0.013547538717262997, 0.013547538717262997, 0.046258034900610756, 0.046258034900610756, 0.046258034900610756, 0.008583814409537593, 0.008583814409537593, 0.008583814409537593, 0.08592615395248993, 0.08592615395248993, 0.08592615395248993, 0.06443695036097674, 0.06443695036097674, 0.06443695036097674, 0.09709349306261283, 0.09709349306261283, 0.09709349306261283, 0.08731345022342862, 0.08731345022342862, 0.08731345022342862, 0.07937683740390888, 0.07937683740390888, 0.07937683740390888, 0.0738227686859656, 0.0738227686859656, 0.0738227686859656, 0.9843398914879911, 0.9843398914879911, 0.9843398914879911, 0.9855134634333182, 0.9855134634333182, 0.9855134634333182, 0.9917453030017143, 0.9917453030017143, 0.9917453030017143, 0.17772553958738158, 0.17772553958738158, 0.17772553958738158, 0.13712457742403017, 0.13712457742403017, 0.13712457742403017, 0.2228933440121944, 0.2228933440121944, 0.2228933440121944, 0.153552243789416, 0.153552243789416, 0.153552243789416, 0.15422140470123213, 0.15422140470123213, 0.15422140470123213, 0.13566981206503292, 0.13566981206503292, 0.13566981206503292, 0.1042759718719386, 0.1042759718719386, 0.1042759718719386, 0.11806621922288063, 0.11806621922288063, 0.11806621922288063, 0.12498357207469546, 0.12498357207469546, 0.12498357207469546, 0.019568249914195257, 0.019568249914195257, 0.019568249914195257, 0.10287100867776877, 0.10287100867776877, 0.10287100867776877, 0.08348049617273445, 0.08348049617273445, 0.08348049617273445, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05817202070026761, 0.05817202070026761, 0.05817202070026761, 0.09513047055517732, 0.09513047055517732, 0.09513047055517732, 0.014506697717627914, 0.014506697717627914, 0.014506697717627914, 0.018296864695719117, 0.018296864695719117, 0.018296864695719117, 0.01427418441074968, 0.01427418441074968, 0.01427418441074968, 0.030625440053469344, 0.030625440053469344, 0.030625440053469344, 0.022495874824442708, 0.022495874824442708, 0.022495874824442708, 0.025438411678810224, 0.025438411678810224, 0.025438411678810224, 0.04354654203208452, 0.04354654203208452, 0.04354654203208452, 0.34207136754334755, 0.34207136754334755, 0.34207136754334755, 0.37114698311090066, 0.37114698311090066, 0.37114698311090066, 0.3151344437796765, 0.3151344437796765, 0.3151344437796765, 0.055415280372684395, 0.055415280372684395, 0.055415280372684395, 0.06776627882288522, 0.06776627882288522, 0.06776627882288522, 0.06936878898011434, 0.06936878898011434, 0.06936878898011434, 0.1536497230297006, 0.1536497230297006, 0.1536497230297006, 0.21066134609330567, 0.21066134609330567, 0.21066134609330567, 0.20741902530697875, 0.20741902530697875, 0.20741902530697875, 0.23002979097199172, 0.23002979097199172, 0.23002979097199172, 0.26126311599981034, 0.26126311599981034, 0.26126311599981034, 0.23990255186217113, 0.23990255186217113, 0.23990255186217113, 0.14079426677453644, 0.14079426677453644, 0.14079426677453644, 0.1464213128711217, 0.1464213128711217, 0.1464213128711217, 0.17892486695117693, 0.17892486695117693, 0.17892486695117693, 0.19504804755077076, 0.19504804755077076, 0.19504804755077076, 0.1789050291840807, 0.1789050291840807, 0.1789050291840807, 0.16661034321315404, 0.16661034321315404, 0.16661034321315404, 0.20062446629561081, 0.20062446629561081, 0.20062446629561081, 0.16310578506296391, 0.16310578506296391, 0.16310578506296391, 0.17860441122997306, 0.17860441122997306, 0.17860441122997306, 0.5424253626684425, 0.5424253626684425, 0.5424253626684425, 0.14835620356811052, 0.14835620356811052, 0.14835620356811052, 0.1715030262681836, 0.1715030262681836, 0.1715030262681836, 0.15703377721277634, 0.15703377721277634, 0.15703377721277634, 0.18989624606582833, 0.18989624606582833, 0.18989624606582833, 0.2673703723544524, 0.2673703723544524, 0.2673703723544524, 0.1941183647345044, 0.1941183647345044, 0.1941183647345044, 0.18731504687450684, 0.18731504687450684, 0.18731504687450684, 0.18475613190512163, 0.18475613190512163, 0.18475613190512163, 0.06062724853056822, 0.06062724853056822, 0.06062724853056822, 0.07128093821474923, 0.07128093821474923, 0.07128093821474923, 0.0671880757617016, 0.0671880757617016, 0.0671880757617016]}, "mutation_prompt": null}
{"id": "a6734b5c-016d-445b-b2c0-9a71ae918900", "solution": "import numpy as np\n\nclass QuantumHybridPSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.85\n        self.w_min = 0.2\n        self.F = 0.8\n        self.CR = 0.9\n        self.rotational_diversity = 0.1\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 3  # Cubic inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "QuantumHybridPSO_DE_Adaptive", "description": "Quantum-Inspired Hybrid PSO-DE with Adaptive Diversity Management and Non-linear Inertia Strategy for enhanced global exploration.", "configspace": "", "generation": 24, "fitness": 0.19766325066984636, "feedback": "The algorithm QuantumHybridPSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5086912352712117, 0.5086912352712117, 0.5086912352712117, 0.4903310275296956, 0.4903310275296956, 0.4903310275296956, 0.5203751146264244, 0.5203751146264244, 0.5203751146264244, 0.02552281653613664, 0.02552281653613664, 0.02552281653613664, 0.1295176754862416, 0.1295176754862416, 0.1295176754862416, 0.022565758286234083, 0.022565758286234083, 0.022565758286234083, 0.09303983816397177, 0.09303983816397177, 0.09303983816397177, 0.19328896303428122, 0.19328896303428122, 0.19328896303428122, 0.1355388344266637, 0.1355388344266637, 0.1355388344266637, 0.10351669039379863, 0.10351669039379863, 0.10351669039379863, 0.06120143749918183, 0.06120143749918183, 0.06120143749918183, 0.09346976475350399, 0.09346976475350399, 0.09346976475350399, 0.9854484927883752, 0.9854484927883752, 0.9854484927883752, 0.9866131542408538, 0.9866131542408538, 0.9866131542408538, 0.9922925644040275, 0.9922925644040275, 0.9922925644040275, 0.28576760151788716, 0.28576760151788716, 0.28576760151788716, 0.13651014151462437, 0.13651014151462437, 0.13651014151462437, 0.26927795833238355, 0.26927795833238355, 0.26927795833238355, 0.20918322441732218, 0.20918322441732218, 0.20918322441732218, 0.1570126504524858, 0.1570126504524858, 0.1570126504524858, 0.12665077255567014, 0.12665077255567014, 0.12665077255567014, 0.14318227349752777, 0.14318227349752777, 0.14318227349752777, 0.11820528445157252, 0.11820528445157252, 0.11820528445157252, 0.14316164755144178, 0.14316164755144178, 0.14316164755144178, 0.032766330966154444, 0.032766330966154444, 0.032766330966154444, 0.13795025847611198, 0.13795025847611198, 0.13795025847611198, 0.10993950475993619, 0.10993950475993619, 0.10993950475993619, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00017216186580537585, 0.00017216186580537585, 0.00017216186580537585, 0.0015573055636377564, 0.0015573055636377564, 0.0015573055636377564, 0.05533684463779187, 0.05533684463779187, 0.05533684463779187, 0.041734333284958125, 0.041734333284958125, 0.041734333284958125, 0.05321773593252732, 0.05321773593252732, 0.05321773593252732, 0.01767589184527696, 0.01767589184527696, 0.01767589184527696, 0.03139309210032426, 0.03139309210032426, 0.03139309210032426, 0.032769175072160706, 0.032769175072160706, 0.032769175072160706, 0.005356063752706031, 0.005356063752706031, 0.005356063752706031, 0.09270227703820544, 0.09270227703820544, 0.09270227703820544, 0.042695598006290525, 0.042695598006290525, 0.042695598006290525, 0.4056825006510488, 0.4056825006510488, 0.4056825006510488, 0.4041872241168355, 0.4041872241168355, 0.4041872241168355, 0.3728378907269564, 0.3728378907269564, 0.3728378907269564, 0.05104518838005767, 0.05104518838005767, 0.05104518838005767, 0.08903463584965632, 0.08903463584965632, 0.08903463584965632, 0.06958289312011112, 0.06958289312011112, 0.06958289312011112, 0.14175875192156107, 0.14175875192156107, 0.14175875192156107, 0.16283905815717148, 0.16283905815717148, 0.16283905815717148, 0.1436136006738319, 0.1436136006738319, 0.1436136006738319, 0.26790489354613567, 0.26790489354613567, 0.26790489354613567, 0.1862261979298634, 0.1862261979298634, 0.1862261979298634, 0.2953517987680725, 0.2953517987680725, 0.2953517987680725, 0.15595144664352478, 0.15595144664352478, 0.15595144664352478, 0.16975183785063508, 0.16975183785063508, 0.16975183785063508, 0.12592304797210652, 0.12592304797210652, 0.12592304797210652, 0.18622148641456326, 0.18622148641456326, 0.18622148641456326, 0.1846909461468047, 0.1846909461468047, 0.1846909461468047, 0.1914819677979509, 0.1914819677979509, 0.1914819677979509, 0.18207333951843507, 0.18207333951843507, 0.18207333951843507, 0.19636563376765925, 0.19636563376765925, 0.19636563376765925, 0.1883735028535144, 0.1883735028535144, 0.1883735028535144, 0.7242061742583339, 0.7242061742583339, 0.7242061742583339, 0.187977266591288, 0.187977266591288, 0.187977266591288, 0.16793676347331998, 0.16793676347331998, 0.16793676347331998, 0.15254040848867167, 0.15254040848867167, 0.15254040848867167, 0.19726050679934093, 0.19726050679934093, 0.19726050679934093, 0.259206022158053, 0.259206022158053, 0.259206022158053, 0.2035052146836992, 0.2035052146836992, 0.2035052146836992, 0.17577215509084487, 0.17577215509084487, 0.17577215509084487, 0.18744749348463596, 0.18744749348463596, 0.18744749348463596, 0.07258213680482473, 0.07258213680482473, 0.07258213680482473, 0.07604864881135143, 0.07604864881135143, 0.07604864881135143, 0.07064191974467415, 0.07064191974467415, 0.07064191974467415]}, "mutation_prompt": null}
{"id": "b1932756-8581-4220-8f8e-383a7d5c23c9", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.2  # Increased diversity\n        self.mutation_probability = 0.2  # Increased mutation probability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = np.zeros(self.dim)\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.cos(np.pi * evaluations / (2 * self.budget))  # Cosine inertia decay\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = np.copy(positions[i])\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == np.random.randint(self.dim):\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = np.copy(trial_vector)\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = np.copy(positions[idx])\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Enhanced Rotational Diversity and Stochastic Mutation for Efficient Global Optimization.", "configspace": "", "generation": 25, "fitness": 0.30468425958476997, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.8890629007571463, 0.8890629007571463, 0.8890629007571463, 0.8874460461149305, 0.8874460461149305, 0.8874460461149305, 0.8882492357798968, 0.8882492357798968, 0.8882492357798968, 0.5739037463822181, 0.5739037463822181, 0.5739037463822181, 0.5482097461115589, 0.5482097461115589, 0.5482097461115589, 0.579859881321402, 0.579859881321402, 0.579859881321402, 0.18002309600912447, 0.18002309600912447, 0.18002309600912447, 0.1128884254336614, 0.1128884254336614, 0.1128884254336614, 0.15565726993086448, 0.15565726993086448, 0.15565726993086448, 0.10849911507835164, 0.10849911507835164, 0.10849911507835164, 0.11850188352046775, 0.11850188352046775, 0.11850188352046775, 0.11005997301195802, 0.11005997301195802, 0.11005997301195802, 0.9796530275327943, 0.9796530275327943, 0.9796530275327943, 0.9785913562428973, 0.9785913562428973, 0.9785913562428973, 0.9809916796392503, 0.9809916796392503, 0.9809916796392503, 0.4272657683353026, 0.4272657683353026, 0.4272657683353026, 0.5339226313008353, 0.5339226313008353, 0.5339226313008353, 0.3894789641533214, 0.3894789641533214, 0.3894789641533214, 0.24109403733367651, 0.24109403733367651, 0.24109403733367651, 0.20207643008568343, 0.20207643008568343, 0.20207643008568343, 0.17541728347219032, 0.17541728347219032, 0.17541728347219032, 0.2556290178481381, 0.2556290178481381, 0.2556290178481381, 0.12893100105151056, 0.12893100105151056, 0.12893100105151056, 0.18126568735132698, 0.18126568735132698, 0.18126568735132698, 0.16050176025892127, 0.16050176025892127, 0.16050176025892127, 0.18638275308928276, 0.18638275308928276, 0.18638275308928276, 0.13623440182626034, 0.13623440182626034, 0.13623440182626034, 0.039412290683819684, 0.039412290683819684, 0.039412290683819684, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03711239901846053, 0.03711239901846053, 0.03711239901846053, 0.0373740747621778, 0.0373740747621778, 0.0373740747621778, 0.06592773115952733, 0.06592773115952733, 0.06592773115952733, 0.049665987779552445, 0.049665987779552445, 0.049665987779552445, 0.186940236032349, 0.186940236032349, 0.186940236032349, 0.09251670918578325, 0.09251670918578325, 0.09251670918578325, 0.061977490569257276, 0.061977490569257276, 0.061977490569257276, 0.048919580295718745, 0.048919580295718745, 0.048919580295718745, 0.12046013816505052, 0.12046013816505052, 0.12046013816505052, 0.5724503921962487, 0.5724503921962487, 0.5724503921962487, 0.49033004240495626, 0.49033004240495626, 0.49033004240495626, 0.5351742670312234, 0.5351742670312234, 0.5351742670312234, 0.07767050348342597, 0.07767050348342597, 0.07767050348342597, 0.09597462732453899, 0.09597462732453899, 0.09597462732453899, 0.08071374633611361, 0.08071374633611361, 0.08071374633611361, 0.1882865813250323, 0.1882865813250323, 0.1882865813250323, 0.18598870277523638, 0.18598870277523638, 0.18598870277523638, 0.2644237433111539, 0.2644237433111539, 0.2644237433111539, 0.3267795991439514, 0.3267795991439514, 0.3267795991439514, 0.3118885301286799, 0.3118885301286799, 0.3118885301286799, 0.2438022264918458, 0.2438022264918458, 0.2438022264918458, 0.23579099605256537, 0.23579099605256537, 0.23579099605256537, 0.1896125105215094, 0.1896125105215094, 0.1896125105215094, 0.1719642664758645, 0.1719642664758645, 0.1719642664758645, 0.20836418274163993, 0.20836418274163993, 0.20836418274163993, 0.24530904295166966, 0.24530904295166966, 0.24530904295166966, 0.21119482241275378, 0.21119482241275378, 0.21119482241275378, 0.7716274672635088, 0.7716274672635088, 0.7716274672635088, 0.19893458753716908, 0.19893458753716908, 0.19893458753716908, 0.203563336275969, 0.203563336275969, 0.203563336275969, 0.9344873134930369, 0.9344873134930369, 0.9344873134930369, 0.8669373000378444, 0.8669373000378444, 0.8669373000378444, 0.16870429217553917, 0.16870429217553917, 0.16870429217553917, 0.5202070518790471, 0.5202070518790471, 0.5202070518790471, 0.3262639131146108, 0.3262639131146108, 0.3262639131146108, 0.4861374690747119, 0.4861374690747119, 0.4861374690747119, 0.2321137578617385, 0.2321137578617385, 0.2321137578617385, 0.18141427830770018, 0.18141427830770018, 0.18141427830770018, 0.21799042745237507, 0.21799042745237507, 0.21799042745237507, 0.0904599379967107, 0.0904599379967107, 0.0904599379967107, 0.11173747991220151, 0.11173747991220151, 0.11173747991220151, 0.14066553798820036, 0.14066553798820036, 0.14066553798820036]}, "mutation_prompt": null}
{"id": "56103dff-4311-4308-957b-ee91f33d8613", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.1  # Reduced mutation probability for balance\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Stochastic inertia weight\n            w = self.w_min + np.random.rand() * (self.w_max - self.w_min)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)  # Reduced mutation rate\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Stochastic Inertia and Mutation for robust global search.", "configspace": "", "generation": 26, "fitness": 0.2869197977012859, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.7964059788549736, 0.7964059788549736, 0.7964059788549736, 0.7911064811984961, 0.7911064811984961, 0.7911064811984961, 0.809129756018064, 0.809129756018064, 0.809129756018064, 0.5749902542069847, 0.5749902542069847, 0.5749902542069847, 0.47859023727383454, 0.47859023727383454, 0.47859023727383454, 0.5902729888383467, 0.5902729888383467, 0.5902729888383467, 0.1426508180753382, 0.1426508180753382, 0.1426508180753382, 0.08973296133865571, 0.08973296133865571, 0.08973296133865571, 0.12789240534873947, 0.12789240534873947, 0.12789240534873947, 0.15887143419558358, 0.15887143419558358, 0.15887143419558358, 0.1452144552799668, 0.1452144552799668, 0.1452144552799668, 0.13826540708427293, 0.13826540708427293, 0.13826540708427293, 0.9792606211192633, 0.9792606211192633, 0.9792606211192633, 0.9843961732701976, 0.9843961732701976, 0.9843961732701976, 0.975624524918497, 0.975624524918497, 0.975624524918497, 0.4697778669696506, 0.4697778669696506, 0.4697778669696506, 0.34771945218360756, 0.34771945218360756, 0.34771945218360756, 0.4545267125343164, 0.4545267125343164, 0.4545267125343164, 0.6439241712429138, 0.6439241712429138, 0.6439241712429138, 0.20243846698301982, 0.20243846698301982, 0.20243846698301982, 0.23087519353752572, 0.23087519353752572, 0.23087519353752572, 0.23076227917399827, 0.23076227917399827, 0.23076227917399827, 0.33980907952869865, 0.33980907952869865, 0.33980907952869865, 0.18152449679741345, 0.18152449679741345, 0.18152449679741345, 0.12167504777340221, 0.12167504777340221, 0.12167504777340221, 0.15224773264269753, 0.15224773264269753, 0.15224773264269753, 0.08558837331142388, 0.08558837331142388, 0.08558837331142388, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003497674828637942, 0.003497674828637942, 0.003497674828637942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06651106587223476, 0.06651106587223476, 0.06651106587223476, 0.05874569278491615, 0.05874569278491615, 0.05874569278491615, 0.02743052723791095, 0.02743052723791095, 0.02743052723791095, 0.04360978825050188, 0.04360978825050188, 0.04360978825050188, 0.0687964352825462, 0.0687964352825462, 0.0687964352825462, 0.06317533760606453, 0.06317533760606453, 0.06317533760606453, 0.010401632276030304, 0.010401632276030304, 0.010401632276030304, 0.036512771003554545, 0.036512771003554545, 0.036512771003554545, 0.0730700137567788, 0.0730700137567788, 0.0730700137567788, 0.49897125703355827, 0.49897125703355827, 0.49897125703355827, 0.5831765194286411, 0.5831765194286411, 0.5831765194286411, 0.5540149376203511, 0.5540149376203511, 0.5540149376203511, 0.0902993237207298, 0.0902993237207298, 0.0902993237207298, 0.1044182854351502, 0.1044182854351502, 0.1044182854351502, 0.11062916602877049, 0.11062916602877049, 0.11062916602877049, 0.21114847880217302, 0.21114847880217302, 0.21114847880217302, 0.3056779989228131, 0.3056779989228131, 0.3056779989228131, 0.26017111326584486, 0.26017111326584486, 0.26017111326584486, 0.37230360365115933, 0.37230360365115933, 0.37230360365115933, 0.32523686519652895, 0.32523686519652895, 0.32523686519652895, 0.46017597859839465, 0.46017597859839465, 0.46017597859839465, 0.2088412561317542, 0.2088412561317542, 0.2088412561317542, 0.2444134117418062, 0.2444134117418062, 0.2444134117418062, 0.14014704817776125, 0.14014704817776125, 0.14014704817776125, 0.20832033085365775, 0.20832033085365775, 0.20832033085365775, 0.2104880395471037, 0.2104880395471037, 0.2104880395471037, 0.19883120105151997, 0.19883120105151997, 0.19883120105151997, 0.6234639978640744, 0.6234639978640744, 0.6234639978640744, 0.18562709062066707, 0.18562709062066707, 0.18562709062066707, 0.21328314556481598, 0.21328314556481598, 0.21328314556481598, 0.8551739771303218, 0.8551739771303218, 0.8551739771303218, 0.16481501509187002, 0.16481501509187002, 0.16481501509187002, 0.1682698588004179, 0.1682698588004179, 0.1682698588004179, 0.4505808728273276, 0.4505808728273276, 0.4505808728273276, 0.20791767078284207, 0.20791767078284207, 0.20791767078284207, 0.1550563375757389, 0.1550563375757389, 0.1550563375757389, 0.19808979713588926, 0.19808979713588926, 0.19808979713588926, 0.1748137138270489, 0.1748137138270489, 0.1748137138270489, 0.18876568463497356, 0.18876568463497356, 0.18876568463497356, 0.08819454578915031, 0.08819454578915031, 0.08819454578915031, 0.07771606979086287, 0.07771606979086287, 0.07771606979086287, 0.12396853324980917, 0.12396853324980917, 0.12396853324980917]}, "mutation_prompt": null}
{"id": "7924824f-f77b-4c11-ab27-a3d9a847f6af", "solution": "import numpy as np\n\nclass EnhancedQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted inertia min value for gradual decay\n        self.F = 0.9  # Increased DE scaling factor\n        self.CR = 0.9  # Increased crossover rate for more dimensions swapped\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2  # Increased mutation probability for diversity\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2  # Quadratic inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)  # Increased mutation size\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedQuantumHybridPSO_DE", "description": "Enhanced Quantum-Inspired Hybrid PSO-DE with Adaptive Velocity Scaling and Randomized Mutation for improved exploration and exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.18515109749292527, "feedback": "The algorithm EnhancedQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.40867024389307904, 0.40867024389307904, 0.40867024389307904, 0.39197790751844375, 0.39197790751844375, 0.39197790751844375, 0.37992506669124837, 0.37992506669124837, 0.37992506669124837, 0.03122250688094441, 0.03122250688094441, 0.03122250688094441, 0.019246760154521536, 0.019246760154521536, 0.019246760154521536, 0.01976424911145991, 0.01976424911145991, 0.01976424911145991, 0.07494374688024474, 0.07494374688024474, 0.07494374688024474, 0.07282766606119362, 0.07282766606119362, 0.07282766606119362, 0.07722093690362652, 0.07722093690362652, 0.07722093690362652, 0.0571973660601911, 0.0571973660601911, 0.0571973660601911, 0.08237904724470646, 0.08237904724470646, 0.08237904724470646, 0.06300301785296447, 0.06300301785296447, 0.06300301785296447, 0.9842551374648446, 0.9842551374648446, 0.9842551374648446, 0.9846445447632597, 0.9846445447632597, 0.9846445447632597, 0.9905504664266528, 0.9905504664266528, 0.9905504664266528, 0.18946342797932902, 0.18946342797932902, 0.18946342797932902, 0.13757672460116988, 0.13757672460116988, 0.13757672460116988, 0.18438603149291843, 0.18438603149291843, 0.18438603149291843, 0.17714931508746268, 0.17714931508746268, 0.17714931508746268, 0.4114292944882816, 0.4114292944882816, 0.4114292944882816, 0.12427334209099594, 0.12427334209099594, 0.12427334209099594, 0.11195961604848748, 0.11195961604848748, 0.11195961604848748, 0.11593279688960934, 0.11593279688960934, 0.11593279688960934, 0.10842965766666113, 0.10842965766666113, 0.10842965766666113, 0.03655646098783327, 0.03655646098783327, 0.03655646098783327, 0.09360085339381163, 0.09360085339381163, 0.09360085339381163, 0.071783653973302, 0.071783653973302, 0.071783653973302, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0021845842693170026, 0.0021845842693170026, 0.0021845842693170026, 0.02434552979361726, 0.02434552979361726, 0.02434552979361726, 0.013885771046031725, 0.013885771046031725, 0.013885771046031725, 0.037875064698187244, 0.037875064698187244, 0.037875064698187244, 0.007758486541034615, 0.007758486541034615, 0.007758486541034615, 0.023945311087238075, 0.023945311087238075, 0.023945311087238075, 0.017071279589090826, 0.017071279589090826, 0.017071279589090826, 0.037388165452516664, 0.037388165452516664, 0.037388165452516664, 0.044936885841873164, 0.044936885841873164, 0.044936885841873164, 0.0335441628621187, 0.0335441628621187, 0.0335441628621187, 0.3317716469727976, 0.3317716469727976, 0.3317716469727976, 0.35372922214877967, 0.35372922214877967, 0.35372922214877967, 0.3239969185615592, 0.3239969185615592, 0.3239969185615592, 0.08516181394829869, 0.08516181394829869, 0.08516181394829869, 0.0768306540483158, 0.0768306540483158, 0.0768306540483158, 0.08078254622941217, 0.08078254622941217, 0.08078254622941217, 0.14304236986297614, 0.14304236986297614, 0.14304236986297614, 0.19644751809992977, 0.19644751809992977, 0.19644751809992977, 0.17585878500970809, 0.17585878500970809, 0.17585878500970809, 0.21185385322608807, 0.21185385322608807, 0.21185385322608807, 0.18279285416965074, 0.18279285416965074, 0.18279285416965074, 0.24789567000725932, 0.24789567000725932, 0.24789567000725932, 0.11570772029028031, 0.11570772029028031, 0.11570772029028031, 0.15621032961553027, 0.15621032961553027, 0.15621032961553027, 0.1872157731725791, 0.1872157731725791, 0.1872157731725791, 0.16495373644033606, 0.16495373644033606, 0.16495373644033606, 0.17025319062110011, 0.17025319062110011, 0.17025319062110011, 0.16781644423750308, 0.16781644423750308, 0.16781644423750308, 0.1667150970456931, 0.1667150970456931, 0.1667150970456931, 0.1870855076448339, 0.1870855076448339, 0.1870855076448339, 0.17695631553338387, 0.17695631553338387, 0.17695631553338387, 0.5448555269654125, 0.5448555269654125, 0.5448555269654125, 0.41835831284464764, 0.41835831284464764, 0.41835831284464764, 0.182990598828228, 0.182990598828228, 0.182990598828228, 0.2972089960066694, 0.2972089960066694, 0.2972089960066694, 0.3336558970778304, 0.3336558970778304, 0.3336558970778304, 0.24813939358191106, 0.24813939358191106, 0.24813939358191106, 0.19206078863398923, 0.19206078863398923, 0.19206078863398923, 0.17404997634861774, 0.17404997634861774, 0.17404997634861774, 0.1826507130584749, 0.1826507130584749, 0.1826507130584749, 0.07002285271153341, 0.07002285271153341, 0.07002285271153341, 0.07750498442198583, 0.07750498442198583, 0.07750498442198583, 0.06279793233703457, 0.06279793233703457, 0.06279793233703457]}, "mutation_prompt": null}
{"id": "cdde7b5a-41e2-45cd-8eef-dc79a6f75d0d", "solution": "import numpy as np\n\nclass EnhancedRotationalDiversityPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 2.0  # Increased cognitive attraction\n        self.c2 = 2.0  # Increased social attraction\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted to change the inertia bounds\n        self.F = 0.9  # Increased differential weight\n        self.CR = 0.9  # Increased crossover rate\n        self.rotational_diversity = 0.2  # Increased diversity impact\n        self.mutation_probability = 0.2  # Increased mutation probability for diversity\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - (evaluations / self.budget) ** 3)  # More aggressive non-linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)  # Increased mutation rate\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedRotationalDiversityPSO_DE", "description": "Enhanced Rotational Diversity with Adaptive Inertia and Mutative Differential Evolution for Diverse Exploration and Exploitation Balance.", "configspace": "", "generation": 28, "fitness": 0.2264271600046479, "feedback": "The algorithm EnhancedRotationalDiversityPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.23.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.7568424792665234, 0.7568424792665234, 0.7568424792665234, 0.709212249959432, 0.709212249959432, 0.709212249959432, 0.6745110594160676, 0.6745110594160676, 0.6745110594160676, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044314476069409636, 0.044314476069409636, 0.044314476069409636, 0.05166172692722448, 0.05166172692722448, 0.05166172692722448, 0.11136901709485791, 0.11136901709485791, 0.11136901709485791, 0.07635622048932422, 0.07635622048932422, 0.07635622048932422, 0.13197949089505, 0.13197949089505, 0.13197949089505, 0.1211601794117616, 0.1211601794117616, 0.1211601794117616, 0.13340105277486636, 0.13340105277486636, 0.13340105277486636, 0.09115202733314731, 0.09115202733314731, 0.09115202733314731, 0.9872926906777377, 0.9872926906777377, 0.9872926906777377, 0.9838781765759195, 0.9838781765759195, 0.9838781765759195, 0.9811566184939451, 0.9811566184939451, 0.9811566184939451, 0.31241198717274943, 0.31241198717274943, 0.31241198717274943, 0.2646176776566457, 0.2646176776566457, 0.2646176776566457, 0.22965662347194293, 0.22965662347194293, 0.22965662347194293, 0.23637039896055945, 0.23637039896055945, 0.23637039896055945, 0.18042063775010642, 0.18042063775010642, 0.18042063775010642, 0.25443684847405457, 0.25443684847405457, 0.25443684847405457, 0.14839060824698969, 0.14839060824698969, 0.14839060824698969, 0.12397986826478846, 0.12397986826478846, 0.12397986826478846, 0.14565820394037055, 0.14565820394037055, 0.14565820394037055, 0.03389643123812369, 0.03389643123812369, 0.03389643123812369, 0.15280454519408326, 0.15280454519408326, 0.15280454519408326, 0.18060321994236506, 0.18060321994236506, 0.18060321994236506, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03864817521679598, 0.03864817521679598, 0.03864817521679598, 0.05563377465566832, 0.05563377465566832, 0.05563377465566832, 0.04866014031415655, 0.04866014031415655, 0.04866014031415655, 0.04121825511980637, 0.04121825511980637, 0.04121825511980637, 0.11718553504061657, 0.11718553504061657, 0.11718553504061657, 0.08413266627305749, 0.08413266627305749, 0.08413266627305749, 0.006926287875065662, 0.006926287875065662, 0.006926287875065662, 0.11610172225675919, 0.11610172225675919, 0.11610172225675919, 0.07790427733314043, 0.07790427733314043, 0.07790427733314043, 0.44618012678448304, 0.44618012678448304, 0.44618012678448304, 0.43267375245480677, 0.43267375245480677, 0.43267375245480677, 0.44648518634129497, 0.44648518634129497, 0.44648518634129497, 0.10671187467861598, 0.10671187467861598, 0.10671187467861598, 0.09178419927863413, 0.09178419927863413, 0.09178419927863413, 0.06455231816552676, 0.06455231816552676, 0.06455231816552676, 0.20918156799961374, 0.20918156799961374, 0.20918156799961374, 0.16692815692992713, 0.16692815692992713, 0.16692815692992713, 0.165723822436867, 0.165723822436867, 0.165723822436867, 0.3047884970827376, 0.3047884970827376, 0.3047884970827376, 0.3474146007175072, 0.3474146007175072, 0.3474146007175072, 0.35778809734185435, 0.35778809734185435, 0.35778809734185435, 0.1384137601224833, 0.1384137601224833, 0.1384137601224833, 0.2495326585578561, 0.2495326585578561, 0.2495326585578561, 0.21795996530841855, 0.21795996530841855, 0.21795996530841855, 0.19273621458151335, 0.19273621458151335, 0.19273621458151335, 0.1885887861493376, 0.1885887861493376, 0.1885887861493376, 0.17490938429034653, 0.17490938429034653, 0.17490938429034653, 0.20346842303629453, 0.20346842303629453, 0.20346842303629453, 0.22652987839793504, 0.22652987839793504, 0.22652987839793504, 0.18612232653785155, 0.18612232653785155, 0.18612232653785155, 0.8995012043014565, 0.8995012043014565, 0.8995012043014565, 0.2077542519966935, 0.2077542519966935, 0.2077542519966935, 0.1676448369849548, 0.1676448369849548, 0.1676448369849548, 0.2561133141363152, 0.2561133141363152, 0.2561133141363152, 0.20643158776167403, 0.20643158776167403, 0.20643158776167403, 0.15208379650556436, 0.15208379650556436, 0.15208379650556436, 0.18273958607593033, 0.18273958607593033, 0.18273958607593033, 0.18638307535127618, 0.18638307535127618, 0.18638307535127618, 0.1712865447953793, 0.1712865447953793, 0.1712865447953793, 0.07172401158154829, 0.07172401158154829, 0.07172401158154829, 0.0858302762101244, 0.0858302762101244, 0.0858302762101244, 0.09244408765671508, 0.09244408765671508, 0.09244408765671508]}, "mutation_prompt": null}
{"id": "5f55c148-4f28-4d13-b4ea-79da5123bf90", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.75\n        self.CR = 0.9\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2  # Non-linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            velocities = np.clip(velocities, -0.5, 0.5)  # Velocity clamping\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Velocity Clamping and Dynamic Mutation for robust convergence.", "configspace": "", "generation": 29, "fitness": 0.24209343693386268, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5268063732773391, 0.5268063732773391, 0.5268063732773391, 0.5263543532825428, 0.5263543532825428, 0.5263543532825428, 0.5146606573870641, 0.5146606573870641, 0.5146606573870641, 0.10652216890989352, 0.10652216890989352, 0.10652216890989352, 0.04788381775998607, 0.04788381775998607, 0.04788381775998607, 0.06896672908769963, 0.06896672908769963, 0.06896672908769963, 0.12656704197248492, 0.12656704197248492, 0.12656704197248492, 0.11113434488342677, 0.11113434488342677, 0.11113434488342677, 0.10375072705552923, 0.10375072705552923, 0.10375072705552923, 0.10978657756798915, 0.10978657756798915, 0.10978657756798915, 0.09169866364513779, 0.09169866364513779, 0.09169866364513779, 0.09889584318637878, 0.09889584318637878, 0.09889584318637878, 0.8929409970768366, 0.8929409970768366, 0.8929409970768366, 0.8920978505927154, 0.8920978505927154, 0.8920978505927154, 0.8958563403703774, 0.8958563403703774, 0.8958563403703774, 0.3056687638809471, 0.3056687638809471, 0.3056687638809471, 0.33425371417407235, 0.33425371417407235, 0.33425371417407235, 0.3250089874259432, 0.3250089874259432, 0.3250089874259432, 0.22185634367059448, 0.22185634367059448, 0.22185634367059448, 0.20990548876923898, 0.20990548876923898, 0.20990548876923898, 0.21896356144234463, 0.21896356144234463, 0.21896356144234463, 0.14550219128933728, 0.14550219128933728, 0.14550219128933728, 0.148413719617135, 0.148413719617135, 0.148413719617135, 0.2032587699789492, 0.2032587699789492, 0.2032587699789492, 0.1525406740012364, 0.1525406740012364, 0.1525406740012364, 0.16746302413779435, 0.16746302413779435, 0.16746302413779435, 0.17553336429664357, 0.17553336429664357, 0.17553336429664357, 0.012255131783629025, 0.012255131783629025, 0.012255131783629025, 0.0013098647565490396, 0.0013098647565490396, 0.0013098647565490396, 0.023040752900890027, 0.023040752900890027, 0.023040752900890027, 0.11457055133958316, 0.11457055133958316, 0.11457055133958316, 0.0940076865557603, 0.0940076865557603, 0.0940076865557603, 0.09363565386294381, 0.09363565386294381, 0.09363565386294381, 0.020561850796649517, 0.020561850796649517, 0.020561850796649517, 0.0360228029333417, 0.0360228029333417, 0.0360228029333417, 0.047103821693526116, 0.047103821693526116, 0.047103821693526116, 0.10623333754642517, 0.10623333754642517, 0.10623333754642517, 0.1438671398836039, 0.1438671398836039, 0.1438671398836039, 0.1594654596672912, 0.1594654596672912, 0.1594654596672912, 0.40860075142714836, 0.40860075142714836, 0.40860075142714836, 0.41669310898045175, 0.41669310898045175, 0.41669310898045175, 0.4296570097457978, 0.4296570097457978, 0.4296570097457978, 0.10197098562787765, 0.10197098562787765, 0.10197098562787765, 0.09203355502651234, 0.09203355502651234, 0.09203355502651234, 0.10574074403558698, 0.10574074403558698, 0.10574074403558698, 0.27303178211813717, 0.27303178211813717, 0.27303178211813717, 0.2584623325963654, 0.2584623325963654, 0.2584623325963654, 0.17890250431062682, 0.17890250431062682, 0.17890250431062682, 0.3077713817996188, 0.3077713817996188, 0.3077713817996188, 0.314456960633165, 0.314456960633165, 0.314456960633165, 0.32403274514720803, 0.32403274514720803, 0.32403274514720803, 0.18493958614088712, 0.18493958614088712, 0.18493958614088712, 0.2405370849100643, 0.2405370849100643, 0.2405370849100643, 0.25882874881128315, 0.25882874881128315, 0.25882874881128315, 0.2027797592497309, 0.2027797592497309, 0.2027797592497309, 0.2573028299779918, 0.2573028299779918, 0.2573028299779918, 0.24470594606214857, 0.24470594606214857, 0.24470594606214857, 0.17388482195021793, 0.17388482195021793, 0.17388482195021793, 0.17521107144237325, 0.17521107144237325, 0.17521107144237325, 0.18541569787733492, 0.18541569787733492, 0.18541569787733492, 0.6908731917251607, 0.6908731917251607, 0.6908731917251607, 0.6232780474586819, 0.6232780474586819, 0.6232780474586819, 0.17444725854507703, 0.17444725854507703, 0.17444725854507703, 0.5334461908275676, 0.5334461908275676, 0.5334461908275676, 0.21049065608284168, 0.21049065608284168, 0.21049065608284168, 0.6420075587077212, 0.6420075587077212, 0.6420075587077212, 0.19184328408565698, 0.19184328408565698, 0.19184328408565698, 0.1888235975034417, 0.1888235975034417, 0.1888235975034417, 0.18813085358043613, 0.18813085358043613, 0.18813085358043613, 0.07486409092081958, 0.07486409092081958, 0.07486409092081958, 0.08790565088202806, 0.08790565088202806, 0.08790565088202806, 0.1152925285883224, 0.1152925285883224, 0.1152925285883224]}, "mutation_prompt": null}
{"id": "75d3bbb9-92e2-4ceb-9ec1-86bb186fadbf", "solution": "import numpy as np\n\nclass AdaptiveDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted inertia factor\n        self.F = 0.85     # Adjusted DE scaling factor\n        self.CR = 0.9     # Adjusted DE crossover rate\n        self.rotational_diversity = 0.2  # Increased for diversity\n        self.mutation_probability = 0.2  # Increased mutation probability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound) / 2, abs(self.upper_bound - self.lower_bound) / 2, (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 3  # Cubic inertial decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < 0.5:  # Stochastic position update\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, trial_vector)\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveDynamicQuantumHybridPSO_DE", "description": "Adaptive Dynamic Quantum-Inspired Hybrid PSO-DE with Enhanced Exploration through Adaptive Velocity Scaling and Stochastic Position Updates.", "configspace": "", "generation": 30, "fitness": 0.16764905605965982, "feedback": "The algorithm AdaptiveDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.20.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.3370841900315187, 0.3370841900315187, 0.3370841900315187, 0.3586124059001744, 0.3586124059001744, 0.3586124059001744, 0.32319668674316204, 0.32319668674316204, 0.32319668674316204, 0.00761565204085668, 0.00761565204085668, 0.00761565204085668, 0.019986950247303348, 0.019986950247303348, 0.019986950247303348, 0.0013798803919109481, 0.0013798803919109481, 0.0013798803919109481, 0.07430781319047697, 0.07430781319047697, 0.07430781319047697, 0.06705972444417929, 0.06705972444417929, 0.06705972444417929, 0.08113284311730118, 0.08113284311730118, 0.08113284311730118, 0.06438075902266771, 0.06438075902266771, 0.06438075902266771, 0.07313607815574652, 0.07313607815574652, 0.07313607815574652, 0.09559624934059374, 0.09559624934059374, 0.09559624934059374, 0.9876097084544555, 0.9876097084544555, 0.9876097084544555, 0.9851930649394897, 0.9851930649394897, 0.9851930649394897, 0.9805797640486191, 0.9805797640486191, 0.9805797640486191, 0.1416955185716079, 0.1416955185716079, 0.1416955185716079, 0.12896769701036426, 0.12896769701036426, 0.12896769701036426, 0.15101081281467377, 0.15101081281467377, 0.15101081281467377, 0.14625606964851923, 0.14625606964851923, 0.14625606964851923, 0.19359624578170154, 0.19359624578170154, 0.19359624578170154, 0.15254963537315458, 0.15254963537315458, 0.15254963537315458, 0.10394934856876903, 0.10394934856876903, 0.10394934856876903, 0.0633111607428064, 0.0633111607428064, 0.0633111607428064, 0.09889319491339121, 0.09889319491339121, 0.09889319491339121, 0.04212907661278764, 0.04212907661278764, 0.04212907661278764, 0.09310950152348052, 0.09310950152348052, 0.09310950152348052, 0.021519049605087992, 0.021519049605087992, 0.021519049605087992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026211984170394498, 0.026211984170394498, 0.026211984170394498, 0.04865100239123843, 0.04865100239123843, 0.04865100239123843, 0.06843722266294794, 0.06843722266294794, 0.06843722266294794, 0.0018516748255084092, 0.0018516748255084092, 0.0018516748255084092, 0.0015270423067408334, 0.0015270423067408334, 0.0015270423067408334, 0.0030195571208252447, 0.0030195571208252447, 0.0030195571208252447, 0.04656439082811725, 0.04656439082811725, 0.04656439082811725, 0.05295088480493415, 0.05295088480493415, 0.05295088480493415, 0.02721018390413299, 0.02721018390413299, 0.02721018390413299, 0.31347165941767985, 0.31347165941767985, 0.31347165941767985, 0.26080128887889187, 0.26080128887889187, 0.26080128887889187, 0.30525717066558133, 0.30525717066558133, 0.30525717066558133, 0.07742733850437966, 0.07742733850437966, 0.07742733850437966, 0.07544758824739983, 0.07544758824739983, 0.07544758824739983, 0.06952550447675598, 0.06952550447675598, 0.06952550447675598, 0.1998708662809281, 0.1998708662809281, 0.1998708662809281, 0.18891234625075337, 0.18891234625075337, 0.18891234625075337, 0.15769053734234328, 0.15769053734234328, 0.15769053734234328, 0.19656308087950713, 0.19656308087950713, 0.19656308087950713, 0.2275007848923848, 0.2275007848923848, 0.2275007848923848, 0.22016478146737362, 0.22016478146737362, 0.22016478146737362, 0.15976572237321307, 0.15976572237321307, 0.15976572237321307, 0.1520330091659906, 0.1520330091659906, 0.1520330091659906, 0.11049885836288431, 0.11049885836288431, 0.11049885836288431, 0.16848052613682862, 0.16848052613682862, 0.16848052613682862, 0.17000579917688974, 0.17000579917688974, 0.17000579917688974, 0.18604194581886047, 0.18604194581886047, 0.18604194581886047, 0.17212102579037747, 0.17212102579037747, 0.17212102579037747, 0.17392364833905305, 0.17392364833905305, 0.17392364833905305, 0.15881915038168304, 0.15881915038168304, 0.15881915038168304, 0.4093723467886897, 0.4093723467886897, 0.4093723467886897, 0.23501025915739315, 0.23501025915739315, 0.23501025915739315, 0.2968583191866009, 0.2968583191866009, 0.2968583191866009, 0.23109068791095022, 0.23109068791095022, 0.23109068791095022, 0.18192936221121458, 0.18192936221121458, 0.18192936221121458, 0.16010502641418256, 0.16010502641418256, 0.16010502641418256, 0.1818083027079629, 0.1818083027079629, 0.1818083027079629, 0.17911176853015842, 0.17911176853015842, 0.17911176853015842, 0.18229205807065196, 0.18229205807065196, 0.18229205807065196, 0.06443491209325514, 0.06443491209325514, 0.06443491209325514, 0.07334877721069277, 0.07334877721069277, 0.07334877721069277, 0.060464558914356537, 0.060464558914356537, 0.060464558914356537]}, "mutation_prompt": null}
{"id": "b7601b4c-520e-413d-9c44-bba5a688d7f4", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_min = 0.2\n        self.w_max = 0.8\n        self.F = 0.9\n        self.CR = 0.9\n        self.diversity_factor = 0.2\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_min + (self.w_max - self.w_min) * np.exp(-5 * evaluations / self.budget)  # Exponential inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.diversity_factor * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumPSO", "description": "Adaptive Quantum-Inspired PSO with Dynamic Mutation Strategy and Exponential Decay for enhanced exploration-exploitation balance.", "configspace": "", "generation": 31, "fitness": 0.29331365640775436, "feedback": "The algorithm AdaptiveQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.8338023046545038, 0.8338023046545038, 0.8338023046545038, 0.8302549195039631, 0.8302549195039631, 0.8302549195039631, 0.8194384932607024, 0.8194384932607024, 0.8194384932607024, 0.6341587083036102, 0.6341587083036102, 0.6341587083036102, 0.6456539500831722, 0.6456539500831722, 0.6456539500831722, 0.6516125069505634, 0.6516125069505634, 0.6516125069505634, 0.1486040268544464, 0.1486040268544464, 0.1486040268544464, 0.14385361147803066, 0.14385361147803066, 0.14385361147803066, 0.13850663050862588, 0.13850663050862588, 0.13850663050862588, 0.10798360798711493, 0.10798360798711493, 0.10798360798711493, 0.13802443669396403, 0.13802443669396403, 0.13802443669396403, 0.12690348859520018, 0.12690348859520018, 0.12690348859520018, 0.984324073182402, 0.984324073182402, 0.984324073182402, 0.9854418951708774, 0.9854418951708774, 0.9854418951708774, 0.99171416121273, 0.99171416121273, 0.99171416121273, 0.6236853490193182, 0.6236853490193182, 0.6236853490193182, 0.3290716430688695, 0.3290716430688695, 0.3290716430688695, 0.5145123912105953, 0.5145123912105953, 0.5145123912105953, 0.35526375631118323, 0.35526375631118323, 0.35526375631118323, 0.20667664570564603, 0.20667664570564603, 0.20667664570564603, 0.11481764667306893, 0.11481764667306893, 0.11481764667306893, 0.23747694482866255, 0.23747694482866255, 0.23747694482866255, 0.12266957530710565, 0.12266957530710565, 0.12266957530710565, 0.16957878368409196, 0.16957878368409196, 0.16957878368409196, 0.06347178283821797, 0.06347178283821797, 0.06347178283821797, 0.13275738401963189, 0.13275738401963189, 0.13275738401963189, 0.10018246205582915, 0.10018246205582915, 0.10018246205582915, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04206959660454268, 0.04206959660454268, 0.04206959660454268, 0.0728589742712844, 0.0728589742712844, 0.0728589742712844, 0.06818963630868513, 0.06818963630868513, 0.06818963630868513, 0.04520032162262455, 0.04520032162262455, 0.04520032162262455, 0.07092930451090451, 0.07092930451090451, 0.07092930451090451, 0.09168730559844629, 0.09168730559844629, 0.09168730559844629, 0.010750034560525812, 0.010750034560525812, 0.010750034560525812, 0.042656607277195, 0.042656607277195, 0.042656607277195, 0.04613698642898634, 0.04613698642898634, 0.04613698642898634, 0.523701504792242, 0.523701504792242, 0.523701504792242, 0.5046555955238068, 0.5046555955238068, 0.5046555955238068, 0.5289105503072076, 0.5289105503072076, 0.5289105503072076, 0.0938784193526544, 0.0938784193526544, 0.0938784193526544, 0.08788672082113447, 0.08788672082113447, 0.08788672082113447, 0.14319870516564226, 0.14319870516564226, 0.14319870516564226, 0.200857476972084, 0.200857476972084, 0.200857476972084, 0.19110310007745446, 0.19110310007745446, 0.19110310007745446, 0.1606367005005761, 0.1606367005005761, 0.1606367005005761, 0.2269701314471595, 0.2269701314471595, 0.2269701314471595, 0.3871383101117831, 0.3871383101117831, 0.3871383101117831, 0.280708626672295, 0.280708626672295, 0.280708626672295, 0.14442003226673805, 0.14442003226673805, 0.14442003226673805, 0.23283636034573463, 0.23283636034573463, 0.23283636034573463, 0.17099282412608174, 0.17099282412608174, 0.17099282412608174, 0.18894113397420687, 0.18894113397420687, 0.18894113397420687, 0.2785687658321162, 0.2785687658321162, 0.2785687658321162, 0.2138813265410745, 0.2138813265410745, 0.2138813265410745, 0.2141201937783298, 0.2141201937783298, 0.2141201937783298, 0.2255830494383484, 0.2255830494383484, 0.2255830494383484, 0.19905734402657027, 0.19905734402657027, 0.19905734402657027, 0.8567275196872954, 0.8567275196872954, 0.8567275196872954, 0.18780725169985812, 0.18780725169985812, 0.18780725169985812, 0.28615296040951166, 0.28615296040951166, 0.28615296040951166, 0.7079153372493634, 0.7079153372493634, 0.7079153372493634, 0.7189731117282071, 0.7189731117282071, 0.7189731117282071, 0.6268959930871016, 0.6268959930871016, 0.6268959930871016, 0.18388730026013378, 0.18388730026013378, 0.18388730026013378, 0.2229275065733478, 0.2229275065733478, 0.2229275065733478, 0.19216375956496268, 0.19216375956496268, 0.19216375956496268, 0.10192800589145246, 0.10192800589145246, 0.10192800589145246, 0.07926117298297197, 0.07926117298297197, 0.07926117298297197, 0.1146765238055446, 0.1146765238055446, 0.1146765238055446]}, "mutation_prompt": null}
{"id": "07ce6c7f-bf53-49bc-bb73-204e1127fb66", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptivePSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.1  # Slightly decreased to broaden exploration\n        self.F = 0.9      # Increased to enhance differential variation\n        self.CR = 0.9     # Increased to allow more crossover\n        self.rotational_diversity = 0.2  # More clones for diverse mutation\n        self.mutation_probability = 0.2  # Increased for higher mutation rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.cos(evaluations / self.budget * np.pi / 2)  # Non-linear inertia scaling using cosine\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)  # Larger mutation pool\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "QuantumEnhancedAdaptivePSO_DE", "description": "Quantum-Enhanced Adaptive PSO-DE with Non-linear Velocity Scaling and Contextual Mutation for robust global search.", "configspace": "", "generation": 32, "fitness": 0.29159301830518963, "feedback": "The algorithm QuantumEnhancedAdaptivePSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.8692046600888905, 0.8692046600888905, 0.8692046600888905, 0.8730804540377854, 0.8730804540377854, 0.8730804540377854, 0.902022248154832, 0.902022248154832, 0.902022248154832, 0.8289126086303411, 0.8289126086303411, 0.8289126086303411, 0.7923237392157607, 0.7923237392157607, 0.7923237392157607, 0.568969076856144, 0.568969076856144, 0.568969076856144, 0.14257283259333542, 0.14257283259333542, 0.14257283259333542, 0.14314197244681293, 0.14314197244681293, 0.14314197244681293, 0.17937648135150863, 0.17937648135150863, 0.17937648135150863, 0.1596520209255734, 0.1596520209255734, 0.1596520209255734, 0.11608038592976733, 0.11608038592976733, 0.11608038592976733, 0.08943962759545376, 0.08943962759545376, 0.08943962759545376, 0.9803121044144792, 0.9803121044144792, 0.9803121044144792, 0.9719795832386876, 0.9719795832386876, 0.9719795832386876, 0.9687824250607442, 0.9687824250607442, 0.9687824250607442, 0.38343844657299564, 0.38343844657299564, 0.38343844657299564, 0.35925106711043997, 0.35925106711043997, 0.35925106711043997, 0.3538873518524409, 0.3538873518524409, 0.3538873518524409, 0.26035038104481345, 0.26035038104481345, 0.26035038104481345, 0.1923217387136913, 0.1923217387136913, 0.1923217387136913, 0.1980403795852841, 0.1980403795852841, 0.1980403795852841, 0.16415479819751377, 0.16415479819751377, 0.16415479819751377, 0.1655278827090595, 0.1655278827090595, 0.1655278827090595, 0.20784585328685512, 0.20784585328685512, 0.20784585328685512, 0.12333453209817868, 0.12333453209817868, 0.12333453209817868, 0.20867715548612764, 0.20867715548612764, 0.20867715548612764, 0.12982527497631013, 0.12982527497631013, 0.12982527497631013, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004439405152068532, 0.004439405152068532, 0.004439405152068532, 0.017399167688109785, 0.017399167688109785, 0.017399167688109785, 0.08045790462527525, 0.08045790462527525, 0.08045790462527525, 0.019365943926713758, 0.019365943926713758, 0.019365943926713758, 0.0760435749263535, 0.0760435749263535, 0.0760435749263535, 0.06508689339247775, 0.06508689339247775, 0.06508689339247775, 0.24541455898088815, 0.24541455898088815, 0.24541455898088815, 0.15048940986381198, 0.15048940986381198, 0.15048940986381198, 0.15062506338464476, 0.15062506338464476, 0.15062506338464476, 0.03913166695058512, 0.03913166695058512, 0.03913166695058512, 0.21418321981823762, 0.21418321981823762, 0.21418321981823762, 0.5539405621166319, 0.5539405621166319, 0.5539405621166319, 0.4929325266780664, 0.4929325266780664, 0.4929325266780664, 0.5466637666853418, 0.5466637666853418, 0.5466637666853418, 0.575606395438603, 0.575606395438603, 0.575606395438603, 0.08969344771659671, 0.08969344771659671, 0.08969344771659671, 0.06741569311296247, 0.06741569311296247, 0.06741569311296247, 0.13513427135504807, 0.13513427135504807, 0.13513427135504807, 0.1759186081240035, 0.1759186081240035, 0.1759186081240035, 0.15405450154907607, 0.15405450154907607, 0.15405450154907607, 0.34606717215709837, 0.34606717215709837, 0.34606717215709837, 0.29906198952676344, 0.29906198952676344, 0.29906198952676344, 0.2695072804584797, 0.2695072804584797, 0.2695072804584797, 0.16097735549883252, 0.16097735549883252, 0.16097735549883252, 0.2650946966733101, 0.2650946966733101, 0.2650946966733101, 0.12572626043564383, 0.12572626043564383, 0.12572626043564383, 0.20096723932257576, 0.20096723932257576, 0.20096723932257576, 0.2252383231296763, 0.2252383231296763, 0.2252383231296763, 0.24175353595602933, 0.24175353595602933, 0.24175353595602933, 0.32316694229594756, 0.32316694229594756, 0.32316694229594756, 0.20986382202866705, 0.20986382202866705, 0.20986382202866705, 0.24709498716143752, 0.24709498716143752, 0.24709498716143752, 0.8304222795053506, 0.8304222795053506, 0.8304222795053506, 0.15934972278097959, 0.15934972278097959, 0.15934972278097959, 0.1703892509105892, 0.1703892509105892, 0.1703892509105892, 0.3489075145130722, 0.3489075145130722, 0.3489075145130722, 0.2102834694839898, 0.2102834694839898, 0.2102834694839898, 0.2654407895161922, 0.2654407895161922, 0.2654407895161922, 0.2015004062988196, 0.2015004062988196, 0.2015004062988196, 0.19557147615796155, 0.19557147615796155, 0.19557147615796155, 0.21810300973699714, 0.21810300973699714, 0.21810300973699714, 0.09409014358460865, 0.09409014358460865, 0.09409014358460865, 0.07381720109693035, 0.07381720109693035, 0.07381720109693035, 0.12570078608437996, 0.12570078608437996, 0.12570078608437996]}, "mutation_prompt": null}
{"id": "a06d212c-a443-477b-a402-a6598a1d286b", "solution": "import numpy as np\n\nclass AdaptiveHybridQuantumPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 70\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.8\n        self.w_min = 0.4\n        self.F = 0.85\n        self.CR = 0.8\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.25\n        self.velocity_clamp_factor = 0.5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound) * self.velocity_clamp_factor,\n                                       abs(self.upper_bound - self.lower_bound) * self.velocity_clamp_factor,\n                                       (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.exp(-2 * evaluations / self.budget)  # Exponential inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            velocities = np.clip(velocities, -abs(self.upper_bound - self.lower_bound) * self.velocity_clamp_factor,\n                                 abs(self.upper_bound - self.lower_bound) * self.velocity_clamp_factor)\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveHybridQuantumPSO_DE", "description": "Adaptive Hybrid Quantum PSO-DE leveraging Anomalous Velocity Clamping for enhanced global exploration and local exploitation.", "configspace": "", "generation": 33, "fitness": 0.24247051056072844, "feedback": "The algorithm AdaptiveHybridQuantumPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.662742534585934, 0.662742534585934, 0.662742534585934, 0.6806544470264435, 0.6806544470264435, 0.6806544470264435, 0.7037850706081472, 0.7037850706081472, 0.7037850706081472, 0.08486204753645998, 0.08486204753645998, 0.08486204753645998, 0.15176789306583593, 0.15176789306583593, 0.15176789306583593, 0.014733358746986447, 0.014733358746986447, 0.014733358746986447, 0.13352460936244936, 0.13352460936244936, 0.13352460936244936, 0.12958895485835642, 0.12958895485835642, 0.12958895485835642, 0.13206297537315748, 0.13206297537315748, 0.13206297537315748, 0.11422964392051693, 0.11422964392051693, 0.11422964392051693, 0.10505604968891125, 0.10505604968891125, 0.10505604968891125, 0.16829423617788164, 0.16829423617788164, 0.16829423617788164, 0.9685156583858417, 0.9685156583858417, 0.9685156583858417, 0.9771900621660757, 0.9771900621660757, 0.9771900621660757, 0.9662427943692934, 0.9662427943692934, 0.9662427943692934, 0.36546779081753356, 0.36546779081753356, 0.36546779081753356, 0.2965661592298118, 0.2965661592298118, 0.2965661592298118, 0.3436298396374916, 0.3436298396374916, 0.3436298396374916, 0.2760492224796559, 0.2760492224796559, 0.2760492224796559, 0.21119293451378152, 0.21119293451378152, 0.21119293451378152, 0.34870132462801506, 0.34870132462801506, 0.34870132462801506, 0.1618398253599218, 0.1618398253599218, 0.1618398253599218, 0.12887552306071703, 0.12887552306071703, 0.12887552306071703, 0.17159311567220903, 0.17159311567220903, 0.17159311567220903, 0.12786154687942253, 0.12786154687942253, 0.12786154687942253, 0.1295196625784576, 0.1295196625784576, 0.1295196625784576, 0.15885022859147446, 0.15885022859147446, 0.15885022859147446, 0.0427389007536243, 0.0427389007536243, 0.0427389007536243, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0458618842591304, 0.0458618842591304, 0.0458618842591304, 0.11743641749030997, 0.11743641749030997, 0.11743641749030997, 0.013325077211862713, 0.013325077211862713, 0.013325077211862713, 0.0782851535880058, 0.0782851535880058, 0.0782851535880058, 0.03818077105290463, 0.03818077105290463, 0.03818077105290463, 0.1321431824313346, 0.1321431824313346, 0.1321431824313346, 0.08428707617512465, 0.08428707617512465, 0.08428707617512465, 0.11491052909206267, 0.11491052909206267, 0.11491052909206267, 0.10596495640951309, 0.10596495640951309, 0.10596495640951309, 0.05250854720308451, 0.05250854720308451, 0.05250854720308451, 0.46882737553173237, 0.46882737553173237, 0.46882737553173237, 0.4814587022024923, 0.4814587022024923, 0.4814587022024923, 0.46060099222719597, 0.46060099222719597, 0.46060099222719597, 0.0776606665181182, 0.0776606665181182, 0.0776606665181182, 0.1524729951985131, 0.1524729951985131, 0.1524729951985131, 0.09253025652278646, 0.09253025652278646, 0.09253025652278646, 0.1555503639838378, 0.1555503639838378, 0.1555503639838378, 0.21085548524630715, 0.21085548524630715, 0.21085548524630715, 0.12850750722500348, 0.12850750722500348, 0.12850750722500348, 0.2183998205813923, 0.2183998205813923, 0.2183998205813923, 0.2776699143055119, 0.2776699143055119, 0.2776699143055119, 0.3692556216949373, 0.3692556216949373, 0.3692556216949373, 0.24534078150904715, 0.24534078150904715, 0.24534078150904715, 0.2270639591880812, 0.2270639591880812, 0.2270639591880812, 0.19244447715974622, 0.19244447715974622, 0.19244447715974622, 0.22964863375616706, 0.22964863375616706, 0.22964863375616706, 0.30800958989176164, 0.30800958989176164, 0.30800958989176164, 0.18462911731547293, 0.18462911731547293, 0.18462911731547293, 0.20005628562865263, 0.20005628562865263, 0.20005628562865263, 0.18560132213288139, 0.18560132213288139, 0.18560132213288139, 0.19587650318513283, 0.19587650318513283, 0.19587650318513283, 0.8656033686323185, 0.8656033686323185, 0.8656033686323185, 0.1574330832079297, 0.1574330832079297, 0.1574330832079297, 0.15274129802222247, 0.15274129802222247, 0.15274129802222247, 0.3089298579022254, 0.3089298579022254, 0.3089298579022254, 0.211003327146414, 0.211003327146414, 0.211003327146414, 0.34171411495482285, 0.34171411495482285, 0.34171411495482285, 0.17808555943039317, 0.17808555943039317, 0.17808555943039317, 0.1749671176436861, 0.1749671176436861, 0.1749671176436861, 0.1808540889085707, 0.1808540889085707, 0.1808540889085707, 0.08717750093476295, 0.08717750093476295, 0.08717750093476295, 0.08699281424975125, 0.08699281424975125, 0.08699281424975125, 0.11077425334683844, 0.11077425334683844, 0.11077425334683844]}, "mutation_prompt": null}
{"id": "7df2d93c-e826-4c77-93d4-6ff2b1a43d90", "solution": "import numpy as np\n\nclass AdaptiveMultiSwarmPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.8\n        self.CR = 0.75\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * evaluations / self.budget  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            \n            local_positions = np.copy(positions)\n            for i in range(self.population_size):\n                local_positions[i] = np.mean(positions[max(0, i-5):min(self.population_size, i+5)], axis=0)\n            positions = np.clip(local_positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(0.2 * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveMultiSwarmPSO_DE", "description": "Adaptive Multi-Swarm PSO with Differential Evolution and Stochastic Inertia for enhanced exploration-exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.16455283904016688, "feedback": "The algorithm AdaptiveMultiSwarmPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.2982570606842895, 0.2982570606842895, 0.2982570606842895, 0.3317096943770994, 0.3317096943770994, 0.3317096943770994, 0.2909192075636964, 0.2909192075636964, 0.2909192075636964, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08353607780432826, 0.08353607780432826, 0.08353607780432826, 0.07222801836970427, 0.07222801836970427, 0.07222801836970427, 0.08627768370956435, 0.08627768370956435, 0.08627768370956435, 0.08392653468792488, 0.08392653468792488, 0.08392653468792488, 0.06392227727959343, 0.06392227727959343, 0.06392227727959343, 0.07118486751284059, 0.07118486751284059, 0.07118486751284059, 0.9853556290651062, 0.9853556290651062, 0.9853556290651062, 0.9913882558416658, 0.9913882558416658, 0.9913882558416658, 0.9794534262071488, 0.9794534262071488, 0.9794534262071488, 0.14371148500584063, 0.14371148500584063, 0.14371148500584063, 0.14073167651194884, 0.14073167651194884, 0.14073167651194884, 0.15872470114078951, 0.15872470114078951, 0.15872470114078951, 0.19239407366652983, 0.19239407366652983, 0.19239407366652983, 0.1571337547131456, 0.1571337547131456, 0.1571337547131456, 0.1641472880866771, 0.1641472880866771, 0.1641472880866771, 0.09370549930972283, 0.09370549930972283, 0.09370549930972283, 0.10251897208686045, 0.10251897208686045, 0.10251897208686045, 0.11604529624316728, 0.11604529624316728, 0.11604529624316728, 0.07271127901810703, 0.07271127901810703, 0.07271127901810703, 0.0767462422275883, 0.0767462422275883, 0.0767462422275883, 0.025449672460844286, 0.025449672460844286, 0.025449672460844286, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03989130924760809, 0.03989130924760809, 0.03989130924760809, 0.01065779121378252, 0.01065779121378252, 0.01065779121378252, 0.04553913335431303, 0.04553913335431303, 0.04553913335431303, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00307875713465533, 0.00307875713465533, 0.00307875713465533, 0.05406038328403606, 0.05406038328403606, 0.05406038328403606, 0.03792025049915371, 0.03792025049915371, 0.03792025049915371, 0.26576203201357407, 0.26576203201357407, 0.26576203201357407, 0.3024508265003496, 0.3024508265003496, 0.3024508265003496, 0.29533734258749555, 0.29533734258749555, 0.29533734258749555, 0.07842571421050992, 0.07842571421050992, 0.07842571421050992, 0.07663679310739258, 0.07663679310739258, 0.07663679310739258, 0.0712752097243412, 0.0712752097243412, 0.0712752097243412, 0.14455507614920804, 0.14455507614920804, 0.14455507614920804, 0.2345594170885853, 0.2345594170885853, 0.2345594170885853, 0.13973682676330268, 0.13973682676330268, 0.13973682676330268, 0.20262869008527373, 0.20262869008527373, 0.20262869008527373, 0.21867556349854622, 0.21867556349854622, 0.21867556349854622, 0.21589928007919157, 0.21589928007919157, 0.21589928007919157, 0.11414139587967931, 0.11414139587967931, 0.11414139587967931, 0.14925115468975725, 0.14925115468975725, 0.14925115468975725, 0.12328094443033621, 0.12328094443033621, 0.12328094443033621, 0.19492941403049668, 0.19492941403049668, 0.19492941403049668, 0.19859602105482277, 0.19859602105482277, 0.19859602105482277, 0.1979989563632094, 0.1979989563632094, 0.1979989563632094, 0.18153720719934408, 0.18153720719934408, 0.18153720719934408, 0.16984165338098078, 0.16984165338098078, 0.16984165338098078, 0.16181418512133916, 0.16181418512133916, 0.16181418512133916, 0.3906738365711694, 0.3906738365711694, 0.3906738365711694, 0.16112224650361318, 0.16112224650361318, 0.16112224650361318, 0.12758259453622667, 0.12758259453622667, 0.12758259453622667, 0.3114143087521132, 0.3114143087521132, 0.3114143087521132, 0.18965864144094302, 0.18965864144094302, 0.18965864144094302, 0.14994642688525361, 0.14994642688525361, 0.14994642688525361, 0.18069632812237868, 0.18069632812237868, 0.18069632812237868, 0.18604270847194715, 0.18604270847194715, 0.18604270847194715, 0.19341690018487467, 0.19341690018487467, 0.19341690018487467, 0.0776415376316254, 0.0776415376316254, 0.0776415376316254, 0.07262845420481068, 0.07262845420481068, 0.07262845420481068, 0.09542042532159178, 0.09542042532159178, 0.09542042532159178]}, "mutation_prompt": null}
{"id": "eb27421f-e74f-4895-95e5-edb8ca993f49", "solution": "import numpy as np\n\nclass AdaptiveHybridPSO_DE_Crossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 0.5  # Adaptive inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            crossover_count = int(self.rotational_diversity * self.population_size)\n            for i in range(crossover_count):\n                if evaluations >= self.budget:\n                    break\n                sub_pop_indices = np.random.choice(self.population_size, size=4, replace=False)\n                a, b, c, d = sub_pop_indices\n                if np.random.rand() < self.CR:\n                    trial_vector = np.clip(positions[a] + self.F * (positions[b] - positions[c]), self.lower_bound, self.upper_bound)\n                else:\n                    trial_vector = positions[d]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.15 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveHybridPSO_DE_Crossover", "description": "Adaptive Particle Swarm Optimization with Differential Evolution and Randomized Sub-population Crossover for enhanced solution diversity and convergence.", "configspace": "", "generation": 35, "fitness": 0.25454119704464623, "feedback": "The algorithm AdaptiveHybridPSO_DE_Crossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.7482652457203305, 0.7482652457203305, 0.7482652457203305, 0.7507632931648958, 0.7507632931648958, 0.7507632931648958, 0.6830555446725899, 0.6830555446725899, 0.6830555446725899, 0.06533284653703653, 0.06533284653703653, 0.06533284653703653, 0.2905880317106254, 0.2905880317106254, 0.2905880317106254, 0.3928385815767965, 0.3928385815767965, 0.3928385815767965, 0.13576261541319778, 0.13576261541319778, 0.13576261541319778, 0.07239907277706314, 0.07239907277706314, 0.07239907277706314, 0.527329171525668, 0.527329171525668, 0.527329171525668, 0.13509783403351916, 0.13509783403351916, 0.13509783403351916, 0.12359659665867717, 0.12359659665867717, 0.12359659665867717, 0.12001633482654339, 0.12001633482654339, 0.12001633482654339, 0.9842872480155801, 0.9842872480155801, 0.9842872480155801, 0.9853080682659892, 0.9853080682659892, 0.9853080682659892, 0.9920172168829365, 0.9920172168829365, 0.9920172168829365, 0.34912160666336745, 0.34912160666336745, 0.34912160666336745, 0.46877939011329817, 0.46877939011329817, 0.46877939011329817, 0.43195021055052807, 0.43195021055052807, 0.43195021055052807, 0.1911069501071423, 0.1911069501071423, 0.1911069501071423, 0.1567864693329769, 0.1567864693329769, 0.1567864693329769, 0.13128470628698574, 0.13128470628698574, 0.13128470628698574, 0.17401861512931105, 0.17401861512931105, 0.17401861512931105, 0.11731943083355911, 0.11731943083355911, 0.11731943083355911, 0.16265560125312173, 0.16265560125312173, 0.16265560125312173, 0.1471738579703311, 0.1471738579703311, 0.1471738579703311, 0.09201799066095606, 0.09201799066095606, 0.09201799066095606, 0.08650513248866376, 0.08650513248866376, 0.08650513248866376, 0.0021057269227542363, 0.0021057269227542363, 0.0021057269227542363, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052988105123987994, 0.052988105123987994, 0.052988105123987994, 0.057747083801302, 0.057747083801302, 0.057747083801302, 0.0033551561478670777, 0.0033551561478670777, 0.0033551561478670777, 0.052591159447248126, 0.052591159447248126, 0.052591159447248126, 0.03963746546648239, 0.03963746546648239, 0.03963746546648239, 0.06325823734937153, 0.06325823734937153, 0.06325823734937153, 0.055651835767893454, 0.055651835767893454, 0.055651835767893454, 0.009937410882615239, 0.009937410882615239, 0.009937410882615239, 0.03832407339948607, 0.03832407339948607, 0.03832407339948607, 0.08114228838852777, 0.08114228838852777, 0.08114228838852777, 0.4839978024292504, 0.4839978024292504, 0.4839978024292504, 0.42844574254377854, 0.42844574254377854, 0.42844574254377854, 0.49044355502426096, 0.49044355502426096, 0.49044355502426096, 0.08737855221265112, 0.08737855221265112, 0.08737855221265112, 0.08454616234502466, 0.08454616234502466, 0.08454616234502466, 0.12060925895461938, 0.12060925895461938, 0.12060925895461938, 0.1741584905046517, 0.1741584905046517, 0.1741584905046517, 0.1687981928853245, 0.1687981928853245, 0.1687981928853245, 0.24355709307051598, 0.24355709307051598, 0.24355709307051598, 0.35527220469763965, 0.35527220469763965, 0.35527220469763965, 0.1971216950052348, 0.1971216950052348, 0.1971216950052348, 0.2082041039126038, 0.2082041039126038, 0.2082041039126038, 0.16202215166170064, 0.16202215166170064, 0.16202215166170064, 0.2412488150015606, 0.2412488150015606, 0.2412488150015606, 0.22153425590991616, 0.22153425590991616, 0.22153425590991616, 0.21590888346273063, 0.21590888346273063, 0.21590888346273063, 0.19751555390335462, 0.19751555390335462, 0.19751555390335462, 0.20636404655975815, 0.20636404655975815, 0.20636404655975815, 0.1801085282394672, 0.1801085282394672, 0.1801085282394672, 0.22720253272468482, 0.22720253272468482, 0.22720253272468482, 0.20753792292395412, 0.20753792292395412, 0.20753792292395412, 0.8080282567548092, 0.8080282567548092, 0.8080282567548092, 0.17181620040135004, 0.17181620040135004, 0.17181620040135004, 0.8094869446450277, 0.8094869446450277, 0.8094869446450277, 0.32088729156488593, 0.32088729156488593, 0.32088729156488593, 0.2049936583962355, 0.2049936583962355, 0.2049936583962355, 0.28130995613645104, 0.28130995613645104, 0.28130995613645104, 0.19339247852901376, 0.19339247852901376, 0.19339247852901376, 0.18971728389478437, 0.18971728389478437, 0.18971728389478437, 0.1817857568744795, 0.1817857568744795, 0.1817857568744795, 0.08172745342881538, 0.08172745342881538, 0.08172745342881538, 0.08038501675860021, 0.08038501675860021, 0.08038501675860021, 0.12924413998816764, 0.12924413998816764, 0.12924413998816764]}, "mutation_prompt": null}
{"id": "aaff26ec-aeda-4c69-ba3c-7cffa90e83c1", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.1  # Adjusted for more dynamic range\n        self.F = 0.8\n        self.CR = 0.9  # Increased crossover rate for better exploration\n        self.rotational_diversity = 0.2  # Increased for more diversity\n        self.mutation_probability = 0.1  # Reduced to focus more on crossover\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - (evaluations / self.budget) ** 0.5)  # Adjusted inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.15 * self.population_size), replace=False)  # Less frequent mutation\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridEA", "description": "Adaptive Quantum-Inspired Hybrid Evolutionary Algorithm with Non-linear Inertia and Self-Adaptive Control for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 36, "fitness": 0.3042181137365957, "feedback": "The algorithm AdaptiveQuantumHybridEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.9061523381123799, 0.9061523381123799, 0.9061523381123799, 0.909105100230996, 0.909105100230996, 0.909105100230996, 0.9074528106185485, 0.9074528106185485, 0.9074528106185485, 0.7129969651120859, 0.7129969651120859, 0.7129969651120859, 0.7247618958010138, 0.7247618958010138, 0.7247618958010138, 0.7513075218663846, 0.7513075218663846, 0.7513075218663846, 0.1583998244996666, 0.1583998244996666, 0.1583998244996666, 0.11761128066170878, 0.11761128066170878, 0.11761128066170878, 0.17572100886372832, 0.17572100886372832, 0.17572100886372832, 0.1491309836798389, 0.1491309836798389, 0.1491309836798389, 0.14940376234245945, 0.14940376234245945, 0.14940376234245945, 0.11523669277815007, 0.11523669277815007, 0.11523669277815007, 0.980166683914188, 0.980166683914188, 0.980166683914188, 0.9680410115800259, 0.9680410115800259, 0.9680410115800259, 0.9689483994461946, 0.9689483994461946, 0.9689483994461946, 0.5437401801425438, 0.5437401801425438, 0.5437401801425438, 0.6869632151991041, 0.6869632151991041, 0.6869632151991041, 0.6574524574307967, 0.6574524574307967, 0.6574524574307967, 0.2274153964985901, 0.2274153964985901, 0.2274153964985901, 0.2101231908233656, 0.2101231908233656, 0.2101231908233656, 0.155179490427113, 0.155179490427113, 0.155179490427113, 0.17135743987466634, 0.17135743987466634, 0.17135743987466634, 0.12953896604514414, 0.12953896604514414, 0.12953896604514414, 0.29379440106761034, 0.29379440106761034, 0.29379440106761034, 0.06632118484607419, 0.06632118484607419, 0.06632118484607419, 0.17413783500292734, 0.17413783500292734, 0.17413783500292734, 0.25563335244318586, 0.25563335244318586, 0.25563335244318586, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040455468430085184, 0.040455468430085184, 0.040455468430085184, 0.0032207818005889344, 0.0032207818005889344, 0.0032207818005889344, 0.05708607560768919, 0.05708607560768919, 0.05708607560768919, 0.03240979307140257, 0.03240979307140257, 0.03240979307140257, 0.0880262532774655, 0.0880262532774655, 0.0880262532774655, 0.051816020307127064, 0.051816020307127064, 0.051816020307127064, 0.1340907729790759, 0.1340907729790759, 0.1340907729790759, 0.15097789953775442, 0.15097789953775442, 0.15097789953775442, 0.1921623488821982, 0.1921623488821982, 0.1921623488821982, 0.039385749002383674, 0.039385749002383674, 0.039385749002383674, 0.12574786043848396, 0.12574786043848396, 0.12574786043848396, 0.5322931667751263, 0.5322931667751263, 0.5322931667751263, 0.5416114645577955, 0.5416114645577955, 0.5416114645577955, 0.5472815298147813, 0.5472815298147813, 0.5472815298147813, 0.18375858882833085, 0.18375858882833085, 0.18375858882833085, 0.09966540665107282, 0.09966540665107282, 0.09966540665107282, 0.14525924775809163, 0.14525924775809163, 0.14525924775809163, 0.21765549252164007, 0.21765549252164007, 0.21765549252164007, 0.3946931970470746, 0.3946931970470746, 0.3946931970470746, 0.2150578332155273, 0.2150578332155273, 0.2150578332155273, 0.4118775527045755, 0.4118775527045755, 0.4118775527045755, 0.3958217680027808, 0.3958217680027808, 0.3958217680027808, 0.2899946536820165, 0.2899946536820165, 0.2899946536820165, 0.21856550791223872, 0.21856550791223872, 0.21856550791223872, 0.2519504192832195, 0.2519504192832195, 0.2519504192832195, 0.13002591360992044, 0.13002591360992044, 0.13002591360992044, 0.20028878732515043, 0.20028878732515043, 0.20028878732515043, 0.22606623722887154, 0.22606623722887154, 0.22606623722887154, 0.21904659703488538, 0.21904659703488538, 0.21904659703488538, 0.2401303374067596, 0.2401303374067596, 0.2401303374067596, 0.18564753245782317, 0.18564753245782317, 0.18564753245782317, 0.2096698546260457, 0.2096698546260457, 0.2096698546260457, 0.9334649636112622, 0.9334649636112622, 0.9334649636112622, 0.159085607963949, 0.159085607963949, 0.159085607963949, 0.1703816288263209, 0.1703816288263209, 0.1703816288263209, 0.36124420055002593, 0.36124420055002593, 0.36124420055002593, 0.21122170536664253, 0.21122170536664253, 0.21122170536664253, 0.1566254863986849, 0.1566254863986849, 0.1566254863986849, 0.17600785244063666, 0.17600785244063666, 0.17600785244063666, 0.22818455756512213, 0.22818455756512213, 0.22818455756512213, 0.21560765234513513, 0.21560765234513513, 0.21560765234513513, 0.08816825538000705, 0.08816825538000705, 0.08816825538000705, 0.07236097963143695, 0.07236097963143695, 0.07236097963143695, 0.09341779786919435, 0.09341779786919435, 0.09341779786919435]}, "mutation_prompt": null}
{"id": "2835b2b4-140f-44b2-bcd5-235e0b376321", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 0.5  # Adaptive inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.15 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Probability-Based Mutation and Non-Linear Inertia Decay for enhanced convergence efficiency.", "configspace": "", "generation": 37, "fitness": 0.24242021932264807, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.24.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.6978560739256762, 0.6978560739256762, 0.6978560739256762, 0.6754732963628627, 0.6754732963628627, 0.6754732963628627, 0.6924690204275998, 0.6924690204275998, 0.6924690204275998, 0.09434386923927562, 0.09434386923927562, 0.09434386923927562, 0.15999500260840382, 0.15999500260840382, 0.15999500260840382, 0.04435505886124158, 0.04435505886124158, 0.04435505886124158, 0.10468893337193896, 0.10468893337193896, 0.10468893337193896, 0.14989274154593912, 0.14989274154593912, 0.14989274154593912, 0.12295991960435881, 0.12295991960435881, 0.12295991960435881, 0.13252391528056884, 0.13252391528056884, 0.13252391528056884, 0.11107470583030987, 0.11107470583030987, 0.11107470583030987, 0.08906328599038604, 0.08906328599038604, 0.08906328599038604, 0.9839907126462788, 0.9839907126462788, 0.9839907126462788, 0.9852770374783044, 0.9852770374783044, 0.9852770374783044, 0.9912075046513658, 0.9912075046513658, 0.9912075046513658, 0.33279749835694816, 0.33279749835694816, 0.33279749835694816, 0.1443866002115889, 0.1443866002115889, 0.1443866002115889, 0.3517048399862013, 0.3517048399862013, 0.3517048399862013, 0.2086561979516649, 0.2086561979516649, 0.2086561979516649, 0.18090428491584476, 0.18090428491584476, 0.18090428491584476, 0.1645593760405012, 0.1645593760405012, 0.1645593760405012, 0.17056881428089132, 0.17056881428089132, 0.17056881428089132, 0.11246430274495356, 0.11246430274495356, 0.11246430274495356, 0.09926989548007181, 0.09926989548007181, 0.09926989548007181, 0.127365159653411, 0.127365159653411, 0.127365159653411, 0.22696209710016912, 0.22696209710016912, 0.22696209710016912, 0.15523480268659895, 0.15523480268659895, 0.15523480268659895, 0.004089126844342039, 0.004089126844342039, 0.004089126844342039, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0025374370159585435, 0.0025374370159585435, 0.0025374370159585435, 0.05930099641145803, 0.05930099641145803, 0.05930099641145803, 0.004331526370779604, 0.004331526370779604, 0.004331526370779604, 0.04437965883091188, 0.04437965883091188, 0.04437965883091188, 0.09541522431222571, 0.09541522431222571, 0.09541522431222571, 0.0663119501465319, 0.0663119501465319, 0.0663119501465319, 0.0725207162914423, 0.0725207162914423, 0.0725207162914423, 0.009968370960886763, 0.009968370960886763, 0.009968370960886763, 0.00545988778822426, 0.00545988778822426, 0.00545988778822426, 0.04487509428479752, 0.04487509428479752, 0.04487509428479752, 0.46294509259992456, 0.46294509259992456, 0.46294509259992456, 0.482394283751427, 0.482394283751427, 0.482394283751427, 0.4545599060258373, 0.4545599060258373, 0.4545599060258373, 0.0783305799128653, 0.0783305799128653, 0.0783305799128653, 0.09660501428494661, 0.09660501428494661, 0.09660501428494661, 0.13735442771866635, 0.13735442771866635, 0.13735442771866635, 0.22239581720962232, 0.22239581720962232, 0.22239581720962232, 0.15822570906132827, 0.15822570906132827, 0.15822570906132827, 0.20495334076695737, 0.20495334076695737, 0.20495334076695737, 0.23887783632245496, 0.23887783632245496, 0.23887783632245496, 0.3293630201200536, 0.3293630201200536, 0.3293630201200536, 0.3124200821167843, 0.3124200821167843, 0.3124200821167843, 0.11921562956018006, 0.11921562956018006, 0.11921562956018006, 0.22530620126660506, 0.22530620126660506, 0.22530620126660506, 0.1975307798877981, 0.1975307798877981, 0.1975307798877981, 0.1733701346635811, 0.1733701346635811, 0.1733701346635811, 0.191463018879528, 0.191463018879528, 0.191463018879528, 0.1869055564405524, 0.1869055564405524, 0.1869055564405524, 0.1920444087569263, 0.1920444087569263, 0.1920444087569263, 0.1833509557133295, 0.1833509557133295, 0.1833509557133295, 0.17452683582813044, 0.17452683582813044, 0.17452683582813044, 0.8158640979855709, 0.8158640979855709, 0.8158640979855709, 0.8049938553934426, 0.8049938553934426, 0.8049938553934426, 0.2843521718110634, 0.2843521718110634, 0.2843521718110634, 0.41404090530363846, 0.41404090530363846, 0.41404090530363846, 0.20433483726133705, 0.20433483726133705, 0.20433483726133705, 0.5971169047732523, 0.5971169047732523, 0.5971169047732523, 0.18576985154069925, 0.18576985154069925, 0.18576985154069925, 0.18778877293704876, 0.18778877293704876, 0.18778877293704876, 0.17206183222922078, 0.17206183222922078, 0.17206183222922078, 0.09100969705825868, 0.09100969705825868, 0.09100969705825868, 0.07317210704005483, 0.07317210704005483, 0.07317210704005483, 0.08227719051865856, 0.08227719051865856, 0.08227719051865856]}, "mutation_prompt": null}
{"id": "e4baa18c-54bc-4184-ab8d-8829c9d7e7be", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.9\n        self.CR = 0.9\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n        num_swarms = 3  # Divide population into multiple swarms\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n            \n            # Implement multi-swarm interaction\n            for swarm_id in range(num_swarms):\n                swarm_indices = range(swarm_id * (self.population_size // num_swarms), (swarm_id + 1) * (self.population_size // num_swarms))\n                g_best_swarm_position = min(swarm_indices, key=lambda idx: p_best_scores[idx])\n                for i in swarm_indices:\n                    if evaluations >= self.budget:\n                        break\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = np.random.choice(idxs, 3, replace=False)\n                    mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                    trial_vector = np.copy(positions[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR:\n                            trial_vector[j] = mutant_vector[j]\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < p_best_scores[i]:\n                        p_best_scores[i] = trial_score\n                        positions[i] = trial_vector\n                        if trial_score < g_best_score:\n                            g_best_score = trial_score\n                            g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDynamicQuantumHybridPSO_DE", "description": "Enhanced Dynamic Quantum-Inspired Hybrid PSO-DE with Adaptive Learning and Multi-swarm Strategy for improved exploration and exploitation.", "configspace": "", "generation": 38, "fitness": 0.17057592460717833, "feedback": "The algorithm EnhancedDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.20.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.3364789432578029, 0.3364789432578029, 0.3364789432578029, 0.3384160033003403, 0.3384160033003403, 0.3384160033003403, 0.35018312059742907, 0.35018312059742907, 0.35018312059742907, 0.010433398348747125, 0.010433398348747125, 0.010433398348747125, 0.013734305564861438, 0.013734305564861438, 0.013734305564861438, 0.006141410944272452, 0.006141410944272452, 0.006141410944272452, 0.08076442683209295, 0.08076442683209295, 0.08076442683209295, 0.07183913185309099, 0.07183913185309099, 0.07183913185309099, 0.08113563090883802, 0.08113563090883802, 0.08113563090883802, 0.059618588977844, 0.059618588977844, 0.059618588977844, 0.07031828846792265, 0.07031828846792265, 0.07031828846792265, 0.06895221228848947, 0.06895221228848947, 0.06895221228848947, 0.9769998015621096, 0.9769998015621096, 0.9769998015621096, 0.9893122454055814, 0.9893122454055814, 0.9893122454055814, 0.9806948418881456, 0.9806948418881456, 0.9806948418881456, 0.18003646065410173, 0.18003646065410173, 0.18003646065410173, 0.1306571327713607, 0.1306571327713607, 0.1306571327713607, 0.16257646020488392, 0.16257646020488392, 0.16257646020488392, 0.19484641883712928, 0.19484641883712928, 0.19484641883712928, 0.15263031743988487, 0.15263031743988487, 0.15263031743988487, 0.12952512688777096, 0.12952512688777096, 0.12952512688777096, 0.10050821124534504, 0.10050821124534504, 0.10050821124534504, 0.08041361706433803, 0.08041361706433803, 0.08041361706433803, 0.10546047370955436, 0.10546047370955436, 0.10546047370955436, 0.05155041943371874, 0.05155041943371874, 0.05155041943371874, 0.08014911607571762, 0.08014911607571762, 0.08014911607571762, 0.0260899041884175, 0.0260899041884175, 0.0260899041884175, 0.00407208641435286, 0.00407208641435286, 0.00407208641435286, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012603627963450048, 0.0012603627963450048, 0.0012603627963450048, 0.05730996367642782, 0.05730996367642782, 0.05730996367642782, 0.014148015412126402, 0.014148015412126402, 0.014148015412126402, 0.03706111976577231, 0.03706111976577231, 0.03706111976577231, 0.007636968247483722, 0.007636968247483722, 0.007636968247483722, 0.003594361385820255, 0.003594361385820255, 0.003594361385820255, 0.010649274203890169, 0.010649274203890169, 0.010649274203890169, 0.0035048830993293922, 0.0035048830993293922, 0.0035048830993293922, 0.06384979222535803, 0.06384979222535803, 0.06384979222535803, 0.035803289469083066, 0.035803289469083066, 0.035803289469083066, 0.3518166150682971, 0.3518166150682971, 0.3518166150682971, 0.32105181151601603, 0.32105181151601603, 0.32105181151601603, 0.35752126833864273, 0.35752126833864273, 0.35752126833864273, 0.05058926000182873, 0.05058926000182873, 0.05058926000182873, 0.07285500546340662, 0.07285500546340662, 0.07285500546340662, 0.054695436820744514, 0.054695436820744514, 0.054695436820744514, 0.1448596122159148, 0.1448596122159148, 0.1448596122159148, 0.14543991395732225, 0.14543991395732225, 0.14543991395732225, 0.15715535548132264, 0.15715535548132264, 0.15715535548132264, 0.214242206740915, 0.214242206740915, 0.214242206740915, 0.21685132675386753, 0.21685132675386753, 0.21685132675386753, 0.2710046410444632, 0.2710046410444632, 0.2710046410444632, 0.17166628507479542, 0.17166628507479542, 0.17166628507479542, 0.14103419278108065, 0.14103419278108065, 0.14103419278108065, 0.17339303075718404, 0.17339303075718404, 0.17339303075718404, 0.169141834494831, 0.169141834494831, 0.169141834494831, 0.1847001287987583, 0.1847001287987583, 0.1847001287987583, 0.16368648266604158, 0.16368648266604158, 0.16368648266604158, 0.1676048298683923, 0.1676048298683923, 0.1676048298683923, 0.1726068275325746, 0.1726068275325746, 0.1726068275325746, 0.16383758012734728, 0.16383758012734728, 0.16383758012734728, 0.43596536623529814, 0.43596536623529814, 0.43596536623529814, 0.3782044942819691, 0.3782044942819691, 0.3782044942819691, 0.1351785996636221, 0.1351785996636221, 0.1351785996636221, 0.17124430505116672, 0.17124430505116672, 0.17124430505116672, 0.18828885146146235, 0.18828885146146235, 0.18828885146146235, 0.28774448297391664, 0.28774448297391664, 0.28774448297391664, 0.1760431683657363, 0.1760431683657363, 0.1760431683657363, 0.17775231734977204, 0.17775231734977204, 0.17775231734977204, 0.18659935196791366, 0.18659935196791366, 0.18659935196791366, 0.06916014771607337, 0.06916014771607337, 0.06916014771607337, 0.06360403021588157, 0.06360403021588157, 0.06360403021588157, 0.0774716855245029, 0.0774716855245029, 0.0774716855245029]}, "mutation_prompt": null}
{"id": "1d7d7bb5-66e9-4b4a-9aba-90960dda036c", "solution": "import numpy as np\n\nclass AdaptiveCognitiveBehavioralQuantumPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c2_initial = 0.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.7\n        self.CR = 0.9\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.25\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 0.5  # Square-root inertia decay\n            c1 = self.c1_initial - (self.c1_initial - 1.5) * (evaluations / self.budget)  # Dynamic cognitive factor\n            c2 = self.c2_initial + (2.5 - self.c2_initial) * (evaluations / self.budget)  # Dynamic social factor\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + c1 * r1 * (p_best_positions - positions) \n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveCognitiveBehavioralQuantumPSO_DE", "description": "Adaptive Cognitive-Behavioral Quantum-Inspired PSO with Differential Evolution leveraging self-organized learning and mutation diversity.", "configspace": "", "generation": 39, "fitness": 0.22398268767910334, "feedback": "The algorithm AdaptiveCognitiveBehavioralQuantumPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5728968328992481, 0.5728968328992481, 0.5728968328992481, 0.5319965239821529, 0.5319965239821529, 0.5319965239821529, 0.6212790238123882, 0.6212790238123882, 0.6212790238123882, 0.12388598284598029, 0.12388598284598029, 0.12388598284598029, 0.13392622621858485, 0.13392622621858485, 0.13392622621858485, 0.012609219991994713, 0.012609219991994713, 0.012609219991994713, 0.13165803808318, 0.13165803808318, 0.13165803808318, 0.12883611834836795, 0.12883611834836795, 0.12883611834836795, 0.11758793989325589, 0.11758793989325589, 0.11758793989325589, 0.10068628560202175, 0.10068628560202175, 0.10068628560202175, 0.07824869750767227, 0.07824869750767227, 0.07824869750767227, 0.0955625624150116, 0.0955625624150116, 0.0955625624150116, 0.9810710974597487, 0.9810710974597487, 0.9810710974597487, 0.9849512010323671, 0.9849512010323671, 0.9849512010323671, 0.9917154112431239, 0.9917154112431239, 0.9917154112431239, 0.248434829276737, 0.248434829276737, 0.248434829276737, 0.14894272511024043, 0.14894272511024043, 0.14894272511024043, 0.22842145117056767, 0.22842145117056767, 0.22842145117056767, 0.526954724040793, 0.526954724040793, 0.526954724040793, 0.2587677398465692, 0.2587677398465692, 0.2587677398465692, 0.2931713675130514, 0.2931713675130514, 0.2931713675130514, 0.12153170239245359, 0.12153170239245359, 0.12153170239245359, 0.11033996110027933, 0.11033996110027933, 0.11033996110027933, 0.17535379321307243, 0.17535379321307243, 0.17535379321307243, 0.04376481780958952, 0.04376481780958952, 0.04376481780958952, 0.19278284749701258, 0.19278284749701258, 0.19278284749701258, 0.14641462470787903, 0.14641462470787903, 0.14641462470787903, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1001648937302898, 0.1001648937302898, 0.1001648937302898, 0.05853126059424829, 0.05853126059424829, 0.05853126059424829, 0.06523800807952373, 0.06523800807952373, 0.06523800807952373, 0.03138377816420723, 0.03138377816420723, 0.03138377816420723, 0.07847170546005933, 0.07847170546005933, 0.07847170546005933, 0.11157976484076626, 0.11157976484076626, 0.11157976484076626, 0.12270347220477396, 0.12270347220477396, 0.12270347220477396, 0.15631660129501035, 0.15631660129501035, 0.15631660129501035, 0.12012877948582923, 0.12012877948582923, 0.12012877948582923, 0.3773915150929331, 0.3773915150929331, 0.3773915150929331, 0.3886543266804109, 0.3886543266804109, 0.3886543266804109, 0.4125480780993659, 0.4125480780993659, 0.4125480780993659, 0.10056523762485703, 0.10056523762485703, 0.10056523762485703, 0.08257006250224008, 0.08257006250224008, 0.08257006250224008, 0.08139322773246638, 0.08139322773246638, 0.08139322773246638, 0.14927359231756632, 0.14927359231756632, 0.14927359231756632, 0.17779763326554787, 0.17779763326554787, 0.17779763326554787, 0.14454477567675694, 0.14454477567675694, 0.14454477567675694, 0.2888791472191433, 0.2888791472191433, 0.2888791472191433, 0.29393744546045475, 0.29393744546045475, 0.29393744546045475, 0.3094212592856357, 0.3094212592856357, 0.3094212592856357, 0.22726597687108008, 0.22726597687108008, 0.22726597687108008, 0.1718456568680491, 0.1718456568680491, 0.1718456568680491, 0.23352822618981972, 0.23352822618981972, 0.23352822618981972, 0.19414535286768264, 0.19414535286768264, 0.19414535286768264, 0.17367266261087866, 0.17367266261087866, 0.17367266261087866, 0.18144812263477972, 0.18144812263477972, 0.18144812263477972, 0.1956922170095623, 0.1956922170095623, 0.1956922170095623, 0.1868053219650999, 0.1868053219650999, 0.1868053219650999, 0.17980840762834527, 0.17980840762834527, 0.17980840762834527, 0.6634814351538314, 0.6634814351538314, 0.6634814351538314, 0.1703265296081885, 0.1703265296081885, 0.1703265296081885, 0.4730198106106368, 0.4730198106106368, 0.4730198106106368, 0.16569524936579438, 0.16569524936579438, 0.16569524936579438, 0.2013582498918578, 0.2013582498918578, 0.2013582498918578, 0.19530019357436734, 0.19530019357436734, 0.19530019357436734, 0.17767144115704214, 0.17767144115704214, 0.17767144115704214, 0.17743119505234295, 0.17743119505234295, 0.17743119505234295, 0.17798970011285198, 0.17798970011285198, 0.17798970011285198, 0.07823158686859011, 0.07823158686859011, 0.07823158686859011, 0.07497266501756805, 0.07497266501756805, 0.07497266501756805, 0.07347720201164398, 0.07347720201164398, 0.07347720201164398]}, "mutation_prompt": null}
{"id": "e0b29d16-933a-40f6-a1d6-11f0488ff641", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.F = 0.8\n        self.CR = 0.9\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_min + (self.w_max - self.w_min) * (np.sin(np.pi * evaluations / self.budget) ** 2)  # Chaotic inertia weight\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            self.mutation_probability = 0.1 + 0.1 * np.cos(np.pi * evaluations / self.budget)  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Chaotic Inertia Weight and Dynamic Mutation for enhanced exploration and exploitation.", "configspace": "", "generation": 40, "fitness": 0.2549961746139362, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.7546715138410516, 0.7546715138410516, 0.7546715138410516, 0.7675897355243242, 0.7675897355243242, 0.7675897355243242, 0.742003572710044, 0.742003572710044, 0.742003572710044, 0.04735864086243802, 0.04735864086243802, 0.04735864086243802, 0.42045523330307644, 0.42045523330307644, 0.42045523330307644, 0.23689714960097596, 0.23689714960097596, 0.23689714960097596, 0.12092553247778082, 0.12092553247778082, 0.12092553247778082, 0.10799545487908546, 0.10799545487908546, 0.10799545487908546, 0.11892787677627226, 0.11892787677627226, 0.11892787677627226, 0.11657162450501946, 0.11657162450501946, 0.11657162450501946, 0.09239982231252675, 0.09239982231252675, 0.09239982231252675, 0.10211626609426894, 0.10211626609426894, 0.10211626609426894, 0.9772040869879928, 0.9772040869879928, 0.9772040869879928, 0.9788670633314279, 0.9788670633314279, 0.9788670633314279, 0.9771434515966366, 0.9771434515966366, 0.9771434515966366, 0.3319139739771485, 0.3319139739771485, 0.3319139739771485, 0.3130132271475766, 0.3130132271475766, 0.3130132271475766, 0.41961533033260934, 0.41961533033260934, 0.41961533033260934, 0.27307027840416764, 0.27307027840416764, 0.27307027840416764, 0.2603087027575771, 0.2603087027575771, 0.2603087027575771, 0.4358692873081852, 0.4358692873081852, 0.4358692873081852, 0.2646506300548853, 0.2646506300548853, 0.2646506300548853, 0.15035377274435946, 0.15035377274435946, 0.15035377274435946, 0.13187006108233235, 0.13187006108233235, 0.13187006108233235, 0.15834919779218048, 0.15834919779218048, 0.15834919779218048, 0.12023829952563314, 0.12023829952563314, 0.12023829952563314, 0.16388294843812123, 0.16388294843812123, 0.16388294843812123, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051683551034999664, 0.051683551034999664, 0.051683551034999664, 0.020887104335708173, 0.020887104335708173, 0.020887104335708173, 0.0659978818360103, 0.0659978818360103, 0.0659978818360103, 0.04391867562232843, 0.04391867562232843, 0.04391867562232843, 0.12890257011520312, 0.12890257011520312, 0.12890257011520312, 0.09258510719455348, 0.09258510719455348, 0.09258510719455348, 0.047786198581242334, 0.047786198581242334, 0.047786198581242334, 0.038070348544219645, 0.038070348544219645, 0.038070348544219645, 0.08096714620395906, 0.08096714620395906, 0.08096714620395906, 0.5144610182776743, 0.5144610182776743, 0.5144610182776743, 0.5130579607888235, 0.5130579607888235, 0.5130579607888235, 0.4827653124042698, 0.4827653124042698, 0.4827653124042698, 0.11409831280197946, 0.11409831280197946, 0.11409831280197946, 0.1531339952605114, 0.1531339952605114, 0.1531339952605114, 0.11881919104381156, 0.11881919104381156, 0.11881919104381156, 0.3411610824815047, 0.3411610824815047, 0.3411610824815047, 0.29065062470532643, 0.29065062470532643, 0.29065062470532643, 0.2670306977395086, 0.2670306977395086, 0.2670306977395086, 0.2710132894291828, 0.2710132894291828, 0.2710132894291828, 0.2787489866569457, 0.2787489866569457, 0.2787489866569457, 0.34751482508806897, 0.34751482508806897, 0.34751482508806897, 0.13162798890622185, 0.13162798890622185, 0.13162798890622185, 0.22809931736354705, 0.22809931736354705, 0.22809931736354705, 0.14044837761430806, 0.14044837761430806, 0.14044837761430806, 0.2129561331623342, 0.2129561331623342, 0.2129561331623342, 0.19306327045218097, 0.19306327045218097, 0.19306327045218097, 0.21266697744116658, 0.21266697744116658, 0.21266697744116658, 0.36739228819872327, 0.36739228819872327, 0.36739228819872327, 0.1822828203652983, 0.1822828203652983, 0.1822828203652983, 0.1931485680450421, 0.1931485680450421, 0.1931485680450421, 0.92018483510442, 0.92018483510442, 0.92018483510442, 0.19596795129210998, 0.19596795129210998, 0.19596795129210998, 0.16855410523446568, 0.16855410523446568, 0.16855410523446568, 0.16793982979463695, 0.16793982979463695, 0.16793982979463695, 0.20824232995318082, 0.20824232995318082, 0.20824232995318082, 0.1555277422438649, 0.1555277422438649, 0.1555277422438649, 0.1874811459653295, 0.1874811459653295, 0.1874811459653295, 0.19426956000820128, 0.19426956000820128, 0.19426956000820128, 0.19353979843072322, 0.19353979843072322, 0.19353979843072322, 0.09092119473807125, 0.09092119473807125, 0.09092119473807125, 0.08833044122442513, 0.08833044122442513, 0.08833044122442513, 0.07926328215162592, 0.07926328215162592, 0.07926328215162592]}, "mutation_prompt": null}
{"id": "6e2a2070-414a-4035-826f-8fba6229f311", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.8\n        self.w_min = 0.2\n        self.F = 0.7\n        self.CR = 0.9\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.sin(np.pi / 2 * evaluations / self.budget)  # Sinusoidal inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDynamicQuantumHybridPSO_DE", "description": "Enhanced Dynamic Quantum Hybrid PSO-DE with Adaptive Survival Strategy and Non-linear Velocity Adjustment.", "configspace": "", "generation": 41, "fitness": 0.24078442668474917, "feedback": "The algorithm EnhancedDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.7150833777234922, 0.7150833777234922, 0.7150833777234922, 0.731023771344052, 0.731023771344052, 0.731023771344052, 0.6961835414952966, 0.6961835414952966, 0.6961835414952966, 0.17612913849846568, 0.17612913849846568, 0.17612913849846568, 0.20844776099443285, 0.20844776099443285, 0.20844776099443285, 0.12965392924998687, 0.12965392924998687, 0.12965392924998687, 0.09971178215825371, 0.09971178215825371, 0.09971178215825371, 0.10216161624779985, 0.10216161624779985, 0.10216161624779985, 0.145683511200979, 0.145683511200979, 0.145683511200979, 0.10616144065883615, 0.10616144065883615, 0.10616144065883615, 0.1368019170590713, 0.1368019170590713, 0.1368019170590713, 0.12637793493774474, 0.12637793493774474, 0.12637793493774474, 0.984300193520394, 0.984300193520394, 0.984300193520394, 0.9854652964295401, 0.9854652964295401, 0.9854652964295401, 0.9917148180193611, 0.9917148180193611, 0.9917148180193611, 0.371063483113118, 0.371063483113118, 0.371063483113118, 0.16006654893053185, 0.16006654893053185, 0.16006654893053185, 0.3618032829767557, 0.3618032829767557, 0.3618032829767557, 0.3501056070625005, 0.3501056070625005, 0.3501056070625005, 0.15884132353338687, 0.15884132353338687, 0.15884132353338687, 0.3590809804063131, 0.3590809804063131, 0.3590809804063131, 0.23034868021810295, 0.23034868021810295, 0.23034868021810295, 0.1421268819479501, 0.1421268819479501, 0.1421268819479501, 0.15673602218983163, 0.15673602218983163, 0.15673602218983163, 0.02889189446797047, 0.02889189446797047, 0.02889189446797047, 0.12057835785648419, 0.12057835785648419, 0.12057835785648419, 0.12251254141350565, 0.12251254141350565, 0.12251254141350565, 0.019489585881118043, 0.019489585881118043, 0.019489585881118043, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0594710345471523, 0.0594710345471523, 0.0594710345471523, 0.022153911436951224, 0.022153911436951224, 0.022153911436951224, 0.06027170195839393, 0.06027170195839393, 0.06027170195839393, 0.03910789857814412, 0.03910789857814412, 0.03910789857814412, 0.05210707381623669, 0.05210707381623669, 0.05210707381623669, 0.07344272511631567, 0.07344272511631567, 0.07344272511631567, 0.10750439205671647, 0.10750439205671647, 0.10750439205671647, 0.07392647588927226, 0.07392647588927226, 0.07392647588927226, 0.045490637759771024, 0.045490637759771024, 0.045490637759771024, 0.4314666518415776, 0.4314666518415776, 0.4314666518415776, 0.46984871919690785, 0.46984871919690785, 0.46984871919690785, 0.4789712426018946, 0.4789712426018946, 0.4789712426018946, 0.05694626326557828, 0.05694626326557828, 0.05694626326557828, 0.11068192376874963, 0.11068192376874963, 0.11068192376874963, 0.1348116289694603, 0.1348116289694603, 0.1348116289694603, 0.17339486038933993, 0.17339486038933993, 0.17339486038933993, 0.20865216811989484, 0.20865216811989484, 0.20865216811989484, 0.21805664471509845, 0.21805664471509845, 0.21805664471509845, 0.25308155873178995, 0.25308155873178995, 0.25308155873178995, 0.32878680038650776, 0.32878680038650776, 0.32878680038650776, 0.28720065363441394, 0.28720065363441394, 0.28720065363441394, 0.17430504687245663, 0.17430504687245663, 0.17430504687245663, 0.18692682734937727, 0.18692682734937727, 0.18692682734937727, 0.11329693738414337, 0.11329693738414337, 0.11329693738414337, 0.20572915825470395, 0.20572915825470395, 0.20572915825470395, 0.22927985003321116, 0.22927985003321116, 0.22927985003321116, 0.23598935439719804, 0.23598935439719804, 0.23598935439719804, 0.21144964411289735, 0.21144964411289735, 0.21144964411289735, 0.18783913842093736, 0.18783913842093736, 0.18783913842093736, 0.21638070629093964, 0.21638070629093964, 0.21638070629093964, 0.8056280174157644, 0.8056280174157644, 0.8056280174157644, 0.16278146346870492, 0.16278146346870492, 0.16278146346870492, 0.1653861830798169, 0.1653861830798169, 0.1653861830798169, 0.35868975124321756, 0.35868975124321756, 0.35868975124321756, 0.2041734423599485, 0.2041734423599485, 0.2041734423599485, 0.44812263685530696, 0.44812263685530696, 0.44812263685530696, 0.17518550761152196, 0.17518550761152196, 0.17518550761152196, 0.1718071230861462, 0.1718071230861462, 0.1718071230861462, 0.19765064046035474, 0.19765064046035474, 0.19765064046035474, 0.09284361480396142, 0.09284361480396142, 0.09284361480396142, 0.08800103936392367, 0.08800103936392367, 0.08800103936392367, 0.10289245212196751, 0.10289245212196751, 0.10289245212196751]}, "mutation_prompt": null}
{"id": "71d661e2-5782-459e-9a28-3ec851cf0f07", "solution": "import numpy as np\n\nclass EnhancedQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2  # Non-linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n            # Dynamic Neighborhood Strategy\n            neighborhood_size = max(2, int(0.1 * self.population_size))\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                neighbors = np.random.choice(self.population_size, size=neighborhood_size, replace=False)\n                local_best = min(neighbors, key=lambda idx: p_best_scores[idx])\n                r3 = np.random.rand(self.dim)\n                velocities[i] += self.c1 * r3 * (p_best_positions[local_best] - positions[i])\n                positions[i] = np.clip(positions[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n        return g_best_position, g_best_score", "name": "EnhancedQuantumHybridPSO_DE", "description": "Enhanced Quantum-Inspired Hybrid PSO-DE utilizing Rotational Diversity, Adaptive Mutation, and Dynamic Neighborhood Strategy for improved solution exploration.", "configspace": "", "generation": 42, "fitness": 0.13073047618875705, "feedback": "The algorithm EnhancedQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.19020038466076672, 0.19020038466076672, 0.19020038466076672, 0.19293567936539124, 0.19293567936539124, 0.19293567936539124, 0.24500481136558094, 0.24500481136558094, 0.24500481136558094, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04709373813247497, 0.04709373813247497, 0.04709373813247497, 0.0558429537476155, 0.0558429537476155, 0.0558429537476155, 0.05157293721159384, 0.05157293721159384, 0.05157293721159384, 0.050679400530280305, 0.050679400530280305, 0.050679400530280305, 0.032879034392029105, 0.032879034392029105, 0.032879034392029105, 0.04796834004075845, 0.04796834004075845, 0.04796834004075845, 0.9893773295595432, 0.9893773295595432, 0.9893773295595432, 0.9916985466535501, 0.9916985466535501, 0.9916985466535501, 0.9920442844450535, 0.9920442844450535, 0.9920442844450535, 0.08929838855416616, 0.08929838855416616, 0.08929838855416616, 0.08734990243475038, 0.08734990243475038, 0.08734990243475038, 0.08368845004878733, 0.08368845004878733, 0.08368845004878733, 0.12589966012779075, 0.12589966012779075, 0.12589966012779075, 0.11729148398037526, 0.11729148398037526, 0.11729148398037526, 0.11281884808094567, 0.11281884808094567, 0.11281884808094567, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005153096944195523, 0.005153096944195523, 0.005153096944195523, 0.0021584079612172458, 0.0021584079612172458, 0.0021584079612172458, 0.02121404147860717, 0.02121404147860717, 0.02121404147860717, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005489355172574317, 0.0005489355172574317, 0.0005489355172574317, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02373414600837731, 0.02373414600837731, 0.02373414600837731, 0.01785342978140214, 0.01785342978140214, 0.01785342978140214, 0.0423618727114361, 0.0423618727114361, 0.0423618727114361, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025743488931423975, 0.025743488931423975, 0.025743488931423975, 0.23240017276394476, 0.23240017276394476, 0.23240017276394476, 0.20605696969343767, 0.20605696969343767, 0.20605696969343767, 0.22241195166509486, 0.22241195166509486, 0.22241195166509486, 0.08147170156292138, 0.08147170156292138, 0.08147170156292138, 0.048643649999926986, 0.048643649999926986, 0.048643649999926986, 0.045246663333170734, 0.045246663333170734, 0.045246663333170734, 0.14028545803709536, 0.14028545803709536, 0.14028545803709536, 0.1381609560363113, 0.1381609560363113, 0.1381609560363113, 0.14756466465754603, 0.14756466465754603, 0.14756466465754603, 0.1660929760023131, 0.1660929760023131, 0.1660929760023131, 0.16652180866527522, 0.16652180866527522, 0.16652180866527522, 0.19583032979054915, 0.19583032979054915, 0.19583032979054915, 0.12670861159262126, 0.12670861159262126, 0.12670861159262126, 0.09541570694571333, 0.09541570694571333, 0.09541570694571333, 0.136738269584891, 0.136738269584891, 0.136738269584891, 0.15580534345869312, 0.15580534345869312, 0.15580534345869312, 0.145010705127958, 0.145010705127958, 0.145010705127958, 0.1381233219249991, 0.1381233219249991, 0.1381233219249991, 0.13431666581263102, 0.13431666581263102, 0.13431666581263102, 0.13430630603267546, 0.13430630603267546, 0.13430630603267546, 0.16431615695316615, 0.16431615695316615, 0.16431615695316615, 0.22461427871299722, 0.22461427871299722, 0.22461427871299722, 0.15296727863346027, 0.15296727863346027, 0.15296727863346027, 0.16184016210918784, 0.16184016210918784, 0.16184016210918784, 0.18479403404544237, 0.18479403404544237, 0.18479403404544237, 0.14263889578812017, 0.14263889578812017, 0.14263889578812017, 0.19246061765173084, 0.19246061765173084, 0.19246061765173084, 0.18174503561961763, 0.18174503561961763, 0.18174503561961763, 0.18944679775377427, 0.18944679775377427, 0.18944679775377427, 0.17607278705160057, 0.17607278705160057, 0.17607278705160057, 0.05456494659912037, 0.05456494659912037, 0.05456494659912037, 0.048815349266218666, 0.048815349266218666, 0.048815349266218666, 0.037494120052933066, 0.037494120052933066, 0.037494120052933066]}, "mutation_prompt": null}
{"id": "c49e83f1-5d15-403a-b874-7327007ad2e8", "solution": "import numpy as np\n\nclass AdaptiveQuantumEnhancedPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.7\n        self.CR = 0.9\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 0.5  # Adjusted inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = positions + velocities\n            out_of_bounds_high = positions > self.upper_bound\n            out_of_bounds_low = positions < self.lower_bound\n            positions[out_of_bounds_high] = 2 * self.upper_bound - positions[out_of_bounds_high]\n            positions[out_of_bounds_low] = 2 * self.lower_bound - positions[out_of_bounds_low]\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumEnhancedPSO_DE", "description": "Adaptive Quantum-Enhanced Hybrid PSO-DE with Non-Linear Boundary Reflection and Dynamic Selection for enhanced exploration and exploitation balance.", "configspace": "", "generation": 43, "fitness": 0.19050852067545546, "feedback": "The algorithm AdaptiveQuantumEnhancedPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.7105551788218002, 0.7105551788218002, 0.7105551788218002, 0.5190831336653916, 0.5190831336653916, 0.5190831336653916, 0.18737776545912865, 0.18737776545912865, 0.18737776545912865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03900307373023404, 0.03900307373023404, 0.03900307373023404, 0.1380576277884631, 0.1380576277884631, 0.1380576277884631, 0.1109198562439444, 0.1109198562439444, 0.1109198562439444, 0.10875166790043145, 0.10875166790043145, 0.10875166790043145, 0.12595321565362105, 0.12595321565362105, 0.12595321565362105, 0.12894944246117157, 0.12894944246117157, 0.12894944246117157, 0.15294686465639928, 0.15294686465639928, 0.15294686465639928, 0.12039487989503772, 0.12039487989503772, 0.12039487989503772, 0.46726360128083055, 0.46726360128083055, 0.46726360128083055, 0.7308233577468165, 0.7308233577468165, 0.7308233577468165, 0.10170026629873197, 0.10170026629873197, 0.10170026629873197, 0.1520297987792919, 0.1520297987792919, 0.1520297987792919, 0.18521366634284397, 0.18521366634284397, 0.18521366634284397, 0.6847525224987625, 0.6847525224987625, 0.6847525224987625, 0.19000421391135847, 0.19000421391135847, 0.19000421391135847, 0.1686543246341966, 0.1686543246341966, 0.1686543246341966, 0.14882410265707535, 0.14882410265707535, 0.14882410265707535, 0.11283529358222533, 0.11283529358222533, 0.11283529358222533, 0.3399977883115335, 0.3399977883115335, 0.3399977883115335, 0.090638342114431, 0.090638342114431, 0.090638342114431, 0.16715897042771044, 0.16715897042771044, 0.16715897042771044, 0.17773738779851678, 0.17773738779851678, 0.17773738779851678, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0695139792846099, 0.0695139792846099, 0.0695139792846099, 0.045412323230551, 0.045412323230551, 0.045412323230551, 0.09182526771154498, 0.09182526771154498, 0.09182526771154498, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046194408794293484, 0.046194408794293484, 0.046194408794293484, 0.11173198859860645, 0.11173198859860645, 0.11173198859860645, 0.011103395121874193, 0.011103395121874193, 0.011103395121874193, 0.0348162906112488, 0.0348162906112488, 0.0348162906112488, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.462335431208748, 0.462335431208748, 0.462335431208748, 0.3981593765308996, 0.3981593765308996, 0.3981593765308996, 0.48841893483592147, 0.48841893483592147, 0.48841893483592147, 0.08864542032276601, 0.08864542032276601, 0.08864542032276601, 0.11672792751882566, 0.11672792751882566, 0.11672792751882566, 0.10383173532318402, 0.10383173532318402, 0.10383173532318402, 0.0960182178489507, 0.0960182178489507, 0.0960182178489507, 0.1727918646282014, 0.1727918646282014, 0.1727918646282014, 0.23668820470980012, 0.23668820470980012, 0.23668820470980012, 0.31766722636045186, 0.31766722636045186, 0.31766722636045186, 0.19177336318370075, 0.19177336318370075, 0.19177336318370075, 0.2479439320769643, 0.2479439320769643, 0.2479439320769643, 0.22989388962122848, 0.22989388962122848, 0.22989388962122848, 0.18420145113765307, 0.18420145113765307, 0.18420145113765307, 0.1822335829159939, 0.1822335829159939, 0.1822335829159939, 0.20251798687433165, 0.20251798687433165, 0.20251798687433165, 0.17715697719645418, 0.17715697719645418, 0.17715697719645418, 0.22238270719651831, 0.22238270719651831, 0.22238270719651831, 0.21905243568800092, 0.21905243568800092, 0.21905243568800092, 0.1840294410357023, 0.1840294410357023, 0.1840294410357023, 0.19416495525726196, 0.19416495525726196, 0.19416495525726196, 0.7813626852677364, 0.7813626852677364, 0.7813626852677364, 0.16286572463525606, 0.16286572463525606, 0.16286572463525606, 0.16141830066863383, 0.16141830066863383, 0.16141830066863383, 0.2656835225434666, 0.2656835225434666, 0.2656835225434666, 0.15946155494450742, 0.15946155494450742, 0.15946155494450742, 0.18852926544125592, 0.18852926544125592, 0.18852926544125592, 0.1812343454050449, 0.1812343454050449, 0.1812343454050449, 0.1999227959127876, 0.1999227959127876, 0.1999227959127876, 0.1769496977255539, 0.1769496977255539, 0.1769496977255539, 0.08050920283544871, 0.08050920283544871, 0.08050920283544871, 0.09328637707503751, 0.09328637707503751, 0.09328637707503751, 0.07783095869382994, 0.07783095869382994, 0.07783095869382994]}, "mutation_prompt": null}
{"id": "a3e3c972-e761-4318-a30c-1c82d323746c", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 65\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.95\n        self.w_min = 0.2\n        self.F = 0.85\n        self.CR = 0.9\n        self.diversity_factor = 0.2\n        self.mutation_chance = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * evaluations / self.budget  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.diversity_factor * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_chance:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE leveraging Dynamic Diversity with Multi-Scale Mutation for robust optimization.", "configspace": "", "generation": 44, "fitness": 0.1971647307250404, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5728082902163352, 0.5728082902163352, 0.5728082902163352, 0.53041929623084, 0.53041929623084, 0.53041929623084, 0.5112627391205942, 0.5112627391205942, 0.5112627391205942, 0.04031284221652498, 0.04031284221652498, 0.04031284221652498, 0.03847975563143968, 0.03847975563143968, 0.03847975563143968, 0.04492899632716851, 0.04492899632716851, 0.04492899632716851, 0.12001325454975009, 0.12001325454975009, 0.12001325454975009, 0.11525780852258982, 0.11525780852258982, 0.11525780852258982, 0.13298483270927386, 0.13298483270927386, 0.13298483270927386, 0.08927348384788603, 0.08927348384788603, 0.08927348384788603, 0.10537207802496884, 0.10537207802496884, 0.10537207802496884, 0.09158755876773195, 0.09158755876773195, 0.09158755876773195, 0.9835533422322931, 0.9835533422322931, 0.9835533422322931, 0.9851268758050038, 0.9851268758050038, 0.9851268758050038, 0.9863787547791879, 0.9863787547791879, 0.9863787547791879, 0.22456833294481204, 0.22456833294481204, 0.22456833294481204, 0.13261597802642633, 0.13261597802642633, 0.13261597802642633, 0.2542238628894775, 0.2542238628894775, 0.2542238628894775, 0.2023036470180687, 0.2023036470180687, 0.2023036470180687, 0.15235971373655044, 0.15235971373655044, 0.15235971373655044, 0.2169402994178813, 0.2169402994178813, 0.2169402994178813, 0.12141623264740287, 0.12141623264740287, 0.12141623264740287, 0.1059864961438719, 0.1059864961438719, 0.1059864961438719, 0.09756930600056835, 0.09756930600056835, 0.09756930600056835, 0.04410605264088319, 0.04410605264088319, 0.04410605264088319, 0.13033087413028444, 0.13033087413028444, 0.13033087413028444, 0.0259503188261897, 0.0259503188261897, 0.0259503188261897, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022131419071291902, 0.022131419071291902, 0.022131419071291902, 0.07032510586677632, 0.07032510586677632, 0.07032510586677632, 0.04276175414755656, 0.04276175414755656, 0.04276175414755656, 0.02157108582005063, 0.02157108582005063, 0.02157108582005063, 0.04411551609803466, 0.04411551609803466, 0.04411551609803466, 0.046563381706562046, 0.046563381706562046, 0.046563381706562046, 0.01602553032736176, 0.01602553032736176, 0.01602553032736176, 0.02910020279769121, 0.02910020279769121, 0.02910020279769121, 0.04267905318428433, 0.04267905318428433, 0.04267905318428433, 0.40541240982421345, 0.40541240982421345, 0.40541240982421345, 0.393742661861593, 0.393742661861593, 0.393742661861593, 0.4289218286252886, 0.4289218286252886, 0.4289218286252886, 0.0621374346414274, 0.0621374346414274, 0.0621374346414274, 0.11497730827672492, 0.11497730827672492, 0.11497730827672492, 0.07276665917287861, 0.07276665917287861, 0.07276665917287861, 0.1529106075002179, 0.1529106075002179, 0.1529106075002179, 0.1519883552491279, 0.1519883552491279, 0.1519883552491279, 0.19887649376834227, 0.19887649376834227, 0.19887649376834227, 0.21079821472484805, 0.21079821472484805, 0.21079821472484805, 0.25879576833956197, 0.25879576833956197, 0.25879576833956197, 0.22540884606800238, 0.22540884606800238, 0.22540884606800238, 0.10986137603669499, 0.10986137603669499, 0.10986137603669499, 0.1642664380800325, 0.1642664380800325, 0.1642664380800325, 0.14233834670560153, 0.14233834670560153, 0.14233834670560153, 0.1670247022532072, 0.1670247022532072, 0.1670247022532072, 0.18802603332827417, 0.18802603332827417, 0.18802603332827417, 0.17223244372909507, 0.17223244372909507, 0.17223244372909507, 0.17833555486842412, 0.17833555486842412, 0.17833555486842412, 0.21153629457353307, 0.21153629457353307, 0.21153629457353307, 0.19207489075207185, 0.19207489075207185, 0.19207489075207185, 0.7001866797345935, 0.7001866797345935, 0.7001866797345935, 0.15763272808250006, 0.15763272808250006, 0.15763272808250006, 0.163368240364689, 0.163368240364689, 0.163368240364689, 0.24460534543503298, 0.24460534543503298, 0.24460534543503298, 0.28812142825903564, 0.28812142825903564, 0.28812142825903564, 0.2575759672180783, 0.2575759672180783, 0.2575759672180783, 0.18566988911086002, 0.18566988911086002, 0.18566988911086002, 0.19014087311163708, 0.19014087311163708, 0.19014087311163708, 0.18752748419656795, 0.18752748419656795, 0.18752748419656795, 0.07712832547117654, 0.07712832547117654, 0.07712832547117654, 0.07136374496846476, 0.07136374496846476, 0.07136374496846476, 0.07840316544749837, 0.07840316544749837, 0.07840316544749837]}, "mutation_prompt": null}
{"id": "0f2f9c60-61d9-47a4-b423-a1a95e9292bc", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted for better balance in exploration and exploitation\n        self.F = 0.7  # Slightly adjusted differential weight\n        self.CR = 0.9  # Increased crossover probability for more exploration\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2  # Increased mutation probability to enhance diversity\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.random.rand()  # Randomized inertia\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSODE", "description": "Adaptive Quantum-Inspired Hybrid PSO with Differential Evolution and Randomized Inertia for enhanced exploration and exploitation balance.", "configspace": "", "generation": 45, "fitness": 0.2416588276395785, "feedback": "The algorithm AdaptiveQuantumHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.710894447010469, 0.710894447010469, 0.710894447010469, 0.6952935714052773, 0.6952935714052773, 0.6952935714052773, 0.7082278641215634, 0.7082278641215634, 0.7082278641215634, 0.3720880292238423, 0.3720880292238423, 0.3720880292238423, 0.37941784086078323, 0.37941784086078323, 0.37941784086078323, 0.04676882585581954, 0.04676882585581954, 0.04676882585581954, 0.1376648149520232, 0.1376648149520232, 0.1376648149520232, 0.1339571797707726, 0.1339571797707726, 0.1339571797707726, 0.12231020439309792, 0.12231020439309792, 0.12231020439309792, 0.11777955447413857, 0.11777955447413857, 0.11777955447413857, 0.12762569371208266, 0.12762569371208266, 0.12762569371208266, 0.09707468651724105, 0.09707468651724105, 0.09707468651724105, 0.9828785673411736, 0.9828785673411736, 0.9828785673411736, 0.9836365780694392, 0.9836365780694392, 0.9836365780694392, 0.9908400796193148, 0.9908400796193148, 0.9908400796193148, 0.4349976700977073, 0.4349976700977073, 0.4349976700977073, 0.14736166803449668, 0.14736166803449668, 0.14736166803449668, 0.360131162626242, 0.360131162626242, 0.360131162626242, 0.20135488889804132, 0.20135488889804132, 0.20135488889804132, 0.23297427832294137, 0.23297427832294137, 0.23297427832294137, 0.14837954422798683, 0.14837954422798683, 0.14837954422798683, 0.08920952062878751, 0.08920952062878751, 0.08920952062878751, 0.09750482122170123, 0.09750482122170123, 0.09750482122170123, 0.1562654390150967, 0.1562654390150967, 0.1562654390150967, 0.030883120610428305, 0.030883120610428305, 0.030883120610428305, 0.13718653460649644, 0.13718653460649644, 0.13718653460649644, 0.13329273881285408, 0.13329273881285408, 0.13329273881285408, 0.05018478632604617, 0.05018478632604617, 0.05018478632604617, 0.039082179777973014, 0.039082179777973014, 0.039082179777973014, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07788445779725539, 0.07788445779725539, 0.07788445779725539, 0.007788670933106201, 0.007788670933106201, 0.007788670933106201, 0.02617095331542929, 0.02617095331542929, 0.02617095331542929, 0.03790536947188139, 0.03790536947188139, 0.03790536947188139, 0.0789051802575963, 0.0789051802575963, 0.0789051802575963, 0.07565437344931303, 0.07565437344931303, 0.07565437344931303, 0.009391577031718779, 0.009391577031718779, 0.009391577031718779, 0.03344872839466284, 0.03344872839466284, 0.03344872839466284, 0.05218866558542046, 0.05218866558542046, 0.05218866558542046, 0.5167903747779017, 0.5167903747779017, 0.5167903747779017, 0.4314937339765428, 0.4314937339765428, 0.4314937339765428, 0.4686109322318259, 0.4686109322318259, 0.4686109322318259, 0.09517554447506593, 0.09517554447506593, 0.09517554447506593, 0.11815097950053766, 0.11815097950053766, 0.11815097950053766, 0.11791636526281613, 0.11791636526281613, 0.11791636526281613, 0.21951786024988118, 0.21951786024988118, 0.21951786024988118, 0.17821871650840637, 0.17821871650840637, 0.17821871650840637, 0.17463243377952298, 0.17463243377952298, 0.17463243377952298, 0.21831920403159155, 0.21831920403159155, 0.21831920403159155, 0.326394986111584, 0.326394986111584, 0.326394986111584, 0.3678652167238292, 0.3678652167238292, 0.3678652167238292, 0.23776875679785114, 0.23776875679785114, 0.23776875679785114, 0.1836394862754942, 0.1836394862754942, 0.1836394862754942, 0.11835482296535571, 0.11835482296535571, 0.11835482296535571, 0.21099232202235874, 0.21099232202235874, 0.21099232202235874, 0.18692235557230474, 0.18692235557230474, 0.18692235557230474, 0.17149319984102585, 0.17149319984102585, 0.17149319984102585, 0.18703945120386245, 0.18703945120386245, 0.18703945120386245, 0.20361628374006213, 0.20361628374006213, 0.20361628374006213, 0.20006438990351771, 0.20006438990351771, 0.20006438990351771, 0.8018356125398184, 0.8018356125398184, 0.8018356125398184, 0.4641666454152704, 0.4641666454152704, 0.4641666454152704, 0.16647714073096942, 0.16647714073096942, 0.16647714073096942, 0.1649259366564898, 0.1649259366564898, 0.1649259366564898, 0.20804370291331464, 0.20804370291331464, 0.20804370291331464, 0.5079644475363361, 0.5079644475363361, 0.5079644475363361, 0.1984796745263987, 0.1984796745263987, 0.1984796745263987, 0.1943952875482745, 0.1943952875482745, 0.1943952875482745, 0.21156921621553948, 0.21156921621553948, 0.21156921621553948, 0.08164477270791881, 0.08164477270791881, 0.08164477270791881, 0.08526549613044665, 0.08526549613044665, 0.08526549613044665, 0.11698597440731628, 0.11698597440731628, 0.11698597440731628]}, "mutation_prompt": null}
{"id": "e8c5ad82-92c6-43cd-8ddb-126f036d839b", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2  # Adjusted mutation probability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2  # Revised inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                j_rand = np.random.randint(self.dim)  # Ensure at least one crossover\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)  # Increased mutation strength\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE using Dynamic Velocity Control and Enhanced Crossover for robust optimization.", "configspace": "", "generation": 46, "fitness": 0.19218215262169722, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.4577638542241972, 0.4577638542241972, 0.4577638542241972, 0.3586785630946683, 0.3586785630946683, 0.3586785630946683, 0.4337617806935632, 0.4337617806935632, 0.4337617806935632, 0.04596850879118375, 0.04596850879118375, 0.04596850879118375, 0.014070878849533841, 0.014070878849533841, 0.014070878849533841, 0.0018028640742555613, 0.0018028640742555613, 0.0018028640742555613, 0.1029636360746099, 0.1029636360746099, 0.1029636360746099, 0.0873280876862167, 0.0873280876862167, 0.0873280876862167, 0.11232843598533016, 0.11232843598533016, 0.11232843598533016, 0.07674885352276872, 0.07674885352276872, 0.07674885352276872, 0.09057646578888323, 0.09057646578888323, 0.09057646578888323, 0.07341592210990988, 0.07341592210990988, 0.07341592210990988, 0.9874805529546665, 0.9874805529546665, 0.9874805529546665, 0.9859981556960032, 0.9859981556960032, 0.9859981556960032, 0.9920190066476532, 0.9920190066476532, 0.9920190066476532, 0.10495000449579439, 0.10495000449579439, 0.10495000449579439, 0.1906183655257112, 0.1906183655257112, 0.1906183655257112, 0.22922078546959967, 0.22922078546959967, 0.22922078546959967, 0.18506758862239836, 0.18506758862239836, 0.18506758862239836, 0.15199394562585444, 0.15199394562585444, 0.15199394562585444, 0.17938225467915403, 0.17938225467915403, 0.17938225467915403, 0.09877141258454136, 0.09877141258454136, 0.09877141258454136, 0.10155525431597967, 0.10155525431597967, 0.10155525431597967, 0.1247420767008478, 0.1247420767008478, 0.1247420767008478, 0.02083825588386312, 0.02083825588386312, 0.02083825588386312, 0.1165146763750814, 0.1165146763750814, 0.1165146763750814, 0.09789613420191567, 0.09789613420191567, 0.09789613420191567, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050104005538106455, 0.050104005538106455, 0.050104005538106455, 0.07787795863232272, 0.07787795863232272, 0.07787795863232272, 0.05136532931067217, 0.05136532931067217, 0.05136532931067217, 0.013232634953478373, 0.013232634953478373, 0.013232634953478373, 0.01447764316049338, 0.01447764316049338, 0.01447764316049338, 0.025468281947887417, 0.025468281947887417, 0.025468281947887417, 0.06492676355266636, 0.06492676355266636, 0.06492676355266636, 0.03920638281736555, 0.03920638281736555, 0.03920638281736555, 0.05676012793918983, 0.05676012793918983, 0.05676012793918983, 0.3361684733113578, 0.3361684733113578, 0.3361684733113578, 0.34944147500042866, 0.34944147500042866, 0.34944147500042866, 0.3413271265952732, 0.3413271265952732, 0.3413271265952732, 0.07711736695209459, 0.07711736695209459, 0.07711736695209459, 0.08587316044444737, 0.08587316044444737, 0.08587316044444737, 0.07325756582890486, 0.07325756582890486, 0.07325756582890486, 0.27819655534376975, 0.27819655534376975, 0.27819655534376975, 0.17898375061655003, 0.17898375061655003, 0.17898375061655003, 0.1829940143640545, 0.1829940143640545, 0.1829940143640545, 0.24039222179917463, 0.24039222179917463, 0.24039222179917463, 0.22188671138472982, 0.22188671138472982, 0.22188671138472982, 0.18264361849767907, 0.18264361849767907, 0.18264361849767907, 0.10747194378964797, 0.10747194378964797, 0.10747194378964797, 0.16124629389791645, 0.16124629389791645, 0.16124629389791645, 0.19339595419338973, 0.19339595419338973, 0.19339595419338973, 0.1703733595503849, 0.1703733595503849, 0.1703733595503849, 0.19096831251553348, 0.19096831251553348, 0.19096831251553348, 0.20143275265551075, 0.20143275265551075, 0.20143275265551075, 0.17792109430861092, 0.17792109430861092, 0.17792109430861092, 0.17864320651744714, 0.17864320651744714, 0.17864320651744714, 0.1682933192531354, 0.1682933192531354, 0.1682933192531354, 0.5997697274162035, 0.5997697274162035, 0.5997697274162035, 0.17988638568520732, 0.17988638568520732, 0.17988638568520732, 0.4425535274389576, 0.4425535274389576, 0.4425535274389576, 0.3415017669656144, 0.3415017669656144, 0.3415017669656144, 0.28098368851556477, 0.28098368851556477, 0.28098368851556477, 0.3184570999619981, 0.3184570999619981, 0.3184570999619981, 0.18129794113001174, 0.18129794113001174, 0.18129794113001174, 0.18642018124220927, 0.18642018124220927, 0.18642018124220927, 0.18457150741470651, 0.18457150741470651, 0.18457150741470651, 0.0736634542761756, 0.0736634542761756, 0.0736634542761756, 0.06952622047312218, 0.06952622047312218, 0.06952622047312218, 0.06427976289602122, 0.06427976289602122, 0.06427976289602122]}, "mutation_prompt": null}
{"id": "e206e8f1-8dca-4c16-ab02-136e75ea3ff8", "solution": "import numpy as np\n\nclass EnhancedQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.85\n        self.w_min = 0.4\n        self.F = 0.75\n        self.CR = 0.9\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.sqrt(evaluations / self.budget)  # Square-root inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedQuantumHybridPSO_DE", "description": "Enhanced Quantum-Inspired Hybrid PSO-DE with Adaptive Learning and Crossover for improved exploration and exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.22545000847726365, "feedback": "The algorithm EnhancedQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.23.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.7233415325158554, 0.7233415325158554, 0.7233415325158554, 0.6543630486568148, 0.6543630486568148, 0.6543630486568148, 0.731415873939243, 0.731415873939243, 0.731415873939243, 0.29169364259762265, 0.29169364259762265, 0.29169364259762265, 0.20113841173089664, 0.20113841173089664, 0.20113841173089664, 0.03531462305417732, 0.03531462305417732, 0.03531462305417732, 0.12173384282826427, 0.12173384282826427, 0.12173384282826427, 0.14692782197209087, 0.14692782197209087, 0.14692782197209087, 0.12924759574581035, 0.12924759574581035, 0.12924759574581035, 0.11727178182123865, 0.11727178182123865, 0.11727178182123865, 0.10588350653396628, 0.10588350653396628, 0.10588350653396628, 0.08842122773325611, 0.08842122773325611, 0.08842122773325611, 0.9843349337305851, 0.9843349337305851, 0.9843349337305851, 0.9854917507668317, 0.9854917507668317, 0.9854917507668317, 0.9917151131988474, 0.9917151131988474, 0.9917151131988474, 0.10857186340463265, 0.10857186340463265, 0.10857186340463265, 0.1446175158749582, 0.1446175158749582, 0.1446175158749582, 0.34223616053542827, 0.34223616053542827, 0.34223616053542827, 0.20837190128154348, 0.20837190128154348, 0.20837190128154348, 0.15745769543791777, 0.15745769543791777, 0.15745769543791777, 0.16319420196241685, 0.16319420196241685, 0.16319420196241685, 0.18751803061535033, 0.18751803061535033, 0.18751803061535033, 0.090655603921179, 0.090655603921179, 0.090655603921179, 0.15864831722179262, 0.15864831722179262, 0.15864831722179262, 0.06116739171719854, 0.06116739171719854, 0.06116739171719854, 0.16322693706839486, 0.16322693706839486, 0.16322693706839486, 0.014785210830572937, 0.014785210830572937, 0.014785210830572937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034601864059645604, 0.034601864059645604, 0.034601864059645604, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05954654141202609, 0.05954654141202609, 0.05954654141202609, 0.04869675168829091, 0.04869675168829091, 0.04869675168829091, 0.04608448094415685, 0.04608448094415685, 0.04608448094415685, 0.03872882727804061, 0.03872882727804061, 0.03872882727804061, 0.059932375257278236, 0.059932375257278236, 0.059932375257278236, 0.07330093714230712, 0.07330093714230712, 0.07330093714230712, 0.010278946154438362, 0.010278946154438362, 0.010278946154438362, 0.07619123055691146, 0.07619123055691146, 0.07619123055691146, 0.04563330906561547, 0.04563330906561547, 0.04563330906561547, 0.47288690518347143, 0.47288690518347143, 0.47288690518347143, 0.4870694605513508, 0.4870694605513508, 0.4870694605513508, 0.4675165872370197, 0.4675165872370197, 0.4675165872370197, 0.06789035919933462, 0.06789035919933462, 0.06789035919933462, 0.11763135403918679, 0.11763135403918679, 0.11763135403918679, 0.10638352499559556, 0.10638352499559556, 0.10638352499559556, 0.19083777196908414, 0.19083777196908414, 0.19083777196908414, 0.1737873646187571, 0.1737873646187571, 0.1737873646187571, 0.15057633498073775, 0.15057633498073775, 0.15057633498073775, 0.24552821659197221, 0.24552821659197221, 0.24552821659197221, 0.22716361347324177, 0.22716361347324177, 0.22716361347324177, 0.25299657184914204, 0.25299657184914204, 0.25299657184914204, 0.17750086064809056, 0.17750086064809056, 0.17750086064809056, 0.1826272487353292, 0.1826272487353292, 0.1826272487353292, 0.11671488490801873, 0.11671488490801873, 0.11671488490801873, 0.21819360118832687, 0.21819360118832687, 0.21819360118832687, 0.2266486968028636, 0.2266486968028636, 0.2266486968028636, 0.19984801278647712, 0.19984801278647712, 0.19984801278647712, 0.20877883029464428, 0.20877883029464428, 0.20877883029464428, 0.2071991210780597, 0.2071991210780597, 0.2071991210780597, 0.21660972012662627, 0.21660972012662627, 0.21660972012662627, 0.8519449548245693, 0.8519449548245693, 0.8519449548245693, 0.15377702941196114, 0.15377702941196114, 0.15377702941196114, 0.163837259862204, 0.163837259862204, 0.163837259862204, 0.3232535694392039, 0.3232535694392039, 0.3232535694392039, 0.20402904004102007, 0.20402904004102007, 0.20402904004102007, 0.39731449819176967, 0.39731449819176967, 0.39731449819176967, 0.17690037010874093, 0.17690037010874093, 0.17690037010874093, 0.18656226562749112, 0.18656226562749112, 0.18656226562749112, 0.1785544915013756, 0.1785544915013756, 0.1785544915013756, 0.07849622278991208, 0.07849622278991208, 0.07849622278991208, 0.09066921059290112, 0.09066921059290112, 0.09066921059290112, 0.11073185645890571, 0.11073185645890571, 0.11073185645890571]}, "mutation_prompt": null}
{"id": "8c746ef8-128e-4f24-aba1-7790ec656ee9", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w_max = 0.85\n        self.w_min = 0.35\n        self.F = 0.9\n        self.CR = 0.9\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 3  # Adjusted non-linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Non-Linear Inertia and Dynamic Mutation for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 48, "fitness": 0.2465485044346906, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.82036790011025, 0.82036790011025, 0.82036790011025, 0.8061687279732341, 0.8061687279732341, 0.8061687279732341, 0.7913843937165467, 0.7913843937165467, 0.7913843937165467, 0.041658236300574414, 0.041658236300574414, 0.041658236300574414, 0.27736807469792446, 0.27736807469792446, 0.27736807469792446, 0.2641654494722171, 0.2641654494722171, 0.2641654494722171, 0.10703572569144781, 0.10703572569144781, 0.10703572569144781, 0.1204366181973795, 0.1204366181973795, 0.1204366181973795, 0.13897181303084394, 0.13897181303084394, 0.13897181303084394, 0.10994521952747005, 0.10994521952747005, 0.10994521952747005, 0.13296949399931624, 0.13296949399931624, 0.13296949399931624, 0.11278209785794369, 0.11278209785794369, 0.11278209785794369, 0.9802976895075313, 0.9802976895075313, 0.9802976895075313, 0.977305882226076, 0.977305882226076, 0.977305882226076, 0.9769345144880875, 0.9769345144880875, 0.9769345144880875, 0.32930453622605405, 0.32930453622605405, 0.32930453622605405, 0.40546800014522155, 0.40546800014522155, 0.40546800014522155, 0.4395733613892726, 0.4395733613892726, 0.4395733613892726, 0.21373825394960455, 0.21373825394960455, 0.21373825394960455, 0.17926718950087905, 0.17926718950087905, 0.17926718950087905, 0.17921111431093362, 0.17921111431093362, 0.17921111431093362, 0.15963147879474526, 0.15963147879474526, 0.15963147879474526, 0.16925885525797535, 0.16925885525797535, 0.16925885525797535, 0.17954072781347874, 0.17954072781347874, 0.17954072781347874, 0.1510915325453721, 0.1510915325453721, 0.1510915325453721, 0.1668974783162921, 0.1668974783162921, 0.1668974783162921, 0.24436264077244207, 0.24436264077244207, 0.24436264077244207, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059716586739227195, 0.059716586739227195, 0.059716586739227195, 0.03456467895501958, 0.03456467895501958, 0.03456467895501958, 0.03685403877489557, 0.03685403877489557, 0.03685403877489557, 0.048460322529897515, 0.048460322529897515, 0.048460322529897515, 0.08988269043173591, 0.08988269043173591, 0.08988269043173591, 0.09444148376600092, 0.09444148376600092, 0.09444148376600092, 0.08991359451045755, 0.08991359451045755, 0.08991359451045755, 0.08402769174420954, 0.08402769174420954, 0.08402769174420954, 0.04866870659827893, 0.04866870659827893, 0.04866870659827893, 0.5277525871140152, 0.5277525871140152, 0.5277525871140152, 0.46897666585401243, 0.46897666585401243, 0.46897666585401243, 0.4719306769461743, 0.4719306769461743, 0.4719306769461743, 0.09557104269361227, 0.09557104269361227, 0.09557104269361227, 0.08330689594274299, 0.08330689594274299, 0.08330689594274299, 0.07954050497500686, 0.07954050497500686, 0.07954050497500686, 0.17003693650035168, 0.17003693650035168, 0.17003693650035168, 0.1727665960167153, 0.1727665960167153, 0.1727665960167153, 0.19181177588507448, 0.19181177588507448, 0.19181177588507448, 0.29159419738273473, 0.29159419738273473, 0.29159419738273473, 0.43156012402752963, 0.43156012402752963, 0.43156012402752963, 0.23772212734820686, 0.23772212734820686, 0.23772212734820686, 0.179101157935998, 0.179101157935998, 0.179101157935998, 0.23185854558977348, 0.23185854558977348, 0.23185854558977348, 0.14199300781636304, 0.14199300781636304, 0.14199300781636304, 0.1986296625214492, 0.1986296625214492, 0.1986296625214492, 0.20368995393303524, 0.20368995393303524, 0.20368995393303524, 0.1867985746406292, 0.1867985746406292, 0.1867985746406292, 0.21745021382879715, 0.21745021382879715, 0.21745021382879715, 0.1988194569253181, 0.1988194569253181, 0.1988194569253181, 0.1960199321050372, 0.1960199321050372, 0.1960199321050372, 0.9320290902497513, 0.9320290902497513, 0.9320290902497513, 0.1585821528627792, 0.1585821528627792, 0.1585821528627792, 0.1677447823221655, 0.1677447823221655, 0.1677447823221655, 0.3115268747516817, 0.3115268747516817, 0.3115268747516817, 0.20908581141117977, 0.20908581141117977, 0.20908581141117977, 0.15428428362244562, 0.15428428362244562, 0.15428428362244562, 0.1768350184314158, 0.1768350184314158, 0.1768350184314158, 0.1811926428322127, 0.1811926428322127, 0.1811926428322127, 0.17035838970782513, 0.17035838970782513, 0.17035838970782513, 0.09367730350067394, 0.09367730350067394, 0.09367730350067394, 0.0747593273272078, 0.0747593273272078, 0.0747593273272078, 0.08251920642697019, 0.08251920642697019, 0.08251920642697019]}, "mutation_prompt": null}
{"id": "6f95bd9c-f23b-45e3-9b4e-24abe935bddc", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.6\n        self.CR = 0.9\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(int(self.rotational_diversity * self.population_size)):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "QuantumAdaptivePSO", "description": "Quantum-Inspired Adaptive Particle Swarm Optimization with Dynamic Rotational Mutation for enhanced exploration-exploitation balance.", "configspace": "", "generation": 49, "fitness": 0.1821554517060754, "feedback": "The algorithm QuantumAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.39919377008608237, 0.39919377008608237, 0.39919377008608237, 0.4425062142648779, 0.4425062142648779, 0.4425062142648779, 0.41405607886341345, 0.41405607886341345, 0.41405607886341345, 0.01203686849803176, 0.01203686849803176, 0.01203686849803176, 0.011896462913535855, 0.011896462913535855, 0.011896462913535855, 0.0016513559722325377, 0.0016513559722325377, 0.0016513559722325377, 0.10160036522084681, 0.10160036522084681, 0.10160036522084681, 0.0992670370778942, 0.0992670370778942, 0.0992670370778942, 0.0795676600189894, 0.0795676600189894, 0.0795676600189894, 0.06933399491437808, 0.06933399491437808, 0.06933399491437808, 0.08323003744694857, 0.08323003744694857, 0.08323003744694857, 0.07846520959494774, 0.07846520959494774, 0.07846520959494774, 0.9950446366386624, 0.9950446366386624, 0.9950446366386624, 0.9914302125838821, 0.9914302125838821, 0.9914302125838821, 0.9871760702808975, 0.9871760702808975, 0.9871760702808975, 0.09628122932583394, 0.09628122932583394, 0.09628122932583394, 0.14033631267836788, 0.14033631267836788, 0.14033631267836788, 0.21282852441769362, 0.21282852441769362, 0.21282852441769362, 0.17748138972937466, 0.17748138972937466, 0.17748138972937466, 0.1564051465006221, 0.1564051465006221, 0.1564051465006221, 0.15644108603997375, 0.15644108603997375, 0.15644108603997375, 0.1073786838283628, 0.1073786838283628, 0.1073786838283628, 0.06693724392992406, 0.06693724392992406, 0.06693724392992406, 0.0716230431819358, 0.0716230431819358, 0.0716230431819358, 0.010269865724062965, 0.010269865724062965, 0.010269865724062965, 0.10255469757034807, 0.10255469757034807, 0.10255469757034807, 0.13772609594359142, 0.13772609594359142, 0.13772609594359142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06635091084919353, 0.06635091084919353, 0.06635091084919353, 0.006704676452660374, 0.006704676452660374, 0.006704676452660374, 0.0291274812145772, 0.0291274812145772, 0.0291274812145772, 0.011348704189327541, 0.011348704189327541, 0.011348704189327541, 0.026681738689025236, 0.026681738689025236, 0.026681738689025236, 0.019176789612634138, 0.019176789612634138, 0.019176789612634138, 0.08265787555521253, 0.08265787555521253, 0.08265787555521253, 0.02429117983492124, 0.02429117983492124, 0.02429117983492124, 0.033489983932563194, 0.033489983932563194, 0.033489983932563194, 0.35735844134369954, 0.35735844134369954, 0.35735844134369954, 0.20185993330460483, 0.20185993330460483, 0.20185993330460483, 0.31981311922381406, 0.31981311922381406, 0.31981311922381406, 0.0753218973270563, 0.0753218973270563, 0.0753218973270563, 0.07484536131339936, 0.07484536131339936, 0.07484536131339936, 0.07144664888592545, 0.07144664888592545, 0.07144664888592545, 0.19574983015898673, 0.19574983015898673, 0.19574983015898673, 0.13943431690848485, 0.13943431690848485, 0.13943431690848485, 0.19322671012797077, 0.19322671012797077, 0.19322671012797077, 0.2006143399136907, 0.2006143399136907, 0.2006143399136907, 0.26561483764252625, 0.26561483764252625, 0.26561483764252625, 0.2366707029210573, 0.2366707029210573, 0.2366707029210573, 0.12257633478678454, 0.12257633478678454, 0.12257633478678454, 0.15678241565753492, 0.15678241565753492, 0.15678241565753492, 0.10959957521489339, 0.10959957521489339, 0.10959957521489339, 0.18323427525088043, 0.18323427525088043, 0.18323427525088043, 0.19434828533356374, 0.19434828533356374, 0.19434828533356374, 0.17691024174918835, 0.17691024174918835, 0.17691024174918835, 0.18574579946243053, 0.18574579946243053, 0.18574579946243053, 0.18048972550847175, 0.18048972550847175, 0.18048972550847175, 0.16986534388840246, 0.16986534388840246, 0.16986534388840246, 0.5214835314123196, 0.5214835314123196, 0.5214835314123196, 0.45516960239109705, 0.45516960239109705, 0.45516960239109705, 0.19135454224185766, 0.19135454224185766, 0.19135454224185766, 0.2848618979029619, 0.2848618979029619, 0.2848618979029619, 0.3799215399971666, 0.3799215399971666, 0.3799215399971666, 0.2217797165220713, 0.2217797165220713, 0.2217797165220713, 0.1820186057289439, 0.1820186057289439, 0.1820186057289439, 0.18648326833911966, 0.18648326833911966, 0.18648326833911966, 0.1781446531340949, 0.1781446531340949, 0.1781446531340949, 0.06896830961934375, 0.06896830961934375, 0.06896830961934375, 0.06638490934782726, 0.06638490934782726, 0.06638490934782726, 0.06426517670143184, 0.06426517670143184, 0.06426517670143184]}, "mutation_prompt": null}
{"id": "03611ea4-d1e8-4676-bf76-bb9b4e28f963", "solution": "import numpy as np\n\nclass AdaptiveHybridQuantumPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Changed from 0.3 for improved exploration\n        self.F = 0.7  # Adjusted for better control in mutation\n        self.CR = 0.9  # Increased for higher crossover rate\n        self.rotational_diversity = 0.2  # Increased for more diversity\n        self.mutation_probability = 0.1  # Decreased to focus on quality mutations\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2  # Changed to linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.uniform(0.5, 1, (self.population_size, self.dim))  # Adjusted randomization for r1\n            r2 = np.random.uniform(0.5, 1, (self.population_size, self.dim))  # Adjusted randomization for r2\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)  # Adjusted mutation rate\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveHybridQuantumPSO_DE", "description": "Adaptive Hybrid Quantum PSO-DE with Convergence-Driven Dynamic Parameters for Enhanced Global Optimization.", "configspace": "", "generation": 50, "fitness": 0.22160851565584896, "feedback": "The algorithm AdaptiveHybridQuantumPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.22.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5701276629507386, 0.5701276629507386, 0.5701276629507386, 0.5833571336959829, 0.5833571336959829, 0.5833571336959829, 0.5902674363254534, 0.5902674363254534, 0.5902674363254534, 0.1475343133655399, 0.1475343133655399, 0.1475343133655399, 0.0362968689284775, 0.0362968689284775, 0.0362968689284775, 0.13257512277030858, 0.13257512277030858, 0.13257512277030858, 0.09941471868881602, 0.09941471868881602, 0.09941471868881602, 0.11709144317753195, 0.11709144317753195, 0.11709144317753195, 0.11242195793092191, 0.11242195793092191, 0.11242195793092191, 0.11404764395562228, 0.11404764395562228, 0.11404764395562228, 0.12605823948235317, 0.12605823948235317, 0.12605823948235317, 0.08952730767093575, 0.08952730767093575, 0.08952730767093575, 0.9903752692304837, 0.9903752692304837, 0.9903752692304837, 0.9862665513324713, 0.9862665513324713, 0.9862665513324713, 0.9917160093074462, 0.9917160093074462, 0.9917160093074462, 0.30507626938077226, 0.30507626938077226, 0.30507626938077226, 0.14296995778526977, 0.14296995778526977, 0.14296995778526977, 0.38123446275135076, 0.38123446275135076, 0.38123446275135076, 0.18749302553626068, 0.18749302553626068, 0.18749302553626068, 0.5612800786569381, 0.5612800786569381, 0.5612800786569381, 0.11246929232716207, 0.11246929232716207, 0.11246929232716207, 0.15807944009732933, 0.15807944009732933, 0.15807944009732933, 0.17133642809222582, 0.17133642809222582, 0.17133642809222582, 0.2563038362622604, 0.2563038362622604, 0.2563038362622604, 0.04932613572291533, 0.04932613572291533, 0.04932613572291533, 0.14675104925609594, 0.14675104925609594, 0.14675104925609594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0432646090765445, 0.0432646090765445, 0.0432646090765445, 0.0032831708193625797, 0.0032831708193625797, 0.0032831708193625797, 0.016382967859399966, 0.016382967859399966, 0.016382967859399966, 0.025795544457514752, 0.025795544457514752, 0.025795544457514752, 0.04125424935003508, 0.04125424935003508, 0.04125424935003508, 0.03563293295702774, 0.03563293295702774, 0.03563293295702774, 0.09455613340962865, 0.09455613340962865, 0.09455613340962865, 0.004397323180138302, 0.004397323180138302, 0.004397323180138302, 0.043842765915603765, 0.043842765915603765, 0.043842765915603765, 0.49443307965929173, 0.49443307965929173, 0.49443307965929173, 0.40475145643607435, 0.40475145643607435, 0.40475145643607435, 0.3997328198167597, 0.3997328198167597, 0.3997328198167597, 0.13636573910918126, 0.13636573910918126, 0.13636573910918126, 0.10843151467529366, 0.10843151467529366, 0.10843151467529366, 0.08471848447463781, 0.08471848447463781, 0.08471848447463781, 0.1933988357852664, 0.1933988357852664, 0.1933988357852664, 0.18311281601452223, 0.18311281601452223, 0.18311281601452223, 0.175420786587685, 0.175420786587685, 0.175420786587685, 0.33167232842426386, 0.33167232842426386, 0.33167232842426386, 0.2915966201743322, 0.2915966201743322, 0.2915966201743322, 0.25558681358899993, 0.25558681358899993, 0.25558681358899993, 0.15408578907613557, 0.15408578907613557, 0.15408578907613557, 0.18686113431459028, 0.18686113431459028, 0.18686113431459028, 0.1427293871576747, 0.1427293871576747, 0.1427293871576747, 0.21319404278646847, 0.21319404278646847, 0.21319404278646847, 0.20298057868963715, 0.20298057868963715, 0.20298057868963715, 0.1815925769249257, 0.1815925769249257, 0.1815925769249257, 0.19761519703723096, 0.19761519703723096, 0.19761519703723096, 0.1673978509675409, 0.1673978509675409, 0.1673978509675409, 0.20636294714164105, 0.20636294714164105, 0.20636294714164105, 0.7061988945832287, 0.7061988945832287, 0.7061988945832287, 0.2542883296421956, 0.2542883296421956, 0.2542883296421956, 0.1745741349690626, 0.1745741349690626, 0.1745741349690626, 0.44185954271460237, 0.44185954271460237, 0.44185954271460237, 0.20497471991838978, 0.20497471991838978, 0.20497471991838978, 0.16531417610261745, 0.16531417610261745, 0.16531417610261745, 0.18498688002602326, 0.18498688002602326, 0.18498688002602326, 0.18891700980656778, 0.18891700980656778, 0.18891700980656778, 0.1945620979569046, 0.1945620979569046, 0.1945620979569046, 0.08516354681658644, 0.08516354681658644, 0.08516354681658644, 0.0793341136533725, 0.0793341136533725, 0.0793341136533725, 0.09539153048250537, 0.09539153048250537, 0.09539153048250537]}, "mutation_prompt": null}
{"id": "1d253bc4-4b26-44f6-9a2c-0a318b6cfaf3", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.num_swarms = 3\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, \n                                      (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), \n                                       abs(self.upper_bound - self.lower_bound), \n                                       (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n        swarm_size = self.population_size // self.num_swarms\n\n        while evaluations < self.budget:\n            w = self.w_max * (1 - evaluations / self.budget) + self.w_min\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n\n            for swarm in range(self.num_swarms):\n                start = swarm * swarm_size\n                end = start + swarm_size\n                local_best = np.argmin(p_best_scores[start:end])\n                local_best_position = p_best_positions[start + local_best]\n                velocities[start:end] = (w * velocities[start:end]\n                                         + self.c1 * r1[start:end] * (p_best_positions[start:end] - positions[start:end])\n                                         + self.c2 * r2[start:end] * (local_best_position - positions[start:end]))\n\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDynamicQuantumHybridPSO_DE", "description": "Enhanced Dynamic Quantum-Inspired Hybrid PSO-DE leveraging Multi-Swarm and Adaptive Velocity Adjustment for robust optimization.", "configspace": "", "generation": 51, "fitness": 0.16009454005411858, "feedback": "The algorithm EnhancedDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.20.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.40168605609262664, 0.40168605609262664, 0.40168605609262664, 0.3344140844025706, 0.3344140844025706, 0.3344140844025706, 0.21833507628525695, 0.21833507628525695, 0.21833507628525695, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00580844372153877, 0.00580844372153877, 0.00580844372153877, 0.06971856647322727, 0.06971856647322727, 0.06971856647322727, 0.08414828371027416, 0.08414828371027416, 0.08414828371027416, 0.08715707995624777, 0.08715707995624777, 0.08715707995624777, 0.06418159390138212, 0.06418159390138212, 0.06418159390138212, 0.06743486551400946, 0.06743486551400946, 0.06743486551400946, 0.079079016984127, 0.079079016984127, 0.079079016984127, 0.9835390716140215, 0.9835390716140215, 0.9835390716140215, 0.9848051484998208, 0.9848051484998208, 0.9848051484998208, 0.9920283501470621, 0.9920283501470621, 0.9920283501470621, 0.15722760513868161, 0.15722760513868161, 0.15722760513868161, 0.10027897211498382, 0.10027897211498382, 0.10027897211498382, 0.08167674402381941, 0.08167674402381941, 0.08167674402381941, 0.14978506363622224, 0.14978506363622224, 0.14978506363622224, 0.16007327137903982, 0.16007327137903982, 0.16007327137903982, 0.18623042338376616, 0.18623042338376616, 0.18623042338376616, 0.07886451726413723, 0.07886451726413723, 0.07886451726413723, 0.07865476493384671, 0.07865476493384671, 0.07865476493384671, 0.08731595934988723, 0.08731595934988723, 0.08731595934988723, 0.07672951566762753, 0.07672951566762753, 0.07672951566762753, 0.0625304439642761, 0.0625304439642761, 0.0625304439642761, 0.02464852307154375, 0.02464852307154375, 0.02464852307154375, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04021840349863037, 0.04021840349863037, 0.04021840349863037, 0.007195091464400338, 0.007195091464400338, 0.007195091464400338, 0.01453348253066511, 0.01453348253066511, 0.01453348253066511, 0.013939262845298783, 0.013939262845298783, 0.013939262845298783, 0.02244399280041165, 0.02244399280041165, 0.02244399280041165, 0.019783517156502062, 0.019783517156502062, 0.019783517156502062, 0.02037303986393657, 0.02037303986393657, 0.02037303986393657, 0.10566760279364262, 0.10566760279364262, 0.10566760279364262, 0.025887094402786137, 0.025887094402786137, 0.025887094402786137, 0.34624461661327, 0.34624461661327, 0.34624461661327, 0.3017779691915301, 0.3017779691915301, 0.3017779691915301, 0.31086103902890283, 0.31086103902890283, 0.31086103902890283, 0.04763659280726351, 0.04763659280726351, 0.04763659280726351, 0.07866167656328893, 0.07866167656328893, 0.07866167656328893, 0.05704027334973494, 0.05704027334973494, 0.05704027334973494, 0.1528699675375288, 0.1528699675375288, 0.1528699675375288, 0.1574067429310757, 0.1574067429310757, 0.1574067429310757, 0.17880095343156355, 0.17880095343156355, 0.17880095343156355, 0.16221994682143448, 0.16221994682143448, 0.16221994682143448, 0.20905164572413537, 0.20905164572413537, 0.20905164572413537, 0.22231002813563006, 0.22231002813563006, 0.22231002813563006, 0.15401382328478508, 0.15401382328478508, 0.15401382328478508, 0.13945772549670588, 0.13945772549670588, 0.13945772549670588, 0.10298121912442892, 0.10298121912442892, 0.10298121912442892, 0.17301043667298655, 0.17301043667298655, 0.17301043667298655, 0.17254731475692164, 0.17254731475692164, 0.17254731475692164, 0.18451625296257557, 0.18451625296257557, 0.18451625296257557, 0.14283249448736857, 0.14283249448736857, 0.14283249448736857, 0.15546245113539148, 0.15546245113539148, 0.15546245113539148, 0.20281156523064992, 0.20281156523064992, 0.20281156523064992, 0.4326898157444663, 0.4326898157444663, 0.4326898157444663, 0.16180485396631827, 0.16180485396631827, 0.16180485396631827, 0.18240481462309788, 0.18240481462309788, 0.18240481462309788, 0.1711072506959357, 0.1711072506959357, 0.1711072506959357, 0.10481738528918871, 0.10481738528918871, 0.10481738528918871, 0.1787703895577224, 0.1787703895577224, 0.1787703895577224, 0.1868965210368031, 0.1868965210368031, 0.1868965210368031, 0.19215580199496518, 0.19215580199496518, 0.19215580199496518, 0.19289688176078035, 0.19289688176078035, 0.19289688176078035, 0.06335554489677486, 0.06335554489677486, 0.06335554489677486, 0.054502299799407794, 0.054502299799407794, 0.054502299799407794, 0.06599766065763357, 0.06599766065763357, 0.06599766065763357]}, "mutation_prompt": null}
{"id": "e29fd7f9-07b6-4524-9b2f-939d16f351fd", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.9  # Slightly increased for exploration\n        self.CR = 0.8  # Slightly decreased for exploitation\n        self.restart_probability = 0.1  # Probability to restart individuals\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2  # Non-linear inertia increase\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(0.2 * self.population_size)  # Modified clone count\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.restart_probability:  # Apply stochastic restarts\n                restart_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in restart_indices:\n                    positions[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumPSO_DE", "description": "Adaptive Quantum PSO-DE with Stochastic Restarts and Enhanced Mutation Control for global optimization.", "configspace": "", "generation": 52, "fitness": 0.19884884285413595, "feedback": "The algorithm AdaptiveQuantumPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5469823713574189, 0.5469823713574189, 0.5469823713574189, 0.5335984059337546, 0.5335984059337546, 0.5335984059337546, 0.4704255982215588, 0.4704255982215588, 0.4704255982215588, 0.13727236273120091, 0.13727236273120091, 0.13727236273120091, 0.13489506450120348, 0.13489506450120348, 0.13489506450120348, 0.17143083431345818, 0.17143083431345818, 0.17143083431345818, 0.10339926100471108, 0.10339926100471108, 0.10339926100471108, 0.12013357322830343, 0.12013357322830343, 0.12013357322830343, 0.1052303792860394, 0.1052303792860394, 0.1052303792860394, 0.0879007905542114, 0.0879007905542114, 0.0879007905542114, 0.07351828476868905, 0.07351828476868905, 0.07351828476868905, 0.08725533689540532, 0.08725533689540532, 0.08725533689540532, 0.9843614222900351, 0.9843614222900351, 0.9843614222900351, 0.9872122687918577, 0.9872122687918577, 0.9872122687918577, 0.9917634096967879, 0.9917634096967879, 0.9917634096967879, 0.2229586754914361, 0.2229586754914361, 0.2229586754914361, 0.17503484786455026, 0.17503484786455026, 0.17503484786455026, 0.28876968909416545, 0.28876968909416545, 0.28876968909416545, 0.2165194940941132, 0.2165194940941132, 0.2165194940941132, 0.19051056476751038, 0.19051056476751038, 0.19051056476751038, 0.1312228327876801, 0.1312228327876801, 0.1312228327876801, 0.13058391410923087, 0.13058391410923087, 0.13058391410923087, 0.06613751371263787, 0.06613751371263787, 0.06613751371263787, 0.12989615975262514, 0.12989615975262514, 0.12989615975262514, 0.030648314792314668, 0.030648314792314668, 0.030648314792314668, 0.10380396660295266, 0.10380396660295266, 0.10380396660295266, 0.07796987578349124, 0.07796987578349124, 0.07796987578349124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019167872609207937, 0.019167872609207937, 0.019167872609207937, 0.01387294772229164, 0.01387294772229164, 0.01387294772229164, 0.035675615080047685, 0.035675615080047685, 0.035675615080047685, 0.03690751304359641, 0.03690751304359641, 0.03690751304359641, 0.03600369532032144, 0.03600369532032144, 0.03600369532032144, 0.05570491519441079, 0.05570491519441079, 0.05570491519441079, 0.024093150833317645, 0.024093150833317645, 0.024093150833317645, 0.03933825834342042, 0.03933825834342042, 0.03933825834342042, 0.04126402259462425, 0.04126402259462425, 0.04126402259462425, 0.3702654776066735, 0.3702654776066735, 0.3702654776066735, 0.3976931829581737, 0.3976931829581737, 0.3976931829581737, 0.3885793633545259, 0.3885793633545259, 0.3885793633545259, 0.05900379696839242, 0.05900379696839242, 0.05900379696839242, 0.08989420755645827, 0.08989420755645827, 0.08989420755645827, 0.0969559466553741, 0.0969559466553741, 0.0969559466553741, 0.1454371962589215, 0.1454371962589215, 0.1454371962589215, 0.22548924237754064, 0.22548924237754064, 0.22548924237754064, 0.1471905035829515, 0.1471905035829515, 0.1471905035829515, 0.22513397604560748, 0.22513397604560748, 0.22513397604560748, 0.24057710365270357, 0.24057710365270357, 0.24057710365270357, 0.22294602239792427, 0.22294602239792427, 0.22294602239792427, 0.15214384876002118, 0.15214384876002118, 0.15214384876002118, 0.1468240602058335, 0.1468240602058335, 0.1468240602058335, 0.1422739389989751, 0.1422739389989751, 0.1422739389989751, 0.1886335672538576, 0.1886335672538576, 0.1886335672538576, 0.19257759558719723, 0.19257759558719723, 0.19257759558719723, 0.19717852326405105, 0.19717852326405105, 0.19717852326405105, 0.18005069483449931, 0.18005069483449931, 0.18005069483449931, 0.16871531920330085, 0.16871531920330085, 0.16871531920330085, 0.18552324155918976, 0.18552324155918976, 0.18552324155918976, 0.6271018332545377, 0.6271018332545377, 0.6271018332545377, 0.16612248889878922, 0.16612248889878922, 0.16612248889878922, 0.16446109208419946, 0.16446109208419946, 0.16446109208419946, 0.3492707992270567, 0.3492707992270567, 0.3492707992270567, 0.19219744529355942, 0.19219744529355942, 0.19219744529355942, 0.25307575057012055, 0.25307575057012055, 0.25307575057012055, 0.18627048387057, 0.18627048387057, 0.18627048387057, 0.1954056064714157, 0.1954056064714157, 0.1954056064714157, 0.18704061335734956, 0.18704061335734956, 0.18704061335734956, 0.07470984877738096, 0.07470984877738096, 0.07470984877738096, 0.07086675191542968, 0.07086675191542968, 0.07086675191542968, 0.08574395952662739, 0.08574395952662739, 0.08574395952662739]}, "mutation_prompt": null}
{"id": "06956b0c-11d7-45aa-b872-2eea42328acd", "solution": "import numpy as np\n\nclass AdaptiveNeurodynamicHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.8\n        self.w_min = 0.4\n        self.F = 0.9\n        self.CR = 0.9\n        self.neurodynamic_feedback = 0.25\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2  # Adaptive inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            feedback_count = int(self.neurodynamic_feedback * self.population_size)\n            for i in range(feedback_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveNeurodynamicHybridPSO_DE", "description": "Adaptive Neurodynamic-Inspired Hybrid PSO-DE utilizing Stochastic Population Feedback and Non-linear Mutation for enhanced exploratory efficiency.", "configspace": "", "generation": 53, "fitness": 0.20300988264480463, "feedback": "The algorithm AdaptiveNeurodynamicHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.22.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.48023852641302867, 0.48023852641302867, 0.48023852641302867, 0.5279274202173663, 0.5279274202173663, 0.5279274202173663, 0.5058861890954591, 0.5058861890954591, 0.5058861890954591, 0.1443593103474199, 0.1443593103474199, 0.1443593103474199, 0.027161517845053273, 0.027161517845053273, 0.027161517845053273, 0.003534021516298669, 0.003534021516298669, 0.003534021516298669, 0.11836467064894374, 0.11836467064894374, 0.11836467064894374, 0.0644574632607322, 0.0644574632607322, 0.0644574632607322, 0.10933688889300486, 0.10933688889300486, 0.10933688889300486, 0.08875944612235176, 0.08875944612235176, 0.08875944612235176, 0.060509992121268286, 0.060509992121268286, 0.060509992121268286, 0.11762878954086009, 0.11762878954086009, 0.11762878954086009, 0.9822391188336368, 0.9822391188336368, 0.9822391188336368, 0.9832988557431711, 0.9832988557431711, 0.9832988557431711, 0.9826719813437071, 0.9826719813437071, 0.9826719813437071, 0.23386209972948502, 0.23386209972948502, 0.23386209972948502, 0.14131824471933963, 0.14131824471933963, 0.14131824471933963, 0.18731709614569192, 0.18731709614569192, 0.18731709614569192, 0.16809889574176673, 0.16809889574176673, 0.16809889574176673, 0.15418865070781174, 0.15418865070781174, 0.15418865070781174, 0.136098253237804, 0.136098253237804, 0.136098253237804, 0.1333057366965439, 0.1333057366965439, 0.1333057366965439, 0.11072990231927182, 0.11072990231927182, 0.11072990231927182, 0.1507354905058057, 0.1507354905058057, 0.1507354905058057, 0.040403440983210026, 0.040403440983210026, 0.040403440983210026, 0.13819573700579546, 0.13819573700579546, 0.13819573700579546, 0.030568158888368058, 0.030568158888368058, 0.030568158888368058, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005684164644692125, 0.005684164644692125, 0.005684164644692125, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06482312831987724, 0.06482312831987724, 0.06482312831987724, 0.036903370190433105, 0.036903370190433105, 0.036903370190433105, 0.07381262048944859, 0.07381262048944859, 0.07381262048944859, 0.02804203364376534, 0.02804203364376534, 0.02804203364376534, 0.0402653401209655, 0.0402653401209655, 0.0402653401209655, 0.03873916824141821, 0.03873916824141821, 0.03873916824141821, 0.11424497646685117, 0.11424497646685117, 0.11424497646685117, 0.031041970006577824, 0.031041970006577824, 0.031041970006577824, 0.04029810296633296, 0.04029810296633296, 0.04029810296633296, 0.3838620035138056, 0.3838620035138056, 0.3838620035138056, 0.4195503161169858, 0.4195503161169858, 0.4195503161169858, 0.41655036207122, 0.41655036207122, 0.41655036207122, 0.11048786254032461, 0.11048786254032461, 0.11048786254032461, 0.09079774607391677, 0.09079774607391677, 0.09079774607391677, 0.08953424868555393, 0.08953424868555393, 0.08953424868555393, 0.16433545406663286, 0.16433545406663286, 0.16433545406663286, 0.1792412118690454, 0.1792412118690454, 0.1792412118690454, 0.18862314266910052, 0.18862314266910052, 0.18862314266910052, 0.23471085367451083, 0.23471085367451083, 0.23471085367451083, 0.26663461104581865, 0.26663461104581865, 0.26663461104581865, 0.2544411576742356, 0.2544411576742356, 0.2544411576742356, 0.14548077301977613, 0.14548077301977613, 0.14548077301977613, 0.17528388467393474, 0.17528388467393474, 0.17528388467393474, 0.1520972747286985, 0.1520972747286985, 0.1520972747286985, 0.17736417919869185, 0.17736417919869185, 0.17736417919869185, 0.18386374100740688, 0.18386374100740688, 0.18386374100740688, 0.17779112653851992, 0.17779112653851992, 0.17779112653851992, 0.18709055007195297, 0.18709055007195297, 0.18709055007195297, 0.1995597096176086, 0.1995597096176086, 0.1995597096176086, 0.18009250804848365, 0.18009250804848365, 0.18009250804848365, 0.7213632173589757, 0.7213632173589757, 0.7213632173589757, 0.6061217269768425, 0.6061217269768425, 0.6061217269768425, 0.19396531203299017, 0.19396531203299017, 0.19396531203299017, 0.1593147474725043, 0.1593147474725043, 0.1593147474725043, 0.1978332427273034, 0.1978332427273034, 0.1978332427273034, 0.276635121742807, 0.276635121742807, 0.276635121742807, 0.16874569105184722, 0.16874569105184722, 0.16874569105184722, 0.18248656313212053, 0.18248656313212053, 0.18248656313212053, 0.1939612693776055, 0.1939612693776055, 0.1939612693776055, 0.08762841698819701, 0.08762841698819701, 0.08762841698819701, 0.07304207122991246, 0.07304207122991246, 0.07304207122991246, 0.08297067971504479, 0.08297067971504479, 0.08297067971504479]}, "mutation_prompt": null}
{"id": "06fda5da-e4e9-4eea-a46c-5e93c2aec9e9", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted to allow more exploration initially\n        self.F = 0.7  # Slightly reduced for more stable mutation\n        self.CR = 0.9  # Increased to promote crossover\n        self.rotational_diversity = 0.2  # Increased to enhance diversity\n        self.mutation_probability = 0.2  # Increased to introduce more randomness\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.sqrt(evaluations / self.budget)  # Non-linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)  # Increased mutation size\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDynamicQuantumHybridPSO_DE", "description": "Enhanced Dynamic Quantum-Inspired Hybrid PSO-DE with Adaptive Parameter Control and Strategic Exploration for improved convergence.", "configspace": "", "generation": 54, "fitness": 0.2276667690971052, "feedback": "The algorithm EnhancedDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.6370039598072603, 0.6370039598072603, 0.6370039598072603, 0.6259350023295694, 0.6259350023295694, 0.6259350023295694, 0.6335167068057679, 0.6335167068057679, 0.6335167068057679, 0.21331782371912378, 0.21331782371912378, 0.21331782371912378, 0.23443249836329483, 0.23443249836329483, 0.23443249836329483, 0.19810967023107828, 0.19810967023107828, 0.19810967023107828, 0.12441717385759299, 0.12441717385759299, 0.12441717385759299, 0.13001480385156228, 0.13001480385156228, 0.13001480385156228, 0.07794031716464744, 0.07794031716464744, 0.07794031716464744, 0.12153182438759536, 0.12153182438759536, 0.12153182438759536, 0.11351817085539584, 0.11351817085539584, 0.11351817085539584, 0.11889066384735325, 0.11889066384735325, 0.11889066384735325, 0.9843628118265703, 0.9843628118265703, 0.9843628118265703, 0.9855177833398526, 0.9855177833398526, 0.9855177833398526, 0.991715472056498, 0.991715472056498, 0.991715472056498, 0.3200979065900147, 0.3200979065900147, 0.3200979065900147, 0.14569629436536402, 0.14569629436536402, 0.14569629436536402, 0.30539818157343823, 0.30539818157343823, 0.30539818157343823, 0.3123152637602148, 0.3123152637602148, 0.3123152637602148, 0.15350042127908436, 0.15350042127908436, 0.15350042127908436, 0.11312849179487461, 0.11312849179487461, 0.11312849179487461, 0.1443601820103222, 0.1443601820103222, 0.1443601820103222, 0.1284341156309925, 0.1284341156309925, 0.1284341156309925, 0.1478300670520275, 0.1478300670520275, 0.1478300670520275, 0.12086259039338054, 0.12086259039338054, 0.12086259039338054, 0.1504526155323983, 0.1504526155323983, 0.1504526155323983, 0.11988227126714135, 0.11988227126714135, 0.11988227126714135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02742923142093112, 0.02742923142093112, 0.02742923142093112, 0.007745787207396493, 0.007745787207396493, 0.007745787207396493, 0.032227120942338705, 0.032227120942338705, 0.032227120942338705, 0.03088296413815117, 0.03088296413815117, 0.03088296413815117, 0.0521088271642004, 0.0521088271642004, 0.0521088271642004, 0.05240821105323845, 0.05240821105323845, 0.05240821105323845, 0.006768688025594161, 0.006768688025594161, 0.006768688025594161, 0.058171091818649434, 0.058171091818649434, 0.058171091818649434, 0.04281968679835735, 0.04281968679835735, 0.04281968679835735, 0.4383947495625631, 0.4383947495625631, 0.4383947495625631, 0.4582223041009008, 0.4582223041009008, 0.4582223041009008, 0.43331365687388557, 0.43331365687388557, 0.43331365687388557, 0.0991300632533304, 0.0991300632533304, 0.0991300632533304, 0.12475399399131748, 0.12475399399131748, 0.12475399399131748, 0.09675551662924065, 0.09675551662924065, 0.09675551662924065, 0.17664176038260726, 0.17664176038260726, 0.17664176038260726, 0.3044949987834704, 0.3044949987834704, 0.3044949987834704, 0.17614277802199507, 0.17614277802199507, 0.17614277802199507, 0.2415019428143329, 0.2415019428143329, 0.2415019428143329, 0.217389524218221, 0.217389524218221, 0.217389524218221, 0.27048820301418064, 0.27048820301418064, 0.27048820301418064, 0.11531222851152434, 0.11531222851152434, 0.11531222851152434, 0.17744437435092364, 0.17744437435092364, 0.17744437435092364, 0.1500231985252054, 0.1500231985252054, 0.1500231985252054, 0.19532699497244255, 0.19532699497244255, 0.19532699497244255, 0.2001459328839944, 0.2001459328839944, 0.2001459328839944, 0.17964095748888576, 0.17964095748888576, 0.17964095748888576, 0.22933710742552704, 0.22933710742552704, 0.22933710742552704, 0.215620418638798, 0.215620418638798, 0.215620418638798, 0.19678981246046146, 0.19678981246046146, 0.19678981246046146, 0.7236833803527141, 0.7236833803527141, 0.7236833803527141, 0.1664212046424236, 0.1664212046424236, 0.1664212046424236, 0.16561320270436286, 0.16561320270436286, 0.16561320270436286, 0.33394477789274557, 0.33394477789274557, 0.33394477789274557, 0.5731667102195204, 0.5731667102195204, 0.5731667102195204, 0.3016964600904054, 0.3016964600904054, 0.3016964600904054, 0.17894701377082056, 0.17894701377082056, 0.17894701377082056, 0.17703409282143934, 0.17703409282143934, 0.17703409282143934, 0.18754125251733444, 0.18754125251733444, 0.18754125251733444, 0.0773974701114798, 0.0773974701114798, 0.0773974701114798, 0.06751975691975254, 0.06751975691975254, 0.06751975691975254, 0.07912684378349477, 0.07912684378349477, 0.07912684378349477]}, "mutation_prompt": null}
{"id": "c0b24706-a9dc-4ce8-87cf-6134a5412962", "solution": "import numpy as np\n\nclass AdaptiveSwarmClusteredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted lower inertia bound for better local search\n        self.F = 0.75  # Slightly adjusted\n        self.CR = 0.9  # Increased crossover rate for diversity\n        self.rotational_diversity = 0.2  # Increased diversity\n        self.mutation_probability = 0.2  # Increased mutation probability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2  # Quadratic inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)  # Increased mutation size\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveSwarmClusteredPSO_DE", "description": "Adaptive Swarm-Clustered Hybrid PSO-DE integrating Non-linear Inertia and Stochastic Differential Strategy for enhanced exploration-exploitation balance.", "configspace": "", "generation": 55, "fitness": 0.18270467337327823, "feedback": "The algorithm AdaptiveSwarmClusteredPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.40278861139546773, 0.40278861139546773, 0.40278861139546773, 0.43619792660822465, 0.43619792660822465, 0.43619792660822465, 0.4050548887496642, 0.4050548887496642, 0.4050548887496642, 0.04707625105062341, 0.04707625105062341, 0.04707625105062341, 0.007329026644181114, 0.007329026644181114, 0.007329026644181114, 0.0020701176889459383, 0.0020701176889459383, 0.0020701176889459383, 0.07689474787958062, 0.07689474787958062, 0.07689474787958062, 0.06384328122631, 0.06384328122631, 0.06384328122631, 0.08448205532220365, 0.08448205532220365, 0.08448205532220365, 0.05967901299554612, 0.05967901299554612, 0.05967901299554612, 0.07420800510066528, 0.07420800510066528, 0.07420800510066528, 0.07627532499935163, 0.07627532499935163, 0.07627532499935163, 0.984356519549661, 0.984356519549661, 0.984356519549661, 0.9855200260447285, 0.9855200260447285, 0.9855200260447285, 0.991715472056498, 0.991715472056498, 0.991715472056498, 0.09079221190744868, 0.09079221190744868, 0.09079221190744868, 0.13220737673956318, 0.13220737673956318, 0.13220737673956318, 0.16234341104762784, 0.16234341104762784, 0.16234341104762784, 0.20679051764506717, 0.20679051764506717, 0.20679051764506717, 0.18463622371442656, 0.18463622371442656, 0.18463622371442656, 0.18358006571414487, 0.18358006571414487, 0.18358006571414487, 0.0836172594325959, 0.0836172594325959, 0.0836172594325959, 0.06738515476633944, 0.06738515476633944, 0.06738515476633944, 0.1104675728981801, 0.1104675728981801, 0.1104675728981801, 0.11528373663655145, 0.11528373663655145, 0.11528373663655145, 0.10291709991474474, 0.10291709991474474, 0.10291709991474474, 0.10319223057006788, 0.10319223057006788, 0.10319223057006788, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003815509932199035, 0.0003815509932199035, 0.0003815509932199035, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0758335403589886, 0.0758335403589886, 0.0758335403589886, 0.010880118897659496, 0.010880118897659496, 0.010880118897659496, 0.0352000853501373, 0.0352000853501373, 0.0352000853501373, 0.011036881454019376, 0.011036881454019376, 0.011036881454019376, 0.02006508717544131, 0.02006508717544131, 0.02006508717544131, 0.04566556041853309, 0.04566556041853309, 0.04566556041853309, 0.002816582830031611, 0.002816582830031611, 0.002816582830031611, 0.007535496292673471, 0.007535496292673471, 0.007535496292673471, 0.03568818847463462, 0.03568818847463462, 0.03568818847463462, 0.33265409569711124, 0.33265409569711124, 0.33265409569711124, 0.28161613589913503, 0.28161613589913503, 0.28161613589913503, 0.32890728179198436, 0.32890728179198436, 0.32890728179198436, 0.08141082187214799, 0.08141082187214799, 0.08141082187214799, 0.08110178689733893, 0.08110178689733893, 0.08110178689733893, 0.06522990457436995, 0.06522990457436995, 0.06522990457436995, 0.1767240682073119, 0.1767240682073119, 0.1767240682073119, 0.1422292091298354, 0.1422292091298354, 0.1422292091298354, 0.15741905243103826, 0.15741905243103826, 0.15741905243103826, 0.21456899851990074, 0.21456899851990074, 0.21456899851990074, 0.260797972340709, 0.260797972340709, 0.260797972340709, 0.2126301339056036, 0.2126301339056036, 0.2126301339056036, 0.20051792229025267, 0.20051792229025267, 0.20051792229025267, 0.1651815868146823, 0.1651815868146823, 0.1651815868146823, 0.1894355151439432, 0.1894355151439432, 0.1894355151439432, 0.18188139672288994, 0.18188139672288994, 0.18188139672288994, 0.16341412000104716, 0.16341412000104716, 0.16341412000104716, 0.1872233466100388, 0.1872233466100388, 0.1872233466100388, 0.16593750797399132, 0.16593750797399132, 0.16593750797399132, 0.1763026929674606, 0.1763026929674606, 0.1763026929674606, 0.18286039737755033, 0.18286039737755033, 0.18286039737755033, 0.6077917117114766, 0.6077917117114766, 0.6077917117114766, 0.1678240334249287, 0.1678240334249287, 0.1678240334249287, 0.44913065024729126, 0.44913065024729126, 0.44913065024729126, 0.19317266260991806, 0.19317266260991806, 0.19317266260991806, 0.30034895160404607, 0.30034895160404607, 0.30034895160404607, 0.24297142813698247, 0.24297142813698247, 0.24297142813698247, 0.20112088265553274, 0.20112088265553274, 0.20112088265553274, 0.1783979409195655, 0.1783979409195655, 0.1783979409195655, 0.1872493018282616, 0.1872493018282616, 0.1872493018282616, 0.06314775357663749, 0.06314775357663749, 0.06314775357663749, 0.06099275563742845, 0.06099275563742845, 0.06099275563742845, 0.06853724281187445, 0.06853724281187445, 0.06853724281187445]}, "mutation_prompt": null}
{"id": "f324718e-08a5-4936-b65a-9a28f7bede4d", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.2  # Altered for increased variation\n        self.F = 0.85  # Slightly increased for better exploration\n        self.CR = 0.9  # Slightly increased for better information exchange\n        self.rotational_diversity = 0.1  # Reduced to focus more on mutation\n        self.mutation_probability = 0.2  # Increased probability for mutation\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 3  # Cubic inertia decay for smoother reduction\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            mutation_indices = np.random.choice(self.population_size, size=int(self.mutation_probability * self.population_size), replace=False)\n            for idx in mutation_indices:\n                mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                positions[idx] = mutation_vector\n                score = func(positions[idx])\n                evaluations += 1\n                if score < p_best_scores[idx]:\n                    p_best_scores[idx] = score\n                    p_best_positions[idx] = positions[idx]\n                    if score < g_best_score:\n                        g_best_score = score\n                        g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired PSO-DE with Rotational Diversity and Mutation Enhancement for robust global exploration.", "configspace": "", "generation": 56, "fitness": 0.20931061890116923, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.6300139340749356, 0.6300139340749356, 0.6300139340749356, 0.4656337961639412, 0.4656337961639412, 0.4656337961639412, 0.5632471077623589, 0.5632471077623589, 0.5632471077623589, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013630020011584199, 0.013630020011584199, 0.013630020011584199, 0.1500803255966484, 0.1500803255966484, 0.1500803255966484, 0.12438686887546924, 0.12438686887546924, 0.12438686887546924, 0.1281731381402227, 0.1281731381402227, 0.1281731381402227, 0.11379710835940027, 0.11379710835940027, 0.11379710835940027, 0.10294139724216844, 0.10294139724216844, 0.10294139724216844, 0.08083018801377673, 0.08083018801377673, 0.08083018801377673, 0.966317458671575, 0.966317458671575, 0.966317458671575, 0.9700606647128092, 0.9700606647128092, 0.9700606647128092, 0.9703481033198597, 0.9703481033198597, 0.9703481033198597, 0.21025455850359953, 0.21025455850359953, 0.21025455850359953, 0.23833974482014386, 0.23833974482014386, 0.23833974482014386, 0.23871386207781142, 0.23871386207781142, 0.23871386207781142, 0.20368275130135094, 0.20368275130135094, 0.20368275130135094, 0.25530959565554967, 0.25530959565554967, 0.25530959565554967, 0.23271193350177632, 0.23271193350177632, 0.23271193350177632, 0.1660940837322411, 0.1660940837322411, 0.1660940837322411, 0.1538364603325446, 0.1538364603325446, 0.1538364603325446, 0.13893359712339337, 0.13893359712339337, 0.13893359712339337, 0.11299155742870515, 0.11299155742870515, 0.11299155742870515, 0.12137055203707992, 0.12137055203707992, 0.12137055203707992, 0.16666517850848084, 0.16666517850848084, 0.16666517850848084, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05500790138757783, 0.05500790138757783, 0.05500790138757783, 0.04829739154761392, 0.04829739154761392, 0.04829739154761392, 0.04291167820389752, 0.04291167820389752, 0.04291167820389752, 0.047193341850750636, 0.047193341850750636, 0.047193341850750636, 0.016587351969105435, 0.016587351969105435, 0.016587351969105435, 0.019021131723165663, 0.019021131723165663, 0.019021131723165663, 0.0920852694983405, 0.0920852694983405, 0.0920852694983405, 0.05803848256160504, 0.05803848256160504, 0.05803848256160504, 0.0488634221315124, 0.0488634221315124, 0.0488634221315124, 0.3753287474103142, 0.3753287474103142, 0.3753287474103142, 0.37293757284057916, 0.37293757284057916, 0.37293757284057916, 0.4308079824072002, 0.4308079824072002, 0.4308079824072002, 0.05948898518133028, 0.05948898518133028, 0.05948898518133028, 0.08650050965948908, 0.08650050965948908, 0.08650050965948908, 0.06882075585844583, 0.06882075585844583, 0.06882075585844583, 0.16672621960474976, 0.16672621960474976, 0.16672621960474976, 0.15330947718983956, 0.15330947718983956, 0.15330947718983956, 0.23135731382326397, 0.23135731382326397, 0.23135731382326397, 0.3002706148849932, 0.3002706148849932, 0.3002706148849932, 0.2770064382513858, 0.2770064382513858, 0.2770064382513858, 0.2743081627038044, 0.2743081627038044, 0.2743081627038044, 0.1441639438597393, 0.1441639438597393, 0.1441639438597393, 0.16671823002070107, 0.16671823002070107, 0.16671823002070107, 0.1813697695150256, 0.1813697695150256, 0.1813697695150256, 0.20190099678083762, 0.20190099678083762, 0.20190099678083762, 0.18342095312976447, 0.18342095312976447, 0.18342095312976447, 0.19475955659222088, 0.19475955659222088, 0.19475955659222088, 0.17927581174264196, 0.17927581174264196, 0.17927581174264196, 0.17720526633910905, 0.17720526633910905, 0.17720526633910905, 0.2078356886316497, 0.2078356886316497, 0.2078356886316497, 0.8151726733098184, 0.8151726733098184, 0.8151726733098184, 0.15774889082910648, 0.15774889082910648, 0.15774889082910648, 0.16974213754945244, 0.16974213754945244, 0.16974213754945244, 0.4208457138556553, 0.4208457138556553, 0.4208457138556553, 0.2074128512993233, 0.2074128512993233, 0.2074128512993233, 0.15591960432162866, 0.15591960432162866, 0.15591960432162866, 0.17520639204758448, 0.17520639204758448, 0.17520639204758448, 0.18547845743676084, 0.18547845743676084, 0.18547845743676084, 0.17123544346467168, 0.17123544346467168, 0.17123544346467168, 0.07521449560750426, 0.07521449560750426, 0.07521449560750426, 0.07537863536872114, 0.07537863536872114, 0.07537863536872114, 0.0806263125258776, 0.0806263125258776, 0.0806263125258776]}, "mutation_prompt": null}
{"id": "6f197742-d4ef-4bcd-9d83-926b7fd0a2c4", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.diversity_threshold = 0.1\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            diversity = np.mean(np.std(positions, axis=0))\n            if diversity < self.diversity_threshold:\n                self.mutation_probability = 0.3\n\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumPSO_DE", "description": "Improved Quantum-Inspired Hybrid PSO with Adaptive Diversity Control and Dynamic Inertia for enhanced convergence.", "configspace": "", "generation": 57, "fitness": 0.19363762520117153, "feedback": "The algorithm AdaptiveQuantumPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.43039528344929845, 0.43039528344929845, 0.43039528344929845, 0.4566613664404403, 0.4566613664404403, 0.4566613664404403, 0.4782512730376761, 0.4782512730376761, 0.4782512730376761, 0.023308095939047035, 0.023308095939047035, 0.023308095939047035, 0.1145846278223176, 0.1145846278223176, 0.1145846278223176, 0.03654790963584942, 0.03654790963584942, 0.03654790963584942, 0.08301410706442547, 0.08301410706442547, 0.08301410706442547, 0.08707770887470057, 0.08707770887470057, 0.08707770887470057, 0.11296714985029888, 0.11296714985029888, 0.11296714985029888, 0.10973641552577351, 0.10973641552577351, 0.10973641552577351, 0.08733395581695635, 0.08733395581695635, 0.08733395581695635, 0.0773529365967659, 0.0773529365967659, 0.0773529365967659, 0.9815147325933582, 0.9815147325933582, 0.9815147325933582, 0.975186349331928, 0.975186349331928, 0.975186349331928, 0.9892154986497401, 0.9892154986497401, 0.9892154986497401, 0.17017893180087618, 0.17017893180087618, 0.17017893180087618, 0.12518832761766008, 0.12518832761766008, 0.12518832761766008, 0.20318470111410158, 0.20318470111410158, 0.20318470111410158, 0.179345361797704, 0.179345361797704, 0.179345361797704, 0.155703544299289, 0.155703544299289, 0.155703544299289, 0.18295369263462735, 0.18295369263462735, 0.18295369263462735, 0.09960254550147696, 0.09960254550147696, 0.09960254550147696, 0.08543539108493803, 0.08543539108493803, 0.08543539108493803, 0.06588605552531901, 0.06588605552531901, 0.06588605552531901, 0.030865583287564502, 0.030865583287564502, 0.030865583287564502, 0.07785291066741629, 0.07785291066741629, 0.07785291066741629, 0.0990360579700158, 0.0990360579700158, 0.0990360579700158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028296216161887378, 0.028296216161887378, 0.028296216161887378, 0.059009159332252925, 0.059009159332252925, 0.059009159332252925, 0.06863099008569717, 0.06863099008569717, 0.06863099008569717, 0.041720154613008376, 0.041720154613008376, 0.041720154613008376, 0.017728106679627875, 0.017728106679627875, 0.017728106679627875, 0.019395704144853365, 0.019395704144853365, 0.019395704144853365, 0.03820111086783795, 0.03820111086783795, 0.03820111086783795, 0.02379222314446272, 0.02379222314446272, 0.02379222314446272, 0.08627529145401003, 0.08627529145401003, 0.08627529145401003, 0.050547942902159027, 0.050547942902159027, 0.050547942902159027, 0.3460872902021599, 0.3460872902021599, 0.3460872902021599, 0.35942392434521164, 0.35942392434521164, 0.35942392434521164, 0.34400246019453806, 0.34400246019453806, 0.34400246019453806, 0.07464885513145403, 0.07464885513145403, 0.07464885513145403, 0.07369981798005465, 0.07369981798005465, 0.07369981798005465, 0.059236969843466936, 0.059236969843466936, 0.059236969843466936, 0.1467256951037722, 0.1467256951037722, 0.1467256951037722, 0.12463589739787206, 0.12463589739787206, 0.12463589739787206, 0.17068083796792066, 0.17068083796792066, 0.17068083796792066, 0.27572390395061097, 0.27572390395061097, 0.27572390395061097, 0.2660646522153023, 0.2660646522153023, 0.2660646522153023, 0.2255665871046144, 0.2255665871046144, 0.2255665871046144, 0.18468433800098827, 0.18468433800098827, 0.18468433800098827, 0.1416690365071629, 0.1416690365071629, 0.1416690365071629, 0.13770469250565964, 0.13770469250565964, 0.13770469250565964, 0.18236395541835404, 0.18236395541835404, 0.18236395541835404, 0.1821404711698782, 0.1821404711698782, 0.1821404711698782, 0.18252784401660205, 0.18252784401660205, 0.18252784401660205, 0.18025048294803514, 0.18025048294803514, 0.18025048294803514, 0.16981687625966368, 0.16981687625966368, 0.16981687625966368, 0.15584533157497904, 0.15584533157497904, 0.15584533157497904, 0.5855598797559112, 0.5855598797559112, 0.5855598797559112, 0.5412409920879319, 0.5412409920879319, 0.5412409920879319, 0.19686665840923978, 0.19686665840923978, 0.19686665840923978, 0.3020253712029971, 0.3020253712029971, 0.3020253712029971, 0.3176372230423471, 0.3176372230423471, 0.3176372230423471, 0.3243651980539587, 0.3243651980539587, 0.3243651980539587, 0.18495297031776248, 0.18495297031776248, 0.18495297031776248, 0.1730984553708531, 0.1730984553708531, 0.1730984553708531, 0.18136092290846717, 0.18136092290846717, 0.18136092290846717, 0.06768779592028618, 0.06768779592028618, 0.06768779592028618, 0.06294454074788647, 0.06294454074788647, 0.06294454074788647, 0.06849167351304586, 0.06849167351304586, 0.06849167351304586]}, "mutation_prompt": null}
{"id": "054cce4c-f38f-40c2-8513-83ee2548240e", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_start = 2.0\n        self.c2_end = 0.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.9\n        self.CR = 0.8\n        self.rotational_diversity = 0.2\n        self.mutation_probability_start = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n            c1 = self.c1_start - (self.c1_start - self.c2_end) * (evaluations / self.budget)\n            mutation_probability = self.mutation_probability_start + (self.mutation_probability_start * evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + c1 * r1 * (p_best_positions - positions) \n                          + self.c2_end * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Enhanced Mutation Strategy and Adaptive Parameter Tuning for Optimized Global Convergence.", "configspace": "", "generation": 58, "fitness": 0.23864228703091367, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.6581476152388039, 0.6581476152388039, 0.6581476152388039, 0.6483687040854544, 0.6483687040854544, 0.6483687040854544, 0.640925115453316, 0.640925115453316, 0.640925115453316, 0.060419858860764175, 0.060419858860764175, 0.060419858860764175, 0.05650306179958864, 0.05650306179958864, 0.05650306179958864, 0.03982825057215955, 0.03982825057215955, 0.03982825057215955, 0.0932913692613847, 0.0932913692613847, 0.0932913692613847, 0.07110715021378766, 0.07110715021378766, 0.07110715021378766, 0.10417766255404315, 0.10417766255404315, 0.10417766255404315, 0.08973926005799182, 0.08973926005799182, 0.08973926005799182, 0.09929795254242779, 0.09929795254242779, 0.09929795254242779, 0.09633816874509826, 0.09633816874509826, 0.09633816874509826, 0.9771377806584695, 0.9771377806584695, 0.9771377806584695, 0.985158436780124, 0.985158436780124, 0.985158436780124, 0.9917184169397917, 0.9917184169397917, 0.9917184169397917, 0.3741227132174584, 0.3741227132174584, 0.3741227132174584, 0.1918220733284639, 0.1918220733284639, 0.1918220733284639, 0.23667606474345526, 0.23667606474345526, 0.23667606474345526, 0.3042630432949117, 0.3042630432949117, 0.3042630432949117, 0.1875607612897796, 0.1875607612897796, 0.1875607612897796, 0.3896559974426095, 0.3896559974426095, 0.3896559974426095, 0.12354001370017509, 0.12354001370017509, 0.12354001370017509, 0.10616843995793046, 0.10616843995793046, 0.10616843995793046, 0.1281718901587401, 0.1281718901587401, 0.1281718901587401, 0.0712943918692559, 0.0712943918692559, 0.0712943918692559, 0.11705484954411771, 0.11705484954411771, 0.11705484954411771, 0.15416867589404315, 0.15416867589404315, 0.15416867589404315, 0.012151080329500519, 0.012151080329500519, 0.012151080329500519, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07564505691555712, 0.07564505691555712, 0.07564505691555712, 0.08945237839785236, 0.08945237839785236, 0.08945237839785236, 0.10692138090574788, 0.10692138090574788, 0.10692138090574788, 0.04694371225528393, 0.04694371225528393, 0.04694371225528393, 0.04589138980641805, 0.04589138980641805, 0.04589138980641805, 0.06960539387690878, 0.06960539387690878, 0.06960539387690878, 0.1431171724081276, 0.1431171724081276, 0.1431171724081276, 0.0746645110912596, 0.0746645110912596, 0.0746645110912596, 0.04685461046930228, 0.04685461046930228, 0.04685461046930228, 0.46067763960124153, 0.46067763960124153, 0.46067763960124153, 0.42853985345635515, 0.42853985345635515, 0.42853985345635515, 0.4376732826685783, 0.4376732826685783, 0.4376732826685783, 0.07964745098531711, 0.07964745098531711, 0.07964745098531711, 0.11528390698451985, 0.11528390698451985, 0.11528390698451985, 0.13257553457390858, 0.13257553457390858, 0.13257553457390858, 0.23593498421285963, 0.23593498421285963, 0.23593498421285963, 0.14892490418227222, 0.14892490418227222, 0.14892490418227222, 0.16702760700365094, 0.16702760700365094, 0.16702760700365094, 0.2982190924975333, 0.2982190924975333, 0.2982190924975333, 0.34140538811913224, 0.34140538811913224, 0.34140538811913224, 0.302789231165553, 0.302789231165553, 0.302789231165553, 0.19101956055509717, 0.19101956055509717, 0.19101956055509717, 0.18217513400756102, 0.18217513400756102, 0.18217513400756102, 0.21126558712172672, 0.21126558712172672, 0.21126558712172672, 0.17725899915588184, 0.17725899915588184, 0.17725899915588184, 0.20288768799780665, 0.20288768799780665, 0.20288768799780665, 0.1854808550712468, 0.1854808550712468, 0.1854808550712468, 0.19082392503912038, 0.19082392503912038, 0.19082392503912038, 0.16955772927361445, 0.16955772927361445, 0.16955772927361445, 0.18535644885077462, 0.18535644885077462, 0.18535644885077462, 0.6393969518647447, 0.6393969518647447, 0.6393969518647447, 0.6210521691135205, 0.6210521691135205, 0.6210521691135205, 0.6847177166694199, 0.6847177166694199, 0.6847177166694199, 0.19866782606910904, 0.19866782606910904, 0.19866782606910904, 0.2560029797652691, 0.2560029797652691, 0.2560029797652691, 0.43379233863766886, 0.43379233863766886, 0.43379233863766886, 0.18799916350733326, 0.18799916350733326, 0.18799916350733326, 0.18917395776012214, 0.18917395776012214, 0.18917395776012214, 0.17639895391595906, 0.17639895391595906, 0.17639895391595906, 0.08755695902053229, 0.08755695902053229, 0.08755695902053229, 0.08288951546923962, 0.08288951546923962, 0.08288951546923962, 0.07196692724901044, 0.07196692724901044, 0.07196692724901044]}, "mutation_prompt": null}
{"id": "5697991e-f9d8-45e0-9dab-4a1c8a0a9eaa", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.9\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * evaluations / self.budget  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDynamicQuantumHybridPSO_DE", "description": "Enhanced Dynamic Quantum-Inspired Hybrid PSO-DE with Adaptive Diversity and Multi-Swarm Learning for improved exploitation and exploration balance.", "configspace": "", "generation": 59, "fitness": 0.21040676386086787, "feedback": "The algorithm EnhancedDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5825929068336264, 0.5825929068336264, 0.5825929068336264, 0.5795278266370726, 0.5795278266370726, 0.5795278266370726, 0.5767640209833167, 0.5767640209833167, 0.5767640209833167, 0.08351649957654095, 0.08351649957654095, 0.08351649957654095, 0.0595858628086533, 0.0595858628086533, 0.0595858628086533, 0.11083836602743902, 0.11083836602743902, 0.11083836602743902, 0.12459772542210612, 0.12459772542210612, 0.12459772542210612, 0.12004712749655011, 0.12004712749655011, 0.12004712749655011, 0.122649655381175, 0.122649655381175, 0.122649655381175, 0.10373637878608022, 0.10373637878608022, 0.10373637878608022, 0.07843877641530983, 0.07843877641530983, 0.07843877641530983, 0.07653950715219493, 0.07653950715219493, 0.07653950715219493, 0.984350633517705, 0.984350633517705, 0.984350633517705, 0.9855231919678653, 0.9855231919678653, 0.9855231919678653, 0.991715472056498, 0.991715472056498, 0.991715472056498, 0.28644361446888766, 0.28644361446888766, 0.28644361446888766, 0.2676487761925338, 0.2676487761925338, 0.2676487761925338, 0.28292364895636246, 0.28292364895636246, 0.28292364895636246, 0.31551378042000866, 0.31551378042000866, 0.31551378042000866, 0.18646321369523122, 0.18646321369523122, 0.18646321369523122, 0.15563151308310752, 0.15563151308310752, 0.15563151308310752, 0.17783771958350314, 0.17783771958350314, 0.17783771958350314, 0.07821308595242882, 0.07821308595242882, 0.07821308595242882, 0.13403700022887532, 0.13403700022887532, 0.13403700022887532, 0.10524505302048526, 0.10524505302048526, 0.10524505302048526, 0.11069596602073783, 0.11069596602073783, 0.11069596602073783, 0.08386935953707275, 0.08386935953707275, 0.08386935953707275, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027351880268169593, 0.027351880268169593, 0.027351880268169593, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07056153406995436, 0.07056153406995436, 0.07056153406995436, 0.01855825113321785, 0.01855825113321785, 0.01855825113321785, 0.025390112650578667, 0.025390112650578667, 0.025390112650578667, 0.02642554905714911, 0.02642554905714911, 0.02642554905714911, 0.04735294532934209, 0.04735294532934209, 0.04735294532934209, 0.05902214400111028, 0.05902214400111028, 0.05902214400111028, 0.0070541296765610495, 0.0070541296765610495, 0.0070541296765610495, 0.0047430560928029, 0.0047430560928029, 0.0047430560928029, 0.041376697751224656, 0.041376697751224656, 0.041376697751224656, 0.4244751356152239, 0.4244751356152239, 0.4244751356152239, 0.2881657664697175, 0.2881657664697175, 0.2881657664697175, 0.4041253636561247, 0.4041253636561247, 0.4041253636561247, 0.08640167973526147, 0.08640167973526147, 0.08640167973526147, 0.08344938199592711, 0.08344938199592711, 0.08344938199592711, 0.0961492934585132, 0.0961492934585132, 0.0961492934585132, 0.16593708734910984, 0.16593708734910984, 0.16593708734910984, 0.16136932336271004, 0.16136932336271004, 0.16136932336271004, 0.19117719206595107, 0.19117719206595107, 0.19117719206595107, 0.24255165104414889, 0.24255165104414889, 0.24255165104414889, 0.19157906480380227, 0.19157906480380227, 0.19157906480380227, 0.274479185512686, 0.274479185512686, 0.274479185512686, 0.1337834474699775, 0.1337834474699775, 0.1337834474699775, 0.22171649150894468, 0.22171649150894468, 0.22171649150894468, 0.12598108389556328, 0.12598108389556328, 0.12598108389556328, 0.19880272130242616, 0.19880272130242616, 0.19880272130242616, 0.1849104259480998, 0.1849104259480998, 0.1849104259480998, 0.1873655405876804, 0.1873655405876804, 0.1873655405876804, 0.20737894235686316, 0.20737894235686316, 0.20737894235686316, 0.17540787382568646, 0.17540787382568646, 0.17540787382568646, 0.1903681755706903, 0.1903681755706903, 0.1903681755706903, 0.7038095980933821, 0.7038095980933821, 0.7038095980933821, 0.18458387670775422, 0.18458387670775422, 0.18458387670775422, 0.16408089246750113, 0.16408089246750113, 0.16408089246750113, 0.2009758933114697, 0.2009758933114697, 0.2009758933114697, 0.43114131302548686, 0.43114131302548686, 0.43114131302548686, 0.3231519105212799, 0.3231519105212799, 0.3231519105212799, 0.18906533636073886, 0.18906533636073886, 0.18906533636073886, 0.18076383665719098, 0.18076383665719098, 0.18076383665719098, 0.19460753397272146, 0.19460753397272146, 0.19460753397272146, 0.06930269640473141, 0.06930269640473141, 0.06930269640473141, 0.08593864492488301, 0.08593864492488301, 0.08593864492488301, 0.09330765574875954, 0.09330765574875954, 0.09330765574875954]}, "mutation_prompt": null}
{"id": "3946f49f-03f1-4d83-8d3b-aa74218aadaa", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.2  # Slightly adjusted for exploration\n        self.F = 0.85  # Adjusted scaling factor\n        self.CR = 0.9  # Adjusted crossover rate\n        self.rotational_diversity = 0.2  # Increased for diversity\n        self.mutation_probability = 0.2  # Increased for diversity\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget)  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities += (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)  # More mutated individuals\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE utilizing Stochastic Velocity Update and Enhanced Mutation Strategy for robust optimization across varied landscapes.", "configspace": "", "generation": 60, "fitness": 0.10664891822951904, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.19.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.13293938902740987, 0.13293938902740987, 0.13293938902740987, 0.1493376250943722, 0.1493376250943722, 0.1493376250943722, 0.1674535194711656, 0.1674535194711656, 0.1674535194711656, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02182425139506794, 0.02182425139506794, 0.02182425139506794, 0.016766250850555164, 0.016766250850555164, 0.016766250850555164, 0.03473482785960336, 0.03473482785960336, 0.03473482785960336, 0.01190758665195868, 0.01190758665195868, 0.01190758665195868, 0.016790685098176383, 0.016790685098176383, 0.016790685098176383, 0.014336493039787679, 0.014336493039787679, 0.014336493039787679, 0.9844816718699495, 0.9844816718699495, 0.9844816718699495, 0.9860905047947182, 0.9860905047947182, 0.9860905047947182, 0.991719567222052, 0.991719567222052, 0.991719567222052, 0.05991925831873546, 0.05991925831873546, 0.05991925831873546, 0.03528168006135568, 0.03528168006135568, 0.03528168006135568, 0.06275482109771224, 0.06275482109771224, 0.06275482109771224, 0.09023844464617892, 0.09023844464617892, 0.09023844464617892, 0.0766239841239792, 0.0766239841239792, 0.0766239841239792, 0.09406480945760087, 0.09406480945760087, 0.09406480945760087, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009839112106765469, 0.009839112106765469, 0.009839112106765469, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00905385718591134, 0.00905385718591134, 0.00905385718591134, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019444421098473885, 0.019444421098473885, 0.019444421098473885, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17571684354220796, 0.17571684354220796, 0.17571684354220796, 0.14552913704375425, 0.14552913704375425, 0.14552913704375425, 0.1385951634582696, 0.1385951634582696, 0.1385951634582696, 0.03976309431322511, 0.03976309431322511, 0.03976309431322511, 0.044445643419182335, 0.044445643419182335, 0.044445643419182335, 0.024493157840592916, 0.024493157840592916, 0.024493157840592916, 0.13303297183716456, 0.13303297183716456, 0.13303297183716456, 0.12957253741806363, 0.12957253741806363, 0.12957253741806363, 0.12488112699321241, 0.12488112699321241, 0.12488112699321241, 0.15181047930395963, 0.15181047930395963, 0.15181047930395963, 0.12831044658881785, 0.12831044658881785, 0.12831044658881785, 0.14112334609532773, 0.14112334609532773, 0.14112334609532773, 0.08278496477115549, 0.08278496477115549, 0.08278496477115549, 0.0834328969382907, 0.0834328969382907, 0.0834328969382907, 0.08817301450336579, 0.08817301450336579, 0.08817301450336579, 0.12025755956822781, 0.12025755956822781, 0.12025755956822781, 0.11329731437447499, 0.11329731437447499, 0.11329731437447499, 0.12601378104941374, 0.12601378104941374, 0.12601378104941374, 0.07491393973810134, 0.07491393973810134, 0.07491393973810134, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11899122477370183, 0.11899122477370183, 0.11899122477370183, 0.22335957880686652, 0.22335957880686652, 0.22335957880686652, 0.13742818800465761, 0.13742818800465761, 0.13742818800465761, 0.11294341821125964, 0.11294341821125964, 0.11294341821125964, 0.12321422786753466, 0.12321422786753466, 0.12321422786753466, 0.10240270063034185, 0.10240270063034185, 0.10240270063034185, 0.16211790606026355, 0.16211790606026355, 0.16211790606026355, 0.18173869344864946, 0.18173869344864946, 0.18173869344864946, 0.16073480039415733, 0.16073480039415733, 0.16073480039415733, 0.18561809086683545, 0.18561809086683545, 0.18561809086683545, 0.04711321652763778, 0.04711321652763778, 0.04711321652763778, 0.027733307761213077, 0.027733307761213077, 0.027733307761213077, 0.04167657990391638, 0.04167657990391638, 0.04167657990391638]}, "mutation_prompt": null}
{"id": "0f30ff75-ed69-478d-b6a0-c1d1767faf28", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Changed from 0.3 for more exploration\n        self.F = 0.9  # Changed from 0.8 for stronger mutations\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2  # Increased for more frequent mutations\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 3  # Cubic non-linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)  # Increased mutation indices\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE integrating Non-linear Inertia and Randomized Mutation for enhanced search dynamics.", "configspace": "", "generation": 61, "fitness": 0.2350688101747308, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.6353203200978037, 0.6353203200978037, 0.6353203200978037, 0.6445313490212807, 0.6445313490212807, 0.6445313490212807, 0.6712044443559609, 0.6712044443559609, 0.6712044443559609, 0.2156627323385647, 0.2156627323385647, 0.2156627323385647, 0.09011589073774795, 0.09011589073774795, 0.09011589073774795, 0.05714349524577633, 0.05714349524577633, 0.05714349524577633, 0.1474363233551882, 0.1474363233551882, 0.1474363233551882, 0.068201634740641, 0.068201634740641, 0.068201634740641, 0.09311661516833813, 0.09311661516833813, 0.09311661516833813, 0.1064671964583529, 0.1064671964583529, 0.1064671964583529, 0.07531447061744401, 0.07531447061744401, 0.07531447061744401, 0.0899460973072137, 0.0899460973072137, 0.0899460973072137, 0.9809537408059389, 0.9809537408059389, 0.9809537408059389, 0.9808292157088099, 0.9808292157088099, 0.9808292157088099, 0.9778419541007768, 0.9778419541007768, 0.9778419541007768, 0.3291625738147318, 0.3291625738147318, 0.3291625738147318, 0.36012708376305913, 0.36012708376305913, 0.36012708376305913, 0.36280460666702496, 0.36280460666702496, 0.36280460666702496, 0.2221306987426943, 0.2221306987426943, 0.2221306987426943, 0.21849892915328684, 0.21849892915328684, 0.21849892915328684, 0.23225094174430838, 0.23225094174430838, 0.23225094174430838, 0.13069583316416156, 0.13069583316416156, 0.13069583316416156, 0.1603839511578613, 0.1603839511578613, 0.1603839511578613, 0.19682734708737393, 0.19682734708737393, 0.19682734708737393, 0.014511179253357431, 0.014511179253357431, 0.014511179253357431, 0.18955549905501912, 0.18955549905501912, 0.18955549905501912, 0.1303986251683349, 0.1303986251683349, 0.1303986251683349, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05965897489646155, 0.05965897489646155, 0.05965897489646155, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0669654518872167, 0.0669654518872167, 0.0669654518872167, 0.04356866108256674, 0.04356866108256674, 0.04356866108256674, 0.11192307301571969, 0.11192307301571969, 0.11192307301571969, 0.08780080492408082, 0.08780080492408082, 0.08780080492408082, 0.09381596593593244, 0.09381596593593244, 0.09381596593593244, 0.07283576184197715, 0.07283576184197715, 0.07283576184197715, 0.08237996614482435, 0.08237996614482435, 0.08237996614482435, 0.4589651607431402, 0.4589651607431402, 0.4589651607431402, 0.481194999191768, 0.481194999191768, 0.481194999191768, 0.5083722847289394, 0.5083722847289394, 0.5083722847289394, 0.09494180658030094, 0.09494180658030094, 0.09494180658030094, 0.13329310991670884, 0.13329310991670884, 0.13329310991670884, 0.08643723419491378, 0.08643723419491378, 0.08643723419491378, 0.26654318802444243, 0.26654318802444243, 0.26654318802444243, 0.22749409531030895, 0.22749409531030895, 0.22749409531030895, 0.1843222076619936, 0.1843222076619936, 0.1843222076619936, 0.34788950041213007, 0.34788950041213007, 0.34788950041213007, 0.24796957994831847, 0.24796957994831847, 0.24796957994831847, 0.353615648312508, 0.353615648312508, 0.353615648312508, 0.18651049893456617, 0.18651049893456617, 0.18651049893456617, 0.2515134293373259, 0.2515134293373259, 0.2515134293373259, 0.13668306141064024, 0.13668306141064024, 0.13668306141064024, 0.2113381133218154, 0.2113381133218154, 0.2113381133218154, 0.20592691858829015, 0.20592691858829015, 0.20592691858829015, 0.2193174101240517, 0.2193174101240517, 0.2193174101240517, 0.1752813194215903, 0.1752813194215903, 0.1752813194215903, 0.222949243521115, 0.222949243521115, 0.222949243521115, 0.24615795936514295, 0.24615795936514295, 0.24615795936514295, 0.8965980094025914, 0.8965980094025914, 0.8965980094025914, 0.15737349766931497, 0.15737349766931497, 0.15737349766931497, 0.1694158066110244, 0.1694158066110244, 0.1694158066110244, 0.30645008095951876, 0.30645008095951876, 0.30645008095951876, 0.2096024148987854, 0.2096024148987854, 0.2096024148987854, 0.1563780122338736, 0.1563780122338736, 0.1563780122338736, 0.19114245596541934, 0.19114245596541934, 0.19114245596541934, 0.17556745538179241, 0.17556745538179241, 0.17556745538179241, 0.18645438027163452, 0.18645438027163452, 0.18645438027163452, 0.07369281681300477, 0.07369281681300477, 0.07369281681300477, 0.07422540101143804, 0.07422540101143804, 0.07422540101143804, 0.08055582375237935, 0.08055582375237935, 0.08055582375237935]}, "mutation_prompt": null}
{"id": "c7411efe-3cf1-4f82-a1f9-291dae7a2843", "solution": "import numpy as np\n\nclass AdaptiveHierarchicalQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.2   # Slight increase for diversity\n        self.mutation_probability = 0.15\n        self.selection_pressure = 0.3     # Progressive selection\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 3  # More aggressive non-linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n            # Implementing dynamic search space reduction\n            if evaluations > self.budget * 0.7:\n                self.lower_bound = max(self.lower_bound, g_best_position.min() - 1.0)\n                self.upper_bound = min(self.upper_bound, g_best_position.max() + 1.0)\n        \n        return g_best_position, g_best_score", "name": "AdaptiveHierarchicalQuantumHybridPSO_DE", "description": "Adaptive Hierarchical Quantum-Inspired Hybrid PSO-DE with Progressive Selection and Dynamic Search Space Reduction for robust and efficient global optimization.", "configspace": "", "generation": 62, "fitness": 0.28716098871324863, "feedback": "The algorithm AdaptiveHierarchicalQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.8466276991893934, 0.8466276991893934, 0.8466276991893934, 0.8106104820830243, 0.8106104820830243, 0.8106104820830243, 0.8614004728166872, 0.8614004728166872, 0.8614004728166872, 0.040676252687567804, 0.040676252687567804, 0.040676252687567804, 0.39019018147996554, 0.39019018147996554, 0.39019018147996554, 0.3382979090581816, 0.3382979090581816, 0.3382979090581816, 0.1839887974871196, 0.1839887974871196, 0.1839887974871196, 0.16807499329666442, 0.16807499329666442, 0.16807499329666442, 0.12302450406153453, 0.12302450406153453, 0.12302450406153453, 0.15474616195145752, 0.15474616195145752, 0.15474616195145752, 0.10139627572495535, 0.10139627572495535, 0.10139627572495535, 0.14710124925423207, 0.14710124925423207, 0.14710124925423207, 0.9700280758367841, 0.9700280758367841, 0.9700280758367841, 0.9747075350835281, 0.9747075350835281, 0.9747075350835281, 0.9757879783614478, 0.9757879783614478, 0.9757879783614478, 0.4449977081869133, 0.4449977081869133, 0.4449977081869133, 0.373993767770436, 0.373993767770436, 0.373993767770436, 0.4926578343144884, 0.4926578343144884, 0.4926578343144884, 0.2405227229118444, 0.2405227229118444, 0.2405227229118444, 0.21294163720678672, 0.21294163720678672, 0.21294163720678672, 0.11978604610811472, 0.11978604610811472, 0.11978604610811472, 0.18410235894632465, 0.18410235894632465, 0.18410235894632465, 0.09671220459218444, 0.09671220459218444, 0.09671220459218444, 0.18769287178637073, 0.18769287178637073, 0.18769287178637073, 0.10047913644656059, 0.10047913644656059, 0.10047913644656059, 0.13124424519527345, 0.13124424519527345, 0.13124424519527345, 0.205413407222096, 0.205413407222096, 0.205413407222096, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.061317368626884305, 0.061317368626884305, 0.061317368626884305, 0.03847288532080073, 0.03847288532080073, 0.03847288532080073, 0.0673802051408049, 0.0673802051408049, 0.0673802051408049, 0.04864278212803186, 0.04864278212803186, 0.04864278212803186, 0.2566985178130353, 0.2566985178130353, 0.2566985178130353, 0.09720522038199286, 0.09720522038199286, 0.09720522038199286, 0.10129012954872707, 0.10129012954872707, 0.10129012954872707, 0.03904949861698537, 0.03904949861698537, 0.03904949861698537, 0.05719466384661298, 0.05719466384661298, 0.05719466384661298, 0.5181374149761482, 0.5181374149761482, 0.5181374149761482, 0.5274507381407667, 0.5274507381407667, 0.5274507381407667, 0.5579217973487001, 0.5579217973487001, 0.5579217973487001, 0.15093971179157883, 0.15093971179157883, 0.15093971179157883, 0.09252026008277114, 0.09252026008277114, 0.09252026008277114, 0.1430115636539816, 0.1430115636539816, 0.1430115636539816, 0.14696133068791462, 0.14696133068791462, 0.14696133068791462, 0.1431815373406058, 0.1431815373406058, 0.1431815373406058, 0.21785860913876365, 0.21785860913876365, 0.21785860913876365, 0.3426915959212491, 0.3426915959212491, 0.3426915959212491, 0.3239266001183091, 0.3239266001183091, 0.3239266001183091, 0.4524779942956456, 0.4524779942956456, 0.4524779942956456, 0.21460707825079084, 0.21460707825079084, 0.21460707825079084, 0.19134010609181973, 0.19134010609181973, 0.19134010609181973, 0.1147222216548427, 0.1147222216548427, 0.1147222216548427, 0.20586794178400436, 0.20586794178400436, 0.20586794178400436, 0.20323743971931585, 0.20323743971931585, 0.20323743971931585, 0.1890575778678062, 0.1890575778678062, 0.1890575778678062, 0.6971051883830774, 0.6971051883830774, 0.6971051883830774, 0.19762994627264585, 0.19762994627264585, 0.19762994627264585, 0.20375875481338523, 0.20375875481338523, 0.20375875481338523, 0.8914104563532159, 0.8914104563532159, 0.8914104563532159, 0.15797091407523678, 0.15797091407523678, 0.15797091407523678, 0.8536490689599575, 0.8536490689599575, 0.8536490689599575, 0.6451811035632112, 0.6451811035632112, 0.6451811035632112, 0.44400278188111675, 0.44400278188111675, 0.44400278188111675, 0.3487905736756235, 0.3487905736756235, 0.3487905736756235, 0.2088933308619939, 0.2088933308619939, 0.2088933308619939, 0.1756779960728443, 0.1756779960728443, 0.1756779960728443, 0.1841428954630694, 0.1841428954630694, 0.1841428954630694, 0.08322390481110853, 0.08322390481110853, 0.08322390481110853, 0.10572167074673, 0.10572167074673, 0.10572167074673, 0.09776730207185647, 0.09776730207185647, 0.09776730207185647]}, "mutation_prompt": null}
{"id": "fda91439-ee2e-493b-ba66-ceaab88660cb", "solution": "import numpy as np\n\nclass ReinforcedQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 60\n        self.min_population_size = 30\n        self.max_population_size = 90\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.8\n        self.w_min = 0.4\n        self.F = 0.7\n        self.CR = 0.9\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population_size = self.initial_population_size\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n\n            for i in range(population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(population_size, self.dim)\n            r2 = np.random.rand(population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(population_size, size=int(0.25 * population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n            if g_best_score < np.mean(p_best_scores):\n                population_size = min(self.max_population_size, population_size + 10)\n            else:\n                population_size = max(self.min_population_size, population_size - 5)\n\n        return g_best_position, g_best_score", "name": "ReinforcedQuantumHybridPSO_DE", "description": "Reinforced Dynamics in Quantum-Inspired Hybrid PSO-DE with Adaptive Population and Targeted Exploration for Enhanced Global Optimization.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {}, "mutation_prompt": null}
{"id": "c40a84e8-121d-47d8-a9d3-4bdd44b8f49f", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.7\n        self.CR = 0.9\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.15 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumSwarmDE", "description": "Adaptive Quantum-Inspired Swarm DE with Stochastic Component Optimization for dynamic exploration-exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.20406419623125002, "feedback": "The algorithm AdaptiveQuantumSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5103468896344842, 0.5103468896344842, 0.5103468896344842, 0.5030880186787927, 0.5030880186787927, 0.5030880186787927, 0.5294640367712798, 0.5294640367712798, 0.5294640367712798, 0.12376946725393267, 0.12376946725393267, 0.12376946725393267, 0.033103821565628966, 0.033103821565628966, 0.033103821565628966, 0.010241754262467095, 0.010241754262467095, 0.010241754262467095, 0.10242918195343176, 0.10242918195343176, 0.10242918195343176, 0.06703154350942164, 0.06703154350942164, 0.06703154350942164, 0.10013800928141314, 0.10013800928141314, 0.10013800928141314, 0.08516623806306522, 0.08516623806306522, 0.08516623806306522, 0.11031951000329931, 0.11031951000329931, 0.11031951000329931, 0.1026846071273767, 0.1026846071273767, 0.1026846071273767, 0.9840032518152978, 0.9840032518152978, 0.9840032518152978, 0.9852874397381828, 0.9852874397381828, 0.9852874397381828, 0.9911279176318328, 0.9911279176318328, 0.9911279176318328, 0.24216616519708578, 0.24216616519708578, 0.24216616519708578, 0.13845335403576142, 0.13845335403576142, 0.13845335403576142, 0.11890510139048094, 0.11890510139048094, 0.11890510139048094, 0.18007603178555887, 0.18007603178555887, 0.18007603178555887, 0.155143684219332, 0.155143684219332, 0.155143684219332, 0.16264217165362915, 0.16264217165362915, 0.16264217165362915, 0.13977477662930848, 0.13977477662930848, 0.13977477662930848, 0.15729570671836135, 0.15729570671836135, 0.15729570671836135, 0.1276540909699193, 0.1276540909699193, 0.1276540909699193, 0.13134147605135227, 0.13134147605135227, 0.13134147605135227, 0.11483051279288758, 0.11483051279288758, 0.11483051279288758, 0.1291275420581045, 0.1291275420581045, 0.1291275420581045, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05228070442180155, 0.05228070442180155, 0.05228070442180155, 0.051532822214055196, 0.051532822214055196, 0.051532822214055196, 0.028326273873011676, 0.028326273873011676, 0.028326273873011676, 0.023126500790204174, 0.023126500790204174, 0.023126500790204174, 0.04606978911979154, 0.04606978911979154, 0.04606978911979154, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031078404990832698, 0.031078404990832698, 0.031078404990832698, 0.1681751174692685, 0.1681751174692685, 0.1681751174692685, 0.043284005973913575, 0.043284005973913575, 0.043284005973913575, 0.3870359839763182, 0.3870359839763182, 0.3870359839763182, 0.4092103405081814, 0.4092103405081814, 0.4092103405081814, 0.4005019596984499, 0.4005019596984499, 0.4005019596984499, 0.06740064408983981, 0.06740064408983981, 0.06740064408983981, 0.09507779198765587, 0.09507779198765587, 0.09507779198765587, 0.091002668922737, 0.091002668922737, 0.091002668922737, 0.15769432047008436, 0.15769432047008436, 0.15769432047008436, 0.17982951684761883, 0.17982951684761883, 0.17982951684761883, 0.15343340643402303, 0.15343340643402303, 0.15343340643402303, 0.22592939799367417, 0.22592939799367417, 0.22592939799367417, 0.2588101455633983, 0.2588101455633983, 0.2588101455633983, 0.26884434812771474, 0.26884434812771474, 0.26884434812771474, 0.1674099249329455, 0.1674099249329455, 0.1674099249329455, 0.19286430304199098, 0.19286430304199098, 0.19286430304199098, 0.1499104645086491, 0.1499104645086491, 0.1499104645086491, 0.19392698089357596, 0.19392698089357596, 0.19392698089357596, 0.19202033257433793, 0.19202033257433793, 0.19202033257433793, 0.18866609674153278, 0.18866609674153278, 0.18866609674153278, 0.18748663912177754, 0.18748663912177754, 0.18748663912177754, 0.17563169874221507, 0.17563169874221507, 0.17563169874221507, 0.1813104947453742, 0.1813104947453742, 0.1813104947453742, 0.6673822883697402, 0.6673822883697402, 0.6673822883697402, 0.6191433717080241, 0.6191433717080241, 0.6191433717080241, 0.19678551549542422, 0.19678551549542422, 0.19678551549542422, 0.25915201815569167, 0.25915201815569167, 0.25915201815569167, 0.18670323973465563, 0.18670323973465563, 0.18670323973465563, 0.14676295519283689, 0.14676295519283689, 0.14676295519283689, 0.18920805730800516, 0.18920805730800516, 0.18920805730800516, 0.1858177554298891, 0.1858177554298891, 0.1858177554298891, 0.1846852301111901, 0.1846852301111901, 0.1846852301111901, 0.08163224902670208, 0.08163224902670208, 0.08163224902670208, 0.08259268176109402, 0.08259268176109402, 0.08259268176109402, 0.0888733867900866, 0.0888733867900866, 0.0888733867900866]}, "mutation_prompt": null}
{"id": "84a8788a-3477-469e-8018-4050bccaf399", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.85  # Slight adjustment for differential mutation scaling factor\n        self.CR = 0.9  # Slight adjustment for crossover probability\n        self.rotational_diversity = 0.2  # Increased for additional exploration\n        self.mutation_probability = 0.2  # Increased mutation rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.log1p(evaluations) / np.log1p(self.budget)  # Logarithmic inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == np.random.choice(self.dim):\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "QuantumAdaptivePSO_DE", "description": "Quantum-Inspired Adaptive Particle Swarm with Rotational Diversity and Enhanced Differential Mutation for Robust Global Optimization.", "configspace": "", "generation": 65, "fitness": 0.2707998868629989, "feedback": "The algorithm QuantumAdaptivePSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.8266504023503534, 0.8266504023503534, 0.8266504023503534, 0.690993991452397, 0.690993991452397, 0.690993991452397, 0.8570295042414351, 0.8570295042414351, 0.8570295042414351, 0.5683599637323937, 0.5683599637323937, 0.5683599637323937, 0.6161042766774567, 0.6161042766774567, 0.6161042766774567, 0.4372627868536807, 0.4372627868536807, 0.4372627868536807, 0.1512162580194918, 0.1512162580194918, 0.1512162580194918, 0.14508540502242118, 0.14508540502242118, 0.14508540502242118, 0.10352088889519107, 0.10352088889519107, 0.10352088889519107, 0.08872091160344753, 0.08872091160344753, 0.08872091160344753, 0.09247184549441367, 0.09247184549441367, 0.09247184549441367, 0.13233178112422794, 0.13233178112422794, 0.13233178112422794, 0.9843330947903294, 0.9843330947903294, 0.9843330947903294, 0.9855190991570293, 0.9855190991570293, 0.9855190991570293, 0.991715472056498, 0.991715472056498, 0.991715472056498, 0.4251151899967365, 0.4251151899967365, 0.4251151899967365, 0.14993207782549833, 0.14993207782549833, 0.14993207782549833, 0.4619578995672112, 0.4619578995672112, 0.4619578995672112, 0.26586984442046413, 0.26586984442046413, 0.26586984442046413, 0.1586993413535267, 0.1586993413535267, 0.1586993413535267, 0.1658552232485404, 0.1658552232485404, 0.1658552232485404, 0.12756987585409663, 0.12756987585409663, 0.12756987585409663, 0.17877165314785703, 0.17877165314785703, 0.17877165314785703, 0.1722901256581847, 0.1722901256581847, 0.1722901256581847, 0.17114438371361052, 0.17114438371361052, 0.17114438371361052, 0.12307000743258811, 0.12307000743258811, 0.12307000743258811, 0.08290700699689768, 0.08290700699689768, 0.08290700699689768, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0530053670733438, 0.0530053670733438, 0.0530053670733438, 0.07181416872417412, 0.07181416872417412, 0.07181416872417412, 0.09407156616732537, 0.09407156616732537, 0.09407156616732537, 0.04698211767685023, 0.04698211767685023, 0.04698211767685023, 0.0716702765605094, 0.0716702765605094, 0.0716702765605094, 0.09131788661944029, 0.09131788661944029, 0.09131788661944029, 0.06771452788944565, 0.06771452788944565, 0.06771452788944565, 0.04088784224775299, 0.04088784224775299, 0.04088784224775299, 0.07852591183473401, 0.07852591183473401, 0.07852591183473401, 0.48459273100649713, 0.48459273100649713, 0.48459273100649713, 0.5147538549609848, 0.5147538549609848, 0.5147538549609848, 0.515612087223084, 0.515612087223084, 0.515612087223084, 0.1076173898936702, 0.1076173898936702, 0.1076173898936702, 0.09505334571051027, 0.09505334571051027, 0.09505334571051027, 0.11521789970983953, 0.11521789970983953, 0.11521789970983953, 0.294320521270943, 0.294320521270943, 0.294320521270943, 0.23684338261276827, 0.23684338261276827, 0.23684338261276827, 0.2725661194801826, 0.2725661194801826, 0.2725661194801826, 0.35763834910014425, 0.35763834910014425, 0.35763834910014425, 0.34273922399574897, 0.34273922399574897, 0.34273922399574897, 0.2771541644182516, 0.2771541644182516, 0.2771541644182516, 0.17649811073887045, 0.17649811073887045, 0.17649811073887045, 0.2206467945097701, 0.2206467945097701, 0.2206467945097701, 0.12721859922570455, 0.12721859922570455, 0.12721859922570455, 0.24024422212026608, 0.24024422212026608, 0.24024422212026608, 0.2368544880115373, 0.2368544880115373, 0.2368544880115373, 0.2276385482714024, 0.2276385482714024, 0.2276385482714024, 0.1918935235518746, 0.1918935235518746, 0.1918935235518746, 0.23455550316435214, 0.23455550316435214, 0.23455550316435214, 0.24416100951943176, 0.24416100951943176, 0.24416100951943176, 0.8376971906737155, 0.8376971906737155, 0.8376971906737155, 0.1545927424211997, 0.1545927424211997, 0.1545927424211997, 0.2174801713293627, 0.2174801713293627, 0.2174801713293627, 0.15343490501813972, 0.15343490501813972, 0.15343490501813972, 0.20732579580264887, 0.20732579580264887, 0.20732579580264887, 0.740952763469336, 0.740952763469336, 0.740952763469336, 0.1990325485150164, 0.1990325485150164, 0.1990325485150164, 0.17767927071298417, 0.17767927071298417, 0.17767927071298417, 0.20767436833091923, 0.20767436833091923, 0.20767436833091923, 0.10700080716935223, 0.10700080716935223, 0.10700080716935223, 0.10033626899441228, 0.10033626899441228, 0.10033626899441228, 0.1097771777234462, 0.1097771777234462, 0.1097771777234462]}, "mutation_prompt": null}
{"id": "ef04551c-64f9-441f-85de-3f44b9a15707", "solution": "import numpy as np\n\nclass QuantumAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.25  # Increased for experimentation\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            velocities = np.clip(velocities, -self.upper_bound, self.upper_bound)  # Velocity clamping\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutated_positions = np.copy(positions[idx])  # Diversity-driven mutation\n                    for j in range(self.dim):\n                        if np.random.rand() < 0.5:\n                            mutated_positions[j] = mutation_vector[j]\n                    positions[idx] = mutated_positions\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "QuantumAdaptiveHybridPSO_DE", "description": "Quantum-Inspired Hybrid PSO-DE with Adaptive Velocity Clamping and Diversity-Driven Mutation for robust optimization.", "configspace": "", "generation": 66, "fitness": 0.23072352965473503, "feedback": "The algorithm QuantumAdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5908890271773439, 0.5908890271773439, 0.5908890271773439, 0.6294064984466343, 0.6294064984466343, 0.6294064984466343, 0.6230127915714203, 0.6230127915714203, 0.6230127915714203, 0.28331910688056816, 0.28331910688056816, 0.28331910688056816, 0.257604885527527, 0.257604885527527, 0.257604885527527, 0.25759727756211337, 0.25759727756211337, 0.25759727756211337, 0.09948810238339478, 0.09948810238339478, 0.09948810238339478, 0.12309328792607899, 0.12309328792607899, 0.12309328792607899, 0.28824277371337437, 0.28824277371337437, 0.28824277371337437, 0.10331732717607578, 0.10331732717607578, 0.10331732717607578, 0.08736439011877006, 0.08736439011877006, 0.08736439011877006, 0.15075383157247235, 0.15075383157247235, 0.15075383157247235, 0.983014737710436, 0.983014737710436, 0.983014737710436, 0.9841727553909462, 0.9841727553909462, 0.9841727553909462, 0.9844094438122385, 0.9844094438122385, 0.9844094438122385, 0.2880383012015242, 0.2880383012015242, 0.2880383012015242, 0.22018257614871584, 0.22018257614871584, 0.22018257614871584, 0.30244038089388237, 0.30244038089388237, 0.30244038089388237, 0.18710685953670791, 0.18710685953670791, 0.18710685953670791, 0.2245431376065119, 0.2245431376065119, 0.2245431376065119, 0.2244176830371729, 0.2244176830371729, 0.2244176830371729, 0.1448352624437892, 0.1448352624437892, 0.1448352624437892, 0.14759272075180596, 0.14759272075180596, 0.14759272075180596, 0.160309573441188, 0.160309573441188, 0.160309573441188, 0.06525741768258253, 0.06525741768258253, 0.06525741768258253, 0.12914883154409962, 0.12914883154409962, 0.12914883154409962, 0.11849573812017566, 0.11849573812017566, 0.11849573812017566, 0.0001251450028525447, 0.0001251450028525447, 0.0001251450028525447, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01080720352543485, 0.01080720352543485, 0.01080720352543485, 0.02679534051456811, 0.02679534051456811, 0.02679534051456811, 0.04295040554982166, 0.04295040554982166, 0.04295040554982166, 0.07565294498889819, 0.07565294498889819, 0.07565294498889819, 0.030426817192422462, 0.030426817192422462, 0.030426817192422462, 0.04533309468892199, 0.04533309468892199, 0.04533309468892199, 0.054187505349713505, 0.054187505349713505, 0.054187505349713505, 0.019923442889824394, 0.019923442889824394, 0.019923442889824394, 0.09966125076214771, 0.09966125076214771, 0.09966125076214771, 0.06839194215480127, 0.06839194215480127, 0.06839194215480127, 0.4200387223013148, 0.4200387223013148, 0.4200387223013148, 0.4239263485945106, 0.4239263485945106, 0.4239263485945106, 0.42520024027292624, 0.42520024027292624, 0.42520024027292624, 0.08733684256928942, 0.08733684256928942, 0.08733684256928942, 0.100042137094281, 0.100042137094281, 0.100042137094281, 0.0778201868241265, 0.0778201868241265, 0.0778201868241265, 0.17394112872005285, 0.17394112872005285, 0.17394112872005285, 0.1698637446856719, 0.1698637446856719, 0.1698637446856719, 0.24894311816482362, 0.24894311816482362, 0.24894311816482362, 0.28946261291534137, 0.28946261291534137, 0.28946261291534137, 0.296758736695965, 0.296758736695965, 0.296758736695965, 0.25556793667684496, 0.25556793667684496, 0.25556793667684496, 0.1517719276376598, 0.1517719276376598, 0.1517719276376598, 0.24902249920893005, 0.24902249920893005, 0.24902249920893005, 0.15319793058281883, 0.15319793058281883, 0.15319793058281883, 0.226033260568417, 0.226033260568417, 0.226033260568417, 0.1845132762708308, 0.1845132762708308, 0.1845132762708308, 0.2017039677649788, 0.2017039677649788, 0.2017039677649788, 0.20413783142144215, 0.20413783142144215, 0.20413783142144215, 0.19331548932927645, 0.19331548932927645, 0.19331548932927645, 0.3984263788439648, 0.3984263788439648, 0.3984263788439648, 0.6855915293912539, 0.6855915293912539, 0.6855915293912539, 0.18568932587226228, 0.18568932587226228, 0.18568932587226228, 0.18904956434111542, 0.18904956434111542, 0.18904956434111542, 0.31149154509463983, 0.31149154509463983, 0.31149154509463983, 0.20060802050734794, 0.20060802050734794, 0.20060802050734794, 0.15255451401998488, 0.15255451401998488, 0.15255451401998488, 0.2027548322542967, 0.2027548322542967, 0.2027548322542967, 0.17267818200649632, 0.17267818200649632, 0.17267818200649632, 0.19955441462574852, 0.19955441462574852, 0.19955441462574852, 0.08739184602394179, 0.08739184602394179, 0.08739184602394179, 0.07157962353656189, 0.07157962353656189, 0.07157962353656189, 0.08971660832684614, 0.08971660832684614, 0.08971660832684614]}, "mutation_prompt": null}
{"id": "0821a119-3516-4ca0-a6d4-7ff389cb44ff", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted minimum inertia weight for better exploration-exploitation balance\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.2  # Increased rotational diversity for more trial vectors\n        self.mutation_probability = 0.2  # Increased mutation probability for enhanced exploration\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 3  # Cubic decay for smoother transition\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDynamicQuantumHybridPSO_DE", "description": "Enhanced Dynamic Quantum-Inspired Hybrid PSO-DE utilizing Adaptive Local and Global Mutation Strategies for superior convergence.", "configspace": "", "generation": 67, "fitness": 0.2308141567945783, "feedback": "The algorithm EnhancedDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.23.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.6673814043773065, 0.6673814043773065, 0.6673814043773065, 0.6704961539232027, 0.6704961539232027, 0.6704961539232027, 0.6976009734161398, 0.6976009734161398, 0.6976009734161398, 0.23081038901028006, 0.23081038901028006, 0.23081038901028006, 0.10937241350601312, 0.10937241350601312, 0.10937241350601312, 0.23573512081016557, 0.23573512081016557, 0.23573512081016557, 0.10349415199625456, 0.10349415199625456, 0.10349415199625456, 0.07027614971898799, 0.07027614971898799, 0.07027614971898799, 0.14554968894594422, 0.14554968894594422, 0.14554968894594422, 0.09159589810694635, 0.09159589810694635, 0.09159589810694635, 0.10778013030831501, 0.10778013030831501, 0.10778013030831501, 0.12841184916406745, 0.12841184916406745, 0.12841184916406745, 0.9775725649009938, 0.9775725649009938, 0.9775725649009938, 0.9780654088850025, 0.9780654088850025, 0.9780654088850025, 0.9781018735809156, 0.9781018735809156, 0.9781018735809156, 0.34896237503244754, 0.34896237503244754, 0.34896237503244754, 0.3126721029062872, 0.3126721029062872, 0.3126721029062872, 0.29297948537770735, 0.29297948537770735, 0.29297948537770735, 0.21932406830778572, 0.21932406830778572, 0.21932406830778572, 0.18261997194916058, 0.18261997194916058, 0.18261997194916058, 0.2007792571324114, 0.2007792571324114, 0.2007792571324114, 0.13778969729867407, 0.13778969729867407, 0.13778969729867407, 0.12455739160273038, 0.12455739160273038, 0.12455739160273038, 0.1252878973371826, 0.1252878973371826, 0.1252878973371826, 0.031137020320488595, 0.031137020320488595, 0.031137020320488595, 0.15160113432954092, 0.15160113432954092, 0.15160113432954092, 0.03273232321714892, 0.03273232321714892, 0.03273232321714892, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05664318268809243, 0.05664318268809243, 0.05664318268809243, 0.009369870205615971, 0.009369870205615971, 0.009369870205615971, 0.07608216244286936, 0.07608216244286936, 0.07608216244286936, 0.049107997809732296, 0.049107997809732296, 0.049107997809732296, 0.14514956377279742, 0.14514956377279742, 0.14514956377279742, 0.0809517635269763, 0.0809517635269763, 0.0809517635269763, 0.12153101797990662, 0.12153101797990662, 0.12153101797990662, 0.19645826968797797, 0.19645826968797797, 0.19645826968797797, 0.0488294052713798, 0.0488294052713798, 0.0488294052713798, 0.478348453857089, 0.478348453857089, 0.478348453857089, 0.4786855991805019, 0.4786855991805019, 0.4786855991805019, 0.436774804871246, 0.436774804871246, 0.436774804871246, 0.0712357519841027, 0.0712357519841027, 0.0712357519841027, 0.08243249442778067, 0.08243249442778067, 0.08243249442778067, 0.0907257094313032, 0.0907257094313032, 0.0907257094313032, 0.20468686304555883, 0.20468686304555883, 0.20468686304555883, 0.137907769115866, 0.137907769115866, 0.137907769115866, 0.15894342806753936, 0.15894342806753936, 0.15894342806753936, 0.29800235311706325, 0.29800235311706325, 0.29800235311706325, 0.31169966205273103, 0.31169966205273103, 0.31169966205273103, 0.3201834780129149, 0.3201834780129149, 0.3201834780129149, 0.2197373889892137, 0.2197373889892137, 0.2197373889892137, 0.2175395262902915, 0.2175395262902915, 0.2175395262902915, 0.13047904002779287, 0.13047904002779287, 0.13047904002779287, 0.18868551604147143, 0.18868551604147143, 0.18868551604147143, 0.19959859447183803, 0.19959859447183803, 0.19959859447183803, 0.18128770922732096, 0.18128770922732096, 0.18128770922732096, 0.1709833768850234, 0.1709833768850234, 0.1709833768850234, 0.20509129005235716, 0.20509129005235716, 0.20509129005235716, 0.2501560349081696, 0.2501560349081696, 0.2501560349081696, 0.8977920207317805, 0.8977920207317805, 0.8977920207317805, 0.1572642213044041, 0.1572642213044041, 0.1572642213044041, 0.16878614819623794, 0.16878614819623794, 0.16878614819623794, 0.24654178795562953, 0.24654178795562953, 0.24654178795562953, 0.20810118531588073, 0.20810118531588073, 0.20810118531588073, 0.1552184237859323, 0.1552184237859323, 0.1552184237859323, 0.17980784433596742, 0.17980784433596742, 0.17980784433596742, 0.1826312259978543, 0.1826312259978543, 0.1826312259978543, 0.1839879828330363, 0.1839879828330363, 0.1839879828330363, 0.09734455433312827, 0.09734455433312827, 0.09734455433312827, 0.08335790522187758, 0.08335790522187758, 0.08335790522187758, 0.0874910162932836, 0.0874910162932836, 0.0874910162932836]}, "mutation_prompt": null}
{"id": "0eb2f5af-734d-4ef9-811c-845d5c1eb320", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Dynamic Inertia and Local Search Enhancement for robust optimization.", "configspace": "", "generation": 68, "fitness": 0.2028687449175434, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.536489429676697, 0.536489429676697, 0.536489429676697, 0.560993652512548, 0.560993652512548, 0.560993652512548, 0.44256949976579063, 0.44256949976579063, 0.44256949976579063, 0.026020082245707954, 0.026020082245707954, 0.026020082245707954, 0.11308174268175519, 0.11308174268175519, 0.11308174268175519, 0.020613847311053757, 0.020613847311053757, 0.020613847311053757, 0.11153301978065988, 0.11153301978065988, 0.11153301978065988, 0.06613830909005824, 0.06613830909005824, 0.06613830909005824, 0.1278402081405191, 0.1278402081405191, 0.1278402081405191, 0.10573832705726949, 0.10573832705726949, 0.10573832705726949, 0.07887077665879916, 0.07887077665879916, 0.07887077665879916, 0.09882142078368561, 0.09882142078368561, 0.09882142078368561, 0.9828053900027672, 0.9828053900027672, 0.9828053900027672, 0.9839416963369757, 0.9839416963369757, 0.9839416963369757, 0.9909290213294313, 0.9909290213294313, 0.9909290213294313, 0.2507887057913647, 0.2507887057913647, 0.2507887057913647, 0.13695888389627175, 0.13695888389627175, 0.13695888389627175, 0.2671657743448834, 0.2671657743448834, 0.2671657743448834, 0.222019597774053, 0.222019597774053, 0.222019597774053, 0.30457205114731367, 0.30457205114731367, 0.30457205114731367, 0.20577623065862183, 0.20577623065862183, 0.20577623065862183, 0.13346244473820257, 0.13346244473820257, 0.13346244473820257, 0.10503903022456051, 0.10503903022456051, 0.10503903022456051, 0.13109602622793048, 0.13109602622793048, 0.13109602622793048, 0.021803752902211815, 0.021803752902211815, 0.021803752902211815, 0.09993346491015831, 0.09993346491015831, 0.09993346491015831, 0.14403843277639716, 0.14403843277639716, 0.14403843277639716, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004452590827371816, 0.0004452590827371816, 0.0004452590827371816, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05334718215428125, 0.05334718215428125, 0.05334718215428125, 0.01939996139806066, 0.01939996139806066, 0.01939996139806066, 0.03720767724504803, 0.03720767724504803, 0.03720767724504803, 0.02554847055772369, 0.02554847055772369, 0.02554847055772369, 0.03440672669201117, 0.03440672669201117, 0.03440672669201117, 0.07581935915450011, 0.07581935915450011, 0.07581935915450011, 0.02759284212574531, 0.02759284212574531, 0.02759284212574531, 0.004592408845787044, 0.004592408845787044, 0.004592408845787044, 0.06727339973256585, 0.06727339973256585, 0.06727339973256585, 0.40885502330490087, 0.40885502330490087, 0.40885502330490087, 0.4305418008677492, 0.4305418008677492, 0.4305418008677492, 0.40728416627725605, 0.40728416627725605, 0.40728416627725605, 0.09374991340987071, 0.09374991340987071, 0.09374991340987071, 0.07740822141720183, 0.07740822141720183, 0.07740822141720183, 0.09582035919744702, 0.09582035919744702, 0.09582035919744702, 0.17859086861605833, 0.17859086861605833, 0.17859086861605833, 0.1596717376772271, 0.1596717376772271, 0.1596717376772271, 0.1548805737893859, 0.1548805737893859, 0.1548805737893859, 0.22099143435186774, 0.22099143435186774, 0.22099143435186774, 0.24597871368758395, 0.24597871368758395, 0.24597871368758395, 0.2933118863751061, 0.2933118863751061, 0.2933118863751061, 0.14094978469804087, 0.14094978469804087, 0.14094978469804087, 0.15789581065614344, 0.15789581065614344, 0.15789581065614344, 0.19534093776703998, 0.19534093776703998, 0.19534093776703998, 0.20588067684496603, 0.20588067684496603, 0.20588067684496603, 0.18889604759265521, 0.18889604759265521, 0.18889604759265521, 0.18100330468462078, 0.18100330468462078, 0.18100330468462078, 0.18944400385443683, 0.18944400385443683, 0.18944400385443683, 0.1793718812118673, 0.1793718812118673, 0.1793718812118673, 0.16938096775246836, 0.16938096775246836, 0.16938096775246836, 0.6652424198422134, 0.6652424198422134, 0.6652424198422134, 0.1626999551075372, 0.1626999551075372, 0.1626999551075372, 0.2006073854816237, 0.2006073854816237, 0.2006073854816237, 0.4126675149696988, 0.4126675149696988, 0.4126675149696988, 0.19704246709333562, 0.19704246709333562, 0.19704246709333562, 0.1950925416683703, 0.1950925416683703, 0.1950925416683703, 0.17537357622217764, 0.17537357622217764, 0.17537357622217764, 0.18898573221219428, 0.18898573221219428, 0.18898573221219428, 0.19243807261323176, 0.19243807261323176, 0.19243807261323176, 0.07478811787590622, 0.07478811787590622, 0.07478811787590622, 0.07013320344258789, 0.07013320344258789, 0.07013320344258789, 0.08135642774620644, 0.08135642774620644, 0.08135642774620644]}, "mutation_prompt": null}
{"id": "a90307c2-78c8-49ed-8be2-cf8a48ccd552", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 70  # Increased population for diversity\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Slightly increased w_min for more exploration\n        self.F = 0.9  # Increased mutation factor\n        self.CR = 0.9  # Increased crossover rate\n        self.rotational_diversity = 0.2  # More diversity for exploration\n        self.mutation_probability = 0.2  # Higher mutation probability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * np.sin(np.pi * evaluations / (2 * self.budget))  # Sinusoidal inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)  # More mutations\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDynamicQuantumHybridPSO_DE", "description": "Enhanced Dynamic Quantum-Inspired Hybrid PSO-DE with improved convergence through adaptive velocity updates and strategic mutation control.", "configspace": "", "generation": 69, "fitness": 0.21301544453596366, "feedback": "The algorithm EnhancedDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5944166918297797, 0.5944166918297797, 0.5944166918297797, 0.5430712714372963, 0.5430712714372963, 0.5430712714372963, 0.577180385509236, 0.577180385509236, 0.577180385509236, 0.12037418867089567, 0.12037418867089567, 0.12037418867089567, 0.2516831573985624, 0.2516831573985624, 0.2516831573985624, 0.1403472280279937, 0.1403472280279937, 0.1403472280279937, 0.09611922352044222, 0.09611922352044222, 0.09611922352044222, 0.0694290254370531, 0.0694290254370531, 0.0694290254370531, 0.10512891393003065, 0.10512891393003065, 0.10512891393003065, 0.09674266629665873, 0.09674266629665873, 0.09674266629665873, 0.09015487176682213, 0.09015487176682213, 0.09015487176682213, 0.10150827125760609, 0.10150827125760609, 0.10150827125760609, 0.9837624134473659, 0.9837624134473659, 0.9837624134473659, 0.9840829402438962, 0.9840829402438962, 0.9840829402438962, 0.9722691569361056, 0.9722691569361056, 0.9722691569361056, 0.2687829457616754, 0.2687829457616754, 0.2687829457616754, 0.26418641279434973, 0.26418641279434973, 0.26418641279434973, 0.24065392348271575, 0.24065392348271575, 0.24065392348271575, 0.18677294586546, 0.18677294586546, 0.18677294586546, 0.16709426322547438, 0.16709426322547438, 0.16709426322547438, 0.1290773175018889, 0.1290773175018889, 0.1290773175018889, 0.13984208442825052, 0.13984208442825052, 0.13984208442825052, 0.12056765442950745, 0.12056765442950745, 0.12056765442950745, 0.13120696330893766, 0.13120696330893766, 0.13120696330893766, 0.11670997816206996, 0.11670997816206996, 0.11670997816206996, 0.1321803388737609, 0.1321803388737609, 0.1321803388737609, 0.04997940327093964, 0.04997940327093964, 0.04997940327093964, 0.01484088468684508, 0.01484088468684508, 0.01484088468684508, 0.05525929741280888, 0.05525929741280888, 0.05525929741280888, 0.015197284699028923, 0.015197284699028923, 0.015197284699028923, 0.07520188014989848, 0.07520188014989848, 0.07520188014989848, 0.02334894682687738, 0.02334894682687738, 0.02334894682687738, 0.050276489565874494, 0.050276489565874494, 0.050276489565874494, 0.07994047518209135, 0.07994047518209135, 0.07994047518209135, 0.04834768647611987, 0.04834768647611987, 0.04834768647611987, 0.05458183960865759, 0.05458183960865759, 0.05458183960865759, 0.07524519122114837, 0.07524519122114837, 0.07524519122114837, 0.02994801854643281, 0.02994801854643281, 0.02994801854643281, 0.06267530043461333, 0.06267530043461333, 0.06267530043461333, 0.4083063574363005, 0.4083063574363005, 0.4083063574363005, 0.41772536407365735, 0.41772536407365735, 0.41772536407365735, 0.4317960724865717, 0.4317960724865717, 0.4317960724865717, 0.11144487783716994, 0.11144487783716994, 0.11144487783716994, 0.11266267178975775, 0.11266267178975775, 0.11266267178975775, 0.08118578711751889, 0.08118578711751889, 0.08118578711751889, 0.16535350387586478, 0.16535350387586478, 0.16535350387586478, 0.1436058675415468, 0.1436058675415468, 0.1436058675415468, 0.2521114838723649, 0.2521114838723649, 0.2521114838723649, 0.2169399851533086, 0.2169399851533086, 0.2169399851533086, 0.3083976994470663, 0.3083976994470663, 0.3083976994470663, 0.32336166323209614, 0.32336166323209614, 0.32336166323209614, 0.1802112423597697, 0.1802112423597697, 0.1802112423597697, 0.17416547474902722, 0.17416547474902722, 0.17416547474902722, 0.19167415170222168, 0.19167415170222168, 0.19167415170222168, 0.20512780621805982, 0.20512780621805982, 0.20512780621805982, 0.16927251085431183, 0.16927251085431183, 0.16927251085431183, 0.20434507429491755, 0.20434507429491755, 0.20434507429491755, 0.18581271160258817, 0.18581271160258817, 0.18581271160258817, 0.18511566326191453, 0.18511566326191453, 0.18511566326191453, 0.17846523485721522, 0.17846523485721522, 0.17846523485721522, 0.6877162797979761, 0.6877162797979761, 0.6877162797979761, 0.16771641856944552, 0.16771641856944552, 0.16771641856944552, 0.1674205832052712, 0.1674205832052712, 0.1674205832052712, 0.20872844467759266, 0.20872844467759266, 0.20872844467759266, 0.19890133565045276, 0.19890133565045276, 0.19890133565045276, 0.19961387499649486, 0.19961387499649486, 0.19961387499649486, 0.18637995261087303, 0.18637995261087303, 0.18637995261087303, 0.18013067954063533, 0.18013067954063533, 0.18013067954063533, 0.18959191090310779, 0.18959191090310779, 0.18959191090310779, 0.07277700847143331, 0.07277700847143331, 0.07277700847143331, 0.08063064816836196, 0.08063064816836196, 0.08063064816836196, 0.09223573460931844, 0.09223573460931844, 0.09223573460931844]}, "mutation_prompt": null}
{"id": "33767ded-bd79-42de-b66d-4773ec070878", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.85\n        self.CR = 0.9\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Rotational Diversity and Self-Adaptive Mutation for enhanced global optimization.", "configspace": "", "generation": 70, "fitness": 0.20940911179936397, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.5529499910874491, 0.5529499910874491, 0.5529499910874491, 0.5600040737155503, 0.5600040737155503, 0.5600040737155503, 0.4357846538566136, 0.4357846538566136, 0.4357846538566136, 0.11681316159829747, 0.11681316159829747, 0.11681316159829747, 0.05229938827324476, 0.05229938827324476, 0.05229938827324476, 0.024042453785177553, 0.024042453785177553, 0.024042453785177553, 0.10839988233148856, 0.10839988233148856, 0.10839988233148856, 0.0649628731046683, 0.0649628731046683, 0.0649628731046683, 0.11400757582033694, 0.11400757582033694, 0.11400757582033694, 0.10273632566470547, 0.10273632566470547, 0.10273632566470547, 0.10175912070857285, 0.10175912070857285, 0.10175912070857285, 0.10092108576674597, 0.10092108576674597, 0.10092108576674597, 0.9828165380281085, 0.9828165380281085, 0.9828165380281085, 0.9839542413862107, 0.9839542413862107, 0.9839542413862107, 0.9908391920292428, 0.9908391920292428, 0.9908391920292428, 0.11405637345088326, 0.11405637345088326, 0.11405637345088326, 0.13916509719992554, 0.13916509719992554, 0.13916509719992554, 0.27629435793908086, 0.27629435793908086, 0.27629435793908086, 0.3151736480779719, 0.3151736480779719, 0.3151736480779719, 0.5803199557627108, 0.5803199557627108, 0.5803199557627108, 0.16849318227307464, 0.16849318227307464, 0.16849318227307464, 0.13392017800229494, 0.13392017800229494, 0.13392017800229494, 0.10506955542656071, 0.10506955542656071, 0.10506955542656071, 0.11665018603185018, 0.11665018603185018, 0.11665018603185018, 0.021502086595251657, 0.021502086595251657, 0.021502086595251657, 0.1009372045446405, 0.1009372045446405, 0.1009372045446405, 0.14390497444659978, 0.14390497444659978, 0.14390497444659978, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10686566998548475, 0.10686566998548475, 0.10686566998548475, 0.04284201054183645, 0.04284201054183645, 0.04284201054183645, 0.06491539235681698, 0.06491539235681698, 0.06491539235681698, 0.02580871248062644, 0.02580871248062644, 0.02580871248062644, 0.04912979783450977, 0.04912979783450977, 0.04912979783450977, 0.0334634671627797, 0.0334634671627797, 0.0334634671627797, 0.00798841789876914, 0.00798841789876914, 0.00798841789876914, 0.06353523275952178, 0.06353523275952178, 0.06353523275952178, 0.05993382171040562, 0.05993382171040562, 0.05993382171040562, 0.42047752970449526, 0.42047752970449526, 0.42047752970449526, 0.4231387707306429, 0.4231387707306429, 0.4231387707306429, 0.4024505170755365, 0.4024505170755365, 0.4024505170755365, 0.06799058662324764, 0.06799058662324764, 0.06799058662324764, 0.07522142275911847, 0.07522142275911847, 0.07522142275911847, 0.07649065552435863, 0.07649065552435863, 0.07649065552435863, 0.3307201101323195, 0.3307201101323195, 0.3307201101323195, 0.15923473487475925, 0.15923473487475925, 0.15923473487475925, 0.20982867022794338, 0.20982867022794338, 0.20982867022794338, 0.21748984522152381, 0.21748984522152381, 0.21748984522152381, 0.2598851588427413, 0.2598851588427413, 0.2598851588427413, 0.2961121868083797, 0.2961121868083797, 0.2961121868083797, 0.132136244419498, 0.132136244419498, 0.132136244419498, 0.16800313088650798, 0.16800313088650798, 0.16800313088650798, 0.17211474629198875, 0.17211474629198875, 0.17211474629198875, 0.20588067684496603, 0.20588067684496603, 0.20588067684496603, 0.19586432138817678, 0.19586432138817678, 0.19586432138817678, 0.20294329424348512, 0.20294329424348512, 0.20294329424348512, 0.21143711931073317, 0.21143711931073317, 0.21143711931073317, 0.1824935617610538, 0.1824935617610538, 0.1824935617610538, 0.21091702357150732, 0.21091702357150732, 0.21091702357150732, 0.6784971190652637, 0.6784971190652637, 0.6784971190652637, 0.18705897029546614, 0.18705897029546614, 0.18705897029546614, 0.20020583753246746, 0.20020583753246746, 0.20020583753246746, 0.2599799391521085, 0.2599799391521085, 0.2599799391521085, 0.19703417356182062, 0.19703417356182062, 0.19703417356182062, 0.1894904687457699, 0.1894904687457699, 0.1894904687457699, 0.17537357622217764, 0.17537357622217764, 0.17537357622217764, 0.17933266371556655, 0.17933266371556655, 0.17933266371556655, 0.19433292092132493, 0.19433292092132493, 0.19433292092132493, 0.07478811787590622, 0.07478811787590622, 0.07478811787590622, 0.07197223849940437, 0.07197223849940437, 0.07197223849940437, 0.08599983708593628, 0.08599983708593628, 0.08599983708593628]}, "mutation_prompt": null}
{"id": "3e0f09cc-f1d6-4ac0-a40d-5ab40f66f99e", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F = 0.9\n        self.CR = 0.85\n        self.rotational_diversity = 0.1\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    perturbation = np.random.uniform(-0.5, 0.5, self.dim)  # New perturbation step\n                    positions[idx] = mutation_vector + perturbation\n                    positions[idx] = np.clip(positions[idx], self.lower_bound, self.upper_bound)\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n            # Dynamic population adjustment\n            if evaluations % (self.budget // 10) == 0:  # Adjust every 10% of budget\n                self.population_size = max(20, int(self.population_size * (0.9 + 0.2 * np.random.rand())))\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Perturbation and Dynamic Population for enhanced exploration and convergence.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (56,5) (60,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (56,5) (60,5) ')", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {}, "mutation_prompt": null}
{"id": "15385f05-ee70-4e0a-a19b-17274fa55def", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.4  # Slightly increased minimum inertia weight\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.2  # Increased mutation probability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - (evaluations / self.budget) ** 3)  # Cubic inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.3 * self.population_size), replace=False)  # Increased number of mutants\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Enhanced Non-linear Inertia and Mutation Strategy to improve convergence on diverse problems.", "configspace": "", "generation": 72, "fitness": 0.2814990727191929, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.8589110023737528, 0.8589110023737528, 0.8589110023737528, 0.8474779686681077, 0.8474779686681077, 0.8474779686681077, 0.8418159088822422, 0.8418159088822422, 0.8418159088822422, 0.34417180182286156, 0.34417180182286156, 0.34417180182286156, 0.42821460564376046, 0.42821460564376046, 0.42821460564376046, 0.05148891910678899, 0.05148891910678899, 0.05148891910678899, 0.1477510952328014, 0.1477510952328014, 0.1477510952328014, 0.15035003165004868, 0.15035003165004868, 0.15035003165004868, 0.16162265063406034, 0.16162265063406034, 0.16162265063406034, 0.10818137684862672, 0.10818137684862672, 0.10818137684862672, 0.0876654902940387, 0.0876654902940387, 0.0876654902940387, 0.10255096825233811, 0.10255096825233811, 0.10255096825233811, 0.9740384358288516, 0.9740384358288516, 0.9740384358288516, 0.9779491621828085, 0.9779491621828085, 0.9779491621828085, 0.9809306529042446, 0.9809306529042446, 0.9809306529042446, 0.43353146464994086, 0.43353146464994086, 0.43353146464994086, 0.28286689759905903, 0.28286689759905903, 0.28286689759905903, 0.4230417524000484, 0.4230417524000484, 0.4230417524000484, 0.3380882003134189, 0.3380882003134189, 0.3380882003134189, 0.15968926000047323, 0.15968926000047323, 0.15968926000047323, 0.16807041959275903, 0.16807041959275903, 0.16807041959275903, 0.23674293657008572, 0.23674293657008572, 0.23674293657008572, 0.21409523182063006, 0.21409523182063006, 0.21409523182063006, 0.17703479023303115, 0.17703479023303115, 0.17703479023303115, 0.11383613851213503, 0.11383613851213503, 0.11383613851213503, 0.1707330288407598, 0.1707330288407598, 0.1707330288407598, 0.20547361602241931, 0.20547361602241931, 0.20547361602241931, 0.002819238999452689, 0.002819238999452689, 0.002819238999452689, 0.00099088330479713, 0.00099088330479713, 0.00099088330479713, 0.00944289736187276, 0.00944289736187276, 0.00944289736187276, 0.05992664024321148, 0.05992664024321148, 0.05992664024321148, 0.024028037162089455, 0.024028037162089455, 0.024028037162089455, 0.04945215802540337, 0.04945215802540337, 0.04945215802540337, 0.04789016901415599, 0.04789016901415599, 0.04789016901415599, 0.0927195088725632, 0.0927195088725632, 0.0927195088725632, 0.09557111922757233, 0.09557111922757233, 0.09557111922757233, 0.13438586381290263, 0.13438586381290263, 0.13438586381290263, 0.03745836598531349, 0.03745836598531349, 0.03745836598531349, 0.08083047503979779, 0.08083047503979779, 0.08083047503979779, 0.4751349790998146, 0.4751349790998146, 0.4751349790998146, 0.4831909086943099, 0.4831909086943099, 0.4831909086943099, 0.5304697708608856, 0.5304697708608856, 0.5304697708608856, 0.1150207805592357, 0.1150207805592357, 0.1150207805592357, 0.1429067432259873, 0.1429067432259873, 0.1429067432259873, 0.07493468069679343, 0.07493468069679343, 0.07493468069679343, 0.1781004310449975, 0.1781004310449975, 0.1781004310449975, 0.20487480319198814, 0.20487480319198814, 0.20487480319198814, 0.19593552047082563, 0.19593552047082563, 0.19593552047082563, 0.39666451222912424, 0.39666451222912424, 0.39666451222912424, 0.358455051274036, 0.358455051274036, 0.358455051274036, 0.33322741155501734, 0.33322741155501734, 0.33322741155501734, 0.2230994138839797, 0.2230994138839797, 0.2230994138839797, 0.19054202354699157, 0.19054202354699157, 0.19054202354699157, 0.12818242020920423, 0.12818242020920423, 0.12818242020920423, 0.20747844898419954, 0.20747844898419954, 0.20747844898419954, 0.2380582228947148, 0.2380582228947148, 0.2380582228947148, 0.19256103430806748, 0.19256103430806748, 0.19256103430806748, 0.18825236637102094, 0.18825236637102094, 0.18825236637102094, 0.222070572648694, 0.222070572648694, 0.222070572648694, 0.2055312529147032, 0.2055312529147032, 0.2055312529147032, 0.9099773384324432, 0.9099773384324432, 0.9099773384324432, 0.7838794213060113, 0.7838794213060113, 0.7838794213060113, 0.16852434445205744, 0.16852434445205744, 0.16852434445205744, 0.4470687174818476, 0.4470687174818476, 0.4470687174818476, 0.658611627160766, 0.658611627160766, 0.658611627160766, 0.5280619469984703, 0.5280619469984703, 0.5280619469984703, 0.2156725943543788, 0.2156725943543788, 0.2156725943543788, 0.18335889093804325, 0.18335889093804325, 0.18335889093804325, 0.1923537640744879, 0.1923537640744879, 0.1923537640744879, 0.09807163501822014, 0.09807163501822014, 0.09807163501822014, 0.0782107548193901, 0.0782107548193901, 0.0782107548193901, 0.09761168815195398, 0.09761168815195398, 0.09761168815195398]}, "mutation_prompt": null}
{"id": "0c6a2197-58e3-48ba-9ec3-b0ebf8066699", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.2  # Increased to enhance exploration\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + self.c1 * r1 * (p_best_positions - positions) \n                          + self.c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = np.random.randint(1, int(self.rotational_diversity * self.population_size))  # Randomized clone count\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                crossover_points = np.random.choice(self.dim, np.random.randint(1, self.dim), replace=False)  # Multi-point crossover\n                for j in crossover_points:\n                    trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDynamicQuantumHybridPSO_DE", "description": "Enhanced Hybrid PSO-DE with Adaptive Inertia, Randomized Clone Proportion, and Multi-point Crossover for improved exploration and exploitation.", "configspace": "", "generation": 73, "fitness": 0.2235488250372343, "feedback": "The algorithm EnhancedDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.23.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.6340355285219987, 0.6340355285219987, 0.6340355285219987, 0.6429301049539409, 0.6429301049539409, 0.6429301049539409, 0.6678589076104564, 0.6678589076104564, 0.6678589076104564, 0.16014104437352839, 0.16014104437352839, 0.16014104437352839, 0.1393485482874106, 0.1393485482874106, 0.1393485482874106, 0.0033171318354648927, 0.0033171318354648927, 0.0033171318354648927, 0.13257156724272423, 0.13257156724272423, 0.13257156724272423, 0.07222703417459309, 0.07222703417459309, 0.07222703417459309, 0.13418614130544482, 0.13418614130544482, 0.13418614130544482, 0.10333476151425203, 0.10333476151425203, 0.10333476151425203, 0.08021158529568617, 0.08021158529568617, 0.08021158529568617, 0.10413217442390088, 0.10413217442390088, 0.10413217442390088, 0.9854790521981863, 0.9854790521981863, 0.9854790521981863, 0.9864418325575088, 0.9864418325575088, 0.9864418325575088, 0.9922330669181143, 0.9922330669181143, 0.9922330669181143, 0.24873392557261542, 0.24873392557261542, 0.24873392557261542, 0.1609422658950891, 0.1609422658950891, 0.1609422658950891, 0.3020783414247311, 0.3020783414247311, 0.3020783414247311, 0.5372608003477137, 0.5372608003477137, 0.5372608003477137, 0.15732945481667027, 0.15732945481667027, 0.15732945481667027, 0.16398102790272573, 0.16398102790272573, 0.16398102790272573, 0.1399666628347237, 0.1399666628347237, 0.1399666628347237, 0.12435595508336861, 0.12435595508336861, 0.12435595508336861, 0.14756145638864293, 0.14756145638864293, 0.14756145638864293, 0.21352565672024804, 0.21352565672024804, 0.21352565672024804, 0.13577157819056607, 0.13577157819056607, 0.13577157819056607, 0.11242326073985243, 0.11242326073985243, 0.11242326073985243, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006236795851681798, 0.006236795851681798, 0.006236795851681798, 0.06369595786054216, 0.06369595786054216, 0.06369595786054216, 0.03088375439616231, 0.03088375439616231, 0.03088375439616231, 0.03509249230271472, 0.03509249230271472, 0.03509249230271472, 0.028217956469595684, 0.028217956469595684, 0.028217956469595684, 0.04357979564819148, 0.04357979564819148, 0.04357979564819148, 0.10363776858627594, 0.10363776858627594, 0.10363776858627594, 0.009857266126286568, 0.009857266126286568, 0.009857266126286568, 0.00490678294353708, 0.00490678294353708, 0.00490678294353708, 0.04358291798024361, 0.04358291798024361, 0.04358291798024361, 0.44444928366054237, 0.44444928366054237, 0.44444928366054237, 0.43564319129871687, 0.43564319129871687, 0.43564319129871687, 0.4190288936346245, 0.4190288936346245, 0.4190288936346245, 0.08064529635586914, 0.08064529635586914, 0.08064529635586914, 0.10622742129170781, 0.10622742129170781, 0.10622742129170781, 0.11624832433980681, 0.11624832433980681, 0.11624832433980681, 0.18382046185658973, 0.18382046185658973, 0.18382046185658973, 0.176542486353928, 0.176542486353928, 0.176542486353928, 0.1537233144017891, 0.1537233144017891, 0.1537233144017891, 0.23694962203687786, 0.23694962203687786, 0.23694962203687786, 0.30630717856400425, 0.30630717856400425, 0.30630717856400425, 0.2601263528207224, 0.2601263528207224, 0.2601263528207224, 0.11315999152409573, 0.11315999152409573, 0.11315999152409573, 0.1734193251701146, 0.1734193251701146, 0.1734193251701146, 0.13827839058295288, 0.13827839058295288, 0.13827839058295288, 0.19240615099723146, 0.19240615099723146, 0.19240615099723146, 0.19473679257119236, 0.19473679257119236, 0.19473679257119236, 0.19739757719246032, 0.19739757719246032, 0.19739757719246032, 0.20496076337162417, 0.20496076337162417, 0.20496076337162417, 0.19866965530254677, 0.19866965530254677, 0.19866965530254677, 0.21347778909283832, 0.21347778909283832, 0.21347778909283832, 0.7984220203123376, 0.7984220203123376, 0.7984220203123376, 0.15290016906979198, 0.15290016906979198, 0.15290016906979198, 0.1496927148428585, 0.1496927148428585, 0.1496927148428585, 0.4937944505979174, 0.4937944505979174, 0.4937944505979174, 0.1979530436035587, 0.1979530436035587, 0.1979530436035587, 0.29655272364354657, 0.29655272364354657, 0.29655272364354657, 0.1906536764123934, 0.1906536764123934, 0.1906536764123934, 0.19326067209316367, 0.19326067209316367, 0.19326067209316367, 0.17974616537476062, 0.17974616537476062, 0.17974616537476062, 0.080484106288232, 0.080484106288232, 0.080484106288232, 0.06766100833219957, 0.06766100833219957, 0.06766100833219957, 0.09590603439448464, 0.09590603439448464, 0.09590603439448464]}, "mutation_prompt": null}
{"id": "b008ea76-d623-4c91-bccc-6da557632ce7", "solution": "import numpy as np\n\nclass EnhancedDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.5\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 2  # Non-linear inertia decay\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + c1 * r1 * (p_best_positions - positions) \n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDynamicQuantumHybridPSO_DE", "description": "Enhanced Dynamic Quantum-Inspired Hybrid PSO-DE with Non-Linear Time-Varying Acceleration Coefficients for Improved Convergence and Diversity.", "configspace": "", "generation": 74, "fitness": 0.3150455534853321, "feedback": "The algorithm EnhancedDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "960e9a2d-f06d-40e5-b2a6-9f5d3fc6d565", "metadata": {"aucs": [0.8847012378145376, 0.8847012378145376, 0.8847012378145376, 0.8943851696220163, 0.8943851696220163, 0.8943851696220163, 0.8888718657495057, 0.8888718657495057, 0.8888718657495057, 0.3223100191723973, 0.3223100191723973, 0.3223100191723973, 0.26397583105823885, 0.26397583105823885, 0.26397583105823885, 0.7400533361254057, 0.7400533361254057, 0.7400533361254057, 0.23166356480443284, 0.23166356480443284, 0.23166356480443284, 0.1410809266393529, 0.1410809266393529, 0.1410809266393529, 0.12047933993018034, 0.12047933993018034, 0.12047933993018034, 0.12047266611554663, 0.12047266611554663, 0.12047266611554663, 0.12421369716636765, 0.12421369716636765, 0.12421369716636765, 0.09085529445514262, 0.09085529445514262, 0.09085529445514262, 0.9326481394477408, 0.9326481394477408, 0.9326481394477408, 0.9161010006971968, 0.9161010006971968, 0.9161010006971968, 0.9467936048065649, 0.9467936048065649, 0.9467936048065649, 0.30837622460373937, 0.30837622460373937, 0.30837622460373937, 0.44944705725995404, 0.44944705725995404, 0.44944705725995404, 0.3684463805935163, 0.3684463805935163, 0.3684463805935163, 0.7811208191069485, 0.7811208191069485, 0.7811208191069485, 0.2783248661780253, 0.2783248661780253, 0.2783248661780253, 0.22271259959225664, 0.22271259959225664, 0.22271259959225664, 0.17115637353833013, 0.17115637353833013, 0.17115637353833013, 0.2779785773670276, 0.2779785773670276, 0.2779785773670276, 0.4432778493609165, 0.4432778493609165, 0.4432778493609165, 0.14790920624742343, 0.14790920624742343, 0.14790920624742343, 0.48090107046886665, 0.48090107046886665, 0.48090107046886665, 0.12598699255307932, 0.12598699255307932, 0.12598699255307932, 0.015427559772149824, 0.015427559772149824, 0.015427559772149824, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011465884999719345, 0.011465884999719345, 0.011465884999719345, 0.06178613834365754, 0.06178613834365754, 0.06178613834365754, 0.1029487277254133, 0.1029487277254133, 0.1029487277254133, 0.07162848498639052, 0.07162848498639052, 0.07162848498639052, 0.11328454463308912, 0.11328454463308912, 0.11328454463308912, 0.16072041379566016, 0.16072041379566016, 0.16072041379566016, 0.15785902472942503, 0.15785902472942503, 0.15785902472942503, 0.04648015921827786, 0.04648015921827786, 0.04648015921827786, 0.1174540587736197, 0.1174540587736197, 0.1174540587736197, 0.0814940044943252, 0.0814940044943252, 0.0814940044943252, 0.5399130636723588, 0.5399130636723588, 0.5399130636723588, 0.5246304832934462, 0.5246304832934462, 0.5246304832934462, 0.5586742245560286, 0.5586742245560286, 0.5586742245560286, 0.5521006895766619, 0.5521006895766619, 0.5521006895766619, 0.15882651106752055, 0.15882651106752055, 0.15882651106752055, 0.13545368768653643, 0.13545368768653643, 0.13545368768653643, 0.19754594708938233, 0.19754594708938233, 0.19754594708938233, 0.18815623468983778, 0.18815623468983778, 0.18815623468983778, 0.13312016966861717, 0.13312016966861717, 0.13312016966861717, 0.35375357250144723, 0.35375357250144723, 0.35375357250144723, 0.3952565146091864, 0.3952565146091864, 0.3952565146091864, 0.2639228737373662, 0.2639228737373662, 0.2639228737373662, 0.17147505613754488, 0.17147505613754488, 0.17147505613754488, 0.21827185705166274, 0.21827185705166274, 0.21827185705166274, 0.2783501193475644, 0.2783501193475644, 0.2783501193475644, 0.21034598279007355, 0.21034598279007355, 0.21034598279007355, 0.268370280410272, 0.268370280410272, 0.268370280410272, 0.21042322195216834, 0.21042322195216834, 0.21042322195216834, 0.2117891065238684, 0.2117891065238684, 0.2117891065238684, 0.2070740682301514, 0.2070740682301514, 0.2070740682301514, 0.2763733040382046, 0.2763733040382046, 0.2763733040382046, 0.9197053146098144, 0.9197053146098144, 0.9197053146098144, 0.15791654523507626, 0.15791654523507626, 0.15791654523507626, 0.7917015363682947, 0.7917015363682947, 0.7917015363682947, 0.38289673757628784, 0.38289673757628784, 0.38289673757628784, 0.31577876740670496, 0.31577876740670496, 0.31577876740670496, 0.540813891936303, 0.540813891936303, 0.540813891936303, 0.20964712066207858, 0.20964712066207858, 0.20964712066207858, 0.18668013378827975, 0.18668013378827975, 0.18668013378827975, 0.19792335260395555, 0.19792335260395555, 0.19792335260395555, 0.09052626915653528, 0.09052626915653528, 0.09052626915653528, 0.09091393002907466, 0.09091393002907466, 0.09091393002907466, 0.1300565709951672, 0.1300565709951672, 0.1300565709951672]}, "mutation_prompt": null}
{"id": "86fafa5f-9b8e-4475-bbb6-3fce0751148a", "solution": "import numpy as np\n\nclass AdaptiveSwarmQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.0\n        self.w_max = 0.8\n        self.w_min = 0.2\n        self.F = 0.7\n        self.CR = 0.9\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + c1 * r1 * (p_best_positions - positions) \n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.15 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveSwarmQuantumHybridPSO_DE", "description": "Adaptive Swarm-Based Quantum-Inspired Hybrid PSO-DE with Dynamic Velocity Scaling and Mutation Strategy for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 75, "fitness": 0.2744246227268992, "feedback": "The algorithm AdaptiveSwarmQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "b008ea76-d623-4c91-bccc-6da557632ce7", "metadata": {"aucs": [0.7655230955860279, 0.7655230955860279, 0.7655230955860279, 0.7801525204228146, 0.7801525204228146, 0.7801525204228146, 0.7633687113243681, 0.7633687113243681, 0.7633687113243681, 0.5041421446899469, 0.5041421446899469, 0.5041421446899469, 0.4232643421182105, 0.4232643421182105, 0.4232643421182105, 0.41262040195904615, 0.41262040195904615, 0.41262040195904615, 0.13362261452763013, 0.13362261452763013, 0.13362261452763013, 0.1225454328453165, 0.1225454328453165, 0.1225454328453165, 0.12039242621194934, 0.12039242621194934, 0.12039242621194934, 0.12689657153931655, 0.12689657153931655, 0.12689657153931655, 0.1207817012241007, 0.1207817012241007, 0.1207817012241007, 0.12854800013305445, 0.12854800013305445, 0.12854800013305445, 0.9806685699012474, 0.9806685699012474, 0.9806685699012474, 0.9783731394857005, 0.9783731394857005, 0.9783731394857005, 0.9858540617271495, 0.9858540617271495, 0.9858540617271495, 0.3472131064089562, 0.3472131064089562, 0.3472131064089562, 0.38393480830701077, 0.38393480830701077, 0.38393480830701077, 0.40808433293209645, 0.40808433293209645, 0.40808433293209645, 0.20526464225838748, 0.20526464225838748, 0.20526464225838748, 0.18946341498402552, 0.18946341498402552, 0.18946341498402552, 0.20917628774963182, 0.20917628774963182, 0.20917628774963182, 0.15593783175092535, 0.15593783175092535, 0.15593783175092535, 0.14042829441476568, 0.14042829441476568, 0.14042829441476568, 0.11675327915465317, 0.11675327915465317, 0.11675327915465317, 0.1019941256383472, 0.1019941256383472, 0.1019941256383472, 0.17731802987004464, 0.17731802987004464, 0.17731802987004464, 0.16036864312495125, 0.16036864312495125, 0.16036864312495125, 0.06368188367911498, 0.06368188367911498, 0.06368188367911498, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05321389736648163, 0.05321389736648163, 0.05321389736648163, 0.08857851407408235, 0.08857851407408235, 0.08857851407408235, 0.03930840760133125, 0.03930840760133125, 0.03930840760133125, 0.0717567709466872, 0.0717567709466872, 0.0717567709466872, 0.03989092581560416, 0.03989092581560416, 0.03989092581560416, 0.12246518576584309, 0.12246518576584309, 0.12246518576584309, 0.15373562822256592, 0.15373562822256592, 0.15373562822256592, 0.05864497959395687, 0.05864497959395687, 0.05864497959395687, 0.143201924497792, 0.143201924497792, 0.143201924497792, 0.05221094799124881, 0.05221094799124881, 0.05221094799124881, 0.47536673840974475, 0.47536673840974475, 0.47536673840974475, 0.4910395394938186, 0.4910395394938186, 0.4910395394938186, 0.5186426013406741, 0.5186426013406741, 0.5186426013406741, 0.10448599597365571, 0.10448599597365571, 0.10448599597365571, 0.12183076001450333, 0.12183076001450333, 0.12183076001450333, 0.1043784872019402, 0.1043784872019402, 0.1043784872019402, 0.1965415209267949, 0.1965415209267949, 0.1965415209267949, 0.19608563958086966, 0.19608563958086966, 0.19608563958086966, 0.18466116287971224, 0.18466116287971224, 0.18466116287971224, 0.3736736912228169, 0.3736736912228169, 0.3736736912228169, 0.33136319693920857, 0.33136319693920857, 0.33136319693920857, 0.3931992336784632, 0.3931992336784632, 0.3931992336784632, 0.16565437245962333, 0.16565437245962333, 0.16565437245962333, 0.15580448213812792, 0.15580448213812792, 0.15580448213812792, 0.24278089964623129, 0.24278089964623129, 0.24278089964623129, 0.2501771018318262, 0.2501771018318262, 0.2501771018318262, 0.20048951609670995, 0.20048951609670995, 0.20048951609670995, 0.20578334266934528, 0.20578334266934528, 0.20578334266934528, 0.20374242792703523, 0.20374242792703523, 0.20374242792703523, 0.19799571076232692, 0.19799571076232692, 0.19799571076232692, 0.21322395634908542, 0.21322395634908542, 0.21322395634908542, 0.7939914111075621, 0.7939914111075621, 0.7939914111075621, 0.5406189342705618, 0.5406189342705618, 0.5406189342705618, 0.19465919275756793, 0.19465919275756793, 0.19465919275756793, 0.36922441285776475, 0.36922441285776475, 0.36922441285776475, 0.37030870024921747, 0.37030870024921747, 0.37030870024921747, 0.46715949555292113, 0.46715949555292113, 0.46715949555292113, 0.21445674580006002, 0.21445674580006002, 0.21445674580006002, 0.20254763195427838, 0.20254763195427838, 0.20254763195427838, 0.17746743706739276, 0.17746743706739276, 0.17746743706739276, 0.09246128906003737, 0.09246128906003737, 0.09246128906003737, 0.08601239546605954, 0.08601239546605954, 0.08601239546605954, 0.09326521680642141, 0.09326521680642141, 0.09326521680642141]}, "mutation_prompt": null}
{"id": "838e26c2-952c-4374-b6d6-cc7ffde08894", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.5\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.initial_diversity = 0.2\n        self.diversity_decay_factor = 0.995\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n        current_diversity = self.initial_diversity\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 2\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + c1 * r1 * (p_best_positions - positions) \n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(current_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n            current_diversity *= self.diversity_decay_factor\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumPSO_DE", "description": "Adaptive Quantum-Inspired PSO-DE with Dynamic Rotational Diversity Control for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 76, "fitness": 0.30366923329558865, "feedback": "The algorithm AdaptiveQuantumPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "b008ea76-d623-4c91-bccc-6da557632ce7", "metadata": {"aucs": [0.909078085133014, 0.909078085133014, 0.909078085133014, 0.7915955958137895, 0.7915955958137895, 0.7915955958137895, 0.8915758952643584, 0.8915758952643584, 0.8915758952643584, 0.6353498402758258, 0.6353498402758258, 0.6353498402758258, 0.33535315761566176, 0.33535315761566176, 0.33535315761566176, 0.5638422008796347, 0.5638422008796347, 0.5638422008796347, 0.17282686298842387, 0.17282686298842387, 0.17282686298842387, 0.14554123727533275, 0.14554123727533275, 0.14554123727533275, 0.1426408731371983, 0.1426408731371983, 0.1426408731371983, 0.16600883395572508, 0.16600883395572508, 0.16600883395572508, 0.09875874921516059, 0.09875874921516059, 0.09875874921516059, 0.1024731988909332, 0.1024731988909332, 0.1024731988909332, 0.9614303449064632, 0.9614303449064632, 0.9614303449064632, 0.9502438139346725, 0.9502438139346725, 0.9502438139346725, 0.9495203389314069, 0.9495203389314069, 0.9495203389314069, 0.3344774614856574, 0.3344774614856574, 0.3344774614856574, 0.40364743556661775, 0.40364743556661775, 0.40364743556661775, 0.3827378825133947, 0.3827378825133947, 0.3827378825133947, 0.3627833711700099, 0.3627833711700099, 0.3627833711700099, 0.2802407647511459, 0.2802407647511459, 0.2802407647511459, 0.22209550381559728, 0.22209550381559728, 0.22209550381559728, 0.16800968623037282, 0.16800968623037282, 0.16800968623037282, 0.1954222965180551, 0.1954222965180551, 0.1954222965180551, 0.18114184387633647, 0.18114184387633647, 0.18114184387633647, 0.2993237123364322, 0.2993237123364322, 0.2993237123364322, 0.17806004705482648, 0.17806004705482648, 0.17806004705482648, 0.19713441068226556, 0.19713441068226556, 0.19713441068226556, 0.0032908706275824873, 0.0032908706275824873, 0.0032908706275824873, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010970549742354674, 0.010970549742354674, 0.010970549742354674, 0.09747618813597914, 0.09747618813597914, 0.09747618813597914, 0.0676400587985525, 0.0676400587985525, 0.0676400587985525, 0.12473472195221402, 0.12473472195221402, 0.12473472195221402, 0.051127391185051274, 0.051127391185051274, 0.051127391185051274, 0.13765264479862593, 0.13765264479862593, 0.13765264479862593, 0.4211251777504218, 0.4211251777504218, 0.4211251777504218, 0.054711649274395535, 0.054711649274395535, 0.054711649274395535, 0.11154559915650075, 0.11154559915650075, 0.11154559915650075, 0.3068223947848461, 0.3068223947848461, 0.3068223947848461, 0.5159494959764269, 0.5159494959764269, 0.5159494959764269, 0.5372946511672988, 0.5372946511672988, 0.5372946511672988, 0.5066709298431178, 0.5066709298431178, 0.5066709298431178, 0.1384862962484933, 0.1384862962484933, 0.1384862962484933, 0.12804443103236285, 0.12804443103236285, 0.12804443103236285, 0.11510846750848946, 0.11510846750848946, 0.11510846750848946, 0.19329467491416574, 0.19329467491416574, 0.19329467491416574, 0.2165429395921431, 0.2165429395921431, 0.2165429395921431, 0.15431902605452197, 0.15431902605452197, 0.15431902605452197, 0.35761890622728854, 0.35761890622728854, 0.35761890622728854, 0.35180162711133633, 0.35180162711133633, 0.35180162711133633, 0.3422340722645485, 0.3422340722645485, 0.3422340722645485, 0.2187030957406535, 0.2187030957406535, 0.2187030957406535, 0.27208224963361205, 0.27208224963361205, 0.27208224963361205, 0.23286469431827905, 0.23286469431827905, 0.23286469431827905, 0.23620506942035158, 0.23620506942035158, 0.23620506942035158, 0.20073923725275122, 0.20073923725275122, 0.20073923725275122, 0.20088937067779677, 0.20088937067779677, 0.20088937067779677, 0.22693265394359663, 0.22693265394359663, 0.22693265394359663, 0.19538753597562697, 0.19538753597562697, 0.19538753597562697, 0.24765483155086065, 0.24765483155086065, 0.24765483155086065, 0.8485911557643274, 0.8485911557643274, 0.8485911557643274, 0.15727703025924078, 0.15727703025924078, 0.15727703025924078, 0.7503162174019349, 0.7503162174019349, 0.7503162174019349, 0.45342998118307687, 0.45342998118307687, 0.45342998118307687, 0.36612782088101525, 0.36612782088101525, 0.36612782088101525, 0.48252999544728525, 0.48252999544728525, 0.48252999544728525, 0.17250095071366378, 0.17250095071366378, 0.17250095071366378, 0.19274048353499018, 0.19274048353499018, 0.19274048353499018, 0.17304763620494013, 0.17304763620494013, 0.17304763620494013, 0.09650527370316064, 0.09650527370316064, 0.09650527370316064, 0.08917906363057515, 0.08917906363057515, 0.08917906363057515, 0.08460424167961378, 0.08460424167961378, 0.08460424167961378]}, "mutation_prompt": null}
{"id": "2a298144-01b7-4924-8237-df9d18ab0e7b", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.8  # Modified for better exploration\n        self.c1_final = 0.4  # Adjusted for better exploitation\n        self.c2_initial = 0.4\n        self.c2_final = 2.8\n        self.w_max = 0.8  # Modified inertia weight for stability\n        self.w_min = 0.4\n        self.F = 0.9  # Slightly increased for diversity\n        self.CR = 0.75  # Adjusted crossover rate\n        self.rotational_diversity = 0.25  # Increased for better exploration\n        self.mutation_probability = 0.1  # Reduced to minimize random disruptions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)  # Linear inertia decay\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * ((evaluations / self.budget) ** 2)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * ((evaluations / self.budget) ** 2)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + c1 * r1 * (p_best_positions - positions) \n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.15 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Dynamic Diversity Enhancement for Superior Convergence.", "configspace": "", "generation": 77, "fitness": 0.25402590152140414, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "b008ea76-d623-4c91-bccc-6da557632ce7", "metadata": {"aucs": [0.6294523372068273, 0.6294523372068273, 0.6294523372068273, 0.621568733976769, 0.621568733976769, 0.621568733976769, 0.6461530877819303, 0.6461530877819303, 0.6461530877819303, 0.2994513934919609, 0.2994513934919609, 0.2994513934919609, 0.3232410139988333, 0.3232410139988333, 0.3232410139988333, 0.35276917740360003, 0.35276917740360003, 0.35276917740360003, 0.11406016385506812, 0.11406016385506812, 0.11406016385506812, 0.11948800059199871, 0.11948800059199871, 0.11948800059199871, 0.14231368779371112, 0.14231368779371112, 0.14231368779371112, 0.09003009501366999, 0.09003009501366999, 0.09003009501366999, 0.090195097014109, 0.090195097014109, 0.090195097014109, 0.0821276671423008, 0.0821276671423008, 0.0821276671423008, 0.9637639080665938, 0.9637639080665938, 0.9637639080665938, 0.9867411889405642, 0.9867411889405642, 0.9867411889405642, 0.9687048242559736, 0.9687048242559736, 0.9687048242559736, 0.34016116596636725, 0.34016116596636725, 0.34016116596636725, 0.3096627686990837, 0.3096627686990837, 0.3096627686990837, 0.29891005194646236, 0.29891005194646236, 0.29891005194646236, 0.5194903050181393, 0.5194903050181393, 0.5194903050181393, 0.6011235443408198, 0.6011235443408198, 0.6011235443408198, 0.3046774719337424, 0.3046774719337424, 0.3046774719337424, 0.14198439925916773, 0.14198439925916773, 0.14198439925916773, 0.135286840528954, 0.135286840528954, 0.135286840528954, 0.17545276887583605, 0.17545276887583605, 0.17545276887583605, 0.11747320764275915, 0.11747320764275915, 0.11747320764275915, 0.14519301771711068, 0.14519301771711068, 0.14519301771711068, 0.16643677086626318, 0.16643677086626318, 0.16643677086626318, 0.014383826037568381, 0.014383826037568381, 0.014383826037568381, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002179252546770871, 0.002179252546770871, 0.002179252546770871, 0.05591075071833207, 0.05591075071833207, 0.05591075071833207, 0.044261145416153336, 0.044261145416153336, 0.044261145416153336, 0.05227126752945499, 0.05227126752945499, 0.05227126752945499, 0.02846827135316321, 0.02846827135316321, 0.02846827135316321, 0.08444945812113236, 0.08444945812113236, 0.08444945812113236, 0.06386684276239807, 0.06386684276239807, 0.06386684276239807, 0.03529154890838149, 0.03529154890838149, 0.03529154890838149, 0.056336130946393115, 0.056336130946393115, 0.056336130946393115, 0.06717550306074027, 0.06717550306074027, 0.06717550306074027, 0.4601791102564765, 0.4601791102564765, 0.4601791102564765, 0.4603132078809522, 0.4603132078809522, 0.4603132078809522, 0.4341154263568897, 0.4341154263568897, 0.4341154263568897, 0.11106161450660401, 0.11106161450660401, 0.11106161450660401, 0.09964224349542239, 0.09964224349542239, 0.09964224349542239, 0.08268368970998308, 0.08268368970998308, 0.08268368970998308, 0.1587505775167587, 0.1587505775167587, 0.1587505775167587, 0.15214157443825826, 0.15214157443825826, 0.15214157443825826, 0.1394492027958567, 0.1394492027958567, 0.1394492027958567, 0.31791218929476917, 0.31791218929476917, 0.31791218929476917, 0.29130982769865, 0.29130982769865, 0.29130982769865, 0.3078093975437408, 0.3078093975437408, 0.3078093975437408, 0.2372977097674006, 0.2372977097674006, 0.2372977097674006, 0.20638414475895206, 0.20638414475895206, 0.20638414475895206, 0.18072645252780617, 0.18072645252780617, 0.18072645252780617, 0.18579902489737332, 0.18579902489737332, 0.18579902489737332, 0.18173216675733694, 0.18173216675733694, 0.18173216675733694, 0.18030193747268874, 0.18030193747268874, 0.18030193747268874, 0.2044065742164617, 0.2044065742164617, 0.2044065742164617, 0.20753558520354187, 0.20753558520354187, 0.20753558520354187, 0.1914437005565599, 0.1914437005565599, 0.1914437005565599, 0.675064903205346, 0.675064903205346, 0.675064903205346, 0.15451825777212813, 0.15451825777212813, 0.15451825777212813, 0.5127684317571739, 0.5127684317571739, 0.5127684317571739, 0.4775911366665777, 0.4775911366665777, 0.4775911366665777, 0.2558597140867004, 0.2558597140867004, 0.2558597140867004, 0.41028934672644957, 0.41028934672644957, 0.41028934672644957, 0.20685361452932693, 0.20685361452932693, 0.20685361452932693, 0.19299438609620456, 0.19299438609620456, 0.19299438609620456, 0.18753369078689908, 0.18753369078689908, 0.18753369078689908, 0.08054272839613241, 0.08054272839613241, 0.08054272839613241, 0.08431868795529263, 0.08431868795529263, 0.08431868795529263, 0.06992796718127814, 0.06992796718127814, 0.06992796718127814]}, "mutation_prompt": null}
{"id": "18f97561-a454-4300-bb3a-b70ffe3d6d8f", "solution": "import numpy as np\n\nclass AdvancedAdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.5\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.2  # Updated value\n        self.mutation_probability = 0.2  # Updated value\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2.5  # Adjusted non-linear inertia decay\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities \n                          + c1 * r1 * (p_best_positions - positions) \n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False)  # Adjusted mutation size\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdvancedAdaptiveQuantumHybridPSO_DE", "description": "Advanced Adaptive Quantum-Inspired Hybrid PSO-DE with Dynamic Rotational Diversity and Mutation Strategies for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 78, "fitness": 0.17582858302515175, "feedback": "The algorithm AdvancedAdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "b008ea76-d623-4c91-bccc-6da557632ce7", "metadata": {"aucs": [0.3310026068843862, 0.3310026068843862, 0.3310026068843862, 0.40024627807110325, 0.40024627807110325, 0.40024627807110325, 0.3767992906774902, 0.3767992906774902, 0.3767992906774902, 0.02238327080704039, 0.02238327080704039, 0.02238327080704039, 0.021003791185715825, 0.021003791185715825, 0.021003791185715825, 0.05327309237253097, 0.05327309237253097, 0.05327309237253097, 0.0829343907819623, 0.0829343907819623, 0.0829343907819623, 0.07228067561193696, 0.07228067561193696, 0.07228067561193696, 0.09892554048162983, 0.09892554048162983, 0.09892554048162983, 0.06891120066987333, 0.06891120066987333, 0.06891120066987333, 0.06340908560723879, 0.06340908560723879, 0.06340908560723879, 0.06154165579284454, 0.06154165579284454, 0.06154165579284454, 0.975817780091244, 0.975817780091244, 0.975817780091244, 0.984955667354235, 0.984955667354235, 0.984955667354235, 0.9917154112431239, 0.9917154112431239, 0.9917154112431239, 0.17542893975843288, 0.17542893975843288, 0.17542893975843288, 0.13216966537247588, 0.13216966537247588, 0.13216966537247588, 0.2072772488453838, 0.2072772488453838, 0.2072772488453838, 0.17657849525163383, 0.17657849525163383, 0.17657849525163383, 0.14659121682381138, 0.14659121682381138, 0.14659121682381138, 0.3634063672336888, 0.3634063672336888, 0.3634063672336888, 0.08778239956428702, 0.08778239956428702, 0.08778239956428702, 0.06321868837151723, 0.06321868837151723, 0.06321868837151723, 0.07050980053724942, 0.07050980053724942, 0.07050980053724942, 0.020180403272339387, 0.020180403272339387, 0.020180403272339387, 0.07992586587333295, 0.07992586587333295, 0.07992586587333295, 0.08691925580607152, 0.08691925580607152, 0.08691925580607152, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018110945679524204, 0.018110945679524204, 0.018110945679524204, 0.05476810891449935, 0.05476810891449935, 0.05476810891449935, 0.0606825915929432, 0.0606825915929432, 0.0606825915929432, 0.012100746721623867, 0.012100746721623867, 0.012100746721623867, 0.014945992747540049, 0.014945992747540049, 0.014945992747540049, 0.012430269777754077, 0.012430269777754077, 0.012430269777754077, 0.0313053385589368, 0.0313053385589368, 0.0313053385589368, 0.023822685154663348, 0.023822685154663348, 0.023822685154663348, 0.0385785462756667, 0.0385785462756667, 0.0385785462756667, 0.33761689399551065, 0.33761689399551065, 0.33761689399551065, 0.3268149834027094, 0.3268149834027094, 0.3268149834027094, 0.32775255703855977, 0.32775255703855977, 0.32775255703855977, 0.075417036299533, 0.075417036299533, 0.075417036299533, 0.0864879251309969, 0.0864879251309969, 0.0864879251309969, 0.07435942903724224, 0.07435942903724224, 0.07435942903724224, 0.15673458334230184, 0.15673458334230184, 0.15673458334230184, 0.17215820595020614, 0.17215820595020614, 0.17215820595020614, 0.15779776009887736, 0.15779776009887736, 0.15779776009887736, 0.20472036543075833, 0.20472036543075833, 0.20472036543075833, 0.1774120244726266, 0.1774120244726266, 0.1774120244726266, 0.22149139312858634, 0.22149139312858634, 0.22149139312858634, 0.18230619018230798, 0.18230619018230798, 0.18230619018230798, 0.17646159099009495, 0.17646159099009495, 0.17646159099009495, 0.18874194346611795, 0.18874194346611795, 0.18874194346611795, 0.16969455021189184, 0.16969455021189184, 0.16969455021189184, 0.17768813789591498, 0.17768813789591498, 0.17768813789591498, 0.1956920205427488, 0.1956920205427488, 0.1956920205427488, 0.17030555802515335, 0.17030555802515335, 0.17030555802515335, 0.15615829424738714, 0.15615829424738714, 0.15615829424738714, 0.1645276028538084, 0.1645276028538084, 0.1645276028538084, 0.43627031333149235, 0.43627031333149235, 0.43627031333149235, 0.17670733291024954, 0.17670733291024954, 0.17670733291024954, 0.321742620094817, 0.321742620094817, 0.321742620094817, 0.2241648237906867, 0.2241648237906867, 0.2241648237906867, 0.17590353685937843, 0.17590353685937843, 0.17590353685937843, 0.17216945026500985, 0.17216945026500985, 0.17216945026500985, 0.1898016275302814, 0.1898016275302814, 0.1898016275302814, 0.18595655627493457, 0.18595655627493457, 0.18595655627493457, 0.1819028630189874, 0.1819028630189874, 0.1819028630189874, 0.07415580766887653, 0.07415580766887653, 0.07415580766887653, 0.06155068266429331, 0.06155068266429331, 0.06155068266429331, 0.07676000789285464, 0.07676000789285464, 0.07676000789285464]}, "mutation_prompt": null}
{"id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "solution": "import numpy as np\n\nclass ImprovedDynamicQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c1_final = 0.7\n        self.c2_initial = 0.7\n        self.c2_final = 2.0\n        self.w_max = 0.85\n        self.w_min = 0.4\n        self.F = 0.9\n        self.CR = 0.9\n        self.rotational_diversity = 0.2\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 2\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.15 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "ImprovedDynamicQuantumHybridPSO_DE", "description": "Improved Dynamic Quantum Hybrid PSO-DE with Adaptive Strategy for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 79, "fitness": 0.32583419056046964, "feedback": "The algorithm ImprovedDynamicQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "b008ea76-d623-4c91-bccc-6da557632ce7", "metadata": {"aucs": [0.869951219899722, 0.869951219899722, 0.869951219899722, 0.8691292760954497, 0.8691292760954497, 0.8691292760954497, 0.8599773200493618, 0.8599773200493618, 0.8599773200493618, 0.5951534914572846, 0.5951534914572846, 0.5951534914572846, 0.329191425131666, 0.329191425131666, 0.329191425131666, 0.5091305086535722, 0.5091305086535722, 0.5091305086535722, 0.13575249203863604, 0.13575249203863604, 0.13575249203863604, 0.42638830374340864, 0.42638830374340864, 0.42638830374340864, 0.1630955070360629, 0.1630955070360629, 0.1630955070360629, 0.14139369227117116, 0.14139369227117116, 0.14139369227117116, 0.14278528802802992, 0.14278528802802992, 0.14278528802802992, 0.1410792750986779, 0.1410792750986779, 0.1410792750986779, 0.9709469144172883, 0.9709469144172883, 0.9709469144172883, 0.9605226624280662, 0.9605226624280662, 0.9605226624280662, 0.9572298423990984, 0.9572298423990984, 0.9572298423990984, 0.43899970233079844, 0.43899970233079844, 0.43899970233079844, 0.5201970937958882, 0.5201970937958882, 0.5201970937958882, 0.4693432165574861, 0.4693432165574861, 0.4693432165574861, 0.7292315227982968, 0.7292315227982968, 0.7292315227982968, 0.21124397085084823, 0.21124397085084823, 0.21124397085084823, 0.6940112409064516, 0.6940112409064516, 0.6940112409064516, 0.2400972341202059, 0.2400972341202059, 0.2400972341202059, 0.16100584656354144, 0.16100584656354144, 0.16100584656354144, 0.15953867610133365, 0.15953867610133365, 0.15953867610133365, 0.17388867014893006, 0.17388867014893006, 0.17388867014893006, 0.1984351060127123, 0.1984351060127123, 0.1984351060127123, 0.16532728554666187, 0.16532728554666187, 0.16532728554666187, 0.0704554786879189, 0.0704554786879189, 0.0704554786879189, 0.03700518390916152, 0.03700518390916152, 0.03700518390916152, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10539476234692524, 0.10539476234692524, 0.10539476234692524, 0.08063216551327856, 0.08063216551327856, 0.08063216551327856, 0.0737306140610241, 0.0737306140610241, 0.0737306140610241, 0.10188925489994016, 0.10188925489994016, 0.10188925489994016, 0.17216329367676297, 0.17216329367676297, 0.17216329367676297, 0.15931939185932387, 0.15931939185932387, 0.15931939185932387, 0.34440701303317955, 0.34440701303317955, 0.34440701303317955, 0.14481807043998396, 0.14481807043998396, 0.14481807043998396, 0.08086840246944771, 0.08086840246944771, 0.08086840246944771, 0.4940000553594561, 0.4940000553594561, 0.4940000553594561, 0.5375330182610272, 0.5375330182610272, 0.5375330182610272, 0.5806065431628367, 0.5806065431628367, 0.5806065431628367, 0.10716795024996317, 0.10716795024996317, 0.10716795024996317, 0.18276065068347902, 0.18276065068347902, 0.18276065068347902, 0.09437904238804151, 0.09437904238804151, 0.09437904238804151, 0.1505080715269187, 0.1505080715269187, 0.1505080715269187, 0.23751959269614376, 0.23751959269614376, 0.23751959269614376, 0.1669099512700083, 0.1669099512700083, 0.1669099512700083, 0.40828200031976747, 0.40828200031976747, 0.40828200031976747, 0.3840490923572484, 0.3840490923572484, 0.3840490923572484, 0.20938492515867357, 0.20938492515867357, 0.20938492515867357, 0.17127881002260548, 0.17127881002260548, 0.17127881002260548, 0.2511693136905404, 0.2511693136905404, 0.2511693136905404, 0.24293146471234994, 0.24293146471234994, 0.24293146471234994, 0.21829255071097842, 0.21829255071097842, 0.21829255071097842, 0.21466770633337218, 0.21466770633337218, 0.21466770633337218, 0.23253801369165028, 0.23253801369165028, 0.23253801369165028, 0.21462240417496048, 0.21462240417496048, 0.21462240417496048, 0.24024636000591582, 0.24024636000591582, 0.24024636000591582, 0.2004196081280194, 0.2004196081280194, 0.2004196081280194, 0.8805248473600764, 0.8805248473600764, 0.8805248473600764, 0.8806764202122961, 0.8806764202122961, 0.8806764202122961, 0.1677817570433071, 0.1677817570433071, 0.1677817570433071, 0.774499820365865, 0.774499820365865, 0.774499820365865, 0.6061757342514132, 0.6061757342514132, 0.6061757342514132, 0.16810150405848867, 0.16810150405848867, 0.16810150405848867, 0.20198008485236973, 0.20198008485236973, 0.20198008485236973, 0.18506044194290716, 0.18506044194290716, 0.18506044194290716, 0.19643570232049357, 0.19643570232049357, 0.19643570232049357, 0.09205623858586043, 0.09205623858586043, 0.09205623858586043, 0.0928615909842414, 0.0928615909842414, 0.0928615909842414, 0.07081003809494268, 0.07081003809494268, 0.07081003809494268]}, "mutation_prompt": null}
{"id": "8ec3acf0-b64d-4f30-9b8c-955986b1a3f9", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.8\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 3\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget) ** 0.5\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget) ** 0.5\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridOptimizer", "description": "Adaptive Quantum-Inspired Hybrid Algorithm with Dynamic Parameter Tuning and Progressive Diversity Mechanisms for Robust Optimization.", "configspace": "", "generation": 80, "fitness": 0.2871598852142221, "feedback": "The algorithm AdaptiveQuantumHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.8657651676650207, 0.8657651676650207, 0.8657651676650207, 0.8583913905689223, 0.8583913905689223, 0.8583913905689223, 0.8603866954665004, 0.8603866954665004, 0.8603866954665004, 0.4551200808816419, 0.4551200808816419, 0.4551200808816419, 0.2415977890107357, 0.2415977890107357, 0.2415977890107357, 0.13752044751032377, 0.13752044751032377, 0.13752044751032377, 0.18515124804440497, 0.18515124804440497, 0.18515124804440497, 0.13092234570338168, 0.13092234570338168, 0.13092234570338168, 0.1664661027430575, 0.1664661027430575, 0.1664661027430575, 0.10072694730193521, 0.10072694730193521, 0.10072694730193521, 0.11408767271990472, 0.11408767271990472, 0.11408767271990472, 0.10121829553143613, 0.10121829553143613, 0.10121829553143613, 0.9349260312691992, 0.9349260312691992, 0.9349260312691992, 0.9321681739475062, 0.9321681739475062, 0.9321681739475062, 0.9292485128185168, 0.9292485128185168, 0.9292485128185168, 0.38214272541626704, 0.38214272541626704, 0.38214272541626704, 0.43670502702840663, 0.43670502702840663, 0.43670502702840663, 0.5148102295509767, 0.5148102295509767, 0.5148102295509767, 0.5846963790659498, 0.5846963790659498, 0.5846963790659498, 0.19461575086739313, 0.19461575086739313, 0.19461575086739313, 0.2209853153452065, 0.2209853153452065, 0.2209853153452065, 0.24484291552933024, 0.24484291552933024, 0.24484291552933024, 0.12319747518790791, 0.12319747518790791, 0.12319747518790791, 0.182507798470957, 0.182507798470957, 0.182507798470957, 0.1894542385712903, 0.1894542385712903, 0.1894542385712903, 0.12902871601792465, 0.12902871601792465, 0.12902871601792465, 0.13292954162838777, 0.13292954162838777, 0.13292954162838777, 0.01871175567008654, 0.01871175567008654, 0.01871175567008654, 0.027028542823664625, 0.027028542823664625, 0.027028542823664625, 0.012044756416733304, 0.012044756416733304, 0.012044756416733304, 0.09574253611355976, 0.09574253611355976, 0.09574253611355976, 0.047275440583987804, 0.047275440583987804, 0.047275440583987804, 0.07914527853155218, 0.07914527853155218, 0.07914527853155218, 0.04887827207172302, 0.04887827207172302, 0.04887827207172302, 0.13976213206149168, 0.13976213206149168, 0.13976213206149168, 0.31065266294779725, 0.31065266294779725, 0.31065266294779725, 0.1034333545524605, 0.1034333545524605, 0.1034333545524605, 0.09068240174705189, 0.09068240174705189, 0.09068240174705189, 0.25094041477198226, 0.25094041477198226, 0.25094041477198226, 0.5117423901639768, 0.5117423901639768, 0.5117423901639768, 0.4716215473721159, 0.4716215473721159, 0.4716215473721159, 0.5258925740634377, 0.5258925740634377, 0.5258925740634377, 0.13116984649036367, 0.13116984649036367, 0.13116984649036367, 0.09942365750234217, 0.09942365750234217, 0.09942365750234217, 0.12584190866062817, 0.12584190866062817, 0.12584190866062817, 0.37101695425607206, 0.37101695425607206, 0.37101695425607206, 0.17118657560837414, 0.17118657560837414, 0.17118657560837414, 0.23717768655925553, 0.23717768655925553, 0.23717768655925553, 0.45654061406957935, 0.45654061406957935, 0.45654061406957935, 0.2514442204730093, 0.2514442204730093, 0.2514442204730093, 0.25982529115799924, 0.25982529115799924, 0.25982529115799924, 0.17069391058497585, 0.17069391058497585, 0.17069391058497585, 0.2188677166109806, 0.2188677166109806, 0.2188677166109806, 0.22515426543653572, 0.22515426543653572, 0.22515426543653572, 0.20546936061004917, 0.20546936061004917, 0.20546936061004917, 0.1909402667778013, 0.1909402667778013, 0.1909402667778013, 0.2839398648805185, 0.2839398648805185, 0.2839398648805185, 0.1963320354538184, 0.1963320354538184, 0.1963320354538184, 0.21177844436989846, 0.21177844436989846, 0.21177844436989846, 0.20567954129305333, 0.20567954129305333, 0.20567954129305333, 0.8998680338233467, 0.8998680338233467, 0.8998680338233467, 0.1575249614196973, 0.1575249614196973, 0.1575249614196973, 0.7058228491591145, 0.7058228491591145, 0.7058228491591145, 0.4001614975514157, 0.4001614975514157, 0.4001614975514157, 0.42348008796216374, 0.42348008796216374, 0.42348008796216374, 0.16666581211243936, 0.16666581211243936, 0.16666581211243936, 0.19212071764429217, 0.19212071764429217, 0.19212071764429217, 0.18445919750845408, 0.18445919750845408, 0.18445919750845408, 0.19292541834608679, 0.19292541834608679, 0.19292541834608679, 0.08638808922484364, 0.08638808922484364, 0.08638808922484364, 0.08740648012542729, 0.08740648012542729, 0.08740648012542729, 0.08303935599734646, 0.08303935599734646, 0.08303935599734646]}, "mutation_prompt": null}
{"id": "676fcd2a-4288-4dfa-b612-dce5785986ee", "solution": "import numpy as np\n\nclass AdaptivePSOwithDynamicMutationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.8\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 3\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptivePSOwithDynamicMutationDE", "description": "Adaptive Particle Swarm Optimization with Dynamic Mutation and Differential Evolution for Enhanced Search Capability.", "configspace": "", "generation": 81, "fitness": 0.19872352529005347, "feedback": "The algorithm AdaptivePSOwithDynamicMutationDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.4805311987107138, 0.4805311987107138, 0.4805311987107138, 0.5078822574807611, 0.5078822574807611, 0.5078822574807611, 0.48599873017581063, 0.48599873017581063, 0.48599873017581063, 0.04041714204026925, 0.04041714204026925, 0.04041714204026925, 0.05597020344769321, 0.05597020344769321, 0.05597020344769321, 0.01884189021188709, 0.01884189021188709, 0.01884189021188709, 0.11386078377588915, 0.11386078377588915, 0.11386078377588915, 0.06845531852432374, 0.06845531852432374, 0.06845531852432374, 0.09187109106700408, 0.09187109106700408, 0.09187109106700408, 0.07414018780289511, 0.07414018780289511, 0.07414018780289511, 0.08986299203875936, 0.08986299203875936, 0.08986299203875936, 0.07843729716134717, 0.07843729716134717, 0.07843729716134717, 0.9708149617047295, 0.9708149617047295, 0.9708149617047295, 0.9844906708106212, 0.9844906708106212, 0.9844906708106212, 0.9928788688200709, 0.9928788688200709, 0.9928788688200709, 0.26984446193429956, 0.26984446193429956, 0.26984446193429956, 0.15533573279548507, 0.15533573279548507, 0.15533573279548507, 0.2087830850317146, 0.2087830850317146, 0.2087830850317146, 0.17506973635842293, 0.17506973635842293, 0.17506973635842293, 0.17313770583821275, 0.17313770583821275, 0.17313770583821275, 0.1828568338538048, 0.1828568338538048, 0.1828568338538048, 0.1202892559002603, 0.1202892559002603, 0.1202892559002603, 0.1187654259066514, 0.1187654259066514, 0.1187654259066514, 0.11735270312238988, 0.11735270312238988, 0.11735270312238988, 0.054332392050572165, 0.054332392050572165, 0.054332392050572165, 0.1263036213931399, 0.1263036213931399, 0.1263036213931399, 0.10493658051223265, 0.10493658051223265, 0.10493658051223265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060521574733511496, 0.060521574733511496, 0.060521574733511496, 0.030902840164793055, 0.030902840164793055, 0.030902840164793055, 0.08074114781096464, 0.08074114781096464, 0.08074114781096464, 0.015187515295749132, 0.015187515295749132, 0.015187515295749132, 0.07032042964263696, 0.07032042964263696, 0.07032042964263696, 0.03146852983455084, 0.03146852983455084, 0.03146852983455084, 0.0274157246669674, 0.0274157246669674, 0.0274157246669674, 0.0981264330785887, 0.0981264330785887, 0.0981264330785887, 0.10106105313680946, 0.10106105313680946, 0.10106105313680946, 0.38338946748204195, 0.38338946748204195, 0.38338946748204195, 0.3604259466758186, 0.3604259466758186, 0.3604259466758186, 0.38083604536511795, 0.38083604536511795, 0.38083604536511795, 0.08788568376247219, 0.08788568376247219, 0.08788568376247219, 0.09843523683413713, 0.09843523683413713, 0.09843523683413713, 0.08805134628548439, 0.08805134628548439, 0.08805134628548439, 0.16991839333314807, 0.16991839333314807, 0.16991839333314807, 0.19318880449549614, 0.19318880449549614, 0.19318880449549614, 0.17665812749833765, 0.17665812749833765, 0.17665812749833765, 0.2678070523298447, 0.2678070523298447, 0.2678070523298447, 0.24956969367657766, 0.24956969367657766, 0.24956969367657766, 0.18734672100817062, 0.18734672100817062, 0.18734672100817062, 0.16953644074510776, 0.16953644074510776, 0.16953644074510776, 0.2037882143570261, 0.2037882143570261, 0.2037882143570261, 0.20639241843254708, 0.20639241843254708, 0.20639241843254708, 0.18242066301465854, 0.18242066301465854, 0.18242066301465854, 0.17518246056033926, 0.17518246056033926, 0.17518246056033926, 0.1903447371564022, 0.1903447371564022, 0.1903447371564022, 0.19586365169080755, 0.19586365169080755, 0.19586365169080755, 0.18390836758672546, 0.18390836758672546, 0.18390836758672546, 0.17935528342350338, 0.17935528342350338, 0.17935528342350338, 0.6046747956612364, 0.6046747956612364, 0.6046747956612364, 0.14548331754939992, 0.14548331754939992, 0.14548331754939992, 0.16905066363644006, 0.16905066363644006, 0.16905066363644006, 0.19428788354046567, 0.19428788354046567, 0.19428788354046567, 0.40499906871491276, 0.40499906871491276, 0.40499906871491276, 0.3271594289418628, 0.3271594289418628, 0.3271594289418628, 0.17223744881917247, 0.17223744881917247, 0.17223744881917247, 0.1817081906881075, 0.1817081906881075, 0.1817081906881075, 0.18380975652134346, 0.18380975652134346, 0.18380975652134346, 0.07548839996890389, 0.07548839996890389, 0.07548839996890389, 0.07176582430012224, 0.07176582430012224, 0.07176582430012224, 0.06961790999358475, 0.06961790999358475, 0.06961790999358475]}, "mutation_prompt": null}
{"id": "ae08c050-2a12-4a10-b6c1-c6e5a7f17424", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Reduced population size for faster convergence\n        self.c1_initial = 1.8  # Adjusted cognitive component\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.2  # Enhanced social component\n        self.w_max = 0.9  # Increased inertia weight for better exploration\n        self.w_min = 0.3\n        self.F = 0.8  # Moderate differential weight\n        self.CR = 0.85  # Slightly reduced crossover rate\n        self.rotational_diversity = 0.25  # Increased diversity factor\n        self.mutation_probability = 0.15  # Slightly higher mutation probability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 2.5  # Adjusted inertia decay\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)  # Increased mutation coverage\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedAdaptiveQuantumPSO_DE", "description": "Enhanced Metaheuristic with Adaptive Quantum-Inspired Dynamics and Rotational Diversity for Robust Global Optimization.", "configspace": "", "generation": 82, "fitness": 0.2950376344627808, "feedback": "The algorithm EnhancedAdaptiveQuantumPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.8997777046638972, 0.8997777046638972, 0.8997777046638972, 0.8610175120453787, 0.8610175120453787, 0.8610175120453787, 0.9073504047458845, 0.9073504047458845, 0.9073504047458845, 0.3378771394626455, 0.3378771394626455, 0.3378771394626455, 0.2632948807093318, 0.2632948807093318, 0.2632948807093318, 0.6046855717274926, 0.6046855717274926, 0.6046855717274926, 0.13895784018244828, 0.13895784018244828, 0.13895784018244828, 0.17965140457993833, 0.17965140457993833, 0.17965140457993833, 0.13871971725021848, 0.13871971725021848, 0.13871971725021848, 0.10059299599031035, 0.10059299599031035, 0.10059299599031035, 0.08190703997812687, 0.08190703997812687, 0.08190703997812687, 0.11485837494007556, 0.11485837494007556, 0.11485837494007556, 0.9425762868432457, 0.9425762868432457, 0.9425762868432457, 0.9115668303719462, 0.9115668303719462, 0.9115668303719462, 0.9421054071555658, 0.9421054071555658, 0.9421054071555658, 0.37258973754391467, 0.37258973754391467, 0.37258973754391467, 0.40682860972235435, 0.40682860972235435, 0.40682860972235435, 0.4255243078598012, 0.4255243078598012, 0.4255243078598012, 0.751199889722363, 0.751199889722363, 0.751199889722363, 0.16453836126856436, 0.16453836126856436, 0.16453836126856436, 0.21012497206473002, 0.21012497206473002, 0.21012497206473002, 0.21424382637024342, 0.21424382637024342, 0.21424382637024342, 0.18942510703493465, 0.18942510703493465, 0.18942510703493465, 0.17161105994602444, 0.17161105994602444, 0.17161105994602444, 0.14840405009344448, 0.14840405009344448, 0.14840405009344448, 0.12766977375264998, 0.12766977375264998, 0.12766977375264998, 0.2170902407879337, 0.2170902407879337, 0.2170902407879337, 0.011278160989922625, 0.011278160989922625, 0.011278160989922625, 0.0027547093990054616, 0.0027547093990054616, 0.0027547093990054616, 0.04598695625295168, 0.04598695625295168, 0.04598695625295168, 0.17208557556306137, 0.17208557556306137, 0.17208557556306137, 0.058944162382941645, 0.058944162382941645, 0.058944162382941645, 0.13483079352600402, 0.13483079352600402, 0.13483079352600402, 0.1634829004503836, 0.1634829004503836, 0.1634829004503836, 0.11238450635944575, 0.11238450635944575, 0.11238450635944575, 0.08899310118504822, 0.08899310118504822, 0.08899310118504822, 0.11802228060245756, 0.11802228060245756, 0.11802228060245756, 0.10195991982512587, 0.10195991982512587, 0.10195991982512587, 0.31959274309578567, 0.31959274309578567, 0.31959274309578567, 0.5085333267068735, 0.5085333267068735, 0.5085333267068735, 0.5297824064487486, 0.5297824064487486, 0.5297824064487486, 0.5295148626486815, 0.5295148626486815, 0.5295148626486815, 0.09263969914956649, 0.09263969914956649, 0.09263969914956649, 0.09031150615336536, 0.09031150615336536, 0.09031150615336536, 0.09100279854671567, 0.09100279854671567, 0.09100279854671567, 0.2338154945630767, 0.2338154945630767, 0.2338154945630767, 0.24108348726879092, 0.24108348726879092, 0.24108348726879092, 0.17054791663081248, 0.17054791663081248, 0.17054791663081248, 0.2683209641465957, 0.2683209641465957, 0.2683209641465957, 0.22288042899306193, 0.22288042899306193, 0.22288042899306193, 0.2538523370077863, 0.2538523370077863, 0.2538523370077863, 0.21263530636335026, 0.21263530636335026, 0.21263530636335026, 0.18906678713740888, 0.18906678713740888, 0.18906678713740888, 0.188743355166335, 0.188743355166335, 0.188743355166335, 0.2446332897827419, 0.2446332897827419, 0.2446332897827419, 0.2019057719013635, 0.2019057719013635, 0.2019057719013635, 0.22734753544756248, 0.22734753544756248, 0.22734753544756248, 0.19496846492716624, 0.19496846492716624, 0.19496846492716624, 0.18303247057712424, 0.18303247057712424, 0.18303247057712424, 0.2170346263021513, 0.2170346263021513, 0.2170346263021513, 0.8220303687237306, 0.8220303687237306, 0.8220303687237306, 0.156123381463542, 0.156123381463542, 0.156123381463542, 0.7560985515066674, 0.7560985515066674, 0.7560985515066674, 0.20516241308586058, 0.20516241308586058, 0.20516241308586058, 0.3592524356552994, 0.3592524356552994, 0.3592524356552994, 0.8278806605734228, 0.8278806605734228, 0.8278806605734228, 0.182887981936658, 0.182887981936658, 0.182887981936658, 0.17612273023113234, 0.17612273023113234, 0.17612273023113234, 0.19426537832443225, 0.19426537832443225, 0.19426537832443225, 0.11060567707440117, 0.11060567707440117, 0.11060567707440117, 0.08158543588392697, 0.08158543588392697, 0.08158543588392697, 0.12453697454626966, 0.12453697454626966, 0.12453697454626966]}, "mutation_prompt": null}
{"id": "0b06465a-4c3a-4f0d-9e68-c978ac4efc62", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c1_final = 0.8\n        self.c2_initial = 0.8\n        self.c2_final = 2.2\n        self.w_max = 0.9\n        self.w_min = 0.35\n        self.F = 0.8\n        self.CR = 0.95\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.12\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 3\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumInspiredPSO_DE", "description": "Adaptive Quantum-Inspired Particle Swarm with Differential Mutation and Reinforced Diversity for Robust Global Exploration.", "configspace": "", "generation": 83, "fitness": 0.27979677796906127, "feedback": "The algorithm AdaptiveQuantumInspiredPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.8587065716700273, 0.8587065716700273, 0.8587065716700273, 0.8378161071687922, 0.8378161071687922, 0.8378161071687922, 0.8441767189182985, 0.8441767189182985, 0.8441767189182985, 0.39537857838948987, 0.39537857838948987, 0.39537857838948987, 0.19778108898436908, 0.19778108898436908, 0.19778108898436908, 0.28487879851637754, 0.28487879851637754, 0.28487879851637754, 0.12443551154085342, 0.12443551154085342, 0.12443551154085342, 0.11629451790637846, 0.11629451790637846, 0.11629451790637846, 0.12064769857351698, 0.12064769857351698, 0.12064769857351698, 0.13802767453016151, 0.13802767453016151, 0.13802767453016151, 0.1247298262781602, 0.1247298262781602, 0.1247298262781602, 0.09527037396679994, 0.09527037396679994, 0.09527037396679994, 0.9623780359251469, 0.9623780359251469, 0.9623780359251469, 0.959239445763499, 0.959239445763499, 0.959239445763499, 0.9534566315392035, 0.9534566315392035, 0.9534566315392035, 0.38015930621430627, 0.38015930621430627, 0.38015930621430627, 0.4049850082161174, 0.4049850082161174, 0.4049850082161174, 0.4796016237690607, 0.4796016237690607, 0.4796016237690607, 0.347558031030721, 0.347558031030721, 0.347558031030721, 0.24752876554077974, 0.24752876554077974, 0.24752876554077974, 0.3977324082350938, 0.3977324082350938, 0.3977324082350938, 0.14416484979123, 0.14416484979123, 0.14416484979123, 0.13578918913870053, 0.13578918913870053, 0.13578918913870053, 0.15845176818594087, 0.15845176818594087, 0.15845176818594087, 0.16660963535335904, 0.16660963535335904, 0.16660963535335904, 0.175349641187182, 0.175349641187182, 0.175349641187182, 0.18094662607333023, 0.18094662607333023, 0.18094662607333023, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07580914953040041, 0.07580914953040041, 0.07580914953040041, 0.03895780075201294, 0.03895780075201294, 0.03895780075201294, 0.10350922208561408, 0.10350922208561408, 0.10350922208561408, 0.04971479046088645, 0.04971479046088645, 0.04971479046088645, 0.1915215215723466, 0.1915215215723466, 0.1915215215723466, 0.19657004656386368, 0.19657004656386368, 0.19657004656386368, 0.16430469808964787, 0.16430469808964787, 0.16430469808964787, 0.13336962839773436, 0.13336962839773436, 0.13336962839773436, 0.1590277087176757, 0.1590277087176757, 0.1590277087176757, 0.5018347619025327, 0.5018347619025327, 0.5018347619025327, 0.5102287580192784, 0.5102287580192784, 0.5102287580192784, 0.5846978201490612, 0.5846978201490612, 0.5846978201490612, 0.10304702081958239, 0.10304702081958239, 0.10304702081958239, 0.09385138780117541, 0.09385138780117541, 0.09385138780117541, 0.07038315489800606, 0.07038315489800606, 0.07038315489800606, 0.1520846030484796, 0.1520846030484796, 0.1520846030484796, 0.15503627661991615, 0.15503627661991615, 0.15503627661991615, 0.20498906949535056, 0.20498906949535056, 0.20498906949535056, 0.38960576535955393, 0.38960576535955393, 0.38960576535955393, 0.276214593896589, 0.276214593896589, 0.276214593896589, 0.3372367406892738, 0.3372367406892738, 0.3372367406892738, 0.2027685119718562, 0.2027685119718562, 0.2027685119718562, 0.22203339455332427, 0.22203339455332427, 0.22203339455332427, 0.2520602293054499, 0.2520602293054499, 0.2520602293054499, 0.22741930422975853, 0.22741930422975853, 0.22741930422975853, 0.2241000966400254, 0.2241000966400254, 0.2241000966400254, 0.1952765231404272, 0.1952765231404272, 0.1952765231404272, 0.19805503141789982, 0.19805503141789982, 0.19805503141789982, 0.2502767357832616, 0.2502767357832616, 0.2502767357832616, 0.1952657911464074, 0.1952657911464074, 0.1952657911464074, 0.874866707506984, 0.874866707506984, 0.874866707506984, 0.3584476000777952, 0.3584476000777952, 0.3584476000777952, 0.16163787452715184, 0.16163787452715184, 0.16163787452715184, 0.3321066187734648, 0.3321066187734648, 0.3321066187734648, 0.5006926767313773, 0.5006926767313773, 0.5006926767313773, 0.384067544220106, 0.384067544220106, 0.384067544220106, 0.18723801962196096, 0.18723801962196096, 0.18723801962196096, 0.18745087305793318, 0.18745087305793318, 0.18745087305793318, 0.1916139032071702, 0.1916139032071702, 0.1916139032071702, 0.09362049049083376, 0.09362049049083376, 0.09362049049083376, 0.09139287174648414, 0.09139287174648414, 0.09139287174648414, 0.09058826434686162, 0.09058826434686162, 0.09058826434686162]}, "mutation_prompt": null}
{"id": "d8a04f82-1b76-4cd5-b589-3a8622c385ac", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 1.9\n        self.c1_final = 0.6\n        self.c2_initial = 0.6\n        self.c2_final = 1.9\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                swap_indices = np.random.rand(self.dim) < self.CR\n                trial_vector[swap_indices] = mutant_vector[swap_indices]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumInspiredHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Enhanced Mutation and Dynamic Coefficients for Balanced Search.", "configspace": "", "generation": 84, "fitness": 0.21148363877886409, "feedback": "The algorithm AdaptiveQuantumInspiredHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.5262470591905877, 0.5262470591905877, 0.5262470591905877, 0.5274798758756711, 0.5274798758756711, 0.5274798758756711, 0.5522827270175625, 0.5522827270175625, 0.5522827270175625, 0.10409346104394768, 0.10409346104394768, 0.10409346104394768, 0.012285691932303555, 0.012285691932303555, 0.012285691932303555, 0.16703293392714824, 0.16703293392714824, 0.16703293392714824, 0.10740097625650291, 0.10740097625650291, 0.10740097625650291, 0.10717017070235613, 0.10717017070235613, 0.10717017070235613, 0.11013584143258082, 0.11013584143258082, 0.11013584143258082, 0.08265030777829019, 0.08265030777829019, 0.08265030777829019, 0.09681348587609351, 0.09681348587609351, 0.09681348587609351, 0.09573611987032815, 0.09573611987032815, 0.09573611987032815, 0.976845981420019, 0.976845981420019, 0.976845981420019, 0.9846593974173463, 0.9846593974173463, 0.9846593974173463, 0.9688689718870309, 0.9688689718870309, 0.9688689718870309, 0.24099473220478285, 0.24099473220478285, 0.24099473220478285, 0.17521122164060177, 0.17521122164060177, 0.17521122164060177, 0.2639461083123731, 0.2639461083123731, 0.2639461083123731, 0.17236392900854403, 0.17236392900854403, 0.17236392900854403, 0.1730860002490876, 0.1730860002490876, 0.1730860002490876, 0.23152325080769376, 0.23152325080769376, 0.23152325080769376, 0.13099065775480723, 0.13099065775480723, 0.13099065775480723, 0.08773089789391375, 0.08773089789391375, 0.08773089789391375, 0.09697450547766606, 0.09697450547766606, 0.09697450547766606, 0.040894453853529966, 0.040894453853529966, 0.040894453853529966, 0.09288236018975438, 0.09288236018975438, 0.09288236018975438, 0.09767069843532172, 0.09767069843532172, 0.09767069843532172, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033979530335627173, 0.0033979530335627173, 0.0033979530335627173, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06190284720907746, 0.06190284720907746, 0.06190284720907746, 0.015670354924259167, 0.015670354924259167, 0.015670354924259167, 0.03627705019809713, 0.03627705019809713, 0.03627705019809713, 0.018739343083719495, 0.018739343083719495, 0.018739343083719495, 0.03776125725585899, 0.03776125725585899, 0.03776125725585899, 0.041040009683228185, 0.041040009683228185, 0.041040009683228185, 0.02511258350128287, 0.02511258350128287, 0.02511258350128287, 0.032266463604678, 0.032266463604678, 0.032266463604678, 0.09614111356267274, 0.09614111356267274, 0.09614111356267274, 0.3669311183873021, 0.3669311183873021, 0.3669311183873021, 0.393298257180261, 0.393298257180261, 0.393298257180261, 0.37658945546255207, 0.37658945546255207, 0.37658945546255207, 0.10920572423764674, 0.10920572423764674, 0.10920572423764674, 0.09312168321737502, 0.09312168321737502, 0.09312168321737502, 0.08450871093107781, 0.08450871093107781, 0.08450871093107781, 0.14392352220596927, 0.14392352220596927, 0.14392352220596927, 0.15423912547986074, 0.15423912547986074, 0.15423912547986074, 0.1696300856331061, 0.1696300856331061, 0.1696300856331061, 0.27153268656213847, 0.27153268656213847, 0.27153268656213847, 0.25167412116798427, 0.25167412116798427, 0.25167412116798427, 0.3028570829131261, 0.3028570829131261, 0.3028570829131261, 0.18902115068644476, 0.18902115068644476, 0.18902115068644476, 0.22926950591326334, 0.22926950591326334, 0.22926950591326334, 0.1104920515190635, 0.1104920515190635, 0.1104920515190635, 0.19107923515720315, 0.19107923515720315, 0.19107923515720315, 0.18195708674110378, 0.18195708674110378, 0.18195708674110378, 0.1912895772403499, 0.1912895772403499, 0.1912895772403499, 0.174629160089103, 0.174629160089103, 0.174629160089103, 0.1911199663626676, 0.1911199663626676, 0.1911199663626676, 0.2281792333910666, 0.2281792333910666, 0.2281792333910666, 0.6003480626624562, 0.6003480626624562, 0.6003480626624562, 0.5045082518577573, 0.5045082518577573, 0.5045082518577573, 0.47982500035658804, 0.47982500035658804, 0.47982500035658804, 0.3198372699654075, 0.3198372699654075, 0.3198372699654075, 0.19862223235795007, 0.19862223235795007, 0.19862223235795007, 0.3458688720904456, 0.3458688720904456, 0.3458688720904456, 0.18987530349005666, 0.18987530349005666, 0.18987530349005666, 0.17710348773996942, 0.17710348773996942, 0.17710348773996942, 0.18544404044384932, 0.18544404044384932, 0.18544404044384932, 0.07429832359838617, 0.07429832359838617, 0.07429832359838617, 0.07436284836650098, 0.07436284836650098, 0.07436284836650098, 0.0796989651578981, 0.0796989651578981, 0.0796989651578981]}, "mutation_prompt": null}
{"id": "66f7b73e-c122-4610-89cc-0d9453b2f70e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 1.8\n        self.c1_final = 0.9\n        self.c2_initial = 0.9\n        self.c2_final = 1.8\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.8\n        self.diversity_factor = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * np.sin(np.pi * evaluations / (2 * self.budget))\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.diversity_factor * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                trial_vector = np.copy(positions[i])\n\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedAdaptiveQuantumPSO_DE", "description": "Enhanced Adaptive Quantum-Inspired Dual Strategy PSO-DE with Stochastic Mutation for Robust Optimization.", "configspace": "", "generation": 85, "fitness": 0.21790143829973097, "feedback": "The algorithm EnhancedAdaptiveQuantumPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.5311573113628292, 0.5311573113628292, 0.5311573113628292, 0.5436383207677439, 0.5436383207677439, 0.5436383207677439, 0.5797056850117956, 0.5797056850117956, 0.5797056850117956, 0.15503147342236334, 0.15503147342236334, 0.15503147342236334, 0.15970650562415467, 0.15970650562415467, 0.15970650562415467, 0.03388776544717764, 0.03388776544717764, 0.03388776544717764, 0.10475130823590806, 0.10475130823590806, 0.10475130823590806, 0.10538408138141753, 0.10538408138141753, 0.10538408138141753, 0.12297221236491152, 0.12297221236491152, 0.12297221236491152, 0.08304610855470784, 0.08304610855470784, 0.08304610855470784, 0.11766039135873085, 0.11766039135873085, 0.11766039135873085, 0.10039424374287098, 0.10039424374287098, 0.10039424374287098, 0.9833385003299578, 0.9833385003299578, 0.9833385003299578, 0.9848032668892222, 0.9848032668892222, 0.9848032668892222, 0.9928788688200709, 0.9928788688200709, 0.9928788688200709, 0.2048976226168735, 0.2048976226168735, 0.2048976226168735, 0.28534727950241845, 0.28534727950241845, 0.28534727950241845, 0.29572070718160226, 0.29572070718160226, 0.29572070718160226, 0.23298518604426977, 0.23298518604426977, 0.23298518604426977, 0.21984679235808646, 0.21984679235808646, 0.21984679235808646, 0.22877093449918573, 0.22877093449918573, 0.22877093449918573, 0.14771230259148727, 0.14771230259148727, 0.14771230259148727, 0.11754326180370245, 0.11754326180370245, 0.11754326180370245, 0.11850631255780242, 0.11850631255780242, 0.11850631255780242, 0.03605008320725789, 0.03605008320725789, 0.03605008320725789, 0.1090338157963413, 0.1090338157963413, 0.1090338157963413, 0.1603435251874591, 0.1603435251874591, 0.1603435251874591, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013703892885041924, 0.00013703892885041924, 0.00013703892885041924, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13351907602704982, 0.13351907602704982, 0.13351907602704982, 0.010782036183665133, 0.010782036183665133, 0.010782036183665133, 0.08807553058070827, 0.08807553058070827, 0.08807553058070827, 0.02303786603412461, 0.02303786603412461, 0.02303786603412461, 0.12090188198092888, 0.12090188198092888, 0.12090188198092888, 0.04708001230602954, 0.04708001230602954, 0.04708001230602954, 0.06936727348854743, 0.06936727348854743, 0.06936727348854743, 0.09371492779741197, 0.09371492779741197, 0.09371492779741197, 0.042518128102609465, 0.042518128102609465, 0.042518128102609465, 0.3898665345814105, 0.3898665345814105, 0.3898665345814105, 0.37762154176932927, 0.37762154176932927, 0.37762154176932927, 0.39615738148988067, 0.39615738148988067, 0.39615738148988067, 0.19248481210109136, 0.19248481210109136, 0.19248481210109136, 0.08941446916719487, 0.08941446916719487, 0.08941446916719487, 0.08719810138194573, 0.08719810138194573, 0.08719810138194573, 0.17617579087922697, 0.17617579087922697, 0.17617579087922697, 0.19679651089971972, 0.19679651089971972, 0.19679651089971972, 0.179571208551923, 0.179571208551923, 0.179571208551923, 0.31529646356714935, 0.31529646356714935, 0.31529646356714935, 0.199903146366328, 0.199903146366328, 0.199903146366328, 0.2891355010375972, 0.2891355010375972, 0.2891355010375972, 0.2176817480814467, 0.2176817480814467, 0.2176817480814467, 0.16485224271983423, 0.16485224271983423, 0.16485224271983423, 0.13135023339057372, 0.13135023339057372, 0.13135023339057372, 0.20553948809050293, 0.20553948809050293, 0.20553948809050293, 0.19393169342613026, 0.19393169342613026, 0.19393169342613026, 0.16270460010706123, 0.16270460010706123, 0.16270460010706123, 0.16673362776507095, 0.16673362776507095, 0.16673362776507095, 0.1713217477270178, 0.1713217477270178, 0.1713217477270178, 0.1988013711787152, 0.1988013711787152, 0.1988013711787152, 0.6017636734566496, 0.6017636734566496, 0.6017636734566496, 0.18157790311415845, 0.18157790311415845, 0.18157790311415845, 0.18389262000934936, 0.18389262000934936, 0.18389262000934936, 0.31520596648972443, 0.31520596648972443, 0.31520596648972443, 0.3629723422764164, 0.3629723422764164, 0.3629723422764164, 0.3695231170931079, 0.3695231170931079, 0.3695231170931079, 0.17990115046675492, 0.17990115046675492, 0.17990115046675492, 0.18138967457019695, 0.18138967457019695, 0.18138967457019695, 0.18581527045216129, 0.18581527045216129, 0.18581527045216129, 0.07871717666908695, 0.07871717666908695, 0.07871717666908695, 0.07284878510684467, 0.07284878510684467, 0.07284878510684467, 0.08831002550675715, 0.08831002550675715, 0.08831002550675715]}, "mutation_prompt": null}
{"id": "f2ae018e-15a3-4df0-a7b1-a7a5605a1357", "solution": "import numpy as np\n\nclass AdaptiveQuantumEnhancedPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.1\n        self.c1_final = 0.8\n        self.c2_initial = 0.8\n        self.c2_final = 2.1\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.85\n        self.CR = 0.8\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 1.5\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * ((evaluations / self.budget) ** 1.2)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * ((evaluations / self.budget) ** 1.2)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumEnhancedPSO_DE", "description": "Adaptive Quantum-Enhanced PSO-DE with Dynamic Parameter Adjustment for Balanced Exploration and Diversity.", "configspace": "", "generation": 86, "fitness": 0.2138641290116744, "feedback": "The algorithm AdaptiveQuantumEnhancedPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.5272701855035677, 0.5272701855035677, 0.5272701855035677, 0.5867018158858659, 0.5867018158858659, 0.5867018158858659, 0.5605870245771829, 0.5605870245771829, 0.5605870245771829, 0.08416332933957915, 0.08416332933957915, 0.08416332933957915, 0.14712210607586407, 0.14712210607586407, 0.14712210607586407, 0.1809648004630907, 0.1809648004630907, 0.1809648004630907, 0.10891364007243665, 0.10891364007243665, 0.10891364007243665, 0.08602824032780232, 0.08602824032780232, 0.08602824032780232, 0.09644270282168332, 0.09644270282168332, 0.09644270282168332, 0.08712239983082037, 0.08712239983082037, 0.08712239983082037, 0.07802663287429479, 0.07802663287429479, 0.07802663287429479, 0.08973600050291952, 0.08973600050291952, 0.08973600050291952, 0.9833704437838083, 0.9833704437838083, 0.9833704437838083, 0.9848055880033826, 0.9848055880033826, 0.9848055880033826, 0.9928788688200709, 0.9928788688200709, 0.9928788688200709, 0.3309155206912413, 0.3309155206912413, 0.3309155206912413, 0.13915643212001583, 0.13915643212001583, 0.13915643212001583, 0.2512397718050857, 0.2512397718050857, 0.2512397718050857, 0.19267804173781633, 0.19267804173781633, 0.19267804173781633, 0.1922451181284689, 0.1922451181284689, 0.1922451181284689, 0.15134038056129906, 0.15134038056129906, 0.15134038056129906, 0.11460860990387844, 0.11460860990387844, 0.11460860990387844, 0.0801466946891164, 0.0801466946891164, 0.0801466946891164, 0.13021349519681358, 0.13021349519681358, 0.13021349519681358, 0.04395357951966272, 0.04395357951966272, 0.04395357951966272, 0.09847532498219169, 0.09847532498219169, 0.09847532498219169, 0.1501525035392144, 0.1501525035392144, 0.1501525035392144, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002147340583047108, 0.002147340583047108, 0.002147340583047108, 0.07535455781984424, 0.07535455781984424, 0.07535455781984424, 0.019008622146170495, 0.019008622146170495, 0.019008622146170495, 0.08138267750440442, 0.08138267750440442, 0.08138267750440442, 0.021830460218253744, 0.021830460218253744, 0.021830460218253744, 0.033572911283581974, 0.033572911283581974, 0.033572911283581974, 0.04797547314066686, 0.04797547314066686, 0.04797547314066686, 0.11795874919076099, 0.11795874919076099, 0.11795874919076099, 0.03057260796669803, 0.03057260796669803, 0.03057260796669803, 0.041902104688648634, 0.041902104688648634, 0.041902104688648634, 0.42294465225263744, 0.42294465225263744, 0.42294465225263744, 0.4214822395923177, 0.4214822395923177, 0.4214822395923177, 0.4052261566218682, 0.4052261566218682, 0.4052261566218682, 0.08915348901575948, 0.08915348901575948, 0.08915348901575948, 0.09736868444826452, 0.09736868444826452, 0.09736868444826452, 0.09270313260784191, 0.09270313260784191, 0.09270313260784191, 0.20201449408957328, 0.20201449408957328, 0.20201449408957328, 0.16130738254523203, 0.16130738254523203, 0.16130738254523203, 0.17890424893955037, 0.17890424893955037, 0.17890424893955037, 0.29816204482979125, 0.29816204482979125, 0.29816204482979125, 0.24709896570849688, 0.24709896570849688, 0.24709896570849688, 0.3169959077899335, 0.3169959077899335, 0.3169959077899335, 0.23068010335120626, 0.23068010335120626, 0.23068010335120626, 0.1585010788254867, 0.1585010788254867, 0.1585010788254867, 0.12812794432423102, 0.12812794432423102, 0.12812794432423102, 0.18012857414171013, 0.18012857414171013, 0.18012857414171013, 0.14842005180813722, 0.14842005180813722, 0.14842005180813722, 0.16771290915799186, 0.16771290915799186, 0.16771290915799186, 0.17150287079222248, 0.17150287079222248, 0.17150287079222248, 0.26211942084674245, 0.26211942084674245, 0.26211942084674245, 0.18319552401063188, 0.18319552401063188, 0.18319552401063188, 0.6808959969278525, 0.6808959969278525, 0.6808959969278525, 0.17340593186190467, 0.17340593186190467, 0.17340593186190467, 0.5346511756286074, 0.5346511756286074, 0.5346511756286074, 0.37994242023080715, 0.37994242023080715, 0.37994242023080715, 0.1890483650942799, 0.1890483650942799, 0.1890483650942799, 0.19473456881798146, 0.19473456881798146, 0.19473456881798146, 0.18568430831139404, 0.18568430831139404, 0.18568430831139404, 0.1791100847488829, 0.1791100847488829, 0.1791100847488829, 0.17210825129683893, 0.17210825129683893, 0.17210825129683893, 0.07303134436925429, 0.07303134436925429, 0.07303134436925429, 0.06586380903138656, 0.06586380903138656, 0.06586380903138656, 0.06482640052248845, 0.06482640052248845, 0.06482640052248845]}, "mutation_prompt": null}
{"id": "89d8e04f-5ce1-4355-b5a2-4e7ab6b18694", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.9\n        self.rotational_diversity = 0.15\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 3\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumSwarmDE", "description": "Adaptive Quantum Swarm with Differential Evolution and Dynamic Strategy Enhancement for Optimized Search.", "configspace": "", "generation": 87, "fitness": 0.3026214776335181, "feedback": "The algorithm AdaptiveQuantumSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.8915081970367138, 0.8915081970367138, 0.8915081970367138, 0.8969857774582959, 0.8969857774582959, 0.8969857774582959, 0.880750746454181, 0.880750746454181, 0.880750746454181, 0.2832378612818408, 0.2832378612818408, 0.2832378612818408, 0.2517357905430201, 0.2517357905430201, 0.2517357905430201, 0.5213176425298004, 0.5213176425298004, 0.5213176425298004, 0.16635404319096125, 0.16635404319096125, 0.16635404319096125, 0.11896341650294384, 0.11896341650294384, 0.11896341650294384, 0.12166461015332986, 0.12166461015332986, 0.12166461015332986, 0.13807527389054663, 0.13807527389054663, 0.13807527389054663, 0.10577925257027598, 0.10577925257027598, 0.10577925257027598, 0.13340707981003108, 0.13340707981003108, 0.13340707981003108, 0.9486963864488897, 0.9486963864488897, 0.9486963864488897, 0.9348165739591346, 0.9348165739591346, 0.9348165739591346, 0.9391148265073194, 0.9391148265073194, 0.9391148265073194, 0.43020782130961, 0.43020782130961, 0.43020782130961, 0.6219594160401769, 0.6219594160401769, 0.6219594160401769, 0.5327295884063297, 0.5327295884063297, 0.5327295884063297, 0.3564430726400223, 0.3564430726400223, 0.3564430726400223, 0.8844353581872455, 0.8844353581872455, 0.8844353581872455, 0.24567395551980442, 0.24567395551980442, 0.24567395551980442, 0.22716312565310226, 0.22716312565310226, 0.22716312565310226, 0.15098567988753875, 0.15098567988753875, 0.15098567988753875, 0.18162978689139786, 0.18162978689139786, 0.18162978689139786, 0.20469612919472113, 0.20469612919472113, 0.20469612919472113, 0.17794503530464678, 0.17794503530464678, 0.17794503530464678, 0.12702644966286458, 0.12702644966286458, 0.12702644966286458, 0.001706132947488781, 0.001706132947488781, 0.001706132947488781, 0.021284960914574547, 0.021284960914574547, 0.021284960914574547, 0.010383057747708646, 0.010383057747708646, 0.010383057747708646, 0.09458122029008986, 0.09458122029008986, 0.09458122029008986, 0.08061764561686668, 0.08061764561686668, 0.08061764561686668, 0.13964590147725742, 0.13964590147725742, 0.13964590147725742, 0.08521469051883812, 0.08521469051883812, 0.08521469051883812, 0.17245117570492752, 0.17245117570492752, 0.17245117570492752, 0.318439993675935, 0.318439993675935, 0.318439993675935, 0.032638639103856226, 0.032638639103856226, 0.032638639103856226, 0.12239491148229786, 0.12239491148229786, 0.12239491148229786, 0.18045684288191732, 0.18045684288191732, 0.18045684288191732, 0.47032307469132295, 0.47032307469132295, 0.47032307469132295, 0.5303500671211024, 0.5303500671211024, 0.5303500671211024, 0.5122582477591919, 0.5122582477591919, 0.5122582477591919, 0.13925611202427046, 0.13925611202427046, 0.13925611202427046, 0.14265668792446717, 0.14265668792446717, 0.14265668792446717, 0.09126387457554774, 0.09126387457554774, 0.09126387457554774, 0.18523620407706232, 0.18523620407706232, 0.18523620407706232, 0.28455273985779694, 0.28455273985779694, 0.28455273985779694, 0.26669733672014717, 0.26669733672014717, 0.26669733672014717, 0.33566039758416044, 0.33566039758416044, 0.33566039758416044, 0.26059621521019694, 0.26059621521019694, 0.26059621521019694, 0.5090089968863066, 0.5090089968863066, 0.5090089968863066, 0.22443506893302967, 0.22443506893302967, 0.22443506893302967, 0.39851197792384574, 0.39851197792384574, 0.39851197792384574, 0.32901994992309136, 0.32901994992309136, 0.32901994992309136, 0.19987068690605014, 0.19987068690605014, 0.19987068690605014, 0.19884085617115188, 0.19884085617115188, 0.19884085617115188, 0.2351110463371685, 0.2351110463371685, 0.2351110463371685, 0.2138677397732952, 0.2138677397732952, 0.2138677397732952, 0.21972247835580683, 0.21972247835580683, 0.21972247835580683, 0.1876682469252291, 0.1876682469252291, 0.1876682469252291, 0.9099909098064506, 0.9099909098064506, 0.9099909098064506, 0.15724346514076482, 0.15724346514076482, 0.15724346514076482, 0.15481246258555237, 0.15481246258555237, 0.15481246258555237, 0.45551668873636864, 0.45551668873636864, 0.45551668873636864, 0.4240220429544358, 0.4240220429544358, 0.4240220429544358, 0.16617584492257487, 0.16617584492257487, 0.16617584492257487, 0.18499279447588268, 0.18499279447588268, 0.18499279447588268, 0.2050709707390299, 0.2050709707390299, 0.2050709707390299, 0.1788452915016735, 0.1788452915016735, 0.1788452915016735, 0.1007966723024114, 0.1007966723024114, 0.1007966723024114, 0.08639942921242039, 0.08639942921242039, 0.08639942921242039, 0.09685374215899478, 0.09685374215899478, 0.09685374215899478]}, "mutation_prompt": null}
{"id": "dbe6036a-5bb3-4065-aca1-f8c9fa4b2470", "solution": "import numpy as np\n\nclass DynamicAdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c1_final = 0.7\n        self.c2_initial = 0.7\n        self.c2_final = 2.0\n        self.w_max = 0.85\n        self.w_min = 0.4\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.15 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "DynamicAdaptiveQuantumHybridPSO_DE", "description": "Dynamic Adaptive Quantum Hybrid PSO-DE with Enhanced Diversity and Mutation Strategies for Robust Optimization.", "configspace": "", "generation": 88, "fitness": 0.24017861205861354, "feedback": "The algorithm DynamicAdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.6486366269378114, 0.6486366269378114, 0.6486366269378114, 0.6982251868411022, 0.6982251868411022, 0.6982251868411022, 0.6974291963786468, 0.6974291963786468, 0.6974291963786468, 0.3078654982614767, 0.3078654982614767, 0.3078654982614767, 0.3629636029632566, 0.3629636029632566, 0.3629636029632566, 0.011157909018810974, 0.011157909018810974, 0.011157909018810974, 0.10546089406763004, 0.10546089406763004, 0.10546089406763004, 0.20418175198504362, 0.20418175198504362, 0.20418175198504362, 0.15092152015492488, 0.15092152015492488, 0.15092152015492488, 0.09130831365260406, 0.09130831365260406, 0.09130831365260406, 0.0837958676635917, 0.0837958676635917, 0.0837958676635917, 0.10600086914367035, 0.10600086914367035, 0.10600086914367035, 0.9758936549942848, 0.9758936549942848, 0.9758936549942848, 0.9838367787086296, 0.9838367787086296, 0.9838367787086296, 0.975733073975377, 0.975733073975377, 0.975733073975377, 0.3904212821063433, 0.3904212821063433, 0.3904212821063433, 0.3361680138810589, 0.3361680138810589, 0.3361680138810589, 0.3566383920477322, 0.3566383920477322, 0.3566383920477322, 0.20908910331582686, 0.20908910331582686, 0.20908910331582686, 0.21125263399515326, 0.21125263399515326, 0.21125263399515326, 0.2674252560676684, 0.2674252560676684, 0.2674252560676684, 0.14376406033971967, 0.14376406033971967, 0.14376406033971967, 0.14796518404536496, 0.14796518404536496, 0.14796518404536496, 0.16105245182720895, 0.16105245182720895, 0.16105245182720895, 0.07724787990740278, 0.07724787990740278, 0.07724787990740278, 0.13615201077408434, 0.13615201077408434, 0.13615201077408434, 0.160373877920584, 0.160373877920584, 0.160373877920584, 0.001937254736317895, 0.001937254736317895, 0.001937254736317895, 0.054486017737899184, 0.054486017737899184, 0.054486017737899184, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0932061086933158, 0.0932061086933158, 0.0932061086933158, 0.030707365910945583, 0.030707365910945583, 0.030707365910945583, 0.06494904905322996, 0.06494904905322996, 0.06494904905322996, 0.04543372154649383, 0.04543372154649383, 0.04543372154649383, 0.05402825065070904, 0.05402825065070904, 0.05402825065070904, 0.06722012551693757, 0.06722012551693757, 0.06722012551693757, 0.1854292575765707, 0.1854292575765707, 0.1854292575765707, 0.07903319308902135, 0.07903319308902135, 0.07903319308902135, 0.04432996237056108, 0.04432996237056108, 0.04432996237056108, 0.4397004133899429, 0.4397004133899429, 0.4397004133899429, 0.4745772068442565, 0.4745772068442565, 0.4745772068442565, 0.47473845255419833, 0.47473845255419833, 0.47473845255419833, 0.08718790433630075, 0.08718790433630075, 0.08718790433630075, 0.10394703258856297, 0.10394703258856297, 0.10394703258856297, 0.12358691246446818, 0.12358691246446818, 0.12358691246446818, 0.16597899206841216, 0.16597899206841216, 0.16597899206841216, 0.17105687073468978, 0.17105687073468978, 0.17105687073468978, 0.16556455751007892, 0.16556455751007892, 0.16556455751007892, 0.21199268626096646, 0.21199268626096646, 0.21199268626096646, 0.3090729184304044, 0.3090729184304044, 0.3090729184304044, 0.3386531485110268, 0.3386531485110268, 0.3386531485110268, 0.2743879347364856, 0.2743879347364856, 0.2743879347364856, 0.17205740420068272, 0.17205740420068272, 0.17205740420068272, 0.1566446082096019, 0.1566446082096019, 0.1566446082096019, 0.19373353388748615, 0.19373353388748615, 0.19373353388748615, 0.20925900054337776, 0.20925900054337776, 0.20925900054337776, 0.19648361866922237, 0.19648361866922237, 0.19648361866922237, 0.191781614311756, 0.191781614311756, 0.191781614311756, 0.17958528571523835, 0.17958528571523835, 0.17958528571523835, 0.19206237255651148, 0.19206237255651148, 0.19206237255651148, 0.7237734054867329, 0.7237734054867329, 0.7237734054867329, 0.186385138157117, 0.186385138157117, 0.186385138157117, 0.20073984919837184, 0.20073984919837184, 0.20073984919837184, 0.45052561580136974, 0.45052561580136974, 0.45052561580136974, 0.1966675416801591, 0.1966675416801591, 0.1966675416801591, 0.20238835080240247, 0.20238835080240247, 0.20238835080240247, 0.18535432177825883, 0.18535432177825883, 0.18535432177825883, 0.17731422756464166, 0.17731422756464166, 0.17731422756464166, 0.17105355764401697, 0.17105355764401697, 0.17105355764401697, 0.06895393274567119, 0.06895393274567119, 0.06895393274567119, 0.08709890758245142, 0.08709890758245142, 0.08709890758245142, 0.08873155339829919, 0.08873155339829919, 0.08873155339829919]}, "mutation_prompt": null}
{"id": "0775ff81-7a61-4992-8b37-ccc766afb88e", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO_DE_DynamicMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.5\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.8\n        self.rotational_diversity = 0.3\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 3\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumPSO_DE_DynamicMutation", "description": "Adaptive Quantum Particle Swarm Optimization with Differential Evolution and Dynamic Mutation for Accelerated Convergence.", "configspace": "", "generation": 89, "fitness": 0.17693593481168335, "feedback": "The algorithm AdaptiveQuantumPSO_DE_DynamicMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.3243497768947292, 0.3243497768947292, 0.3243497768947292, 0.3721762505769731, 0.3721762505769731, 0.3721762505769731, 0.3684369634219713, 0.3684369634219713, 0.3684369634219713, 0.03750393798211826, 0.03750393798211826, 0.03750393798211826, 0.022221505541232367, 0.022221505541232367, 0.022221505541232367, 0.051307795080910545, 0.051307795080910545, 0.051307795080910545, 0.08816598255726016, 0.08816598255726016, 0.08816598255726016, 0.1025109155282764, 0.1025109155282764, 0.1025109155282764, 0.08195043692018789, 0.08195043692018789, 0.08195043692018789, 0.06500540629097973, 0.06500540629097973, 0.06500540629097973, 0.08368365717678494, 0.08368365717678494, 0.08368365717678494, 0.07109279231765597, 0.07109279231765597, 0.07109279231765597, 0.9695065192107043, 0.9695065192107043, 0.9695065192107043, 0.9839733572444307, 0.9839733572444307, 0.9839733572444307, 0.9928788688200709, 0.9928788688200709, 0.9928788688200709, 0.14426029206610835, 0.14426029206610835, 0.14426029206610835, 0.14628572868796086, 0.14628572868796086, 0.14628572868796086, 0.15692388500008714, 0.15692388500008714, 0.15692388500008714, 0.18363337842611904, 0.18363337842611904, 0.18363337842611904, 0.21829803512782098, 0.21829803512782098, 0.21829803512782098, 0.2557138545232679, 0.2557138545232679, 0.2557138545232679, 0.09189441790654618, 0.09189441790654618, 0.09189441790654618, 0.10649713895896129, 0.10649713895896129, 0.10649713895896129, 0.08811633983375833, 0.08811633983375833, 0.08811633983375833, 0.041964457406788225, 0.041964457406788225, 0.041964457406788225, 0.08324197071599371, 0.08324197071599371, 0.08324197071599371, 0.0798230248938051, 0.0798230248938051, 0.0798230248938051, 0.0006869768026479539, 0.0006869768026479539, 0.0006869768026479539, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04705396977884846, 0.04705396977884846, 0.04705396977884846, 0.010037784766526059, 0.010037784766526059, 0.010037784766526059, 0.039326264406821965, 0.039326264406821965, 0.039326264406821965, 0.0070369552754993014, 0.0070369552754993014, 0.0070369552754993014, 0.010740854886430728, 0.010740854886430728, 0.010740854886430728, 0.00764409226207774, 0.00764409226207774, 0.00764409226207774, 0.027181859702157474, 0.027181859702157474, 0.027181859702157474, 0.0469488968428623, 0.0469488968428623, 0.0469488968428623, 0.03634610986258335, 0.03634610986258335, 0.03634610986258335, 0.32679220601080283, 0.32679220601080283, 0.32679220601080283, 0.27865045387816534, 0.27865045387816534, 0.27865045387816534, 0.31250519334307414, 0.31250519334307414, 0.31250519334307414, 0.10621644715985479, 0.10621644715985479, 0.10621644715985479, 0.0608900397110439, 0.0608900397110439, 0.0608900397110439, 0.07314821833956031, 0.07314821833956031, 0.07314821833956031, 0.1370178152414504, 0.1370178152414504, 0.1370178152414504, 0.15039873427927852, 0.15039873427927852, 0.15039873427927852, 0.14434189572776812, 0.14434189572776812, 0.14434189572776812, 0.24827061210857193, 0.24827061210857193, 0.24827061210857193, 0.2514265142759984, 0.2514265142759984, 0.2514265142759984, 0.2192480288644404, 0.2192480288644404, 0.2192480288644404, 0.1508795864289887, 0.1508795864289887, 0.1508795864289887, 0.1533428876522781, 0.1533428876522781, 0.1533428876522781, 0.15404245788946558, 0.15404245788946558, 0.15404245788946558, 0.18273205304439066, 0.18273205304439066, 0.18273205304439066, 0.17650543783547468, 0.17650543783547468, 0.17650543783547468, 0.17377205715669752, 0.17377205715669752, 0.17377205715669752, 0.15243065834390013, 0.15243065834390013, 0.15243065834390013, 0.15402242132977917, 0.15402242132977917, 0.15402242132977917, 0.16067774892952724, 0.16067774892952724, 0.16067774892952724, 0.4139369800705731, 0.4139369800705731, 0.4139369800705731, 0.31680290812357426, 0.31680290812357426, 0.31680290812357426, 0.27341806645892397, 0.27341806645892397, 0.27341806645892397, 0.18492297790671175, 0.18492297790671175, 0.18492297790671175, 0.32021150073220817, 0.32021150073220817, 0.32021150073220817, 0.25561769002703405, 0.25561769002703405, 0.25561769002703405, 0.18648648153690883, 0.18648648153690883, 0.18648648153690883, 0.20106761215388913, 0.20106761215388913, 0.20106761215388913, 0.1757654653959978, 0.1757654653959978, 0.1757654653959978, 0.07051126433388744, 0.07051126433388744, 0.07051126433388744, 0.06247464326553143, 0.06247464326553143, 0.06247464326553143, 0.06623979518749457, 0.06623979518749457, 0.06623979518749457]}, "mutation_prompt": null}
{"id": "774ba27c-ad5f-44a0-96d6-af7a8a24b1fa", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredPSO_SDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.5\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F_initial = 0.8\n        self.F_final = 0.4\n        self.CR = 0.8\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 3\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            F = self.F_initial - (self.F_initial - self.F_final) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumInspiredPSO_SDE", "description": "Adaptive Quantum-Inspired PSO with Stochastic Differential Evolution for Enhanced Exploration using Dynamic Parameters.", "configspace": "", "generation": 90, "fitness": 0.15013204802586325, "feedback": "The algorithm AdaptiveQuantumInspiredPSO_SDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.24223465181902304, 0.24223465181902304, 0.24223465181902304, 0.2787853858578635, 0.2787853858578635, 0.2787853858578635, 0.2794595948688874, 0.2794595948688874, 0.2794595948688874, 0.0009328844985370122, 0.0009328844985370122, 0.0009328844985370122, 0.0025693915346307605, 0.0025693915346307605, 0.0025693915346307605, 0.008881090881314946, 0.008881090881314946, 0.008881090881314946, 0.060754190016496956, 0.060754190016496956, 0.060754190016496956, 0.05471981519057112, 0.05471981519057112, 0.05471981519057112, 0.05936836185593841, 0.05936836185593841, 0.05936836185593841, 0.05760526325783899, 0.05760526325783899, 0.05760526325783899, 0.041497453074370916, 0.041497453074370916, 0.041497453074370916, 0.04961582070333337, 0.04961582070333337, 0.04961582070333337, 0.9785372463210031, 0.9785372463210031, 0.9785372463210031, 0.9567977618208162, 0.9567977618208162, 0.9567977618208162, 0.9928788688200709, 0.9928788688200709, 0.9928788688200709, 0.12054193514912837, 0.12054193514912837, 0.12054193514912837, 0.1260517488547599, 0.1260517488547599, 0.1260517488547599, 0.12521006010165692, 0.12521006010165692, 0.12521006010165692, 0.15877600069622366, 0.15877600069622366, 0.15877600069622366, 0.14306176528666914, 0.14306176528666914, 0.14306176528666914, 0.1590564392528946, 0.1590564392528946, 0.1590564392528946, 0.02942217868414032, 0.02942217868414032, 0.02942217868414032, 0.04562946492636988, 0.04562946492636988, 0.04562946492636988, 0.06047959332147568, 0.06047959332147568, 0.06047959332147568, 0.052789681903995356, 0.052789681903995356, 0.052789681903995356, 0.030172708921516245, 0.030172708921516245, 0.030172708921516245, 0.025012095488418873, 0.025012095488418873, 0.025012095488418873, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023046090992716595, 0.0023046090992716595, 0.0023046090992716595, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09216771746345709, 0.09216771746345709, 0.09216771746345709, 0.043648116341442056, 0.043648116341442056, 0.043648116341442056, 0.08903991391116794, 0.08903991391116794, 0.08903991391116794, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004441572618523071, 0.004441572618523071, 0.004441572618523071, 0.05106766207340119, 0.05106766207340119, 0.05106766207340119, 0.023448797658025766, 0.023448797658025766, 0.023448797658025766, 0.03805859468102335, 0.03805859468102335, 0.03805859468102335, 0.2723847532843674, 0.2723847532843674, 0.2723847532843674, 0.27615239114775203, 0.27615239114775203, 0.27615239114775203, 0.2366997438533328, 0.2366997438533328, 0.2366997438533328, 0.07215807628671334, 0.07215807628671334, 0.07215807628671334, 0.06851124856431556, 0.06851124856431556, 0.06851124856431556, 0.08751961703372613, 0.08751961703372613, 0.08751961703372613, 0.14703233221700607, 0.14703233221700607, 0.14703233221700607, 0.13670024616377252, 0.13670024616377252, 0.13670024616377252, 0.14267326883335296, 0.14267326883335296, 0.14267326883335296, 0.18570795917191285, 0.18570795917191285, 0.18570795917191285, 0.1911099388709414, 0.1911099388709414, 0.1911099388709414, 0.20278420099465833, 0.20278420099465833, 0.20278420099465833, 0.13507485167885203, 0.13507485167885203, 0.13507485167885203, 0.1347418858469842, 0.1347418858469842, 0.1347418858469842, 0.12332542058452123, 0.12332542058452123, 0.12332542058452123, 0.15675129824844147, 0.15675129824844147, 0.15675129824844147, 0.172730648337604, 0.172730648337604, 0.172730648337604, 0.16544962666484475, 0.16544962666484475, 0.16544962666484475, 0.16828133674773815, 0.16828133674773815, 0.16828133674773815, 0.1517966313145115, 0.1517966313145115, 0.1517966313145115, 0.15056116594233337, 0.15056116594233337, 0.15056116594233337, 0.34995229365386593, 0.34995229365386593, 0.34995229365386593, 0.15960487589860828, 0.15960487589860828, 0.15960487589860828, 0.21647938323043725, 0.21647938323043725, 0.21647938323043725, 0.15177054911728938, 0.15177054911728938, 0.15177054911728938, 0.16729246013388133, 0.16729246013388133, 0.16729246013388133, 0.17335749249750665, 0.17335749249750665, 0.17335749249750665, 0.18517772441880032, 0.18517772441880032, 0.18517772441880032, 0.18031848072175616, 0.18031848072175616, 0.18031848072175616, 0.1838808930525373, 0.1838808930525373, 0.1838808930525373, 0.060721987338487216, 0.060721987338487216, 0.060721987338487216, 0.06297725491287309, 0.06297725491287309, 0.06297725491287309, 0.05440898414417117, 0.05440898414417117, 0.05440898414417117]}, "mutation_prompt": null}
{"id": "e161fe55-4fda-4275-b7b4-e72756f860f9", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDynamicPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.8\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 3\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idxs = np.random.choice(self.dim, size=int(self.dim * 0.3), replace=False)\n                    trial_vector[swap_idxs] = mutant_vector[swap_idxs]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "QuantumInspiredAdaptiveDynamicPSO_DE", "description": "Quantum-Inspired Adaptive Dynamic PSO-DE with Variable Mutation Enhancements for Versatile Search Efficiency.", "configspace": "", "generation": 91, "fitness": 0.28322691617358486, "feedback": "The algorithm QuantumInspiredAdaptiveDynamicPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.8695221752529609, 0.8695221752529609, 0.8695221752529609, 0.8584964033218242, 0.8584964033218242, 0.8584964033218242, 0.8642922130019463, 0.8642922130019463, 0.8642922130019463, 0.3138428221912003, 0.3138428221912003, 0.3138428221912003, 0.2543011468077232, 0.2543011468077232, 0.2543011468077232, 0.09741805404478598, 0.09741805404478598, 0.09741805404478598, 0.17989905623845204, 0.17989905623845204, 0.17989905623845204, 0.11359495264102915, 0.11359495264102915, 0.11359495264102915, 0.13928863413763848, 0.13928863413763848, 0.13928863413763848, 0.12309591355984562, 0.12309591355984562, 0.12309591355984562, 0.10480167418136677, 0.10480167418136677, 0.10480167418136677, 0.10431901155512513, 0.10431901155512513, 0.10431901155512513, 0.9038011129293466, 0.9038011129293466, 0.9038011129293466, 0.937229679219594, 0.937229679219594, 0.937229679219594, 0.923733909928897, 0.923733909928897, 0.923733909928897, 0.24753823744935766, 0.24753823744935766, 0.24753823744935766, 0.4613031878317815, 0.4613031878317815, 0.4613031878317815, 0.44855197783620737, 0.44855197783620737, 0.44855197783620737, 0.32520967986015414, 0.32520967986015414, 0.32520967986015414, 0.8479243207894606, 0.8479243207894606, 0.8479243207894606, 0.21194543904809426, 0.21194543904809426, 0.21194543904809426, 0.16899053042588041, 0.16899053042588041, 0.16899053042588041, 0.13073386631217132, 0.13073386631217132, 0.13073386631217132, 0.1740312709141515, 0.1740312709141515, 0.1740312709141515, 0.3764120295303882, 0.3764120295303882, 0.3764120295303882, 0.1530250445502701, 0.1530250445502701, 0.1530250445502701, 0.19427829102957772, 0.19427829102957772, 0.19427829102957772, 0.021638922441579833, 0.021638922441579833, 0.021638922441579833, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013352709291787557, 0.013352709291787557, 0.013352709291787557, 0.08395706161528327, 0.08395706161528327, 0.08395706161528327, 0.07500282916231404, 0.07500282916231404, 0.07500282916231404, 0.12903642611592314, 0.12903642611592314, 0.12903642611592314, 0.09813053524624771, 0.09813053524624771, 0.09813053524624771, 0.23312406533729724, 0.23312406533729724, 0.23312406533729724, 0.18744995278392118, 0.18744995278392118, 0.18744995278392118, 0.1423198473134749, 0.1423198473134749, 0.1423198473134749, 0.22244593971306048, 0.22244593971306048, 0.22244593971306048, 0.2010263290993317, 0.2010263290993317, 0.2010263290993317, 0.5181563746193492, 0.5181563746193492, 0.5181563746193492, 0.5250511121957855, 0.5250511121957855, 0.5250511121957855, 0.502815077188396, 0.502815077188396, 0.502815077188396, 0.1189943450801918, 0.1189943450801918, 0.1189943450801918, 0.13319313167576674, 0.13319313167576674, 0.13319313167576674, 0.1371978824231299, 0.1371978824231299, 0.1371978824231299, 0.19007937772165884, 0.19007937772165884, 0.19007937772165884, 0.177954598358538, 0.177954598358538, 0.177954598358538, 0.16476734288110562, 0.16476734288110562, 0.16476734288110562, 0.26121054786420705, 0.26121054786420705, 0.26121054786420705, 0.24814251164913348, 0.24814251164913348, 0.24814251164913348, 0.3467973471871755, 0.3467973471871755, 0.3467973471871755, 0.1667212812050124, 0.1667212812050124, 0.1667212812050124, 0.3305807284327603, 0.3305807284327603, 0.3305807284327603, 0.19433864058638806, 0.19433864058638806, 0.19433864058638806, 0.2397655441986145, 0.2397655441986145, 0.2397655441986145, 0.22693237797133015, 0.22693237797133015, 0.22693237797133015, 0.2160351074225879, 0.2160351074225879, 0.2160351074225879, 0.20148648711686956, 0.20148648711686956, 0.20148648711686956, 0.1819792347975998, 0.1819792347975998, 0.1819792347975998, 0.20717458702288316, 0.20717458702288316, 0.20717458702288316, 0.8337787110377437, 0.8337787110377437, 0.8337787110377437, 0.15575613262108634, 0.15575613262108634, 0.15575613262108634, 0.47011983843714766, 0.47011983843714766, 0.47011983843714766, 0.38176620146658, 0.38176620146658, 0.38176620146658, 0.32857729261201907, 0.32857729261201907, 0.32857729261201907, 0.1659585375411532, 0.1659585375411532, 0.1659585375411532, 0.19221918149989092, 0.19221918149989092, 0.19221918149989092, 0.19381196385242938, 0.19381196385242938, 0.19381196385242938, 0.1811367304854693, 0.1811367304854693, 0.1811367304854693, 0.0915906435150946, 0.0915906435150946, 0.0915906435150946, 0.09302228935911294, 0.09302228935911294, 0.09302228935911294, 0.08006155176244933, 0.08006155176244933, 0.08006155176244933]}, "mutation_prompt": null}
{"id": "24b1f1b7-3898-4c65-a581-dccfefa6570c", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.5\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumInspiredPSO", "description": "Adaptive Quantum-Inspired Particle Swarm with Enhanced Mutation and Hybrid Learning Strategy.", "configspace": "", "generation": 92, "fitness": 0.189630916773551, "feedback": "The algorithm AdaptiveQuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.41173265654902835, 0.41173265654902835, 0.41173265654902835, 0.4080721617589459, 0.4080721617589459, 0.4080721617589459, 0.4001521671361655, 0.4001521671361655, 0.4001521671361655, 0.01826390228181496, 0.01826390228181496, 0.01826390228181496, 0.012564407641260544, 0.012564407641260544, 0.012564407641260544, 0.024805789544995793, 0.024805789544995793, 0.024805789544995793, 0.12951481245261443, 0.12951481245261443, 0.12951481245261443, 0.09931962189450405, 0.09931962189450405, 0.09931962189450405, 0.12288278278086018, 0.12288278278086018, 0.12288278278086018, 0.0779491011303608, 0.0779491011303608, 0.0779491011303608, 0.0521129433728873, 0.0521129433728873, 0.0521129433728873, 0.07777041796536921, 0.07777041796536921, 0.07777041796536921, 0.9694375544581288, 0.9694375544581288, 0.9694375544581288, 0.9833767310662832, 0.9833767310662832, 0.9833767310662832, 0.9685147152810786, 0.9685147152810786, 0.9685147152810786, 0.20237322813651248, 0.20237322813651248, 0.20237322813651248, 0.17750714159857994, 0.17750714159857994, 0.17750714159857994, 0.16356037386582523, 0.16356037386582523, 0.16356037386582523, 0.23507519355607143, 0.23507519355607143, 0.23507519355607143, 0.15509867206828565, 0.15509867206828565, 0.15509867206828565, 0.22218827791181106, 0.22218827791181106, 0.22218827791181106, 0.12041428267460708, 0.12041428267460708, 0.12041428267460708, 0.11387013014812619, 0.11387013014812619, 0.11387013014812619, 0.11092726833104971, 0.11092726833104971, 0.11092726833104971, 0.04894599289033519, 0.04894599289033519, 0.04894599289033519, 0.08650348989730061, 0.08650348989730061, 0.08650348989730061, 0.04858194613749334, 0.04858194613749334, 0.04858194613749334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0046035463937301735, 0.0046035463937301735, 0.0046035463937301735, 0.0645336058905781, 0.0645336058905781, 0.0645336058905781, 0.04829473733970224, 0.04829473733970224, 0.04829473733970224, 0.06924353623518142, 0.06924353623518142, 0.06924353623518142, 0.0015987549784802768, 0.0015987549784802768, 0.0015987549784802768, 0.0019940135015016347, 0.0019940135015016347, 0.0019940135015016347, 0.02140186286193202, 0.02140186286193202, 0.02140186286193202, 0.12187033484253607, 0.12187033484253607, 0.12187033484253607, 0.03027805847927212, 0.03027805847927212, 0.03027805847927212, 0.044447879101293664, 0.044447879101293664, 0.044447879101293664, 0.36181563891031343, 0.36181563891031343, 0.36181563891031343, 0.33644162852901327, 0.33644162852901327, 0.33644162852901327, 0.35573987028463405, 0.35573987028463405, 0.35573987028463405, 0.09588510356507052, 0.09588510356507052, 0.09588510356507052, 0.06501841960634591, 0.06501841960634591, 0.06501841960634591, 0.08604253951279628, 0.08604253951279628, 0.08604253951279628, 0.1655678241848616, 0.1655678241848616, 0.1655678241848616, 0.2031200187597938, 0.2031200187597938, 0.2031200187597938, 0.1288944866344589, 0.1288944866344589, 0.1288944866344589, 0.18453404516322147, 0.18453404516322147, 0.18453404516322147, 0.23011412081034122, 0.23011412081034122, 0.23011412081034122, 0.23437694576673174, 0.23437694576673174, 0.23437694576673174, 0.1528910409760732, 0.1528910409760732, 0.1528910409760732, 0.15927643791683366, 0.15927643791683366, 0.15927643791683366, 0.16065128659001582, 0.16065128659001582, 0.16065128659001582, 0.17753012406997026, 0.17753012406997026, 0.17753012406997026, 0.18011254173982982, 0.18011254173982982, 0.18011254173982982, 0.18241600118446855, 0.18241600118446855, 0.18241600118446855, 0.1811725762402342, 0.1811725762402342, 0.1811725762402342, 0.17911746993910815, 0.17911746993910815, 0.17911746993910815, 0.2035238814690553, 0.2035238814690553, 0.2035238814690553, 0.5399079696925269, 0.5399079696925269, 0.5399079696925269, 0.14565046198821185, 0.14565046198821185, 0.14565046198821185, 0.381305089272966, 0.381305089272966, 0.381305089272966, 0.19290568996489654, 0.19290568996489654, 0.19290568996489654, 0.4566053246416907, 0.4566053246416907, 0.4566053246416907, 0.2879685521733071, 0.2879685521733071, 0.2879685521733071, 0.18450925171091026, 0.18450925171091026, 0.18450925171091026, 0.1764951290971427, 0.1764951290971427, 0.1764951290971427, 0.19389685774040022, 0.19389685774040022, 0.19389685774040022, 0.08036725992447924, 0.08036725992447924, 0.08036725992447924, 0.07647366222254348, 0.07647366222254348, 0.07647366222254348, 0.06311666525892579, 0.06311666525892579, 0.06311666525892579]}, "mutation_prompt": null}
{"id": "25908418-67f6-4a7b-8ea8-043909be7aa7", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.0\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.8\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptiveQuantumHybridPSO_DE", "description": "Adaptive Quantum-Inspired Hybrid PSO-DE with Dynamic Strategy for Enhanced Convergence and Robust Search.", "configspace": "", "generation": 93, "fitness": 0.22424791377062225, "feedback": "The algorithm AdaptiveQuantumHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.5547578700857527, 0.5547578700857527, 0.5547578700857527, 0.5464967736972198, 0.5464967736972198, 0.5464967736972198, 0.532307026799784, 0.532307026799784, 0.532307026799784, 0.07329436978165849, 0.07329436978165849, 0.07329436978165849, 0.0617038608122743, 0.0617038608122743, 0.0617038608122743, 0.14670632509587034, 0.14670632509587034, 0.14670632509587034, 0.10368674305375558, 0.10368674305375558, 0.10368674305375558, 0.12387402251455826, 0.12387402251455826, 0.12387402251455826, 0.09829084927848819, 0.09829084927848819, 0.09829084927848819, 0.07795265953351149, 0.07795265953351149, 0.07795265953351149, 0.084363083407627, 0.084363083407627, 0.084363083407627, 0.09248584703326046, 0.09248584703326046, 0.09248584703326046, 0.970833213958331, 0.970833213958331, 0.970833213958331, 0.9844906708106212, 0.9844906708106212, 0.9844906708106212, 0.9928788688200709, 0.9928788688200709, 0.9928788688200709, 0.30883618512595956, 0.30883618512595956, 0.30883618512595956, 0.2716033366236599, 0.2716033366236599, 0.2716033366236599, 0.2829912077720934, 0.2829912077720934, 0.2829912077720934, 0.40400606541567785, 0.40400606541567785, 0.40400606541567785, 0.17846057652333835, 0.17846057652333835, 0.17846057652333835, 0.2414085155400163, 0.2414085155400163, 0.2414085155400163, 0.14311530732138034, 0.14311530732138034, 0.14311530732138034, 0.10754785918539178, 0.10754785918539178, 0.10754785918539178, 0.13385993086081138, 0.13385993086081138, 0.13385993086081138, 0.12165092231952934, 0.12165092231952934, 0.12165092231952934, 0.13181920799677826, 0.13181920799677826, 0.13181920799677826, 0.13261983301622526, 0.13261983301622526, 0.13261983301622526, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07714160112040869, 0.07714160112040869, 0.07714160112040869, 0.03896596108375894, 0.03896596108375894, 0.03896596108375894, 0.07676793603437071, 0.07676793603437071, 0.07676793603437071, 0.022907834427483453, 0.022907834427483453, 0.022907834427483453, 0.04802811125785922, 0.04802811125785922, 0.04802811125785922, 0.04141927217842878, 0.04141927217842878, 0.04141927217842878, 0.09713236732864794, 0.09713236732864794, 0.09713236732864794, 0.03778835316173279, 0.03778835316173279, 0.03778835316173279, 0.09559755285923655, 0.09559755285923655, 0.09559755285923655, 0.3792116196164871, 0.3792116196164871, 0.3792116196164871, 0.4517000349640895, 0.4517000349640895, 0.4517000349640895, 0.40283128656013634, 0.40283128656013634, 0.40283128656013634, 0.06431513805465894, 0.06431513805465894, 0.06431513805465894, 0.13529906231227273, 0.13529906231227273, 0.13529906231227273, 0.08733186848240004, 0.08733186848240004, 0.08733186848240004, 0.21447639328231205, 0.21447639328231205, 0.21447639328231205, 0.14575951569105672, 0.14575951569105672, 0.14575951569105672, 0.25240678972827435, 0.25240678972827435, 0.25240678972827435, 0.30703736223669187, 0.30703736223669187, 0.30703736223669187, 0.2755808968323312, 0.2755808968323312, 0.2755808968323312, 0.3010983811808906, 0.3010983811808906, 0.3010983811808906, 0.18971298183636676, 0.18971298183636676, 0.18971298183636676, 0.23500434958989724, 0.23500434958989724, 0.23500434958989724, 0.22505775376196357, 0.22505775376196357, 0.22505775376196357, 0.17710699603297453, 0.17710699603297453, 0.17710699603297453, 0.18454274789724534, 0.18454274789724534, 0.18454274789724534, 0.18152849431734652, 0.18152849431734652, 0.18152849431734652, 0.17552126024125214, 0.17552126024125214, 0.17552126024125214, 0.2638212682898887, 0.2638212682898887, 0.2638212682898887, 0.1906707802043055, 0.1906707802043055, 0.1906707802043055, 0.5674602216474786, 0.5674602216474786, 0.5674602216474786, 0.18163968326578905, 0.18163968326578905, 0.18163968326578905, 0.176618823787819, 0.176618823787819, 0.176618823787819, 0.42280856732932093, 0.42280856732932093, 0.42280856732932093, 0.3797301268427996, 0.3797301268427996, 0.3797301268427996, 0.3509121932674638, 0.3509121932674638, 0.3509121932674638, 0.17704100084362873, 0.17704100084362873, 0.17704100084362873, 0.18412703029406208, 0.18412703029406208, 0.18412703029406208, 0.20586225565164928, 0.20586225565164928, 0.20586225565164928, 0.07159938578183678, 0.07159938578183678, 0.07159938578183678, 0.07601750099977822, 0.07601750099977822, 0.07601750099977822, 0.0739278988247617, 0.0739278988247617, 0.0739278988247617]}, "mutation_prompt": null}
{"id": "51e08b85-5f95-40fc-abba-12d5181b7b27", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 1.8  # Adjusted\n        self.c1_final = 0.8    # Adjusted\n        self.c2_initial = 0.8  # Adjusted\n        self.c2_final = 1.8    # Adjusted\n        self.w_max = 0.9       # Adjusted\n        self.w_min = 0.3       # Adjusted\n        self.F = 0.8           # Adjusted\n        self.CR = 0.85         # Adjusted\n        self.rotational_diversity = 0.25  # Adjusted\n        self.mutation_probability = 0.15  # Adjusted\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 2\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                swap_indices = np.random.choice(self.dim, size=int(self.dim * self.CR), replace=False)  # Adjusted\n                trial_vector[swap_indices] = mutant_vector[swap_indices]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)  # Adjusted\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "QuantumEnhancedAdaptiveHybridPSO_DE", "description": "Quantum-Enhanced Adaptive Hybrid PSO-DE with Stochastic Perturbation for Robust Convergence and Diversity.", "configspace": "", "generation": 94, "fitness": 0.29027543909146486, "feedback": "The algorithm QuantumEnhancedAdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.8793049565326019, 0.8793049565326019, 0.8793049565326019, 0.8782721816935809, 0.8782721816935809, 0.8782721816935809, 0.8792905053702286, 0.8792905053702286, 0.8792905053702286, 0.6762805714361662, 0.6762805714361662, 0.6762805714361662, 0.48647537749340664, 0.48647537749340664, 0.48647537749340664, 0.6601435640800808, 0.6601435640800808, 0.6601435640800808, 0.15084787894857765, 0.15084787894857765, 0.15084787894857765, 0.11559301473371542, 0.11559301473371542, 0.11559301473371542, 0.13793309119021724, 0.13793309119021724, 0.13793309119021724, 0.14007237343470746, 0.14007237343470746, 0.14007237343470746, 0.099520514690976, 0.099520514690976, 0.099520514690976, 0.15052002320804336, 0.15052002320804336, 0.15052002320804336, 0.964750132665286, 0.964750132665286, 0.964750132665286, 0.9656531296328126, 0.9656531296328126, 0.9656531296328126, 0.9391913752053543, 0.9391913752053543, 0.9391913752053543, 0.27824952224962474, 0.27824952224962474, 0.27824952224962474, 0.2780686172765994, 0.2780686172765994, 0.2780686172765994, 0.5505437213620884, 0.5505437213620884, 0.5505437213620884, 0.7573256169516568, 0.7573256169516568, 0.7573256169516568, 0.21862492619886487, 0.21862492619886487, 0.21862492619886487, 0.22594564905594183, 0.22594564905594183, 0.22594564905594183, 0.1911363405612695, 0.1911363405612695, 0.1911363405612695, 0.20150572822817492, 0.20150572822817492, 0.20150572822817492, 0.1598383042579331, 0.1598383042579331, 0.1598383042579331, 0.19400823752693652, 0.19400823752693652, 0.19400823752693652, 0.1866482330342546, 0.1866482330342546, 0.1866482330342546, 0.21449401239117272, 0.21449401239117272, 0.21449401239117272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011585245826642332, 0.011585245826642332, 0.011585245826642332, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07870594917287421, 0.07870594917287421, 0.07870594917287421, 0.03581576154948829, 0.03581576154948829, 0.03581576154948829, 0.0831560175219207, 0.0831560175219207, 0.0831560175219207, 0.050195026809611965, 0.050195026809611965, 0.050195026809611965, 0.08842890582788132, 0.08842890582788132, 0.08842890582788132, 0.12423484429322906, 0.12423484429322906, 0.12423484429322906, 0.11321886915847224, 0.11321886915847224, 0.11321886915847224, 0.27573565830665425, 0.27573565830665425, 0.27573565830665425, 0.08552716127271054, 0.08552716127271054, 0.08552716127271054, 0.5178007664997438, 0.5178007664997438, 0.5178007664997438, 0.543597024226514, 0.543597024226514, 0.543597024226514, 0.5480166628869484, 0.5480166628869484, 0.5480166628869484, 0.1211180225767493, 0.1211180225767493, 0.1211180225767493, 0.11626300897947728, 0.11626300897947728, 0.11626300897947728, 0.11629963582443692, 0.11629963582443692, 0.11629963582443692, 0.23272467444384914, 0.23272467444384914, 0.23272467444384914, 0.24320014769335552, 0.24320014769335552, 0.24320014769335552, 0.21533470800895416, 0.21533470800895416, 0.21533470800895416, 0.36047175196990233, 0.36047175196990233, 0.36047175196990233, 0.3628485918030908, 0.3628485918030908, 0.3628485918030908, 0.21961080675252753, 0.21961080675252753, 0.21961080675252753, 0.2119708068560251, 0.2119708068560251, 0.2119708068560251, 0.16814883820843007, 0.16814883820843007, 0.16814883820843007, 0.224067208312424, 0.224067208312424, 0.224067208312424, 0.2172342296148908, 0.2172342296148908, 0.2172342296148908, 0.20789952898908948, 0.20789952898908948, 0.20789952898908948, 0.2161364153090367, 0.2161364153090367, 0.2161364153090367, 0.1791992592228946, 0.1791992592228946, 0.1791992592228946, 0.1910504327140201, 0.1910504327140201, 0.1910504327140201, 0.2515333165638326, 0.2515333165638326, 0.2515333165638326, 0.9278424780987073, 0.9278424780987073, 0.9278424780987073, 0.1579760853324742, 0.1579760853324742, 0.1579760853324742, 0.1588399349598707, 0.1588399349598707, 0.1588399349598707, 0.34813014460158653, 0.34813014460158653, 0.34813014460158653, 0.16722648661102268, 0.16722648661102268, 0.16722648661102268, 0.2560558347138946, 0.2560558347138946, 0.2560558347138946, 0.2261620333987474, 0.2261620333987474, 0.2261620333987474, 0.19073590324568612, 0.19073590324568612, 0.19073590324568612, 0.20021167438857557, 0.20021167438857557, 0.20021167438857557, 0.0786497516927257, 0.0786497516927257, 0.0786497516927257, 0.08788635029096858, 0.08788635029096858, 0.08788635029096858, 0.10854806064526457, 0.10854806064526457, 0.10854806064526457]}, "mutation_prompt": null}
{"id": "23392ab2-a8c9-488b-804c-da6d9ce51873", "solution": "import numpy as np\n\nclass AdaptivePSO_DE_QRM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.8\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 0.5\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * ((self.budget - evaluations) / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "AdaptivePSO_DE_QRM", "description": "Adaptive Particle Swarm with Differential Evolution and Quantum Rotational Mutation for Robust Black-Box Optimization.", "configspace": "", "generation": 95, "fitness": 0.2782092799591561, "feedback": "The algorithm AdaptivePSO_DE_QRM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.7842468815220838, 0.7842468815220838, 0.7842468815220838, 0.7652207874703627, 0.7652207874703627, 0.7652207874703627, 0.7847459193940658, 0.7847459193940658, 0.7847459193940658, 0.3979530725547036, 0.3979530725547036, 0.3979530725547036, 0.48336734693123207, 0.48336734693123207, 0.48336734693123207, 0.18058103157154348, 0.18058103157154348, 0.18058103157154348, 0.12865860779515714, 0.12865860779515714, 0.12865860779515714, 0.105553939813264, 0.105553939813264, 0.105553939813264, 0.1629589087755734, 0.1629589087755734, 0.1629589087755734, 0.10454907679588121, 0.10454907679588121, 0.10454907679588121, 0.09729242816599781, 0.09729242816599781, 0.09729242816599781, 0.08898243302451103, 0.08898243302451103, 0.08898243302451103, 0.970602907352646, 0.970602907352646, 0.970602907352646, 0.9844906708106212, 0.9844906708106212, 0.9844906708106212, 0.9928788688200709, 0.9928788688200709, 0.9928788688200709, 0.5202688465672622, 0.5202688465672622, 0.5202688465672622, 0.4340515834723071, 0.4340515834723071, 0.4340515834723071, 0.34266920669965273, 0.34266920669965273, 0.34266920669965273, 0.24311079426358784, 0.24311079426358784, 0.24311079426358784, 0.266069638310549, 0.266069638310549, 0.266069638310549, 0.2103639198002193, 0.2103639198002193, 0.2103639198002193, 0.1556609467260467, 0.1556609467260467, 0.1556609467260467, 0.12290840777943812, 0.12290840777943812, 0.12290840777943812, 0.1243961406631584, 0.1243961406631584, 0.1243961406631584, 0.09444567553600258, 0.09444567553600258, 0.09444567553600258, 0.17203003110577286, 0.17203003110577286, 0.17203003110577286, 0.18668240841114137, 0.18668240841114137, 0.18668240841114137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10169834293139046, 0.10169834293139046, 0.10169834293139046, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1485194708448686, 0.1485194708448686, 0.1485194708448686, 0.021764173773169526, 0.021764173773169526, 0.021764173773169526, 0.07337561661608871, 0.07337561661608871, 0.07337561661608871, 0.042076825172887355, 0.042076825172887355, 0.042076825172887355, 0.145028033772848, 0.145028033772848, 0.145028033772848, 0.11945028418152648, 0.11945028418152648, 0.11945028418152648, 0.17163917129481765, 0.17163917129481765, 0.17163917129481765, 0.03488485760227633, 0.03488485760227633, 0.03488485760227633, 0.16688079674087564, 0.16688079674087564, 0.16688079674087564, 0.47792299852895315, 0.47792299852895315, 0.47792299852895315, 0.48620317543608593, 0.48620317543608593, 0.48620317543608593, 0.4707962415887984, 0.4707962415887984, 0.4707962415887984, 0.13180859322302552, 0.13180859322302552, 0.13180859322302552, 0.11013292007192899, 0.11013292007192899, 0.11013292007192899, 0.0860814733691776, 0.0860814733691776, 0.0860814733691776, 0.19391114467207815, 0.19391114467207815, 0.19391114467207815, 0.22664908098292014, 0.22664908098292014, 0.22664908098292014, 0.17006649971607823, 0.17006649971607823, 0.17006649971607823, 0.42563552761342527, 0.42563552761342527, 0.42563552761342527, 0.32241343900599206, 0.32241343900599206, 0.32241343900599206, 0.46209902091192434, 0.46209902091192434, 0.46209902091192434, 0.3112750778935719, 0.3112750778935719, 0.3112750778935719, 0.20678180460125317, 0.20678180460125317, 0.20678180460125317, 0.24774199044677858, 0.24774199044677858, 0.24774199044677858, 0.19733901124183328, 0.19733901124183328, 0.19733901124183328, 0.19732206664376295, 0.19732206664376295, 0.19732206664376295, 0.22607198950190055, 0.22607198950190055, 0.22607198950190055, 0.6746019429617551, 0.6746019429617551, 0.6746019429617551, 0.18148886672789, 0.18148886672789, 0.18148886672789, 0.1859310840515711, 0.1859310840515711, 0.1859310840515711, 0.8718434716989083, 0.8718434716989083, 0.8718434716989083, 0.43974081145159893, 0.43974081145159893, 0.43974081145159893, 0.16610867313919464, 0.16610867313919464, 0.16610867313919464, 0.2042750960186731, 0.2042750960186731, 0.2042750960186731, 0.20697695600222987, 0.20697695600222987, 0.20697695600222987, 0.3249647346674276, 0.3249647346674276, 0.3249647346674276, 0.21210761857445426, 0.21210761857445426, 0.21210761857445426, 0.17687817618316837, 0.17687817618316837, 0.17687817618316837, 0.19640017319441638, 0.19640017319441638, 0.19640017319441638, 0.09083939085942161, 0.09083939085942161, 0.09083939085942161, 0.07787720079525662, 0.07787720079525662, 0.07787720079525662, 0.1405238522201846, 0.1405238522201846, 0.1405238522201846]}, "mutation_prompt": null}
{"id": "6724761e-a24f-4ded-9d99-5fa2159bbe09", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.8\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), \n                                       (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)**2\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * ((evaluations / self.budget)**0.5)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * ((evaluations / self.budget)**0.5)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "EnhancedDifferentialEvolutionQuantumPSO", "description": "Enhanced Differential Evolution with Adaptive Quantum-Inspired PSO for Optimized Exploration and Exploitation Dynamics.", "configspace": "", "generation": 96, "fitness": 0.21864889592632702, "feedback": "The algorithm EnhancedDifferentialEvolutionQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.5360150483720066, 0.5360150483720066, 0.5360150483720066, 0.5945695205508753, 0.5945695205508753, 0.5945695205508753, 0.5641767616816601, 0.5641767616816601, 0.5641767616816601, 0.12570838806479734, 0.12570838806479734, 0.12570838806479734, 0.05413134855579049, 0.05413134855579049, 0.05413134855579049, 0.19109403184212925, 0.19109403184212925, 0.19109403184212925, 0.10191601269300188, 0.10191601269300188, 0.10191601269300188, 0.1019045843269123, 0.1019045843269123, 0.1019045843269123, 0.1056703989544403, 0.1056703989544403, 0.1056703989544403, 0.07687220072916212, 0.07687220072916212, 0.07687220072916212, 0.11831721681740948, 0.11831721681740948, 0.11831721681740948, 0.10720490862570986, 0.10720490862570986, 0.10720490862570986, 0.9765414261325592, 0.9765414261325592, 0.9765414261325592, 0.9869254184153937, 0.9869254184153937, 0.9869254184153937, 0.9690899504548058, 0.9690899504548058, 0.9690899504548058, 0.2877473418292119, 0.2877473418292119, 0.2877473418292119, 0.2648412026637851, 0.2648412026637851, 0.2648412026637851, 0.2914534067499722, 0.2914534067499722, 0.2914534067499722, 0.20424251913955682, 0.20424251913955682, 0.20424251913955682, 0.15503078293242212, 0.15503078293242212, 0.15503078293242212, 0.2924472480411239, 0.2924472480411239, 0.2924472480411239, 0.13725378246379483, 0.13725378246379483, 0.13725378246379483, 0.12010133254853739, 0.12010133254853739, 0.12010133254853739, 0.14308620442698883, 0.14308620442698883, 0.14308620442698883, 0.14953863373713083, 0.14953863373713083, 0.14953863373713083, 0.12438599598130018, 0.12438599598130018, 0.12438599598130018, 0.09088382433606601, 0.09088382433606601, 0.09088382433606601, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033502961857848956, 0.033502961857848956, 0.033502961857848956, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03844973757841885, 0.03844973757841885, 0.03844973757841885, 0.03342949713737231, 0.03342949713737231, 0.03342949713737231, 0.056268713585969854, 0.056268713585969854, 0.056268713585969854, 0.021264468755164523, 0.021264468755164523, 0.021264468755164523, 0.06373508032520858, 0.06373508032520858, 0.06373508032520858, 0.043674574081657536, 0.043674574081657536, 0.043674574081657536, 0.12854287621184723, 0.12854287621184723, 0.12854287621184723, 0.06330997633911994, 0.06330997633911994, 0.06330997633911994, 0.04106713497736014, 0.04106713497736014, 0.04106713497736014, 0.40743701840634283, 0.40743701840634283, 0.40743701840634283, 0.40321652483008996, 0.40321652483008996, 0.40321652483008996, 0.4225012776860202, 0.4225012776860202, 0.4225012776860202, 0.08885648551394587, 0.08885648551394587, 0.08885648551394587, 0.09857610102893455, 0.09857610102893455, 0.09857610102893455, 0.08343271314733991, 0.08343271314733991, 0.08343271314733991, 0.2200488456210301, 0.2200488456210301, 0.2200488456210301, 0.18445178391493278, 0.18445178391493278, 0.18445178391493278, 0.1947235074020357, 0.1947235074020357, 0.1947235074020357, 0.2857064000102165, 0.2857064000102165, 0.2857064000102165, 0.27726316704974774, 0.27726316704974774, 0.27726316704974774, 0.3077290531127741, 0.3077290531127741, 0.3077290531127741, 0.21391806085529574, 0.21391806085529574, 0.21391806085529574, 0.22946989518572714, 0.22946989518572714, 0.22946989518572714, 0.19603314026798502, 0.19603314026798502, 0.19603314026798502, 0.19260740128541853, 0.19260740128541853, 0.19260740128541853, 0.2029152612458056, 0.2029152612458056, 0.2029152612458056, 0.2168285099783115, 0.2168285099783115, 0.2168285099783115, 0.18357044977989911, 0.18357044977989911, 0.18357044977989911, 0.33717875491750515, 0.33717875491750515, 0.33717875491750515, 0.1696096184554734, 0.1696096184554734, 0.1696096184554734, 0.6629458474682346, 0.6629458474682346, 0.6629458474682346, 0.17317042353383605, 0.17317042353383605, 0.17317042353383605, 0.16328705414236533, 0.16328705414236533, 0.16328705414236533, 0.18584211436877995, 0.18584211436877995, 0.18584211436877995, 0.19338817843889589, 0.19338817843889589, 0.19338817843889589, 0.26114769612392974, 0.26114769612392974, 0.26114769612392974, 0.18556555221473703, 0.18556555221473703, 0.18556555221473703, 0.1786127110387422, 0.1786127110387422, 0.1786127110387422, 0.18543539087875938, 0.18543539087875938, 0.18543539087875938, 0.08018813370414846, 0.08018813370414846, 0.08018813370414846, 0.08280342633734383, 0.08280342633734383, 0.08280342633734383, 0.07966549683443047, 0.07966549683443047, 0.07966549683443047]}, "mutation_prompt": null}
{"id": "de3421dc-8d8e-4891-819e-f9dc84ebee9a", "solution": "import numpy as np\n\nclass QuantumAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.5\n        self.c1_final = 0.5\n        self.c2_initial = 0.8\n        self.c2_final = 2.2\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.85\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 2\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "QuantumAdaptiveHybridPSO_DE", "description": "Quantum-Adaptive Hybrid PSO-DE with Dynamic Diversity and Enhanced Exploration-Exploitation Balancing.", "configspace": "", "generation": 97, "fitness": 0.18729309956870652, "feedback": "The algorithm QuantumAdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.4098843831101382, 0.4098843831101382, 0.4098843831101382, 0.433741423290792, 0.433741423290792, 0.433741423290792, 0.45445096864247747, 0.45445096864247747, 0.45445096864247747, 0.020468011297335442, 0.020468011297335442, 0.020468011297335442, 0.019161997908035855, 0.019161997908035855, 0.019161997908035855, 0.0058732671674517345, 0.0058732671674517345, 0.0058732671674517345, 0.10213042692742369, 0.10213042692742369, 0.10213042692742369, 0.09095458985187233, 0.09095458985187233, 0.09095458985187233, 0.08975116596915744, 0.08975116596915744, 0.08975116596915744, 0.08987835187749593, 0.08987835187749593, 0.08987835187749593, 0.08197180534149717, 0.08197180534149717, 0.08197180534149717, 0.0902828149182413, 0.0902828149182413, 0.0902828149182413, 0.9778087623335453, 0.9778087623335453, 0.9778087623335453, 0.9836953812733722, 0.9836953812733722, 0.9836953812733722, 0.974590899156033, 0.974590899156033, 0.974590899156033, 0.23782835983685435, 0.23782835983685435, 0.23782835983685435, 0.195785973958725, 0.195785973958725, 0.195785973958725, 0.2127996910558302, 0.2127996910558302, 0.2127996910558302, 0.15814153598575775, 0.15814153598575775, 0.15814153598575775, 0.22322964122033973, 0.22322964122033973, 0.22322964122033973, 0.1922285892876916, 0.1922285892876916, 0.1922285892876916, 0.13293908328627746, 0.13293908328627746, 0.13293908328627746, 0.11176423176593997, 0.11176423176593997, 0.11176423176593997, 0.10266943391874706, 0.10266943391874706, 0.10266943391874706, 0.07696965435108527, 0.07696965435108527, 0.07696965435108527, 0.10111319434012134, 0.10111319434012134, 0.10111319434012134, 0.12429590858690864, 0.12429590858690864, 0.12429590858690864, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00171350358289879, 0.00171350358289879, 0.00171350358289879, 0.0016732411472119013, 0.0016732411472119013, 0.0016732411472119013, 0.034484166505146074, 0.034484166505146074, 0.034484166505146074, 0.014942923279582798, 0.014942923279582798, 0.014942923279582798, 0.03505045005805063, 0.03505045005805063, 0.03505045005805063, 0.006892068885245295, 0.006892068885245295, 0.006892068885245295, 0.018872840257048162, 0.018872840257048162, 0.018872840257048162, 0.02391621213941031, 0.02391621213941031, 0.02391621213941031, 0.06737267813278636, 0.06737267813278636, 0.06737267813278636, 0.07505510600083964, 0.07505510600083964, 0.07505510600083964, 0.03233718599629609, 0.03233718599629609, 0.03233718599629609, 0.32945267411601875, 0.32945267411601875, 0.32945267411601875, 0.3639761826083455, 0.3639761826083455, 0.3639761826083455, 0.3203399689279426, 0.3203399689279426, 0.3203399689279426, 0.07494669622700167, 0.07494669622700167, 0.07494669622700167, 0.08882292125801527, 0.08882292125801527, 0.08882292125801527, 0.08871954477881516, 0.08871954477881516, 0.08871954477881516, 0.20053166502483732, 0.20053166502483732, 0.20053166502483732, 0.16948558721259654, 0.16948558721259654, 0.16948558721259654, 0.18609200242318813, 0.18609200242318813, 0.18609200242318813, 0.24951203871872485, 0.24951203871872485, 0.24951203871872485, 0.22582678626736774, 0.22582678626736774, 0.22582678626736774, 0.19917774348817108, 0.19917774348817108, 0.19917774348817108, 0.17735657352114098, 0.17735657352114098, 0.17735657352114098, 0.17307133556258214, 0.17307133556258214, 0.17307133556258214, 0.17744977998393785, 0.17744977998393785, 0.17744977998393785, 0.17677011092250416, 0.17677011092250416, 0.17677011092250416, 0.17870273909460843, 0.17870273909460843, 0.17870273909460843, 0.17097475105550508, 0.17097475105550508, 0.17097475105550508, 0.17276639184650777, 0.17276639184650777, 0.17276639184650777, 0.16517309763337673, 0.16517309763337673, 0.16517309763337673, 0.14921112271549342, 0.14921112271549342, 0.14921112271549342, 0.5481257604204575, 0.5481257604204575, 0.5481257604204575, 0.16753355704426465, 0.16753355704426465, 0.16753355704426465, 0.1804355742439464, 0.1804355742439464, 0.1804355742439464, 0.3338800696044214, 0.3338800696044214, 0.3338800696044214, 0.24509138436263234, 0.24509138436263234, 0.24509138436263234, 0.19076355830708502, 0.19076355830708502, 0.19076355830708502, 0.17855175658184363, 0.17855175658184363, 0.17855175658184363, 0.18528456171307517, 0.18528456171307517, 0.18528456171307517, 0.18547208723665676, 0.18547208723665676, 0.18547208723665676, 0.07151694836622935, 0.07151694836622935, 0.07151694836622935, 0.06696192417647451, 0.06696192417647451, 0.06696192417647451, 0.08630635085943728, 0.08630635085943728, 0.08630635085943728]}, "mutation_prompt": null}
{"id": "0a03295d-e58b-45b0-9b66-271feb5ee534", "solution": "import numpy as np\n\nclass QuantumInformedDynamicHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.8\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget) ** 0.5\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                swap_idx = np.random.randint(self.dim)\n                trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.2 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "QuantumInformedDynamicHybridPSO_DE", "description": "Quantum Informed Dynamic Hybrid PSO-DE with Adaptive Control for Enhanced Convergence Speed and Diversity.", "configspace": "", "generation": 98, "fitness": 0.27140746275052796, "feedback": "The algorithm QuantumInformedDynamicHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.7399058520252046, 0.7399058520252046, 0.7399058520252046, 0.7280029335480229, 0.7280029335480229, 0.7280029335480229, 0.7451576031059568, 0.7451576031059568, 0.7451576031059568, 0.42721722759988445, 0.42721722759988445, 0.42721722759988445, 0.3858325937385677, 0.3858325937385677, 0.3858325937385677, 0.43114584123027977, 0.43114584123027977, 0.43114584123027977, 0.12475751791047118, 0.12475751791047118, 0.12475751791047118, 0.13234922876578514, 0.13234922876578514, 0.13234922876578514, 0.12237008433470564, 0.12237008433470564, 0.12237008433470564, 0.13020112438569775, 0.13020112438569775, 0.13020112438569775, 0.09676354951198607, 0.09676354951198607, 0.09676354951198607, 0.13972185339083898, 0.13972185339083898, 0.13972185339083898, 0.9779448203418727, 0.9779448203418727, 0.9779448203418727, 0.9845135820009617, 0.9845135820009617, 0.9845135820009617, 0.9928728112256704, 0.9928728112256704, 0.9928728112256704, 0.42639809580484167, 0.42639809580484167, 0.42639809580484167, 0.15521013328507416, 0.15521013328507416, 0.15521013328507416, 0.41668313602451623, 0.41668313602451623, 0.41668313602451623, 0.5788424088870506, 0.5788424088870506, 0.5788424088870506, 0.1991994623987906, 0.1991994623987906, 0.1991994623987906, 0.2164459449499011, 0.2164459449499011, 0.2164459449499011, 0.1497459851153018, 0.1497459851153018, 0.1497459851153018, 0.14820962632791546, 0.14820962632791546, 0.14820962632791546, 0.14569991199544807, 0.14569991199544807, 0.14569991199544807, 0.1055564700752335, 0.1055564700752335, 0.1055564700752335, 0.14839785315481568, 0.14839785315481568, 0.14839785315481568, 0.17006566970021653, 0.17006566970021653, 0.17006566970021653, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09855419642580432, 0.09855419642580432, 0.09855419642580432, 0.051133967135690184, 0.051133967135690184, 0.051133967135690184, 0.0902709630481433, 0.0902709630481433, 0.0902709630481433, 0.03667902113188537, 0.03667902113188537, 0.03667902113188537, 0.17396244567756625, 0.17396244567756625, 0.17396244567756625, 0.15880825070092464, 0.15880825070092464, 0.15880825070092464, 0.05786733734072036, 0.05786733734072036, 0.05786733734072036, 0.08616176227367067, 0.08616176227367067, 0.08616176227367067, 0.12603136950972915, 0.12603136950972915, 0.12603136950972915, 0.45477392849164644, 0.45477392849164644, 0.45477392849164644, 0.4762558883540631, 0.4762558883540631, 0.4762558883540631, 0.4817259518959317, 0.4817259518959317, 0.4817259518959317, 0.10086157670964835, 0.10086157670964835, 0.10086157670964835, 0.41440767289436387, 0.41440767289436387, 0.41440767289436387, 0.12569674338817327, 0.12569674338817327, 0.12569674338817327, 0.2064712296935911, 0.2064712296935911, 0.2064712296935911, 0.16954186247793135, 0.16954186247793135, 0.16954186247793135, 0.2116577356518895, 0.2116577356518895, 0.2116577356518895, 0.3101986266453842, 0.3101986266453842, 0.3101986266453842, 0.2577194347447709, 0.2577194347447709, 0.2577194347447709, 0.3223608233544034, 0.3223608233544034, 0.3223608233544034, 0.2774262427654045, 0.2774262427654045, 0.2774262427654045, 0.1798307153308173, 0.1798307153308173, 0.1798307153308173, 0.23613144822768606, 0.23613144822768606, 0.23613144822768606, 0.21253563206827453, 0.21253563206827453, 0.21253563206827453, 0.2044849746463122, 0.2044849746463122, 0.2044849746463122, 0.20343968546700542, 0.20343968546700542, 0.20343968546700542, 0.18610195092890391, 0.18610195092890391, 0.18610195092890391, 0.2201145690138746, 0.2201145690138746, 0.2201145690138746, 0.22159762833360064, 0.22159762833360064, 0.22159762833360064, 0.7144531073036549, 0.7144531073036549, 0.7144531073036549, 0.15816292638196905, 0.15816292638196905, 0.15816292638196905, 0.1824306171757658, 0.1824306171757658, 0.1824306171757658, 0.28482443240158273, 0.28482443240158273, 0.28482443240158273, 0.5432388249872468, 0.5432388249872468, 0.5432388249872468, 0.4119927541395949, 0.4119927541395949, 0.4119927541395949, 0.19891059720633164, 0.19891059720633164, 0.19891059720633164, 0.19218892263253873, 0.19218892263253873, 0.19218892263253873, 0.20628755930113007, 0.20628755930113007, 0.20628755930113007, 0.09321502120499114, 0.09321502120499114, 0.09321502120499114, 0.09098137158055875, 0.09098137158055875, 0.09098137158055875, 0.09233622855982504, 0.09233622855982504, 0.09233622855982504]}, "mutation_prompt": null}
{"id": "57455783-2fa9-453f-8dcd-c919cff2b2ca", "solution": "import numpy as np\n\nclass QuantumAdaptivePSO_DE_Tunneling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 60\n        self.c1_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_initial = 0.5\n        self.c2_final = 2.5\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.F = 0.8\n        self.CR = 0.9\n        self.rotational_diversity = 0.25\n        self.mutation_probability = 0.15\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.upper_bound - self.lower_bound), abs(self.upper_bound - self.lower_bound), (self.population_size, self.dim))\n        p_best_positions = np.copy(positions)\n        p_best_scores = np.full(self.population_size, np.inf)\n        g_best_position = None\n        g_best_score = np.inf\n        evaluations = 0\n\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (1 - evaluations / self.budget) ** 2\n            c1 = self.c1_initial - (self.c1_initial - self.c1_final) * np.sin(evaluations / self.budget * np.pi / 2)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(positions[i])\n                evaluations += 1\n                if score < p_best_scores[i]:\n                    p_best_scores[i] = score\n                    p_best_positions[i] = positions[i]\n                if score < g_best_score:\n                    g_best_score = score\n                    g_best_position = positions[i]\n\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (w * velocities\n                          + c1 * r1 * (p_best_positions - positions)\n                          + c2 * r2 * (g_best_position - positions))\n            positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n\n            clone_count = int(self.rotational_diversity * self.population_size)\n            for i in range(clone_count):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n\n                trial_vector = np.copy(positions[i])\n                if np.random.rand() < self.CR:\n                    swap_idx = np.random.randint(self.dim)\n                    trial_vector[swap_idx] = mutant_vector[swap_idx]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < p_best_scores[i]:\n                    p_best_scores[i] = trial_score\n                    positions[i] = trial_vector\n                    if trial_score < g_best_score:\n                        g_best_score = trial_score\n                        g_best_position = trial_vector\n\n            if np.random.rand() < self.mutation_probability:\n                mutation_indices = np.random.choice(self.population_size, size=int(0.15 * self.population_size), replace=False)\n                for idx in mutation_indices:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[idx] = mutation_vector\n                    score = func(positions[idx])\n                    evaluations += 1\n                    if score < p_best_scores[idx]:\n                        p_best_scores[idx] = score\n                        p_best_positions[idx] = positions[idx]\n                        if score < g_best_score:\n                            g_best_score = score\n                            g_best_position = positions[idx]\n\n        return g_best_position, g_best_score", "name": "QuantumAdaptivePSO_DE_Tunneling", "description": "Quantum-Inspired Adaptive PSO-DE with Stochastic Tunneling for Enhanced Global Search and Convergence.", "configspace": "", "generation": 99, "fitness": 0.28024162170480305, "feedback": "The algorithm QuantumAdaptivePSO_DE_Tunneling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "0c83ea2e-37a9-4e8c-8f1a-ef81a05d8098", "metadata": {"aucs": [0.8981040755275072, 0.8981040755275072, 0.8981040755275072, 0.8447029098575429, 0.8447029098575429, 0.8447029098575429, 0.8910347791607074, 0.8910347791607074, 0.8910347791607074, 0.2410895065850832, 0.2410895065850832, 0.2410895065850832, 0.169464785651937, 0.169464785651937, 0.169464785651937, 0.40054665242088494, 0.40054665242088494, 0.40054665242088494, 0.14208947485991608, 0.14208947485991608, 0.14208947485991608, 0.1279580202539672, 0.1279580202539672, 0.1279580202539672, 0.11414263898084187, 0.11414263898084187, 0.11414263898084187, 0.11273826173646417, 0.11273826173646417, 0.11273826173646417, 0.10862647649526702, 0.10862647649526702, 0.10862647649526702, 0.08953975741398568, 0.08953975741398568, 0.08953975741398568, 0.9227745967400753, 0.9227745967400753, 0.9227745967400753, 0.92072867103645, 0.92072867103645, 0.92072867103645, 0.9089480646265572, 0.9089480646265572, 0.9089480646265572, 0.2605566553327463, 0.2605566553327463, 0.2605566553327463, 0.3981773075912264, 0.3981773075912264, 0.3981773075912264, 0.36290980479980217, 0.36290980479980217, 0.36290980479980217, 0.21791154839075488, 0.21791154839075488, 0.21791154839075488, 0.21338739824051522, 0.21338739824051522, 0.21338739824051522, 0.32138993719584286, 0.32138993719584286, 0.32138993719584286, 0.1614748073076283, 0.1614748073076283, 0.1614748073076283, 0.12508754839936465, 0.12508754839936465, 0.12508754839936465, 0.12593329028067723, 0.12593329028067723, 0.12593329028067723, 0.20957772320840584, 0.20957772320840584, 0.20957772320840584, 0.16806569641723723, 0.16806569641723723, 0.16806569641723723, 0.13035690333124894, 0.13035690333124894, 0.13035690333124894, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028300827650528104, 0.028300827650528104, 0.028300827650528104, 0.010379949596555527, 0.010379949596555527, 0.010379949596555527, 0.08231718361976692, 0.08231718361976692, 0.08231718361976692, 0.04240223054661785, 0.04240223054661785, 0.04240223054661785, 0.09260915616866261, 0.09260915616866261, 0.09260915616866261, 0.04797150304063458, 0.04797150304063458, 0.04797150304063458, 0.14418982473795927, 0.14418982473795927, 0.14418982473795927, 0.1911382957744988, 0.1911382957744988, 0.1911382957744988, 0.09381884791547601, 0.09381884791547601, 0.09381884791547601, 0.15264445055279974, 0.15264445055279974, 0.15264445055279974, 0.15495011520713053, 0.15495011520713053, 0.15495011520713053, 0.5062624120128141, 0.5062624120128141, 0.5062624120128141, 0.49279204174037716, 0.49279204174037716, 0.49279204174037716, 0.5954763038137866, 0.5954763038137866, 0.5954763038137866, 0.15499091083848193, 0.15499091083848193, 0.15499091083848193, 0.15646624715448143, 0.15646624715448143, 0.15646624715448143, 0.10242540447588544, 0.10242540447588544, 0.10242540447588544, 0.34242486458824806, 0.34242486458824806, 0.34242486458824806, 0.21806141094706866, 0.21806141094706866, 0.21806141094706866, 0.1577719334822687, 0.1577719334822687, 0.1577719334822687, 0.36510135841917235, 0.36510135841917235, 0.36510135841917235, 0.26798389124551436, 0.26798389124551436, 0.26798389124551436, 0.3445321149733498, 0.3445321149733498, 0.3445321149733498, 0.1578561338037172, 0.1578561338037172, 0.1578561338037172, 0.3408927646916343, 0.3408927646916343, 0.3408927646916343, 0.17060152517834393, 0.17060152517834393, 0.17060152517834393, 0.19882215505521883, 0.19882215505521883, 0.19882215505521883, 0.2125886580747559, 0.2125886580747559, 0.2125886580747559, 0.22181988199585456, 0.22181988199585456, 0.22181988199585456, 0.2500958443663016, 0.2500958443663016, 0.2500958443663016, 0.2072405308450309, 0.2072405308450309, 0.2072405308450309, 0.5195704940647066, 0.5195704940647066, 0.5195704940647066, 0.8925158274982317, 0.8925158274982317, 0.8925158274982317, 0.1564776842714236, 0.1564776842714236, 0.1564776842714236, 0.7260229642872098, 0.7260229642872098, 0.7260229642872098, 0.3467788561811619, 0.3467788561811619, 0.3467788561811619, 0.3664867615619969, 0.3664867615619969, 0.3664867615619969, 0.22746482598447992, 0.22746482598447992, 0.22746482598447992, 0.18437128346338616, 0.18437128346338616, 0.18437128346338616, 0.1781287891319493, 0.1781287891319493, 0.1781287891319493, 0.2229065663888371, 0.2229065663888371, 0.2229065663888371, 0.08885455506133, 0.08885455506133, 0.08885455506133, 0.09564534902076316, 0.09564534902076316, 0.09564534902076316, 0.07982674147477176, 0.07982674147477176, 0.07982674147477176]}, "mutation_prompt": null}
