{"id": "146f490c-8705-4fee-a542-f3468c029c08", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.dim * 5):\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.local_search(func)\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "HybridOptimizer", "description": "A hybrid metaheuristic using differential evolution for exploration and local search for exploitation to efficiently handle diverse optimization landscapes.", "configspace": "", "generation": 0, "fitness": 0.22595440269011424, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.47127635259216516, 0.46661654866164215, 0.4858353140474705, 0.5412922716402211, 0.5111379643117072, 0.5003444224454349, 0.4965671825861897, 0.4953234230025064, 0.5015135855748294, 0.19668898961217263, 0.2319784661297225, 0.22235372801683384, 0.22918642217598062, 0.21750553480733315, 0.22601724943113566, 0.21772859247709941, 0.22384930964514593, 0.24462069203011483, 0.11267165043803473, 0.09625406883694942, 0.08699747670709057, 0.11531241171285567, 0.09652180159551971, 0.12362456586518544, 0.10040072542513823, 0.10932143808172001, 0.11598601232751737, 0.12349524383577004, 0.0949526692385565, 0.07965693768234627, 0.11015478573846871, 0.11223725278984309, 0.07959287454871988, 0.0966652179494073, 0.09139134293053974, 0.09400267368654713, 0.9407186808485334, 0.9164822900819475, 0.9130507719758114, 0.9062683006996307, 0.8340134889384755, 0.9423518671862318, 0.9331495205736231, 0.9592135822000705, 0.8927876639744574, 0.24411924579483268, 0.19724241928696307, 0.2346327297686881, 0.212758129688155, 0.2345261034859577, 0.22445011474994314, 0.23377840815742856, 0.236274283295283, 0.2594556353539357, 0.30569334032004203, 0.29039046819723446, 0.7443964916945645, 0.5484380144914811, 0.35817250098406517, 0.5587437685904254, 0.28594643448484347, 0.5047264943858821, 0.3281891864274692, 0.1462016143794812, 0.19002815988533672, 0.17717675244081998, 0.13966676698144131, 0.16043353286871354, 0.14107172966006087, 0.18972276195969873, 0.14766014050013798, 0.14384797977954, 0.23813362351502532, 0.20328114258222196, 0.03784998441659171, 0.13171832476362255, 0.12306177995830969, 0.14162738777479644, 0.11401723286018639, 0.15898264846817622, 0.15396080684535207, 0.0499799531602203, 0.0496408146404832, 0.0585615852588619, 0.06496460538181548, 0.05060951514103196, 0.08480440343718965, 0.07585491023032942, 0.061835506969074805, 0.06124340644277548, 0.17065770208444808, 0.16655377172678487, 0.17542523352602968, 0.19454032993222092, 0.1954064145255623, 0.1516221208841031, 0.19519309510906135, 0.22168719428401462, 0.1864501068418568, 0.003515512495182116, 0.0011644387334759365, 0.0006606865147529284, 0.0078050149458431806, 0.011009819844961966, 0.00528188064124957, 0.013045651008835146, 0.0035455146899741052, 0.005592752532467271, 0.12548492262857036, 0.11317083760459723, 0.09439392671348579, 0.11373841339993818, 0.11921998463436789, 0.10586187770627642, 0.11797763007217987, 0.11064013233900571, 0.10486009486853742, 0.406813445781644, 0.40113448379566197, 0.39681023801010606, 0.41565651232290723, 0.4023613587404252, 0.41893299485075064, 0.409965019591393, 0.4105627783695349, 0.40669064239068, 0.08668851730226201, 0.09582278824893509, 0.08215154791960322, 0.08602342046733191, 0.08220919524223647, 0.08481386429952054, 0.0995317748106459, 0.11426549722034873, 0.11875455800708457, 0.18752572853914995, 0.16154538980315158, 0.16700060745786993, 0.1461427110749839, 0.1427965388794099, 0.20504097331578863, 0.17667530980920232, 0.20606096575637267, 0.22465043578822907, 0.2501994902326462, 0.24447479393923954, 0.25740014642527465, 0.24521646289215215, 0.26482737189659344, 0.2520873851946782, 0.27559398650355815, 0.26619695837103186, 0.2574022107313906, 0.20814131957410975, 0.17513457648729147, 0.16485526157273056, 0.19195603178222265, 0.16215151863101618, 0.20821205069722037, 0.18789323712258588, 0.21012447743147467, 0.1881036553801937, 0.18186952935916756, 0.18288247628359888, 0.20883385226924023, 0.1934796357254669, 0.17525506745802633, 0.19245938094058423, 0.21527967646220536, 0.18954215049696, 0.1890344826537076, 0.21169414054972635, 0.17792186577993485, 0.17807655408851464, 0.21942630386310036, 0.17455026465938994, 0.1960171976547883, 0.1878223780744187, 0.20069931148832731, 0.1761150020350899, 0.47991311521032065, 0.16895806939562696, 0.16782224349430452, 0.18076748448773328, 0.19547446608852592, 0.17258908954749663, 0.17311217376131405, 0.2776829537293707, 0.18263179691999387, 0.4215128505654864, 0.19994480922214075, 0.4005500475620737, 0.22722119302254584, 0.18185408528689107, 0.1892483971296166, 0.22717730824846782, 0.19896149569933563, 0.20901177262493675, 0.1787174331986544, 0.1791576306443372, 0.1932744356431615, 0.18884911628040002, 0.19255676524848053, 0.21203375941408287, 0.18486316403157455, 0.1991068444404016, 0.18325247123503408, 0.09660499794558419, 0.07830332332966738, 0.06706553232036172, 0.07383317677627488, 0.06777481056057078, 0.06652364143148692, 0.07146352356194274, 0.0804613963507389, 0.07083083934989243]}, "mutation_prompt": null}
{"id": "8cb1bb16-2976-4ca2-9056-11da9ad9979b", "solution": "import numpy as np\n\nclass ProbabilisticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.tunneling_probability = 0.1\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n            elif np.random.rand() < self.tunneling_probability:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.dim * 5):\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.local_search(func)\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "ProbabilisticHybridOptimizer", "description": "A probabilistic hybrid metaheuristic incorporating stochastic tunneling with differential evolution to enhance exploration and escape local optima.", "configspace": "", "generation": 1, "fitness": 0.1848227916086135, "feedback": "The algorithm ProbabilisticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "146f490c-8705-4fee-a542-f3468c029c08", "metadata": {"aucs": [0.38844540014373286, 0.3303219031159307, 0.34954692841879653, 0.400321116411239, 0.4229370806586008, 0.4241472908854448, 0.39456561200368145, 0.4033760396587376, 0.40571548607920527, 0.1367637378559421, 0.08691656771614686, 0.12410653706788288, 0.11830252890721948, 0.11819229834409162, 0.11274307045181109, 0.11859214966125475, 0.1020581099456298, 0.12249306041886432, 0.11936392953657282, 0.10119032201050415, 0.12954243830093382, 0.08487653261713635, 0.10647796178797886, 0.08720315782743093, 0.10265058558062878, 0.09736427885102727, 0.1090040822306555, 0.07896631018017197, 0.08043955087483012, 0.07426544776060895, 0.11654935846660741, 0.0812013844688163, 0.08247846858499275, 0.08787169986690913, 0.08508489349758674, 0.09819377685810016, 0.9477675407595257, 0.9570426793786312, 0.9187662603997845, 0.9311533379155675, 0.9222486893406752, 0.9173924364663728, 0.936190915695901, 0.968962162707519, 0.9617923163451783, 0.15157638735889922, 0.13802548798768133, 0.12815204779608758, 0.14497370236094353, 0.13314475482915988, 0.15288426064713134, 0.1555937450229392, 0.18468686398605694, 0.18563164153336797, 0.20898885113102073, 0.2117794713963247, 0.17216157827146417, 0.267079312744926, 0.20686280063526508, 0.24251042431806813, 0.2222042202139498, 0.20224483009933047, 0.2308745367341909, 0.11227964387303091, 0.10186930951436501, 0.09639258249811755, 0.1170120878386981, 0.11426160551370701, 0.13016309529207082, 0.12996875268580355, 0.1231221292131035, 0.14759981967960434, 0.08851330338373686, 0.11903062481121796, 0.1128204066205748, 0.09923794271309094, 0.11789865321315973, 0.11898509140166857, 0.09046303429167002, 0.04666999479820677, 0.09331477510622876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016258240155606618, 0.0012033158511453035, 0.000240294566222099, 9.999999999998899e-05, 9.999999999998899e-05, 0.09256907198452624, 0.07435442913116763, 0.05103443934785301, 0.061587345915291025, 0.07294849983170737, 0.08736163736302338, 0.08294841998947411, 0.08654451461221047, 0.07239510749416256, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0692013731713027, 0.0696556862724177, 0.05710954194450879, 0.09373411054216996, 0.09634748907676971, 0.07216103561945364, 0.07778430170512896, 0.07420635696000422, 0.07547646539720076, 0.36890377210247793, 0.36034682297245935, 0.3382525899210119, 0.3374797814897904, 0.36328917336007605, 0.33511987289076606, 0.3419894353320033, 0.33936012218075284, 0.32429688009625823, 0.10859113060734094, 0.09281520317814451, 0.10150471141074047, 0.09157075853198948, 0.08679653363960349, 0.11592902340452094, 0.10617661560543257, 0.08901837902688947, 0.10047725168637844, 0.1863035829250287, 0.15440485698717277, 0.1881254389283803, 0.1665040427513228, 0.19376274279899153, 0.18197602786978329, 0.17602126592332445, 0.20762332754187296, 0.19739612505032567, 0.2170252583298612, 0.23107004123714026, 0.21555878636508408, 0.1924385626005416, 0.2094705471901449, 0.1866857817454044, 0.22119855854266945, 0.21994301371680325, 0.23326179845456974, 0.16061487270225516, 0.1724035043895561, 0.16452493758504005, 0.18136662677750903, 0.1670256066357877, 0.15902940599688864, 0.16478522080987046, 0.16980178735349638, 0.1490796154233287, 0.17992289382202564, 0.20397940892411492, 0.18545590479286267, 0.19946508245608374, 0.18901831142114311, 0.201076493204985, 0.20988366378557488, 0.20526591220573487, 0.18306453792861288, 0.19208969151094302, 0.17241818172554502, 0.17559461340963078, 0.17734457330321218, 0.19507362082670665, 0.17841730545383871, 0.187738984031659, 0.17613009461923812, 0.18447575749314393, 0.3533010603763923, 0.16045795806726726, 0.18454536051309955, 0.14678712305138308, 0.16841356280451947, 0.18011718493961393, 0.16879669424280852, 0.20360471527135104, 0.18137495924146863, 0.17535168278664515, 0.19255940872538913, 0.1527669505523871, 0.30620068037864245, 0.14334933799364902, 0.32447120524868645, 0.2004825119403385, 0.2071934484651805, 0.19948422298510815, 0.1949969210805239, 0.18277352224910592, 0.17909694806622267, 0.18266439660146594, 0.18539585890300625, 0.18409605104459792, 0.2001185637876044, 0.17887724784529313, 0.21733372118285654, 0.09135363477512493, 0.07408017483184526, 0.0734455221033894, 0.07196062935742031, 0.07210826602830844, 0.08711333862270043, 0.06624661450080571, 0.07463442411470678, 0.0758821934367444]}, "mutation_prompt": null}
{"id": "0aebde3d-6798-4170-800a-09d491a50a4b", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity):\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.9\n            self.crossover_rate = 0.95\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptiveHybridOptimizer", "description": "An adaptive hybrid metaheuristic leveraging differential evolution and variable local search intensity to improve convergence efficiency.", "configspace": "", "generation": 2, "fitness": 0.24940186622751165, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "146f490c-8705-4fee-a542-f3468c029c08", "metadata": {"aucs": [0.5799755149670526, 0.5278989143145397, 0.5579346016902522, 0.6116545864711027, 0.5559390026015574, 0.5621623954020041, 0.6120900761584476, 0.5611048279033135, 0.5690192897566924, 0.31003786177325776, 0.2964262870003188, 0.3200002100102911, 0.30106850027583665, 0.3004000789779335, 0.2878491601345836, 0.31991916859411484, 0.3464694750985392, 0.32240182057447064, 0.11123441942491341, 0.10805582891838006, 0.09037152293181494, 0.10365342926428622, 0.09774364508993327, 0.08786211541541256, 0.10776791586943824, 0.10399966382540349, 0.09670724675840159, 0.0843299837080842, 0.08609221314088644, 0.1004224939183681, 0.10180842050721217, 0.10189437157952175, 0.10169909774501573, 0.11498111925917076, 0.09748139719227789, 0.0982627395758735, 0.9268312451476628, 0.9714879274319053, 0.9526094463531548, 0.9243224451523603, 0.9455230347004748, 0.9587988122509499, 0.9291573996572101, 0.9272686023250467, 0.938566465597984, 0.2544518785462805, 0.24762512778316637, 0.24980308766578918, 0.26069822643678464, 0.2464641581355813, 0.291538364550858, 0.3208555345780073, 0.24416051204802214, 0.2834057222964348, 0.4194189933745953, 0.4586530479154013, 0.450172459019585, 0.4746959868906758, 0.5912340534015268, 0.5136855016334577, 0.32123258078795536, 0.4765130718609393, 0.4692991097122744, 0.16534256315008566, 0.18244579400688987, 0.2068720012665659, 0.19029957638592632, 0.1960696971987742, 0.19725987174627635, 0.1804925692102981, 0.1796204221211365, 0.19906094325461166, 0.02930150446992341, 0.2460742802523458, 0.20811496047861, 0.19617679027337165, 0.1834362181504171, 0.19304723458099637, 0.14164130759794302, 0.1509877122635238, 0.17932158192787173, 0.10595886928317866, 0.09300901770419956, 0.12721548717229603, 0.12398155197574545, 0.132369915502335, 0.10079676159204687, 0.10542532392851067, 0.076977808124566, 0.07300056386083509, 0.24916983214362232, 0.23319914964600252, 0.2178875446211641, 0.2235983987668232, 0.2409459939175166, 0.2125594385092816, 0.24485981057326967, 0.2630843740029627, 0.25960691672660896, 0.01670486132774418, 0.023103473476436598, 0.02113123650338089, 0.014995889819812369, 0.007758534036054532, 0.031277009592342586, 0.026758802986666108, 0.02982726927488455, 0.021508342764689603, 0.15151112380103315, 0.13100530209419814, 0.1375740303054951, 0.14001556123279568, 0.15643481899723788, 0.14287403226627104, 0.1629108136300902, 0.15289418770618501, 0.15117040889784983, 0.43081727645794154, 0.43973599234594063, 0.4491822467510347, 0.4540096112212717, 0.4735889672908047, 0.44958973936696633, 0.4477806170306715, 0.45838241039530325, 0.46802058345502984, 0.0950053030097493, 0.08583898936389012, 0.0997611043973804, 0.09284467652699169, 0.10130564102959394, 0.08878644734197716, 0.13447478337269259, 0.09763312163766313, 0.09881011128271078, 0.16942576231355255, 0.1678696469740989, 0.15255924560077094, 0.1493531269250954, 0.14460867340045802, 0.17027771070108522, 0.1536722258010924, 0.17602212684674745, 0.14656560888080417, 0.25857367612466997, 0.26168809542505267, 0.26809897498018176, 0.24202749994872697, 0.25582659602086477, 0.2529124665263449, 0.2868485403386004, 0.26547081371779324, 0.2718057282008308, 0.21122036523397614, 0.2142910065785627, 0.19874679423173924, 0.22798646928406552, 0.19675435992014245, 0.21030621644135783, 0.21046039240407421, 0.20210511035400536, 0.21521202139493212, 0.18281166767833001, 0.19430567262536047, 0.17244295871906978, 0.1894416501179801, 0.18699282073036527, 0.22141578698278574, 0.18898339214396764, 0.17572828745318425, 0.18783524338254676, 0.18536474702154104, 0.18632963903688227, 0.18908273283105137, 0.18313688577662635, 0.18431553542475299, 0.17798830702564505, 0.191540153239806, 0.18359366226671503, 0.17697305964153331, 0.5364440485751565, 0.16705645470435027, 0.5752073261795076, 0.17793587259646915, 0.29311130619963155, 0.5273054459549111, 0.152781148138191, 0.1906713404808975, 0.17598071341944288, 0.1692679878422979, 0.1988235825827106, 0.5284382017908309, 0.1910928573110784, 0.20082566456628048, 0.2294703132125807, 0.20561290456476422, 0.20641443104332968, 0.2087970601629402, 0.20101651375088414, 0.17314511437892943, 0.1831142350422933, 0.18547427226297275, 0.16976394810306594, 0.18259076786084183, 0.1806946673091081, 0.18290009018553388, 0.2108821614977623, 0.07023561369475229, 0.06369790855750546, 0.07251016217168071, 0.07122693021832438, 0.07051365806109022, 0.06402629874393684, 0.06721542586733431, 0.07949460546243281, 0.08866531752082252]}, "mutation_prompt": null}
{"id": "2d941707-6070-48a7-86fa-e32cbf1e4340", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity):\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.9\n            self.crossover_rate = 0.95\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptiveHybridOptimizer", "description": "An adaptive hybrid metaheuristic leveraging differential evolution and variable local search intensity to improve convergence efficiency.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0aebde3d-6798-4170-800a-09d491a50a4b", "metadata": {"aucs": [0.5799755149670526, 0.5278989143145397, 0.5579346016902522, 0.6116545864711027, 0.5559390026015574, 0.5621623954020041, 0.6120900761584476, 0.5611048279033135, 0.5690192897566924, 0.31003786177325776, 0.2964262870003188, 0.3200002100102911, 0.30106850027583665, 0.3004000789779335, 0.2878491601345836, 0.31991916859411484, 0.3464694750985392, 0.32240182057447064, 0.11123441942491341, 0.10805582891838006, 0.09037152293181494, 0.10365342926428622, 0.09774364508993327, 0.08786211541541256, 0.10776791586943824, 0.10399966382540349, 0.09670724675840159, 0.0843299837080842, 0.08609221314088644, 0.1004224939183681, 0.10180842050721217, 0.10189437157952175, 0.10169909774501573, 0.11498111925917076, 0.09748139719227789, 0.0982627395758735, 0.9268312451476628, 0.9714879274319053, 0.9526094463531548, 0.9243224451523603, 0.9455230347004748, 0.9587988122509499, 0.9291573996572101, 0.9272686023250467, 0.938566465597984, 0.2544518785462805, 0.24762512778316637, 0.24980308766578918, 0.26069822643678464, 0.2464641581355813, 0.291538364550858, 0.3208555345780073, 0.24416051204802214, 0.2834057222964348, 0.4194189933745953, 0.4586530479154013, 0.450172459019585, 0.4746959868906758, 0.5912340534015268, 0.5136855016334577, 0.32123258078795536, 0.4765130718609393, 0.4692991097122744, 0.16534256315008566, 0.18244579400688987, 0.2068720012665659, 0.19029957638592632, 0.1960696971987742, 0.19725987174627635, 0.1804925692102981, 0.1796204221211365, 0.19906094325461166, 0.02930150446992341, 0.2460742802523458, 0.20811496047861, 0.19617679027337165, 0.1834362181504171, 0.19304723458099637, 0.14164130759794302, 0.1509877122635238, 0.17932158192787173, 0.10595886928317866, 0.09300901770419956, 0.12721548717229603, 0.12398155197574545, 0.132369915502335, 0.10079676159204687, 0.10542532392851067, 0.076977808124566, 0.07300056386083509, 0.24916983214362232, 0.23319914964600252, 0.2178875446211641, 0.2235983987668232, 0.2409459939175166, 0.2125594385092816, 0.24485981057326967, 0.2630843740029627, 0.25960691672660896, 0.01670486132774418, 0.023103473476436598, 0.02113123650338089, 0.014995889819812369, 0.007758534036054532, 0.031277009592342586, 0.026758802986666108, 0.02982726927488455, 0.021508342764689603, 0.15151112380103315, 0.13100530209419814, 0.1375740303054951, 0.14001556123279568, 0.15643481899723788, 0.14287403226627104, 0.1629108136300902, 0.15289418770618501, 0.15117040889784983, 0.43081727645794154, 0.43973599234594063, 0.4491822467510347, 0.4540096112212717, 0.4735889672908047, 0.44958973936696633, 0.4477806170306715, 0.45838241039530325, 0.46802058345502984, 0.0950053030097493, 0.08583898936389012, 0.0997611043973804, 0.09284467652699169, 0.10130564102959394, 0.08878644734197716, 0.13447478337269259, 0.09763312163766313, 0.09881011128271078, 0.16942576231355255, 0.1678696469740989, 0.15255924560077094, 0.1493531269250954, 0.14460867340045802, 0.17027771070108522, 0.1536722258010924, 0.17602212684674745, 0.14656560888080417, 0.25857367612466997, 0.26168809542505267, 0.26809897498018176, 0.24202749994872697, 0.25582659602086477, 0.2529124665263449, 0.2868485403386004, 0.26547081371779324, 0.2718057282008308, 0.21122036523397614, 0.2142910065785627, 0.19874679423173924, 0.22798646928406552, 0.19675435992014245, 0.21030621644135783, 0.21046039240407421, 0.20210511035400536, 0.21521202139493212, 0.18281166767833001, 0.19430567262536047, 0.17244295871906978, 0.1894416501179801, 0.18699282073036527, 0.22141578698278574, 0.18898339214396764, 0.17572828745318425, 0.18783524338254676, 0.18536474702154104, 0.18632963903688227, 0.18908273283105137, 0.18313688577662635, 0.18431553542475299, 0.17798830702564505, 0.191540153239806, 0.18359366226671503, 0.17697305964153331, 0.5364440485751565, 0.16705645470435027, 0.5752073261795076, 0.17793587259646915, 0.29311130619963155, 0.5273054459549111, 0.152781148138191, 0.1906713404808975, 0.17598071341944288, 0.1692679878422979, 0.1988235825827106, 0.5284382017908309, 0.1910928573110784, 0.20082566456628048, 0.2294703132125807, 0.20561290456476422, 0.20641443104332968, 0.2087970601629402, 0.20101651375088414, 0.17314511437892943, 0.1831142350422933, 0.18547427226297275, 0.16976394810306594, 0.18259076786084183, 0.1806946673091081, 0.18290009018553388, 0.2108821614977623, 0.07023561369475229, 0.06369790855750546, 0.07251016217168071, 0.07122693021832438, 0.07051365806109022, 0.06402629874393684, 0.06721542586733431, 0.07949460546243281, 0.08866531752082252]}, "mutation_prompt": null}
{"id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7  # Changed mutation factor\n        self.crossover_rate = 0.85  # Changed crossover rate\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):  # Randomize search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85  # Adaptive mutation factor\n            self.crossover_rate = 0.9  # Adaptive crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer utilizing stochastic local search intensification and crossover adaptation for robust convergence.", "configspace": "", "generation": 4, "fitness": 0.27397654938832466, "feedback": "The algorithm MutationAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "0aebde3d-6798-4170-800a-09d491a50a4b", "metadata": {"aucs": [0.6384985807086965, 0.6339732821819166, 0.6371531490293669, 0.6927058357064666, 0.6770330159266937, 0.680832036516016, 0.6533716164942065, 0.6666360012848684, 0.6340578797007526, 0.359180864369291, 0.37066304666490546, 0.3733453550154331, 0.4225684366929948, 0.39541666912672957, 0.385794183336828, 0.42774345471198605, 0.38810977278923964, 0.40913127263577365, 0.12817502273083847, 0.12036598365694207, 0.11069603586390786, 0.10491651155207016, 0.14185020732166542, 0.11775704113422414, 0.1060914170979258, 0.12597606962918162, 0.11690270118283697, 0.10994141569793103, 0.10714051932994173, 0.09659174442506524, 0.11485380241321819, 0.11129872386202078, 0.09224830600315526, 0.10829274963470448, 0.11103392467415307, 0.10912248760940824, 0.9318224298119114, 0.9275192757236804, 0.9401610640040723, 0.9408963859547194, 0.931847119652183, 0.9517585163371646, 0.944898108709874, 0.9535771632385173, 0.9281927308166372, 0.28430662176206356, 0.26754510594062153, 0.27098587981713096, 0.276004667102716, 0.28488794187752964, 0.272221496963144, 0.3065794775918316, 0.29907912125414626, 0.28584271115508164, 0.4184081497342218, 0.40358485189438553, 0.6592024849166078, 0.5532156638065322, 0.5095361350579866, 0.6675188324466887, 0.5355939939832268, 0.5944557975413576, 0.6359804938973379, 0.22954232372872352, 0.23697342759725692, 0.17839689367762435, 0.20745379293917632, 0.20876856987902104, 0.2039184057671839, 0.1979046409009474, 0.20073360912376503, 0.19283601216357837, 0.1868660524064809, 0.28970599062095936, 0.18925647186281014, 0.15783451243777313, 0.23494193077349435, 0.19088526265533912, 0.20895242918237855, 0.1968350896172475, 0.19683535050853307, 0.10689630630096913, 0.08223035070336393, 0.09392580171028653, 0.1313497305354716, 0.10158321743353771, 0.05873950850980414, 0.08675277118817726, 0.11130928428813636, 0.08570625741069893, 0.2163118189281389, 0.26920656428347933, 0.2512894835438615, 0.20175526836905033, 0.22714341640779667, 0.22337082402542485, 0.2141292220436335, 0.2760242474195691, 0.2563549153056298, 0.0159759469503733, 0.025662408344924725, 0.01753533829457976, 0.04081286918964866, 0.03923295781975045, 0.025241874767651606, 0.040127492275430665, 0.029785310426343692, 0.032374797501504515, 0.14041054513169837, 0.14779581135391306, 0.15599042478709002, 0.14620086299000234, 0.1513143308973336, 0.15848598894269106, 0.1486101846185447, 0.16794285303745982, 0.15405032900983207, 0.49776602892330435, 0.4835292709758261, 0.4665127364818865, 0.49954438182684857, 0.4930267336041465, 0.48635523965050176, 0.5069050314428112, 0.4950274310271472, 0.4810277469425418, 0.10625118658196331, 0.126210944547397, 0.11591145019370575, 0.11817290809418535, 0.11599832911872776, 0.10366926317904412, 0.0824043787183113, 0.1138237254436435, 0.10309740732371153, 0.1536559029239366, 0.15431417994543262, 0.22399635612568247, 0.13929972833118887, 0.1990679908902332, 0.16165215532697563, 0.18668253269176138, 0.19453892780391058, 0.15311237722569893, 0.2822306565328476, 0.2772413150772822, 0.31071299165537825, 0.29161164918555516, 0.27668130648666445, 0.27908104483316853, 0.3018823548628108, 0.2967955122089254, 0.3118344453609948, 0.2256398885862253, 0.22078677729697083, 0.2221518696078698, 0.19887156467967937, 0.23002504299755522, 0.21442289204935527, 0.230036210314425, 0.23922146123659926, 0.22417180886822707, 0.20316106429569092, 0.19482100653522316, 0.17895046604826292, 0.19232413826636308, 0.21168136057176468, 0.19177267585075175, 0.1910699505235791, 0.21582314162844896, 0.17958097531785955, 0.18429267633261903, 0.18584993912106518, 0.1825350357484845, 0.18400611746524853, 0.1803207403309165, 0.19068906061597213, 0.21121053780413945, 0.2109397515912741, 0.20342744201878127, 0.17362948653966037, 0.17257686899398572, 0.480574784867404, 0.5275061594900667, 0.3154958305797153, 0.5390126544584274, 0.22329439934542272, 0.562255034788962, 0.41743166587161307, 0.2775167874421328, 0.20032788136841206, 0.42205305963440987, 0.29543195741568684, 0.1888284797156593, 0.49600328888273526, 0.20642324999649775, 0.15096307676042398, 0.20330660461441807, 0.1825375981848214, 0.18197028146773775, 0.1875020263587751, 0.18453335483105437, 0.18310533893198833, 0.19141357579656204, 0.22686943915672286, 0.20640996933297417, 0.18611194178091472, 0.08636300678950937, 0.07879415210385599, 0.08085692544481027, 0.08521897053505778, 0.07901236156076907, 0.08164132248142264, 0.07506127951804609, 0.07184422297608084, 0.07428699432306962]}, "mutation_prompt": null}
{"id": "533b475f-fe43-481e-90cf-99af80f87ecb", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8  # Slightly increased mutation factor\n        self.crossover_rate = 0.8  # Slightly reduced crossover rate\n        self.local_search_intensity = 5\n        self.elitism_rate = 0.05  # Introduced elitism rate\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        elitism_cutoff = int(self.population_size * self.elitism_rate)\n        elite_indices = np.argsort(self.fitness)[:elitism_cutoff]\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget or i in elite_indices:\n                continue\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.08  # Reduced step size for finer local search\n        for _ in range(self.local_search_intensity):\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 15  # Increased local search intensity\n            self.mutation_factor = 0.9  # Further adaptive mutation factor increment\n            self.crossover_rate = 0.75  # Slightly reduced crossover rate for diversity\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer with adaptive learning rates and controlled elitism for enhancing convergence reliability.", "configspace": "", "generation": 5, "fitness": 0.24068370135736902, "feedback": "The algorithm MutationAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.5858342869661226, 0.6118475520624691, 0.6293928074707322, 0.6285247562856457, 0.6234463277128878, 0.6181244137476029, 0.6386504035629014, 0.6294254487007541, 0.6230108873198192, 0.31935866200153284, 0.3394445746377933, 0.3384386008724839, 0.3008211100385132, 0.337024399501068, 0.3391806149841403, 0.34416829105151525, 0.3507877516404725, 0.3564617951597795, 0.12068021731033896, 0.1192778161533743, 0.1261310476393912, 0.1263174605681061, 0.1171246848409675, 0.12937712679896252, 0.11745200290267876, 0.12138553868011748, 0.12866227088337834, 0.10723879077495313, 0.11649166147106749, 0.12111242717554083, 0.11427135846890557, 0.11890712003472659, 0.11187473924978042, 0.12535664277373393, 0.10654939050272405, 0.09914411265512313, 0.9654086424704031, 0.9621098324995447, 0.9661783162078148, 0.931937110535594, 0.9665376898188828, 0.9332279800504136, 0.9673005832455813, 0.9545596096157691, 0.9678030096339162, 0.25389905679641545, 0.2576626433362278, 0.23345135557195873, 0.25656805168459607, 0.24805631963229058, 0.2789304361531537, 0.2542078659323298, 0.24736741236426518, 0.23323540477177396, 0.28447827123040714, 0.27268487372559813, 0.28431155488012616, 0.35573183506074346, 0.40730977148436465, 0.502468277304237, 0.39646423598858105, 0.3874631540641781, 0.5148752434374997, 0.18006585877272152, 0.16095052877048277, 0.14798822718817262, 0.16092008300762906, 0.130876133363517, 0.15510269063830362, 0.16469698377705277, 0.1578380038746231, 0.15534139002718816, 0.13787187229158826, 0.17191901024226497, 0.13942933800688428, 0.17034609403535472, 0.14066377777648853, 0.1412987686015118, 0.14685561410424086, 0.1148244057572414, 0.14694642473318364, 0.011165334767755164, 0.04070475476637203, 0.04445031035295377, 0.05380795606586142, 0.009861690738497741, 0.021811296170901162, 0.011128753869631192, 0.03184196725268862, 0.05561177730918698, 0.1557916117822844, 0.10311825861657875, 0.14252581090564476, 0.13480745372039404, 0.1272825548533525, 0.11248033227530341, 0.16744188820150852, 0.1683428471701225, 0.16683245596088747, 0.002113030937805682, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00018127397169043213, 0.12606228287720223, 0.1054448859954209, 0.09920417379477853, 0.11865860689905916, 0.11765381894787674, 0.11656237530204161, 0.10535970524740912, 0.12339417354107085, 0.10315105651351764, 0.4210720231835656, 0.4276745607416311, 0.40692498474116334, 0.4427238412072405, 0.42995604631952744, 0.44078740695755936, 0.424604154030928, 0.4211659526212146, 0.4564040879358455, 0.12455361989079683, 0.10267433636523216, 0.11397800156818816, 0.10704552488321384, 0.10553720596904459, 0.08305512314230878, 0.10309535715482421, 0.1011234396287467, 0.10521793986901973, 0.1463621752262716, 0.19817795544963968, 0.18643511933214685, 0.16263516062074956, 0.14391222628649014, 0.16287963361118474, 0.17137136037952372, 0.1492883570391752, 0.17571473529565407, 0.25066916162051944, 0.2834939807171184, 0.25366766105804806, 0.2552573109003492, 0.27320544781340317, 0.25062764743202526, 0.2954618638424331, 0.27456583009533997, 0.2795616193807764, 0.18679677984940868, 0.20084632897578336, 0.17628483076116952, 0.1782814478728636, 0.1766896491089499, 0.20112298565265385, 0.20154259791138052, 0.23580408925344065, 0.19906093163912952, 0.18391450983346036, 0.18560131896238508, 0.18968720358226843, 0.21449164612443528, 0.17597201945164964, 0.18898481833630332, 0.17904454066583386, 0.20610149518190424, 0.22349956865394982, 0.19235058378058179, 0.20290750127194002, 0.1863540855138891, 0.19499806886694315, 0.18688924825108455, 0.18404424390110763, 0.19763180893512222, 0.19078467757302597, 0.18353402059450896, 0.47503535546340203, 0.49267395486583987, 0.4456789011761927, 0.27060838793286024, 0.1787691842602741, 0.36994096807785204, 0.4950347503260273, 0.20161054851564864, 0.3077129032431435, 0.3356655328312059, 0.20090691188207987, 0.3703391015448737, 0.16172629927801185, 0.22195606002558244, 0.20621830758266058, 0.20394508205024553, 0.20390218392842274, 0.20079120294890485, 0.19485526832421862, 0.19262095754350061, 0.20127631181866168, 0.1875435431686424, 0.17601748526291117, 0.18357728267981033, 0.18393638260442124, 0.18443191038781737, 0.180410362915848, 0.07519141059667944, 0.08506719216066816, 0.0708380288647994, 0.07715277250277774, 0.06960658463921432, 0.07558102062841321, 0.0776504887119005, 0.07009209717586296, 0.0782596305832427]}, "mutation_prompt": null}
{"id": "23fa3d78-9ed1-4e35-ab2a-e678d618cb65", "solution": "import numpy as np\n\nclass ProbabilisticAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.9\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover_mask, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.05\n        for _ in range(self.local_search_intensity + np.random.randint(0, 2)):\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 12\n            self.mutation_factor = 0.75\n            self.crossover_rate = 0.95\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "ProbabilisticAdaptiveOptimizer", "description": "An adaptive hybrid optimizer leveraging probabilistic learning and adaptive crossover rates for effective exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.2727866557371301, "feedback": "The algorithm ProbabilisticAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6241269899379143, 0.5778818914282777, 0.6102713157454119, 0.6258145162084549, 0.6363769661552422, 0.6339817777353384, 0.6157037444457556, 0.6109168706143598, 0.6342265122622726, 0.3565322084190292, 0.3540269872644286, 0.3557322548458318, 0.3324432254574926, 0.2889420816698943, 0.33071441681382685, 0.34286403084472783, 0.3433330651708, 0.3254334625258777, 0.11567961802395188, 0.10453542863623733, 0.10071889121139233, 0.11074887518057674, 0.1170611500418367, 0.12331416723318833, 0.11819080648055458, 0.12157774436176283, 0.12561291173335742, 0.08824440028725766, 0.09759688195171712, 0.11076413639897387, 0.09832703764343409, 0.1016954192535211, 0.09767888959477655, 0.08799330518453752, 0.09805027107738529, 0.10702734939947511, 0.9177197129677808, 0.8639416592088963, 0.9285277159743639, 0.910558826085929, 0.880269305841231, 0.8885455392444485, 0.9207365196306276, 0.8869510755057588, 0.9368560860669997, 0.2776152713854202, 0.25948584090752236, 0.2526421252210609, 0.27074545225794955, 0.25832037095525817, 0.28979345916734967, 0.2896483186841934, 0.30135219949714975, 0.3114436334768338, 0.49999702905373256, 0.58042181804027, 0.5620776007011663, 0.5453033727548027, 0.6402064426090247, 0.5705327222189155, 0.5369705743260187, 0.5570723862300883, 0.6778936635161046, 0.175478725711247, 0.18423491470507047, 0.17669944354567924, 0.20547762498176714, 0.18278040819913632, 0.18048772594717233, 0.20517950407679864, 0.22369310909399032, 0.1944206128210353, 0.21802049550684544, 0.24362585606397702, 0.19076187795224508, 0.14246292974001062, 0.18876486378384127, 0.2034074504290706, 0.1621864261557272, 0.20609572561199563, 0.1833391748456027, 0.14017940370440096, 0.1304873039213017, 0.13305880269306325, 0.15706578943184035, 0.12182296624252686, 0.13914561111798152, 0.1328145852426873, 0.14772163626988166, 0.11512490022056021, 0.29015702049612346, 0.2610603031990808, 0.27708682287266206, 0.24634758464660822, 0.24755182391158592, 0.22233341540313045, 0.24611049520573747, 0.26961209051213064, 0.2808370194782659, 0.019728188913935796, 0.015433992864647417, 0.02911416777701581, 0.05754007418884699, 0.057102090920550075, 0.037945312588800184, 0.027636269510799116, 0.03472679277084045, 0.04498433178873473, 0.14859007401075397, 0.16118213968619144, 0.14896621161263413, 0.16854769535556346, 0.15956011301863982, 0.1583920505081713, 0.17709715484497124, 0.17354057663079125, 0.1590562510616914, 0.4877010236134961, 0.477093479113331, 0.4932426342205617, 0.4802210574506144, 0.503405191704964, 0.4706795662386968, 0.5000264225338806, 0.492607233415313, 0.49661752186204045, 0.11019012189375843, 0.10335569188573102, 0.10322898380860734, 0.10978260707065202, 0.10513066913679525, 0.10178560232795608, 0.1094710030539976, 0.130037962516655, 0.11386836644847986, 0.17196083873241808, 0.16627051185921193, 0.14865185000578318, 0.1548777544031562, 0.24711591217824502, 0.2369506163409838, 0.1579709581793377, 0.1459201488659888, 0.15064498129215098, 0.28395039675299716, 0.2762774831437471, 0.269266789269231, 0.2676921537821768, 0.2621103993934423, 0.26820500085950283, 0.2882657952722594, 0.29548994400444273, 0.3145660260056746, 0.2348900256282883, 0.22894849448605104, 0.2275080002881612, 0.2209663179063055, 0.21700278414844354, 0.2228981192011099, 0.21925523338170672, 0.22263393526355735, 0.2386521983440093, 0.18360597275957724, 0.1981763304953661, 0.19320708377690188, 0.18811440178993022, 0.18096842982645467, 0.20350212033843362, 0.21237637028263923, 0.20048478843966244, 0.17361570008082583, 0.18880157370802753, 0.18839685551772767, 0.19095027606567938, 0.18125559202120323, 0.1865343939398716, 0.1847140406496397, 0.21511350030500342, 0.17310113880123668, 0.18886289658797628, 0.5361610311810827, 0.41579426981329903, 0.6026196799545562, 0.48595947125536887, 0.24449821462852006, 0.46230854499766705, 0.37129661154116056, 0.1681294535957828, 0.2502152811143745, 0.5211920278689056, 0.5095139298637186, 0.192333472107184, 0.28488257488633717, 0.18933223592540882, 0.1972551433701264, 0.20662469242596004, 0.20513955475000578, 0.5387614442666192, 0.18606038761636523, 0.18644857551202376, 0.17488192316508955, 0.18570288703123627, 0.1899760816569559, 0.18410311590809902, 0.1825374235975541, 0.18755931299390916, 0.19092363091172415, 0.08932962707897296, 0.09615887490693253, 0.07635269867527317, 0.08872728199004343, 0.069877013301049, 0.08499272679432701, 0.09027918003177071, 0.08234352362406094, 0.08993021364645515]}, "mutation_prompt": null}
{"id": "b4445db5-c196-4d4d-9b7d-85313c39a524", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted initial population size\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.15  # Increased step size for exploration\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 3:  # Earlier adaptation of parameters\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85\n            self.crossover_rate = 0.9\n            if self.used_budget > 2 * self.budget // 3:\n                self.population_size = int(self.population_size * 0.75)  # Dynamic reduction of population size\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer with dynamic population size, integrating stochastic local search and adaptive parameters for efficient convergence.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {}, "mutation_prompt": null}
{"id": "5fe4a98a-1cc2-418c-9aee-41b9f609aae9", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7  # Changed mutation factor\n        self.crossover_rate = 0.85  # Changed crossover rate\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):  # Randomize search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85  # Adaptive mutation factor\n            self.crossover_rate = 0.9  # Adaptive crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer utilizing stochastic local search intensification and crossover adaptation for robust convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6384985807086965, 0.6339732821819166, 0.6371531490293669, 0.6927058357064666, 0.6770330159266937, 0.680832036516016, 0.6533716164942065, 0.6666360012848684, 0.6340578797007526, 0.359180864369291, 0.37066304666490546, 0.3733453550154331, 0.4225684366929948, 0.39541666912672957, 0.385794183336828, 0.42774345471198605, 0.38810977278923964, 0.40913127263577365, 0.12817502273083847, 0.12036598365694207, 0.11069603586390786, 0.10491651155207016, 0.14185020732166542, 0.11775704113422414, 0.1060914170979258, 0.12597606962918162, 0.11690270118283697, 0.10994141569793103, 0.10714051932994173, 0.09659174442506524, 0.11485380241321819, 0.11129872386202078, 0.09224830600315526, 0.10829274963470448, 0.11103392467415307, 0.10912248760940824, 0.9318224298119114, 0.9275192757236804, 0.9401610640040723, 0.9408963859547194, 0.931847119652183, 0.9517585163371646, 0.944898108709874, 0.9535771632385173, 0.9281927308166372, 0.28430662176206356, 0.26754510594062153, 0.27098587981713096, 0.276004667102716, 0.28488794187752964, 0.272221496963144, 0.3065794775918316, 0.29907912125414626, 0.28584271115508164, 0.4184081497342218, 0.40358485189438553, 0.6592024849166078, 0.5532156638065322, 0.5095361350579866, 0.6675188324466887, 0.5355939939832268, 0.5944557975413576, 0.6359804938973379, 0.22954232372872352, 0.23697342759725692, 0.17839689367762435, 0.20745379293917632, 0.20876856987902104, 0.2039184057671839, 0.1979046409009474, 0.20073360912376503, 0.19283601216357837, 0.1868660524064809, 0.28970599062095936, 0.18925647186281014, 0.15783451243777313, 0.23494193077349435, 0.19088526265533912, 0.20895242918237855, 0.1968350896172475, 0.19683535050853307, 0.10689630630096913, 0.08223035070336393, 0.09392580171028653, 0.1313497305354716, 0.10158321743353771, 0.05873950850980414, 0.08675277118817726, 0.11130928428813636, 0.08570625741069893, 0.2163118189281389, 0.26920656428347933, 0.2512894835438615, 0.20175526836905033, 0.22714341640779667, 0.22337082402542485, 0.2141292220436335, 0.2760242474195691, 0.2563549153056298, 0.0159759469503733, 0.025662408344924725, 0.01753533829457976, 0.04081286918964866, 0.03923295781975045, 0.025241874767651606, 0.040127492275430665, 0.029785310426343692, 0.032374797501504515, 0.14041054513169837, 0.14779581135391306, 0.15599042478709002, 0.14620086299000234, 0.1513143308973336, 0.15848598894269106, 0.1486101846185447, 0.16794285303745982, 0.15405032900983207, 0.49776602892330435, 0.4835292709758261, 0.4665127364818865, 0.49954438182684857, 0.4930267336041465, 0.48635523965050176, 0.5069050314428112, 0.4950274310271472, 0.4810277469425418, 0.10625118658196331, 0.126210944547397, 0.11591145019370575, 0.11817290809418535, 0.11599832911872776, 0.10366926317904412, 0.0824043787183113, 0.1138237254436435, 0.10309740732371153, 0.1536559029239366, 0.15431417994543262, 0.22399635612568247, 0.13929972833118887, 0.1990679908902332, 0.16165215532697563, 0.18668253269176138, 0.19453892780391058, 0.15311237722569893, 0.2822306565328476, 0.2772413150772822, 0.31071299165537825, 0.29161164918555516, 0.27668130648666445, 0.27908104483316853, 0.3018823548628108, 0.2967955122089254, 0.3118344453609948, 0.2256398885862253, 0.22078677729697083, 0.2221518696078698, 0.19887156467967937, 0.23002504299755522, 0.21442289204935527, 0.230036210314425, 0.23922146123659926, 0.22417180886822707, 0.20316106429569092, 0.19482100653522316, 0.17895046604826292, 0.19232413826636308, 0.21168136057176468, 0.19177267585075175, 0.1910699505235791, 0.21582314162844896, 0.17958097531785955, 0.18429267633261903, 0.18584993912106518, 0.1825350357484845, 0.18400611746524853, 0.1803207403309165, 0.19068906061597213, 0.21121053780413945, 0.2109397515912741, 0.20342744201878127, 0.17362948653966037, 0.17257686899398572, 0.480574784867404, 0.5275061594900667, 0.3154958305797153, 0.5390126544584274, 0.22329439934542272, 0.562255034788962, 0.41743166587161307, 0.2775167874421328, 0.20032788136841206, 0.42205305963440987, 0.29543195741568684, 0.1888284797156593, 0.49600328888273526, 0.20642324999649775, 0.15096307676042398, 0.20330660461441807, 0.1825375981848214, 0.18197028146773775, 0.1875020263587751, 0.18453335483105437, 0.18310533893198833, 0.19141357579656204, 0.22686943915672286, 0.20640996933297417, 0.18611194178091472, 0.08636300678950937, 0.07879415210385599, 0.08085692544481027, 0.08521897053505778, 0.07901236156076907, 0.08164132248142264, 0.07506127951804609, 0.07184422297608084, 0.07428699432306962]}, "mutation_prompt": null}
{"id": "e7b3da3f-b001-4fcf-9d3f-cfbfa92889fc", "solution": "import numpy as np\n\nclass MutationCrossoverDynamicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.local_search_intensity = 6  # Adjusted local search intensity\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.15  # Adjusted step size\n        for _ in range(self.local_search_intensity + np.random.randint(0, 4)):  # Adjusted random intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 3:  # Early adaptation\n            self.local_search_intensity = 12  # More aggressive local search\n            self.mutation_factor = 0.9  # Further adaptive mutation factor\n            self.crossover_rate = 0.95  # Further adaptive crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationCrossoverDynamicOptimizer", "description": "An enhanced mutation-crossover dynamic optimizer leveraging adaptive selection pressure and probabilistic parameter adjustments for efficient exploration.", "configspace": "", "generation": 9, "fitness": 0.2695454357811818, "feedback": "The algorithm MutationCrossoverDynamicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.5804020272080537, 0.5801154783652851, 0.5710457034212426, 0.6268597608122173, 0.6373949716825609, 0.6309371565636572, 0.6094970815938958, 0.5965912293143885, 0.5899739687127198, 0.3291046649501995, 0.35141223927730525, 0.32474497310129025, 0.3405407525830707, 0.3206821347155083, 0.29773437228420263, 0.3006531809442634, 0.32433278107969266, 0.36217167213908774, 0.12810233463343013, 0.1027109436539616, 0.12032483337376976, 0.1129255382894504, 0.11444168692439594, 0.10399731818108793, 0.09077592047827165, 0.1043711427151569, 0.09818389271962713, 0.0936391992543476, 0.0952159800128578, 0.1064542481609797, 0.11606630618764469, 0.10852793003709071, 0.09354405364817175, 0.11184854894105267, 0.10809404711290604, 0.11068627302806178, 0.970382472280545, 0.9607390537261621, 0.9324303636578182, 0.9393981922918118, 0.9587799503762958, 0.9389684321123118, 0.9575380723295618, 0.8984220968556824, 0.9459792589790298, 0.2521776055379268, 0.2469833274930645, 0.28946441405926693, 0.2684551934602867, 0.27631414490815764, 0.26356209192849533, 0.2594504445707978, 0.2742217915093118, 0.27115879518669084, 0.49302773388156373, 0.449920960859293, 0.5219919991183688, 0.5247457753999679, 0.6959271143164338, 0.40831485305084936, 0.5436915094362842, 0.5068710032467745, 0.5709449698713323, 0.19562219910170453, 0.16700893332953615, 0.20116590083222186, 0.196156562310284, 0.17435654987517524, 0.2028668327263361, 0.18423885154578157, 0.21201002313441186, 0.24088446564031984, 0.24377069915629002, 0.20181819376388255, 0.042731082239416684, 0.22786170012078333, 0.21198656006382277, 0.19703316183803732, 0.19670994499238403, 0.1706990287375223, 0.1832266339616767, 0.13537255938819293, 0.1288155432075997, 0.1422504452367057, 0.15417901747202412, 0.17211306479915933, 0.1300411604162447, 0.11145782248763403, 0.13289617606109716, 0.11266199274648048, 0.2384497938884811, 0.2879484298542261, 0.24945481301637817, 0.23061569000345872, 0.2145178187623621, 0.22176580508753674, 0.27867851444449754, 0.2938556669440684, 0.24336066772079912, 0.028910717506569927, 0.015784140901992427, 0.014692590456237165, 0.01742840167758608, 0.04229534660344303, 0.04967357357128199, 0.01962919016863418, 0.04055474023641925, 0.05647897529526125, 0.136361077234326, 0.15595372926084183, 0.14225033213830407, 0.1650548052452515, 0.1619657451908677, 0.1725659079949573, 0.18072634839253332, 0.15322367426882988, 0.15408800073611473, 0.462906447870151, 0.4882864472217119, 0.4830683895047563, 0.49164456338610996, 0.5010509125118301, 0.4867278150516702, 0.48820770147319825, 0.47560249913620867, 0.48168818686761716, 0.10216878308917587, 0.0815602889568039, 0.09288380291673826, 0.1501329562273349, 0.09582116617310932, 0.0978359624799745, 0.12807146153404825, 0.09562844876747056, 0.1050444403370564, 0.197652027965335, 0.18011122988811623, 0.1532132982100578, 0.14846597346413493, 0.18398669028391668, 0.16617984556570153, 0.23930651856739482, 0.1539209878678386, 0.18670598013220896, 0.2769085641285308, 0.25708236548834207, 0.2514822097241962, 0.24833750819705136, 0.2562052546369419, 0.2616713587484629, 0.2817167321333125, 0.2710935041475212, 0.26939159592740447, 0.20587188521508715, 0.19600812094920872, 0.2174357921999852, 0.2171360170813207, 0.2058910930605089, 0.2019974509363014, 0.21629724337397416, 0.22220719826624313, 0.20013827675412232, 0.18372720364021733, 0.18158708653808175, 0.188121574820866, 0.20585704432798735, 0.23591180724905236, 0.19790983872574597, 0.22114149882529, 0.184157881693793, 0.20047232370590673, 0.19099103155763864, 0.1992422714938944, 0.18568193065653482, 0.18779822684550018, 0.17935482238843503, 0.19146878692716063, 0.2054450761829466, 0.23836481789625408, 0.20105745140028397, 0.6560301808135477, 0.6973888133110943, 0.642934395323411, 0.2136112606776135, 0.19225809646095648, 0.42524092801677726, 0.18400334320509826, 0.29279515735125816, 0.47621487835362986, 0.634757151404796, 0.5551128005004017, 0.4274861311760886, 0.18736058203845773, 0.17888440215891022, 0.1920990661478167, 0.20566062374825167, 0.20553649180204314, 0.20086541172597527, 0.19608071576169828, 0.18539262658419298, 0.18106864111577514, 0.17441479797806592, 0.18649802536493865, 0.1871913472333684, 0.19932324522796774, 0.19390269899174395, 0.17557407462112784, 0.07107175503915153, 0.06327738786280768, 0.06953710692063708, 0.07852705290198614, 0.07591195966582232, 0.07656932277758532, 0.08491012846368029, 0.07697659845644234, 0.0741256899274062]}, "mutation_prompt": null}
{"id": "e34eadfe-83ce-46e0-ac75-cf0d68c186d2", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7  # Changed mutation factor\n        self.crossover_rate = 0.85  # Changed crossover rate\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):  # Randomize search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85  # Adaptive mutation factor\n            self.crossover_rate = 0.9  # Adaptive crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer utilizing stochastic local search intensification and crossover adaptation for robust convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6384985807086965, 0.6339732821819166, 0.6371531490293669, 0.6927058357064666, 0.6770330159266937, 0.680832036516016, 0.6533716164942065, 0.6666360012848684, 0.6340578797007526, 0.359180864369291, 0.37066304666490546, 0.3733453550154331, 0.4225684366929948, 0.39541666912672957, 0.385794183336828, 0.42774345471198605, 0.38810977278923964, 0.40913127263577365, 0.12817502273083847, 0.12036598365694207, 0.11069603586390786, 0.10491651155207016, 0.14185020732166542, 0.11775704113422414, 0.1060914170979258, 0.12597606962918162, 0.11690270118283697, 0.10994141569793103, 0.10714051932994173, 0.09659174442506524, 0.11485380241321819, 0.11129872386202078, 0.09224830600315526, 0.10829274963470448, 0.11103392467415307, 0.10912248760940824, 0.9318224298119114, 0.9275192757236804, 0.9401610640040723, 0.9408963859547194, 0.931847119652183, 0.9517585163371646, 0.944898108709874, 0.9535771632385173, 0.9281927308166372, 0.28430662176206356, 0.26754510594062153, 0.27098587981713096, 0.276004667102716, 0.28488794187752964, 0.272221496963144, 0.3065794775918316, 0.29907912125414626, 0.28584271115508164, 0.4184081497342218, 0.40358485189438553, 0.6592024849166078, 0.5532156638065322, 0.5095361350579866, 0.6675188324466887, 0.5355939939832268, 0.5944557975413576, 0.6359804938973379, 0.22954232372872352, 0.23697342759725692, 0.17839689367762435, 0.20745379293917632, 0.20876856987902104, 0.2039184057671839, 0.1979046409009474, 0.20073360912376503, 0.19283601216357837, 0.1868660524064809, 0.28970599062095936, 0.18925647186281014, 0.15783451243777313, 0.23494193077349435, 0.19088526265533912, 0.20895242918237855, 0.1968350896172475, 0.19683535050853307, 0.10689630630096913, 0.08223035070336393, 0.09392580171028653, 0.1313497305354716, 0.10158321743353771, 0.05873950850980414, 0.08675277118817726, 0.11130928428813636, 0.08570625741069893, 0.2163118189281389, 0.26920656428347933, 0.2512894835438615, 0.20175526836905033, 0.22714341640779667, 0.22337082402542485, 0.2141292220436335, 0.2760242474195691, 0.2563549153056298, 0.0159759469503733, 0.025662408344924725, 0.01753533829457976, 0.04081286918964866, 0.03923295781975045, 0.025241874767651606, 0.040127492275430665, 0.029785310426343692, 0.032374797501504515, 0.14041054513169837, 0.14779581135391306, 0.15599042478709002, 0.14620086299000234, 0.1513143308973336, 0.15848598894269106, 0.1486101846185447, 0.16794285303745982, 0.15405032900983207, 0.49776602892330435, 0.4835292709758261, 0.4665127364818865, 0.49954438182684857, 0.4930267336041465, 0.48635523965050176, 0.5069050314428112, 0.4950274310271472, 0.4810277469425418, 0.10625118658196331, 0.126210944547397, 0.11591145019370575, 0.11817290809418535, 0.11599832911872776, 0.10366926317904412, 0.0824043787183113, 0.1138237254436435, 0.10309740732371153, 0.1536559029239366, 0.15431417994543262, 0.22399635612568247, 0.13929972833118887, 0.1990679908902332, 0.16165215532697563, 0.18668253269176138, 0.19453892780391058, 0.15311237722569893, 0.2822306565328476, 0.2772413150772822, 0.31071299165537825, 0.29161164918555516, 0.27668130648666445, 0.27908104483316853, 0.3018823548628108, 0.2967955122089254, 0.3118344453609948, 0.2256398885862253, 0.22078677729697083, 0.2221518696078698, 0.19887156467967937, 0.23002504299755522, 0.21442289204935527, 0.230036210314425, 0.23922146123659926, 0.22417180886822707, 0.20316106429569092, 0.19482100653522316, 0.17895046604826292, 0.19232413826636308, 0.21168136057176468, 0.19177267585075175, 0.1910699505235791, 0.21582314162844896, 0.17958097531785955, 0.18429267633261903, 0.18584993912106518, 0.1825350357484845, 0.18400611746524853, 0.1803207403309165, 0.19068906061597213, 0.21121053780413945, 0.2109397515912741, 0.20342744201878127, 0.17362948653966037, 0.17257686899398572, 0.480574784867404, 0.5275061594900667, 0.3154958305797153, 0.5390126544584274, 0.22329439934542272, 0.562255034788962, 0.41743166587161307, 0.2775167874421328, 0.20032788136841206, 0.42205305963440987, 0.29543195741568684, 0.1888284797156593, 0.49600328888273526, 0.20642324999649775, 0.15096307676042398, 0.20330660461441807, 0.1825375981848214, 0.18197028146773775, 0.1875020263587751, 0.18453335483105437, 0.18310533893198833, 0.19141357579656204, 0.22686943915672286, 0.20640996933297417, 0.18611194178091472, 0.08636300678950937, 0.07879415210385599, 0.08085692544481027, 0.08521897053505778, 0.07901236156076907, 0.08164132248142264, 0.07506127951804609, 0.07184422297608084, 0.07428699432306962]}, "mutation_prompt": null}
{"id": "58579337-23b2-41d6-97a0-3922d6290cbf", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7  # Changed mutation factor\n        self.crossover_rate = 0.85  # Changed crossover rate\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):  # Randomize search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85  # Adaptive mutation factor\n            self.crossover_rate = 0.9  # Adaptive crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer utilizing stochastic local search intensification and crossover adaptation for robust convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6384985807086965, 0.6339732821819166, 0.6371531490293669, 0.6927058357064666, 0.6770330159266937, 0.680832036516016, 0.6533716164942065, 0.6666360012848684, 0.6340578797007526, 0.359180864369291, 0.37066304666490546, 0.3733453550154331, 0.4225684366929948, 0.39541666912672957, 0.385794183336828, 0.42774345471198605, 0.38810977278923964, 0.40913127263577365, 0.12817502273083847, 0.12036598365694207, 0.11069603586390786, 0.10491651155207016, 0.14185020732166542, 0.11775704113422414, 0.1060914170979258, 0.12597606962918162, 0.11690270118283697, 0.10994141569793103, 0.10714051932994173, 0.09659174442506524, 0.11485380241321819, 0.11129872386202078, 0.09224830600315526, 0.10829274963470448, 0.11103392467415307, 0.10912248760940824, 0.9318224298119114, 0.9275192757236804, 0.9401610640040723, 0.9408963859547194, 0.931847119652183, 0.9517585163371646, 0.944898108709874, 0.9535771632385173, 0.9281927308166372, 0.28430662176206356, 0.26754510594062153, 0.27098587981713096, 0.276004667102716, 0.28488794187752964, 0.272221496963144, 0.3065794775918316, 0.29907912125414626, 0.28584271115508164, 0.4184081497342218, 0.40358485189438553, 0.6592024849166078, 0.5532156638065322, 0.5095361350579866, 0.6675188324466887, 0.5355939939832268, 0.5944557975413576, 0.6359804938973379, 0.22954232372872352, 0.23697342759725692, 0.17839689367762435, 0.20745379293917632, 0.20876856987902104, 0.2039184057671839, 0.1979046409009474, 0.20073360912376503, 0.19283601216357837, 0.1868660524064809, 0.28970599062095936, 0.18925647186281014, 0.15783451243777313, 0.23494193077349435, 0.19088526265533912, 0.20895242918237855, 0.1968350896172475, 0.19683535050853307, 0.10689630630096913, 0.08223035070336393, 0.09392580171028653, 0.1313497305354716, 0.10158321743353771, 0.05873950850980414, 0.08675277118817726, 0.11130928428813636, 0.08570625741069893, 0.2163118189281389, 0.26920656428347933, 0.2512894835438615, 0.20175526836905033, 0.22714341640779667, 0.22337082402542485, 0.2141292220436335, 0.2760242474195691, 0.2563549153056298, 0.0159759469503733, 0.025662408344924725, 0.01753533829457976, 0.04081286918964866, 0.03923295781975045, 0.025241874767651606, 0.040127492275430665, 0.029785310426343692, 0.032374797501504515, 0.14041054513169837, 0.14779581135391306, 0.15599042478709002, 0.14620086299000234, 0.1513143308973336, 0.15848598894269106, 0.1486101846185447, 0.16794285303745982, 0.15405032900983207, 0.49776602892330435, 0.4835292709758261, 0.4665127364818865, 0.49954438182684857, 0.4930267336041465, 0.48635523965050176, 0.5069050314428112, 0.4950274310271472, 0.4810277469425418, 0.10625118658196331, 0.126210944547397, 0.11591145019370575, 0.11817290809418535, 0.11599832911872776, 0.10366926317904412, 0.0824043787183113, 0.1138237254436435, 0.10309740732371153, 0.1536559029239366, 0.15431417994543262, 0.22399635612568247, 0.13929972833118887, 0.1990679908902332, 0.16165215532697563, 0.18668253269176138, 0.19453892780391058, 0.15311237722569893, 0.2822306565328476, 0.2772413150772822, 0.31071299165537825, 0.29161164918555516, 0.27668130648666445, 0.27908104483316853, 0.3018823548628108, 0.2967955122089254, 0.3118344453609948, 0.2256398885862253, 0.22078677729697083, 0.2221518696078698, 0.19887156467967937, 0.23002504299755522, 0.21442289204935527, 0.230036210314425, 0.23922146123659926, 0.22417180886822707, 0.20316106429569092, 0.19482100653522316, 0.17895046604826292, 0.19232413826636308, 0.21168136057176468, 0.19177267585075175, 0.1910699505235791, 0.21582314162844896, 0.17958097531785955, 0.18429267633261903, 0.18584993912106518, 0.1825350357484845, 0.18400611746524853, 0.1803207403309165, 0.19068906061597213, 0.21121053780413945, 0.2109397515912741, 0.20342744201878127, 0.17362948653966037, 0.17257686899398572, 0.480574784867404, 0.5275061594900667, 0.3154958305797153, 0.5390126544584274, 0.22329439934542272, 0.562255034788962, 0.41743166587161307, 0.2775167874421328, 0.20032788136841206, 0.42205305963440987, 0.29543195741568684, 0.1888284797156593, 0.49600328888273526, 0.20642324999649775, 0.15096307676042398, 0.20330660461441807, 0.1825375981848214, 0.18197028146773775, 0.1875020263587751, 0.18453335483105437, 0.18310533893198833, 0.19141357579656204, 0.22686943915672286, 0.20640996933297417, 0.18611194178091472, 0.08636300678950937, 0.07879415210385599, 0.08085692544481027, 0.08521897053505778, 0.07901236156076907, 0.08164132248142264, 0.07506127951804609, 0.07184422297608084, 0.07428699432306962]}, "mutation_prompt": null}
{"id": "fd5f0e79-eceb-43a7-b9c6-83249b2a03b8", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7  # Changed mutation factor\n        self.crossover_rate = 0.85  # Changed crossover rate\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):  # Randomize search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85  # Adaptive mutation factor\n            self.crossover_rate = 0.9  # Adaptive crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer utilizing stochastic local search intensification and crossover adaptation for robust convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6384985807086965, 0.6339732821819166, 0.6371531490293669, 0.6927058357064666, 0.6770330159266937, 0.680832036516016, 0.6533716164942065, 0.6666360012848684, 0.6340578797007526, 0.359180864369291, 0.37066304666490546, 0.3733453550154331, 0.4225684366929948, 0.39541666912672957, 0.385794183336828, 0.42774345471198605, 0.38810977278923964, 0.40913127263577365, 0.12817502273083847, 0.12036598365694207, 0.11069603586390786, 0.10491651155207016, 0.14185020732166542, 0.11775704113422414, 0.1060914170979258, 0.12597606962918162, 0.11690270118283697, 0.10994141569793103, 0.10714051932994173, 0.09659174442506524, 0.11485380241321819, 0.11129872386202078, 0.09224830600315526, 0.10829274963470448, 0.11103392467415307, 0.10912248760940824, 0.9318224298119114, 0.9275192757236804, 0.9401610640040723, 0.9408963859547194, 0.931847119652183, 0.9517585163371646, 0.944898108709874, 0.9535771632385173, 0.9281927308166372, 0.28430662176206356, 0.26754510594062153, 0.27098587981713096, 0.276004667102716, 0.28488794187752964, 0.272221496963144, 0.3065794775918316, 0.29907912125414626, 0.28584271115508164, 0.4184081497342218, 0.40358485189438553, 0.6592024849166078, 0.5532156638065322, 0.5095361350579866, 0.6675188324466887, 0.5355939939832268, 0.5944557975413576, 0.6359804938973379, 0.22954232372872352, 0.23697342759725692, 0.17839689367762435, 0.20745379293917632, 0.20876856987902104, 0.2039184057671839, 0.1979046409009474, 0.20073360912376503, 0.19283601216357837, 0.1868660524064809, 0.28970599062095936, 0.18925647186281014, 0.15783451243777313, 0.23494193077349435, 0.19088526265533912, 0.20895242918237855, 0.1968350896172475, 0.19683535050853307, 0.10689630630096913, 0.08223035070336393, 0.09392580171028653, 0.1313497305354716, 0.10158321743353771, 0.05873950850980414, 0.08675277118817726, 0.11130928428813636, 0.08570625741069893, 0.2163118189281389, 0.26920656428347933, 0.2512894835438615, 0.20175526836905033, 0.22714341640779667, 0.22337082402542485, 0.2141292220436335, 0.2760242474195691, 0.2563549153056298, 0.0159759469503733, 0.025662408344924725, 0.01753533829457976, 0.04081286918964866, 0.03923295781975045, 0.025241874767651606, 0.040127492275430665, 0.029785310426343692, 0.032374797501504515, 0.14041054513169837, 0.14779581135391306, 0.15599042478709002, 0.14620086299000234, 0.1513143308973336, 0.15848598894269106, 0.1486101846185447, 0.16794285303745982, 0.15405032900983207, 0.49776602892330435, 0.4835292709758261, 0.4665127364818865, 0.49954438182684857, 0.4930267336041465, 0.48635523965050176, 0.5069050314428112, 0.4950274310271472, 0.4810277469425418, 0.10625118658196331, 0.126210944547397, 0.11591145019370575, 0.11817290809418535, 0.11599832911872776, 0.10366926317904412, 0.0824043787183113, 0.1138237254436435, 0.10309740732371153, 0.1536559029239366, 0.15431417994543262, 0.22399635612568247, 0.13929972833118887, 0.1990679908902332, 0.16165215532697563, 0.18668253269176138, 0.19453892780391058, 0.15311237722569893, 0.2822306565328476, 0.2772413150772822, 0.31071299165537825, 0.29161164918555516, 0.27668130648666445, 0.27908104483316853, 0.3018823548628108, 0.2967955122089254, 0.3118344453609948, 0.2256398885862253, 0.22078677729697083, 0.2221518696078698, 0.19887156467967937, 0.23002504299755522, 0.21442289204935527, 0.230036210314425, 0.23922146123659926, 0.22417180886822707, 0.20316106429569092, 0.19482100653522316, 0.17895046604826292, 0.19232413826636308, 0.21168136057176468, 0.19177267585075175, 0.1910699505235791, 0.21582314162844896, 0.17958097531785955, 0.18429267633261903, 0.18584993912106518, 0.1825350357484845, 0.18400611746524853, 0.1803207403309165, 0.19068906061597213, 0.21121053780413945, 0.2109397515912741, 0.20342744201878127, 0.17362948653966037, 0.17257686899398572, 0.480574784867404, 0.5275061594900667, 0.3154958305797153, 0.5390126544584274, 0.22329439934542272, 0.562255034788962, 0.41743166587161307, 0.2775167874421328, 0.20032788136841206, 0.42205305963440987, 0.29543195741568684, 0.1888284797156593, 0.49600328888273526, 0.20642324999649775, 0.15096307676042398, 0.20330660461441807, 0.1825375981848214, 0.18197028146773775, 0.1875020263587751, 0.18453335483105437, 0.18310533893198833, 0.19141357579656204, 0.22686943915672286, 0.20640996933297417, 0.18611194178091472, 0.08636300678950937, 0.07879415210385599, 0.08085692544481027, 0.08521897053505778, 0.07901236156076907, 0.08164132248142264, 0.07506127951804609, 0.07184422297608084, 0.07428699432306962]}, "mutation_prompt": null}
{"id": "c33b4a41-fd91-436a-afec-a55faa227b97", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size for better diversity\n        self.mutation_factor = 0.8  # Enhanced mutation factor\n        self.crossover_rate = 0.8  # Balanced crossover rate\n        self.local_search_intensity = 7  # Increased local search intensity\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.15  # Increased step size for broader search\n        for _ in range(self.local_search_intensity + np.random.randint(0, 4)):  # More randomized search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 3:\n            self.local_search_intensity = 12  # More aggressive local search in later stages\n            self.mutation_factor = 0.9  # Increased mutation factor for late-stage exploration\n            self.crossover_rate = 0.92  # Higher crossover rate to maintain diversity\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptiveMultiStrategyOptimizer", "description": "An adaptive multi-strategy optimizer using enhanced mutation dynamics and dynamic parameter adaptations for improved exploitation and exploration balance.", "configspace": "", "generation": 13, "fitness": 0.2161584085272858, "feedback": "The algorithm AdaptiveMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.4688596334996765, 0.44030943888543905, 0.43791311593120863, 0.4982093363964051, 0.4890656410938953, 0.4890540419506104, 0.4630066751744809, 0.4824686991443067, 0.4676269965426061, 0.21952614832628858, 0.23838941285694915, 0.17932648006397411, 0.21584397300465885, 0.18396430634361127, 0.19613328238818184, 0.21093165377282364, 0.22855983689645754, 0.19817237573339308, 0.1100273298579274, 0.1182274172263813, 0.12303198069986554, 0.11797906994337792, 0.11377366877553108, 0.10575998777064033, 0.10250345244101333, 0.12605763421182214, 0.12253052791488517, 0.10283671149974305, 0.09664350710702296, 0.10002139993158021, 0.1123250211090292, 0.0892269803536121, 0.09094619421814243, 0.08453996228497562, 0.09264991060407168, 0.08944109227051411, 0.9074780126320682, 0.9543757035964028, 0.9540732220781639, 0.9459531983102769, 0.9690655005372322, 0.9397527520796846, 0.9474879426722231, 0.9644166901449832, 0.9388567325163334, 0.20913012383045992, 0.22452128460871867, 0.21574228793550543, 0.2099088803941408, 0.2132549958867782, 0.21714242763466773, 0.2138503742166934, 0.2231910352359039, 0.21691081835315185, 0.28086929539211536, 0.3304002255077325, 0.2435608724395254, 0.2781303849069867, 0.288781356360316, 0.33479196749744555, 0.2663098300761161, 0.25100073911128795, 0.2926399403801643, 0.13623818129258003, 0.14120199099370168, 0.14120233782684222, 0.15362344978124454, 0.1434176050656264, 0.1279806739488264, 0.1317790814355012, 0.13278306060929967, 0.15095171886417424, 0.18058252462539637, 0.12281086650479645, 0.12364027428538682, 0.1411113079552071, 0.10820961629201264, 0.13493096017834083, 0.10898959005541442, 0.14244977324342767, 0.14169108036610456, 0.02606089180686033, 0.04388524201287913, 0.06240725727737795, 0.024852168532956465, 0.041410942232586456, 0.030894759893037027, 0.028527649205705496, 0.021654115455326806, 0.03660009473308401, 0.16985113613571812, 0.14752491160430004, 0.15768299821734721, 0.1444929236497312, 0.1216630272426279, 0.12673159136665124, 0.14896805368152488, 0.1914732042424082, 0.17371032473678094, 0.001025793616311832, 9.999999999998899e-05, 9.999999999998899e-05, 0.0021964809331344037, 0.03397284379742538, 0.0014681704329581047, 9.999999999998899e-05, 0.0024881667306830835, 9.999999999998899e-05, 0.09171004970476793, 0.10925595897460116, 0.10771962653028966, 0.10326939295063309, 0.10088100698923574, 0.09222442164642997, 0.10907540679280281, 0.11098327399323316, 0.09252696392026505, 0.36723486703628727, 0.41228978790568194, 0.4189721861822018, 0.4108386244348152, 0.3930305024602425, 0.42736128130339923, 0.3961658330141361, 0.4023704106835081, 0.38727831245325106, 0.08731826987168734, 0.09085417144909347, 0.11390593772194169, 0.08096397830455027, 0.09730094115558185, 0.0932581346061464, 0.09484888985538797, 0.0879871606148046, 0.09457465828378497, 0.15344837949590218, 0.15939038081628076, 0.1843722680890889, 0.16917806269736668, 0.14497593944905307, 0.19010144246951888, 0.17124744504141165, 0.1531784323290707, 0.15079342502848503, 0.2375473241418209, 0.23595490949141995, 0.2404214899695074, 0.23298947770597955, 0.24013456826950397, 0.2431388828360065, 0.2585540086223459, 0.2750562454167872, 0.2533470624863883, 0.19791419804537058, 0.16994146726675774, 0.17450542323206775, 0.17086549755642022, 0.17166856114500806, 0.1960891010109026, 0.19109389878407157, 0.2149476148346774, 0.1797416755641168, 0.2026200197126925, 0.18983518907109664, 0.1962643206069259, 0.18901813900469078, 0.18323617026655437, 0.2323117484510553, 0.20724729498247219, 0.1980967191123738, 0.17741998964658667, 0.19115513460915767, 0.1902828494985167, 0.20625307621902966, 0.1850932757790129, 0.1782438206882765, 0.21045697109950912, 0.18266348377885888, 0.1870885274229077, 0.1915904838941298, 0.45124594348308855, 0.3920416121832001, 0.3244169892678682, 0.3681498045211198, 0.16742472444319267, 0.1788256657140468, 0.2338568746785662, 0.16855389576083324, 0.18835131396741012, 0.35443929822176445, 0.3580091169328383, 0.3009114913434122, 0.27409735346181074, 0.24899367060548117, 0.283629828638547, 0.2021354427369344, 0.20474799940137178, 0.20462777328020332, 0.19668919272822927, 0.19124774272379907, 0.17513836840566055, 0.190171833195925, 0.1929649033752574, 0.1771603069521912, 0.17842404502858966, 0.17072447270880042, 0.17497266041071213, 0.0742223981049458, 0.07982580070332002, 0.06313773792673327, 0.07468126212735637, 0.06688993643974694, 0.07083191167977965, 0.08895050462665255, 0.07910926018197006, 0.0659243300329565]}, "mutation_prompt": null}
{"id": "6d14dfc0-e515-4a36-8da6-7db55a3e3e82", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7  # Changed mutation factor\n        self.crossover_rate = 0.85  # Changed crossover rate\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):  # Randomize search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85  # Adaptive mutation factor\n            self.crossover_rate = 0.9  # Adaptive crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer utilizing stochastic local search intensification and crossover adaptation for robust convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6384985807086965, 0.6339732821819166, 0.6371531490293669, 0.6927058357064666, 0.6770330159266937, 0.680832036516016, 0.6533716164942065, 0.6666360012848684, 0.6340578797007526, 0.359180864369291, 0.37066304666490546, 0.3733453550154331, 0.4225684366929948, 0.39541666912672957, 0.385794183336828, 0.42774345471198605, 0.38810977278923964, 0.40913127263577365, 0.12817502273083847, 0.12036598365694207, 0.11069603586390786, 0.10491651155207016, 0.14185020732166542, 0.11775704113422414, 0.1060914170979258, 0.12597606962918162, 0.11690270118283697, 0.10994141569793103, 0.10714051932994173, 0.09659174442506524, 0.11485380241321819, 0.11129872386202078, 0.09224830600315526, 0.10829274963470448, 0.11103392467415307, 0.10912248760940824, 0.9318224298119114, 0.9275192757236804, 0.9401610640040723, 0.9408963859547194, 0.931847119652183, 0.9517585163371646, 0.944898108709874, 0.9535771632385173, 0.9281927308166372, 0.28430662176206356, 0.26754510594062153, 0.27098587981713096, 0.276004667102716, 0.28488794187752964, 0.272221496963144, 0.3065794775918316, 0.29907912125414626, 0.28584271115508164, 0.4184081497342218, 0.40358485189438553, 0.6592024849166078, 0.5532156638065322, 0.5095361350579866, 0.6675188324466887, 0.5355939939832268, 0.5944557975413576, 0.6359804938973379, 0.22954232372872352, 0.23697342759725692, 0.17839689367762435, 0.20745379293917632, 0.20876856987902104, 0.2039184057671839, 0.1979046409009474, 0.20073360912376503, 0.19283601216357837, 0.1868660524064809, 0.28970599062095936, 0.18925647186281014, 0.15783451243777313, 0.23494193077349435, 0.19088526265533912, 0.20895242918237855, 0.1968350896172475, 0.19683535050853307, 0.10689630630096913, 0.08223035070336393, 0.09392580171028653, 0.1313497305354716, 0.10158321743353771, 0.05873950850980414, 0.08675277118817726, 0.11130928428813636, 0.08570625741069893, 0.2163118189281389, 0.26920656428347933, 0.2512894835438615, 0.20175526836905033, 0.22714341640779667, 0.22337082402542485, 0.2141292220436335, 0.2760242474195691, 0.2563549153056298, 0.0159759469503733, 0.025662408344924725, 0.01753533829457976, 0.04081286918964866, 0.03923295781975045, 0.025241874767651606, 0.040127492275430665, 0.029785310426343692, 0.032374797501504515, 0.14041054513169837, 0.14779581135391306, 0.15599042478709002, 0.14620086299000234, 0.1513143308973336, 0.15848598894269106, 0.1486101846185447, 0.16794285303745982, 0.15405032900983207, 0.49776602892330435, 0.4835292709758261, 0.4665127364818865, 0.49954438182684857, 0.4930267336041465, 0.48635523965050176, 0.5069050314428112, 0.4950274310271472, 0.4810277469425418, 0.10625118658196331, 0.126210944547397, 0.11591145019370575, 0.11817290809418535, 0.11599832911872776, 0.10366926317904412, 0.0824043787183113, 0.1138237254436435, 0.10309740732371153, 0.1536559029239366, 0.15431417994543262, 0.22399635612568247, 0.13929972833118887, 0.1990679908902332, 0.16165215532697563, 0.18668253269176138, 0.19453892780391058, 0.15311237722569893, 0.2822306565328476, 0.2772413150772822, 0.31071299165537825, 0.29161164918555516, 0.27668130648666445, 0.27908104483316853, 0.3018823548628108, 0.2967955122089254, 0.3118344453609948, 0.2256398885862253, 0.22078677729697083, 0.2221518696078698, 0.19887156467967937, 0.23002504299755522, 0.21442289204935527, 0.230036210314425, 0.23922146123659926, 0.22417180886822707, 0.20316106429569092, 0.19482100653522316, 0.17895046604826292, 0.19232413826636308, 0.21168136057176468, 0.19177267585075175, 0.1910699505235791, 0.21582314162844896, 0.17958097531785955, 0.18429267633261903, 0.18584993912106518, 0.1825350357484845, 0.18400611746524853, 0.1803207403309165, 0.19068906061597213, 0.21121053780413945, 0.2109397515912741, 0.20342744201878127, 0.17362948653966037, 0.17257686899398572, 0.480574784867404, 0.5275061594900667, 0.3154958305797153, 0.5390126544584274, 0.22329439934542272, 0.562255034788962, 0.41743166587161307, 0.2775167874421328, 0.20032788136841206, 0.42205305963440987, 0.29543195741568684, 0.1888284797156593, 0.49600328888273526, 0.20642324999649775, 0.15096307676042398, 0.20330660461441807, 0.1825375981848214, 0.18197028146773775, 0.1875020263587751, 0.18453335483105437, 0.18310533893198833, 0.19141357579656204, 0.22686943915672286, 0.20640996933297417, 0.18611194178091472, 0.08636300678950937, 0.07879415210385599, 0.08085692544481027, 0.08521897053505778, 0.07901236156076907, 0.08164132248142264, 0.07506127951804609, 0.07184422297608084, 0.07428699432306962]}, "mutation_prompt": null}
{"id": "357c647f-2ac9-4a6c-a4a4-ce965f2f1238", "solution": "import numpy as np\n\nclass DynamicAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Reduced population size for quicker exploration\n        self.mutation_factor = 0.8  # Adjusted mutation factor for better diversity\n        self.crossover_rate = 0.8  # Adjusted crossover rate for balanced exploration-exploitation\n        self.local_search_intensity = 4  # Slightly reduced intensity for quicker convergence\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.15  # Increased step size for more aggressive local search\n        for _ in range(self.local_search_intensity + np.random.randint(0, 2)):  # Less variance in intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 3:  # Earlier adaptation trigger point\n            self.local_search_intensity = 8  # Increased adaptive search intensity for focused improvement\n            self.mutation_factor = 0.9  # Further adaptive mutation factor for exploration\n            self.crossover_rate = 0.95  # Enhanced crossover rate for exploiting good solutions\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "DynamicAdaptiveOptimizer", "description": "An adaptive optimizer using dynamic parameter tuning and probabilistic local search to enhance convergence efficiency.", "configspace": "", "generation": 15, "fitness": 0.26883267717002934, "feedback": "The algorithm DynamicAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6256944664728319, 0.6134028476351883, 0.6640605637234971, 0.6379943921311283, 0.6507585350814902, 0.6800774933080878, 0.6586484688334201, 0.6844346117769117, 0.6380393428171578, 0.35819501590336167, 0.33533581025853576, 0.35793458720205074, 0.30437961602132757, 0.3904655620539834, 0.4011941494063975, 0.3896044548614501, 0.36590765556144955, 0.40366451111755663, 0.10328232025590933, 0.10856648223934795, 0.12084860042325107, 0.1222094216271633, 0.11293352632776965, 0.11767169703096259, 0.12019053352440556, 0.11930508629797965, 0.12205974077980208, 0.09582305359082843, 0.0981865092843498, 0.12653651651818343, 0.09611576307812086, 0.10106690014739017, 0.10986690524699261, 0.11260736991013842, 0.10549732153359714, 0.11093523686728801, 0.9671890540372298, 0.9527713241865606, 0.960739934451206, 0.9385957333839624, 0.9580652060914391, 0.9605889624217827, 0.9728577015561993, 0.964641440160122, 0.9534625940990025, 0.2836784788562371, 0.26857904290135326, 0.2631301205838349, 0.29808839486337246, 0.28559328547679874, 0.27286526953223067, 0.31323679342072497, 0.2830398866367082, 0.29934934892351117, 0.5437177242884064, 0.37654127224259204, 0.608664806542972, 0.45661562274683487, 0.4906477122534071, 0.5422640251786035, 0.548554142926177, 0.43593184772569005, 0.48468986975957407, 0.22013873214636837, 0.21716383717744914, 0.20443905352133318, 0.18486877515903077, 0.1753368090573093, 0.24764720734497014, 0.24337920186317052, 0.23499282763139073, 0.2103984767767212, 0.10964653001544411, 0.21295356946168653, 0.19807315651279933, 0.2256447976000302, 0.19072922537368486, 0.22471383746252227, 0.16655427983800764, 0.21333318552111513, 0.1570294632788628, 0.10529464072587402, 0.1302243944332646, 0.09116073523277124, 0.10854312507846409, 0.09843661751776422, 0.10470294551659243, 0.07910398413396436, 0.08731283996575001, 0.09164077696111383, 0.20511797669048792, 0.21798002654207504, 0.22298393491396595, 0.22869346542752134, 0.1778786395753672, 0.189382578687445, 0.25667157402198304, 0.22303419123679158, 0.23163398539983804, 0.022967744422631053, 0.047241878635944756, 0.02885678534444136, 0.042338730489683396, 0.009996242074725714, 0.02029523915826481, 0.02783517287717352, 0.021239617862570448, 0.031111294437050296, 0.15704133268251785, 0.15673404642067257, 0.1482773486068325, 0.13970254845460717, 0.16078689459004603, 0.163305014577089, 0.15004444268886963, 0.14857596807233786, 0.1386320362098502, 0.5019466195178528, 0.48401349744972044, 0.5157246598820571, 0.49863093234931277, 0.49903394269816215, 0.4919779197822519, 0.5170610557201181, 0.4938662149462518, 0.4931187480782143, 0.11536610692744176, 0.09827428643431413, 0.107894215386102, 0.12819530452588657, 0.10046362567799638, 0.09535454534135701, 0.10153445374766756, 0.0908394206180152, 0.10678447085191833, 0.2352608250800502, 0.17033210461970882, 0.1580181897269518, 0.19181071689613105, 0.1727945358515166, 0.17460056522155243, 0.21998074213739938, 0.14267958306466277, 0.19367810630349003, 0.27109871739404545, 0.2506038695053471, 0.27727876873981316, 0.2807780776446247, 0.25026859522778466, 0.22960949635703498, 0.29057387017859104, 0.29940178704275555, 0.2759958754292344, 0.19834863107081113, 0.1938287889670156, 0.19403075741106535, 0.20810914321244323, 0.17844926256734728, 0.18205836484078697, 0.22871165427070184, 0.23758260615277904, 0.22309791270809076, 0.20444171242178621, 0.19824931076808128, 0.2009010041745357, 0.19586311211040253, 0.18072199570052616, 0.19187595399438573, 0.21055584211899148, 0.19345714174655282, 0.18477003000218561, 0.18129900296130363, 0.17934465994504967, 0.20364833170124153, 0.18432575226540338, 0.1751752614677744, 0.19155135629535713, 0.19853696317387493, 0.19392184492749498, 0.18664580699556077, 0.5910659653013948, 0.42045208014725277, 0.6484651389042602, 0.3486345399943892, 0.5385740946233281, 0.4279819270862243, 0.40905779608970383, 0.18510263231727897, 0.31757634733490203, 0.1683565515053912, 0.20193402109024083, 0.18599343605396523, 0.2747632684722733, 0.2359641660466354, 0.3837774039481727, 0.2100053056633031, 0.20439291465526432, 0.2073770130166871, 0.18489319800570692, 0.20595053842690247, 0.17676707230521183, 0.19445205404322774, 0.18291658604035788, 0.17904260590658083, 0.17668975964536637, 0.17241592254709015, 0.19029400646597483, 0.06742304362078289, 0.07346620719435704, 0.0695350624305513, 0.07961078386418563, 0.07645178705798517, 0.07240823179518752, 0.07723084562513871, 0.07521532078466775, 0.07985759088543054]}, "mutation_prompt": null}
{"id": "38060bf1-a8ff-4a1c-be2c-891b751f3924", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7  # Changed mutation factor\n        self.crossover_rate = 0.85  # Changed crossover rate\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):  # Randomize search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85  # Adaptive mutation factor\n            self.crossover_rate = 0.9  # Adaptive crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer utilizing stochastic local search intensification and crossover adaptation for robust convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6384985807086965, 0.6339732821819166, 0.6371531490293669, 0.6927058357064666, 0.6770330159266937, 0.680832036516016, 0.6533716164942065, 0.6666360012848684, 0.6340578797007526, 0.359180864369291, 0.37066304666490546, 0.3733453550154331, 0.4225684366929948, 0.39541666912672957, 0.385794183336828, 0.42774345471198605, 0.38810977278923964, 0.40913127263577365, 0.12817502273083847, 0.12036598365694207, 0.11069603586390786, 0.10491651155207016, 0.14185020732166542, 0.11775704113422414, 0.1060914170979258, 0.12597606962918162, 0.11690270118283697, 0.10994141569793103, 0.10714051932994173, 0.09659174442506524, 0.11485380241321819, 0.11129872386202078, 0.09224830600315526, 0.10829274963470448, 0.11103392467415307, 0.10912248760940824, 0.9318224298119114, 0.9275192757236804, 0.9401610640040723, 0.9408963859547194, 0.931847119652183, 0.9517585163371646, 0.944898108709874, 0.9535771632385173, 0.9281927308166372, 0.28430662176206356, 0.26754510594062153, 0.27098587981713096, 0.276004667102716, 0.28488794187752964, 0.272221496963144, 0.3065794775918316, 0.29907912125414626, 0.28584271115508164, 0.4184081497342218, 0.40358485189438553, 0.6592024849166078, 0.5532156638065322, 0.5095361350579866, 0.6675188324466887, 0.5355939939832268, 0.5944557975413576, 0.6359804938973379, 0.22954232372872352, 0.23697342759725692, 0.17839689367762435, 0.20745379293917632, 0.20876856987902104, 0.2039184057671839, 0.1979046409009474, 0.20073360912376503, 0.19283601216357837, 0.1868660524064809, 0.28970599062095936, 0.18925647186281014, 0.15783451243777313, 0.23494193077349435, 0.19088526265533912, 0.20895242918237855, 0.1968350896172475, 0.19683535050853307, 0.10689630630096913, 0.08223035070336393, 0.09392580171028653, 0.1313497305354716, 0.10158321743353771, 0.05873950850980414, 0.08675277118817726, 0.11130928428813636, 0.08570625741069893, 0.2163118189281389, 0.26920656428347933, 0.2512894835438615, 0.20175526836905033, 0.22714341640779667, 0.22337082402542485, 0.2141292220436335, 0.2760242474195691, 0.2563549153056298, 0.0159759469503733, 0.025662408344924725, 0.01753533829457976, 0.04081286918964866, 0.03923295781975045, 0.025241874767651606, 0.040127492275430665, 0.029785310426343692, 0.032374797501504515, 0.14041054513169837, 0.14779581135391306, 0.15599042478709002, 0.14620086299000234, 0.1513143308973336, 0.15848598894269106, 0.1486101846185447, 0.16794285303745982, 0.15405032900983207, 0.49776602892330435, 0.4835292709758261, 0.4665127364818865, 0.49954438182684857, 0.4930267336041465, 0.48635523965050176, 0.5069050314428112, 0.4950274310271472, 0.4810277469425418, 0.10625118658196331, 0.126210944547397, 0.11591145019370575, 0.11817290809418535, 0.11599832911872776, 0.10366926317904412, 0.0824043787183113, 0.1138237254436435, 0.10309740732371153, 0.1536559029239366, 0.15431417994543262, 0.22399635612568247, 0.13929972833118887, 0.1990679908902332, 0.16165215532697563, 0.18668253269176138, 0.19453892780391058, 0.15311237722569893, 0.2822306565328476, 0.2772413150772822, 0.31071299165537825, 0.29161164918555516, 0.27668130648666445, 0.27908104483316853, 0.3018823548628108, 0.2967955122089254, 0.3118344453609948, 0.2256398885862253, 0.22078677729697083, 0.2221518696078698, 0.19887156467967937, 0.23002504299755522, 0.21442289204935527, 0.230036210314425, 0.23922146123659926, 0.22417180886822707, 0.20316106429569092, 0.19482100653522316, 0.17895046604826292, 0.19232413826636308, 0.21168136057176468, 0.19177267585075175, 0.1910699505235791, 0.21582314162844896, 0.17958097531785955, 0.18429267633261903, 0.18584993912106518, 0.1825350357484845, 0.18400611746524853, 0.1803207403309165, 0.19068906061597213, 0.21121053780413945, 0.2109397515912741, 0.20342744201878127, 0.17362948653966037, 0.17257686899398572, 0.480574784867404, 0.5275061594900667, 0.3154958305797153, 0.5390126544584274, 0.22329439934542272, 0.562255034788962, 0.41743166587161307, 0.2775167874421328, 0.20032788136841206, 0.42205305963440987, 0.29543195741568684, 0.1888284797156593, 0.49600328888273526, 0.20642324999649775, 0.15096307676042398, 0.20330660461441807, 0.1825375981848214, 0.18197028146773775, 0.1875020263587751, 0.18453335483105437, 0.18310533893198833, 0.19141357579656204, 0.22686943915672286, 0.20640996933297417, 0.18611194178091472, 0.08636300678950937, 0.07879415210385599, 0.08085692544481027, 0.08521897053505778, 0.07901236156076907, 0.08164132248142264, 0.07506127951804609, 0.07184422297608084, 0.07428699432306962]}, "mutation_prompt": null}
{"id": "929cfd92-4944-48dd-927b-4a1416d48597", "solution": "import numpy as np\n\nclass SynergyDrivenOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7  # Initial mutation factor\n        self.crossover_rate = 0.85  # Initial crossover rate\n        self.local_search_intensity = 5\n        self.reinitialize_after = budget // 3  # Reinitialize periodically\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):  # Randomize search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85  # Adaptive mutation factor\n            self.crossover_rate = 0.9  # Adaptive crossover rate\n\n    def reinitialize_population(self):\n        worst_indices = np.argsort(self.fitness)[-self.population_size//4:]\n        for idx in worst_indices:\n            self.population[idx] = np.random.uniform(-5, 5, self.dim)\n            self.fitness[idx] = func(self.population[idx])\n            self.used_budget += 1\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n            if self.used_budget % self.reinitialize_after == 0:\n                self.reinitialize_population()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "SynergyDrivenOptimizer", "description": "A synergy-driven optimizer blending adaptive differential evolution with stochastic local search and periodic reinitialization for improved exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.27397654938832466, "feedback": "The algorithm SynergyDrivenOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6384985807086965, 0.6339732821819166, 0.6371531490293669, 0.6927058357064666, 0.6770330159266937, 0.680832036516016, 0.6533716164942065, 0.6666360012848684, 0.6340578797007526, 0.359180864369291, 0.37066304666490546, 0.3733453550154331, 0.4225684366929948, 0.39541666912672957, 0.385794183336828, 0.42774345471198605, 0.38810977278923964, 0.40913127263577365, 0.12817502273083847, 0.12036598365694207, 0.11069603586390786, 0.10491651155207016, 0.14185020732166542, 0.11775704113422414, 0.1060914170979258, 0.12597606962918162, 0.11690270118283697, 0.10994141569793103, 0.10714051932994173, 0.09659174442506524, 0.11485380241321819, 0.11129872386202078, 0.09224830600315526, 0.10829274963470448, 0.11103392467415307, 0.10912248760940824, 0.9318224298119114, 0.9275192757236804, 0.9401610640040723, 0.9408963859547194, 0.931847119652183, 0.9517585163371646, 0.944898108709874, 0.9535771632385173, 0.9281927308166372, 0.28430662176206356, 0.26754510594062153, 0.27098587981713096, 0.276004667102716, 0.28488794187752964, 0.272221496963144, 0.3065794775918316, 0.29907912125414626, 0.28584271115508164, 0.4184081497342218, 0.40358485189438553, 0.6592024849166078, 0.5532156638065322, 0.5095361350579866, 0.6675188324466887, 0.5355939939832268, 0.5944557975413576, 0.6359804938973379, 0.22954232372872352, 0.23697342759725692, 0.17839689367762435, 0.20745379293917632, 0.20876856987902104, 0.2039184057671839, 0.1979046409009474, 0.20073360912376503, 0.19283601216357837, 0.1868660524064809, 0.28970599062095936, 0.18925647186281014, 0.15783451243777313, 0.23494193077349435, 0.19088526265533912, 0.20895242918237855, 0.1968350896172475, 0.19683535050853307, 0.10689630630096913, 0.08223035070336393, 0.09392580171028653, 0.1313497305354716, 0.10158321743353771, 0.05873950850980414, 0.08675277118817726, 0.11130928428813636, 0.08570625741069893, 0.2163118189281389, 0.26920656428347933, 0.2512894835438615, 0.20175526836905033, 0.22714341640779667, 0.22337082402542485, 0.2141292220436335, 0.2760242474195691, 0.2563549153056298, 0.0159759469503733, 0.025662408344924725, 0.01753533829457976, 0.04081286918964866, 0.03923295781975045, 0.025241874767651606, 0.040127492275430665, 0.029785310426343692, 0.032374797501504515, 0.14041054513169837, 0.14779581135391306, 0.15599042478709002, 0.14620086299000234, 0.1513143308973336, 0.15848598894269106, 0.1486101846185447, 0.16794285303745982, 0.15405032900983207, 0.49776602892330435, 0.4835292709758261, 0.4665127364818865, 0.49954438182684857, 0.4930267336041465, 0.48635523965050176, 0.5069050314428112, 0.4950274310271472, 0.4810277469425418, 0.10625118658196331, 0.126210944547397, 0.11591145019370575, 0.11817290809418535, 0.11599832911872776, 0.10366926317904412, 0.0824043787183113, 0.1138237254436435, 0.10309740732371153, 0.1536559029239366, 0.15431417994543262, 0.22399635612568247, 0.13929972833118887, 0.1990679908902332, 0.16165215532697563, 0.18668253269176138, 0.19453892780391058, 0.15311237722569893, 0.2822306565328476, 0.2772413150772822, 0.31071299165537825, 0.29161164918555516, 0.27668130648666445, 0.27908104483316853, 0.3018823548628108, 0.2967955122089254, 0.3118344453609948, 0.2256398885862253, 0.22078677729697083, 0.2221518696078698, 0.19887156467967937, 0.23002504299755522, 0.21442289204935527, 0.230036210314425, 0.23922146123659926, 0.22417180886822707, 0.20316106429569092, 0.19482100653522316, 0.17895046604826292, 0.19232413826636308, 0.21168136057176468, 0.19177267585075175, 0.1910699505235791, 0.21582314162844896, 0.17958097531785955, 0.18429267633261903, 0.18584993912106518, 0.1825350357484845, 0.18400611746524853, 0.1803207403309165, 0.19068906061597213, 0.21121053780413945, 0.2109397515912741, 0.20342744201878127, 0.17362948653966037, 0.17257686899398572, 0.480574784867404, 0.5275061594900667, 0.3154958305797153, 0.5390126544584274, 0.22329439934542272, 0.562255034788962, 0.41743166587161307, 0.2775167874421328, 0.20032788136841206, 0.42205305963440987, 0.29543195741568684, 0.1888284797156593, 0.49600328888273526, 0.20642324999649775, 0.15096307676042398, 0.20330660461441807, 0.1825375981848214, 0.18197028146773775, 0.1875020263587751, 0.18453335483105437, 0.18310533893198833, 0.19141357579656204, 0.22686943915672286, 0.20640996933297417, 0.18611194178091472, 0.08636300678950937, 0.07879415210385599, 0.08085692544481027, 0.08521897053505778, 0.07901236156076907, 0.08164132248142264, 0.07506127951804609, 0.07184422297608084, 0.07428699432306962]}, "mutation_prompt": null}
{"id": "fc786380-a1e0-475c-820d-223276596a2c", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7  # Changed mutation factor\n        self.crossover_rate = 0.85  # Changed crossover rate\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):  # Randomize search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85  # Adaptive mutation factor\n            self.crossover_rate = 0.9  # Adaptive crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer utilizing stochastic local search intensification and crossover adaptation for robust convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6384985807086965, 0.6339732821819166, 0.6371531490293669, 0.6927058357064666, 0.6770330159266937, 0.680832036516016, 0.6533716164942065, 0.6666360012848684, 0.6340578797007526, 0.359180864369291, 0.37066304666490546, 0.3733453550154331, 0.4225684366929948, 0.39541666912672957, 0.385794183336828, 0.42774345471198605, 0.38810977278923964, 0.40913127263577365, 0.12817502273083847, 0.12036598365694207, 0.11069603586390786, 0.10491651155207016, 0.14185020732166542, 0.11775704113422414, 0.1060914170979258, 0.12597606962918162, 0.11690270118283697, 0.10994141569793103, 0.10714051932994173, 0.09659174442506524, 0.11485380241321819, 0.11129872386202078, 0.09224830600315526, 0.10829274963470448, 0.11103392467415307, 0.10912248760940824, 0.9318224298119114, 0.9275192757236804, 0.9401610640040723, 0.9408963859547194, 0.931847119652183, 0.9517585163371646, 0.944898108709874, 0.9535771632385173, 0.9281927308166372, 0.28430662176206356, 0.26754510594062153, 0.27098587981713096, 0.276004667102716, 0.28488794187752964, 0.272221496963144, 0.3065794775918316, 0.29907912125414626, 0.28584271115508164, 0.4184081497342218, 0.40358485189438553, 0.6592024849166078, 0.5532156638065322, 0.5095361350579866, 0.6675188324466887, 0.5355939939832268, 0.5944557975413576, 0.6359804938973379, 0.22954232372872352, 0.23697342759725692, 0.17839689367762435, 0.20745379293917632, 0.20876856987902104, 0.2039184057671839, 0.1979046409009474, 0.20073360912376503, 0.19283601216357837, 0.1868660524064809, 0.28970599062095936, 0.18925647186281014, 0.15783451243777313, 0.23494193077349435, 0.19088526265533912, 0.20895242918237855, 0.1968350896172475, 0.19683535050853307, 0.10689630630096913, 0.08223035070336393, 0.09392580171028653, 0.1313497305354716, 0.10158321743353771, 0.05873950850980414, 0.08675277118817726, 0.11130928428813636, 0.08570625741069893, 0.2163118189281389, 0.26920656428347933, 0.2512894835438615, 0.20175526836905033, 0.22714341640779667, 0.22337082402542485, 0.2141292220436335, 0.2760242474195691, 0.2563549153056298, 0.0159759469503733, 0.025662408344924725, 0.01753533829457976, 0.04081286918964866, 0.03923295781975045, 0.025241874767651606, 0.040127492275430665, 0.029785310426343692, 0.032374797501504515, 0.14041054513169837, 0.14779581135391306, 0.15599042478709002, 0.14620086299000234, 0.1513143308973336, 0.15848598894269106, 0.1486101846185447, 0.16794285303745982, 0.15405032900983207, 0.49776602892330435, 0.4835292709758261, 0.4665127364818865, 0.49954438182684857, 0.4930267336041465, 0.48635523965050176, 0.5069050314428112, 0.4950274310271472, 0.4810277469425418, 0.10625118658196331, 0.126210944547397, 0.11591145019370575, 0.11817290809418535, 0.11599832911872776, 0.10366926317904412, 0.0824043787183113, 0.1138237254436435, 0.10309740732371153, 0.1536559029239366, 0.15431417994543262, 0.22399635612568247, 0.13929972833118887, 0.1990679908902332, 0.16165215532697563, 0.18668253269176138, 0.19453892780391058, 0.15311237722569893, 0.2822306565328476, 0.2772413150772822, 0.31071299165537825, 0.29161164918555516, 0.27668130648666445, 0.27908104483316853, 0.3018823548628108, 0.2967955122089254, 0.3118344453609948, 0.2256398885862253, 0.22078677729697083, 0.2221518696078698, 0.19887156467967937, 0.23002504299755522, 0.21442289204935527, 0.230036210314425, 0.23922146123659926, 0.22417180886822707, 0.20316106429569092, 0.19482100653522316, 0.17895046604826292, 0.19232413826636308, 0.21168136057176468, 0.19177267585075175, 0.1910699505235791, 0.21582314162844896, 0.17958097531785955, 0.18429267633261903, 0.18584993912106518, 0.1825350357484845, 0.18400611746524853, 0.1803207403309165, 0.19068906061597213, 0.21121053780413945, 0.2109397515912741, 0.20342744201878127, 0.17362948653966037, 0.17257686899398572, 0.480574784867404, 0.5275061594900667, 0.3154958305797153, 0.5390126544584274, 0.22329439934542272, 0.562255034788962, 0.41743166587161307, 0.2775167874421328, 0.20032788136841206, 0.42205305963440987, 0.29543195741568684, 0.1888284797156593, 0.49600328888273526, 0.20642324999649775, 0.15096307676042398, 0.20330660461441807, 0.1825375981848214, 0.18197028146773775, 0.1875020263587751, 0.18453335483105437, 0.18310533893198833, 0.19141357579656204, 0.22686943915672286, 0.20640996933297417, 0.18611194178091472, 0.08636300678950937, 0.07879415210385599, 0.08085692544481027, 0.08521897053505778, 0.07901236156076907, 0.08164132248142264, 0.07506127951804609, 0.07184422297608084, 0.07428699432306962]}, "mutation_prompt": null}
{"id": "8c2a3f07-bdb5-4ae3-97a0-5b0f21ce3581", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7  # Changed mutation factor\n        self.crossover_rate = 0.85  # Changed crossover rate\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):  # Randomize search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85  # Adaptive mutation factor\n            self.crossover_rate = 0.9  # Adaptive crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer utilizing stochastic local search intensification and crossover adaptation for robust convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6384985807086965, 0.6339732821819166, 0.6371531490293669, 0.6927058357064666, 0.6770330159266937, 0.680832036516016, 0.6533716164942065, 0.6666360012848684, 0.6340578797007526, 0.359180864369291, 0.37066304666490546, 0.3733453550154331, 0.4225684366929948, 0.39541666912672957, 0.385794183336828, 0.42774345471198605, 0.38810977278923964, 0.40913127263577365, 0.12817502273083847, 0.12036598365694207, 0.11069603586390786, 0.10491651155207016, 0.14185020732166542, 0.11775704113422414, 0.1060914170979258, 0.12597606962918162, 0.11690270118283697, 0.10994141569793103, 0.10714051932994173, 0.09659174442506524, 0.11485380241321819, 0.11129872386202078, 0.09224830600315526, 0.10829274963470448, 0.11103392467415307, 0.10912248760940824, 0.9318224298119114, 0.9275192757236804, 0.9401610640040723, 0.9408963859547194, 0.931847119652183, 0.9517585163371646, 0.944898108709874, 0.9535771632385173, 0.9281927308166372, 0.28430662176206356, 0.26754510594062153, 0.27098587981713096, 0.276004667102716, 0.28488794187752964, 0.272221496963144, 0.3065794775918316, 0.29907912125414626, 0.28584271115508164, 0.4184081497342218, 0.40358485189438553, 0.6592024849166078, 0.5532156638065322, 0.5095361350579866, 0.6675188324466887, 0.5355939939832268, 0.5944557975413576, 0.6359804938973379, 0.22954232372872352, 0.23697342759725692, 0.17839689367762435, 0.20745379293917632, 0.20876856987902104, 0.2039184057671839, 0.1979046409009474, 0.20073360912376503, 0.19283601216357837, 0.1868660524064809, 0.28970599062095936, 0.18925647186281014, 0.15783451243777313, 0.23494193077349435, 0.19088526265533912, 0.20895242918237855, 0.1968350896172475, 0.19683535050853307, 0.10689630630096913, 0.08223035070336393, 0.09392580171028653, 0.1313497305354716, 0.10158321743353771, 0.05873950850980414, 0.08675277118817726, 0.11130928428813636, 0.08570625741069893, 0.2163118189281389, 0.26920656428347933, 0.2512894835438615, 0.20175526836905033, 0.22714341640779667, 0.22337082402542485, 0.2141292220436335, 0.2760242474195691, 0.2563549153056298, 0.0159759469503733, 0.025662408344924725, 0.01753533829457976, 0.04081286918964866, 0.03923295781975045, 0.025241874767651606, 0.040127492275430665, 0.029785310426343692, 0.032374797501504515, 0.14041054513169837, 0.14779581135391306, 0.15599042478709002, 0.14620086299000234, 0.1513143308973336, 0.15848598894269106, 0.1486101846185447, 0.16794285303745982, 0.15405032900983207, 0.49776602892330435, 0.4835292709758261, 0.4665127364818865, 0.49954438182684857, 0.4930267336041465, 0.48635523965050176, 0.5069050314428112, 0.4950274310271472, 0.4810277469425418, 0.10625118658196331, 0.126210944547397, 0.11591145019370575, 0.11817290809418535, 0.11599832911872776, 0.10366926317904412, 0.0824043787183113, 0.1138237254436435, 0.10309740732371153, 0.1536559029239366, 0.15431417994543262, 0.22399635612568247, 0.13929972833118887, 0.1990679908902332, 0.16165215532697563, 0.18668253269176138, 0.19453892780391058, 0.15311237722569893, 0.2822306565328476, 0.2772413150772822, 0.31071299165537825, 0.29161164918555516, 0.27668130648666445, 0.27908104483316853, 0.3018823548628108, 0.2967955122089254, 0.3118344453609948, 0.2256398885862253, 0.22078677729697083, 0.2221518696078698, 0.19887156467967937, 0.23002504299755522, 0.21442289204935527, 0.230036210314425, 0.23922146123659926, 0.22417180886822707, 0.20316106429569092, 0.19482100653522316, 0.17895046604826292, 0.19232413826636308, 0.21168136057176468, 0.19177267585075175, 0.1910699505235791, 0.21582314162844896, 0.17958097531785955, 0.18429267633261903, 0.18584993912106518, 0.1825350357484845, 0.18400611746524853, 0.1803207403309165, 0.19068906061597213, 0.21121053780413945, 0.2109397515912741, 0.20342744201878127, 0.17362948653966037, 0.17257686899398572, 0.480574784867404, 0.5275061594900667, 0.3154958305797153, 0.5390126544584274, 0.22329439934542272, 0.562255034788962, 0.41743166587161307, 0.2775167874421328, 0.20032788136841206, 0.42205305963440987, 0.29543195741568684, 0.1888284797156593, 0.49600328888273526, 0.20642324999649775, 0.15096307676042398, 0.20330660461441807, 0.1825375981848214, 0.18197028146773775, 0.1875020263587751, 0.18453335483105437, 0.18310533893198833, 0.19141357579656204, 0.22686943915672286, 0.20640996933297417, 0.18611194178091472, 0.08636300678950937, 0.07879415210385599, 0.08085692544481027, 0.08521897053505778, 0.07901236156076907, 0.08164132248142264, 0.07506127951804609, 0.07184422297608084, 0.07428699432306962]}, "mutation_prompt": null}
{"id": "2f7b7bd0-9ff4-41e5-83fd-5a327c359319", "solution": "import numpy as np\n\nclass MutationAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7  # Changed mutation factor\n        self.crossover_rate = 0.85  # Changed crossover rate\n        self.local_search_intensity = 5\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1\n        for _ in range(self.local_search_intensity + np.random.randint(0, 3)):  # Randomize search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:\n            self.local_search_intensity = 10\n            self.mutation_factor = 0.85  # Adaptive mutation factor\n            self.crossover_rate = 0.9  # Adaptive crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MutationAdaptiveOptimizer", "description": "A mutation-adaptive hybrid optimizer utilizing stochastic local search intensification and crossover adaptation for robust convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.6384985807086965, 0.6339732821819166, 0.6371531490293669, 0.6927058357064666, 0.6770330159266937, 0.680832036516016, 0.6533716164942065, 0.6666360012848684, 0.6340578797007526, 0.359180864369291, 0.37066304666490546, 0.3733453550154331, 0.4225684366929948, 0.39541666912672957, 0.385794183336828, 0.42774345471198605, 0.38810977278923964, 0.40913127263577365, 0.12817502273083847, 0.12036598365694207, 0.11069603586390786, 0.10491651155207016, 0.14185020732166542, 0.11775704113422414, 0.1060914170979258, 0.12597606962918162, 0.11690270118283697, 0.10994141569793103, 0.10714051932994173, 0.09659174442506524, 0.11485380241321819, 0.11129872386202078, 0.09224830600315526, 0.10829274963470448, 0.11103392467415307, 0.10912248760940824, 0.9318224298119114, 0.9275192757236804, 0.9401610640040723, 0.9408963859547194, 0.931847119652183, 0.9517585163371646, 0.944898108709874, 0.9535771632385173, 0.9281927308166372, 0.28430662176206356, 0.26754510594062153, 0.27098587981713096, 0.276004667102716, 0.28488794187752964, 0.272221496963144, 0.3065794775918316, 0.29907912125414626, 0.28584271115508164, 0.4184081497342218, 0.40358485189438553, 0.6592024849166078, 0.5532156638065322, 0.5095361350579866, 0.6675188324466887, 0.5355939939832268, 0.5944557975413576, 0.6359804938973379, 0.22954232372872352, 0.23697342759725692, 0.17839689367762435, 0.20745379293917632, 0.20876856987902104, 0.2039184057671839, 0.1979046409009474, 0.20073360912376503, 0.19283601216357837, 0.1868660524064809, 0.28970599062095936, 0.18925647186281014, 0.15783451243777313, 0.23494193077349435, 0.19088526265533912, 0.20895242918237855, 0.1968350896172475, 0.19683535050853307, 0.10689630630096913, 0.08223035070336393, 0.09392580171028653, 0.1313497305354716, 0.10158321743353771, 0.05873950850980414, 0.08675277118817726, 0.11130928428813636, 0.08570625741069893, 0.2163118189281389, 0.26920656428347933, 0.2512894835438615, 0.20175526836905033, 0.22714341640779667, 0.22337082402542485, 0.2141292220436335, 0.2760242474195691, 0.2563549153056298, 0.0159759469503733, 0.025662408344924725, 0.01753533829457976, 0.04081286918964866, 0.03923295781975045, 0.025241874767651606, 0.040127492275430665, 0.029785310426343692, 0.032374797501504515, 0.14041054513169837, 0.14779581135391306, 0.15599042478709002, 0.14620086299000234, 0.1513143308973336, 0.15848598894269106, 0.1486101846185447, 0.16794285303745982, 0.15405032900983207, 0.49776602892330435, 0.4835292709758261, 0.4665127364818865, 0.49954438182684857, 0.4930267336041465, 0.48635523965050176, 0.5069050314428112, 0.4950274310271472, 0.4810277469425418, 0.10625118658196331, 0.126210944547397, 0.11591145019370575, 0.11817290809418535, 0.11599832911872776, 0.10366926317904412, 0.0824043787183113, 0.1138237254436435, 0.10309740732371153, 0.1536559029239366, 0.15431417994543262, 0.22399635612568247, 0.13929972833118887, 0.1990679908902332, 0.16165215532697563, 0.18668253269176138, 0.19453892780391058, 0.15311237722569893, 0.2822306565328476, 0.2772413150772822, 0.31071299165537825, 0.29161164918555516, 0.27668130648666445, 0.27908104483316853, 0.3018823548628108, 0.2967955122089254, 0.3118344453609948, 0.2256398885862253, 0.22078677729697083, 0.2221518696078698, 0.19887156467967937, 0.23002504299755522, 0.21442289204935527, 0.230036210314425, 0.23922146123659926, 0.22417180886822707, 0.20316106429569092, 0.19482100653522316, 0.17895046604826292, 0.19232413826636308, 0.21168136057176468, 0.19177267585075175, 0.1910699505235791, 0.21582314162844896, 0.17958097531785955, 0.18429267633261903, 0.18584993912106518, 0.1825350357484845, 0.18400611746524853, 0.1803207403309165, 0.19068906061597213, 0.21121053780413945, 0.2109397515912741, 0.20342744201878127, 0.17362948653966037, 0.17257686899398572, 0.480574784867404, 0.5275061594900667, 0.3154958305797153, 0.5390126544584274, 0.22329439934542272, 0.562255034788962, 0.41743166587161307, 0.2775167874421328, 0.20032788136841206, 0.42205305963440987, 0.29543195741568684, 0.1888284797156593, 0.49600328888273526, 0.20642324999649775, 0.15096307676042398, 0.20330660461441807, 0.1825375981848214, 0.18197028146773775, 0.1875020263587751, 0.18453335483105437, 0.18310533893198833, 0.19141357579656204, 0.22686943915672286, 0.20640996933297417, 0.18611194178091472, 0.08636300678950937, 0.07879415210385599, 0.08085692544481027, 0.08521897053505778, 0.07901236156076907, 0.08164132248142264, 0.07506127951804609, 0.07184422297608084, 0.07428699432306962]}, "mutation_prompt": null}
{"id": "78480280-5d00-4421-8bac-7df9290445ab", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.6  # Slightly adjusted mutation factor\n        self.crossover_rate = 0.8  # Slightly adjusted crossover rate\n        self.local_search_intensity = 3\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def randomized_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.15  # Altered step size\n        for _ in range(self.local_search_intensity + np.random.randint(1, 4)):  # Vary search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 3:  # Earlier adaptation\n            self.local_search_intensity = 8  # Adjusted local search intensity\n            self.mutation_factor = 0.75  # Adjust mutation factor\n            self.crossover_rate = 0.88  # Adjust crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.randomized_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptiveMultiStrategyOptimizer", "description": "An adaptive multi-strategy optimizer blending differential evolution, randomized local search, and parameter fine-tuning for enhanced search efficiency.", "configspace": "", "generation": 21, "fitness": 0.2858892822596154, "feedback": "The algorithm AdaptiveMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "a01ba078-6408-43ec-8908-3e9c704fa95e", "metadata": {"aucs": [0.7333136072307658, 0.7425301169880179, 0.7128431582422965, 0.7361937866960052, 0.7104034092476592, 0.7081955701429035, 0.7509479789724484, 0.7436432321884011, 0.7317138973290311, 0.4569665258325646, 0.45604878037005114, 0.4819940117457322, 0.42725955672208016, 0.4953422879169489, 0.47402362834497336, 0.49299072489678253, 0.4545170650801543, 0.4822485858033305, 0.10594067033842369, 0.10810810628424539, 0.10854688761861087, 0.11568393225860907, 0.12607257234727676, 0.12857065481140784, 0.1159906778010541, 0.1276120589720936, 0.11862194808453475, 0.11482550412965808, 0.12101289863829245, 0.11440646974660851, 0.09898281981436452, 0.11272511654911355, 0.12103630198817594, 0.11792530815018476, 0.12039173622462984, 0.12598865928937264, 0.9222199850690389, 0.9486557572297408, 0.9402677548547311, 0.9414346600510854, 0.946715114604804, 0.9288619442854908, 0.9542968718958459, 0.9635405122465681, 0.9465634043599598, 0.3215978703946756, 0.29465218211775923, 0.29332279214013013, 0.30207271301974903, 0.31702560430768867, 0.2958074302600815, 0.3207202935572051, 0.3489495540550891, 0.32313642244196794, 0.5494272649023879, 0.5659476503121607, 0.5708502657461971, 0.6556097643104061, 0.5727975116056597, 0.6043448848887523, 0.5085142401211401, 0.56344480068161, 0.5641928955418035, 0.22997145369140004, 0.24426900847114874, 0.240446543595911, 0.2004438762239018, 0.21925338656617555, 0.24056481783970207, 0.23579953168792445, 0.2353806758746163, 0.23402487458238264, 0.1086451643742199, 0.18283663370836734, 0.22661030961950712, 0.2664092422687816, 0.2400396280214463, 0.1941975188017826, 0.27820504078289343, 0.22420101799165337, 0.1887344566922473, 0.11987749940866033, 0.10230630711461908, 0.10245238188661354, 0.14460443304766346, 0.12176846086026094, 0.10775897094677889, 0.12231435159405568, 0.13291335480688538, 0.103203339446997, 0.25675932258440104, 0.22463085762555246, 0.2233459230818471, 0.2288954877509779, 0.25886405954993785, 0.22189325706013618, 0.2827665040315859, 0.27426370436040237, 0.2963393497864324, 0.031256073611026114, 0.032139067000379495, 0.018406531417928584, 0.03743184956356638, 0.03321937846917522, 0.027183371283012958, 0.04999690691238179, 0.030110901718381267, 0.04878058708267485, 0.16551717764619256, 0.1545285103009042, 0.17426519657615225, 0.17385892495636812, 0.158199278004711, 0.1862178565894569, 0.16352801304906606, 0.1874159623660977, 0.1727175397266032, 0.5145268340336384, 0.5152898753611941, 0.5337490513647958, 0.49972622006918277, 0.4949790829954398, 0.5311409400298579, 0.5243601025865254, 0.5615247827237579, 0.5301224883451165, 0.11500240374692383, 0.11105669589740286, 0.11063781863086242, 0.09836668038588037, 0.11520053086640347, 0.10953388278807574, 0.11421192934422908, 0.10022038015128032, 0.13054468904521999, 0.16318740234088658, 0.21763616806273622, 0.21504253411881646, 0.20729714548252665, 0.19012221904745008, 0.16121504086204108, 0.1707881353249714, 0.14786954036576394, 0.14775943167368155, 0.3093800813449271, 0.29070206159042067, 0.31559805582056766, 0.2835828655457596, 0.30444469676465646, 0.29864208821761373, 0.31860382122831565, 0.3119877549385307, 0.3178692289987948, 0.23962521236128598, 0.232973586391222, 0.23569815807632255, 0.24052942100991082, 0.21673599550290645, 0.2122483283404334, 0.220455904225055, 0.24165079060305805, 0.24132074865542574, 0.1924415337924067, 0.176092547359321, 0.19132097304649043, 0.18228339350066058, 0.20194637017469008, 0.19550641287033577, 0.19230254632373667, 0.2039299322604079, 0.20468122918933307, 0.20425071931170802, 0.1919688866375885, 0.2051240295314175, 0.23226376453971587, 0.19911531751811073, 0.18095214498007428, 0.21426128512088471, 0.1955714296652208, 0.20258133363630348, 0.5205585177106193, 0.42793833961707906, 0.18285019295053995, 0.41365375849869457, 0.23091403034911206, 0.19940653102689399, 0.3356930261659803, 0.32106751482090234, 0.4641670199641451, 0.20595385326178295, 0.1969881739232482, 0.1977180021464089, 0.2504414838875909, 0.3261636594884535, 0.21969950174991426, 0.2078638408467175, 0.20027688949663014, 0.2056304039635678, 0.1797683501215397, 0.18684204723889786, 0.18978413748391076, 0.191266140677953, 0.2071348273584751, 0.17883766157865122, 0.18243022815954324, 0.18442609089432138, 0.19980648290878955, 0.07544294271521468, 0.07771942752665839, 0.0824971932002172, 0.0740179058798347, 0.0731025595765914, 0.08088401687444857, 0.06810501953804482, 0.08218443351470228, 0.08274384443210403]}, "mutation_prompt": null}
{"id": "0783229c-d6c4-461b-af6b-c26c243d8455", "solution": "import numpy as np\n\nclass SymbioticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.65  # Adjusted mutation factor\n        self.crossover_rate = 0.82  # Adjusted crossover rate\n        self.local_search_intensity = 4  # Increased intensity\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def adaptive_local_search(self, func):\n        best_index = np.argmin(self.fitness)\n        best_solution = self.population[best_index].copy()\n        step_size = 0.1  # Reduced step size for finer search\n        for _ in range(self.local_search_intensity + np.random.randint(2, 4)):  # Vary search intensity\n            if self.used_budget >= self.budget:\n                break\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(best_solution + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[best_index]:\n                self.fitness[best_index] = candidate_fitness\n                best_solution = candidate\n\n    def adapt_parameters(self):\n        if self.used_budget > self.budget // 2:  # Dynamic adaptation based on budget\n            self.local_search_intensity = 6  # Adjusted search intensity\n            self.mutation_factor = 0.7  # Adjust mutation factor\n            self.crossover_rate = 0.85  # Adjust crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.adaptive_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "SymbioticHybridOptimizer", "description": "A hybrid symbiotic optimizer combining differential evolution and adaptive local search with dynamic parameter tuning for improved exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.2859604776569091, "feedback": "The algorithm SymbioticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "78480280-5d00-4421-8bac-7df9290445ab", "metadata": {"aucs": [0.7188276332655967, 0.698344069927658, 0.6930847662997115, 0.7059888653986414, 0.7172870195506581, 0.7129862337345905, 0.7372413055973885, 0.7110623323827039, 0.7072225116185373, 0.5115093656755851, 0.47637195173725677, 0.4970651363354819, 0.4851443476411993, 0.4938867085223668, 0.4878225887018711, 0.5016732650258848, 0.5020930204698502, 0.48985195326297937, 0.13052437213970203, 0.13876171375598312, 0.11245275164431934, 0.12091651227036726, 0.09954841912631907, 0.1240052347855004, 0.13875621353226286, 0.12093400179723324, 0.1230332651672339, 0.10542636138683026, 0.10553508800513534, 0.10120174579668295, 0.11272785790203288, 0.12497323823145201, 0.11168494629781, 0.12468532430815771, 0.10675800060451746, 0.10384830309014015, 0.9239108870622255, 0.9550478235159424, 0.9358813064592062, 0.9440564686625637, 0.9208852093087211, 0.9375901252169008, 0.9275468538500901, 0.9586995868582016, 0.9377198255392692, 0.31769802695740834, 0.3276065059655442, 0.2932370166513698, 0.3155987049082498, 0.34849545679140803, 0.34761852149816563, 0.32463851745086447, 0.31955055606556815, 0.3393312466253221, 0.48498972602486834, 0.5421389683672128, 0.5899293152713041, 0.47208151982887825, 0.57951434195241, 0.6601643322289311, 0.5787150188072174, 0.6223340458642398, 0.5961076547585176, 0.19505474697703962, 0.2023034544604938, 0.21640239856156274, 0.21399826212570416, 0.18900967018548365, 0.2212685635143684, 0.21649294824325171, 0.22830289667862802, 0.2079578752619604, 0.17006741885945953, 0.15057525549738293, 0.16497980961716208, 0.16938104475208804, 0.21677900988637744, 0.22590907377783231, 0.19980026444603138, 0.21419933797042556, 0.2262421345633313, 0.09930497624223023, 0.09412062070023819, 0.08480037717522904, 0.10069391173693676, 0.10593165926392989, 0.1042603243930067, 0.10891361332881444, 0.12302939158827486, 0.11251484810286205, 0.23539445603369957, 0.22349189066755104, 0.21992410877124857, 0.22457602768959373, 0.18999874489908275, 0.23946168322598804, 0.2762163961880617, 0.274399038088865, 0.2666447097801299, 0.01574895806486254, 0.025301396903806173, 0.020222161362110302, 0.031370960501361345, 0.02392920539681087, 0.04492156123988911, 0.015248203210493694, 0.05410785001939644, 0.023222279061660633, 0.1616538755262411, 0.17458292466561265, 0.16275166040187983, 0.1564254738886982, 0.15840062446010472, 0.17243482678488786, 0.1648137593639436, 0.16671115705742412, 0.14569971463880282, 0.5152521537713235, 0.5221693025284133, 0.5406639124615447, 0.4830770717306718, 0.5062144086361491, 0.48727752112025435, 0.5088554697652745, 0.5077401202787242, 0.5055129215635229, 0.09545874940962318, 0.11869724990310804, 0.1039253501909716, 0.1597331782348843, 0.10244599930196985, 0.11289993379359553, 0.0920195865881962, 0.11059939705745458, 0.09769899714562014, 0.15480201808158123, 0.19084749277745905, 0.15061304047283197, 0.21499753511826702, 0.22295556545846007, 0.13845311094857393, 0.18177322125400464, 0.17121719959858106, 0.1856477740733773, 0.3070872042057716, 0.3157534959925181, 0.3114087513669592, 0.29590320050681407, 0.2909935641797634, 0.2991327001659382, 0.30715370579268664, 0.3212693569766375, 0.32481156434504077, 0.22779507806730703, 0.2299066633599709, 0.23020256270242623, 0.22373896092297596, 0.23219822635751208, 0.22164485671671008, 0.23047148672180684, 0.24102188624550036, 0.24306040469213164, 0.19076077860119656, 0.183053135871719, 0.20427613524780563, 0.19338843841152398, 0.17471485865491398, 0.20228253317616696, 0.18291737019060694, 0.20825333989841388, 0.2005127020637978, 0.1932803084346837, 0.22372362071606322, 0.1858060583767598, 0.2087580693733917, 0.20512885434045858, 0.20471372401255505, 0.2113806088060013, 0.20164227627093412, 0.20316561864728355, 0.22835707866309718, 0.5271826276344849, 0.6057683667695359, 0.6011035956988071, 0.24435872119367497, 0.4074432024739415, 0.18449119387539714, 0.29347430400748575, 0.23485233838262687, 0.44428921962588697, 0.2029903860546054, 0.16216580008989712, 0.31281907488235117, 0.33745039969124313, 0.43262893563258376, 0.20843879503771234, 0.20634233331939, 0.20807333919118143, 0.19957282662640863, 0.19804261404801016, 0.17657587596878366, 0.20362522783556314, 0.18567522378660128, 0.19162759686255737, 0.1872564653396409, 0.18571301970689824, 0.18566754636398952, 0.08138612577678195, 0.08168168284523059, 0.0748232918686681, 0.07126242277559214, 0.09199436036942266, 0.07396559320461948, 0.07365763500512335, 0.08488771031902398, 0.08068633800579794]}, "mutation_prompt": null}
{"id": "2a756749-bbb0-43ca-a798-b159761ff6eb", "solution": "import numpy as np\n\nclass SymbioticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.mutation_factor = 0.68  # Adjusted mutation factor\n        self.crossover_rate = 0.80  # Adjusted crossover rate\n        self.local_search_intensity = 5  # Modified intensity\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = 0.15  # Increased step size for diversification\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if self.fitness.mean() < (np.median(self.fitness) + 0.1):  # Adaptive check condition\n            self.local_search_intensity = 7  # Adjusted search intensity\n            self.mutation_factor = 0.72  # Adjusted mutation factor\n            self.crossover_rate = 0.88  # Adjust crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "SymbioticHybridOptimizer", "description": "A hybrid optimizer that fuses differential evolution with stochastic local search and dynamic strategy adaptation for enhanced search efficiency.", "configspace": "", "generation": 23, "fitness": 0.32370584182886986, "feedback": "The algorithm SymbioticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "0783229c-d6c4-461b-af6b-c26c243d8455", "metadata": {"aucs": [0.7227616250043754, 0.729486358298918, 0.743514462288939, 0.7557645328427438, 0.741925256343198, 0.7437650219349463, 0.7505833394224459, 0.7539440341898446, 0.7122420710555544, 0.53464717358783, 0.5576205195067518, 0.5283721720707832, 0.5283428689149966, 0.5555510474066152, 0.5340901174288927, 0.4815446178976934, 0.5310825065991884, 0.5213773215432013, 0.11304247460251993, 0.1210443147984952, 0.1346969795356754, 0.12150293521683941, 0.11008201672358031, 0.12019200342156777, 0.12310252139800193, 0.12984650172194978, 0.1168395814964297, 0.11579440044041, 0.10834619518144539, 0.10334908005731791, 0.10661431236559271, 0.10882262661336395, 0.11775260044773928, 0.099555978416073, 0.12497709645823996, 0.10633325310433706, 0.9230206432765862, 0.9088611252901584, 0.9194859575952754, 0.9443389440247087, 0.9217987138666838, 0.9395403317992714, 0.910807192546055, 0.9162082604926769, 0.9439014190717047, 0.3473760576574456, 0.405480002361817, 0.341192514145253, 0.3908206630691491, 0.370663089194576, 0.3545279918139346, 0.3705658139455491, 0.4016877464478684, 0.44556077661020854, 0.734831181903551, 0.5759287910204856, 0.6213375958579661, 0.685963923269066, 0.6848871117751602, 0.6893081756467336, 0.7046337770308129, 0.6213270547400852, 0.642902327065922, 0.24174128163225828, 0.26417340112552945, 0.284743090274706, 0.22468420194278804, 0.24845046528161607, 0.3193265885119442, 0.24379773253945292, 0.26988356179604955, 0.29898504422934913, 0.31045001342792533, 0.30238976191718914, 0.17025006945822097, 0.27308976400531804, 0.30837281229870395, 0.28326961480866175, 0.3202499892126941, 0.2863650444437146, 0.29270115647716766, 0.13799173745381543, 0.12746531030611896, 0.12978813757217034, 0.1751877437706877, 0.11959789962561596, 0.11711992633894952, 0.20272745019835492, 0.16398921352128948, 0.15036168426578278, 0.2534982395562082, 0.24678071917038846, 0.2913607587448914, 0.25846340774129906, 0.23755419709065484, 0.2982742050774754, 0.29177592426521315, 0.2843818068689993, 0.28250309355376335, 0.07505723333927383, 0.053506867761011545, 0.07597462296550384, 0.07230196973984748, 0.10662899391215397, 0.06944369966051378, 0.10128141283116343, 0.09209560461423827, 0.08267184324222143, 0.20291722576330096, 0.18964291628070873, 0.21373524687277645, 0.23485798746785846, 0.23729713719591328, 0.2089489000268966, 0.22230821561781666, 0.21812475686622834, 0.21240597316397547, 0.5863042862432989, 0.558621589105828, 0.5885322046042201, 0.5941176964633599, 0.5716381798014012, 0.5655779539859686, 0.5944256258146254, 0.5689388299425178, 0.6088111952129212, 0.10161972435169697, 0.11272353360905085, 0.11096777056905816, 0.11384791060224964, 0.0996451838684177, 0.11370973698806797, 0.10519150207241745, 0.12053893122387094, 0.1073410736010999, 0.2707073858937914, 0.2065085646154864, 0.23029882633302556, 0.2013557992326771, 0.28531662523071655, 0.24726463631971085, 0.205950591761061, 0.2629863283350009, 0.20755181056646066, 0.31659121871006257, 0.3086827846596081, 0.31951541162079244, 0.3233725331683198, 0.32235716723481933, 0.3013478840150857, 0.33027221648084937, 0.34881653302406346, 0.3268927037489392, 0.24210452884900502, 0.23297198572161149, 0.2349172540500073, 0.24460717494829065, 0.24397442591660023, 0.217059695442412, 0.2343918666355096, 0.251242181430005, 0.24437960915674561, 0.21818113277426776, 0.18699170074642413, 0.1962156282410239, 0.20469469702336673, 0.19708485432723744, 0.2068210452870215, 0.19173737114882683, 0.18474503529044073, 0.2150372213943339, 0.1954109734425088, 0.18703543464950367, 0.22037495224811032, 0.22166042854344448, 0.18630402457935236, 0.19434182658587074, 0.204790034745995, 0.19150180652636528, 0.19589651071302383, 0.6421892882359124, 0.6714442510015733, 0.15159008858564937, 0.6858482333553458, 0.6747281823154089, 0.5879725742995761, 0.4578914622403707, 0.17947993967973108, 0.5526904798765447, 0.6519350233683334, 0.2041895597620953, 0.5253200148581365, 0.19744279882355653, 0.6322961520625812, 0.5454446037106653, 0.20411224175163922, 0.20641441741459288, 0.21047215220235238, 0.17412395838403172, 0.1771634649244388, 0.1743505765930704, 0.18257617206915921, 0.17764230366112188, 0.19693532575371164, 0.1793708087278192, 0.19792841436357078, 0.1944880308050626, 0.08031044936983944, 0.07178744901189205, 0.0752010403618133, 0.08870357238439153, 0.0771047763586139, 0.07431697422395933, 0.07514874069754696, 0.0756745926914979, 0.07694561600086658]}, "mutation_prompt": null}
{"id": "5cd533a1-f4dd-43e9-b7df-1c7df0d5a6b5", "solution": "import numpy as np\n\nclass EnhancedSymbioticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Adjusted population size\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.local_search_intensity = 6  # Modified intensity\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = 0.1  # Adjusted step size for local exploitation\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if self.fitness.mean() > np.median(self.fitness):  # Adaptive check condition\n            self.local_search_intensity = 8  # Adjusted search intensity\n            self.mutation_factor = 0.75  # Adjusted mutation factor\n            self.crossover_rate = 0.90  # Adjust crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedSymbioticOptimizer", "description": "An adaptive symbiotic optimizer integrating enhanced differential evolution, intensified local search, and self-tuning parameter strategies for robust optimization performance.", "configspace": "", "generation": 24, "fitness": 0.2870346896976247, "feedback": "The algorithm EnhancedSymbioticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "2a756749-bbb0-43ca-a798-b159761ff6eb", "metadata": {"aucs": [0.6387447006710978, 0.6054770970272164, 0.6278545947150922, 0.6694033885269952, 0.6700157104914748, 0.6433989343379558, 0.6873388677879884, 0.6746192620291724, 0.6505980510017189, 0.4141050317460834, 0.38205525305870336, 0.3732856744527585, 0.37782844835858564, 0.39004926607088175, 0.3492146594601412, 0.3922140091732351, 0.43257149515235593, 0.3877920297160641, 0.11692811908203571, 0.11479822713187626, 0.1275402694599045, 0.11775340389769229, 0.12607037109623798, 0.121514391640267, 0.11635556736398156, 0.12506401990962646, 0.12118279217612182, 0.10339623437602163, 0.10722203563182287, 0.11022734946724044, 0.09824811996894312, 0.10731628493779222, 0.10796874041337812, 0.10563777998016699, 0.10423666365848316, 0.10717042623116868, 0.9303595267169475, 0.9325493410806306, 0.9332884630499155, 0.9421881696083418, 0.947437622306425, 0.9170653098383728, 0.941808823044387, 0.9126908327794527, 0.9206501655554351, 0.293961387828222, 0.2830061394520884, 0.2828883538894895, 0.29956845306219215, 0.3058285557238559, 0.3097662526877508, 0.312664897274222, 0.31271913363942627, 0.2995764281487403, 0.604475581803896, 0.5638046056803669, 0.5384086640793693, 0.5916321948771087, 0.6454035550898374, 0.6656242922034044, 0.560912667684343, 0.5524203437757661, 0.5426817858724071, 0.2210172272685923, 0.26065535212310764, 0.2126563995580507, 0.22977171653109307, 0.21275324064761536, 0.20269446135459557, 0.2093904846521788, 0.23762526540789863, 0.22877280678101153, 0.18254692072060752, 0.3123450563431195, 0.2146119975395545, 0.20266845854946403, 0.23446592673057964, 0.23995087195154274, 0.2420081937709322, 0.20113475481777487, 0.22550866025017036, 0.1326467948311889, 0.12373025363456802, 0.16563946328482648, 0.16300999032832575, 0.14720012330188115, 0.08354516491985253, 0.1443926752809035, 0.1427908574836314, 0.1244083985559733, 0.2663921697008417, 0.2953889234445852, 0.2681490758562586, 0.2219253378057484, 0.24765389744937394, 0.2733799196661323, 0.28793080980914854, 0.3183090769732766, 0.28127252729656294, 0.030088481899467112, 0.025009604985095413, 0.03647970161702829, 0.04621400598246295, 0.07004166203265727, 0.043973438627067485, 0.05663039232815714, 0.045771229231376, 0.04808622188010281, 0.1779149699943604, 0.16006434285174442, 0.17362260950933883, 0.17070116975693894, 0.1898496336582416, 0.17345880429147642, 0.18069297591876732, 0.18386752743843515, 0.17915419004240063, 0.5133506353011563, 0.49429995773724944, 0.5108564931499064, 0.5123394795219156, 0.5114790255566886, 0.5092317622149432, 0.5043799738015338, 0.4871585089401158, 0.5015631945523455, 0.11578617574061645, 0.1124287626109628, 0.12288963645964635, 0.12664817508378512, 0.14586155546429347, 0.10581106912965788, 0.12227199304898728, 0.12915014487538223, 0.12252504704542222, 0.2531262577170106, 0.21355795440915737, 0.18864806465409345, 0.22918003124060438, 0.18823725385697032, 0.21640986431522702, 0.20810612336950618, 0.2137826377308023, 0.2819702658708809, 0.2862734289493901, 0.282789970853926, 0.28961772915931927, 0.28031557123972384, 0.27782736380274875, 0.28672753564233, 0.30636819824375616, 0.2986003773156196, 0.30190645788607917, 0.21089642802439246, 0.22229467416937942, 0.20357000813677917, 0.22391893821089293, 0.2077610685181941, 0.2174479024418815, 0.2224425933292853, 0.24010448166392728, 0.22199019908290307, 0.18573022941537698, 0.1867599037001021, 0.1765041198027315, 0.19249042950091477, 0.18041899528423677, 0.20088434467331673, 0.196282939064658, 0.18987230899783758, 0.2254723522205605, 0.21215386099474498, 0.21478778780467922, 0.19531329372732076, 0.19573462322168833, 0.2031999989877077, 0.2066643556425226, 0.21661218602831123, 0.19104891613916275, 0.21935184541711794, 0.18076675477191384, 0.18019357887468523, 0.15909081034127703, 0.18006040001304247, 0.6375250931746275, 0.5405717521853495, 0.25786593742492125, 0.41428721698158943, 0.4080520453497555, 0.6203397822177972, 0.20439038622342587, 0.5107787826630711, 0.3687687834540144, 0.5550293487073474, 0.4992765476541544, 0.20640007533087235, 0.14880637396971708, 0.20803239802948637, 0.18703660606869665, 0.17376782539909186, 0.18891632483001508, 0.18869498190092404, 0.18029276580029363, 0.18684679433808116, 0.1856919335043553, 0.19938255220059797, 0.1961503405606252, 0.07395902362937468, 0.08001153328666755, 0.08499784317439973, 0.07548991609310818, 0.08297871721164318, 0.09254357161351312, 0.07925739554980482, 0.08504936806691199, 0.0684609197806374]}, "mutation_prompt": null}
{"id": "bf182bba-81f8-48ca-85b1-fc1c9cb923c5", "solution": "import numpy as np\n\nclass SymbioticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.mutation_factor = 0.68  # Adjusted mutation factor\n        self.crossover_rate = 0.80  # Adjusted crossover rate\n        self.local_search_intensity = 5  # Modified intensity\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = 0.15  # Increased step size for diversification\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if self.fitness.mean() < (np.median(self.fitness) + 0.1):  # Adaptive check condition\n            self.local_search_intensity = 7  # Adjusted search intensity\n            self.mutation_factor = 0.72  # Adjusted mutation factor\n            self.crossover_rate = 0.88  # Adjust crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "SymbioticHybridOptimizer", "description": "A hybrid optimizer that fuses differential evolution with stochastic local search and dynamic strategy adaptation for enhanced search efficiency.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2a756749-bbb0-43ca-a798-b159761ff6eb", "metadata": {"aucs": [0.7227616250043754, 0.729486358298918, 0.743514462288939, 0.7557645328427438, 0.741925256343198, 0.7437650219349463, 0.7505833394224459, 0.7539440341898446, 0.7122420710555544, 0.53464717358783, 0.5576205195067518, 0.5283721720707832, 0.5283428689149966, 0.5555510474066152, 0.5340901174288927, 0.4815446178976934, 0.5310825065991884, 0.5213773215432013, 0.11304247460251993, 0.1210443147984952, 0.1346969795356754, 0.12150293521683941, 0.11008201672358031, 0.12019200342156777, 0.12310252139800193, 0.12984650172194978, 0.1168395814964297, 0.11579440044041, 0.10834619518144539, 0.10334908005731791, 0.10661431236559271, 0.10882262661336395, 0.11775260044773928, 0.099555978416073, 0.12497709645823996, 0.10633325310433706, 0.9230206432765862, 0.9088611252901584, 0.9194859575952754, 0.9443389440247087, 0.9217987138666838, 0.9395403317992714, 0.910807192546055, 0.9162082604926769, 0.9439014190717047, 0.3473760576574456, 0.405480002361817, 0.341192514145253, 0.3908206630691491, 0.370663089194576, 0.3545279918139346, 0.3705658139455491, 0.4016877464478684, 0.44556077661020854, 0.734831181903551, 0.5759287910204856, 0.6213375958579661, 0.685963923269066, 0.6848871117751602, 0.6893081756467336, 0.7046337770308129, 0.6213270547400852, 0.642902327065922, 0.24174128163225828, 0.26417340112552945, 0.284743090274706, 0.22468420194278804, 0.24845046528161607, 0.3193265885119442, 0.24379773253945292, 0.26988356179604955, 0.29898504422934913, 0.31045001342792533, 0.30238976191718914, 0.17025006945822097, 0.27308976400531804, 0.30837281229870395, 0.28326961480866175, 0.3202499892126941, 0.2863650444437146, 0.29270115647716766, 0.13799173745381543, 0.12746531030611896, 0.12978813757217034, 0.1751877437706877, 0.11959789962561596, 0.11711992633894952, 0.20272745019835492, 0.16398921352128948, 0.15036168426578278, 0.2534982395562082, 0.24678071917038846, 0.2913607587448914, 0.25846340774129906, 0.23755419709065484, 0.2982742050774754, 0.29177592426521315, 0.2843818068689993, 0.28250309355376335, 0.07505723333927383, 0.053506867761011545, 0.07597462296550384, 0.07230196973984748, 0.10662899391215397, 0.06944369966051378, 0.10128141283116343, 0.09209560461423827, 0.08267184324222143, 0.20291722576330096, 0.18964291628070873, 0.21373524687277645, 0.23485798746785846, 0.23729713719591328, 0.2089489000268966, 0.22230821561781666, 0.21812475686622834, 0.21240597316397547, 0.5863042862432989, 0.558621589105828, 0.5885322046042201, 0.5941176964633599, 0.5716381798014012, 0.5655779539859686, 0.5944256258146254, 0.5689388299425178, 0.6088111952129212, 0.10161972435169697, 0.11272353360905085, 0.11096777056905816, 0.11384791060224964, 0.0996451838684177, 0.11370973698806797, 0.10519150207241745, 0.12053893122387094, 0.1073410736010999, 0.2707073858937914, 0.2065085646154864, 0.23029882633302556, 0.2013557992326771, 0.28531662523071655, 0.24726463631971085, 0.205950591761061, 0.2629863283350009, 0.20755181056646066, 0.31659121871006257, 0.3086827846596081, 0.31951541162079244, 0.3233725331683198, 0.32235716723481933, 0.3013478840150857, 0.33027221648084937, 0.34881653302406346, 0.3268927037489392, 0.24210452884900502, 0.23297198572161149, 0.2349172540500073, 0.24460717494829065, 0.24397442591660023, 0.217059695442412, 0.2343918666355096, 0.251242181430005, 0.24437960915674561, 0.21818113277426776, 0.18699170074642413, 0.1962156282410239, 0.20469469702336673, 0.19708485432723744, 0.2068210452870215, 0.19173737114882683, 0.18474503529044073, 0.2150372213943339, 0.1954109734425088, 0.18703543464950367, 0.22037495224811032, 0.22166042854344448, 0.18630402457935236, 0.19434182658587074, 0.204790034745995, 0.19150180652636528, 0.19589651071302383, 0.6421892882359124, 0.6714442510015733, 0.15159008858564937, 0.6858482333553458, 0.6747281823154089, 0.5879725742995761, 0.4578914622403707, 0.17947993967973108, 0.5526904798765447, 0.6519350233683334, 0.2041895597620953, 0.5253200148581365, 0.19744279882355653, 0.6322961520625812, 0.5454446037106653, 0.20411224175163922, 0.20641441741459288, 0.21047215220235238, 0.17412395838403172, 0.1771634649244388, 0.1743505765930704, 0.18257617206915921, 0.17764230366112188, 0.19693532575371164, 0.1793708087278192, 0.19792841436357078, 0.1944880308050626, 0.08031044936983944, 0.07178744901189205, 0.0752010403618133, 0.08870357238439153, 0.0771047763586139, 0.07431697422395933, 0.07514874069754696, 0.0756745926914979, 0.07694561600086658]}, "mutation_prompt": null}
{"id": "375ee1c9-86e8-4ff5-a0fd-8ecb86067781", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 7 * dim  # Adjusted population size\n        self.mutation_factor = 0.70  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.local_search_intensity = 6  # Modified intensity\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = 0.10  # Adjusted step size for exploration\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < 0.5:  # Adaptive check condition\n            self.local_search_intensity = 8  # Adjusted search intensity\n            self.mutation_factor = 0.75  # Adjusted mutation factor\n            self.crossover_rate = 0.90  # Adjust crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimizer integrating differential evolution and stochastic local search with adaptive mutation and crossover strategies to improve convergence efficiency.", "configspace": "", "generation": 26, "fitness": 0.3511119198366992, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "2a756749-bbb0-43ca-a798-b159761ff6eb", "metadata": {"aucs": [0.7417224805497582, 0.7621892399645676, 0.7419029300715245, 0.7614216800697884, 0.7420140730892851, 0.7689629065859269, 0.7185878384046214, 0.7656673606825695, 0.7428322763120491, 0.5715057200250016, 0.5897849501062298, 0.6147452851432508, 0.5837443051779327, 0.5802746460078869, 0.5723645230156723, 0.5655017437717685, 0.5938325419084717, 0.5963550276211019, 0.12509915767376656, 0.12414022243980893, 0.13388617034801487, 0.12988731222402639, 0.1294305115555071, 0.12385818904081136, 0.13831298319005803, 0.11880351208168538, 0.1236139342170105, 0.11581910925410355, 0.11078935253357014, 0.11159649882143874, 0.12478936003016938, 0.12724136217427207, 0.11936633690802734, 0.10875902606034393, 0.10955418695071673, 0.11993006352438895, 0.9320057501768583, 0.9764594484620941, 0.9721234620569281, 0.9598983859339514, 0.9518231526541678, 0.9418765048939469, 0.9422590744094994, 0.9530292973041243, 0.9219628377429142, 0.4380311673944308, 0.40610532316450776, 0.3858917988608678, 0.4127012238395257, 0.4043875748208422, 0.3719072303440115, 0.44881749886892097, 0.4148774504675221, 0.4091777310612136, 0.6989926975185272, 0.6628081698140493, 0.6781733890373021, 0.6946661503949748, 0.6974570119022583, 0.6971504613740529, 0.7062952888101497, 0.7245594186867199, 0.6914462041395693, 0.33999894137290443, 0.37468380712628546, 0.2802209403379836, 0.26321829019185083, 0.31392977275560874, 0.3328736711228446, 0.3421773923979604, 0.30431920435749515, 0.3295725431127041, 0.2912004259240515, 0.20278885127978796, 0.4039277625175921, 0.33990001386863433, 0.3368373404833125, 0.35659722864724275, 0.36184975662718066, 0.2311300697067974, 0.35503815239986736, 0.23567443547369815, 0.20366922894430362, 0.19883267135625482, 0.2288042301267521, 0.22743159246269173, 0.22632067588817384, 0.2185345699142247, 0.23153546215684306, 0.21224321945030356, 0.35796751100899193, 0.3296910022720666, 0.32737435642592005, 0.3798895963170047, 0.3707244709530937, 0.2898553879079161, 0.4113056943867356, 0.3724590146661353, 0.4020072933009332, 0.08386769014416928, 0.055471601728978914, 0.06666277747425231, 0.10936779052179968, 0.0874874632161391, 0.15500779243699925, 0.08455785850240971, 0.07625100556550224, 0.05692637712234305, 0.22592302389761898, 0.23140627768399813, 0.24093302952700513, 0.2511027210961032, 0.24582921970902938, 0.2532269785379846, 0.22745898764891603, 0.22695078196499063, 0.23156402423743483, 0.6087313995468869, 0.6122079064377057, 0.6302619638407464, 0.5881973919197279, 0.6265180102034633, 0.5721062343414488, 0.6224876917190492, 0.5728215460753024, 0.6370171325846015, 0.12203573978443016, 0.1402502501221643, 0.11170933604587485, 0.14083816694959572, 0.11331119284473334, 0.11134212227271378, 0.11652450035004092, 0.1384954474399488, 0.14513970528415598, 0.2461918832369584, 0.2259626844146697, 0.2463996812953969, 0.29038455016444475, 0.19860434713815367, 0.21605613773158172, 0.24632588194254512, 0.18604931549140735, 0.20090242163078997, 0.3378304050776637, 0.3390425480932492, 0.327333736361045, 0.3304433939487812, 0.32597721205289354, 0.31263735142744087, 0.34729522776821053, 0.3536455334756806, 0.3608674236543533, 0.24702801966699983, 0.24853505582876945, 0.2677990005297254, 0.24310791587084568, 0.23984343277897335, 0.2418405634318529, 0.2620322209897915, 0.2655433872695807, 0.2738563063650824, 0.19444461905675425, 0.1791763126678788, 0.20576581277703998, 0.21593018006649267, 0.19343607772826543, 0.19566578759952657, 0.18830565479651173, 0.20599607856121782, 0.1993040939978703, 0.23683457903009209, 0.2796269504292571, 0.21699712430881923, 0.2269552293598155, 0.22649954288618568, 0.2091485292210027, 0.25528040209347924, 0.26781420872223904, 0.21144956613605181, 0.16389606159975645, 0.567048297989105, 0.17942992071649766, 0.6501166511543026, 0.6129298749096557, 0.7302898120623587, 0.6475754327121479, 0.7340811363816699, 0.7235035376485783, 0.7698967494037222, 0.20646781942567638, 0.6915805455159325, 0.19229001117702005, 0.7231518294249397, 0.2667151144693881, 0.20589874606735326, 0.6787972233459685, 0.2095131918221076, 0.178218048905333, 0.18835513163264195, 0.19525214463111373, 0.1811733832532545, 0.2062145054594693, 0.19280220815792637, 0.17598524346229205, 0.1816126995467099, 0.1811854327681941, 0.07721079168825162, 0.07651473226013716, 0.08790742358563441, 0.08675985924775742, 0.07564120819928155, 0.07716885951667118, 0.0724527668990701, 0.07650022613042051, 0.07812543879184053]}, "mutation_prompt": null}
{"id": "7637153b-2e55-4529-9275-ce6103672b3e", "solution": "import numpy as np\n\nclass MultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.mutation_factor = 0.65  # Adjusted mutation factor\n        self.crossover_rate = 0.80  # Adjusted crossover rate\n        self.local_search_intensity = 7  # Modified intensity\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def adaptive_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.clip(0.1 * (1.0 - self.used_budget / self.budget), 0.01, 0.1)  # Adaptive step size\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < 0.4:  # Adaptive check condition\n            self.local_search_intensity = 9  # Adjusted search intensity\n            self.mutation_factor = 0.70  # Adjusted mutation factor\n            self.crossover_rate = 0.85  # Adjust crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.adaptive_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "MultiStrategyOptimizer", "description": "A multi-strategy optimizer combining differential evolution, adaptive local search, and feedback-driven parameter tuning for enhanced performance across diverse optimization landscapes.", "configspace": "", "generation": 27, "fitness": 0.3312516622202607, "feedback": "The algorithm MultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "375ee1c9-86e8-4ff5-a0fd-8ecb86067781", "metadata": {"aucs": [0.7342268197514565, 0.76056945110172, 0.7503085516446699, 0.7671505619663135, 0.7697546377214886, 0.7687627160476946, 0.7602111519851558, 0.7759809377374833, 0.7342748476014993, 0.5616752241541079, 0.561406400707255, 0.5586444716194884, 0.5569310897612345, 0.5498180005832076, 0.5534912082557318, 0.5300532485208953, 0.5389540923094938, 0.5582557826731263, 0.2079962766565373, 0.13390569276332387, 0.15820650883203902, 0.1308509471538386, 0.1950622434516146, 0.13816565598587582, 0.18342095998549435, 0.14474072306832264, 0.15719028805448, 0.12902140244522908, 0.1220879948209933, 0.11813984775515907, 0.13714453874381127, 0.13297478301547838, 0.14118381784449918, 0.13281184184789907, 0.13360367865087397, 0.13723052134235336, 0.9286505337739844, 0.9258441277130631, 0.9532942988830784, 0.9380342855925681, 0.9206422799951834, 0.93666625407563, 0.9498765362481104, 0.9288428466809696, 0.9570106512024159, 0.37889725424569765, 0.38107784087389496, 0.34253132549075616, 0.39236383446500744, 0.38382271724315975, 0.3507332834823854, 0.36330512307728124, 0.39684316181235246, 0.3932896628401453, 0.6362409975242886, 0.7030730847001432, 0.6448373091925201, 0.6597621041063719, 0.7519511876479814, 0.7322630837657227, 0.6163044086272387, 0.7831705063117792, 0.661304264449088, 0.27807349303574613, 0.2725149260584907, 0.3246769853220586, 0.24981502653239362, 0.24921044266382097, 0.2402818524250684, 0.33134999424992606, 0.2838578193358464, 0.2488555346797383, 0.18314728879069142, 0.22698581111184069, 0.2990026035219038, 0.26187019482512264, 0.2792168510364538, 0.2827580569416349, 0.2607251912658717, 0.24542515151127742, 0.21605091740197135, 0.16101767481761997, 0.12698803405183867, 0.11892334606807142, 0.11949581456768987, 0.1680123751969277, 0.12330901536266514, 0.15851177127088756, 0.18099404587883816, 0.15053837527183678, 0.2945826455286521, 0.252787602483015, 0.2640210487548038, 0.23175315971819588, 0.24503081349065292, 0.278117028206197, 0.28065108952046647, 0.29613997901410405, 0.2558355531954507, 0.026462219811727472, 0.05304126480178495, 0.05858087288877345, 0.11283939484580807, 0.036665039507254416, 0.11043786844548353, 0.03270940797845867, 0.07667482926454394, 0.038131827081546166, 0.17586386181189206, 0.2046662614422058, 0.17932358806677617, 0.21425473206754486, 0.23350853315262055, 0.21727313848169338, 0.18783015979762419, 0.19565159659155285, 0.1691055990017668, 0.5759621323022417, 0.5746825825172418, 0.5790449886935003, 0.5809113047076191, 0.558335695166202, 0.6189177455217281, 0.5588875314834398, 0.5635482391575859, 0.5636837731665345, 0.14379294652664154, 0.11479824860432708, 0.133637955939936, 0.1304461457743712, 0.13863617291014996, 0.14130332916194988, 0.15161596169211755, 0.12182642172080305, 0.11361404069763703, 0.20572361441799225, 0.16992745331357184, 0.2130201669022046, 0.2216852180803136, 0.24137247252037297, 0.2528583850119237, 0.21342752360728712, 0.19686640698720936, 0.2043876741798767, 0.3150990503686383, 0.2987137356710847, 0.32953410685448015, 0.31292686130328207, 0.33393420095190507, 0.30218720983029856, 0.32797046745171976, 0.32739733177309505, 0.34467981730408814, 0.256479338474898, 0.2638383535205989, 0.23122084681155797, 0.23593200500645994, 0.23767032853944503, 0.23365722335177364, 0.2722867934859049, 0.2693544048595159, 0.268960701656629, 0.19267675917299099, 0.20882770354550895, 0.17799785205246677, 0.20312928927310492, 0.19498349596855613, 0.18156991045172355, 0.20291465992615088, 0.188363935048263, 0.19877563648804053, 0.23796051038192623, 0.21121931416268458, 0.20220673916762366, 0.2468995025124313, 0.25487375527940215, 0.2186000524548498, 0.23823071696850517, 0.29556758866445776, 0.3040191536089396, 0.6284035909773897, 0.1782048542585981, 0.5635714599924128, 0.6690170880243345, 0.6671793826797667, 0.6653934055490893, 0.6335384663652497, 0.6089873108316501, 0.19261257280145383, 0.5750251594052507, 0.1909586447711149, 0.47307080762708853, 0.5204185227726879, 0.1918443610365147, 0.4940758654385621, 0.20654125400122658, 0.20608594869583863, 0.7030547539761786, 0.20135504244285451, 0.19883699756217066, 0.19671692817791042, 0.19835492289461631, 0.18877070510796734, 0.1956281702909135, 0.19025522640690673, 0.19751306257602586, 0.1967998978024469, 0.09761996169161591, 0.08810165215123089, 0.08417569827418336, 0.08810383359087204, 0.08859390168346182, 0.09747463549642266, 0.08649838946485511, 0.08786014410847998, 0.09775534881370318]}, "mutation_prompt": null}
{"id": "e2573f7f-ec15-416e-a3b9-39e33f389f36", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 7 * dim  # Adjusted population size\n        self.mutation_factor = 0.70  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.local_search_intensity = 6  # Modified intensity\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = 0.10  # Adjusted step size for exploration\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < 0.5:  # Adaptive check condition\n            self.local_search_intensity = 8  # Adjusted search intensity\n            self.mutation_factor = 0.75  # Adjusted mutation factor\n            self.crossover_rate = 0.90  # Adjust crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimizer integrating differential evolution and stochastic local search with adaptive mutation and crossover strategies to improve convergence efficiency.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "375ee1c9-86e8-4ff5-a0fd-8ecb86067781", "metadata": {"aucs": [0.7417224805497582, 0.7621892399645676, 0.7419029300715245, 0.7614216800697884, 0.7420140730892851, 0.7689629065859269, 0.7185878384046214, 0.7656673606825695, 0.7428322763120491, 0.5715057200250016, 0.5897849501062298, 0.6147452851432508, 0.5837443051779327, 0.5802746460078869, 0.5723645230156723, 0.5655017437717685, 0.5938325419084717, 0.5963550276211019, 0.12509915767376656, 0.12414022243980893, 0.13388617034801487, 0.12988731222402639, 0.1294305115555071, 0.12385818904081136, 0.13831298319005803, 0.11880351208168538, 0.1236139342170105, 0.11581910925410355, 0.11078935253357014, 0.11159649882143874, 0.12478936003016938, 0.12724136217427207, 0.11936633690802734, 0.10875902606034393, 0.10955418695071673, 0.11993006352438895, 0.9320057501768583, 0.9764594484620941, 0.9721234620569281, 0.9598983859339514, 0.9518231526541678, 0.9418765048939469, 0.9422590744094994, 0.9530292973041243, 0.9219628377429142, 0.4380311673944308, 0.40610532316450776, 0.3858917988608678, 0.4127012238395257, 0.4043875748208422, 0.3719072303440115, 0.44881749886892097, 0.4148774504675221, 0.4091777310612136, 0.6989926975185272, 0.6628081698140493, 0.6781733890373021, 0.6946661503949748, 0.6974570119022583, 0.6971504613740529, 0.7062952888101497, 0.7245594186867199, 0.6914462041395693, 0.33999894137290443, 0.37468380712628546, 0.2802209403379836, 0.26321829019185083, 0.31392977275560874, 0.3328736711228446, 0.3421773923979604, 0.30431920435749515, 0.3295725431127041, 0.2912004259240515, 0.20278885127978796, 0.4039277625175921, 0.33990001386863433, 0.3368373404833125, 0.35659722864724275, 0.36184975662718066, 0.2311300697067974, 0.35503815239986736, 0.23567443547369815, 0.20366922894430362, 0.19883267135625482, 0.2288042301267521, 0.22743159246269173, 0.22632067588817384, 0.2185345699142247, 0.23153546215684306, 0.21224321945030356, 0.35796751100899193, 0.3296910022720666, 0.32737435642592005, 0.3798895963170047, 0.3707244709530937, 0.2898553879079161, 0.4113056943867356, 0.3724590146661353, 0.4020072933009332, 0.08386769014416928, 0.055471601728978914, 0.06666277747425231, 0.10936779052179968, 0.0874874632161391, 0.15500779243699925, 0.08455785850240971, 0.07625100556550224, 0.05692637712234305, 0.22592302389761898, 0.23140627768399813, 0.24093302952700513, 0.2511027210961032, 0.24582921970902938, 0.2532269785379846, 0.22745898764891603, 0.22695078196499063, 0.23156402423743483, 0.6087313995468869, 0.6122079064377057, 0.6302619638407464, 0.5881973919197279, 0.6265180102034633, 0.5721062343414488, 0.6224876917190492, 0.5728215460753024, 0.6370171325846015, 0.12203573978443016, 0.1402502501221643, 0.11170933604587485, 0.14083816694959572, 0.11331119284473334, 0.11134212227271378, 0.11652450035004092, 0.1384954474399488, 0.14513970528415598, 0.2461918832369584, 0.2259626844146697, 0.2463996812953969, 0.29038455016444475, 0.19860434713815367, 0.21605613773158172, 0.24632588194254512, 0.18604931549140735, 0.20090242163078997, 0.3378304050776637, 0.3390425480932492, 0.327333736361045, 0.3304433939487812, 0.32597721205289354, 0.31263735142744087, 0.34729522776821053, 0.3536455334756806, 0.3608674236543533, 0.24702801966699983, 0.24853505582876945, 0.2677990005297254, 0.24310791587084568, 0.23984343277897335, 0.2418405634318529, 0.2620322209897915, 0.2655433872695807, 0.2738563063650824, 0.19444461905675425, 0.1791763126678788, 0.20576581277703998, 0.21593018006649267, 0.19343607772826543, 0.19566578759952657, 0.18830565479651173, 0.20599607856121782, 0.1993040939978703, 0.23683457903009209, 0.2796269504292571, 0.21699712430881923, 0.2269552293598155, 0.22649954288618568, 0.2091485292210027, 0.25528040209347924, 0.26781420872223904, 0.21144956613605181, 0.16389606159975645, 0.567048297989105, 0.17942992071649766, 0.6501166511543026, 0.6129298749096557, 0.7302898120623587, 0.6475754327121479, 0.7340811363816699, 0.7235035376485783, 0.7698967494037222, 0.20646781942567638, 0.6915805455159325, 0.19229001117702005, 0.7231518294249397, 0.2667151144693881, 0.20589874606735326, 0.6787972233459685, 0.2095131918221076, 0.178218048905333, 0.18835513163264195, 0.19525214463111373, 0.1811733832532545, 0.2062145054594693, 0.19280220815792637, 0.17598524346229205, 0.1816126995467099, 0.1811854327681941, 0.07721079168825162, 0.07651473226013716, 0.08790742358563441, 0.08675985924775742, 0.07564120819928155, 0.07716885951667118, 0.0724527668990701, 0.07650022613042051, 0.07812543879184053]}, "mutation_prompt": null}
{"id": "cee310c8-9f7a-478a-a3bd-87e65cb5defb", "solution": "import numpy as np\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 6 * dim  # Adjusted population size for diversity\n        self.mutation_factor = 0.65  # Fine-tuned mutation factor for exploration\n        self.crossover_rate = 0.80  # Fine-tuned crossover rate for balanced search\n        self.local_search_intensity = 5  # Modified intensity to conserve budget\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def dynamic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = 0.15  # Adjusted step size for more pronounced exploration\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < 0.4:  # More dynamic adaptive condition\n            self.local_search_intensity = 7  # Fine-tuned search intensity\n            self.mutation_factor = 0.80  # Adjusted mutation factor\n            self.crossover_rate = 0.85  # Adjust crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.dynamic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "RefinedHybridOptimizer", "description": "A refined hybrid optimizer blending differential evolution and dynamic local search with adaptive exploration and exploitation balancing to enhance global convergence.", "configspace": "", "generation": 29, "fitness": 0.35558748572417, "feedback": "The algorithm RefinedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "375ee1c9-86e8-4ff5-a0fd-8ecb86067781", "metadata": {"aucs": [0.7748417194823198, 0.7746233238095694, 0.7867640810408737, 0.7897888931056285, 0.7789036700996214, 0.7962937962262729, 0.7743340268289731, 0.7884990555861421, 0.7880363108663868, 0.6262960936698814, 0.65777168596721, 0.652466888657926, 0.6137586953650216, 0.6304630765211938, 0.6362564508714543, 0.634524933998911, 0.6135651158842819, 0.6588704820841078, 0.12834754865764664, 0.1408235326963655, 0.20091519629258658, 0.14980681699478993, 0.23520012717565963, 0.13064051720018854, 0.1270232007813209, 0.13225552168868493, 0.12130141394843541, 0.13741854835016343, 0.1362595600073957, 0.12384845150223989, 0.13079239808032217, 0.12024117708765514, 0.12123555290337884, 0.12225804354118552, 0.1327421469165263, 0.12914702413990575, 0.9587957867174277, 0.9716325190203333, 0.9507209220900246, 0.9243389220699958, 0.9669334552420794, 0.9479130285156148, 0.9580392637841164, 0.9560218232688094, 0.954188364348795, 0.43941851258940245, 0.4253483935869913, 0.44147588671686655, 0.3907026023657961, 0.4462501964151102, 0.4220042388972899, 0.38768079375986286, 0.4313988161444088, 0.4299255310468135, 0.6948173446144226, 0.6795913469018575, 0.7001145229953691, 0.7247157512795681, 0.7334106147119008, 0.7109971032169797, 0.6737084297496783, 0.6856466799933523, 0.7510762767692907, 0.3107981914824014, 0.24584709473400712, 0.3464411005602477, 0.29889474312994646, 0.3152090805387231, 0.3017172309271384, 0.34290556011469864, 0.335688965577958, 0.29115680819073786, 0.27926623110992266, 0.1252009615342855, 0.3537199970211663, 0.2982234991728384, 0.3445606294226341, 0.32421798841730154, 0.31647559486507926, 0.2590619079871873, 0.3295847612064772, 0.18723826823084433, 0.22198121097316625, 0.1976712427179268, 0.20329556200460575, 0.1972361262177953, 0.19852017239959718, 0.22193167529803282, 0.1871918282624545, 0.20139214909755743, 0.3215791291275977, 0.3079926127766146, 0.36083230056297233, 0.2850185018412803, 0.35348345087302036, 0.2981956982801175, 0.3352687084968079, 0.35227156619197175, 0.3592550975431055, 0.13364298605704739, 0.09176533275163423, 0.07633902048603047, 0.12536164220900503, 0.17582591611072618, 0.1540345072292303, 0.11108696124815487, 0.13830418327918037, 0.06740661527151393, 0.21730160207157, 0.23225347564361287, 0.23491758444191102, 0.25493012420898276, 0.25602889364662507, 0.2407570178957681, 0.1956668060372312, 0.23595048092376092, 0.25436986694970454, 0.580060259693864, 0.5647290996502563, 0.5830841341540587, 0.6032895855355299, 0.5254831416598851, 0.5947698538449325, 0.580237424235321, 0.5670345594554207, 0.5878038367775256, 0.09996011209719213, 0.1159311815259636, 0.12646369314463823, 0.12064330445454274, 0.11976937669688192, 0.13372728490394725, 0.12400607711441225, 0.11642800140443454, 0.1206868869345753, 0.23127372634059729, 0.17626509022428272, 0.20160150920374453, 0.20601502423801943, 0.19426474691211293, 0.20320084673697936, 0.2586790464078883, 0.23294655445985168, 0.2679148599947755, 0.3149575775976413, 0.3416482190655601, 0.3325222121693284, 0.36102999206273056, 0.334158665426888, 0.3247576686516118, 0.3669854456485203, 0.40089353153990004, 0.35273708692960326, 0.2691813283970107, 0.26447062061716875, 0.258184503190823, 0.27670026877333465, 0.2371906138167834, 0.24857892084501587, 0.26995189350963356, 0.2821575417774649, 0.27894678563005637, 0.1889940812567663, 0.21137802066201006, 0.17705410015108303, 0.2128283273502145, 0.21903461599889762, 0.19507646647715415, 0.20963605058793822, 0.18600658686775728, 0.20879479027927128, 0.2289739709099895, 0.21863343982436723, 0.200931101375168, 0.3867166468034994, 0.21312147909868762, 0.21713493767461634, 0.22394964118552907, 0.2123848971545178, 0.2200406549366598, 0.7076089345819161, 0.16234447649316774, 0.7969364496454105, 0.8032169274092885, 0.19914266736303599, 0.6907473193445839, 0.575007230234228, 0.8214077105484869, 0.7567806702380503, 0.7067363621929699, 0.20527630998948276, 0.6556600756447084, 0.5985196047362558, 0.20457940801452001, 0.20656586661348397, 0.2078225685258982, 0.6657690225772142, 0.21054412412653856, 0.18928427510692125, 0.20111141381361985, 0.20505920135152556, 0.2039947089427424, 0.21016615517574522, 0.1738372160526802, 0.19341658893868807, 0.1817659920098582, 0.1857197225474435, 0.07987538520462223, 0.07541707736498215, 0.08251786316169785, 0.08123256356530406, 0.07893672194624757, 0.07941063977325635, 0.08493839543546988, 0.0916821523655752, 0.09340234514795298]}, "mutation_prompt": null}
{"id": "45127cd7-2543-46aa-80cf-38fc2749d684", "solution": "import numpy as np\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Increased population size for enhanced diversity\n        self.mutation_factor = 0.70  # Adjusted mutation factor for better exploration\n        self.crossover_rate = 0.75  # Slightly reduced crossover rate for diversity\n        self.local_search_intensity = 4  # Lowered intensity to save budget\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def dynamic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = 0.10  # Reduced step size for finer local search\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < 0.3:  # Tightened adaptive condition for responsiveness\n            self.local_search_intensity = 6  # Adjusted search intensity\n            self.mutation_factor = 0.75  # Modified mutation factor\n            self.crossover_rate = 0.80  # Adjusted crossover rate\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.dynamic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "RefinedHybridOptimizer", "description": "A refined hybrid optimizer improving exploration and local search balance with adaptive parameter control for robust global and local optimization.", "configspace": "", "generation": 30, "fitness": 0.29743075222480136, "feedback": "The algorithm RefinedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "cee310c8-9f7a-478a-a3bd-87e65cb5defb", "metadata": {"aucs": [0.7390738072096948, 0.7390345898750852, 0.7461272226190584, 0.753712349877334, 0.763813554188006, 0.7556373083428323, 0.7470255458209073, 0.7497856679007866, 0.7322163211129022, 0.5763486029477969, 0.5368305879639448, 0.5945863005346756, 0.5492294512190367, 0.5455503507176251, 0.5450141594962794, 0.5703812054172523, 0.5649274528765615, 0.5546985991235275, 0.13315257429095873, 0.13588324982225497, 0.15088998389702135, 0.1376490524224322, 0.13022982553531814, 0.11964169318917661, 0.139670597887126, 0.12909175340905, 0.14391819026813357, 0.12314339934065133, 0.11691752707562897, 0.11833726174291281, 0.11804475932649638, 0.11185108565562152, 0.1314875562321569, 0.11547764256806148, 0.12593895919302267, 0.12317439185327816, 0.9640284110380788, 0.9618193925328612, 0.9692378348962245, 0.9571368558711204, 0.9589899165136814, 0.9626354632022855, 0.9582511505640616, 0.9681995810700411, 0.9498123311132046, 0.3468264613365579, 0.33314785934729774, 0.32474632960281846, 0.3601653130401282, 0.37342594066615453, 0.335481060434328, 0.3915584050126003, 0.39309964826639976, 0.3197927458249257, 0.5009247367161449, 0.5940233419942043, 0.6107336210605054, 0.6285064386984462, 0.4788129876199684, 0.6112490695590371, 0.5210401066603907, 0.5332773595939191, 0.5244813489925705, 0.23920096682181502, 0.2516047914552155, 0.2037197810487441, 0.24584265944909045, 0.2085932510674363, 0.19902520982716465, 0.2250082819631657, 0.18759799681600176, 0.21460634000836754, 0.18216833744842842, 0.2393207152788821, 0.18023636070346327, 0.2178941256684327, 0.2355416243065025, 0.23039103266850136, 0.18455676932386067, 0.1833330339548246, 0.21589338806194702, 0.08065923028173017, 0.058557562891006776, 0.06810324875198914, 0.05956256357296641, 0.082264855712472, 0.039485487539270614, 0.06929398264804654, 0.053081337520154426, 0.07830591975847345, 0.16734042820128836, 0.18657850489334316, 0.16813932749796456, 0.15963532469752717, 0.176220631500554, 0.17998857424314607, 0.18747177232228673, 0.19860854717439114, 0.20309783803663417, 0.00880074077396198, 0.012062180577423365, 0.019573484460234103, 0.01890902874822753, 0.031052626041138676, 0.015229915103592284, 0.020884716676542125, 0.029318221443575876, 0.037980544060665866, 0.15331147754376884, 0.14125222765324763, 0.15664060191125295, 0.17242811528760327, 0.16889343097889797, 0.17108584968117635, 0.15539560110777328, 0.15481393589764103, 0.15077320577833342, 0.505647615003508, 0.508316837955217, 0.5314920142864032, 0.5324885638245909, 0.5245704682046917, 0.5171490046971509, 0.5134343314439509, 0.5131832551393161, 0.5198109513852569, 0.10896436890648109, 0.12392639137774497, 0.11938718540015492, 0.12167494735822748, 0.1049884293358706, 0.10534498785770496, 0.11891043154514314, 0.10764876036088566, 0.12400067146371418, 0.193204535500764, 0.17398175720216402, 0.26519978051831516, 0.2890089363494107, 0.16785520358731243, 0.20502161207429448, 0.18202560702211568, 0.15910509980928433, 0.24150887483845795, 0.3256783591045773, 0.2928705672941697, 0.3008976445905771, 0.2898194816398735, 0.30334072086826214, 0.31622990629197023, 0.3245534888894145, 0.3358995427270094, 0.3347198369518818, 0.242627595158742, 0.26680189032788537, 0.23239658968477384, 0.22212197672282463, 0.21801985473524388, 0.2183971560712823, 0.247592510648857, 0.2516072442354442, 0.22318596751256203, 0.2211451295981146, 0.17039730815975895, 0.188631187149649, 0.18775536950333416, 0.19339811150138775, 0.21187768639856674, 0.19082874879394385, 0.19861117565079067, 0.196356669448026, 0.19482894047857602, 0.21678237665070121, 0.20292386443763322, 0.2377071902111143, 0.2452219923026242, 0.2055629934438009, 0.20554035694607697, 0.22054403010863044, 0.2080280318350689, 0.15457017933348416, 0.19798440199570122, 0.551976611530314, 0.6999449925372325, 0.6650045193992358, 0.5504683631763021, 0.4609708753388325, 0.5043628094610404, 0.19698375893849795, 0.49313965774754953, 0.20141884260875342, 0.4917423063825739, 0.5280247703862518, 0.20157747106593749, 0.5108719041951126, 0.2086033383242848, 0.20777572946003708, 0.20414417814062602, 0.1916833590795567, 0.1803157198286357, 0.1825340240294403, 0.1797928581365793, 0.2013300798185772, 0.18733816955446037, 0.20342768489517338, 0.1798064259572948, 0.18090049859177493, 0.09534351547731679, 0.08808746492556618, 0.08579260908131858, 0.07620509811555953, 0.07677681216990151, 0.07216618164068911, 0.07512632356591298, 0.07482188395769696, 0.08404494416788111]}, "mutation_prompt": null}
{"id": "a10508d6-768c-493e-beb1-661e4bff6439", "solution": "import numpy as np\n\nclass ImprovedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Slightly reduced for efficiency\n        self.mutation_factor = 0.75  # Adjusted for better exploration-exploitation balance\n        self.crossover_rate = 0.85  # Enhanced crossover rate for increased diversity\n        self.local_search_intensity = 4  # Reduced to allocate more budget to global search\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.1, 0.2)  # Introduce randomness in step size\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < 0.35:  # More dynamic adaptive condition\n            self.local_search_intensity = 6  # Increase for finer local search\n            self.mutation_factor = 0.85  # Higher mutation for exploration\n            self.crossover_rate = 0.90  # Further diversify search\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "ImprovedHybridOptimizer", "description": "An improved hybrid optimizer combining adaptive differential evolution and stochastic local search with enhanced parameter tuning for robust global optimization.", "configspace": "", "generation": 31, "fitness": 0.38395398581291573, "feedback": "The algorithm ImprovedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "cee310c8-9f7a-478a-a3bd-87e65cb5defb", "metadata": {"aucs": [0.7728839220766364, 0.7903218954838191, 0.7774257783180348, 0.8081664528138882, 0.7967812631125938, 0.8085815059511392, 0.7973487338562864, 0.7927955303496306, 0.8148148818856937, 0.6164093550893213, 0.6040597552182008, 0.6667857941066202, 0.6576209176832106, 0.6389170586908309, 0.5910934506096239, 0.6626277608532753, 0.6337684835582622, 0.6553386249859771, 0.17288328745295056, 0.20808241090747825, 0.17015803685840825, 0.11763654316875816, 0.1330401890497206, 0.12932732773097344, 0.13097193223609227, 0.13196364801204108, 0.11646074264783801, 0.11000569148222361, 0.12520014816073832, 0.1235275548226642, 0.13008430091199574, 0.20589067025093732, 0.11798829360181551, 0.11368168262947798, 0.14815871587395846, 0.11932271521532767, 0.9774196981278354, 0.9714465645676384, 0.9460512239689127, 0.9565083866677249, 0.9744231344702419, 0.9535874655774542, 0.9495114066855159, 0.9897052090931172, 0.9533243764006611, 0.4568981674617286, 0.44598299411540465, 0.44535089104166914, 0.4228881676637051, 0.47744294594815795, 0.4354262182927898, 0.5200988039706261, 0.4397558853714314, 0.5146025155145247, 0.7359937729315971, 0.8228130557049642, 0.6084484762034779, 0.7562287128108203, 0.7989353530005198, 0.8072713103967796, 0.7484583004820606, 0.781595560903916, 0.7861110471648194, 0.4105368230943144, 0.41987056366062747, 0.4394164242884122, 0.36695237225637123, 0.3553971319963857, 0.3899354218071275, 0.4047725238506059, 0.39911942259490074, 0.3427372600372368, 0.4254987276536175, 0.27912661321957144, 0.34225738742016387, 0.3829072992820456, 0.46137232108687454, 0.4001592829401034, 0.34112459689035923, 0.41780977549033493, 0.3899678119801301, 0.2849051148891467, 0.34468310224243226, 0.26508797606490364, 0.2709474625350292, 0.3019413303244197, 0.2970153831258797, 0.34505136304810313, 0.3123362890644956, 0.3318271885232055, 0.36363486469012185, 0.3807538867449318, 0.4365677711881334, 0.44623261579940665, 0.4006840399774706, 0.36345847558664335, 0.4895956648799975, 0.41677126737655856, 0.4200906464562235, 0.15543204707554326, 0.09718047706915967, 0.06038004402059183, 0.183970711228448, 0.20168544781478281, 0.1662804419782693, 0.16741362918285774, 0.07347373277841962, 0.20191551734454194, 0.2603058756394906, 0.2737298990243372, 0.26675521006586866, 0.2855740648528694, 0.29590355481615704, 0.25862782202464407, 0.25890479881583284, 0.2647089395938157, 0.28995300233957366, 0.6155299376727199, 0.6233459939701389, 0.6644633360951393, 0.6450357145160103, 0.6096870934695409, 0.5979741230702502, 0.6504004884566364, 0.6441897947774888, 0.627735744440357, 0.09260356237111156, 0.1220473413649743, 0.11303641020370436, 0.1231134008855701, 0.10454494288972982, 0.10238580126581309, 0.10568466825930956, 0.1226223873184692, 0.10198550488260172, 0.269033798816288, 0.26752556693337814, 0.25755476794014975, 0.28762412384219727, 0.30062917572053893, 0.19895753393872406, 0.3722233173956544, 0.2389857860131872, 0.2582395778861959, 0.37525421462714936, 0.33728790461961733, 0.35087684309558265, 0.3156050897000585, 0.33634481169127095, 0.32168998239519375, 0.35719211088838587, 0.3855202050906146, 0.3781610492687377, 0.25748159331370335, 0.2855401462879569, 0.27376664536425976, 0.23213797238661438, 0.26625891708006943, 0.21739911247700516, 0.2773864965594912, 0.2674149425904616, 0.27176895769769094, 0.18444350287163136, 0.19330675001859976, 0.23226537112819656, 0.23079188205305856, 0.19701142770385638, 0.2089626042223175, 0.19487541860922686, 0.2097541562360049, 0.1876387350089802, 0.2637550914129655, 0.34439344992835663, 0.2486008291038635, 0.29702776498205075, 0.19181868283900771, 0.28196188516283094, 0.2845681428987936, 0.25129734084689903, 0.23675901979473535, 0.7283485955862972, 0.745707782576312, 0.19879058184431053, 0.8166705278146893, 0.196344330086907, 0.7528804212628808, 0.1825484030218869, 0.20474812012466126, 0.5571083221680155, 0.7554364268713744, 0.7612976942427282, 0.7358619867986286, 0.20511780836904558, 0.16332407792903814, 0.7046204094779585, 0.20740608544920258, 0.7878309399745, 0.6914072230713177, 0.1818992970987119, 0.17609833048414925, 0.1788409282847826, 0.19757382437074944, 0.19238811140682, 0.18211709140062504, 0.17876699371513483, 0.21046938588389674, 0.1908237324467602, 0.0846019011609449, 0.0809414794218345, 0.07465439805753127, 0.08504304386129935, 0.08028018842244777, 0.08026954754965776, 0.0804713510903684, 0.06720610452927378, 0.08354042745791179]}, "mutation_prompt": null}
{"id": "a0e193c8-da64-496a-b926-a731c34e4703", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 6 * dim  # Increased for robustness\n        self.mutation_factor = 0.8  # Fine-tuned for balance\n        self.crossover_rate = 0.9  # Higher rate for increased diversity\n        self.local_search_intensity = 3  # Slightly reduced for more global exploration\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.15)  # Lowered range for finer adjustment\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < 0.3:  # More sensitive adaptive condition\n            self.local_search_intensity = 4  # Adjusted for balance\n            self.mutation_factor = 0.9  # Increased for improved exploration\n            self.crossover_rate = 0.92  # Further enhance search diversity\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedAdaptiveHybridOptimizer", "description": "Enhanced Adaptive Hybrid Optimizer with dynamic parameter scaling to improve exploration and exploitation trade-offs in optimization.", "configspace": "", "generation": 32, "fitness": 0.35363838654373275, "feedback": "The algorithm EnhancedAdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.23.", "error": "", "parent_id": "a10508d6-768c-493e-beb1-661e4bff6439", "metadata": {"aucs": [0.6820487599962849, 0.7274630279523224, 0.7432941286298591, 0.7391187973538127, 0.7265200797732823, 0.72449274409078, 0.7392423392204373, 0.7492292451585503, 0.7484254894688218, 0.5753032537624179, 0.5031781799490287, 0.532752409309175, 0.5450072433093782, 0.532035079078694, 0.5379556883526518, 0.5390816663658393, 0.5549392197366748, 0.5403846106056993, 0.1373448941992721, 0.1464022867023781, 0.13574893161289603, 0.16419846911006042, 0.11573778201350393, 0.1640816080793095, 0.12763075620900832, 0.12939524118987356, 0.14059011231463314, 0.11869681505922725, 0.11949432269188032, 0.11132865973396888, 0.13434879178625436, 0.1362940725713675, 0.12720971817903992, 0.10631402005118484, 0.11195403301077134, 0.11165702858190452, 0.9711970152448459, 0.9368845680317476, 0.9753026738770102, 0.9504662274684456, 0.9692464739384629, 0.9432561738969104, 0.9416319629943556, 0.9791858073676256, 0.9637101635657446, 0.4250952397273817, 0.36946956310504375, 0.39580235332892666, 0.3820909386269047, 0.37383459536042685, 0.3800810533193587, 0.3895132604113123, 0.40040648815928337, 0.4187812013164812, 0.6894016881043712, 0.7043391816606651, 0.8058140763966085, 0.6707811329819852, 0.6913160079507987, 0.7185979694470865, 0.7125706360421484, 0.6819416184669211, 0.6119203610942952, 0.3518012715807598, 0.39996831736274974, 0.2904517310326715, 0.3567074707723493, 0.31521744842297794, 0.300825924435837, 0.3355094987767038, 0.38066066090882533, 0.35843943324387284, 0.39101317662373813, 0.24631878662293205, 0.22497120523159686, 0.3584262081285806, 0.36765361587877765, 0.3220940359959532, 0.28431012580185344, 0.34160072021958576, 0.32786584356862936, 0.27766758125041346, 0.3052327797230351, 0.24858913582355546, 0.3127243062341821, 0.2727013013997659, 0.2652351948334434, 0.2546920761701579, 0.2532566941663976, 0.3044661892657238, 0.4012248294874732, 0.3347718458013743, 0.3765307643283343, 0.3888326954858107, 0.37056057809984977, 0.38242848811795693, 0.3946900830657438, 0.4564294634719608, 0.44156039959841487, 0.09295159749020787, 0.11230434031024594, 0.10648303478524723, 0.1381274666286385, 0.21839674775592155, 0.10350810310220748, 0.13464828344544144, 0.18596004539811994, 0.12457927456546314, 0.23990088652805552, 0.25689553911094176, 0.25259706873536625, 0.25490194969537283, 0.265942893760273, 0.2616182876010875, 0.24753805419632458, 0.25623416257685705, 0.25439940477576517, 0.5730183114581104, 0.5463323938128766, 0.5721820301094864, 0.5766784831022903, 0.5694379476120204, 0.6008554328801083, 0.570806052621138, 0.5651923193206896, 0.5836674889013469, 0.12760681041339594, 0.14034499202372752, 0.10150042914961088, 0.12297921426184044, 0.12648627571675353, 0.12958408894554707, 0.11693383911182975, 0.12346516276199604, 0.12230356328308767, 0.19908162449174638, 0.25050435061488274, 0.18117968903055492, 0.27307125722064407, 0.2504106947251561, 0.24623816272438837, 0.22423797245515675, 0.23899293320015813, 0.1878467358813044, 0.31190423679786905, 0.3413621370875105, 0.309666412249611, 0.3094375693145789, 0.28771576727732495, 0.3293245243998367, 0.32573804892931957, 0.3293143802618479, 0.31910006048756245, 0.2657267875611595, 0.2405026079204533, 0.25051793517104337, 0.2611936927001136, 0.2631906888604745, 0.26900085008556585, 0.2506165046729498, 0.26688606945558546, 0.26529122468387345, 0.21158622393745308, 0.18446758985533518, 0.19444940772398833, 0.17569336233749477, 0.22144140286315306, 0.17980358203235847, 0.20549952538803729, 0.19262076052392163, 0.20464672885215818, 0.21995933915216315, 0.19950101146079302, 0.20260495304225656, 0.25969349978388745, 0.20118595007523377, 0.21070034323968734, 0.2594822146174842, 0.22658908861129068, 0.35111222547754173, 0.737406536170103, 0.18990631970032035, 0.6601377137179307, 0.801815240288493, 0.19633025051691888, 0.19208293768222007, 0.5593910762231415, 0.6914603111378639, 0.6154833163482062, 0.6225734581135028, 0.20370970919880393, 0.6129978571309304, 0.6825616371792351, 0.6376949744274321, 0.2010018302325175, 0.20668975269130785, 0.7381762237150761, 0.21197044878239668, 0.1991185466765828, 0.18380425303823034, 0.17471294711797358, 0.19173215898944895, 0.21682707732095152, 0.21357225757592113, 0.1939251457677197, 0.18831259078042872, 0.18997456201944019, 0.07637968625744584, 0.08855088122169086, 0.08498353793524294, 0.0775060956159026, 0.07621057308247492, 0.07223624655037675, 0.08517452846576057, 0.07848368929646132, 0.08057720126814061]}, "mutation_prompt": null}
{"id": "4b7185ab-6356-4f9e-8755-72ee101300aa", "solution": "import numpy as np\n\nclass ImprovedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Slightly reduced for efficiency\n        self.mutation_factor = 0.75  # Adjusted for better exploration-exploitation balance\n        self.crossover_rate = 0.85  # Enhanced crossover rate for increased diversity\n        self.local_search_intensity = 4  # Reduced to allocate more budget to global search\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.1, 0.2)  # Introduce randomness in step size\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < 0.35:  # More dynamic adaptive condition\n            self.local_search_intensity = 6  # Increase for finer local search\n            self.mutation_factor = 0.85  # Higher mutation for exploration\n            self.crossover_rate = 0.90  # Further diversify search\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "ImprovedHybridOptimizer", "description": "An improved hybrid optimizer combining adaptive differential evolution and stochastic local search with enhanced parameter tuning for robust global optimization.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a10508d6-768c-493e-beb1-661e4bff6439", "metadata": {"aucs": [0.7728839220766364, 0.7903218954838191, 0.7774257783180348, 0.8081664528138882, 0.7967812631125938, 0.8085815059511392, 0.7973487338562864, 0.7927955303496306, 0.8148148818856937, 0.6164093550893213, 0.6040597552182008, 0.6667857941066202, 0.6576209176832106, 0.6389170586908309, 0.5910934506096239, 0.6626277608532753, 0.6337684835582622, 0.6553386249859771, 0.17288328745295056, 0.20808241090747825, 0.17015803685840825, 0.11763654316875816, 0.1330401890497206, 0.12932732773097344, 0.13097193223609227, 0.13196364801204108, 0.11646074264783801, 0.11000569148222361, 0.12520014816073832, 0.1235275548226642, 0.13008430091199574, 0.20589067025093732, 0.11798829360181551, 0.11368168262947798, 0.14815871587395846, 0.11932271521532767, 0.9774196981278354, 0.9714465645676384, 0.9460512239689127, 0.9565083866677249, 0.9744231344702419, 0.9535874655774542, 0.9495114066855159, 0.9897052090931172, 0.9533243764006611, 0.4568981674617286, 0.44598299411540465, 0.44535089104166914, 0.4228881676637051, 0.47744294594815795, 0.4354262182927898, 0.5200988039706261, 0.4397558853714314, 0.5146025155145247, 0.7359937729315971, 0.8228130557049642, 0.6084484762034779, 0.7562287128108203, 0.7989353530005198, 0.8072713103967796, 0.7484583004820606, 0.781595560903916, 0.7861110471648194, 0.4105368230943144, 0.41987056366062747, 0.4394164242884122, 0.36695237225637123, 0.3553971319963857, 0.3899354218071275, 0.4047725238506059, 0.39911942259490074, 0.3427372600372368, 0.4254987276536175, 0.27912661321957144, 0.34225738742016387, 0.3829072992820456, 0.46137232108687454, 0.4001592829401034, 0.34112459689035923, 0.41780977549033493, 0.3899678119801301, 0.2849051148891467, 0.34468310224243226, 0.26508797606490364, 0.2709474625350292, 0.3019413303244197, 0.2970153831258797, 0.34505136304810313, 0.3123362890644956, 0.3318271885232055, 0.36363486469012185, 0.3807538867449318, 0.4365677711881334, 0.44623261579940665, 0.4006840399774706, 0.36345847558664335, 0.4895956648799975, 0.41677126737655856, 0.4200906464562235, 0.15543204707554326, 0.09718047706915967, 0.06038004402059183, 0.183970711228448, 0.20168544781478281, 0.1662804419782693, 0.16741362918285774, 0.07347373277841962, 0.20191551734454194, 0.2603058756394906, 0.2737298990243372, 0.26675521006586866, 0.2855740648528694, 0.29590355481615704, 0.25862782202464407, 0.25890479881583284, 0.2647089395938157, 0.28995300233957366, 0.6155299376727199, 0.6233459939701389, 0.6644633360951393, 0.6450357145160103, 0.6096870934695409, 0.5979741230702502, 0.6504004884566364, 0.6441897947774888, 0.627735744440357, 0.09260356237111156, 0.1220473413649743, 0.11303641020370436, 0.1231134008855701, 0.10454494288972982, 0.10238580126581309, 0.10568466825930956, 0.1226223873184692, 0.10198550488260172, 0.269033798816288, 0.26752556693337814, 0.25755476794014975, 0.28762412384219727, 0.30062917572053893, 0.19895753393872406, 0.3722233173956544, 0.2389857860131872, 0.2582395778861959, 0.37525421462714936, 0.33728790461961733, 0.35087684309558265, 0.3156050897000585, 0.33634481169127095, 0.32168998239519375, 0.35719211088838587, 0.3855202050906146, 0.3781610492687377, 0.25748159331370335, 0.2855401462879569, 0.27376664536425976, 0.23213797238661438, 0.26625891708006943, 0.21739911247700516, 0.2773864965594912, 0.2674149425904616, 0.27176895769769094, 0.18444350287163136, 0.19330675001859976, 0.23226537112819656, 0.23079188205305856, 0.19701142770385638, 0.2089626042223175, 0.19487541860922686, 0.2097541562360049, 0.1876387350089802, 0.2637550914129655, 0.34439344992835663, 0.2486008291038635, 0.29702776498205075, 0.19181868283900771, 0.28196188516283094, 0.2845681428987936, 0.25129734084689903, 0.23675901979473535, 0.7283485955862972, 0.745707782576312, 0.19879058184431053, 0.8166705278146893, 0.196344330086907, 0.7528804212628808, 0.1825484030218869, 0.20474812012466126, 0.5571083221680155, 0.7554364268713744, 0.7612976942427282, 0.7358619867986286, 0.20511780836904558, 0.16332407792903814, 0.7046204094779585, 0.20740608544920258, 0.7878309399745, 0.6914072230713177, 0.1818992970987119, 0.17609833048414925, 0.1788409282847826, 0.19757382437074944, 0.19238811140682, 0.18211709140062504, 0.17876699371513483, 0.21046938588389674, 0.1908237324467602, 0.0846019011609449, 0.0809414794218345, 0.07465439805753127, 0.08504304386129935, 0.08028018842244777, 0.08026954754965776, 0.0804713510903684, 0.06720610452927378, 0.08354042745791179]}, "mutation_prompt": null}
{"id": "8c24b775-6153-4138-8e17-058d070d9913", "solution": "import numpy as np\n\nclass ImprovedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Slightly reduced for efficiency\n        self.mutation_factor = 0.75  # Adjusted for better exploration-exploitation balance\n        self.crossover_rate = 0.85  # Enhanced crossover rate for increased diversity\n        self.local_search_intensity = 4  # Reduced to allocate more budget to global search\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.1, 0.2)  # Introduce randomness in step size\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < 0.35:  # More dynamic adaptive condition\n            self.local_search_intensity = 6  # Increase for finer local search\n            self.mutation_factor = 0.85  # Higher mutation for exploration\n            self.crossover_rate = 0.90  # Further diversify search\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "ImprovedHybridOptimizer", "description": "An improved hybrid optimizer combining adaptive differential evolution and stochastic local search with enhanced parameter tuning for robust global optimization.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a10508d6-768c-493e-beb1-661e4bff6439", "metadata": {"aucs": [0.7728839220766364, 0.7903218954838191, 0.7774257783180348, 0.8081664528138882, 0.7967812631125938, 0.8085815059511392, 0.7973487338562864, 0.7927955303496306, 0.8148148818856937, 0.6164093550893213, 0.6040597552182008, 0.6667857941066202, 0.6576209176832106, 0.6389170586908309, 0.5910934506096239, 0.6626277608532753, 0.6337684835582622, 0.6553386249859771, 0.17288328745295056, 0.20808241090747825, 0.17015803685840825, 0.11763654316875816, 0.1330401890497206, 0.12932732773097344, 0.13097193223609227, 0.13196364801204108, 0.11646074264783801, 0.11000569148222361, 0.12520014816073832, 0.1235275548226642, 0.13008430091199574, 0.20589067025093732, 0.11798829360181551, 0.11368168262947798, 0.14815871587395846, 0.11932271521532767, 0.9774196981278354, 0.9714465645676384, 0.9460512239689127, 0.9565083866677249, 0.9744231344702419, 0.9535874655774542, 0.9495114066855159, 0.9897052090931172, 0.9533243764006611, 0.4568981674617286, 0.44598299411540465, 0.44535089104166914, 0.4228881676637051, 0.47744294594815795, 0.4354262182927898, 0.5200988039706261, 0.4397558853714314, 0.5146025155145247, 0.7359937729315971, 0.8228130557049642, 0.6084484762034779, 0.7562287128108203, 0.7989353530005198, 0.8072713103967796, 0.7484583004820606, 0.781595560903916, 0.7861110471648194, 0.4105368230943144, 0.41987056366062747, 0.4394164242884122, 0.36695237225637123, 0.3553971319963857, 0.3899354218071275, 0.4047725238506059, 0.39911942259490074, 0.3427372600372368, 0.4254987276536175, 0.27912661321957144, 0.34225738742016387, 0.3829072992820456, 0.46137232108687454, 0.4001592829401034, 0.34112459689035923, 0.41780977549033493, 0.3899678119801301, 0.2849051148891467, 0.34468310224243226, 0.26508797606490364, 0.2709474625350292, 0.3019413303244197, 0.2970153831258797, 0.34505136304810313, 0.3123362890644956, 0.3318271885232055, 0.36363486469012185, 0.3807538867449318, 0.4365677711881334, 0.44623261579940665, 0.4006840399774706, 0.36345847558664335, 0.4895956648799975, 0.41677126737655856, 0.4200906464562235, 0.15543204707554326, 0.09718047706915967, 0.06038004402059183, 0.183970711228448, 0.20168544781478281, 0.1662804419782693, 0.16741362918285774, 0.07347373277841962, 0.20191551734454194, 0.2603058756394906, 0.2737298990243372, 0.26675521006586866, 0.2855740648528694, 0.29590355481615704, 0.25862782202464407, 0.25890479881583284, 0.2647089395938157, 0.28995300233957366, 0.6155299376727199, 0.6233459939701389, 0.6644633360951393, 0.6450357145160103, 0.6096870934695409, 0.5979741230702502, 0.6504004884566364, 0.6441897947774888, 0.627735744440357, 0.09260356237111156, 0.1220473413649743, 0.11303641020370436, 0.1231134008855701, 0.10454494288972982, 0.10238580126581309, 0.10568466825930956, 0.1226223873184692, 0.10198550488260172, 0.269033798816288, 0.26752556693337814, 0.25755476794014975, 0.28762412384219727, 0.30062917572053893, 0.19895753393872406, 0.3722233173956544, 0.2389857860131872, 0.2582395778861959, 0.37525421462714936, 0.33728790461961733, 0.35087684309558265, 0.3156050897000585, 0.33634481169127095, 0.32168998239519375, 0.35719211088838587, 0.3855202050906146, 0.3781610492687377, 0.25748159331370335, 0.2855401462879569, 0.27376664536425976, 0.23213797238661438, 0.26625891708006943, 0.21739911247700516, 0.2773864965594912, 0.2674149425904616, 0.27176895769769094, 0.18444350287163136, 0.19330675001859976, 0.23226537112819656, 0.23079188205305856, 0.19701142770385638, 0.2089626042223175, 0.19487541860922686, 0.2097541562360049, 0.1876387350089802, 0.2637550914129655, 0.34439344992835663, 0.2486008291038635, 0.29702776498205075, 0.19181868283900771, 0.28196188516283094, 0.2845681428987936, 0.25129734084689903, 0.23675901979473535, 0.7283485955862972, 0.745707782576312, 0.19879058184431053, 0.8166705278146893, 0.196344330086907, 0.7528804212628808, 0.1825484030218869, 0.20474812012466126, 0.5571083221680155, 0.7554364268713744, 0.7612976942427282, 0.7358619867986286, 0.20511780836904558, 0.16332407792903814, 0.7046204094779585, 0.20740608544920258, 0.7878309399745, 0.6914072230713177, 0.1818992970987119, 0.17609833048414925, 0.1788409282847826, 0.19757382437074944, 0.19238811140682, 0.18211709140062504, 0.17876699371513483, 0.21046938588389674, 0.1908237324467602, 0.0846019011609449, 0.0809414794218345, 0.07465439805753127, 0.08504304386129935, 0.08028018842244777, 0.08026954754965776, 0.0804713510903684, 0.06720610452927378, 0.08354042745791179]}, "mutation_prompt": null}
{"id": "3c61a74c-0f05-4c83-bb53-2e948546fec8", "solution": "import numpy as np\n\nclass ImprovedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Slightly reduced for efficiency\n        self.mutation_factor = 0.75  # Adjusted for better exploration-exploitation balance\n        self.crossover_rate = 0.85  # Enhanced crossover rate for increased diversity\n        self.local_search_intensity = 4  # Reduced to allocate more budget to global search\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.1, 0.2)  # Introduce randomness in step size\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < 0.35:  # More dynamic adaptive condition\n            self.local_search_intensity = 6  # Increase for finer local search\n            self.mutation_factor = 0.85  # Higher mutation for exploration\n            self.crossover_rate = 0.90  # Further diversify search\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "ImprovedHybridOptimizer", "description": "An improved hybrid optimizer combining adaptive differential evolution and stochastic local search with enhanced parameter tuning for robust global optimization.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a10508d6-768c-493e-beb1-661e4bff6439", "metadata": {"aucs": [0.7728839220766364, 0.7903218954838191, 0.7774257783180348, 0.8081664528138882, 0.7967812631125938, 0.8085815059511392, 0.7973487338562864, 0.7927955303496306, 0.8148148818856937, 0.6164093550893213, 0.6040597552182008, 0.6667857941066202, 0.6576209176832106, 0.6389170586908309, 0.5910934506096239, 0.6626277608532753, 0.6337684835582622, 0.6553386249859771, 0.17288328745295056, 0.20808241090747825, 0.17015803685840825, 0.11763654316875816, 0.1330401890497206, 0.12932732773097344, 0.13097193223609227, 0.13196364801204108, 0.11646074264783801, 0.11000569148222361, 0.12520014816073832, 0.1235275548226642, 0.13008430091199574, 0.20589067025093732, 0.11798829360181551, 0.11368168262947798, 0.14815871587395846, 0.11932271521532767, 0.9774196981278354, 0.9714465645676384, 0.9460512239689127, 0.9565083866677249, 0.9744231344702419, 0.9535874655774542, 0.9495114066855159, 0.9897052090931172, 0.9533243764006611, 0.4568981674617286, 0.44598299411540465, 0.44535089104166914, 0.4228881676637051, 0.47744294594815795, 0.4354262182927898, 0.5200988039706261, 0.4397558853714314, 0.5146025155145247, 0.7359937729315971, 0.8228130557049642, 0.6084484762034779, 0.7562287128108203, 0.7989353530005198, 0.8072713103967796, 0.7484583004820606, 0.781595560903916, 0.7861110471648194, 0.4105368230943144, 0.41987056366062747, 0.4394164242884122, 0.36695237225637123, 0.3553971319963857, 0.3899354218071275, 0.4047725238506059, 0.39911942259490074, 0.3427372600372368, 0.4254987276536175, 0.27912661321957144, 0.34225738742016387, 0.3829072992820456, 0.46137232108687454, 0.4001592829401034, 0.34112459689035923, 0.41780977549033493, 0.3899678119801301, 0.2849051148891467, 0.34468310224243226, 0.26508797606490364, 0.2709474625350292, 0.3019413303244197, 0.2970153831258797, 0.34505136304810313, 0.3123362890644956, 0.3318271885232055, 0.36363486469012185, 0.3807538867449318, 0.4365677711881334, 0.44623261579940665, 0.4006840399774706, 0.36345847558664335, 0.4895956648799975, 0.41677126737655856, 0.4200906464562235, 0.15543204707554326, 0.09718047706915967, 0.06038004402059183, 0.183970711228448, 0.20168544781478281, 0.1662804419782693, 0.16741362918285774, 0.07347373277841962, 0.20191551734454194, 0.2603058756394906, 0.2737298990243372, 0.26675521006586866, 0.2855740648528694, 0.29590355481615704, 0.25862782202464407, 0.25890479881583284, 0.2647089395938157, 0.28995300233957366, 0.6155299376727199, 0.6233459939701389, 0.6644633360951393, 0.6450357145160103, 0.6096870934695409, 0.5979741230702502, 0.6504004884566364, 0.6441897947774888, 0.627735744440357, 0.09260356237111156, 0.1220473413649743, 0.11303641020370436, 0.1231134008855701, 0.10454494288972982, 0.10238580126581309, 0.10568466825930956, 0.1226223873184692, 0.10198550488260172, 0.269033798816288, 0.26752556693337814, 0.25755476794014975, 0.28762412384219727, 0.30062917572053893, 0.19895753393872406, 0.3722233173956544, 0.2389857860131872, 0.2582395778861959, 0.37525421462714936, 0.33728790461961733, 0.35087684309558265, 0.3156050897000585, 0.33634481169127095, 0.32168998239519375, 0.35719211088838587, 0.3855202050906146, 0.3781610492687377, 0.25748159331370335, 0.2855401462879569, 0.27376664536425976, 0.23213797238661438, 0.26625891708006943, 0.21739911247700516, 0.2773864965594912, 0.2674149425904616, 0.27176895769769094, 0.18444350287163136, 0.19330675001859976, 0.23226537112819656, 0.23079188205305856, 0.19701142770385638, 0.2089626042223175, 0.19487541860922686, 0.2097541562360049, 0.1876387350089802, 0.2637550914129655, 0.34439344992835663, 0.2486008291038635, 0.29702776498205075, 0.19181868283900771, 0.28196188516283094, 0.2845681428987936, 0.25129734084689903, 0.23675901979473535, 0.7283485955862972, 0.745707782576312, 0.19879058184431053, 0.8166705278146893, 0.196344330086907, 0.7528804212628808, 0.1825484030218869, 0.20474812012466126, 0.5571083221680155, 0.7554364268713744, 0.7612976942427282, 0.7358619867986286, 0.20511780836904558, 0.16332407792903814, 0.7046204094779585, 0.20740608544920258, 0.7878309399745, 0.6914072230713177, 0.1818992970987119, 0.17609833048414925, 0.1788409282847826, 0.19757382437074944, 0.19238811140682, 0.18211709140062504, 0.17876699371513483, 0.21046938588389674, 0.1908237324467602, 0.0846019011609449, 0.0809414794218345, 0.07465439805753127, 0.08504304386129935, 0.08028018842244777, 0.08026954754965776, 0.0804713510903684, 0.06720610452927378, 0.08354042745791179]}, "mutation_prompt": null}
{"id": "8633c71e-982c-4781-8883-58e25b27b6a4", "solution": "import numpy as np\n\nclass ChaoticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim\n        self.mutation_factor = 0.70  # Slight tweak for exploration-exploitation trade-off\n        self.crossover_rate = 0.80  # Reduced to control diversity better\n        self.local_search_intensity = 5  # Rebalanced for local enhancement\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n        self.chaotic_sequence = self.chaotic_map_sequence(self.budget, 0.7)\n\n    def chaotic_map_sequence(self, length, init_value):\n        x = init_value\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)  # Logistic map for chaos\n            sequence.append(x)\n        return sequence\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            chaos_idx = self.used_budget % len(self.chaotic_sequence)\n            chaos_factor = self.chaotic_sequence[chaos_idx]\n            mutant_vector = np.clip(a + chaos_factor * self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.15)  # Narrower perturbation for local refinement\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < 0.3:  # Adjusted threshold for parameter adaptation\n            self.local_search_intensity = 7  # Further increase local search focus\n            self.mutation_factor = 0.80  # Tweak mutation for exploration\n            self.crossover_rate = 0.85  # Further manage exploration-exploitation\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "ChaoticHybridOptimizer", "description": "A novel adaptive hybrid optimizer integrating chaotic maps with differential evolution and stochastic local search for improved global convergence.", "configspace": "", "generation": 36, "fitness": 0.35933523309393534, "feedback": "The algorithm ChaoticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "a10508d6-768c-493e-beb1-661e4bff6439", "metadata": {"aucs": [0.8907741323852334, 0.9032580186307971, 0.904050186891097, 0.9002369103072373, 0.9043046775191126, 0.8898160534863421, 0.8846995680261985, 0.9038640186227515, 0.8876033407301832, 0.8260340246232599, 0.7898238061863653, 0.8353722820927412, 0.759194053282134, 0.06321089023711524, 9.999999999998899e-05, 0.796105936103139, 0.8224150489891084, 0.793988347985662, 0.18846866206994672, 0.18859889496899196, 0.1917810640287242, 0.18951536085537535, 0.8035850097466894, 0.7440522903501635, 0.11715403977400096, 0.18653255401799973, 0.835520794032431, 0.11788584528949253, 0.15894403683655234, 0.10515138062863794, 0.0971886280151737, 0.1457661747043656, 0.16065724387666236, 0.10093191369079668, 0.15709912761994604, 0.16268774303891065, 0.9530746450044156, 0.9515199612484054, 0.9510347460056537, 0.9456430666183814, 0.9589349427341702, 0.9054937987999391, 0.9298803243595877, 0.9425511265719819, 0.9426042044547731, 0.5778853061341047, 0.5703475944211742, 0.4684716253657887, 0.517023570637152, 0.5140658333005436, 0.4546714791894876, 0.4406342343694909, 0.45543204807741267, 0.4054354125363129, 0.38352633683545745, 0.22640678622350474, 0.21348097231792384, 0.2203232961031194, 0.3835231731852816, 0.2775158842260341, 0.9251772299607052, 0.8560833735503717, 0.9041744878224823, 0.19779244165356358, 0.22323544582804133, 0.21130451119394067, 0.39603305027268465, 0.1291115559252035, 0.2471946960955278, 0.19497756096599328, 0.1284850467523584, 0.43309882916164044, 0.17354662674045007, 0.15707510736388486, 0.2599307882307127, 0.20177551671666383, 0.2104119846639384, 0.20537816485763993, 0.22297383282856365, 0.150964473711095, 0.1694470151058044, 0.09488771479752833, 9.999999999998899e-05, 0.11736935092854905, 0.11265069305148478, 0.012452443193316287, 0.0851375266545179, 9.999999999998899e-05, 0.1929965967729541, 0.06093544892736025, 0.20220954994133322, 0.16062145919000437, 0.20169176825216595, 0.13179572320514776, 0.26926564266810205, 0.1432548976177732, 0.1995186898566671, 0.1802776274448804, 0.4373693392866723, 0.1536075385597, 0.040493698264931655, 0.1571812635981109, 0.09791455300021135, 0.1048640218181065, 0.3745037829655674, 0.10534156364653868, 0.11542783908938148, 0.1207576670538989, 0.338470600149947, 0.1562001629676415, 0.32901826361960307, 0.31629320633088387, 0.303143102301764, 0.2138453492865039, 0.3891454386515656, 0.16663798808448482, 0.18424481079424138, 0.6446792407446542, 0.5658102392113531, 0.6646762403828309, 0.5615612527143434, 0.501852942106397, 0.6677027490083061, 0.5862983955475226, 0.5198649930271844, 0.6132474873813685, 0.1156557173741729, 0.09085391097871176, 0.7480397820890659, 0.13994217508994788, 0.07508380427237604, 0.15627003777706483, 0.1248021191707801, 0.09933353684971791, 0.145114556324055, 0.2690441481018816, 0.21696423032586787, 0.22644884938537757, 0.7212908772878308, 0.40180466665296466, 0.17325708759462255, 0.31408604465788914, 0.3957280066336003, 0.5818421446988611, 0.41116858464893524, 0.35209055229062536, 0.4548015242030947, 0.5629700707855225, 0.4098566116377148, 0.2812531187170737, 0.5713088032142664, 0.6634298612882825, 0.4747399148423468, 0.2523636073575881, 0.3429563199112089, 0.2704974204734951, 0.4183876632666368, 0.1846706541048767, 0.2996131464339139, 0.2637381121535408, 0.4575347200526223, 0.3255202458915628, 0.2665260312033898, 0.2784045923014805, 0.22966837711634613, 0.2286667548322786, 0.21133282508668816, 0.2749754646264211, 0.24405557059686067, 0.30096971508494685, 0.2499000005240012, 0.1923358165026532, 0.22447546868414825, 0.18490862487891913, 0.1960756486199372, 0.22442729918607585, 0.20175099232033322, 0.8158279657702323, 0.2093786317263564, 0.8317430101677438, 0.18581640559189216, 0.20003742101903643, 0.15290764948484448, 0.17616281728355665, 0.19941800793961806, 0.7953734812768466, 0.16494384257703754, 0.21405645595532885, 0.1670051963314143, 0.6008042470754724, 0.2126412168438241, 0.15645048184836108, 0.15738887386841494, 0.7440515055133118, 0.9152534097169807, 0.20516576899635197, 0.8708004923501662, 0.1272592703267741, 0.2192118174559078, 0.1912392017032486, 0.21120717908144793, 0.18657550153663605, 0.23203531502385644, 0.22321250679621796, 0.20000682801836644, 0.19904760323558646, 0.278830142280199, 0.08584645734699137, 0.08975792710989461, 0.09261693361273882, 0.10575190288790981, 0.10036437758502159, 0.08777028105296014, 0.10261710106315625, 0.0950323278833346, 0.12242195499021435]}, "mutation_prompt": null}
{"id": "59e7da6b-3fe2-4622-a6fa-a945c3fae696", "solution": "import numpy as np\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 6 * dim  # Increased for better diversity\n        self.mutation_factor = 0.7  # Slightly reduced for refined tuning\n        self.crossover_rate = 0.9  # Increased for better crossover efficiency\n        self.local_search_intensity = 3  # Reduced further for more global search focus\n        self.adaptive_threshold = 0.3  # More dynamic for adaptive conditions\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Enhanced step size randomness\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Increase for better exploitation\n            self.mutation_factor = 0.8  # Adjust to enhance diversity\n            self.crossover_rate = 0.92  # Optimize for effective recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "RefinedHybridOptimizer", "description": "A refined hybrid optimizer using probabilistic parameter adaptation and dynamic local search strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 37, "fitness": 0.3871779262385162, "feedback": "The algorithm RefinedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.24.", "error": "", "parent_id": "a10508d6-768c-493e-beb1-661e4bff6439", "metadata": {"aucs": [0.7901908760920135, 0.7389575695350139, 0.7759619503398845, 0.7918071736506729, 0.7882776475500913, 0.7973400364060106, 0.7693273987918534, 0.8035631846669163, 0.7774115041995506, 0.6479439175696726, 0.6288683316356761, 0.6534442372425018, 0.6018932259213585, 0.6771225478418559, 0.647301938815377, 0.6115462022523257, 0.5996075043080975, 0.660404487701998, 0.133193126139884, 0.14060615930049514, 0.12403774113103849, 0.15530026097727145, 0.15511132864342725, 0.17037050432462386, 0.18454295009178245, 0.1384689150312819, 0.14399820585275525, 0.12065377576867975, 0.11303474601349683, 0.10670415761423135, 0.11794264223256268, 0.12667635559562873, 0.12347700712820187, 0.1598040794793627, 0.11352995000845789, 0.12147508153427367, 0.9783951141872379, 0.9518671847516155, 0.9440922454028933, 0.9453758645005926, 0.9597224810055681, 0.9574681002656219, 0.953962642485091, 0.9645391891620376, 0.9632336472285848, 0.4659232720389296, 0.4450166085948456, 0.45964844522650694, 0.44659527876604355, 0.40607662006693745, 0.4632732719244663, 0.4558591803901171, 0.444156313114236, 0.4338847218194082, 0.8075780978363994, 0.7178709812516444, 0.7617369648458565, 0.803670368501636, 0.7644992318050254, 0.7721251783099385, 0.7674627745346722, 0.7973017029511824, 0.7704682050311307, 0.4297042758718176, 0.37368117833483927, 0.39124274519545277, 0.331441477564557, 0.4783500592293679, 0.3757619324146645, 0.43861222683405754, 0.3796142329215866, 0.39439914373658636, 0.28887047942394406, 0.4200182809996993, 0.3900180530990224, 0.40842187748542824, 0.4883421772016625, 0.45044487197433314, 0.4290582463143513, 0.4222799421262906, 0.4061395418048712, 0.39938842320280143, 0.3168292509833345, 0.3325643625011211, 0.35821560326283075, 0.3993175380617785, 0.3668974192325458, 0.44699389835812464, 0.4364047905914362, 0.4483736852780633, 0.45010866554779383, 0.47603430104457445, 0.4788407889367824, 0.48318060136598817, 0.43295082339566204, 0.5078183238208749, 0.4949428255208713, 0.5011183435969057, 0.45246395227543823, 0.20557339249851114, 0.14846564584597166, 0.2067390138006957, 0.27879639856629623, 0.292877299482459, 0.21669715447857574, 0.12316721860851432, 0.17553946195804782, 0.16190514497025688, 0.2999239192026353, 0.28554263898942067, 0.3037465599274993, 0.3113186245794015, 0.3363883842228832, 0.3151869321105315, 0.2970701899420485, 0.29397269221955247, 0.311301702444295, 0.6166401489371303, 0.6444878510212236, 0.6513568987181763, 0.6614610447651798, 0.6333981509090765, 0.6655189685228953, 0.6349447729510942, 0.6700491046205515, 0.6218594573326282, 0.2041502304023356, 0.1374288988161294, 0.11971608002741829, 0.12279608460903091, 0.12778218466330094, 0.13280011536778058, 0.11488207985585719, 0.13838398352298553, 0.09494622093859939, 0.18562646394433713, 0.19536476951506676, 0.14903976185364032, 0.17138290959532443, 0.31712117866758416, 0.20227803245214027, 0.25266253025353724, 0.256768117519093, 0.1629026003930064, 0.32413341128334117, 0.3842478562721794, 0.3831881596336395, 0.3181581597117762, 0.3709235665049685, 0.33980546742499496, 0.34444614094639125, 0.38450230687463305, 0.3683518096277, 0.27312387854282794, 0.28642679788160974, 0.27087414651946407, 0.24998785832550874, 0.28041623252045866, 0.2799135493205669, 0.29411530806796815, 0.33340986896705516, 0.2941346681253998, 0.1826562840108581, 0.19911905115680462, 0.20052698944287783, 0.219735685670034, 0.2025404954673954, 0.18094710801609204, 0.187466093945846, 0.1872140114759533, 0.1875901115554598, 0.19651379567674698, 0.33963234611483817, 0.2331518423623492, 0.2166015937801733, 0.263652750172916, 0.29948660394207915, 0.26819194522795264, 0.2099874925135019, 0.24808547461755892, 0.16848935738030846, 0.18196549115335714, 0.2061033849511419, 0.7975508803662872, 0.18274311048321568, 0.72015619291062, 0.6993807222477606, 0.70691203281465, 0.1757433417864137, 0.7197011996215121, 0.7184120430888741, 0.6573953283118874, 0.6385668877603942, 0.5908284060048438, 0.20902825872966102, 0.2087249324417596, 0.21141214229260563, 0.21207959229311657, 0.18176298116871203, 0.20648467354663036, 0.1873016857223645, 0.1899047675605683, 0.18575696846971146, 0.19205133519152784, 0.1982994665080906, 0.19003933898927605, 0.19039123620744558, 0.07489306674862195, 0.08800589038062756, 0.09423777713300874, 0.08526922158621186, 0.08873084692285016, 0.07545998810265286, 0.08393867531621835, 0.08819169518021897, 0.08075452552772389]}, "mutation_prompt": null}
{"id": "6aff7d03-9be5-4f95-b650-c7cc4d0e0897", "solution": "import numpy as np\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 6 * dim  # Increased for better diversity\n        self.mutation_factor = 0.7  # Slightly reduced for refined tuning\n        self.crossover_rate = 0.9  # Increased for better crossover efficiency\n        self.local_search_intensity = 3  # Reduced further for more global search focus\n        self.adaptive_threshold = 0.3  # More dynamic for adaptive conditions\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Enhanced step size randomness\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Increase for better exploitation\n            self.mutation_factor = 0.8  # Adjust to enhance diversity\n            self.crossover_rate = 0.92  # Optimize for effective recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "RefinedHybridOptimizer", "description": "A refined hybrid optimizer using probabilistic parameter adaptation and dynamic local search strategy to enhance exploration and exploitation balance.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59e7da6b-3fe2-4622-a6fa-a945c3fae696", "metadata": {"aucs": [0.7901908760920135, 0.7389575695350139, 0.7759619503398845, 0.7918071736506729, 0.7882776475500913, 0.7973400364060106, 0.7693273987918534, 0.8035631846669163, 0.7774115041995506, 0.6479439175696726, 0.6288683316356761, 0.6534442372425018, 0.6018932259213585, 0.6771225478418559, 0.647301938815377, 0.6115462022523257, 0.5996075043080975, 0.660404487701998, 0.133193126139884, 0.14060615930049514, 0.12403774113103849, 0.15530026097727145, 0.15511132864342725, 0.17037050432462386, 0.18454295009178245, 0.1384689150312819, 0.14399820585275525, 0.12065377576867975, 0.11303474601349683, 0.10670415761423135, 0.11794264223256268, 0.12667635559562873, 0.12347700712820187, 0.1598040794793627, 0.11352995000845789, 0.12147508153427367, 0.9783951141872379, 0.9518671847516155, 0.9440922454028933, 0.9453758645005926, 0.9597224810055681, 0.9574681002656219, 0.953962642485091, 0.9645391891620376, 0.9632336472285848, 0.4659232720389296, 0.4450166085948456, 0.45964844522650694, 0.44659527876604355, 0.40607662006693745, 0.4632732719244663, 0.4558591803901171, 0.444156313114236, 0.4338847218194082, 0.8075780978363994, 0.7178709812516444, 0.7617369648458565, 0.803670368501636, 0.7644992318050254, 0.7721251783099385, 0.7674627745346722, 0.7973017029511824, 0.7704682050311307, 0.4297042758718176, 0.37368117833483927, 0.39124274519545277, 0.331441477564557, 0.4783500592293679, 0.3757619324146645, 0.43861222683405754, 0.3796142329215866, 0.39439914373658636, 0.28887047942394406, 0.4200182809996993, 0.3900180530990224, 0.40842187748542824, 0.4883421772016625, 0.45044487197433314, 0.4290582463143513, 0.4222799421262906, 0.4061395418048712, 0.39938842320280143, 0.3168292509833345, 0.3325643625011211, 0.35821560326283075, 0.3993175380617785, 0.3668974192325458, 0.44699389835812464, 0.4364047905914362, 0.4483736852780633, 0.45010866554779383, 0.47603430104457445, 0.4788407889367824, 0.48318060136598817, 0.43295082339566204, 0.5078183238208749, 0.4949428255208713, 0.5011183435969057, 0.45246395227543823, 0.20557339249851114, 0.14846564584597166, 0.2067390138006957, 0.27879639856629623, 0.292877299482459, 0.21669715447857574, 0.12316721860851432, 0.17553946195804782, 0.16190514497025688, 0.2999239192026353, 0.28554263898942067, 0.3037465599274993, 0.3113186245794015, 0.3363883842228832, 0.3151869321105315, 0.2970701899420485, 0.29397269221955247, 0.311301702444295, 0.6166401489371303, 0.6444878510212236, 0.6513568987181763, 0.6614610447651798, 0.6333981509090765, 0.6655189685228953, 0.6349447729510942, 0.6700491046205515, 0.6218594573326282, 0.2041502304023356, 0.1374288988161294, 0.11971608002741829, 0.12279608460903091, 0.12778218466330094, 0.13280011536778058, 0.11488207985585719, 0.13838398352298553, 0.09494622093859939, 0.18562646394433713, 0.19536476951506676, 0.14903976185364032, 0.17138290959532443, 0.31712117866758416, 0.20227803245214027, 0.25266253025353724, 0.256768117519093, 0.1629026003930064, 0.32413341128334117, 0.3842478562721794, 0.3831881596336395, 0.3181581597117762, 0.3709235665049685, 0.33980546742499496, 0.34444614094639125, 0.38450230687463305, 0.3683518096277, 0.27312387854282794, 0.28642679788160974, 0.27087414651946407, 0.24998785832550874, 0.28041623252045866, 0.2799135493205669, 0.29411530806796815, 0.33340986896705516, 0.2941346681253998, 0.1826562840108581, 0.19911905115680462, 0.20052698944287783, 0.219735685670034, 0.2025404954673954, 0.18094710801609204, 0.187466093945846, 0.1872140114759533, 0.1875901115554598, 0.19651379567674698, 0.33963234611483817, 0.2331518423623492, 0.2166015937801733, 0.263652750172916, 0.29948660394207915, 0.26819194522795264, 0.2099874925135019, 0.24808547461755892, 0.16848935738030846, 0.18196549115335714, 0.2061033849511419, 0.7975508803662872, 0.18274311048321568, 0.72015619291062, 0.6993807222477606, 0.70691203281465, 0.1757433417864137, 0.7197011996215121, 0.7184120430888741, 0.6573953283118874, 0.6385668877603942, 0.5908284060048438, 0.20902825872966102, 0.2087249324417596, 0.21141214229260563, 0.21207959229311657, 0.18176298116871203, 0.20648467354663036, 0.1873016857223645, 0.1899047675605683, 0.18575696846971146, 0.19205133519152784, 0.1982994665080906, 0.19003933898927605, 0.19039123620744558, 0.07489306674862195, 0.08800589038062756, 0.09423777713300874, 0.08526922158621186, 0.08873084692285016, 0.07545998810265286, 0.08393867531621835, 0.08819169518021897, 0.08075452552772389]}, "mutation_prompt": null}
{"id": "8679cd6d-9936-4560-aab4-8ed0323ea1a6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Slightly reduced for faster convergence in higher dimensions\n        self.mutation_factor = 0.6  # Further refined for better solution quality\n        self.crossover_rate = 0.85  # Adjusted for dynamic search space coverage\n        self.local_search_intensity = 4  # Balanced for exploration and exploitation\n        self.adaptive_threshold = 0.25  # Enhanced for condition-based adaptability\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.01, 0.15)  # Smoothed randomness for precision\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 6  # Moderate increase for fine-tuning\n            self.mutation_factor = 0.75  # Enhance exploration diversity\n            self.crossover_rate = 0.88  # Slightly adjust for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptiveDifferentialSearch", "description": "Adaptive Differential Search with Dynamic Adaptation and Exponential Crossover to balance exploration and exploitation across varied dimensions.", "configspace": "", "generation": 39, "fitness": 0.4414355956501012, "feedback": "The algorithm AdaptiveDifferentialSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "59e7da6b-3fe2-4622-a6fa-a945c3fae696", "metadata": {"aucs": [0.831882359462147, 0.8493957357969371, 0.8521300502471802, 0.8330821829957975, 0.8459109279769772, 0.8594480192114499, 0.8296985803836066, 0.8566824559931441, 0.8460276356791733, 0.7358915376055858, 0.7570780996168267, 0.7373719401204413, 0.7174851785441287, 0.7214970798264696, 0.7371866584939062, 0.7207046437581855, 0.7556733047644328, 0.7342494800849062, 0.16270483347555076, 0.1570280111218756, 0.18616653288682583, 0.2015159493222024, 0.18480212725714584, 0.38447885331725207, 0.1942944640395431, 0.16334092233884434, 0.3714090452410662, 0.13431525842074754, 0.16175401029553882, 0.13993392512046865, 0.15885549169008206, 0.21066932943872807, 0.14513479158868992, 0.222500640133782, 0.1549714947027806, 0.13311619654224027, 0.9711618884327861, 0.9366574444172769, 0.9370274524099833, 0.9524057194638198, 0.9722343384989788, 0.9408818381667752, 0.9459708989026393, 0.9893961212786001, 0.9547205821606073, 0.5920468597724862, 0.5482257977504926, 0.5617344587158022, 0.5343334185361077, 0.5521921555981235, 0.6133368277583611, 0.5964897297662026, 0.5507025149572553, 0.5539214463193656, 0.8764778993424779, 0.7733761004618789, 0.8625085092529463, 0.8219278341565238, 0.849531137032935, 0.8556128780090255, 0.8462794633517108, 0.2286642328843731, 0.8147509838830624, 0.5694956927261017, 0.4632414827197635, 0.45305603806031003, 0.49737388005505767, 0.5063000584557832, 0.4444706491253514, 0.5934128759107096, 0.5535328095399141, 0.4784589632921127, 0.5181477040229605, 0.3844314067648905, 0.43370670248294363, 0.46554104509747685, 0.45988010016021386, 0.5393416885927069, 0.45193157833016073, 0.4939864877780549, 0.4922063987261589, 0.40765770038080473, 0.448050796741041, 0.5146923710734439, 0.48267415626639787, 0.46034924920969766, 0.4182849025962603, 0.4414186081532335, 0.435866030509774, 0.4615135005889953, 0.532918344858274, 0.49805082723922955, 0.5603177807926163, 0.5276942623079561, 0.5650873539198598, 0.581187566353703, 0.636558378601517, 0.6128695174175303, 0.5860338014078985, 0.1335904671718663, 0.15266569033309885, 0.27957259191477857, 0.21489293101288154, 0.3404827083893862, 0.18797881247726422, 0.15642865653261617, 0.19658509125172063, 0.17621024640998006, 0.3266375682779773, 0.34006889435251053, 0.34563218925816164, 0.3510191283251711, 0.40260041643147837, 0.3729576427081136, 0.3576833444048647, 0.3781510260060509, 0.3729020690715592, 0.7142299653147466, 0.7103770225603587, 0.7557775421351769, 0.7106921312314307, 0.6981164867424134, 0.7230124763626141, 0.7247839390949965, 0.7421573486783931, 0.7103610511705292, 0.14532830524103724, 0.13272771489337287, 0.14377421608149765, 0.12299344588401329, 0.13908591057924802, 0.15012146342108823, 0.1351353931174628, 0.13523742168307729, 0.11839420385166288, 0.45303155970748665, 0.4805546813578381, 0.22442398037626488, 0.2434328493601018, 0.33077976158705813, 0.19526337560718887, 0.22151290528112788, 0.2075480680379188, 0.2432382188676928, 0.4070955052123195, 0.387317784131576, 0.4017255048191498, 0.39697147885149087, 0.3955648674628205, 0.42036934494313716, 0.43723010313764676, 0.44650297625573665, 0.4489104314065787, 0.30918687202391715, 0.34328369768909395, 0.32998884147076957, 0.33841964476322617, 0.3219358875144859, 0.35642115378789074, 0.3814928206510888, 0.35359920825673885, 0.3545651361211183, 0.2226197130719696, 0.193908560812736, 0.20337661644818905, 0.20077344265876051, 0.23491424490126434, 0.2270779361041636, 0.2019685391818039, 0.22020120483762562, 0.21166472497510935, 0.22616330452637445, 0.2354829119998869, 0.21106762757942155, 0.20886964593113566, 0.44630058225258895, 0.39030873436548263, 0.22978569267687654, 0.4179378470356405, 0.22329707023387324, 0.20727220028701854, 0.8287558360944044, 0.8317172381851095, 0.1760918558293746, 0.19446465016214698, 0.19252307126395607, 0.7444662291346047, 0.7898194647455795, 0.7947644469869911, 0.20610619378527606, 0.7554776621942545, 0.6781181858635563, 0.2017269629134697, 0.836071723113248, 0.8345707793462944, 0.20958511906959054, 0.21141017376115778, 0.8296875981891039, 0.22724236514005536, 0.21071098004832134, 0.18772732249097868, 0.1827482878534068, 0.21030684671570243, 0.20411004470895855, 0.3671673604635577, 0.18507946554925947, 0.20636227609355806, 0.09300664487063293, 0.09679256128865288, 0.08642664263147859, 0.08671625059018784, 0.09209716750677366, 0.09516201434788285, 0.09180319663670011, 0.08662423868042368, 0.09222804419907116]}, "mutation_prompt": null}
{"id": "a1a2c8fc-159a-4d8c-90f2-0ba9b108d1b0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Slightly reduced for faster convergence in higher dimensions\n        self.mutation_factor = 0.6  # Further refined for better solution quality\n        self.crossover_rate = 0.85  # Adjusted for dynamic search space coverage\n        self.local_search_intensity = 4  # Balanced for exploration and exploitation\n        self.adaptive_threshold = 0.25  # Enhanced for condition-based adaptability\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.01, 0.15)  # Smoothed randomness for precision\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 6  # Moderate increase for fine-tuning\n            self.mutation_factor = 0.75  # Enhance exploration diversity\n            self.crossover_rate = 0.88  # Slightly adjust for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptiveDifferentialSearch", "description": "Adaptive Differential Search with Dynamic Adaptation and Exponential Crossover to balance exploration and exploitation across varied dimensions.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8679cd6d-9936-4560-aab4-8ed0323ea1a6", "metadata": {"aucs": [0.831882359462147, 0.8493957357969371, 0.8521300502471802, 0.8330821829957975, 0.8459109279769772, 0.8594480192114499, 0.8296985803836066, 0.8566824559931441, 0.8460276356791733, 0.7358915376055858, 0.7570780996168267, 0.7373719401204413, 0.7174851785441287, 0.7214970798264696, 0.7371866584939062, 0.7207046437581855, 0.7556733047644328, 0.7342494800849062, 0.16270483347555076, 0.1570280111218756, 0.18616653288682583, 0.2015159493222024, 0.18480212725714584, 0.38447885331725207, 0.1942944640395431, 0.16334092233884434, 0.3714090452410662, 0.13431525842074754, 0.16175401029553882, 0.13993392512046865, 0.15885549169008206, 0.21066932943872807, 0.14513479158868992, 0.222500640133782, 0.1549714947027806, 0.13311619654224027, 0.9711618884327861, 0.9366574444172769, 0.9370274524099833, 0.9524057194638198, 0.9722343384989788, 0.9408818381667752, 0.9459708989026393, 0.9893961212786001, 0.9547205821606073, 0.5920468597724862, 0.5482257977504926, 0.5617344587158022, 0.5343334185361077, 0.5521921555981235, 0.6133368277583611, 0.5964897297662026, 0.5507025149572553, 0.5539214463193656, 0.8764778993424779, 0.7733761004618789, 0.8625085092529463, 0.8219278341565238, 0.849531137032935, 0.8556128780090255, 0.8462794633517108, 0.2286642328843731, 0.8147509838830624, 0.5694956927261017, 0.4632414827197635, 0.45305603806031003, 0.49737388005505767, 0.5063000584557832, 0.4444706491253514, 0.5934128759107096, 0.5535328095399141, 0.4784589632921127, 0.5181477040229605, 0.3844314067648905, 0.43370670248294363, 0.46554104509747685, 0.45988010016021386, 0.5393416885927069, 0.45193157833016073, 0.4939864877780549, 0.4922063987261589, 0.40765770038080473, 0.448050796741041, 0.5146923710734439, 0.48267415626639787, 0.46034924920969766, 0.4182849025962603, 0.4414186081532335, 0.435866030509774, 0.4615135005889953, 0.532918344858274, 0.49805082723922955, 0.5603177807926163, 0.5276942623079561, 0.5650873539198598, 0.581187566353703, 0.636558378601517, 0.6128695174175303, 0.5860338014078985, 0.1335904671718663, 0.15266569033309885, 0.27957259191477857, 0.21489293101288154, 0.3404827083893862, 0.18797881247726422, 0.15642865653261617, 0.19658509125172063, 0.17621024640998006, 0.3266375682779773, 0.34006889435251053, 0.34563218925816164, 0.3510191283251711, 0.40260041643147837, 0.3729576427081136, 0.3576833444048647, 0.3781510260060509, 0.3729020690715592, 0.7142299653147466, 0.7103770225603587, 0.7557775421351769, 0.7106921312314307, 0.6981164867424134, 0.7230124763626141, 0.7247839390949965, 0.7421573486783931, 0.7103610511705292, 0.14532830524103724, 0.13272771489337287, 0.14377421608149765, 0.12299344588401329, 0.13908591057924802, 0.15012146342108823, 0.1351353931174628, 0.13523742168307729, 0.11839420385166288, 0.45303155970748665, 0.4805546813578381, 0.22442398037626488, 0.2434328493601018, 0.33077976158705813, 0.19526337560718887, 0.22151290528112788, 0.2075480680379188, 0.2432382188676928, 0.4070955052123195, 0.387317784131576, 0.4017255048191498, 0.39697147885149087, 0.3955648674628205, 0.42036934494313716, 0.43723010313764676, 0.44650297625573665, 0.4489104314065787, 0.30918687202391715, 0.34328369768909395, 0.32998884147076957, 0.33841964476322617, 0.3219358875144859, 0.35642115378789074, 0.3814928206510888, 0.35359920825673885, 0.3545651361211183, 0.2226197130719696, 0.193908560812736, 0.20337661644818905, 0.20077344265876051, 0.23491424490126434, 0.2270779361041636, 0.2019685391818039, 0.22020120483762562, 0.21166472497510935, 0.22616330452637445, 0.2354829119998869, 0.21106762757942155, 0.20886964593113566, 0.44630058225258895, 0.39030873436548263, 0.22978569267687654, 0.4179378470356405, 0.22329707023387324, 0.20727220028701854, 0.8287558360944044, 0.8317172381851095, 0.1760918558293746, 0.19446465016214698, 0.19252307126395607, 0.7444662291346047, 0.7898194647455795, 0.7947644469869911, 0.20610619378527606, 0.7554776621942545, 0.6781181858635563, 0.2017269629134697, 0.836071723113248, 0.8345707793462944, 0.20958511906959054, 0.21141017376115778, 0.8296875981891039, 0.22724236514005536, 0.21071098004832134, 0.18772732249097868, 0.1827482878534068, 0.21030684671570243, 0.20411004470895855, 0.3671673604635577, 0.18507946554925947, 0.20636227609355806, 0.09300664487063293, 0.09679256128865288, 0.08642664263147859, 0.08671625059018784, 0.09209716750677366, 0.09516201434788285, 0.09180319663670011, 0.08662423868042368, 0.09222804419907116]}, "mutation_prompt": null}
{"id": "88f15261-15b3-402f-88a1-361e239fd777", "solution": "import numpy as np\n\nclass AdaptiveDifferentialSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Slightly reduced for faster convergence in higher dimensions\n        self.mutation_factor = 0.6  # Further refined for better solution quality\n        self.crossover_rate = 0.85  # Adjusted for dynamic search space coverage\n        self.local_search_intensity = 4  # Balanced for exploration and exploitation\n        self.adaptive_threshold = 0.25  # Enhanced for condition-based adaptability\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.01, 0.15)  # Smoothed randomness for precision\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 6  # Moderate increase for fine-tuning\n            self.mutation_factor = 0.75  # Enhance exploration diversity\n            self.crossover_rate = 0.88  # Slightly adjust for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptiveDifferentialSearch", "description": "Adaptive Differential Search with Dynamic Adaptation and Exponential Crossover to balance exploration and exploitation across varied dimensions.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8679cd6d-9936-4560-aab4-8ed0323ea1a6", "metadata": {"aucs": [0.831882359462147, 0.8493957357969371, 0.8521300502471802, 0.8330821829957975, 0.8459109279769772, 0.8594480192114499, 0.8296985803836066, 0.8566824559931441, 0.8460276356791733, 0.7358915376055858, 0.7570780996168267, 0.7373719401204413, 0.7174851785441287, 0.7214970798264696, 0.7371866584939062, 0.7207046437581855, 0.7556733047644328, 0.7342494800849062, 0.16270483347555076, 0.1570280111218756, 0.18616653288682583, 0.2015159493222024, 0.18480212725714584, 0.38447885331725207, 0.1942944640395431, 0.16334092233884434, 0.3714090452410662, 0.13431525842074754, 0.16175401029553882, 0.13993392512046865, 0.15885549169008206, 0.21066932943872807, 0.14513479158868992, 0.222500640133782, 0.1549714947027806, 0.13311619654224027, 0.9711618884327861, 0.9366574444172769, 0.9370274524099833, 0.9524057194638198, 0.9722343384989788, 0.9408818381667752, 0.9459708989026393, 0.9893961212786001, 0.9547205821606073, 0.5920468597724862, 0.5482257977504926, 0.5617344587158022, 0.5343334185361077, 0.5521921555981235, 0.6133368277583611, 0.5964897297662026, 0.5507025149572553, 0.5539214463193656, 0.8764778993424779, 0.7733761004618789, 0.8625085092529463, 0.8219278341565238, 0.849531137032935, 0.8556128780090255, 0.8462794633517108, 0.2286642328843731, 0.8147509838830624, 0.5694956927261017, 0.4632414827197635, 0.45305603806031003, 0.49737388005505767, 0.5063000584557832, 0.4444706491253514, 0.5934128759107096, 0.5535328095399141, 0.4784589632921127, 0.5181477040229605, 0.3844314067648905, 0.43370670248294363, 0.46554104509747685, 0.45988010016021386, 0.5393416885927069, 0.45193157833016073, 0.4939864877780549, 0.4922063987261589, 0.40765770038080473, 0.448050796741041, 0.5146923710734439, 0.48267415626639787, 0.46034924920969766, 0.4182849025962603, 0.4414186081532335, 0.435866030509774, 0.4615135005889953, 0.532918344858274, 0.49805082723922955, 0.5603177807926163, 0.5276942623079561, 0.5650873539198598, 0.581187566353703, 0.636558378601517, 0.6128695174175303, 0.5860338014078985, 0.1335904671718663, 0.15266569033309885, 0.27957259191477857, 0.21489293101288154, 0.3404827083893862, 0.18797881247726422, 0.15642865653261617, 0.19658509125172063, 0.17621024640998006, 0.3266375682779773, 0.34006889435251053, 0.34563218925816164, 0.3510191283251711, 0.40260041643147837, 0.3729576427081136, 0.3576833444048647, 0.3781510260060509, 0.3729020690715592, 0.7142299653147466, 0.7103770225603587, 0.7557775421351769, 0.7106921312314307, 0.6981164867424134, 0.7230124763626141, 0.7247839390949965, 0.7421573486783931, 0.7103610511705292, 0.14532830524103724, 0.13272771489337287, 0.14377421608149765, 0.12299344588401329, 0.13908591057924802, 0.15012146342108823, 0.1351353931174628, 0.13523742168307729, 0.11839420385166288, 0.45303155970748665, 0.4805546813578381, 0.22442398037626488, 0.2434328493601018, 0.33077976158705813, 0.19526337560718887, 0.22151290528112788, 0.2075480680379188, 0.2432382188676928, 0.4070955052123195, 0.387317784131576, 0.4017255048191498, 0.39697147885149087, 0.3955648674628205, 0.42036934494313716, 0.43723010313764676, 0.44650297625573665, 0.4489104314065787, 0.30918687202391715, 0.34328369768909395, 0.32998884147076957, 0.33841964476322617, 0.3219358875144859, 0.35642115378789074, 0.3814928206510888, 0.35359920825673885, 0.3545651361211183, 0.2226197130719696, 0.193908560812736, 0.20337661644818905, 0.20077344265876051, 0.23491424490126434, 0.2270779361041636, 0.2019685391818039, 0.22020120483762562, 0.21166472497510935, 0.22616330452637445, 0.2354829119998869, 0.21106762757942155, 0.20886964593113566, 0.44630058225258895, 0.39030873436548263, 0.22978569267687654, 0.4179378470356405, 0.22329707023387324, 0.20727220028701854, 0.8287558360944044, 0.8317172381851095, 0.1760918558293746, 0.19446465016214698, 0.19252307126395607, 0.7444662291346047, 0.7898194647455795, 0.7947644469869911, 0.20610619378527606, 0.7554776621942545, 0.6781181858635563, 0.2017269629134697, 0.836071723113248, 0.8345707793462944, 0.20958511906959054, 0.21141017376115778, 0.8296875981891039, 0.22724236514005536, 0.21071098004832134, 0.18772732249097868, 0.1827482878534068, 0.21030684671570243, 0.20411004470895855, 0.3671673604635577, 0.18507946554925947, 0.20636227609355806, 0.09300664487063293, 0.09679256128865288, 0.08642664263147859, 0.08671625059018784, 0.09209716750677366, 0.09516201434788285, 0.09180319663670011, 0.08662423868042368, 0.09222804419907116]}, "mutation_prompt": null}
{"id": "d5d2cd87-2cdb-430a-b99d-b4df165949ff", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim\n        self.mutation_factor = 0.7  # Adjusted mutation factor for improved diversity\n        self.crossover_rate = 0.9  # Increased for better recombination\n        self.local_search_intensity = 5  # Increased to enhance local search capability\n        self.adaptive_threshold = 0.2  # Reduced for more frequent adaptability\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.01, 0.1)  # Adjusted for enhanced precision\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase for detailed search\n            self.mutation_factor = 0.8  # Boost exploration capability\n            self.crossover_rate = 0.92  # Further enhance recombination efficiency\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedAdaptiveDifferentialSearch", "description": "Enhanced Adaptive Differential Search with Dynamic Threshold Control and Adaptive Mutation Rates for Optimal Exploration and Exploitation.", "configspace": "", "generation": 42, "fitness": 0.43484192688363904, "feedback": "The algorithm EnhancedAdaptiveDifferentialSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.25.", "error": "", "parent_id": "8679cd6d-9936-4560-aab4-8ed0323ea1a6", "metadata": {"aucs": [0.8276680189451633, 0.8225022121872905, 0.7999346055266029, 0.8175454503326492, 0.8272384558009269, 0.8324151757357282, 0.8369458958688679, 0.8037906697838317, 0.8101920209723893, 0.7153582576176402, 0.6694762566968128, 0.6949075959125657, 0.708096659456238, 0.6525169740652992, 0.6752727976136041, 0.6632535571737401, 0.6670005308483871, 0.6774052183896448, 0.1734320391833245, 0.1327627429008198, 0.14977670224821216, 0.16240405305504357, 0.14406739696904602, 0.24866259408676183, 0.2129948861733736, 0.15139035602552153, 0.14517878729733436, 0.12307937769723121, 0.1384959373819702, 0.12720796482708996, 0.14751946949737482, 0.1492384302445242, 0.1353528341806095, 0.1341719428168242, 0.1568327889467389, 0.1483681870817125, 0.9736943421698768, 0.9449456487611619, 0.945474304540797, 0.9800679259670012, 0.9866544986103327, 0.9352824965075219, 0.934160027217638, 0.9802436440505242, 0.9835613026283034, 0.4983382130269529, 0.5133244505166465, 0.5431465574750849, 0.534033363067033, 0.557545497060015, 0.4993379250563478, 0.5374141558788263, 0.4987136659722654, 0.5145877608129799, 0.804812279311931, 0.8108329583743078, 0.7771035456708272, 0.8520329386927556, 0.8163412947669993, 0.8072488925858357, 0.8196802108516169, 0.7916838400506676, 0.7504540531999474, 0.4881995799262625, 0.5264009781234367, 0.46453655030175933, 0.45867155013121896, 0.5747366331190737, 0.572792832874844, 0.49378738316678805, 0.5488940362356677, 0.4161053178757619, 0.3585726138399795, 0.2671728689662105, 0.42551469801606034, 0.5399568153801154, 0.5017204304870594, 0.45692179571523883, 0.4880276549497031, 0.47698206598326776, 0.4675308206056489, 0.5211766077747095, 0.4567812122551629, 0.5186231824541947, 0.4358524924187944, 0.48057735505347887, 0.43676447127484097, 0.4327296704126993, 0.4903251576089932, 0.5380807212965982, 0.5432279853043156, 0.492713285022215, 0.5713581564014022, 0.5785721860104631, 0.5409483071082871, 0.5965138416324224, 0.5318231331637668, 0.6109577731946292, 0.5730896380784085, 0.2502660256152951, 0.23891149034749748, 0.22315611809941216, 0.24201552010733118, 0.27018297174137373, 0.32786672072434575, 0.1593727440616154, 0.23598989363085576, 0.2182987362693074, 0.36045190393098436, 0.3673912542276706, 0.3496049636914923, 0.35850502387203753, 0.34111673024119904, 0.3437572927744673, 0.3359609578290944, 0.364435499924189, 0.3773081161204117, 0.7027819130692459, 0.730176747496945, 0.7205174443570332, 0.7264518350725842, 0.7217381934710126, 0.6792286545746489, 0.6790208355212044, 0.6961577761756971, 0.7104862063575469, 0.16975121955982686, 0.11687487713560207, 0.1485173584180961, 0.168053939000539, 0.1525169833694877, 0.15499864101116656, 0.15750766090188462, 0.16870574742315092, 0.14678582474329582, 0.19691329973007377, 0.39296907113147717, 0.22485708319531894, 0.27010938314168986, 0.19050590770213327, 0.4625505347808798, 0.16904220860432018, 0.2747629514956288, 0.19310822083457835, 0.3572898918445875, 0.39528273024666327, 0.3782336397960424, 0.34718679523505247, 0.38212204083387247, 0.3711154077765243, 0.43025625041729276, 0.3836580612189644, 0.3846665674705879, 0.29763228003747577, 0.30647368217408155, 0.31522631755796193, 0.32084900345181466, 0.2908781534926924, 0.30933546494282815, 0.32423357493223126, 0.3327315245050567, 0.3265475325418964, 0.21395017206216171, 0.21410281727564806, 0.22589905390227238, 0.21270005285124038, 0.21751948708533653, 0.20331196583313227, 0.22234892494476977, 0.19167112642308948, 0.1929762353972544, 0.35043545285269895, 0.20514845545945282, 0.20258724343358814, 0.21860643770187038, 0.281339647324681, 0.23311826640460764, 0.2229042287540356, 0.5487309488265314, 0.49119845954329544, 0.831643610832852, 0.769860044428073, 0.771129891214592, 0.8262421334590366, 0.18595951752071072, 0.17466538425214562, 0.7348612923346706, 0.8199839116215102, 0.8007698049294469, 0.16472642723163222, 0.2067042936753143, 0.7531779068071236, 0.20782668862336673, 0.7909216067489707, 0.7280221100362745, 0.20999143794900976, 0.858488535308466, 0.1531356759508602, 0.2035171771383938, 0.19656467489953366, 0.19460278022762934, 0.21467212543195313, 0.3430845582956944, 0.19125928772047063, 0.2056540011058613, 0.19110423500864915, 0.22667135538109429, 0.08547736385960147, 0.09790884216238649, 0.09080254674083044, 0.08037617603308866, 0.09536727888656915, 0.09411831699456674, 0.09376662803592084, 0.09694745231308677, 0.09408831914313742]}, "mutation_prompt": null}
{"id": "14d6c563-8c43-4342-a557-441d56718998", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 7 * dim  # Increased for more diversity\n        self.mutation_factor = 0.65  # Slightly adjusted for optimal balance\n        self.crossover_rate = 0.9  # Increased for better recombination\n        self.local_search_intensity = 3  # Adjusted for better exploitation\n        self.adaptive_threshold = 0.3  # Tweaked for improved adaptability\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.01, 0.1)  # Reduced to focus on precision\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 5  # Adjusted for balanced fine-tuning\n            self.mutation_factor = 0.7  # Moderate adjustment for diversity\n            self.crossover_rate = 0.85  # Adjusted for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedAdaptiveDifferentialSearch", "description": "Enhanced Adaptive Differential Search with Improved Selection and Parameter Tuning Techniques for Robust Optimization.", "configspace": "", "generation": 43, "fitness": 0.3786200937975438, "feedback": "The algorithm EnhancedAdaptiveDifferentialSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "8679cd6d-9936-4560-aab4-8ed0323ea1a6", "metadata": {"aucs": [0.7929234459939083, 0.8020960669716106, 0.794859402360683, 0.782946552230303, 0.8038833612042074, 0.8101164209430838, 0.8075305080831595, 0.8044158116856146, 0.7976143301477336, 0.6409958143081018, 0.6507642909388562, 0.6405640948800424, 0.6438912583428372, 0.6449512107943154, 0.6439091124585994, 0.6520079717867793, 0.6404757762380271, 0.6386160904595781, 0.15738990184505097, 0.15037154206076353, 0.12755214324102326, 0.1377256602553555, 0.13034046159764623, 0.15360021467310925, 0.13736727846741792, 0.14672080757429795, 0.14317115374494627, 0.11251966977200067, 0.1269884674584697, 0.12295928792275512, 0.12502951718765432, 0.13826539368081303, 0.11511170270240689, 0.11996002172406262, 0.11939840580754257, 0.12782973243136198, 0.9454023670631088, 0.9354887396928953, 0.9635650618700691, 0.9470683566345043, 0.9193420213704208, 0.9246409075366608, 0.9633986357278135, 0.9039944165938627, 0.9539915999109251, 0.49331920838840404, 0.4324407927267099, 0.474124659343898, 0.47655105184663815, 0.47261840933587196, 0.4559358989756854, 0.46316446444582504, 0.47374912708875694, 0.45563315672485827, 0.7823917727734433, 0.6945100364312173, 0.7471334554700948, 0.7956239761046904, 0.7352670338987068, 0.7550274692408601, 0.7758466148563901, 0.7397870362737846, 0.845470023794993, 0.36573463749268853, 0.41404333838373975, 0.36832925234181346, 0.22022105134579917, 0.3828331857184898, 0.34607530276192466, 0.2888567729544652, 0.32890132136071004, 0.3584064432942595, 0.3969785430575967, 0.31771874153502166, 0.24858973646421423, 0.3415551312180046, 0.40062240453410913, 0.3771883003840335, 0.4293333736528733, 0.3165759179219698, 0.34085257660099755, 0.3296447483863907, 0.3271585394912293, 0.32577952826360856, 0.36329824595710647, 0.3373044865520607, 0.3248593903830459, 0.3236881852548812, 0.30834761104249586, 0.33031409868445627, 0.419235908557008, 0.4265043123998483, 0.4461504177039366, 0.4062155519322558, 0.42273594226180444, 0.4582813710557794, 0.48301433123333104, 0.46179586415269436, 0.4639477492280052, 0.11319996708837665, 0.19679316506577538, 0.1500945490359441, 0.16266594164230042, 0.26270355655691524, 0.21543286774320114, 0.11602296833889691, 0.11239560108328572, 0.1720013887372719, 0.27142333682288744, 0.2767098291043161, 0.27210162499291246, 0.30427458903252624, 0.2981787047319837, 0.2768516736125056, 0.26948313706686555, 0.26311537156018716, 0.2817665571251168, 0.6034018526962833, 0.6155679265117893, 0.5988522572536162, 0.626419164344609, 0.6560150417785282, 0.5971894163265477, 0.5992673684036047, 0.6212210608381064, 0.5993981030383205, 0.14546652109627123, 0.13888195682007465, 0.1321158250003457, 0.13787931874940207, 0.12582540726175462, 0.1391747454230452, 0.15820220723981782, 0.14309402663416837, 0.15686227653903329, 0.19926848265910635, 0.35375513043439466, 0.184657286194297, 0.21213612692701322, 0.1931692001264237, 0.2922829846547008, 0.22385457876034076, 0.20083115471070268, 0.22439059089987012, 0.3445126265307722, 0.37436968421671557, 0.33588450154787364, 0.34517661236023145, 0.34759337460629447, 0.3563838261502327, 0.3845021073631165, 0.3750155213034383, 0.42399185254321003, 0.296269850134396, 0.27093502004820214, 0.27581808925722484, 0.27650562610916696, 0.30861781005084, 0.2684491033992463, 0.27995531701488374, 0.3109881289187697, 0.2885690440117269, 0.20645998992404524, 0.1879401734096059, 0.1965574010762159, 0.19663725519524378, 0.20167019480182613, 0.19550049049763563, 0.18871782219586453, 0.21098609287582326, 0.2009724914183676, 0.22758868698003365, 0.30256125785307963, 0.23268017487268422, 0.3395950247454199, 0.22610332828697832, 0.32436490230293047, 0.22307887507123114, 0.20461592727201006, 0.28065025895738116, 0.6969556494509772, 0.7641802270202511, 0.7084850425312759, 0.7227012255182566, 0.7909393747824669, 0.20241078238656762, 0.7901369546262551, 0.15651936465872918, 0.6445118171239483, 0.16826089145878287, 0.20644106801472317, 0.12481032835789485, 0.19286135733654886, 0.19912520005786016, 0.6374025887874817, 0.20781211049397208, 0.7489769220594007, 0.2108836374707408, 0.19674842771033318, 0.20213459590592808, 0.18898481684104584, 0.19431849479767493, 0.21561362984729926, 0.23229763786891988, 0.19008827911019266, 0.18959967342038753, 0.18270059463753374, 0.08769618269255575, 0.08271042677199025, 0.10020978815121706, 0.0941270495291694, 0.08276730404450972, 0.08853949744487055, 0.09628231713892887, 0.09262385557086295, 0.07502837302588328]}, "mutation_prompt": null}
{"id": "741bd21f-3340-42b8-962b-bc9378505730", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim\n        self.mutation_factor = 0.7  # Improved mutation factor for better diversity\n        self.crossover_rate = 0.9   # Increased crossover rate for enhanced recombination\n        self.local_search_intensity = 5  # Slightly intensified local search\n        self.adaptive_threshold = 0.2  # Fine-tuned adaptability threshold\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.01, 0.2)  # Broadened randomness for enhanced precision\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Increased for deeper fine-tuning\n            self.mutation_factor = 0.8  # Further enhanced exploration diversity\n            self.crossover_rate = 0.92  # Adjusted for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedAdaptiveDifferentialSearch", "description": "Enhanced Adaptive Differential Search with Stochastic Exploration to optimize balance between global exploration and local exploitation.", "configspace": "", "generation": 44, "fitness": 0.43696573901053326, "feedback": "The algorithm EnhancedAdaptiveDifferentialSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.25.", "error": "", "parent_id": "8679cd6d-9936-4560-aab4-8ed0323ea1a6", "metadata": {"aucs": [0.8165022551032936, 0.8151414785821158, 0.8104017805066459, 0.8260210335579282, 0.8191055304869561, 0.8225367729827752, 0.8312797040917737, 0.7938256281760012, 0.8348000226936726, 0.6768818758274997, 0.6608885030500447, 0.6804036361628671, 0.6809519051926816, 0.6685585278693134, 0.6716912721890818, 0.6656476150536569, 0.6922169549769861, 0.7103079698884993, 0.26285410260716646, 0.16524864151918006, 0.11858752819542429, 0.15524866983167884, 0.1434640945437291, 0.15921705523072704, 0.40418802997308945, 0.3496078162267776, 0.15000974703079095, 0.14067045429838487, 0.1328492407468288, 0.13559037709684585, 0.13331682079162932, 0.13351426946225853, 0.12763396421293405, 0.1584213914112057, 0.14415852793311845, 0.16147011111037768, 0.9737091626370729, 0.9558905107560414, 0.941159543763219, 0.9800792419736793, 0.9866741008928313, 0.9512990156533666, 0.9504625457877824, 0.9704681694957317, 0.9835606955211489, 0.5297304422400441, 0.49307556453517287, 0.5464939280275453, 0.5383500472548972, 0.5044781898615529, 0.47584165958476454, 0.55082009997102, 0.526278288345186, 0.491348536491929, 0.8212019079013377, 0.7331284791241786, 0.7841986720425298, 0.8401179467160104, 0.852424910579294, 0.849204453284627, 0.787292447061432, 0.7787049844297166, 0.8083026423381604, 0.5610865730414769, 0.4154790813554513, 0.47055885200109693, 0.4347189674149776, 0.5463655631214128, 0.5069497821263147, 0.49015526372233864, 0.6333250798634217, 0.519149044157582, 0.3485905355739396, 0.521770292385245, 0.5604332785688427, 0.5690925051998277, 0.5292678008364511, 0.46049030442096583, 0.5143783779432596, 0.4973066354353798, 0.458795363128098, 0.43329782812112105, 0.48565525566232304, 0.43724802540730057, 0.4078812878096221, 0.4258989462756574, 0.42774260776165707, 0.43511219794721223, 0.4440789692132705, 0.45712065352667564, 0.5848012853004299, 0.5442147844929688, 0.5724485334180798, 0.5495022818895412, 0.5964612503688892, 0.5590052010940291, 0.6071770064809203, 0.5812407538647368, 0.6128075035544887, 0.12271924096472198, 0.1972897355682075, 0.20628077923363985, 0.28200803405367214, 0.3071730910179339, 0.297606488667959, 0.11948861843947778, 0.3199035303649346, 0.2039047417461708, 0.3430980661677733, 0.35216647854880545, 0.31720163532687273, 0.3645953496755826, 0.34871180814936487, 0.37775662489709316, 0.3406576691159475, 0.35410853637334017, 0.35509237585593467, 0.7022200610128475, 0.7080714425782938, 0.7236404191207737, 0.7152510968176228, 0.67815312714533, 0.7435830340539633, 0.7124067606811213, 0.7074076716760387, 0.6818166237423386, 0.11218502622755955, 0.1431665860722886, 0.4074755149187076, 0.13843271684815006, 0.1457328454447534, 0.15377474207297404, 0.15273480620603352, 0.13547365453387283, 0.13650066767823354, 0.21025711642217015, 0.1804199478184091, 0.20769682886612395, 0.39999935751324367, 0.44389478366254964, 0.2661535192027995, 0.2675186613557141, 0.3123289760185537, 0.23777422336671072, 0.36323815797177106, 0.40007186378586257, 0.37021600057338466, 0.36736708991949396, 0.37480627957283696, 0.3767371713894746, 0.37981991807275106, 0.41070882143385046, 0.4145330851495663, 0.31320715463731585, 0.2945755276754829, 0.2933876858121076, 0.2746880663731125, 0.3012415473257075, 0.31263273469975306, 0.3394440908948898, 0.3368626918846336, 0.34034867767137456, 0.19086468737150064, 0.21626260091430027, 0.17742800339974618, 0.196958745305987, 0.1865279792833996, 0.2129413354138967, 0.20064392650993979, 0.26849498809593475, 0.2247297283805979, 0.23070473296971572, 0.21257602823506594, 0.23542025838642977, 0.222333391384407, 0.36433456937702513, 0.23651434217173806, 0.2935819447905086, 0.29384012812314264, 0.19924695251376434, 0.7951664737824453, 0.8027976511649917, 0.16634140513048534, 0.8376555170434904, 0.1979821025648304, 0.7780506432881542, 0.1942863446407168, 0.8356470248583254, 0.20472365805141857, 0.7734337655417574, 0.2072271649575852, 0.7388896837977331, 0.8070632758826618, 0.8663527565767819, 0.7951915193253759, 0.20873656904168925, 0.8417756618218469, 0.1546279959780058, 0.18502525285421567, 0.18796142454002318, 0.19420348339968263, 0.23568754551494775, 0.2360003443534815, 0.22142009988167444, 0.1962075660502558, 0.18279040544826608, 0.20323814904104742, 0.09025039789294875, 0.08938997538360749, 0.09546478403357628, 0.09767181790975576, 0.09241906339448192, 0.09046798230828568, 0.08627017348460908, 0.08805053896618442, 0.0878903183055485]}, "mutation_prompt": null}
{"id": "7d72611e-9650-4f98-ae11-85150fb1c33b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Slightly reduced for faster convergence in higher dimensions\n        self.mutation_factor = 0.6  # Further refined for better solution quality\n        self.crossover_rate = 0.85  # Adjusted for dynamic search space coverage\n        self.local_search_intensity = 4  # Balanced for exploration and exploitation\n        self.adaptive_threshold = 0.25  # Enhanced for condition-based adaptability\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.01, 0.15)  # Smoothed randomness for precision\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 6  # Moderate increase for fine-tuning\n            self.mutation_factor = 0.75  # Enhance exploration diversity\n            self.crossover_rate = 0.88  # Slightly adjust for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptiveDifferentialSearch", "description": "Adaptive Differential Search with Dynamic Adaptation and Exponential Crossover to balance exploration and exploitation across varied dimensions.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8679cd6d-9936-4560-aab4-8ed0323ea1a6", "metadata": {"aucs": [0.831882359462147, 0.8493957357969371, 0.8521300502471802, 0.8330821829957975, 0.8459109279769772, 0.8594480192114499, 0.8296985803836066, 0.8566824559931441, 0.8460276356791733, 0.7358915376055858, 0.7570780996168267, 0.7373719401204413, 0.7174851785441287, 0.7214970798264696, 0.7371866584939062, 0.7207046437581855, 0.7556733047644328, 0.7342494800849062, 0.16270483347555076, 0.1570280111218756, 0.18616653288682583, 0.2015159493222024, 0.18480212725714584, 0.38447885331725207, 0.1942944640395431, 0.16334092233884434, 0.3714090452410662, 0.13431525842074754, 0.16175401029553882, 0.13993392512046865, 0.15885549169008206, 0.21066932943872807, 0.14513479158868992, 0.222500640133782, 0.1549714947027806, 0.13311619654224027, 0.9711618884327861, 0.9366574444172769, 0.9370274524099833, 0.9524057194638198, 0.9722343384989788, 0.9408818381667752, 0.9459708989026393, 0.9893961212786001, 0.9547205821606073, 0.5920468597724862, 0.5482257977504926, 0.5617344587158022, 0.5343334185361077, 0.5521921555981235, 0.6133368277583611, 0.5964897297662026, 0.5507025149572553, 0.5539214463193656, 0.8764778993424779, 0.7733761004618789, 0.8625085092529463, 0.8219278341565238, 0.849531137032935, 0.8556128780090255, 0.8462794633517108, 0.2286642328843731, 0.8147509838830624, 0.5694956927261017, 0.4632414827197635, 0.45305603806031003, 0.49737388005505767, 0.5063000584557832, 0.4444706491253514, 0.5934128759107096, 0.5535328095399141, 0.4784589632921127, 0.5181477040229605, 0.3844314067648905, 0.43370670248294363, 0.46554104509747685, 0.45988010016021386, 0.5393416885927069, 0.45193157833016073, 0.4939864877780549, 0.4922063987261589, 0.40765770038080473, 0.448050796741041, 0.5146923710734439, 0.48267415626639787, 0.46034924920969766, 0.4182849025962603, 0.4414186081532335, 0.435866030509774, 0.4615135005889953, 0.532918344858274, 0.49805082723922955, 0.5603177807926163, 0.5276942623079561, 0.5650873539198598, 0.581187566353703, 0.636558378601517, 0.6128695174175303, 0.5860338014078985, 0.1335904671718663, 0.15266569033309885, 0.27957259191477857, 0.21489293101288154, 0.3404827083893862, 0.18797881247726422, 0.15642865653261617, 0.19658509125172063, 0.17621024640998006, 0.3266375682779773, 0.34006889435251053, 0.34563218925816164, 0.3510191283251711, 0.40260041643147837, 0.3729576427081136, 0.3576833444048647, 0.3781510260060509, 0.3729020690715592, 0.7142299653147466, 0.7103770225603587, 0.7557775421351769, 0.7106921312314307, 0.6981164867424134, 0.7230124763626141, 0.7247839390949965, 0.7421573486783931, 0.7103610511705292, 0.14532830524103724, 0.13272771489337287, 0.14377421608149765, 0.12299344588401329, 0.13908591057924802, 0.15012146342108823, 0.1351353931174628, 0.13523742168307729, 0.11839420385166288, 0.45303155970748665, 0.4805546813578381, 0.22442398037626488, 0.2434328493601018, 0.33077976158705813, 0.19526337560718887, 0.22151290528112788, 0.2075480680379188, 0.2432382188676928, 0.4070955052123195, 0.387317784131576, 0.4017255048191498, 0.39697147885149087, 0.3955648674628205, 0.42036934494313716, 0.43723010313764676, 0.44650297625573665, 0.4489104314065787, 0.30918687202391715, 0.34328369768909395, 0.32998884147076957, 0.33841964476322617, 0.3219358875144859, 0.35642115378789074, 0.3814928206510888, 0.35359920825673885, 0.3545651361211183, 0.2226197130719696, 0.193908560812736, 0.20337661644818905, 0.20077344265876051, 0.23491424490126434, 0.2270779361041636, 0.2019685391818039, 0.22020120483762562, 0.21166472497510935, 0.22616330452637445, 0.2354829119998869, 0.21106762757942155, 0.20886964593113566, 0.44630058225258895, 0.39030873436548263, 0.22978569267687654, 0.4179378470356405, 0.22329707023387324, 0.20727220028701854, 0.8287558360944044, 0.8317172381851095, 0.1760918558293746, 0.19446465016214698, 0.19252307126395607, 0.7444662291346047, 0.7898194647455795, 0.7947644469869911, 0.20610619378527606, 0.7554776621942545, 0.6781181858635563, 0.2017269629134697, 0.836071723113248, 0.8345707793462944, 0.20958511906959054, 0.21141017376115778, 0.8296875981891039, 0.22724236514005536, 0.21071098004832134, 0.18772732249097868, 0.1827482878534068, 0.21030684671570243, 0.20411004470895855, 0.3671673604635577, 0.18507946554925947, 0.20636227609355806, 0.09300664487063293, 0.09679256128865288, 0.08642664263147859, 0.08671625059018784, 0.09209716750677366, 0.09516201434788285, 0.09180319663670011, 0.08662423868042368, 0.09222804419907116]}, "mutation_prompt": null}
{"id": "71814c72-796e-4ce1-a32a-9fc9485dc28e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 6 * dim  # Increased population size for more diversity\n        self.mutation_factor = 0.65  # Slightly increased for better exploration\n        self.crossover_rate = 0.9  # Enhanced for broader search space exploration\n        self.local_search_intensity = 5  # Increased for more thorough exploitation\n        self.adaptive_threshold = 0.2  # More sensitive to adapt based on fitness spread\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.01, 0.2)  # Increased randomness for broader local search\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase for detailed exploration\n            self.mutation_factor = 0.7  # Adjust for more uniform search diversity\n            self.crossover_rate = 0.92  # Slightly increased for more comprehensive recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedAdaptiveDifferentialSearch", "description": "Enhanced Adaptive Differential Search with Probabilistic Parameter Tuning for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 46, "fitness": 0.40902425358426203, "feedback": "The algorithm EnhancedAdaptiveDifferentialSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "8679cd6d-9936-4560-aab4-8ed0323ea1a6", "metadata": {"aucs": [0.8191307341622299, 0.8098866748368234, 0.8037384749442067, 0.8061721862424547, 0.8266058862992463, 0.8161894894656453, 0.8185534027736496, 0.8081858121998888, 0.835035253718744, 0.6821224114471405, 0.6792801117378872, 0.7016798789296215, 0.6862577794401377, 0.6834400524296427, 0.6549918890227239, 0.6626660901115122, 0.6816652751609217, 0.6686080439209103, 0.13196245661339856, 0.15082930695200614, 0.12677780799746274, 0.12169809548507915, 0.13446814620985914, 0.13783300111022068, 0.13876280196934532, 0.16057632215282536, 0.14163140650455375, 0.12467385850089918, 0.10917577738517215, 0.13425843688475958, 0.11698027509997477, 0.1180905582626699, 0.12545076223320262, 0.1253779038609748, 0.12814452307454627, 0.13043730093771033, 0.9012643860543947, 0.9227894822453749, 0.9510004245770646, 0.9083281150091931, 0.9804635792358052, 0.9345343410865969, 0.935012685350697, 0.9648007158283466, 0.9407010187374699, 0.5654081496859424, 0.5484028943647091, 0.5531759136361503, 0.5035071363133476, 0.5290928657427694, 0.5475391061161532, 0.5546018606368582, 0.548973691765146, 0.5066194271020601, 0.7528630389922542, 0.7773531131732566, 0.8387062913441711, 0.8159024188533774, 0.8395946884782031, 0.7971784172543284, 0.7560144917677958, 0.7836243470411555, 0.7800763634838728, 0.37023495606363455, 0.4392201803459511, 0.41670635480754303, 0.5215837883184357, 0.42996356175643347, 0.4965413469141011, 0.4206624422080223, 0.4237973041834172, 0.4142574855034863, 0.44666830319424433, 0.32862973410207763, 0.37527548253421084, 0.5193758121787184, 0.4990331784391613, 0.4727461404704376, 0.4730115706878536, 0.46065406532801434, 0.3871726666931501, 0.4619079671993084, 0.500608950378601, 0.41150334647296627, 0.4727817812882299, 0.44733221395452305, 0.4211193863060132, 0.44373258479554856, 0.39240050061555654, 0.459627032870385, 0.5985719737599299, 0.5570800410339346, 0.5327933203181587, 0.552914668175174, 0.5770346358470275, 0.5956192650599252, 0.6240942748543483, 0.6170538833707597, 0.593361502722335, 0.09581075090346858, 0.2348348432473597, 0.14993873903926414, 0.2780509269819006, 0.27341500452382383, 0.2237726216519812, 0.21033125478126757, 0.2184224406589519, 0.15992660572225992, 0.3709478793090074, 0.3426065371623812, 0.34659338528011396, 0.362437023577579, 0.3774084389240937, 0.3733449833090735, 0.37176237278982105, 0.3602449860630219, 0.32471705982434507, 0.6954417344194941, 0.7524296639480327, 0.7598400039664982, 0.7221012205251547, 0.716647832725132, 0.7069114097912839, 0.7210258084666522, 0.7055284170246798, 0.699373427602153, 0.13699924963151822, 0.12543714612338208, 0.139570461474811, 0.11632284355520273, 0.13298959156441248, 0.1440283517926818, 0.1324628693784683, 0.1446311642625029, 0.10947122213149374, 0.3567907578852024, 0.33283781576257776, 0.18254883198804528, 0.4123714954004889, 0.17648611851851348, 0.1584034340809174, 0.40822760557298976, 0.20116802987635862, 0.21484679794566963, 0.3746434601655402, 0.3789115846175358, 0.39757173495438436, 0.3910204302443765, 0.380211172280275, 0.3949883079077432, 0.37142655956783766, 0.43285845018647084, 0.3734549173478937, 0.29984641929628675, 0.29944254376323765, 0.3355754937652252, 0.2765545646097056, 0.2812659009901214, 0.3064129861265892, 0.32979611889116045, 0.3216712871591171, 0.36063993544122164, 0.2130471788061532, 0.20329164198965632, 0.19115824876399645, 0.2174464653472944, 0.19942013195499098, 0.19997948150284817, 0.1989525037019252, 0.20363962918513645, 0.19446613591517092, 0.22838876050960766, 0.4382630543331003, 0.20770643756141127, 0.22003385435413791, 0.3160677590683513, 0.20232478608013804, 0.22858758335773677, 0.3146540450621458, 0.20455956106483864, 0.1628065175840846, 0.1740981980291907, 0.15141006774699672, 0.16755949814552062, 0.7467798313391201, 0.19222194191598896, 0.16597125402559554, 0.6604868262576005, 0.806279453139319, 0.7901299537099495, 0.16582263988748058, 0.7944702385320139, 0.2030725584535117, 0.2053205487315075, 0.1627269155546841, 0.12482880112489236, 0.8240429854569342, 0.21043636919425357, 0.18876103685631462, 0.19903395052341388, 0.18547038599785948, 0.19183915427662834, 0.20583788741703613, 0.19247123590163373, 0.2147209761528227, 0.18558225655730165, 0.20119247214257374, 0.09246106573328383, 0.08633228482540323, 0.10022767541433297, 0.08839060279714561, 0.0883951965298998, 0.10019558727388522, 0.08791061877323791, 0.08441879291906085, 0.08585585553657527]}, "mutation_prompt": null}
{"id": "400fbcf3-7130-4c98-a502-5e58346b6cae", "solution": "import numpy as np\n\nclass HybridEvolutionaryLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 7 * dim  # Increased to enhance initial diversity\n        self.mutation_factor = 0.55  # Adjusted for better exploration\n        self.crossover_rate = 0.9  # Increased for higher recombination probability\n        self.local_search_intensity = 5  # Enhanced for better exploitation\n        self.adaptive_threshold = 0.2  # Refined for more dynamic adaptability\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.01, 0.2)  # Increased random step for better precision\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase for intensive fine-tuning\n            self.mutation_factor = 0.7  # Adjusted for better exploration control\n            self.crossover_rate = 0.92  # Enhanced for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "HybridEvolutionaryLocalSearch", "description": "Hybrid Evolutionary and Local Search Algorithm with Adaptive Parameter Tuning for Efficient Global Optimization.", "configspace": "", "generation": 47, "fitness": 0.42224049051279794, "feedback": "The algorithm HybridEvolutionaryLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.25.", "error": "", "parent_id": "8679cd6d-9936-4560-aab4-8ed0323ea1a6", "metadata": {"aucs": [0.7874411341722067, 0.8017608752497958, 0.8131112928492611, 0.8236837490087168, 0.8022061727541819, 0.8082647687333782, 0.8213466526609344, 0.8095482315739362, 0.8139468887172827, 0.6459805965258737, 0.6875529503636575, 0.6659280214499746, 0.6466486837164188, 0.6540189357212984, 0.667686436005573, 0.6771839139200014, 0.6714244818546039, 0.6625042888942387, 0.14598482096209897, 0.150076960601622, 0.1339594723653601, 0.1485620924742992, 0.14619469164093568, 0.2116841090166678, 0.2091407900894493, 0.13644170828002788, 0.15535561012624988, 0.11379442327439426, 0.14957608576514214, 0.12003775472725664, 0.13403104075446448, 0.12536402598013685, 0.135237342784151, 0.12887519289418947, 0.13301473548506382, 0.14572552346455248, 0.9781126512338431, 0.9522999685597532, 0.9281905300214142, 0.951515751952412, 0.9011359673953296, 0.9409230658253459, 0.9681297584894845, 0.9559068352358608, 0.9595947684274025, 0.5332766418973202, 0.49479829011287413, 0.5116421658330481, 0.4821218106890026, 0.4866243864739149, 0.5039285035994343, 0.5103422735980867, 0.5387769344610314, 0.506705504669541, 0.8140350650145828, 0.7903362342891419, 0.7783024773707968, 0.8123132102912642, 0.7499948883395312, 0.8099847040929545, 0.7906934357063964, 0.8197545029074575, 0.7900741797341769, 0.4938421480602809, 0.31738363462323704, 0.6180516959670912, 0.3439976585849893, 0.13393859362248006, 0.4397240652698332, 0.41715954740001493, 0.39924377615603523, 0.5115988783680601, 0.4319293255851323, 0.4259087637472265, 0.40967348314013996, 0.4340148128208733, 0.5155584133739606, 0.529608058859097, 0.5267650930803378, 0.37725831231172324, 0.5017890662322217, 0.45272773764944363, 0.45945923693257196, 0.41085353582593265, 0.4728217687646814, 0.49783485046207354, 0.46845793735422125, 0.44937948807588446, 0.4479544263186215, 0.4753316634829171, 0.5645165553383491, 0.5556435311704806, 0.5479297942159335, 0.6012088649262213, 0.545867771270846, 0.5058116872353747, 0.5971171283609558, 0.5943692552417656, 0.6016420170384199, 0.2122301170783557, 0.29636445055993477, 0.20418834722790546, 0.3378825240509201, 0.3479247475011614, 0.3064758892608469, 0.18924432141214031, 0.18243368996001896, 0.2547095977985552, 0.34418282528085187, 0.34768938004423167, 0.35579971415535716, 0.3742938627884037, 0.352622386527349, 0.38004919630335976, 0.3366949853967498, 0.353745648401523, 0.3627995879436462, 0.727491109621949, 0.689471573105557, 0.6588929929631778, 0.7102780940541753, 0.7162594284032968, 0.6912465997726644, 0.677133559389716, 0.696458651573043, 0.6781934530943294, 0.12017145112872984, 0.1277564420434797, 0.14640474908884948, 0.13617332421398698, 0.1524880974678977, 0.14444505291871357, 0.12967345246760142, 0.11465007441727026, 0.1284004314640862, 0.31754167591395366, 0.26405197445695516, 0.18592977635153707, 0.16676890959100543, 0.27939479156086067, 0.22625411658129213, 0.1827011640838162, 0.2480134658345563, 0.22877667609722852, 0.37998366955877405, 0.37999508952844263, 0.4277807199198205, 0.386657958582182, 0.393945120990598, 0.4247322066605831, 0.39026388674419255, 0.4293942168001278, 0.3829876456901137, 0.34205364755536616, 0.3058892036810026, 0.3254202518382856, 0.29471205512182674, 0.30689656338656846, 0.3179235226185515, 0.34940758014516893, 0.2991600972222157, 0.3252165091914546, 0.20559048854836504, 0.2134063587277546, 0.1807445581555075, 0.20544520870331617, 0.22071863751505738, 0.21288116455910178, 0.21312125058984455, 0.21032906269153573, 0.2090166921513965, 0.4577342961808295, 0.24590236487946115, 0.27664207092194015, 0.5425368010675926, 0.3561679787835602, 0.21587194452251568, 0.2125386885991084, 0.21123588586851305, 0.2953657642731097, 0.8192645695558634, 0.8049634677319965, 0.1843109361668569, 0.770780992353162, 0.1960448691913046, 0.7654534183423408, 0.7444235188031412, 0.7689180010264538, 0.8277476099155782, 0.16926967905183776, 0.7433361453725702, 0.20509883021151054, 0.665785541162482, 0.16656295049290748, 0.2040997397906541, 0.20950822176220896, 0.7184038277018471, 0.21073892373890724, 0.19525158668937703, 0.1959887420571963, 0.22161287139042984, 0.20126293432837927, 0.19762578343071746, 0.19746392598665974, 0.1861636721542531, 0.19353190832781286, 0.20367183684748513, 0.09774065727236847, 0.08084323602525312, 0.08538522803712134, 0.08078030230182576, 0.09417915380792141, 0.08417746679473093, 0.09359910147773098, 0.079315619927527, 0.08943762226488994]}, "mutation_prompt": null}
{"id": "097cb011-0f87-4273-802a-eb52d4609ffe", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 48, "fitness": 0.463987024151269, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "8679cd6d-9936-4560-aab4-8ed0323ea1a6", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "31041a73-47e5-4421-abcd-608a60f088ca", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "9ac6a210-7816-4c6f-b8d5-5c9dbafe19ba", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 30)  # Larger population size for more diversity\n        self.mutation_factor = 0.6  # Lowered for more refined local search\n        self.crossover_rate = 0.85  # Adjusted for better exploration-exploitation balance\n        self.local_search_intensity = 6  # Increased to boost local search performance\n        self.adaptive_threshold = 0.15  # More sensitive adaptation trigger\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def quantum_differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def enhanced_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)  # Narrower range for fine adjustments\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Further intensified for thorough local search\n            self.mutation_factor = 0.75  # Adjusted for increased diversity\n            self.crossover_rate = 0.9  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.quantum_differential_evolution(func)\n            self.enhanced_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "QuantumInspiredDifferentialEvolution", "description": "Dynamic Quantum-Inspired Differential Evolution with Adaptive Parameter Tuning for Enhanced Convergence.", "configspace": "", "generation": 50, "fitness": 0.40648624185031546, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8123103976622026, 0.8074023864076451, 0.7953568790490375, 0.8144672063987053, 0.8167923346923758, 0.8160729457083474, 0.8168814075079399, 0.8072016423342693, 0.7871328809253053, 0.6500780692832837, 0.6630053787868097, 0.6546541559808992, 0.687038486415477, 0.6889922383371074, 0.6601750844823278, 0.6534996664150783, 0.6743743086563727, 0.659009389396398, 0.3045469295306674, 0.1468857649914025, 0.14267264845832273, 0.1651248912764982, 0.19131867550698445, 0.205259243907843, 0.15131066941341398, 0.24915835596415647, 0.1491075655749542, 0.13060572455840103, 0.1324048067443424, 0.23651883842805765, 0.13714545249608145, 0.12185770963187315, 0.13924772584640466, 0.1308778149201486, 0.13230214565939658, 0.13024456327075074, 0.9422134580139988, 0.9523849604873031, 0.9614673566472437, 0.9754436030080392, 0.96052338769134, 0.9361786560255443, 0.9321180724565347, 0.931939853324552, 0.9776122012733813, 0.48176929649628375, 0.5110385518232927, 0.4536680451010552, 0.5087634825848415, 0.4952735201762164, 0.5019456902845665, 0.5290856958971782, 0.49908005690337043, 0.5186842387801653, 0.7770813002747564, 0.7388355026328028, 0.7319349387171126, 0.7791671905350501, 0.7725999149214486, 0.8371490617368801, 0.773522327465075, 0.8053673766814577, 0.8124184645091712, 0.34389218026008717, 0.39817751738933815, 0.36310613599031494, 0.36581393856605493, 0.40490720181826867, 0.43819522383620446, 0.4647796237752626, 0.4591429788486192, 0.3498312523079189, 0.42772896303146823, 0.4079415845112112, 0.37765382625052446, 0.5110342373025271, 0.31291461225991957, 0.4470693115737394, 0.46584490542356405, 0.3720443589647705, 0.3813207735553351, 0.3323924797837161, 0.37913387985740565, 0.35361733815266017, 0.0965944937331964, 0.3606735049423052, 0.3544837485849559, 0.3810573455930317, 0.39771084508557986, 0.3936467212142519, 0.48386737637352717, 0.49077920776866935, 0.47498341309458936, 0.4952572755627621, 0.5108707035312704, 0.4825764649892835, 0.5471998329607686, 0.5516820306735879, 0.4727280931868383, 0.11017203129929953, 0.11227110983069633, 0.1187705249300487, 0.32750830924497376, 0.2966983149380136, 0.1798905815759847, 0.17783342621496812, 0.19993175850202372, 0.1520453951217371, 0.3359793613886465, 0.30491369161764104, 0.3125207591760696, 0.3349642292387973, 0.3215967667137576, 0.35504498183881317, 0.31210827948571873, 0.31826267182576407, 0.323910814871309, 0.7118847177194073, 0.6835938012808107, 0.7005035765252862, 0.6753061222042676, 0.6728512746720681, 0.6834222458893751, 0.6885912550665904, 0.6688386626419451, 0.720124375790082, 0.12742590011536936, 0.12487492134743139, 0.13992338578384755, 0.14192575238997818, 0.14117497175786242, 0.11773106764528407, 0.11725166068266057, 0.14895939352746645, 0.15239537266644876, 0.23375881235063978, 0.18902466789768158, 0.21318883510887765, 0.30027211006427146, 0.21082630529052016, 0.31393574198474117, 0.31710836049374924, 0.2143666993256358, 0.20730584009835784, 0.3999353396185159, 0.3771201886221558, 0.36427187524183213, 0.3941619815630826, 0.38843948906600545, 0.3545194765677354, 0.39525989992944, 0.3825724180946186, 0.3995969629674305, 0.31326601520207464, 0.28314987496941857, 0.2940919374030485, 0.2624759793429221, 0.28113055154760125, 0.29378576614118923, 0.3221324416626161, 0.31219140409550505, 0.3184924416483039, 0.2225450422673786, 0.19846726227969758, 0.21205498629680086, 0.21518396372945714, 0.21831275167178943, 0.25156263310020577, 0.2288651474481036, 0.20593226424340227, 0.20049970109569182, 0.21351957547105238, 0.25323009277223096, 0.3706030049421032, 0.2318068379988234, 0.23199402387569912, 0.2122043459356855, 0.20244356277024522, 0.518419738586154, 0.38431601427565165, 0.829089118219671, 0.7733863922693689, 0.17221471693270374, 0.795294081026967, 0.1955878510166451, 0.7700350553606407, 0.7197614696816501, 0.20321384710245316, 0.6856481748817975, 0.7901806167527068, 0.1667532824467829, 0.7344585430879096, 0.8107450627876478, 0.20070688714194462, 0.2011276628353874, 0.15525602595144938, 0.752529256986139, 0.2080740765397181, 0.19919959884441374, 0.2091833664515289, 0.19238879193042024, 0.1856307698732771, 0.18513568127195068, 0.18800759898190644, 0.1961176409071872, 0.1848581841996766, 0.19896024488211228, 0.08110809288732157, 0.09058732124601387, 0.08089490698161228, 0.084906017484639, 0.08357267367519128, 0.08809661615443853, 0.08340230480838495, 0.0870648479035877, 0.08935365976284737]}, "mutation_prompt": null}
{"id": "a98c6bd7-f832-4b2e-bc50-49b0cb7b68c0", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "7834402c-5f0d-4f15-a984-9566bf08ce2e", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "d7b52159-6ed8-4ed4-9977-965bcec0610e", "solution": "import numpy as np\n\nclass HybridAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.85\n        self.local_search_intensity = 6\n        self.adaptive_threshold = 0.15\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_fitness = np.inf\n        self.used_budget = 0\n\n    def particle_swarm_optimization(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            self.velocity[i] = (self.inertia_weight * self.velocity[i] +\n                                self.cognitive_component * r1 * (self.personal_best_positions[i] - self.population[i]) +\n                                self.social_component * r2 * (self.global_best_position - self.population[i]))\n            self.population[i] = np.clip(self.population[i] + self.velocity[i], -5, 5)\n            fitness = func(self.population[i])\n            self.used_budget += 1\n            if fitness < self.personal_best_fitness[i]:\n                self.personal_best_fitness[i] = fitness\n                self.personal_best_positions[i] = self.population[i]\n                if fitness < self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best_position = self.population[i]\n\n    def differential_mutation(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8\n            self.mutation_factor = 0.7\n            self.crossover_rate = 0.88\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.personal_best_fitness = np.copy(self.fitness)\n        self.personal_best_positions = np.copy(self.population)\n        self.global_best_position = self.population[np.argmin(self.fitness)]\n        self.global_best_fitness = np.min(self.fitness)\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.particle_swarm_optimization(func)\n            self.differential_mutation(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        return self.global_best_position", "name": "HybridAdaptivePSODE", "description": "Hybrid Adaptive Particle Swarm Optimization with Differential Mutation and Stochastic Local Search for Dynamic Balance of Exploration and Exploitation.", "configspace": "", "generation": 53, "fitness": 0.28262292651493875, "feedback": "The algorithm HybridAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.7357973409406473, 0.7855896153940096, 0.7493713980644309, 0.7974335288728528, 0.7838135786526413, 0.6929825190096005, 0.7736629139248138, 0.7960746040352593, 0.7683419185280371, 0.5398898791508009, 0.5030322171680595, 0.5368582144509648, 0.5395700274268698, 0.30246284670730395, 0.5130992229989063, 0.4541324721715265, 0.5121694658738525, 0.552529280260204, 0.16904519417981523, 0.11593853674121923, 0.1822142961691845, 0.14478084356804033, 0.14090008326566206, 0.11290901892417338, 0.14540558961656025, 0.16794307989307056, 0.172033448893405, 0.1431429234066418, 0.12752456075965546, 0.1494128517782154, 0.12405378899282982, 0.10911078981636835, 0.1224767417953313, 0.09009850542693343, 0.11761043526432513, 0.1251264612833647, 0.9813870334671695, 0.9758992671647971, 0.990799398204339, 0.9923084033719468, 0.9885466885020902, 0.9894020303255066, 0.9885657563192718, 0.9886485348624745, 0.9773804244353425, 0.557403208054079, 0.5411113352563661, 0.5033958042049973, 0.4976842445547299, 0.5456000404441919, 0.4544013607547489, 0.5443279188377355, 0.35166601123758323, 0.454483468994926, 0.20633964475971356, 0.21532683581826362, 0.1449845881427374, 0.8078188794016785, 0.21083638878668687, 0.27299915918573836, 0.1631623220597036, 0.707514976326723, 0.22879057980327433, 0.18476074170406498, 0.18342192741534014, 0.17470175406262534, 0.2085982512239587, 0.184025489657481, 0.17440309998202141, 0.1887201307880243, 0.18690953934354548, 0.2165059061405531, 0.19659767160903496, 0.20273607021941675, 0.19065322487965042, 0.18572658245426132, 0.21267732673657413, 0.27362833172119294, 0.22417110098040371, 0.09978208306656888, 0.11385713592880242, 9.999999999998899e-05, 9.999999999998899e-05, 0.06921557441399073, 0.016324942898312433, 9.999999999998899e-05, 0.013695251450677626, 9.999999999998899e-05, 0.005887019101993629, 9.999999999998899e-05, 0.12216181606564658, 0.037443721794079066, 0.06230704271767007, 0.07430099650064803, 0.005471038220331348, 0.014410665104735876, 0.04324128092769319, 0.05618419920101858, 0.04721112281590123, 0.1494672812597828, 0.14642755901328253, 0.14190288647059557, 0.0700873908167039, 0.07083945667419156, 0.06702892286462481, 0.0880733392693468, 0.12581167276777883, 0.10682279730657263, 0.1483948390455877, 0.0960046909379354, 0.12197797273567867, 0.03960829316417824, 0.02851166333842703, 0.021317820226299022, 0.05501869336509824, 0.10876651683922067, 0.07731838550675896, 0.5155426241845374, 0.5112832912720287, 0.5151170563052183, 0.49676954753960867, 0.5041462306533694, 0.49879372653451115, 0.4927285218901192, 0.5223771381656354, 0.5358114419662756, 0.062389459721595486, 0.07778380814690045, 0.07662784473514839, 0.1057415128198389, 0.10880917423456737, 0.10963217691045335, 0.08407272580574499, 0.11441121194107984, 0.11802624313945831, 0.1849166048628068, 0.27607465135869713, 0.17953623015414666, 0.15490378433173757, 0.35213387062088664, 0.19054160341271498, 0.18567377840601396, 0.18419606201804095, 0.20487072198767498, 0.44115056764910365, 0.2472296222928987, 0.2823466145511013, 0.3726705332256065, 0.3260735520793815, 0.22300960083118682, 0.22005737551637727, 0.3079575089282903, 0.4383579636594286, 0.24143174082091956, 0.32477780950963375, 0.28623375955960473, 0.27097453900249036, 0.26414361384114815, 0.31654284832370794, 0.26476162366017364, 0.26404943192862673, 0.1188181665423308, 0.21140843949638988, 0.23423149788876718, 0.2128077109520956, 0.1841837798593886, 0.22226620145068943, 0.2108256667714612, 0.21152622013891176, 0.18482067770582677, 0.23201568450972687, 0.218703097604401, 0.6275646602642142, 0.2314332137149604, 0.24395620662082151, 0.21944309528249528, 0.2180154920605316, 0.20376679766813566, 0.19987842550732238, 0.19423329706470038, 0.8622426852351205, 0.1750247601855992, 0.15190987353247398, 0.8564281167691185, 0.2004137156217063, 0.19613935897228219, 0.11657291879982656, 0.17049360686359016, 0.15773440557152296, 0.1550265532375792, 0.20799801544676666, 0.20355798549135007, 0.21031301130014368, 0.16863293315688843, 0.6908233994954381, 0.11200657699802063, 0.6807660174478394, 0.6641082921261751, 0.20072694538847202, 0.2256052549318147, 0.18120619099099344, 0.18903747988308628, 0.19611747777772048, 0.18704883636207514, 0.19868793183208655, 0.19075848426240372, 0.18283870146392345, 0.08989838957581064, 0.08734092605118426, 0.09566251085242317, 0.05655292174476201, 0.08520076005003208, 0.09774925027129922, 0.0713928404835733, 0.09960308743626611, 0.08542011460507526]}, "mutation_prompt": null}
{"id": "863a7dcf-a0f6-4720-bc8e-390f144c05aa", "solution": "import numpy as np\n\nclass DynamicCoevolutionaryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Adjusted for coevolutionary dynamics\n        self.mutation_factor = 0.6  # Reduced for more controlled mutations\n        self.crossover_rate = 0.85  # Slightly reduced for better stability\n        self.local_search_intensity = 6  # Balanced exploration-exploitation\n        self.adaptive_threshold = 0.15  # Enhanced sensitivity for dynamic adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def hybrid_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.2)  # Fine-tuned for hybrid search adaptation\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Enhanced for deeper exploitation\n            self.mutation_factor = 0.75  # Adjusted for balance between exploration and exploitation\n            self.crossover_rate = 0.88  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.hybrid_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "DynamicCoevolutionaryDifferentialEvolution", "description": "Dynamic Coevolutionary Differential Evolution with Adaptive Mutation Control and Hybrid Local Search for Enhanced Global Optimization.", "configspace": "", "generation": 54, "fitness": 0.4284629216943059, "feedback": "The algorithm DynamicCoevolutionaryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8456213496039838, 0.8301484374349728, 0.8483253483339038, 0.8402591511964096, 0.838753216020339, 0.8292401459599633, 0.825945750877964, 0.8103394103692427, 0.8319304623571437, 0.7208913291285279, 0.7126251557850427, 0.6976452508648873, 0.7332576545315164, 0.7420435095453476, 0.7354585159413632, 0.7234925560618528, 0.701247988929147, 0.733220849911312, 0.1543845788299979, 0.28830091253849854, 0.292688678674618, 0.1363672507987983, 0.14385561911807054, 0.14926456880339156, 0.24086977845673352, 0.24358397706084878, 0.14689731706774733, 0.15101562661539103, 0.13011625109050695, 0.16303709440800718, 0.1454497780275793, 0.1693340218746776, 0.24918444547233498, 0.141700220027972, 0.1447837728495195, 0.14080536313955472, 0.9591102289568012, 0.9609946782391108, 0.967615997009851, 0.9498410352378356, 0.9664265222808892, 0.9498529101954009, 0.9468277703108043, 0.9495151582676248, 0.9633127294438539, 0.6456347702505432, 0.577301963461311, 0.589589831791271, 0.5391545169956377, 0.5842925947473696, 0.5732778436371507, 0.6135334277362801, 0.5158212790258874, 0.5589652817071669, 0.7751755167916574, 0.8318505078823666, 0.7997622967906762, 0.8778093418331041, 0.814653019027526, 0.8326640825507023, 0.8273943017997866, 0.8206472440494166, 0.8042873372292569, 0.46928974156835856, 0.48907872028061583, 0.40213185052597566, 0.13042828978312848, 0.12633545464797502, 0.4073374577129173, 0.4736916369479578, 0.47652154406088065, 0.4997106754605314, 0.3848338470224453, 0.12757285666359164, 0.1886989507773662, 0.5452020156048157, 0.543485566493163, 0.4965613399397171, 0.4389121856888999, 0.39413230146018463, 0.5283233420761021, 0.36302231499473203, 0.37024803181723587, 0.5123912522629334, 0.4121781093058805, 0.42245911824910076, 0.4015887070669649, 0.3571697765884484, 0.43504993565370653, 0.41616876902291744, 0.5403501685744476, 0.5152020285775002, 0.5191740255061007, 0.5088850131211816, 0.5408349919924562, 0.4869845899936487, 0.5131487238102578, 0.5771597266346155, 0.6116671145559296, 0.3007062588841919, 0.15575303560360532, 0.18073083877245244, 0.30380336429135546, 0.2364311647493471, 0.3225538098481927, 0.10868218057281753, 0.2426086585266486, 0.14702932744564, 0.312816714002795, 0.3354856380359894, 0.3480085436544439, 0.3756959895214803, 0.38303134645747206, 0.33863042345172034, 0.3432450037567655, 0.35609660319182246, 0.34661698126965124, 0.6565952938564366, 0.7182945622423997, 0.7112892789292746, 0.7002559858716706, 0.7182255515912095, 0.7033606616515302, 0.6896214370707393, 0.7144743143432515, 0.6782557312932957, 0.12349728906829283, 0.14557480397370726, 0.14489484656516927, 0.12052915905508221, 0.18947986903040315, 0.1415853498229559, 0.13256228003225357, 0.13902706113341678, 0.12329587497306205, 0.20377335867394208, 0.1724418481061757, 0.21027382273736328, 0.37170079355675867, 0.20824177959248968, 0.18487398403303346, 0.20994413508220977, 0.22114316192210848, 0.21100913176704483, 0.37931009455917286, 0.40458311031599203, 0.4149045274855454, 0.3653294777372281, 0.3707591118219179, 0.4144443231317071, 0.4277398654297009, 0.41519167057924566, 0.4174862319163479, 0.3324777374016957, 0.33213268840628607, 0.3053394714460933, 0.3002658812598805, 0.3193914133920569, 0.3448582955427896, 0.3788385515747943, 0.33541241643427033, 0.33112173610099693, 0.2125858505425392, 0.19943524654908396, 0.22788396906436859, 0.21326551958987272, 0.18826767901069508, 0.20230098226277227, 0.20433017973954415, 0.21448464931228628, 0.2166865552156385, 0.21078493280181632, 0.48918502516826357, 0.2171647049143346, 0.2115698025096343, 0.43044358887940515, 0.43889445648827463, 0.5100147727672701, 0.21116402482493812, 0.22314143753130533, 0.8341305973142937, 0.19569101159514735, 0.15189053368569616, 0.18542177303917728, 0.7918046815622699, 0.7195201122685397, 0.76485589640617, 0.8561699507922871, 0.7342912193489362, 0.1679788696286918, 0.21098696003620065, 0.8153165470331211, 0.20611338474100693, 0.7645392754922509, 0.7965169460954313, 0.751702073004992, 0.7710519387551886, 0.15489064566125021, 0.22029616386419837, 0.1741003701328675, 0.1761056231758168, 0.1770534854684067, 0.19383515132889617, 0.18572523612975467, 0.21450134670848264, 0.1880069437704106, 0.19926868698523337, 0.08858142327889196, 0.08811387935133574, 0.0955860905457172, 0.08410171613971251, 0.08266444786744798, 0.08486093816070239, 0.09825415464431475, 0.09056382755000636, 0.08683425528865174]}, "mutation_prompt": null}
{"id": "6b17fad0-8496-473b-92d7-9cf749a71e89", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Increased population size for more diversity\n        self.mutation_factor = 0.8  # Adjusted for a broader exploratory phase\n        self.crossover_rate = 0.85  # Reduced to promote individual stability\n        self.local_search_intensity = 6  # Increased to improve local refinement\n        self.adaptive_threshold = 0.15  # Reduced for quicker parameter adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)  # Narrowed to enhance precision\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Boosted for more focused exploitation\n            self.mutation_factor = 0.85  # Further refined for balanced exploration\n            self.crossover_rate = 0.88  # Adjusted for a better mix of recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adjusting Mechanisms for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 55, "fitness": 0.36888448466633705, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.7879037801849883, 0.7775140033660528, 0.8124203566591607, 0.7928490425303859, 0.7758162255040814, 0.7945293117284263, 0.8080098688827472, 0.7659432098279165, 0.7671062007359726, 0.6340334412290263, 0.6202345235136384, 0.6277744919353155, 0.5781537800000389, 0.6424816917320701, 0.5961549959517358, 0.6230206332035844, 0.5900191869257378, 0.6308182024350955, 0.13962690408307044, 0.26882451413748387, 0.1292117518949737, 0.16119060212122094, 0.11956460483851317, 0.2140442564613948, 0.14031960052163883, 0.215487902283379, 0.2046567446040679, 0.14906824586938638, 0.1217656013214975, 0.1350695879275885, 0.1640216073459706, 0.198680620230131, 0.15212354376691417, 0.12418373008702599, 0.16892561706364506, 0.13322997377254575, 0.9738143500686778, 0.9281066292436777, 0.9685732137659975, 0.9569770690650589, 0.9641806262410558, 0.9399873610476959, 0.9821974224588541, 0.991189390946784, 0.9827588818924812, 0.4341264623781923, 0.4491987677496826, 0.4006392035971874, 0.39223673864980424, 0.45542409480261015, 0.4510104313616138, 0.43142824872848473, 0.391058265724909, 0.4221585733180554, 0.7681371247578594, 0.6986309772896406, 0.7322378705851036, 0.6783622217601268, 0.7762604096010066, 0.640369510435757, 0.605802696912255, 0.6604388002126795, 0.728107561619871, 0.34302432145805273, 0.3268868001698281, 0.3421978967237691, 0.3333610056295484, 0.28392958185256956, 0.3401050338008036, 0.41147337081670887, 0.38347034232597066, 0.35014502344148546, 0.29181483449503076, 0.17992008659382153, 0.2288404348932721, 0.3085226954195348, 0.35875914348910387, 0.28169036163373884, 0.34041545082321834, 0.29812849626826976, 0.2873984458043185, 0.23688588105773933, 0.217030554460508, 0.27183165197431913, 0.29075897682025853, 0.23969862643930173, 0.25020035694043263, 0.22551670194117757, 0.23343792192425517, 0.2276808206444091, 0.36068697034010355, 0.33639272376513285, 0.361299361717735, 0.3596613415983514, 0.3257851106889269, 0.40752153148260584, 0.3730037516909799, 0.3947508070803917, 0.3837637804606756, 0.11392748151055399, 0.056742215820953734, 0.11783999163031111, 0.08791283197848321, 0.14040817422266316, 0.07988092499256527, 0.13269210060889014, 0.15310372921185367, 0.08057216911041798, 0.2347830947511611, 0.23851313470743984, 0.24611266767175677, 0.2653457567132689, 0.25732239694790515, 0.2515464415732894, 0.23201764362094202, 0.2257696583103952, 0.25302637274947204, 0.5983616237102656, 0.6089554366836215, 0.5630024151338267, 0.5766604397360008, 0.5909026957847292, 0.6123356097319672, 0.5856574930896632, 0.5911105043171777, 0.6099402379229483, 0.14665536223473208, 0.11379732511618967, 0.15776683507888178, 0.14415939612506223, 0.11931589000007048, 0.13880096408626252, 0.13884339270176227, 0.12661579155266978, 0.13851497923835554, 0.23924596889786942, 0.30814167578064644, 0.23080864681366442, 0.5265050647214655, 0.21126098335838672, 0.276745780462921, 0.27035679473196306, 0.2255804092674082, 0.25292552456337003, 0.31245030376492744, 0.31602610690884503, 0.3305899852178058, 0.3477821498189012, 0.2934825492205019, 0.31109059854476384, 0.35245869942565355, 0.3545938275277384, 0.3534348602629451, 0.26867504286085653, 0.2557041348181224, 0.24590956292583077, 0.25676462958980684, 0.2784173643314479, 0.241606331315678, 0.2818857827605519, 0.2988092884666619, 0.24666942396558145, 0.20258752196092222, 0.2050602334231808, 0.1905056623049245, 0.18391499046150084, 0.17834531416185329, 0.2158492981020056, 0.1876728872686605, 0.1740784171917723, 0.1788707839937299, 0.3278921232189881, 0.22580941123469644, 0.21887142629053713, 0.3808312162835046, 0.27830339452440056, 0.21685191730643272, 0.22539390711734475, 0.2776435148706069, 0.2280659186311308, 0.6868592876552801, 0.7088462639715222, 0.15946303068164358, 0.7552812025381935, 0.6289755309139147, 0.20387843010272966, 0.6001723370875823, 0.18444592368727464, 0.17588164867000056, 0.778461341557859, 0.7440886747418856, 0.706755221817239, 0.47724132337773495, 0.6870149131079313, 0.7166975013557001, 0.21125791043416187, 0.8160702394473146, 0.6905749100875269, 0.19426401765632662, 0.18532108580574802, 0.18530755536655374, 0.1878251544702806, 0.2132651615872866, 0.1870120384747993, 0.19023365777306156, 0.19199299245361823, 0.19501719529241635, 0.08778823042323036, 0.08749709739130829, 0.07674581549128912, 0.0962979731543332, 0.07896636420716951, 0.08094415180226333, 0.0809406428202023, 0.08495952345926494, 0.07514027645924015]}, "mutation_prompt": null}
{"id": "f609ab1c-6cf3-4f4e-a880-7bebd775068b", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "68893527-86e9-4e60-8b06-5a9a9d2b9cc2", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Increased population for diverse search\n        self.mutation_factor = 0.6  # Adjusted for exploration-exploitation balance\n        self.crossover_rate = 0.85  # Tuned for effective recombination\n        self.local_search_intensity = 6  # Adjusted for balanced local search\n        self.adaptive_threshold = 0.15  # Tweaked for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.04, 0.15)  # Refined for controlled exploration\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Enhanced for deeper local searches\n            self.mutation_factor = 0.75  # Fine-tuned for increased diversity\n            self.crossover_rate = 0.88  # Adjusted for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Adaptive Differential Evolution with Enhanced Learning Phases and Dynamic Strategy Balancing for Effective Optimization.", "configspace": "", "generation": 57, "fitness": 0.43696329125913586, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.25.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8396199359813847, 0.8361951718815229, 0.8397567230971088, 0.8597894983580108, 0.8375323473927496, 0.8264657416851949, 0.8364610395839139, 0.8407664589889772, 0.8289817742404166, 0.7310067405974346, 0.7216124850958943, 0.7138259130110102, 0.7230082875048853, 0.7215214193377923, 0.7426303675614092, 0.7215266714916093, 0.7179825968846487, 0.7353860286833743, 0.16377757727740194, 0.1990615125371059, 0.21109028845963307, 0.2902553360932012, 0.2085624429553593, 0.18374976221894668, 0.2750586890241903, 0.1518809282010516, 0.20870440577144422, 0.11609551326917567, 0.22628299218868075, 0.14952569385324588, 0.2519328432823731, 0.22110125466955532, 0.14168385230881764, 0.12977864116023752, 0.13444633784658122, 0.15245126847401314, 0.9456084091955768, 0.9361672871554891, 0.9677724752058895, 0.9252825422765592, 0.9521344003645642, 0.9417953358018877, 0.9564791141009481, 0.9644409523956698, 0.9601928499153708, 0.503970565742305, 0.5606805220434798, 0.5558214350220396, 0.5605362567228102, 0.5383445641171719, 0.5526423159791856, 0.520240994677803, 0.569046941226081, 0.5987632125697642, 0.8177083774047882, 0.7898647778368395, 0.8053403990010137, 0.8730579037939153, 0.8381120622591625, 0.8305711936037773, 0.814617591434993, 0.7719926446002894, 0.8041219163453437, 0.4879473759242172, 0.5009296769176919, 0.46166554613276845, 0.543544855311645, 0.40254069895396205, 0.4989558955402935, 0.5578563070405557, 0.4759845294952797, 0.4814463577741044, 0.4341882928654015, 0.44437525335579686, 0.23696707775758974, 0.4200305860261897, 0.4082845202283373, 0.5166848239591657, 0.5141818570528606, 0.47248876245694515, 0.33434555448478087, 0.4429878924793803, 0.3822576678923414, 0.41244492742406946, 0.40605749988777906, 0.450600396556855, 0.3537784235830641, 0.35170551805750006, 0.3940271842458155, 0.4589887908609599, 0.5047664496892408, 0.556798413271594, 0.5223819697708529, 0.48599331061838813, 0.5409590501239914, 0.5608877069722662, 0.5626236413074664, 0.5761454035499808, 0.511374773072635, 0.14874623637053686, 0.2015422702933115, 0.24003749060944202, 0.35396532630154265, 0.3153950632422561, 0.36666281220697805, 0.1981907610267336, 0.16393956142876198, 0.16463275840802472, 0.3044333101359822, 0.3365484584443449, 0.3296257191904829, 0.3211107793979443, 0.3356832073667878, 0.35967032473847604, 0.3317623990604156, 0.32619417283927676, 0.34287535892301146, 0.7162587645932432, 0.6685932271993014, 0.7360489966238569, 0.6855958691071132, 0.7013044422084399, 0.6968871180005144, 0.7084547303163177, 0.689092059428602, 0.6976063537572006, 0.1383748075200334, 0.14074985180925292, 0.1644102730564918, 0.12822838725382568, 0.12390985682809119, 0.153603971946499, 0.1213513195682786, 0.13332935261588863, 0.1344593857644255, 0.20577429034811823, 0.2681959539449039, 0.22975800413736913, 0.3333508711987384, 0.44369247113929167, 0.2254497367516406, 0.19780899197231172, 0.24126062078524768, 0.2995775160630384, 0.4054958487920447, 0.4210506602298839, 0.369016846265661, 0.3693545406039279, 0.3626300904638131, 0.41660483558742145, 0.44408160274101416, 0.46477704155133415, 0.4520664961670765, 0.32172917785529076, 0.3357309908950199, 0.319160370798624, 0.32673034754534735, 0.294332318078269, 0.32677222870747036, 0.35600782659394914, 0.33689800051303487, 0.33910703274709686, 0.20110443443931503, 0.21023502061504873, 0.2472004623568571, 0.20912743082322416, 0.216200887067862, 0.24506856630153795, 0.21404839273296516, 0.20114139393890074, 0.2075378050844101, 0.23251808433186083, 0.4560218599503212, 0.4371050189091896, 0.34322049518593134, 0.3972038328251366, 0.455010916694641, 0.23075449006683835, 0.2929767288126355, 0.4578716576884644, 0.16462237628070486, 0.7521846339081899, 0.15188220493063476, 0.8490449853484768, 0.8394302644712152, 0.20435398111947178, 0.8197785550406836, 0.8299932435166433, 0.7903581396227873, 0.16789188601167426, 0.7080246848991381, 0.7887974529140908, 0.20635750956322585, 0.6950631105551901, 0.8208169758858486, 0.20877041412314623, 0.7424311139812738, 0.15499319295267922, 0.18721292451416238, 0.18297622748139697, 0.18867819245624562, 0.17697274481773662, 0.19930295654956287, 0.1849950161504157, 0.18289846489232342, 0.18259720375775068, 0.19931401949667094, 0.07896340789735046, 0.08461453953877585, 0.09469121535577651, 0.08149237890999428, 0.08987792449511112, 0.0796206485054628, 0.07813384210932273, 0.0804400801473788, 0.08444485948622826]}, "mutation_prompt": null}
{"id": "b8c8b7e9-2e37-4fbd-a224-f5c485886cce", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "95919d79-76a3-4075-b315-bef0bb1a5f9e", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "1058acef-ea7f-40b3-9769-ecfc4768fe62", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "cd553983-6858-4793-86ee-170b8039dd46", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "38477d76-61c8-46bf-91d4-e971ae8430c1", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "497c78b5-758f-4335-8627-e5525fb02f96", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 30)  # Enhanced population size for more diverse sampling\n        self.mutation_factor = 0.6  # Tweaked for slightly reduced mutation rate\n        self.crossover_rate = 0.85  # Moderated for enhanced local exploitation\n        self.local_search_intensity = 6  # Fine-tuned for balanced exploration\n        self.adaptive_threshold = 0.15  # Further lowered for sensitivity in adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)  # Narrower range for focused search\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Increased for fine-tuning exploitation\n            self.mutation_factor = 0.75  # Adjusted for optimal diversity maintenance\n            self.crossover_rate = 0.88  # Refined for superior recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "HybridDifferentialEvolution", "description": "Hybridized Differential Evolution with Adaptive Local Search and Dynamic Parameter Adjustment for Robust Optimization.", "configspace": "", "generation": 63, "fitness": 0.3996821619060344, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.25.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8109813770421325, 0.8216369595744535, 0.7994423500431083, 0.8190942816553749, 0.8205060368847444, 0.8225967290058789, 0.8076786955566433, 0.8044019006338039, 0.7851312629890008, 0.6513209092839566, 0.6810203667350097, 0.656832216062719, 0.6853341634041714, 0.6731979924997313, 0.6718008732019347, 0.6732201397849817, 0.6708419608446461, 0.6793767659277845, 0.30095767234080717, 0.1468857649914025, 0.14267264845832273, 0.16510558620968263, 0.1860397833851426, 0.2126500776005953, 0.15131066941341398, 0.25410287213727156, 0.1491075655749542, 0.13060572455840103, 0.13240537249009776, 0.24896119366280622, 0.13714545249608145, 0.12185770963187315, 0.13924772584640466, 0.13087430946542067, 0.13230214565939658, 0.13024456327075074, 0.9422134580139988, 0.9523849604873031, 0.9614673566472437, 0.9754436030080392, 0.96052338769134, 0.9312070492410212, 0.9321180724565347, 0.9335172483636242, 0.9776122012733813, 0.5018724172679243, 0.47917254121731545, 0.46346794718799644, 0.4952223413176684, 0.4628457159011896, 0.49053250239048185, 0.47248846585854765, 0.4827273875632293, 0.514990258920568, 0.7841350639441231, 0.7597674253537323, 0.7129648498589202, 0.8225721222133588, 0.8042965978283518, 0.7557628121399778, 0.7971602338954027, 0.7766291273935907, 0.7949331441593245, 0.3108123249797291, 0.3645540937951598, 0.4044072982180795, 0.3458916372057219, 0.34073776216377494, 0.4133567721831336, 0.42193941274611557, 0.3891395060303027, 0.3364034092591982, 0.4064582904428413, 0.43831872972661723, 0.31178359832180247, 0.5203453563557072, 0.2812730097053441, 0.42442935686509187, 0.4603989666542866, 0.3340265316048321, 0.33188104898467174, 0.3373448141207521, 0.3672068669503705, 0.3258542209125258, 0.09528046376138977, 0.3396860055494503, 0.3422589541587314, 0.33233510514129083, 0.3774293473074922, 0.36746256844697034, 0.47451816402845237, 0.465648303136185, 0.4612329137518364, 0.47291998012109926, 0.46643944748581356, 0.4765657346911075, 0.5142809764866454, 0.533650660433172, 0.45091949939116593, 0.10961116334445142, 0.11254194904165216, 0.12155402841329632, 0.28708874100798176, 0.28368627245868394, 0.17507982110116682, 0.1723343166129091, 0.19444339435629865, 0.15144218243383545, 0.3276281911697385, 0.2991045108418253, 0.30917859649752355, 0.31548490922689754, 0.32594038381435153, 0.32910160283793133, 0.3148853675039093, 0.30527327951848815, 0.32042158834161494, 0.6971973388662014, 0.678077373763555, 0.6903138572427274, 0.6495725426437168, 0.6346840675529015, 0.6543959669730146, 0.65805159766262, 0.6464699993507579, 0.6630654946480159, 0.12742590011536936, 0.12487492134743139, 0.13992338578384755, 0.14192575238997818, 0.14117497175786242, 0.11772626561419497, 0.11725166068266057, 0.14896319814853853, 0.15239537266644876, 0.23375834465512302, 0.18902466789768158, 0.21318883510887765, 0.30027211006427146, 0.21019497913454432, 0.30603119454868744, 0.3221371124942839, 0.2143666993256358, 0.20875002451360758, 0.372843652845091, 0.36623797860287455, 0.35163755341469316, 0.3866274213261982, 0.37595436201202315, 0.33441991272847305, 0.37758971629588256, 0.38957303455565806, 0.3994520681266883, 0.30626713778340187, 0.29490237042288303, 0.2942455823612088, 0.2575766442509494, 0.2685926134519032, 0.2870679520407935, 0.2947117707501753, 0.29625791181906147, 0.31327922878188696, 0.2225450422673786, 0.19846726227969758, 0.21205498629680086, 0.21518396372945714, 0.21831275167178943, 0.25156263310020577, 0.2288651474481036, 0.20593226424340227, 0.20049970109569182, 0.21357492433031566, 0.25323009277223096, 0.37040429568273947, 0.2318068379988234, 0.23199396160085328, 0.2122043459356855, 0.20244356277024522, 0.5243957969969305, 0.388491546858037, 0.8290640953171318, 0.7810506781271888, 0.1721495595244018, 0.7908788077224478, 0.19558282226827928, 0.7826829324040674, 0.7185806699461468, 0.20319490505164672, 0.6908713285487342, 0.7765563005546846, 0.16675325522493534, 0.7052320386475109, 0.7859483872419398, 0.20071752118670694, 0.2011365172818036, 0.15525835948096323, 0.7518274059583557, 0.2080954012331827, 0.19919959884441374, 0.20914983103102902, 0.19238879193042024, 0.1856307698732771, 0.18513568127195068, 0.18800759898190644, 0.1961176409071872, 0.1848581841996766, 0.19896024488211228, 0.08110809288732157, 0.09058732124601387, 0.08089490698161228, 0.084906017484639, 0.08357267367519128, 0.08809661615443853, 0.08340230480838495, 0.0870648479035877, 0.08935365976284737]}, "mutation_prompt": null}
{"id": "8413a842-3f7b-43d2-93e1-6571a2c0c259", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "61ae5b37-394f-49f2-8bc2-53821bc44743", "solution": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Increased to support higher diversity\n        self.mutation_factor = 0.8  # Adjusted for improved search efficiency\n        self.crossover_rate = 0.88  # Slightly reduced to stabilize exploration\n        self.local_search_intensity = 6  # Increased to enhance local exploitation\n        self.adaptive_threshold = 0.25  # Fine-tuned for sensitive parameter adjustment\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)  # Narrowed for precision tuning\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Further increased for intense local search\n            self.mutation_factor = 0.85  # Enhanced for greater diversity control\n            self.crossover_rate = 0.9  # Adjusted for optimal crossover execution\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "QuantumEnhancedDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution with Enhanced Search Dynamics for Superior Solution Convergence.", "configspace": "", "generation": 65, "fitness": 0.3732392900786467, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.7685569930800158, 0.7799570501704551, 0.7656026539999414, 0.7904574195011089, 0.7792399044558018, 0.8110042633574817, 0.7935910456543884, 0.7750357211018396, 0.7813819896876737, 0.5947478142399125, 0.592982860604217, 0.5909724838802264, 0.5911340073443678, 0.5791518731004555, 0.5852600984672576, 0.6373029678351458, 0.5855425284748905, 0.6201839801913821, 0.15439608770661672, 0.15327347288131654, 0.17978150209063748, 0.17127333673449374, 0.1295284742106938, 0.11730951035012971, 0.13658576912698295, 0.1566765129415404, 0.1556513168591357, 0.12640287023730412, 0.12626235057891322, 0.12537410140354022, 0.15205529613947733, 0.13734617159919438, 0.12768317987099764, 0.12889431724319178, 0.12595853954603864, 0.14115623164654822, 0.9640407096996105, 0.9274764670635741, 0.959583331315818, 0.9727448883085353, 0.9724908703798747, 0.9484799558280985, 0.9628868189731696, 0.9814790249464558, 0.9853987406051997, 0.45122001005359536, 0.4376270815459471, 0.4136666576064193, 0.4529516261140287, 0.46099214986153325, 0.48051671004708296, 0.4623120891752336, 0.4237499290933521, 0.5029401068527444, 0.6402247126471343, 0.7437910084114356, 0.6765615682565629, 0.7259613099898865, 0.7775037212365429, 0.7936603035898043, 0.7467730395655622, 0.7935379447056611, 0.7175337088024761, 0.33057036118719996, 0.39043764758370214, 0.31105184657757623, 0.32900168160959953, 0.32061465223237084, 0.3907490104399406, 0.31596097843575477, 0.2937497713671131, 0.39212313147657296, 0.37407140269676, 0.2813550730095745, 0.3324190985048031, 0.3689949530238483, 0.34762487766070704, 0.31517665820277074, 0.34570388008040154, 0.25993364520454465, 0.3472014014073468, 0.27719472140485424, 0.2759905144518936, 0.3041735319193636, 0.278518210771067, 0.29261127618348415, 0.3019724325242016, 0.2953330254194647, 0.3140116006537692, 0.2635314408810644, 0.4103298459892154, 0.35158219761119813, 0.39702618217583385, 0.43190523615135845, 0.37493088920921114, 0.40600699763468706, 0.4348351663361203, 0.4273350758489485, 0.4703191468561434, 0.0650876226862298, 0.1017107314552591, 0.05860785843268146, 0.24470287121976264, 0.2067514014657238, 0.14507322819401403, 0.1811405054698102, 0.10166105724821484, 0.09320441608600571, 0.27502468327159213, 0.23718130177314356, 0.25236475694044525, 0.2810975703155091, 0.26095150301273706, 0.29732103355247386, 0.25077469133319363, 0.25917270609932075, 0.271571199737744, 0.6383607048161208, 0.6301911992036471, 0.682897951627038, 0.6447336081014212, 0.6144419872572777, 0.6236166569729236, 0.656244356435332, 0.6009279421685985, 0.606107545424706, 0.11782482916523696, 0.13120760823733413, 0.1355835703238758, 0.1318715359726893, 0.12716666830165502, 0.10013901702110817, 0.14402033729357722, 0.12028814354548178, 0.13690029997365327, 0.18363367214626514, 0.413271231168612, 0.21948732795412773, 0.4414191882027618, 0.3130878597464145, 0.19997404544187158, 0.31184497954744606, 0.2607771582607098, 0.31835401505713035, 0.33747698238332413, 0.33539732105937714, 0.3181988192868057, 0.3126585508030527, 0.3169341270914747, 0.3340215441047609, 0.3420698791284431, 0.34123386378869136, 0.35070666873541656, 0.2539588930856711, 0.2707339951261801, 0.28531780015200603, 0.2683996500627259, 0.2623833290013111, 0.2536171692151342, 0.28340653689251993, 0.2793373891540134, 0.24859226722448025, 0.2065258866501557, 0.21268434410861825, 0.18556614431673402, 0.19636980486847655, 0.19112038513510965, 0.22372425073481883, 0.23043340152803915, 0.18124865221945352, 0.1815345781647023, 0.3207228295869118, 0.23632624922825396, 0.3807554400611449, 0.36710826718638123, 0.1994731602692259, 0.34375869914422663, 0.1963448520583948, 0.23609353431836133, 0.1960099283253861, 0.19092984386699807, 0.768435929604533, 0.16242517542165824, 0.7586037654775488, 0.1969153180258163, 0.6392220656505434, 0.7085818839580751, 0.18428668900933987, 0.6043908757765225, 0.6951308616050698, 0.20819275064769815, 0.7944360296960262, 0.595260236989527, 0.19907737230980604, 0.6987876889076217, 0.21019631897138047, 0.8498530442429724, 0.15092645254380677, 0.19702898031501204, 0.1870855258091496, 0.22699237697409458, 0.18933255517058956, 0.19323273765148596, 0.20840839009080148, 0.19330857051280126, 0.1825505127285042, 0.21264162745760995, 0.08075236872583735, 0.07531232136529542, 0.08171317440986581, 0.08089321740980626, 0.08855503077053839, 0.08569333231804865, 0.08580425618522891, 0.07901898523521689, 0.08952587558106118]}, "mutation_prompt": null}
{"id": "23173c96-3620-480c-85c2-05fcac4a5912", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Increased minimal population size for diversity\n        self.mutation_factor = 0.6  # Slightly reduced for controlled diversity\n        self.crossover_rate = 0.85  # Reduced to maintain stable convergence\n        self.local_search_intensity = 6  # Balanced for effective local exploration\n        self.adaptive_threshold = 0.15  # Lowered for sensitivity to change\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def quantum_differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            quantum_influence = np.random.uniform(-0.1, 0.1, self.dim)  # Quantum-inspired influence\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector + quantum_influence, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def enhanced_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)  # Adjusted for finer control in local search\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold or self.used_budget > self.budget * 0.8:\n            self.local_search_intensity = 8  # Intensified in late stages of the search\n            self.mutation_factor = 0.75  # Adjusted for diversity control\n            self.crossover_rate = 0.9  # Fine-tuned for better recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.quantum_differential_evolution(func)\n            self.enhanced_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution with Dynamic Population and Strategy Adjustments for Enhanced Exploitation-Exploration Harmonics.", "configspace": "", "generation": 66, "fitness": 0.2862836950751252, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.5405852331847316, 0.5092604073943534, 0.5254421608461128, 0.5216950765999293, 0.49494895341158385, 0.5169145898622605, 0.5298864066714966, 0.5091165649547387, 0.5104797430954892, 0.1342272092525798, 0.13164398941443234, 0.12406606880018756, 0.12228379981357007, 0.10449592052291956, 0.11013288270578692, 0.1287236289020106, 0.1123194436766245, 0.14070166426264608, 0.13657545776783464, 0.15199457380615344, 0.14779160636729027, 0.15304789818810238, 0.1489637935358309, 0.14749033379501764, 0.17827212874982634, 0.15648155995570323, 0.20643629963815702, 0.1195856245861513, 0.13676367420245283, 0.12400226234621547, 0.12861780040270587, 0.1353424330744274, 0.1337579077342569, 0.12042313800725335, 0.12905701583833085, 0.13932539308496128, 0.9536098949480057, 0.9362335458629256, 0.9499311669273096, 0.929417733006572, 0.964680539956682, 0.9550808409289366, 0.9298869219554404, 0.9774380778780951, 0.9313316375935079, 0.3396837174185635, 0.3665170328822408, 0.36489454188649895, 0.32501700296484226, 0.3383925101434443, 0.3681316203188928, 0.350452867159847, 0.33788115319081036, 0.3373720335579109, 0.7677817088901714, 0.6256725953846637, 0.5917369750905749, 0.8076243852882921, 0.7782524770271111, 0.8127727336148678, 0.8105328595225798, 0.8157331245787933, 0.63460033717138, 0.2446164529174334, 0.2520231492425893, 0.19640398351361987, 0.19951313530453352, 0.19920399895145846, 0.27383090156864087, 0.1894315218984588, 0.19974839987301596, 0.23775024573348225, 0.2091761563282405, 0.17178499232113176, 0.18931233158396932, 0.21414569256376903, 0.21341907564801488, 0.2639880809655528, 0.18960350417252925, 0.1980413201175697, 0.19106261239679279, 0.04178897116293134, 0.079389868043368, 0.08479325085968215, 0.07372529264471228, 0.06245172830462831, 0.07199476220769918, 0.07615149941615906, 0.07555701997158171, 0.1918706994160312, 0.1288953029035782, 0.10020626425115664, 0.1237805197230133, 0.09785756785560384, 0.14444797699566336, 0.11976117881525938, 0.13752884718314762, 0.07506226675653616, 0.154888679991657, 9.999999999998899e-05, 0.028031075730958754, 0.01735562400994639, 9.999999999998899e-05, 0.0006538045710227092, 0.013846574553998847, 0.03448762260684868, 0.0013074908784798112, 0.02517449682406181, 0.1370590458684222, 0.13934758521280222, 0.12548239893824176, 0.14160168652374783, 0.148717131119823, 0.14202478803748853, 0.14280012301070255, 0.1379304680986535, 0.13973761492648495, 0.4739057584354137, 0.4549407651678826, 0.45632452390759903, 0.4669275834271678, 0.48829126054819016, 0.4391430680105013, 0.45512403324547157, 0.5097747916488655, 0.4650194680077697, 0.14086694632216823, 0.12907419990786417, 0.1473003397107806, 0.1282834372832603, 0.15139455837184668, 0.14891841318753019, 0.12300792859637655, 0.11363161084347573, 0.13110717402813699, 0.20613148570314466, 0.24243680550851254, 0.2201102393951906, 0.24420771243127382, 0.24095217349353282, 0.15664842433532067, 0.18506008443702093, 0.16744721299571863, 0.24902516872180236, 0.3101496863592198, 0.30495996975462125, 0.32131437562122067, 0.32106711166464197, 0.30957174595525117, 0.33469315730826044, 0.31367351257285225, 0.3125302710932246, 0.31973255832514225, 0.2662116052747503, 0.252313364440797, 0.2421783524253418, 0.2546025213409634, 0.25459200051029307, 0.26155976536785863, 0.26914069164719345, 0.2604233263911786, 0.2474198310837431, 0.19866691121203817, 0.21015558751794472, 0.2007585775546481, 0.2032857037427701, 0.21244215160426105, 0.2730983611384955, 0.2195772800749377, 0.210223009257275, 0.19813618032773306, 0.2547332957780437, 0.2954823456567417, 0.21613797882395525, 0.2602886947413795, 0.3092600374601757, 0.3076060780011617, 0.27593042908972665, 0.22741018591534312, 0.20636754230465615, 0.20662562382163752, 0.20810931965987733, 0.6597220719264726, 0.7008841199176203, 0.815012922899951, 0.7612034950307862, 0.17648806460430422, 0.5498821727022756, 0.6679586209524798, 0.6063101325144725, 0.2063744013091483, 0.6705838315561372, 0.6790149143176328, 0.6613629724317192, 0.2084891283503303, 0.20907854290990613, 0.6434006993144508, 0.21251503295549934, 0.1918341384890403, 0.17307273300595194, 0.1857709581662672, 0.18049296384034352, 0.1998183239697534, 0.2047509485407797, 0.19245432813536745, 0.18649010071395944, 0.18766429836025444, 0.08458701200682972, 0.09323314811802996, 0.11053591757068792, 0.101781344467479, 0.08391419445265436, 0.09092803949599404, 0.08173733404815553, 0.08123269452683801, 0.08273676401831598]}, "mutation_prompt": null}
{"id": "1bd51426-957b-49d7-866f-04369cc7e3e9", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 25)  # Slightly increased minimal population size\n        self.mutation_factor = 0.65  # Adjusted for fine balance\n        self.crossover_rate = 0.88  # Adjusted for better exploration\n        self.quantum_intensity = 4  # Introduced for quantum exploration\n        self.adaptive_threshold = 0.25  # Adjusted for sensitivity to convergence\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def quantum_parallelism(self, func):\n        for i in range(self.quantum_intensity):\n            if self.used_budget >= self.budget:\n                break\n            quantum_samples = np.random.uniform(-5, 5, (self.population_size, self.dim))\n            quantum_fitness = np.array([func(ind) for ind in quantum_samples])\n            self.used_budget += self.population_size\n            better_indices = quantum_fitness < self.fitness\n            self.fitness = np.where(better_indices, quantum_fitness, self.fitness)\n            self.population = np.where(better_indices[:, None], quantum_samples, self.population)\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.quantum_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)  # Adjusted for enhanced adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.quantum_intensity = 6  # Increased to enhance exploratory capabilities\n            self.mutation_factor = 0.75  # Adjusted for improved diversity\n            self.crossover_rate = 0.9  # Slightly refined for balancing exploration\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.quantum_parallelism(func)\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "QuantumInspiredDifferentialEvolution", "description": "Adaptive Quantum-inspired Differential Evolution integrating Quantum Parallelism for Enhanced Solution Diversity and Convergence.", "configspace": "", "generation": 67, "fitness": 0.20492672905644918, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.40957619761537856, 0.3848568073380464, 0.38939442397118196, 0.44663336675676935, 0.42688364503400966, 0.4036393041720817, 0.368126451060768, 0.41997888034966846, 0.4104109385776715, 0.15665747022959364, 0.1765711931469749, 0.16934395951234693, 0.19395339588484162, 0.18660807444081906, 0.16707986826466514, 0.17676780095452982, 0.1778933706919017, 0.1698365653302224, 0.09856573056531559, 0.10972422636885437, 0.11436379384992656, 0.08371608458483881, 0.09346218372874648, 0.10781233323693595, 0.09455685985668993, 0.08879188977476027, 0.0996806990111323, 0.09955132741487271, 0.08604867055380216, 0.09234407120940291, 0.09090711668541696, 0.08240528846805739, 0.07678984672795908, 0.07583365870663605, 0.08705393662777972, 0.08591922753060155, 0.9019747363266664, 0.7613557430607012, 0.7875936438141449, 0.8836187494109493, 0.721754347892299, 0.6556376495383273, 0.9408773007255578, 0.8064779135535227, 0.7359014405368437, 0.19449641477768498, 0.2297124095460249, 0.21013779136643485, 0.1923554123986937, 0.22871705955425603, 0.17923498190946907, 0.20780055007138998, 0.21533200093965965, 0.18709465839167105, 0.2640170457894676, 0.30164449956104, 0.4363694487668799, 0.27815879790997233, 0.2523357500128699, 0.30214853345487724, 0.2900681954632168, 0.3666405370752882, 0.22543637368095037, 0.19709750901180467, 0.12200184462201047, 0.12532514111515125, 0.1477843085780498, 0.12944931245945468, 0.14962294066496618, 0.16796493439006177, 0.12387670940702245, 0.15455857652692118, 0.14515196114622197, 0.1367040101079876, 0.0840817415007723, 0.1822369585430409, 0.14841463996113202, 0.142748409613343, 0.12583909475377497, 0.11872631168063641, 0.10639426711170874, 0.06065258016813713, 0.058715133463265956, 0.033880979413729806, 0.02974568404901967, 0.033840188198696386, 0.02680320954561899, 0.07445799311306511, 0.04956961708764451, 0.06505070876134145, 0.13444356800492274, 0.15074378232455454, 0.16844796060185796, 0.14091463425532125, 0.14940698712332123, 0.13971372765885548, 0.2137114004140631, 0.15483070625209017, 0.1633326470538421, 0.0014886858866360875, 9.999999999998899e-05, 9.999999999998899e-05, 0.01462781546504488, 0.0057434105317392126, 0.005455522650788747, 0.0013720493703381909, 0.00980248394862504, 0.0009297822997353933, 0.09599578791159324, 0.09635629971312809, 0.10324948541714818, 0.1246121346428416, 0.11801046129107073, 0.09293349876387835, 0.09559089478440241, 0.10953406252399367, 0.08852074364016826, 0.367823092191525, 0.3593237232773804, 0.36320089248495824, 0.3684341582438676, 0.3759455214323407, 0.3635445670226499, 0.34652404352541055, 0.3503880591723475, 0.36387615473410795, 0.09286762648635372, 0.09702505148933072, 0.09630211759652851, 0.09342561927904336, 0.08703202188887293, 0.07870613704313278, 0.10405832912435564, 0.08773892159574936, 0.09202294785049359, 0.200547384107296, 0.19104347418725465, 0.15868521206479913, 0.2120978805467002, 0.18825650338379007, 0.17971450426465618, 0.20878824508904603, 0.15627525370560214, 0.14914011778879643, 0.23927926264229782, 0.23956803201474497, 0.25379118944858614, 0.24486859884114442, 0.23723717249051524, 0.22190037107220884, 0.24734153009480742, 0.25718392186922345, 0.24238793255277413, 0.17418720740707772, 0.19803273926471432, 0.17547358187115403, 0.17721965574649834, 0.17348991479575726, 0.16922160511487605, 0.16855130634854432, 0.19753238731156242, 0.2082488800941943, 0.17109892060655962, 0.1676592929355244, 0.18931523091892621, 0.16678521409979818, 0.18556059979851214, 0.18015995037134724, 0.16946793471097732, 0.16532302888158634, 0.17423572701290646, 0.1997865381138374, 0.17871860433422337, 0.18447236452268279, 0.17101008883077906, 0.18561112711465733, 0.16989767732071648, 0.17693129412281883, 0.17432652257671766, 0.18453986581530657, 0.3807758037023735, 0.3877246085293201, 0.17171132868642303, 0.27154172036325097, 0.372819465111487, 0.38421889300523315, 0.2778768025165298, 0.2241756542519714, 0.241840067963912, 0.38739585031365786, 0.30369133523601466, 0.3554338116839433, 0.2847881530794185, 0.23729938915681892, 0.2651143593787446, 0.23557017470012664, 0.28536592273088146, 0.1853055956832801, 0.18448240923429904, 0.18516780740260763, 0.17622329448049912, 0.1972100482670882, 0.18355644540183125, 0.1853931684901856, 0.18194892195748857, 0.19120595207539126, 0.18779902251688496, 0.07516756091197474, 0.07269091406823647, 0.06887111252356648, 0.07367754491146405, 0.0663412769208177, 0.06392937016351408, 0.06356719636126396, 0.06377118857339115, 0.05802453390758222]}, "mutation_prompt": null}
{"id": "19a99393-e3dc-4167-8163-47bc73ac99fd", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "2d3258bb-d1d0-42d4-a405-cfc9cec6a127", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "b5837675-2469-4782-9148-8bfa7513cfba", "solution": "import numpy as np\n\nclass AdaptiveQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Slightly increased population size\n        self.mutation_factor = 0.65  # Adjusted for better balance between exploration and exploitation\n        self.crossover_rate = 0.85  # Modified for enhanced trial vector generation\n        self.local_search_intensity = 6  # Increased for deeper local search\n        self.adaptive_threshold = 0.18  # Fine-tuned for more sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def quantum_inspired_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)  # Adjusted for finer local search steps\n            perturbation = np.random.normal(0, step_size, self.dim)  # Gaussian perturbation\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # More intense local search\n            self.mutation_factor = 0.78  # Increased for greater diversity\n            self.crossover_rate = 0.95  # Higher crossover rate for more variations\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.quantum_inspired_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptiveQuantumDifferentialEvolution", "description": "Adaptive Quantum-Inspired Differential Evolution with Enhanced Local Search for Robust Global Optimization.", "configspace": "", "generation": 70, "fitness": 0.43784748985318633, "feedback": "The algorithm AdaptiveQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8174975491171597, 0.8015217401747552, 0.8428593350716702, 0.8126640102777998, 0.8154656357431903, 0.8243699976683607, 0.8277003964220849, 0.8219167627488928, 0.8106165253086901, 0.6938680897302945, 0.7121563281902751, 0.6842185743178066, 0.7030355040644584, 0.7012273819748502, 0.6832705989500343, 0.6640131324020531, 0.6787872436275824, 0.6867306123390979, 0.12416961618824585, 0.16192834952477753, 0.13653721761800897, 0.15927443987858148, 0.1700359796011991, 0.15973542293797616, 0.4220770130010417, 0.15055877998086686, 0.12275723118603632, 0.23179967927616574, 0.14534327936696867, 0.1385534881902799, 0.13133562586310876, 0.15966633240293793, 0.13358723532015826, 0.13833915254819162, 0.1630493812257393, 0.12576167513191905, 0.9501487834860473, 0.9597513499756369, 0.9490794467654616, 0.951946956322657, 0.9789639135251031, 0.9258778384495452, 0.9732220317351168, 0.993232971395035, 0.9403216066472985, 0.5182399417338721, 0.5139460584828086, 0.4791312963759934, 0.5514167786268152, 0.49066138925895497, 0.5588907957425056, 0.5722543929986943, 0.5372949229050372, 0.5127214294521683, 0.8027123746481089, 0.7530043185369331, 0.757796176156927, 0.7926861680781273, 0.8231766476866393, 0.8232895968644423, 0.8187621001740346, 0.8011936050515982, 0.7817457571225804, 0.5076489076158011, 0.42149299509089133, 0.471390133173511, 0.5048940508459684, 0.29898208118568825, 0.5001773552056787, 0.5989825241975325, 0.5074526042755969, 0.5160954221093278, 0.4811807164824634, 0.5239680317506211, 0.5079419493354431, 0.5290073270094849, 0.5446901603781028, 0.46041588961951274, 0.31987478858953755, 0.4124607179237424, 0.5006597714315592, 0.43879754905427704, 0.45716597022752237, 0.41990853148467333, 0.46802034614366017, 0.49165742287635217, 0.45376990213566515, 0.43749219683804474, 0.44820556481463636, 0.4613740297736919, 0.49293988482555673, 0.5621550146386374, 0.5704830290302221, 0.5130591257632179, 0.5575809229617275, 0.529963933958684, 0.6210181684261273, 0.598322355249491, 0.5648429006634531, 0.2510297662555214, 0.12785007821371497, 0.08897266503872703, 0.35448392414650787, 0.3587065983167106, 0.30058997130655984, 0.23336761714238496, 0.2854899474082233, 0.20075400585154646, 0.3738323755238665, 0.3698685113759326, 0.3408491668283915, 0.3743732787276527, 0.36286918880610186, 0.37990541616046913, 0.35031578569100874, 0.32518840710650654, 0.3030307105910428, 0.7350775304916465, 0.7374306369978899, 0.7396282386529919, 0.722793181471213, 0.7306414356093052, 0.7476383231844177, 0.7543977460536149, 0.7117255481307787, 0.7286213274906088, 0.1260032382544789, 0.12687037055739014, 0.1250632594940111, 0.12813430580764085, 0.1202254557170147, 0.13384808154350125, 0.17666537869558074, 0.123269805415689, 0.1231411269662529, 0.3235504566669748, 0.29805923954207936, 0.3119454370569167, 0.23950429336946344, 0.26972640741280784, 0.25668849849177033, 0.19052467576226473, 0.2629506435868447, 0.26051590630488475, 0.4234157094269694, 0.3854354955969542, 0.389968053991406, 0.38495371607128026, 0.34326181615821094, 0.4247759181100689, 0.4152542048319914, 0.4064337650792852, 0.37005816032208716, 0.2934852364675632, 0.3320526024539554, 0.32351899066818346, 0.3298846974182701, 0.3060236645501553, 0.3214177232511133, 0.32706272544933523, 0.3026080948108937, 0.34294802604261565, 0.20042251856860716, 0.19521303370211818, 0.19004500974183836, 0.2139652697236959, 0.19818720063708783, 0.18978142206953952, 0.19798153804669816, 0.2000310114142474, 0.21585847986920947, 0.23977159388660052, 0.2902697378409874, 0.22391101550817516, 0.20527477546911677, 0.2155085689060937, 0.34461321720892013, 0.22674974005731896, 0.23461200490940237, 0.2171751760203836, 0.7767894411797176, 0.16344424103836064, 0.21041281838306258, 0.8359513687628887, 0.7267173036889611, 0.7333554973862484, 0.6877264542133756, 0.7631508605465107, 0.6925469583758572, 0.7703782833619488, 0.7487330066707516, 0.20456412936616875, 0.6804862023986648, 0.8086942907499587, 0.7601269348115044, 0.834664366873227, 0.808112764939382, 0.1515901570357806, 0.17703530714815974, 0.19324999855288882, 0.1873321696837652, 0.18209710462459328, 0.19072046539489595, 0.1803769005145477, 0.19981591645963526, 0.18129753378855484, 0.192783404286624, 0.08048430082861924, 0.08009135697519254, 0.08373815619497249, 0.08583335958569183, 0.09460187449147983, 0.08156979665869368, 0.08473190051870005, 0.085870422505131, 0.08596464213895738]}, "mutation_prompt": null}
{"id": "69498eba-7874-4b97-957c-96d1aca5704f", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "64159b37-ae94-42c4-b12d-55d3dd6566db", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)  # Slightly increased population size for better diversity\n        self.mutation_factor = 0.75  # Adjusted for refined exploration-exploitation\n        self.crossover_rate = 0.88  # Slightly reduced for better stability\n        self.local_search_intensity = 6  # Increased for more thorough local search\n        self.adaptive_threshold = 0.15  # Lowered for more sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.15)  # Narrowed for precise exploitation\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Further increase for more intensive exploitation\n            self.mutation_factor = 0.85  # Increased for enhanced diversity\n            self.crossover_rate = 0.9  # Slightly decreased for balanced exploration\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment and Improved Local Search Exploration-Exploitation Enhancement.", "configspace": "", "generation": 72, "fitness": 0.38039804683976397, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.7868822736942358, 0.7905819357530042, 0.7850725290742274, 0.794464854745808, 0.7962329072796303, 0.7765159543648427, 0.7848158854318099, 0.8275662071102275, 0.777223471318337, 0.6145502682896382, 0.6242918814397214, 0.6288867846637325, 0.628908434067795, 0.6702626332200001, 0.6279238638879763, 0.6421978099362796, 0.6190152982074879, 0.6185619874460284, 0.13352973414098246, 0.1531022204137591, 0.14156769880303943, 0.18127412379136165, 0.13819833425998984, 0.158945567994353, 0.168863179668727, 0.1422065380203945, 0.1297175463930973, 0.14350466561211928, 0.11604313652304121, 0.14002732195666134, 0.12908122031633862, 0.14521143969279005, 0.12710795192492697, 0.12189340391530823, 0.1455678964669469, 0.12240318767056102, 0.9289858374579618, 0.9816482326962455, 0.9760116094551857, 0.9609533133540228, 0.9621785222245846, 0.9875588539832871, 0.9610690594481206, 0.9867950330564731, 0.9885340173087235, 0.47214883928630436, 0.4356021029792825, 0.426559455465483, 0.46981161441763497, 0.42878643689267326, 0.4402709321089803, 0.42029551788317876, 0.45098667240934076, 0.4910069559168936, 0.7316434488043395, 0.6874930392022164, 0.7432735540938248, 0.7635669185039289, 0.7337110659550241, 0.8228484143783406, 0.7680722356834258, 0.8016016243368322, 0.6847515176518291, 0.39242581020391076, 0.39344725505707767, 0.37862136410300506, 0.3995167045501541, 0.3247518751179058, 0.3843253956300037, 0.3257216479715488, 0.3239687616978484, 0.38075321763595593, 0.3164796246479398, 0.21578426328380507, 0.38629047689220775, 0.39671895110437827, 0.35101263708972896, 0.4395179847621392, 0.4077032192212461, 0.3635238203735499, 0.4240526510742988, 0.3756712963731469, 0.32852366107351927, 0.3755241295318309, 0.32803124652031634, 0.3868569722973191, 0.29653195385642617, 0.3127598858973333, 0.3159489635389686, 0.35119797781535755, 0.43999908292677725, 0.41155746726646736, 0.43424006583266783, 0.43182972012461174, 0.4490892715908139, 0.42935404194901927, 0.463189442152109, 0.4360168332297072, 0.4710505229016795, 0.09772404644623911, 0.0991309395747958, 0.17025220876841818, 0.21394022677945446, 0.12467185407286452, 0.1939478162543612, 0.11944440959025182, 0.11185182548027606, 0.16761575460392852, 0.27534672377392666, 0.2878098160908291, 0.28643173625517704, 0.30771123366655073, 0.27980394520771457, 0.2789070242347832, 0.3151148836354607, 0.2782753965028131, 0.2917663047769544, 0.6577365362927999, 0.6309099807118652, 0.6145587324772414, 0.6150480631049979, 0.6227898565713326, 0.635727571442106, 0.6789483576218276, 0.6423315598778572, 0.6545830317274193, 0.12117782732730753, 0.1492731315987441, 0.1316980050442833, 0.10620343390173748, 0.12099081933680611, 0.12087549349357163, 0.13243639246396233, 0.1418143322128732, 0.1252129458762341, 0.36062962834477175, 0.17427083980926217, 0.23201569394414845, 0.2760782891403303, 0.2699875253505055, 0.22758229516607087, 0.32383253339689455, 0.21229461203005395, 0.396172224737089, 0.34188518753442654, 0.3628936245380723, 0.3315373520959588, 0.3296073513806451, 0.35323286493298467, 0.37924250495211864, 0.3830304609304609, 0.3472148500893848, 0.38447320510955496, 0.28426089789371145, 0.2784631697029103, 0.25464722081327107, 0.27049822129652645, 0.2623954700530915, 0.2707160917444451, 0.29616792839446116, 0.2952161431400653, 0.2618193695318891, 0.18627163478169184, 0.20972350349375424, 0.1870581141881913, 0.2050885941945707, 0.19654478198979264, 0.19565688991296393, 0.1945347266518752, 0.18713595293122742, 0.20132551556384848, 0.273213424576243, 0.2071467750619349, 0.2234645923544918, 0.2025782617023537, 0.21781831770407367, 0.3049470571788514, 0.34629029538344636, 0.2089561922967066, 0.25403258732288936, 0.790158867297178, 0.6196685547154241, 0.18158344947695437, 0.806972288104431, 0.20559919296737794, 0.7318876171038418, 0.757658032351508, 0.20424208871317517, 0.16558948500735837, 0.16316656452904588, 0.20079568186555674, 0.7746018096662213, 0.712455699233844, 0.2045261630313442, 0.6041430212912474, 0.20964751045422414, 0.8219215846057614, 0.1641510269430273, 0.1880514197287313, 0.18179228310218531, 0.17909527309832485, 0.18844730351005456, 0.1800491262633659, 0.17036605754507161, 0.20072859521242403, 0.1879686331990742, 0.18138508395936614, 0.08043526597764517, 0.07466235158395151, 0.0917927311077239, 0.07846159487702176, 0.07186181634496369, 0.08418246102262106, 0.07683287262039795, 0.10025464336788426, 0.08647380962681095]}, "mutation_prompt": null}
{"id": "796cc0f1-bca2-443f-b039-06a9133a29f6", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "5cf57a70-f4ee-47ad-b401-88c8995235f2", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "192d071b-45c8-4d5e-bb66-045f1028c3b8", "solution": "import numpy as np\n\nclass AdaptiveCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Increased minimal population size for robustness\n        self.mutation_factor = 0.75  # Slightly adjusted for enhanced global search\n        self.crossover_rate = 0.85  # Reduced for selective diversity\n        self.local_search_intensity = 4  # Adjusted for balanced exploration-exploitation\n        self.adaptive_threshold = 0.15  # Fine-tuned for sensitive parameter adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)  # Refined step size for precise exploration\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 6  # Increased for strategic exploitation\n            self.mutation_factor = 0.85  # Enhanced for greater search variance\n            self.crossover_rate = 0.88  # Balanced for optimal blending\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptiveCoevolutionaryDE", "description": "Adaptive Coevolutionary Differential Evolution with Improved Search Dynamics and Precision-Driven Exploration.", "configspace": "", "generation": 75, "fitness": 0.3817978789402139, "feedback": "The algorithm AdaptiveCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.7963661558559836, 0.7864686694477294, 0.780342009318995, 0.8027972653755329, 0.8210906891627272, 0.8070056848548863, 0.818743215428809, 0.7645460135296406, 0.7989873007405623, 0.6636498504854754, 0.6615940424604725, 0.6598336243755342, 0.6323025145008467, 0.6591791457319391, 0.6794412320884231, 0.6609973802881266, 0.6759348141037931, 0.6068313178700896, 0.1672655295316472, 0.2946685232420927, 0.16220637452945708, 0.20218148097147015, 0.14331716276813145, 0.16004220782771006, 0.12382289076007147, 0.15563620738641015, 0.16187978973393724, 0.12492371868169361, 0.1310637674744417, 0.13451763846194065, 0.14548946848771016, 0.1586164637685894, 0.1619126683144123, 0.13507064367620691, 0.15585636357076504, 0.1942137028243901, 0.9722694857755615, 0.9685163906992087, 0.945212565221182, 0.9694089005388291, 0.974472645321534, 0.9325855973216589, 0.9423434628998264, 0.9897046537398599, 0.9577274985054633, 0.49762660329258923, 0.4574823423037586, 0.4593479377638723, 0.474507208012957, 0.45523325737526155, 0.4515144951915421, 0.47744122343230144, 0.4793964900060156, 0.5027993299199895, 0.7386392250554301, 0.7742049183840561, 0.7324954256130423, 0.8036035966434174, 0.7647955093123744, 0.7839821846379147, 0.7718290661739802, 0.7976820241010529, 0.7214142325483799, 0.3581991422125288, 0.3311973693833892, 0.40782731068806455, 0.38071547497192804, 0.37404080838021747, 0.37478261514274314, 0.38812108154398606, 0.3875176019156773, 0.38575748291249934, 0.2963143514372101, 0.39288174245364926, 0.42831173908416464, 0.357427548141079, 0.3584766494593069, 0.3539348677662638, 0.2947056145222776, 0.40877207378348956, 0.4000367215052324, 0.2847230810153599, 0.23302989561111576, 0.26647729904635076, 0.24914468938432888, 0.2376764127463994, 0.351453433505704, 0.2679698235784215, 0.33073450537375304, 0.29522610847345787, 0.4119623071131546, 0.4011248847341877, 0.408683356310786, 0.42695680683688386, 0.36238672019223295, 0.39072315971847227, 0.47339342563900677, 0.4387742862060855, 0.4458540046260172, 0.07722234684182916, 0.10993804780377736, 0.16992455572081377, 0.19838598087898673, 0.1251704573454544, 0.19252898366351, 0.20223326496201322, 0.15813203681833288, 0.16113918897119928, 0.26762211437052696, 0.2540404288626461, 0.2586205738687508, 0.3086892753328291, 0.2754834369284509, 0.30975893025228785, 0.2938849253488718, 0.26846715338136584, 0.25611634003199946, 0.6215259177111474, 0.6083877215216609, 0.6559175564001865, 0.6257682196049559, 0.6355879695987068, 0.638426365099414, 0.6432648753668664, 0.641362998045698, 0.6239058171558853, 0.1365780733695936, 0.10549738013543264, 0.161113147248914, 0.13469729317425916, 0.12355975293301802, 0.13394652071601887, 0.12532109215406506, 0.11153027528128967, 0.13413415524407424, 0.4153349162184602, 0.2713728378074898, 0.2600544281605758, 0.21791712268318608, 0.27291394301560645, 0.22085201839776292, 0.19199558416678764, 0.329107793673007, 0.295998058972031, 0.37443568262399396, 0.36002295211210933, 0.32944792678366, 0.3261781183827699, 0.3570339996652917, 0.3248980234546166, 0.37118684509045796, 0.37157874306009064, 0.36525669292460083, 0.27924038760241043, 0.28604668362199714, 0.27550650147779665, 0.26732397570322797, 0.2368163061160533, 0.2756899826682483, 0.2857876173288635, 0.2992631685690188, 0.3063085321309439, 0.1881849156617318, 0.1903154103257816, 0.18188656989374352, 0.19017422345525814, 0.22042635599003102, 0.21117129153048364, 0.19207155218282534, 0.18030047461597098, 0.19765612375033614, 0.22611844691170757, 0.2911033122321852, 0.2292548545895794, 0.22399661440778518, 0.20724878102990463, 0.23732206382930632, 0.21790624791368607, 0.2668251946397525, 0.30228670825187776, 0.16846008315025052, 0.7857460552751186, 0.15256669882202512, 0.774555545203674, 0.7279226259569932, 0.17516484692577194, 0.17952386453317937, 0.20089465114035543, 0.2013701567109778, 0.20619343868669915, 0.20453053322478132, 0.6475505459933091, 0.7171778514769449, 0.703455138497082, 0.6969394239623148, 0.20636252230632102, 0.7900374408799273, 0.7490745275246595, 0.20517486959621778, 0.19986105447678693, 0.18883174626973964, 0.21229537567724022, 0.18035318752216367, 0.18825501142150525, 0.22071212387576145, 0.20152356731016385, 0.20341653671168602, 0.09632930082134772, 0.10009641008360226, 0.08270544276826419, 0.07749118277374945, 0.07862219819458205, 0.085060598158334, 0.08660656559145741, 0.07893753530578651, 0.08449584565246493]}, "mutation_prompt": null}
{"id": "d5184988-2865-43e5-8f69-fb58739495f6", "solution": "import numpy as np\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Slightly increased population size\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.9\n        self.local_search_intensity = 5\n        self.adaptive_threshold = 0.15  # Fine-tuned adaptive threshold\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n        self.surrogate_model = GaussianProcessRegressor(kernel=RBF(), n_restarts_optimizer=5)  # Surrogate model\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.25)  # Broadened step size for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def surrogate_assisted_search(self, func):\n        if self.used_budget >= self.budget:\n            return\n        training_data = np.array([ind for ind in self.population])\n        training_targets = np.array(self.fitness)\n        self.surrogate_model.fit(training_data, training_targets)\n        random_samples = np.random.uniform(-5, 5, (100, self.dim))\n        predicted_fitness = self.surrogate_model.predict(random_samples)\n        best_pred_idx = np.argmin(predicted_fitness)\n        candidate = random_samples[best_pred_idx]\n        candidate_fitness = func(candidate)\n        self.used_budget += 1\n        if candidate_fitness < np.max(self.fitness):\n            worst_idx = np.argmax(self.fitness)\n            self.population[worst_idx] = candidate\n            self.fitness[worst_idx] = candidate_fitness\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 6\n            self.mutation_factor = 0.75\n            self.crossover_rate = 0.91\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.surrogate_assisted_search(func)  # New surrogate search step\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Hybridized Adaptive Differential Evolution with Dynamic Strategy Adjustment and Embedded Surrogate Modeling for Enhanced Convergence and Robustness.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {}, "mutation_prompt": null}
{"id": "23b2b8be-8256-4f74-a673-baa7624ef721", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "9ee3e093-92c5-4f3e-889c-09c1b9b93f3e", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Increased population size for broader search\n        self.mutation_factor = 0.8  # Adjusted for dynamic exploration\n        self.crossover_rate = 0.85  # Tweaked for better genetic diversity\n        self.local_search_intensity = 4  # Reduced slightly for faster convergence\n        self.adaptive_threshold = 0.15  # Lowered to react more sensitively to convergence stagnation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.18)  # Narrowed range for controlled fine-tuning\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 6  # Adjusted for enhanced local search \n            self.mutation_factor = 0.82  # Fine-tuned for exploration balance\n            self.crossover_rate = 0.88  # Slightly lowered to optimize exploration-exploitation\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Adaptive Differential Evolution with Enhanced Local Search and Parameter Sensitivity for Balanced Exploration and Exploitation.", "configspace": "", "generation": 78, "fitness": 0.37434723454421137, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8048861034169225, 0.8212186356263498, 0.8027456886470518, 0.8179546669998672, 0.7989687876310939, 0.806975122737834, 0.812911521949599, 0.819561846571764, 0.8032089990926558, 0.6669148237131552, 0.634714807169879, 0.6394113869274829, 0.6419122360756289, 0.6312236590643174, 0.6501141370193726, 0.6354405712541683, 0.6056665454407851, 0.6661861618417135, 0.14054241824170144, 0.12545235322239934, 0.1440323055709174, 0.15421449524752462, 0.1396199363876296, 0.15606602959153737, 0.14225316289449275, 0.13462789483389082, 0.14949656670709588, 0.143194002325562, 0.12428388135078838, 0.1755038344391926, 0.20119193663453339, 0.1422467519041255, 0.13418972791704964, 0.11046346163046161, 0.13870542313743295, 0.1373049524669796, 0.9683186167071796, 0.9459699554581434, 0.9602266306413862, 0.9698873491361789, 0.960682914250506, 0.9591973766840003, 0.9504175655493051, 0.994062518015161, 0.9744741793651537, 0.4471426502604502, 0.4386908967327794, 0.44252832641363726, 0.42111054981543394, 0.5038866795364508, 0.4569358328813937, 0.4456115880631075, 0.481658255878744, 0.4681308122988026, 0.7295559930055038, 0.6847493687979096, 0.7437837366859923, 0.7653254494508976, 0.784346234551366, 0.6841807503238961, 0.7869258658607361, 0.7416643935786198, 0.6906171276149347, 0.3826494152507869, 0.35606877523686886, 0.32482389430774317, 0.39307505799686016, 0.3159497362241338, 0.4103991879438865, 0.3689647321356966, 0.38562518328631, 0.37566165760405223, 0.25964881722798916, 0.253558239455941, 0.3488391855401973, 0.3526549884510445, 0.3038061342142784, 0.38024119751835495, 0.38199268200701375, 0.32389494199434443, 0.4250776465486241, 0.2971384038448385, 0.25612790412169273, 0.21893008359988175, 0.2592616840164236, 0.2618352032564636, 0.26752817547188157, 0.30028420981402326, 0.20385744840406805, 0.2702718926269285, 0.36594680406277835, 0.36449676714400914, 0.36272853676091477, 0.39197904499924363, 0.37883560714968467, 0.4030042373989031, 0.4699349166530533, 0.45692151733788955, 0.48168550061796245, 0.11839581593846504, 0.11763986699744022, 0.09435254987785269, 0.0952932571032501, 0.1626207730573802, 0.17129533848246248, 0.15033015405510763, 0.10183038009438827, 0.08262341329520917, 0.24099200603769322, 0.24409641512632596, 0.22967423568391354, 0.30059610669835424, 0.2591866807076334, 0.2597057880105922, 0.2707624273251006, 0.22892410723757362, 0.26348327901673485, 0.6428610508505368, 0.6671053319993654, 0.6669501696111504, 0.6553196208165942, 0.6044093483484447, 0.6471289340330555, 0.6218677478645203, 0.6236500097497515, 0.6794651775026019, 0.12301618639251555, 0.12033707675192096, 0.19712038452472636, 0.11975707066968844, 0.13984254865177403, 0.11531851430092088, 0.1189994464874855, 0.12512735495276284, 0.14225862849366988, 0.3413708705781645, 0.20370471042951677, 0.49702694220359545, 0.3022613803293793, 0.15155189825070936, 0.18893230618208923, 0.197494302220366, 0.24576782486405768, 0.2352884774473002, 0.3720107095196228, 0.32648658169662637, 0.3220770025363008, 0.3403754650476052, 0.3187159346586361, 0.34608417861608454, 0.3690441295797603, 0.4095721568738204, 0.4074726169210676, 0.2966506807272399, 0.27135748906533164, 0.2672592152473555, 0.2604861061449838, 0.24969049177374059, 0.24397276678822777, 0.2775215303376867, 0.2846926320503077, 0.2834793697669311, 0.2041467383123614, 0.20668945495969715, 0.18096272622445775, 0.192658136683995, 0.2200817833333767, 0.20033186572143613, 0.194188025692271, 0.2239622597163189, 0.19130243914696277, 0.2096308337165499, 0.33571699559908974, 0.3924393880936834, 0.21191665252298242, 0.21853455567687652, 0.30632168916114777, 0.33117170303537513, 0.36582330454428225, 0.21352934082940533, 0.1691379363770802, 0.20219697749443333, 0.18658634361483706, 0.8214376953688705, 0.5738952549515349, 0.7889668288553335, 0.7684247850273407, 0.184252632136518, 0.7093697706263662, 0.2098989848786167, 0.20153686979734398, 0.6592268346147206, 0.6393795723663456, 0.7470350438193354, 0.736917397315747, 0.20909217249342738, 0.20898558836262915, 0.16102941088857592, 0.1819220968744959, 0.1963004956938128, 0.19227323545974717, 0.20247173460081458, 0.20080440650505182, 0.1909795292432458, 0.18610330295842092, 0.17536863336030073, 0.17930338716836103, 0.08171719456375215, 0.0813540937104208, 0.0841618599814199, 0.08926272987264605, 0.07468713017635231, 0.09167023550981901, 0.09184908412640158, 0.08421590076931951, 0.07790878894707876]}, "mutation_prompt": null}
{"id": "388ed5ae-5a67-4e25-a365-792861990f62", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "b704d01f-cd8b-48c4-849b-598bc68639ea", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "6f1811a6-5354-4d69-b25d-4b848c0d1742", "solution": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)  # Increased population for more diversity\n        self.mutation_factor = 0.75  # Slightly higher for better exploration\n        self.crossover_rate = 0.88  # Slightly reduced for controlled diversity\n        self.local_search_intensity = 5  # Maintained for balanced exploration\n        self.adaptive_threshold = 0.3  # Increased to adapt to wider fitness variations\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def quantum_variant(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            quantum_particle = np.random.uniform(-5, 5, self.dim)\n            quantum_fitness = func(quantum_particle)\n            self.used_budget += 1\n            if quantum_fitness < self.fitness[i]:\n                self.fitness[i] = quantum_fitness\n                self.population[i] = quantum_particle\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.1, 0.25)  # Extended for better adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Further increase to intensify exploitation\n            self.mutation_factor = 0.85  # Further boosted for increased diversity\n            self.crossover_rate = 0.9  # Adjusted for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.quantum_variant(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "QuantumEnhancedDifferentialEvolution", "description": "Quantum-Enhanced Adaptive Differential Evolution using Quantum-inspired Variants for Improved Global Search.", "configspace": "", "generation": 81, "fitness": 0.29726483341128224, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.603829383454475, 0.6304640828721215, 0.6204230277199535, 0.6140760908234666, 0.619989907841126, 0.6609592637148565, 0.6697846564604474, 0.5978401448059958, 0.630816352660093, 0.43118632874659724, 0.4157370184667796, 0.3737492782241074, 0.34294859304999925, 0.3622799094973791, 0.36050840687270924, 0.40012697976348444, 0.3793311005244572, 0.3755976528564011, 0.11122346098574343, 0.1226898885066452, 0.12456993293216712, 0.123514130475737, 0.09836580422911978, 0.11817598916444749, 0.09796996817140957, 0.10266438674384404, 0.14197528411054883, 0.11083910874702252, 0.09147218623962239, 0.10017591937918247, 0.10821733208849582, 0.1047410109102086, 0.09927268545980783, 0.10651017720682854, 0.10829120637108902, 0.09647069308695788, 0.8805950065092681, 0.9483886050711323, 0.9179220969259883, 0.9754245171370103, 0.9877819904895412, 0.9526444479339803, 0.9325177298487339, 0.9861117500783616, 0.9638910283300893, 0.31070145709909813, 0.29944817693577797, 0.2864752979152594, 0.31680444333668856, 0.2938354849827579, 0.3124542487283858, 0.31974183678747026, 0.27277251509694145, 0.306391267418503, 0.37568770658251627, 0.45058060256753296, 0.5087238825394702, 0.6459871919533459, 0.5561991591506039, 0.5760206846897205, 0.6540196818990895, 0.5441102245718016, 0.5904538697739707, 0.20619672299742486, 0.20461156192899654, 0.25044965133655084, 0.13675095062075304, 0.2079309163223828, 0.22289171451075185, 0.24496285669838003, 0.17838483367386415, 0.24131146230424927, 0.1867979593026905, 0.2077781978108797, 0.2219786263692245, 0.20426893493154208, 0.15316231297789995, 0.21560578267241226, 0.20778293394279346, 0.22133003754416736, 0.17647006015368882, 0.18502588651312635, 0.15854227266528564, 0.13423684595825303, 0.14204990571690124, 0.16627127565325395, 0.07949623023553831, 0.15677560096444954, 0.1562024498339517, 0.1718507452902861, 0.2520487310266116, 0.2642365445196786, 0.29106783808346204, 0.2639228299308771, 0.27785769710165753, 0.2572747289336551, 0.2991067940796259, 0.23312184729929586, 0.2703418533813907, 0.08375949189503884, 0.008218397342213524, 0.03123790638343238, 0.049662955049599944, 0.0439167963266498, 0.03489191648551515, 0.0908283729896473, 0.08107793529162988, 0.06434224640337449, 0.18388364342474295, 0.18580959050116985, 0.17964918468402613, 0.17637272983713514, 0.1748171760955507, 0.17936290850421321, 0.16465421430960758, 0.16095055414148807, 0.1808978159953547, 0.49276816267363743, 0.47135761729905223, 0.47415664584925643, 0.4998073756667938, 0.5001331363481598, 0.47556841714383546, 0.4866085587455594, 0.5149707192325921, 0.498164309270846, 0.11726213721483236, 0.10633915007378858, 0.08988420364263527, 0.09380317389945536, 0.0933023108046549, 0.10404005154835871, 0.10751408142747021, 0.1170232989302945, 0.10640429073649826, 0.16582491827346235, 0.19570157596315896, 0.3411888030845752, 0.20321875888525265, 0.19051537391895612, 0.2324716251010639, 0.21947505380241505, 0.21538483173680367, 0.20886276560209904, 0.27554777788405316, 0.305896472210774, 0.29091680950203935, 0.2825274743145193, 0.28723390326190823, 0.27509892098721855, 0.2833449376266016, 0.3101593376838119, 0.3142992685917727, 0.19504194364563432, 0.22145699993804624, 0.20727409742727254, 0.20933164701125873, 0.20839337723317353, 0.22590073377543063, 0.22092777037489375, 0.24094086478041754, 0.23889237368754712, 0.16844859300131376, 0.25140843579903027, 0.17768775948051518, 0.19441867465893115, 0.1802596459560335, 0.17381474578160017, 0.18328660090430515, 0.18238732235982158, 0.18239244738737848, 0.18253211858139384, 0.20890282901443347, 0.18715314163137087, 0.18648568998868964, 0.20020796073689684, 0.18291648387320059, 0.19371705898790648, 0.21119830662062167, 0.18238761614623422, 0.6613248439495353, 0.6207588283483109, 0.5479999924429344, 0.6202841125271601, 0.6081892124427983, 0.5746406193020828, 0.5897714005182011, 0.19957590554859495, 0.6124275944080966, 0.6060862281690511, 0.5162644774810737, 0.4618615940057438, 0.584776776133592, 0.4131541643869172, 0.5757815124504888, 0.6251541194113452, 0.6541012218288007, 0.20441452634110668, 0.18490140434529834, 0.19065970532342913, 0.1896654578381104, 0.18874087668528983, 0.18745790453802402, 0.17687746727545162, 0.20889734715476993, 0.18661445860192094, 0.17464102994275432, 0.08735311385415312, 0.077696315314427, 0.08385506350282357, 0.07501526079104659, 0.07576005609664405, 0.10110668373029896, 0.0726409403277134, 0.07255324129397855, 0.10875739634073911]}, "mutation_prompt": null}
{"id": "e0425047-fb20-44cc-a546-122232e7ceae", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "133622a5-3c3d-499c-af6a-04f892904acf", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "fea7f6f0-afef-4d18-9166-0cf88e3e4bd0", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "b019dee3-aae2-4416-bac3-51d38d5cf1fc", "solution": "import numpy as np\n\nclass SynergisticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Increased minimal population size\n        self.mutation_factor = 0.65  # Adjusted for a new balance between exploration and exploitation\n        self.crossover_rate = 0.85  # Slightly reduced to maintain diversity\n        self.local_search_intensity = 6  # Modified for better local search\n        self.adaptive_threshold = 0.1  # Lowered for more sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        indices = np.arange(self.population_size)\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            a, b, c = self.population[np.random.choice(indices[indices != i], 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.02, 0.15)  # Narrowed range for controlled exploration\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Increase to focus more on exploitation\n            self.mutation_factor = 0.75  # Adjusted for strategic diversity\n            self.crossover_rate = 0.88  # Slightly increased for refined recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "SynergisticDifferentialEvolution", "description": "Synergistic Differential Evolution with Adaptive Search Intensification for Improved Convergence.", "configspace": "", "generation": 85, "fitness": 0.4259308871483981, "feedback": "The algorithm SynergisticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.25.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8516383061576488, 0.8298003288255512, 0.805719543944942, 0.8394292731993956, 0.8390057432010806, 0.8380788789162217, 0.8403068814899487, 0.8303173005971134, 0.8414989502288521, 0.713376040389287, 0.723294753151573, 0.725929300293493, 0.7042338119836129, 0.7222745064248259, 0.7054184380051193, 0.6969092287538721, 0.7083921941551297, 0.7028037922307784, 0.21787101980696877, 0.1319065912317101, 0.18684101754850757, 0.2156754485857597, 0.4038897862212216, 0.18404841342454015, 0.20298501084452847, 0.14894161854305699, 0.20473078499367314, 0.13293517889190354, 0.15340585231945902, 0.13968843975047163, 0.15036419973895843, 0.11802935775514689, 0.13977807146370924, 0.14488584818168526, 0.15284144948755363, 0.1407015410783039, 0.9480046218842627, 0.9400857413366882, 0.9206505554154898, 0.9504611379304041, 0.9486617424336645, 0.9468763834610374, 0.956443383892388, 0.967411690720441, 0.9806651836908244, 0.5316918028900064, 0.5072171473275493, 0.5687068991223465, 0.5640533149568949, 0.5435507027025146, 0.5911667469252757, 0.5248844492430523, 0.5117817289399191, 0.514179519097655, 0.8466427200326461, 0.7988594569506018, 0.7764975725926772, 0.8176253436538591, 0.7588860335017931, 0.8377634487801574, 0.7988110162914941, 0.7993688498521091, 0.7701364935497088, 0.4872366653898682, 0.5205522250899128, 0.424083885301472, 0.4246232572354882, 0.45168891128217714, 0.5063784422219706, 0.4591255094386464, 0.39525511838108196, 0.43684870828343414, 0.5448530551807635, 0.3475959164615928, 0.3941293697548168, 0.5120342948094132, 0.3343323448305646, 0.45686233506560003, 0.4291272963504874, 0.4099955662491469, 0.3856287825002087, 0.41037369419667735, 0.3688620371553033, 0.42149347083104394, 0.4237091091161732, 0.4007889778952579, 0.40079628591465366, 0.4276997199406307, 0.4377743271805389, 0.40710593101961445, 0.4727123625122015, 0.5366506749131552, 0.5102959864741332, 0.5016589879502433, 0.5318389726750384, 0.5154829837025463, 0.5113686063715339, 0.528277169059246, 0.5578974964901062, 0.06050324748770852, 0.15160894648186019, 0.06583316065260292, 0.2524554823394174, 0.26272573197089377, 0.3245500881200033, 0.2261154107182234, 0.27883350787831074, 0.1655878881796694, 0.30554411194865483, 0.32693816994122693, 0.319133099334855, 0.37048033074470754, 0.35842396272313304, 0.3258346795316852, 0.2872024734172808, 0.3328807197145248, 0.3275490178729844, 0.6975894578933857, 0.6836398745506044, 0.7097926373069834, 0.7280779884241111, 0.7024464429926471, 0.7046862346400828, 0.6786996806064727, 0.6905420461863874, 0.670070224012108, 0.13237209234999703, 0.1293676712672437, 0.12575174057840255, 0.13283324997701784, 0.13945657111273757, 0.1298657169892402, 0.13006273244087385, 0.13213057874236567, 0.1324741277777719, 0.22403688472548722, 0.21852775372958755, 0.2570263933039254, 0.21010464433492593, 0.1850572279487427, 0.2879138638488272, 0.20462301247759618, 0.22652638243426304, 0.16240533535483048, 0.4255033745045391, 0.4007585963634698, 0.3770742535037239, 0.40407909765559635, 0.4001769295126568, 0.4223682775641452, 0.4089464164369456, 0.3801640306032721, 0.3979758074141192, 0.31357722501292096, 0.3032965022826314, 0.3157698493219737, 0.29755999080628204, 0.3053690246542369, 0.31410445648732266, 0.35153379216359915, 0.3353119679039763, 0.2999126886866956, 0.21031022345089745, 0.20526363006355097, 0.19854552982966212, 0.19674134432086277, 0.21189980005671427, 0.2138743485414656, 0.21536755056573142, 0.19040306976377286, 0.23267334043796128, 0.2818328848875301, 0.2498354944923239, 0.49277357264778776, 0.37535006267739146, 0.39525713519389005, 0.3536170646179868, 0.3675020089759925, 0.5532203462791447, 0.36063532795480546, 0.8201335881854022, 0.1690346126197363, 0.16914210051392542, 0.8186563797138583, 0.19721741524620884, 0.8240487785342999, 0.8351286868058353, 0.8351397655550161, 0.20684240104659102, 0.7439913168413709, 0.7772720777423905, 0.7365623768651681, 0.1998983653613271, 0.16140709928131214, 0.7806104345490281, 0.2120253493773152, 0.20783275154631542, 0.8233022722289493, 0.17629557903256132, 0.21418363725826428, 0.18107937416596676, 0.18858825931227596, 0.19725805301986143, 0.19003214089803866, 0.1974574128088611, 0.20773662453833164, 0.19189210640052246, 0.08745639868953659, 0.08121819165113087, 0.08585429312052872, 0.08552742220951681, 0.0959329892478814, 0.09112620733696208, 0.08339481990356468, 0.10588729548724818, 0.10087037004314248]}, "mutation_prompt": null}
{"id": "0a230cf7-621c-4873-b2f2-f404b6f7d67f", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "13201450-c23a-4aa7-bd64-74af8509f37d", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "60784fdd-c445-45eb-a766-3a98f9f8e83c", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "95993b49-65d7-4464-87e7-e43fc792197a", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "8993b7a9-8903-48fd-ad3f-6ae553c78459", "solution": "import numpy as np\n\nclass AdvancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Slightly increased for enhanced exploration\n        self.mutation_factor = 0.6  # Tuned for better convergence\n        self.crossover_rate = 0.85  # Enhanced for maintaining diversity\n        self.local_search_intensity = 6  # Adapted for effective local refinement\n        self.adaptive_threshold = 0.15  # Lowered for more responsive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.18)  # Fine-tuned for better local search\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        fitness_std = np.std(self.fitness)\n        if fitness_std < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Increased to capitalize on promising regions\n            self.mutation_factor = 0.75  # Adjusted to enhance convergence\n            self.crossover_rate = 0.88  # Fine-tuned for maintaining diversity\n        elif fitness_std > 0.5:  # Additional condition for boosting exploration\n            self.mutation_factor = 0.9  # Increase for larger exploration when needed\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdvancedDifferentialEvolution", "description": "Advanced Differential Evolution using Contextual Parameter Adaptation for Robust Global Optimization.", "configspace": "", "generation": 90, "fitness": 0.35102906842271125, "feedback": "The algorithm AdvancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.7636621042379483, 0.7721375350695105, 0.7982304813849093, 0.8264027471697981, 0.8057569402197382, 0.8058780799340785, 0.8014031926735399, 0.7981099058182883, 0.7614775006070247, 0.5771260403579003, 0.5769286347432678, 0.5970699386740803, 0.58689926787422, 0.6038382733507909, 0.5746628765806412, 0.6017301482548302, 0.6062165829449719, 0.6297225965310039, 0.23566088810542074, 0.17844006806850488, 0.20898931354856054, 0.15345070287273355, 0.1394111971962848, 0.13757870629780877, 0.24630229971561324, 0.18045309560696188, 0.1983803708968549, 0.18823681509286738, 0.15723774571005722, 0.13864286943362347, 0.1334523138514262, 0.16999852394968018, 0.13186027177452142, 0.1306330617378677, 0.11952474950533665, 0.1127247146022915, 0.943773938424489, 0.9744231087816543, 0.9617837172074921, 0.9643984897786432, 0.9649680944877049, 0.9650014466555661, 0.9826643874873519, 0.9856840311468273, 0.9882393341314312, 0.3863507724113858, 0.39442620453443167, 0.4102720782082304, 0.4449602948448559, 0.41063039107774835, 0.44239611007386936, 0.43179379291579, 0.41665508116993266, 0.42694665452385616, 0.6421240016065312, 0.653773343775996, 0.7568954538450184, 0.6683521906084632, 0.6576511379086696, 0.695554776241623, 0.6640596126045115, 0.6637829775973183, 0.65099906231849, 0.3547537912117398, 0.33182484836949544, 0.3522223347843083, 0.419593922497136, 0.1958102480615711, 0.268015186221362, 0.3478340429847405, 0.3187949489514288, 0.38403877275871334, 0.43895630164245913, 0.13126264265407772, 0.23458249661410202, 0.28722097697859494, 0.27144246386046444, 0.21480636212182735, 0.28703267594659154, 0.39730786030028675, 0.3499923166202471, 0.16338715864404052, 0.1339754180441347, 0.24116918115528396, 0.14960580843540605, 0.12247520560960656, 0.14090840573739838, 0.12585760325032858, 0.14071538304059794, 0.14378163918653775, 0.280658574530782, 0.37546841326313085, 0.297919857551875, 0.27847632683764034, 0.2847288620057833, 0.2733391379415573, 0.29601941115204855, 0.39091479856001865, 0.3393478825787475, 0.06838369795895882, 0.052685739427082656, 0.05042742359383834, 0.07471056035499912, 0.07709477376623075, 0.057262832157009, 0.08634196111312797, 0.05815253876636961, 0.08718564831048425, 0.20321033817488243, 0.20087351735162462, 0.21740186349065138, 0.2388559490395965, 0.2361653484886198, 0.24830139632364978, 0.1725064932004463, 0.1972365154356529, 0.21031082755633457, 0.6430258668154141, 0.6189001491131303, 0.6426554360445776, 0.6583491252058107, 0.641146545552746, 0.6810175270975549, 0.6564165647121447, 0.6122930322238437, 0.6734239490604099, 0.14766281723372998, 0.1080013985898709, 0.12838657762214478, 0.12164725730016923, 0.15211893442542712, 0.11653449037615338, 0.12729173747899092, 0.11036139000040535, 0.12179623127448902, 0.268708035183436, 0.38453212367623113, 0.1984349144917783, 0.2985100371438818, 0.1984418453580219, 0.2813475741364949, 0.3788633927970675, 0.21074291362163078, 0.287716518448756, 0.327626311081775, 0.3261485714550909, 0.31139861855917295, 0.3569747009297347, 0.3124931467427491, 0.31800473435980525, 0.39163915443179187, 0.35711739203384796, 0.34102327045274583, 0.23762576476419728, 0.2511631843684923, 0.21462700905647847, 0.2351270078086377, 0.21543656503815867, 0.22702818966784344, 0.24873772678782857, 0.25463644654684225, 0.2574759212363189, 0.21273005688707758, 0.18144979493575608, 0.18105548798920035, 0.20519040008393008, 0.18766181701010487, 0.19620726121091414, 0.1966590054179468, 0.20317559879520564, 0.18071901662310752, 0.21941363601995278, 0.19959532223646215, 0.2182989420040009, 0.19402551806585222, 0.23278551073072262, 0.25923189401875846, 0.21591752426805477, 0.19883721035379653, 0.19691462842421203, 0.17462680084366422, 0.7123560072192701, 0.17021269316325138, 0.7237365469968433, 0.7413255005857018, 0.20778523458659826, 0.6811146122817522, 0.18026723370058695, 0.7923615462963687, 0.20480454815887483, 0.16730131708707108, 0.6874522806415668, 0.6155507374481741, 0.7416045834051692, 0.5038624627509427, 0.21031833881587503, 0.8248580108064743, 0.19964550228659805, 0.184296772148844, 0.19721821335272427, 0.1933568141736045, 0.1834953097439711, 0.22901001314104186, 0.22786406231714662, 0.1879014411580695, 0.1986106489703744, 0.30287738213137205, 0.08625134298934123, 0.09494900425447483, 0.08116263183426276, 0.08613817834736659, 0.07947375426981229, 0.08553530536800458, 0.07332179027606256, 0.07713267894979947, 0.08388103004923253]}, "mutation_prompt": null}
{"id": "f977b461-a183-48ab-90f5-02515b9b21aa", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Adjusted for preliminary diversification\n        self.mutation_factor = 0.85  # Fine-tuned for a robust mutation process\n        self.crossover_rate = 0.88  # Slightly reduced for targeted crossover\n        self.local_search_intensity = 6  # Enhanced to focus on promising areas\n        self.adaptive_threshold = 0.15  # Lowered for finer sensitivity\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)  # Narrowed for precision in search\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Further increase for intensive local refinement\n            self.mutation_factor = 0.9  # Increased to encourage diversity\n            self.crossover_rate = 0.9  # Balanced for effective exploration\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution with Enhanced Stochastic Local Search for Efficient Global Optimization.", "configspace": "", "generation": 91, "fitness": 0.3600135951741996, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.7643855572206142, 0.7504699382705304, 0.7675568447323244, 0.7630196713439127, 0.7724069172086009, 0.7673804101056431, 0.7519446768188064, 0.7502346500783725, 0.7663014394683614, 0.5426684211160078, 0.5724885299554735, 0.5629528440334626, 0.5950534410963134, 0.5960184596888032, 0.6125084976651967, 0.5400255526164708, 0.5827406904191861, 0.5507520138053018, 0.14419268125904205, 0.2340762797419459, 0.13858378911143843, 0.16852183936414045, 0.15958839977699413, 0.157667536136327, 0.12332625063865121, 0.16416752189271266, 0.25812274926712975, 0.13451588929785607, 0.1414247331540779, 0.1324575602589959, 0.12801232918199834, 0.13285669464261296, 0.1578074800929684, 0.12652105082020804, 0.12330172759444236, 0.13018317560282844, 0.9695285218258503, 0.9517775227040968, 0.962588510453122, 0.9620538878176915, 0.9788101688277804, 0.9463795996094483, 0.9604887930615474, 0.9869782545238756, 0.9607943792163188, 0.4054342408748065, 0.41264581197067374, 0.39377498911041353, 0.42919609356764366, 0.4164160977119902, 0.4096405875859003, 0.4371493674154182, 0.39557687832051724, 0.4199197136230568, 0.6464896868037189, 0.7636733535444921, 0.6298579118494467, 0.7730215733387885, 0.6990639846822455, 0.7546893851059795, 0.6974665651992245, 0.7401157274682654, 0.6741102681094957, 0.31489664732632827, 0.4064438664876461, 0.32306738933396584, 0.36043045187230704, 0.3226855936894546, 0.3363155088682088, 0.38244949167022446, 0.25708612567363076, 0.3554395987928104, 0.4797539462764192, 0.341306057645409, 0.24642332530135524, 0.30409671375946057, 0.3893379570793083, 0.34107265648317764, 0.3287311090417834, 0.3422081414756021, 0.3331582647455058, 0.23156616697452226, 0.26008125794899406, 0.22550102208272815, 0.22899620686013555, 0.2074952940490955, 0.22583127120661572, 0.2613189122866628, 0.26907512199264716, 0.22958882741986142, 0.36167314476143064, 0.37920484176124736, 0.3349549820095272, 0.32686042757424805, 0.3805000455386064, 0.36518553854840297, 0.39537667684377686, 0.3729813181080136, 0.36221023118459694, 0.08167917464397745, 0.08996985319130768, 0.0666784979423235, 0.09198400374230276, 0.10565499645730647, 0.11615353892029712, 0.14600925023048583, 0.07520464950317385, 0.13686935387706212, 0.2428319026394602, 0.22055262729069713, 0.22720288213686923, 0.236323563221837, 0.26877004645849745, 0.23328605460407292, 0.24071743330691875, 0.23656828178401823, 0.2523135063344887, 0.5592542706159587, 0.5696210120853686, 0.5914498775722163, 0.5967126784185895, 0.5599386049678037, 0.6156911303414221, 0.5682353998982301, 0.5601064464029119, 0.5586273406971859, 0.14047916280401407, 0.10845788570868231, 0.12236424485419817, 0.13687228063584078, 0.11896441759782228, 0.14152411106625584, 0.11811272792437977, 0.1462330291701559, 0.10234866306103052, 0.31614704537553906, 0.2763976458278483, 0.2782681900891384, 0.4432195168359925, 0.22808608888170112, 0.2544975219554898, 0.21294377676611198, 0.2026871784407278, 0.19631273136515148, 0.33037214467155074, 0.3178121251298005, 0.33134703353570105, 0.281756682642645, 0.29340549742746547, 0.3083023109614462, 0.33470788064197143, 0.3468871577519663, 0.3305669768806707, 0.24603136679286786, 0.23706859555957294, 0.23031955452003827, 0.22916506527536962, 0.24267877022302087, 0.2413074454220201, 0.26736832396770716, 0.2711265453502708, 0.23981326898114497, 0.2066044801394491, 0.19365633198588028, 0.1897861327173509, 0.1891564357246316, 0.18746160933847256, 0.1949012885060576, 0.1837455295426994, 0.20263047460062056, 0.20965307474189987, 0.2058413675405787, 0.2059665786540611, 0.23520850387716397, 0.3001048697519957, 0.21290626047058958, 0.21259812056315364, 0.3420626055229389, 0.20443531881534782, 0.31772579840476123, 0.7934460238393575, 0.7142344916230537, 0.1509138896689881, 0.7029553807763944, 0.19667699232313884, 0.8097870977768744, 0.18815044275256876, 0.2073967318569494, 0.7966245799088745, 0.16635411096304376, 0.6872811783405828, 0.7005061626815325, 0.5716958008791329, 0.5230370184236786, 0.19294698002611044, 0.8362386032859102, 0.8269609530655486, 0.20944950612609847, 0.1844287651578813, 0.1876044142344615, 0.1834191685469485, 0.20278699657288668, 0.19247869296291742, 0.18199563108967476, 0.20641089552035585, 0.20062254499713283, 0.21103586040949918, 0.08424079231547299, 0.08493294370827209, 0.08867474339024595, 0.08731635147492456, 0.07104223163299306, 0.08038038145615722, 0.07818555057146137, 0.08525545919378696, 0.0854828173231943]}, "mutation_prompt": null}
{"id": "450827a1-296b-4398-8f23-2f20dae661a1", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 25)  # Increased minimal population size for improved exploration in higher dimensions\n        self.mutation_factor = 0.9  # Increased for more aggressive exploration\n        self.crossover_rate = 0.85  # Slightly reduced for balanced diversity\n        self.local_search_intensity = 6  # Increased to intensify local refinement\n        self.adaptive_threshold = 0.3  # Increased for broader parameter adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n        self.quantum_fluctuation = 0.05  # New parameter for quantum-inspired perturbation\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            quantum_effect = np.random.uniform(-self.quantum_fluctuation, self.quantum_fluctuation, self.dim)\n            trial_vector = np.where(crossover, mutant_vector + quantum_effect, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)  # Adjusted range for step size\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Further increase to intensify exploitation\n            self.mutation_factor = 0.85  # Adjusted for optimal balance between exploration and exploitation\n            self.crossover_rate = 0.88  # Fine-tuned for improved recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Crossover and Mutation for Enhanced Solution Diversity and Convergence.", "configspace": "", "generation": 92, "fitness": 0.26992217300805554, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.5183388320484696, 0.5004960375177827, 0.5486701078440257, 0.5616904740077843, 0.5493005282916931, 0.5173060136217877, 0.5328503432619331, 0.5303050668771443, 0.5423280276144278, 0.14438266981359704, 0.11605856826058858, 0.138816587854815, 0.14112406884431916, 0.1316372440881559, 0.12670271724661708, 0.13657339983824446, 0.1565955681106067, 0.153120456028895, 0.1293352932936246, 0.12625473171853518, 0.18085419401969327, 0.15195038319628418, 0.17564508041971416, 0.13849294795860045, 0.15190355055308158, 0.1416475816831868, 0.17932235512902606, 0.12882664328058147, 0.12252072121693924, 0.14929670497962977, 0.12421490295011772, 0.13076017597297573, 0.11916426300610294, 0.13641320537270063, 0.13268081818940103, 0.14545171355466102, 0.9502075932114733, 0.9737490522960155, 0.9663977017110492, 0.962660040851637, 0.9546525424834252, 0.9563484401936168, 0.9386074618199967, 0.9393990314494375, 0.935029702926137, 0.3173596954141279, 0.3289570102565452, 0.32625076584999924, 0.3204350851648493, 0.3255357546766957, 0.3184907023673481, 0.3203355991632124, 0.32081083311232284, 0.318949575879519, 0.61230118835365, 0.5610427771688697, 0.587024191465971, 0.6383115156368537, 0.6922468353680149, 0.654801828306786, 0.6656150367795124, 0.6376657453064285, 0.5633438136589977, 0.2116925614057923, 0.22404915697082006, 0.23052083043527016, 0.23393016788287146, 0.16342034289559781, 0.196575544409341, 0.21201683212309164, 0.21406201763757127, 0.22906122319845368, 0.19623119538870726, 0.12311994107905266, 0.22038102948589278, 0.22333102128183524, 0.22551677319695584, 0.24200169003400362, 0.20375420637636144, 0.22674932655798952, 0.19906770982801536, 0.07748932988315405, 0.10940610582577714, 0.0722713946695982, 0.06638259763726129, 0.06785204579277271, 0.06357579696994575, 0.07401521707533354, 0.05260599008309619, 0.05391720617437856, 0.10139957514447395, 0.14755416576282188, 0.1281309176745281, 0.10743553287019181, 0.10763247903536544, 0.11266350240460032, 0.13248143898913944, 0.11533670562296305, 0.09104010006562491, 0.010082835120136413, 0.0007564302368431308, 0.006237307353204269, 0.0012103540057653017, 0.029704941540993235, 0.010431699828640562, 0.012659765684834179, 0.018754962895141558, 0.012618737588850903, 0.13004766742481189, 0.13096523288493478, 0.1371682377415625, 0.14569762929611474, 0.13908544963867953, 0.1380427405820035, 0.14113521555252917, 0.13955423446762538, 0.14120262125073513, 0.45876834239415, 0.4333313259505277, 0.4368236743862266, 0.443976198842875, 0.4353719451651844, 0.4525250569890278, 0.45056052934971913, 0.43840555487273536, 0.4606988110134326, 0.137567393079437, 0.12475975365285119, 0.14525680541642527, 0.13710382779726604, 0.13334090329646386, 0.1562022137928425, 0.11311493087416347, 0.10838838655092164, 0.11014135902663802, 0.18427270630302428, 0.2294129143280501, 0.2913239640001951, 0.23961328169091534, 0.22625949048331473, 0.22452118151585354, 0.18729521518576886, 0.28446305807562167, 0.3266123729652297, 0.28231274292156183, 0.288722174686708, 0.27900368416154886, 0.29305309684200254, 0.2818451915049043, 0.2757893311110309, 0.2745820138660797, 0.3086566143239978, 0.29611129619250165, 0.23636909984192667, 0.2486597509030748, 0.2216815278377975, 0.23563015195450254, 0.2327240730525183, 0.1834175400563739, 0.21291787640952187, 0.22466431687865163, 0.24393686877872234, 0.18206961832210034, 0.21453729862395332, 0.1948935827065087, 0.20437603397674398, 0.18460103059840538, 0.20905240716170137, 0.1792269643927713, 0.19285492621561684, 0.18814554659409477, 0.21591194831101435, 0.2077501270320279, 0.21321801621432945, 0.19477928370755682, 0.22813257270872178, 0.20617595075387962, 0.2524175832443303, 0.19002847967367864, 0.19392998269195483, 0.708794246980474, 0.19154346169312653, 0.19336149094344335, 0.7075594354674861, 0.18405300542462888, 0.18888060143011176, 0.1894845218021174, 0.6308231141159821, 0.6502932207638784, 0.4871418697886689, 0.2047525931771219, 0.16680181581749798, 0.5427520127034525, 0.622169225967866, 0.5441479232094713, 0.21058763874719055, 0.6495730513776702, 0.6079470386610653, 0.19743909556650885, 0.18053695634771916, 0.1850827620909058, 0.1820823545839575, 0.21195270101990216, 0.2031801075795432, 0.1948396042694035, 0.183146225203631, 0.1817716656217181, 0.07849297990124848, 0.0901324042185816, 0.09892765545969329, 0.08520864554077057, 0.08535024984965367, 0.07429252065343461, 0.08136870305902799, 0.08885209365636915, 0.0779872422947061]}, "mutation_prompt": null}
{"id": "f4db6314-f058-4d15-a03d-526d1e18f329", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "945d7b5b-6a31-470d-ae4d-5e1fb6f5b5c3", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "0b4fa418-c119-473c-8072-a76a11d16afb", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "2bce8bab-b460-4bf6-8eec-5fe4d63fd761", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
{"id": "886d1c93-263d-4df7-a4f1-c16f5beb2c3a", "solution": "import numpy as np\n\nclass AdaptivePositionUpdate:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 18)  # Slightly reduced for smaller exploration needs\n        self.mutation_factor = 0.75  # Modified for tailored mutation\n        self.crossover_rate = 0.88  # Adjusted for precision in exploration\n        self.local_search_intensity = 6  # Increased for thorough local search\n        self.adaptive_threshold = 0.25  # Modified for dynamic adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.15)  # Refined for diversity\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Enhanced for aggressive exploitation\n            self.mutation_factor = 0.85  # Heightened for mutation variability\n            self.crossover_rate = 0.90  # Balanced for recombination efficiency\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "AdaptivePositionUpdate", "description": "Adaptive Position Update Optimization with Stochastic Differential Elements for Enhanced Convergence.", "configspace": "", "generation": 97, "fitness": 0.4300231317173913, "feedback": "The algorithm AdaptivePositionUpdate got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8265438620237274, 0.8238632443508913, 0.8329928077745244, 0.8433776200081355, 0.8439458985753618, 0.8350544110951449, 0.8308166839874502, 0.8335513319100083, 0.8057020933035516, 0.707822556089522, 0.6743783547698161, 0.7079257501291422, 0.6657151616005126, 0.7032883865347128, 0.6929269208961704, 0.7371014101316908, 0.6983194243109795, 0.6854242130872981, 0.16709196522695913, 0.15565083293984006, 0.21616011608002628, 0.22875165558029242, 0.3231235437674145, 0.3560978168144415, 0.2853590869749367, 0.15245006874553568, 0.313730704757909, 0.12431773386471412, 0.4248905100048268, 0.1401664408879475, 0.13569654316926338, 0.34846990992242377, 0.12257754277415844, 0.1468287216451616, 0.13806113901440387, 0.14993682237113737, 0.9518816121111814, 0.9788153091086972, 0.9799882556432842, 0.9716091964444901, 0.9709132448463256, 0.9459072531934226, 0.9510380415592959, 0.9442440548417903, 0.9648785463666212, 0.5178378581331393, 0.5440587244476458, 0.5027901183832502, 0.4865096918849676, 0.47706903871296213, 0.5420633838102962, 0.5721483975250954, 0.608002814056091, 0.5382336472377292, 0.7959944240572709, 0.8228121957272297, 0.8367062000017689, 0.7985425926845027, 0.79473521327952, 0.8437207531799376, 0.7623884509454778, 0.8638602419678819, 0.8110198231116302, 0.4746640114475048, 0.3915440054612426, 0.5240695371364218, 0.39375138273838295, 0.49518041668219115, 0.4044340678402141, 0.4470205221784236, 0.5235068880336898, 0.5450917178564327, 0.2764845345389868, 0.4729321835601227, 0.4615983098777132, 0.542363485356878, 0.4816187124568496, 0.46206821120616404, 0.45009517289258383, 0.493657073797797, 0.5308937186762235, 0.4278420442915889, 0.4218540381981092, 0.3724027979896618, 0.46884302532325806, 0.4150761825179189, 0.23346936915390593, 0.3817788772417148, 0.4986156683552341, 0.37941603587516814, 0.5236261530113324, 0.5747319343552082, 0.60139087038016, 0.47278877070262015, 0.5461769515453133, 0.6144628262134603, 0.5617174803093301, 0.5306758589187273, 0.48452294137990903, 0.0843123469683007, 0.14879627585020316, 0.200567256100882, 0.2889913591462986, 0.3534492614923982, 0.2768507214123176, 0.20625521326071283, 0.2234096212227984, 0.19574086985575678, 0.33526413200366734, 0.3609295588921626, 0.3189221768345787, 0.36794860243983163, 0.38947506578974433, 0.35710570639776995, 0.3432279621849885, 0.3356622470763807, 0.33101545793278797, 0.6863989348436608, 0.681659415777894, 0.7270093229933599, 0.7064291109679091, 0.6778643166156912, 0.690521830981558, 0.7236721481185819, 0.6960605114187863, 0.6997617918193524, 0.12248955453649779, 0.16719842579506272, 0.13668596934156008, 0.14204568677424645, 0.10432938280701187, 0.14280831514594006, 0.1082221721494454, 0.12874485855179196, 0.12236666541731478, 0.19266690525138952, 0.2514154375283105, 0.21860513489062539, 0.4488908378888604, 0.24419497576604388, 0.2800325927020133, 0.42148869382786147, 0.1879385885495094, 0.22059853118611417, 0.3662993206481169, 0.3672488616580577, 0.35245869891263126, 0.3751613170584537, 0.35971940929979696, 0.37850744493508215, 0.4294180360109069, 0.41150237990394, 0.3671287809485191, 0.3048991976861124, 0.30437624052885925, 0.28657727176565784, 0.29287697991132655, 0.3279278011622979, 0.2846522688867704, 0.3567564296605268, 0.3317684552684059, 0.31257129291926533, 0.19913434510063932, 0.19994424158642188, 0.19667532367110285, 0.2243180707254887, 0.19842317513756613, 0.2172944881890737, 0.19566702718675866, 0.1785621891963305, 0.19937399298247105, 0.287653235502198, 0.24624853145880365, 0.4152655508274743, 0.22540139762807343, 0.23944107412292037, 0.21218660422570657, 0.21832633875354734, 0.2807989944022271, 0.22451513051889993, 0.816989852427872, 0.15353680795065283, 0.9023979400926436, 0.8390191859314069, 0.19899272921998679, 0.8341058184700775, 0.20223295238622896, 0.16601514677571738, 0.777952679527083, 0.7429398390950217, 0.1661468711444617, 0.7424125261051595, 0.2070691970704025, 0.20061506317801436, 0.800700787797963, 0.2094162044530945, 0.8314309232788364, 0.8356612288980103, 0.1908333115805383, 0.22269531364414585, 0.19710958979490523, 0.19869369320140173, 0.17571759048781588, 0.19313250077239197, 0.1781113367508328, 0.2092995764612242, 0.19959287390619318, 0.0801502893370949, 0.08616695207385494, 0.08616141583080394, 0.0787214959095518, 0.07387789048456761, 0.07349524431450061, 0.08227294356138515, 0.0866956049434282, 0.0912830833288586]}, "mutation_prompt": null}
{"id": "a4a608cf-a169-45de-848f-c0c99772ad77", "solution": "import numpy as np\n\nclass DynamicAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 25)  # Adjusted for increased diversity\n        self.mutation_factor = 0.65  # Slightly reduced for refined exploration\n        self.crossover_rate = 0.95  # Increased for enhanced recombination\n        self.local_search_intensity = 6  # Adjusted for balanced refinement\n        self.adaptive_threshold = 0.25  # Modified for nuanced adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.03, 0.15)  # Narrowed range for precise exploitation\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 8  # Further enhance exploitation in stable regions\n            self.mutation_factor = 0.85  # Adjusted for fine-tuned diversity\n            self.crossover_rate = 0.93  # Fine-tuned for better recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "DynamicAdaptiveDifferentialEvolution", "description": "Dynamic Adaptive Differential Evolution with Contextual Parameter Tuning for Enhanced Convergence in Black-Box Optimization.", "configspace": "", "generation": 98, "fitness": 0.4238564994800774, "feedback": "The algorithm DynamicAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.25.", "error": "", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.815167299236024, 0.7744976628757907, 0.8070287845963725, 0.8012127646473958, 0.8117318892598983, 0.8077646816118048, 0.7851055650136418, 0.7980159422609142, 0.7911044289851621, 0.6875132884732239, 0.615051091690844, 0.6809005120535307, 0.6562108776009208, 0.6615111161925191, 0.6529118806512826, 0.6510946978861835, 0.6616499793751496, 0.658028764061883, 0.11868869401564497, 0.16555935119715104, 0.13073031340699726, 0.16005493900071088, 0.1440951597606288, 0.15829570653761893, 0.13716233485234408, 0.12846462740614095, 0.1517256328269746, 0.14211497734223444, 0.14896587853956644, 0.14292199879406997, 0.1328310350470545, 0.1579670548757125, 0.15667966267778466, 0.1270895848375414, 0.13268094527375673, 0.13455572702625196, 0.958379904218924, 0.9251598952464963, 0.9214545356699084, 0.9500809412525151, 0.9432343684481231, 0.9658758381836441, 0.9438415969152487, 0.9957134506560764, 0.9671786260221653, 0.5321097925720537, 0.4758985199156113, 0.4831987025607033, 0.5016532916671503, 0.5012643007581254, 0.48891747972100474, 0.48728460955104835, 0.47793975656230936, 0.5115332928232921, 0.7969602728578541, 0.8123737063590852, 0.7848326787348834, 0.8384876251649179, 0.8499235884582919, 0.8468095691689428, 0.7992825749805699, 0.8095824006082959, 0.7974273160569971, 0.45191461205446704, 0.3702670130957224, 0.45473530750965074, 0.42720732852966703, 0.42033932941374297, 0.5681382373014094, 0.4982623451545385, 0.4489610734509445, 0.5573566475587277, 0.4322889840128502, 0.4299764141203698, 0.3125101358715462, 0.4837369291114977, 0.4349064389370403, 0.4404323466914575, 0.566996308864085, 0.47367743190770983, 0.407487581387424, 0.5105749361571008, 0.48021191356152304, 0.5087319550215227, 0.5208389782589096, 0.4325950571928132, 0.5814459537498609, 0.4817989530467034, 0.54490223980433, 0.5067138448227744, 0.5323094002486579, 0.4935689560131331, 0.5747234934535723, 0.5738625054748099, 0.562227946760169, 0.5846141921807219, 0.6327075656888723, 0.5680936142848247, 0.5969221203174173, 0.14013438739128636, 0.2645077117324417, 0.24919885523175778, 0.4327029085301407, 0.3907608117900758, 0.43732625353956067, 0.21665322801194065, 0.28096634256552677, 0.35661033989220514, 0.35494562249350115, 0.3672707159857621, 0.3558454355122519, 0.3916002412907865, 0.3660708607317016, 0.4091852994517693, 0.3395017093063404, 0.3531540864317356, 0.3809797006818608, 0.6472507440828767, 0.6677634484092225, 0.6656617734251216, 0.6865722979275677, 0.6297089216459576, 0.6672929182386071, 0.6843592042279274, 0.6965419887989965, 0.6543735351795092, 0.1245590339396958, 0.14015026696697785, 0.13776692003870228, 0.1344961066876278, 0.152804276509923, 0.1313742072237679, 0.1590843120025467, 0.16583712733072153, 0.1586202690763846, 0.21258852035596398, 0.2707395783758122, 0.1769299427461687, 0.4120652230117269, 0.2798069736863048, 0.21041538711416496, 0.4264087052746438, 0.4486467918110765, 0.22975275500462466, 0.3811129730075691, 0.3706500966089423, 0.34688224351086916, 0.38070487080586934, 0.3491976791679019, 0.3635182307523023, 0.4147373474351407, 0.3856096534359481, 0.3845115411478256, 0.3117377712292043, 0.3103352333498576, 0.30203338941064906, 0.29370466779034377, 0.35529246450475216, 0.3054931669960037, 0.32295712461883974, 0.3344558783124888, 0.31859895508183544, 0.21068682307759623, 0.21314495642065312, 0.21300934327328713, 0.22653485427158104, 0.1979160323927417, 0.21274849313189115, 0.20409000657712273, 0.20661459864696985, 0.2054551901785363, 0.4776323586896688, 0.1960805531520261, 0.3659295182515888, 0.44625611230634554, 0.23428990039985065, 0.20870347716715565, 0.19520297812494591, 0.24244798634730091, 0.22653561491103658, 0.8210823933089014, 0.16667669788920125, 0.20340710778952076, 0.18500453089016977, 0.19791811536446757, 0.1973982362881962, 0.8354947671293067, 0.8100527705427651, 0.2084174396347266, 0.16693441176174306, 0.7791113591044277, 0.7922716725661071, 0.694406316710436, 0.2080402444655025, 0.782323868254439, 0.20943987659957752, 0.8374780423273614, 0.15470118034675762, 0.1842606289729618, 0.1849712978985506, 0.1922354231302944, 0.23742241166682143, 0.20801096688660914, 0.1847547327009995, 0.22267762578450234, 0.20380452570001584, 0.21084505616126104, 0.08031506131541155, 0.09204479077773597, 0.08255150575126013, 0.08642266590596681, 0.08317929221740106, 0.09902166560918446, 0.074646005288597, 0.09680031984577198, 0.08556148092432692]}, "mutation_prompt": null}
{"id": "decdb4bb-e2f4-4ad8-b36f-8467f7cf9442", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4 * dim, 20)  # Ensure a minimal population size for smaller dimensions\n        self.mutation_factor = 0.7  # Refined for a balanced search strategy\n        self.crossover_rate = 0.9  # Increased for improved diversity\n        self.local_search_intensity = 5  # Adjusted for moderate exploration\n        self.adaptive_threshold = 0.2  # Lowered for sensitive adaptation\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.used_budget = 0\n\n    def differential_evolution(self, func):\n        for i in range(self.population_size):\n            if self.used_budget >= self.budget:\n                break\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant_vector = np.clip(a + self.mutation_factor * (b - c), -5, 5)\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial_vector = np.where(crossover, mutant_vector, self.population[i])\n            trial_fitness = func(trial_vector)\n            self.used_budget += 1\n            if trial_fitness < self.fitness[i]:\n                self.fitness[i] = trial_fitness\n                self.population[i] = trial_vector\n\n    def stochastic_local_search(self, func):\n        best_indices = np.argsort(self.fitness)[:self.local_search_intensity]\n        for idx in best_indices:\n            if self.used_budget >= self.budget:\n                break\n            step_size = np.random.uniform(0.05, 0.2)  # Slightly broadened for adaptability\n            perturbation = np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(self.population[idx] + perturbation, -5, 5)\n            candidate_fitness = func(candidate)\n            self.used_budget += 1\n            if candidate_fitness < self.fitness[idx]:\n                self.fitness[idx] = candidate_fitness\n                self.population[idx] = candidate\n\n    def adapt_parameters(self):\n        if np.std(self.fitness) < self.adaptive_threshold:\n            self.local_search_intensity = 7  # Further increase to intensify exploitation\n            self.mutation_factor = 0.8  # Boosted for increased diversity\n            self.crossover_rate = 0.92  # Fine-tuned for optimal recombination\n\n    def __call__(self, func):\n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.used_budget = self.population_size\n        while self.used_budget < self.budget:\n            self.differential_evolution(func)\n            self.stochastic_local_search(func)\n            self.adapt_parameters()\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Adjustment for Optimized Exploration-Exploitation Balance.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "097cb011-0f87-4273-802a-eb52d4609ffe", "metadata": {"aucs": [0.8391328011402109, 0.8452268544964922, 0.8473097170578805, 0.8557784336578853, 0.8568162529387124, 0.8535004566330635, 0.8546851093871589, 0.8287618525600473, 0.847479120105898, 0.7073472880512159, 0.7462713317302508, 0.7321018629038938, 0.737148615029765, 0.7454325276637963, 0.7223917033020593, 0.7269732996011591, 0.7691595098987142, 0.746261501021335, 0.1628478183272971, 0.16886306008595675, 0.1704672625245809, 0.4670768329129039, 0.24631791564865135, 0.29029418302175736, 0.14211296047760769, 0.257192421972954, 0.16549026093624652, 0.13299274437293096, 0.15886040458147743, 0.13293652193965022, 0.14429980091576688, 0.1586995913250826, 0.16947561618496, 0.15296772412769644, 0.1468279328536215, 0.14761300305974823, 0.9525358395242197, 0.9687585193151046, 0.9850353909691685, 0.9465200422012913, 0.97240206575691, 0.9523687325409412, 0.9394332217709392, 0.9522145794991206, 0.9460750349705015, 0.5967902628429413, 0.5873129669440282, 0.6566999922617194, 0.6295945921130082, 0.6411893525085843, 0.6477093519489073, 0.6157999901367854, 0.6433247522009298, 0.6224224241612868, 0.8342556032457463, 0.8887608630358245, 0.9115067601751192, 0.8491305442205701, 0.8402202285793801, 0.8302503658015659, 0.8002779138156726, 0.8541399704400724, 0.8812380490907222, 0.419138226312352, 0.5502409326488262, 0.5227440153860057, 0.6077309432893887, 0.13031971620722793, 0.5866526787399191, 0.45269727595356124, 0.5381672570623575, 0.6196391555896297, 0.6356236545010208, 0.2705033205715831, 0.5288967599284591, 0.5224332503425655, 0.577629316149124, 0.5271363105636757, 0.5283616536681495, 0.5829703225055661, 0.5253383705148832, 0.5447046908488562, 0.5318624821312552, 0.48412910110878515, 0.5655079700675253, 0.6024594751784939, 0.565413565512785, 0.4932073221032732, 0.5552039971901781, 0.5816351839844249, 0.6483964123217487, 0.6450327809491359, 0.6634217737392516, 0.6458106239267756, 0.6800046206954727, 0.6543201690781373, 0.6246771754243325, 0.6846137832918349, 0.6711684736362757, 0.19270641446271175, 0.2011675421486807, 0.3376439761819634, 0.42554759722013746, 0.4078249775466102, 0.38598494249831117, 0.38746003436879806, 0.31984259675724114, 0.2699403629395313, 0.41907678887759603, 0.4815890343472189, 0.4429145253218456, 0.42352366975656763, 0.4298371671135255, 0.46233535817205074, 0.4171887114354056, 0.4524615173027401, 0.40942433900838604, 0.7473231731499779, 0.7736559756875008, 0.7933927021596324, 0.7580785937827312, 0.7496448544530795, 0.7383216244750155, 0.7471099727729131, 0.7855617535192381, 0.7629889719475575, 0.20528970473352315, 0.1138559642792275, 0.1445824942238707, 0.13060407460723855, 0.13225780011859312, 0.14059366853196897, 0.12807017891506944, 0.13143289379176626, 0.13386208340324957, 0.20031098498423994, 0.4854652411022683, 0.23560356283944728, 0.2574575926748566, 0.22734213918753643, 0.21327386019020156, 0.33516314945365444, 0.28838275236413025, 0.19109674408039923, 0.4395056912725561, 0.4204075764306604, 0.46366346294091687, 0.433891392940433, 0.4421366013924839, 0.39043815197151777, 0.4292329064317981, 0.4234917232081129, 0.45064189410321387, 0.33658203230503925, 0.36539473954596224, 0.30561734574099786, 0.33934965787738436, 0.3804969858160083, 0.3266378311241289, 0.37068130441783165, 0.342607147566922, 0.33659700466288134, 0.20161901098560264, 0.19833165494567562, 0.21229162706650018, 0.254978962805646, 0.20333076866933575, 0.18671503468671746, 0.20112604956971714, 0.1933949594501494, 0.183018729991394, 0.383871750488772, 0.451592027466741, 0.21017677424695025, 0.24465935351106993, 0.36414567674248843, 0.21910497409742324, 0.553172334176103, 0.20066607800301928, 0.5619571820418604, 0.1656976669562562, 0.9050358721704517, 0.8795693867746484, 0.17587648036774495, 0.1871318294774631, 0.892228377069795, 0.1637174499976487, 0.17006244544255, 0.8411083318020954, 0.20760809297538363, 0.20664226078156478, 0.16829674081076196, 0.7014972968690789, 0.8475985167918691, 0.1643337500371601, 0.85383264017139, 0.21178586297966628, 0.8620504839918067, 0.20219089717964978, 0.1746083584198801, 0.19051264630085762, 0.18571438630457082, 0.18268978179551565, 0.1981082597741438, 0.23519111211966892, 0.20359382632184608, 0.20338418408161762, 0.0991111433830758, 0.07922941177230969, 0.0827215326703179, 0.08970173541040893, 0.08559576243077627, 0.12460159866859633, 0.0910075221468627, 0.07842332888145143, 0.08114531432068184]}, "mutation_prompt": null}
