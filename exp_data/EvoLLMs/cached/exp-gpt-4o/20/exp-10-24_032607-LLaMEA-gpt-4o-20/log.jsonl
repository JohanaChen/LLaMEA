{"id": "3baafef6-ceb4-480f-b946-a68a91cc7781", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n\n            # Introduce a random walk if stagnated\n            if func_calls > self.budget * 0.8:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1, self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridDE", "description": "A hybrid Differential Evolution and Random Walk optimizer that balances exploration and exploitation for effective convergence across diverse functions.", "configspace": "", "generation": 0, "fitness": 0.18220518965679453, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3912079501444865, 0.3266383939694171, 0.36556076466202103, 0.42112695773405107, 0.41767700522965157, 0.4031902535850025, 0.4330801678097215, 0.40641999444447763, 0.4063241356707843, 0.16401141645217232, 0.12881282264083527, 0.1551924113012687, 0.14896228020272917, 0.15438630915053886, 0.1527358442213348, 0.11717058725562113, 0.1387909869468369, 0.13391719093510834, 0.07314686900648826, 0.07253010426205442, 0.08121123743764269, 0.07177085090706492, 0.08453065676516469, 0.07665421772535008, 0.06952339863884249, 0.0754472636695176, 0.07739288824364543, 0.06248197833079394, 0.0763367558974607, 0.06903049203140477, 0.07610365774508443, 0.06247392214906777, 0.06787859492009907, 0.0660089600260575, 0.06393093246241166, 0.06557440662574066, 0.952105271343092, 0.8934769592379864, 0.8455032084060864, 0.9411010956420673, 0.8876266824856899, 0.8918804734722026, 0.8853546158795746, 0.8963541110683474, 0.9404896514197632, 0.1797952326149267, 0.15511318395370632, 0.15357429193530447, 0.1605595779203759, 0.17850239596260775, 0.1611807758432211, 0.1999253263432872, 0.1883382506809156, 0.1574791898620811, 0.2491414637203644, 0.23613684021287284, 0.22017642848375774, 0.25173873818264925, 0.23372250472539147, 0.2235547570074602, 0.23569843475111507, 0.22358725434480464, 0.25871136069411993, 0.09632831637950168, 0.09843029672103398, 0.09891863755843389, 0.1247170417945288, 0.12696351141683504, 0.10051457463230651, 0.09642439290346172, 0.10559542542075373, 0.09360676463884343, 0.11320350278672886, 0.10977168366516199, 0.12776201087382066, 0.09018882661528027, 0.10064551118901055, 0.0912740518370041, 0.08736786520446638, 0.08661726674571324, 0.11084185465673912, 0.033561793316044586, 0.028134808552921498, 0.028043480567459644, 0.01825085979389418, 0.024349052147681904, 0.04222090260089839, 0.03553875640127113, 0.01882619685795983, 0.04510639031220853, 0.12982671214272012, 0.12477460810110441, 0.15502140075168624, 0.12480003495244762, 0.1304967251476986, 0.11952385735945459, 0.14294606798495857, 0.15938626015574942, 0.17121741092035392, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018502185462996312, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004959598127055598, 0.07462007045504726, 0.07317532571044572, 0.07219048609050205, 0.08381893287447584, 0.07786680711918048, 0.08445327661690205, 0.07662794208810886, 0.09208840282029318, 0.08960321414615069, 0.32438014533957416, 0.35013231954360524, 0.3340546985510072, 0.3478893012940074, 0.3503508608365248, 0.3525140217660445, 0.31897428360733004, 0.3164466001959334, 0.34307263343215944, 0.06669676804542557, 0.07176298931402525, 0.06780284460053299, 0.0633121824860533, 0.06835407545823613, 0.07374822093163658, 0.06823201978292259, 0.05740868279586142, 0.06965077458088431, 0.15250144044464464, 0.13890638079825457, 0.15084399618496136, 0.123309622886427, 0.13937366284470276, 0.14688962759887558, 0.14480337947845123, 0.12606409069624025, 0.12848036756355197, 0.20821113977019212, 0.20868295447383367, 0.23005098770823273, 0.19734313160655526, 0.20773576413196226, 0.20769578401138467, 0.22388138326803708, 0.22482106579679362, 0.2218217461087053, 0.16121317928267542, 0.16258952883364197, 0.150348191896722, 0.1758007912342877, 0.16786842980288363, 0.14959760666592103, 0.15982797300364038, 0.15452971029425822, 0.15594513993144465, 0.1593921891303316, 0.1644095499174466, 0.17705372129415498, 0.16850070735149203, 0.15564019098394877, 0.1852675407192036, 0.17426777439943708, 0.16590944129036012, 0.1912470629632107, 0.15581579387935474, 0.16256827236642624, 0.1622195702770094, 0.15928152004969454, 0.1655065338545475, 0.16087285993451228, 0.16342771288105562, 0.1728985695728319, 0.1533807606956883, 0.4556849368084781, 0.16000397452571757, 0.18141142499548102, 0.3221924258084522, 0.23862669129287317, 0.21180298089736338, 0.1389974803972286, 0.16588342955228685, 0.15968966100806847, 0.2948266205393434, 0.22853045969408936, 0.1610923464475571, 0.16377103082105182, 0.14464552260490726, 0.18669995554822838, 0.18235660919165386, 0.32915264970131297, 0.19295313759784838, 0.16958849603481851, 0.17560901460544587, 0.16966872982194436, 0.18182365148845792, 0.17667858165454742, 0.1711448195307237, 0.17698150224846632, 0.18841439595368548, 0.1791170207743249, 0.05620296367941424, 0.057618815562823, 0.05717919666872928, 0.05837440444041608, 0.05787697600475017, 0.05171586619671542, 0.05559636977456661, 0.05787849589091498, 0.0582018328852133]}, "mutation_prompt": null}
{"id": "bffb2512-8d07-4860-9135-6e4506778868", "solution": "import numpy as np\n\nclass HybridDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'  # Added adaptive mutation strategy\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            # Adaptive mutation strategy adjustment\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            # Adaptive random walk based on stagnation\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.05 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridDEAdaptive", "description": "A hybrid Differential Evolution and Adaptive Random Walk optimizer that adjusts exploration dynamically for improved convergence and robustness across diverse functions.", "configspace": "", "generation": 1, "fitness": 0.2675805175366068, "feedback": "The algorithm HybridDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "3baafef6-ceb4-480f-b946-a68a91cc7781", "metadata": {"aucs": [0.5820935208310847, 0.5302219498435861, 0.5360363166940036, 0.6068573841657648, 0.6660717141892576, 0.6160078916774525, 0.5315772888057124, 0.5738300625844945, 0.5700446508647332, 0.2869593511433213, 0.31205219132258144, 0.31628757893143644, 0.3214448679103079, 0.30303037152935774, 0.32498320872724085, 0.2567978918286822, 0.34524718576590463, 0.3637927369946129, 0.08514039808635476, 0.11349646471887886, 0.10367643415452077, 0.12589212079318657, 0.10962585001177705, 0.11271184477566587, 0.11623136130300393, 0.10289413935851843, 0.14513140126512558, 0.10461067817860292, 0.08197768057109356, 0.1072335352140874, 0.08245329425510373, 0.09720658688572426, 0.09511065059738177, 0.08827600846564987, 0.10277839873338812, 0.08115593956571687, 0.978844527297085, 0.945789676049215, 0.9499638134517645, 0.9445488812420043, 0.9463669404961195, 0.9441436661559767, 0.9654307506483191, 0.943268417819561, 0.9488927691486342, 0.25404779292971613, 0.26546424632542076, 0.2471635081911192, 0.24870491647811088, 0.27760328263574674, 0.2773534375236749, 0.28325799350372693, 0.26577697218642804, 0.2719415191802369, 0.5609980445819999, 0.5644971367638218, 0.5587445965999123, 0.6018278139689696, 0.5938608008894706, 0.5736672524982316, 0.5410891683829734, 0.6035900288445761, 0.6037226054085982, 0.2217466301255553, 0.10443246148266294, 0.22257068883706166, 0.20638542666100368, 0.24684882283278242, 0.11695157669099021, 0.17801259080684262, 0.2630484396621422, 0.22200284617667676, 0.35419023772853075, 0.01948548727010202, 0.17626914347894473, 0.21951397358003744, 0.2568649945976683, 0.19524865176198725, 0.1919681284444169, 0.2534796697959456, 0.2789324363579494, 0.18763744129615478, 0.22769211997077676, 0.1637309541553732, 0.12515536298983043, 0.0494156889720867, 0.1727157308008287, 0.18468975938448629, 0.17186326876312652, 0.17912299771721496, 0.2919229782926783, 0.2886704332907035, 0.2481066274317053, 0.3330874901528046, 0.24014450967955858, 0.2634479937176075, 0.3470816395609386, 0.286297677475034, 0.2871892103854944, 0.05074622567292353, 0.056775656173668865, 0.03310526465932018, 0.043266168427783525, 0.032186751732842134, 0.06950512510318607, 0.056132648202647406, 0.04933486845280699, 0.06524262367027389, 0.17692484871521097, 0.16381338298520254, 0.14864613749254496, 0.17636171908085674, 0.16622148495688416, 0.18655274196294602, 0.05190918893792951, 0.1582990689063416, 0.14958957190589117, 0.47795802088743955, 0.5066563770408219, 0.4853722846411498, 0.4503378042328603, 0.4470054949667689, 0.507378281693176, 0.4925921481958959, 0.467510565274484, 0.4854634148947501, 0.0918312759913289, 0.09675700861903547, 0.07591735125826615, 0.11832381611702292, 0.08013292541247552, 0.08082981988365845, 0.07875905111430315, 0.06521227528849571, 0.0971924775014219, 0.13110236232808836, 0.16525444348182206, 0.13722166811452807, 0.18853191500625233, 0.12739749371049114, 0.1598418004464215, 0.12986116021402083, 0.15696515298022296, 0.18017360992553333, 0.26617769536416225, 0.25077190528214666, 0.298798912008271, 0.2580792317911377, 0.2796979202625566, 0.31489364360818994, 0.31884586474058996, 0.3224824732290281, 0.28566760674935254, 0.23757599462458445, 0.21714276810955524, 0.1946951181508424, 0.1877960921101567, 0.18123176875689606, 0.20565715458658662, 0.23772045630582672, 0.23144245873238267, 0.22185931631860034, 0.18623249116782947, 0.17005927800746246, 0.18312659930244024, 0.16707717507803244, 0.19329900663747512, 0.20305672261323826, 0.180963804824129, 0.18193305050178787, 0.18252911598472288, 0.19032080711387678, 0.18818305484436382, 0.1915547787407218, 0.2926218437343019, 0.18439970715522136, 0.17631005525870846, 0.3071401760408403, 0.2060866635727363, 0.3824923920804659, 0.15019772584827118, 0.11179015482202559, 0.14197835736436448, 0.1888121532927861, 0.551446964810169, 0.14573933490298896, 0.15539735223284656, 0.6081370864117668, 0.18435723961456352, 0.6495319800575108, 0.20004208731057938, 0.5922796468601657, 0.20060063468790823, 0.5583222339877233, 0.1962284076602957, 0.1483835392141345, 0.20368948102291828, 0.15184929517466372, 0.1705912530482594, 0.16888091524106474, 0.17455715260583127, 0.17790231762888853, 0.1646939233194833, 0.19917411442970812, 0.1920439180377831, 0.19220898639210338, 0.17907651236114075, 0.06059136490352468, 0.07211971939347728, 0.06952952602038753, 0.06840073637322497, 0.07037972566890516, 0.06276739505177065, 0.07428828657728359, 0.06377685985179904, 0.06808522580509269]}, "mutation_prompt": null}
{"id": "95946fa7-750f-4a97-aeea-e11eaf73cb9a", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim  # Increased population size for diversity\n        self.F = 0.9  # Slightly increased differential weight for explorative search\n        self.CR = 0.85  # Lower crossover probability for diversity\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'  # Default mutation strategy\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            # Adaptive mutation strategy adjustment\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            # Stochastic tunneling to escape local optima\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.6:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    tunneling_factor = np.random.normal(0, 0.1, self.dim)\n                    tunneled_solution = self.population[i] + tunneling_factor\n                    tunneled_solution = np.clip(tunneled_solution, self.bounds[0], self.bounds[1])\n                    tunneled_fitness = func(tunneled_solution)\n                    func_calls += 1\n                    if tunneled_fitness < self.best_fitness:\n                        self.best_fitness = tunneled_fitness\n                        self.best_solution = tunneled_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedHybridDE", "description": "An enhanced hybrid Differential Evolution with adaptive mutation strategy and stochastic tunneling to escape local optima and improve convergence speed.", "configspace": "", "generation": 2, "fitness": 0.20095935210982022, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "bffb2512-8d07-4860-9135-6e4506778868", "metadata": {"aucs": [0.4534510387651086, 0.39670656186839914, 0.4038200442356017, 0.41404402802079654, 0.45879358378317037, 0.44010120608596714, 0.43806642496537906, 0.42998955438933173, 0.4418763350328869, 0.14702293856605197, 0.14376870654834106, 0.16690238992596496, 0.15160720168562458, 0.166041194454013, 0.16871982313874345, 0.14347632653888087, 0.16761202624148408, 0.13817691206915939, 0.10326047348024603, 0.09514808005742603, 0.07565840822075642, 0.10963788582462641, 0.08085793591306611, 0.08949513268291864, 0.0917658393044749, 0.07708473556050632, 0.10043146069807063, 0.06654990169350461, 0.07520752380744178, 0.08813678796083713, 0.07151659713989611, 0.07565195733044561, 0.07933002753487162, 0.08521943424616041, 0.08363757047681486, 0.07296299651981863, 0.9629191538232315, 0.9326349904777669, 0.9417414646312681, 0.9729453214489195, 0.8951982052781848, 0.9561915496454885, 0.9479206974981257, 0.9575010058179736, 0.9443844750257965, 0.19152002237337895, 0.16760597603800742, 0.16332758969409644, 0.14928941648400118, 0.1719742092235994, 0.1939537304863156, 0.18960491877580787, 0.21447755125484014, 0.1787024466055036, 0.22301901608242714, 0.2279253854799912, 0.2236135257815236, 0.3506906826019912, 0.2259928190064856, 0.24136361212180035, 0.24495730588896092, 0.2152429488284261, 0.23632659129168287, 0.1373059427462231, 0.10149528115286499, 0.15431559133987116, 0.1168586560771997, 0.11669198002925474, 0.11082793291652504, 0.08925602915832387, 0.12365922532657347, 0.13716358183370647, 0.23796642701204607, 0.14266931933975924, 0.09818250522523175, 0.127991147322287, 0.10256875822888145, 0.13259960261086712, 0.10642423208886342, 0.11385604347617662, 0.09328892835653335, 0.024132081605673927, 0.033125138357250616, 0.025922615564323626, 0.044155991929262006, 0.00040211819845148433, 0.028225298162594337, 0.030595751600551724, 0.01229329898992837, 0.07007214445239629, 0.093027561593933, 0.11774996348588906, 0.10874284609976093, 0.09797704730822354, 0.11961527381021675, 0.10177281070760946, 0.13669190475591164, 0.126704435641684, 0.15435797592099976, 0.004581655975169241, 0.0009332260388764668, 0.0007122330798461363, 0.006500600033563897, 9.999999999998899e-05, 0.0012609386017642388, 9.999999999998899e-05, 0.008816358108880928, 0.0013897622894897266, 0.07492339071711596, 0.07150017088543104, 0.07752223057423235, 0.07986384174503569, 0.07498255067084703, 0.08111517905348264, 0.09796485153699741, 0.11388862510696995, 0.09424911354200738, 0.3320361101484617, 0.3709683368804477, 0.3464570449864256, 0.369257210902312, 0.35819020043524474, 0.3598635248825157, 0.3438735385161158, 0.3345998759387727, 0.37360770361336615, 0.07312771923627315, 0.08528516495948701, 0.07271346581607763, 0.06782234954146538, 0.06941852427122708, 0.08733782960760805, 0.06293895979808273, 0.08236015772796179, 0.09194175201037036, 0.13926827854031731, 0.1269592548290619, 0.15052847868227492, 0.1809503568681612, 0.1400040194303438, 0.14090931109553695, 0.14691895659516663, 0.1496955189514756, 0.24182610376613345, 0.22182171036245435, 0.21882226264922944, 0.23354769842465695, 0.21746353949616992, 0.2209049792386073, 0.2111535737499508, 0.25696302038408836, 0.23679703140904973, 0.23767086312474972, 0.19738273860426747, 0.1570257913522859, 0.16583056511211636, 0.18066576559874958, 0.15202751944074766, 0.17084444179005664, 0.1754426647133298, 0.159652679467298, 0.1447582369910313, 0.1664150933112496, 0.15650095230965366, 0.1498905809324078, 0.15854792647087979, 0.1747155550540409, 0.1659975809025469, 0.17469198117090468, 0.1608604887326972, 0.15828959173973578, 0.17568516039906867, 0.16244553565932052, 0.1733527790830156, 0.1865682991098877, 0.1644686063243076, 0.16614057761804046, 0.16350957030038904, 0.17561753018896598, 0.16560547031209139, 0.19417459626329792, 0.45381466678802873, 0.5634252290682868, 0.17656879505533907, 0.4928319264777262, 0.1771615652668026, 0.3180766319843582, 0.1968804065359755, 0.42701393108211183, 0.380022911910859, 0.453340230879968, 0.18543233103246048, 0.3552827839173086, 0.17680978652122326, 0.15544210565449468, 0.4790268275967948, 0.4539155906732555, 0.20181960084266293, 0.1789221756472682, 0.19357004201142836, 0.17426430069697196, 0.18099596746376623, 0.20618741262348483, 0.1836327136507936, 0.18684107967022023, 0.17362878150990524, 0.20011448686710087, 0.05506964955615168, 0.05415566057289467, 0.06163477025875963, 0.0632841380323036, 0.06369549185348222, 0.06617444551795648, 0.06572076496534629, 0.06701429119060232, 0.0624920297051047]}, "mutation_prompt": null}
{"id": "8bea1873-dc6e-48d9-a3e8-58e715b5e67c", "solution": "import numpy as np\n\nclass HybridDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # New adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            # Record fitness for adaptive strategy\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  # Threshold for improvement\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.1, 0.9)\n                    self.CR = np.clip(self.CR, 0.1, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.05 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridDEAdaptive", "description": "A hybrid Differential Evolution and Adaptive Random Walk optimizer with self-adaptive control parameters that dynamically learn from past iterations for enhanced convergence.", "configspace": "", "generation": 3, "fitness": 0.2690057585006219, "feedback": "The algorithm HybridDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "bffb2512-8d07-4860-9135-6e4506778868", "metadata": {"aucs": [0.5833113429012491, 0.5321764600137652, 0.5360363166940036, 0.6104610072082193, 0.6674642700173887, 0.6160268240877259, 0.5332148016923373, 0.5769341632003142, 0.5714147504388751, 0.2869593511433213, 0.31205219132258144, 0.31628757893143644, 0.3214448679103079, 0.30303037152935774, 0.32498320872724085, 0.2567978918286822, 0.34524718576590463, 0.3637927369946129, 0.1709480474615933, 0.12657857484831747, 0.12271400037696789, 0.12589212079318657, 0.10962585001177705, 0.11271184477566587, 0.11623136130300393, 0.10289413935851843, 0.14513140126512558, 0.11648454062192337, 0.0908912367795709, 0.1388166475152528, 0.10012715875259359, 0.09720658688572426, 0.09916993797649742, 0.08827600846564987, 0.10792275737640811, 0.08290154362610269, 0.978844527297085, 0.945789676049215, 0.9499638134517645, 0.9445488812420043, 0.9463669404961195, 0.9441436661559767, 0.9654307506483191, 0.943268417819561, 0.9488927691486342, 0.25404779292971613, 0.26546424632542076, 0.2471635081911192, 0.24870491647811088, 0.27760328263574674, 0.2773534375236749, 0.28325799350372693, 0.26577697218642804, 0.2719415191802369, 0.5609980445819999, 0.5644971367638218, 0.5587445965999123, 0.6018278139689696, 0.5938608008894706, 0.5736672524982316, 0.5410891683829734, 0.6035900288445761, 0.6037226054085982, 0.2217466301255553, 0.10443246148266294, 0.22257068883706166, 0.20638542666100368, 0.24684882283278242, 0.11695157669099021, 0.17801259080684262, 0.2630484396621422, 0.22200284617667676, 0.35419023772853075, 0.01948548727010202, 0.17626914347894473, 0.21951397358003744, 0.2568649945976683, 0.19524865176198725, 0.1919681284444169, 0.2534796697959456, 0.2789324363579494, 0.18763744129615478, 0.22769211997077676, 0.1637309541553732, 0.12515536298983043, 0.0494156889720867, 0.1727157308008287, 0.18468975938448629, 0.17186326876312652, 0.17912299771721496, 0.2919229782926783, 0.2886704332907035, 0.2481066274317053, 0.3330874901528046, 0.24014450967955858, 0.2634479937176075, 0.3470816395609386, 0.286297677475034, 0.2871892103854944, 0.05074622567292353, 0.056775656173668865, 0.03310526465932018, 0.043266168427783525, 0.032186751732842134, 0.06950512510318607, 0.056132648202647406, 0.04933486845280699, 0.06524262367027389, 0.17692484871521097, 0.16381338298520254, 0.14864613749254496, 0.17636171908085674, 0.16622148495688416, 0.18655274196294602, 0.05190918893792951, 0.1582990689063416, 0.14958957190589117, 0.47795802088743955, 0.5066563770408219, 0.4853722846411498, 0.4503378042328603, 0.4470054949667689, 0.507378281693176, 0.4925921481958959, 0.467510565274484, 0.4854634148947501, 0.09543764945001798, 0.09537828773050405, 0.0825719994069739, 0.11818442532380324, 0.0860093784896162, 0.0787050192713945, 0.07916133608136366, 0.0669967979612982, 0.09563899199614712, 0.14668300982301175, 0.16356692802442085, 0.14216268377636043, 0.18853191500625233, 0.12877008857966865, 0.1598418004464215, 0.13237763893699617, 0.13946575827725882, 0.18017360992553333, 0.26617769536416225, 0.25077190528214666, 0.298798912008271, 0.2580792317911377, 0.2796979202625566, 0.31489364360818994, 0.31884586474058996, 0.3224824732290281, 0.28566760674935254, 0.23757599462458445, 0.21714276810955524, 0.1946951181508424, 0.1877960921101567, 0.18123176875689606, 0.20565715458658662, 0.23772045630582672, 0.23144245873238267, 0.2203273695446024, 0.18623249116782947, 0.171376082877419, 0.17983743280148679, 0.17347034589027466, 0.20168615541656298, 0.17286501416217326, 0.18615923706454396, 0.19113491456427434, 0.19592003019062965, 0.19032080711387678, 0.18818305484436382, 0.1915547787407218, 0.2926218437343019, 0.18439970715522136, 0.17631005525870846, 0.3071401760408403, 0.2060866635727363, 0.3824923920804659, 0.15019772585668034, 0.11179015482202559, 0.14197835736436448, 0.18881215328413414, 0.551446964810169, 0.14573933490298896, 0.15539735223315276, 0.6081370864117668, 0.18435723965313622, 0.6495319800575108, 0.20004208731703654, 0.5922796468601657, 0.20060063467994182, 0.5583222339877233, 0.1962284076602957, 0.14838353921364011, 0.20368948102646267, 0.15184929517466372, 0.1754356056694798, 0.16641390360499442, 0.17455715260583127, 0.16940882950163727, 0.17161960181128866, 0.19917411442970812, 0.19204391803777743, 0.20331995678292192, 0.20122859857337783, 0.06783102167335786, 0.07630209728502091, 0.07107809461127512, 0.0678356527149585, 0.06816713300884569, 0.07664456504351713, 0.07620436387074936, 0.06764224102341687, 0.07156877843304388]}, "mutation_prompt": null}
{"id": "834ec159-2de0-4108-be33-3d9078cbc251", "solution": "import numpy as np\n\nclass EnhancedDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Enhanced adaptive factor for more gradual adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 30:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:  # Adjusted threshold for improvement\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.1, 0.9)\n                    self.CR = np.clip(self.CR, 0.1, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedDEAdaptive", "description": "An enhanced Differential Evolution with Adaptive Random Walk and dynamic parameter tuning based on historical fitness variance to improve exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.26779254703981925, "feedback": "The algorithm EnhancedDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "8bea1873-dc6e-48d9-a3e8-58e715b5e67c", "metadata": {"aucs": [0.5822735552788787, 0.531263845035546, 0.5360363166940036, 0.6084374441646834, 0.6663532866264164, 0.6168931599598108, 0.5337672546290394, 0.5763651595964879, 0.57149885151116, 0.2869593511433213, 0.31205219132258144, 0.31628757893143644, 0.3214448679103079, 0.30303037152935774, 0.32498320872724085, 0.2567978918286822, 0.34524718576590463, 0.3637927369946129, 0.08514039808635476, 0.11349646471887886, 0.10367643415452077, 0.12589212079318657, 0.10962585001177705, 0.11271184477566587, 0.11623136130300393, 0.10289413935851843, 0.14513140126512558, 0.10461067817860292, 0.08197768057109356, 0.1072335352140874, 0.08245329425510373, 0.09720658688572426, 0.09511065059738177, 0.08827600846564987, 0.10277839873338812, 0.08187120165677009, 0.978844527297085, 0.945789676049215, 0.9499638134517645, 0.9445488812420043, 0.9463669404961195, 0.9441436661559767, 0.9654307506483191, 0.943268417819561, 0.9488927691486342, 0.25404779292971613, 0.26546424632542076, 0.2471635081911192, 0.24870491647811088, 0.27760328263574674, 0.2773534375236749, 0.28325799350372693, 0.26577697218642804, 0.2719415191802369, 0.5609980445819999, 0.5644971367638218, 0.5587445965999123, 0.6018278139689696, 0.5938608008894706, 0.5736672524982316, 0.5410891683829734, 0.6035900288445761, 0.6037226054085982, 0.2217466301255553, 0.10443246148266294, 0.22257068883706166, 0.20638542666100368, 0.24684882283278242, 0.11695157669099021, 0.17801259080684262, 0.2630484396621422, 0.22200284617667676, 0.35419023772853075, 0.01948548727010202, 0.17626914347894473, 0.21951397358003744, 0.2568649945976683, 0.19524865176198725, 0.1919681284444169, 0.2534796697959456, 0.2789324363579494, 0.18763744129615478, 0.22769211997077676, 0.1637309541553732, 0.12515536298983043, 0.0494156889720867, 0.1727157308008287, 0.18468975938448629, 0.17186326876312652, 0.17912299771721496, 0.2919229782926783, 0.2886704332907035, 0.2481066274317053, 0.3330874901528046, 0.24014450967955858, 0.2634479937176075, 0.3470816395609386, 0.286297677475034, 0.2871892103854944, 0.05074622567292353, 0.056775656173668865, 0.03310526465932018, 0.043266168427783525, 0.032186751732842134, 0.06950512510318607, 0.056132648202647406, 0.04933486845280699, 0.06524262367027389, 0.17692484871521097, 0.16381338298520254, 0.14864613749254496, 0.17636171908085674, 0.16622148495688416, 0.18655274196294602, 0.05190918893792951, 0.1582990689063416, 0.14958957190589117, 0.47795802088743955, 0.5066563770408219, 0.4853722846411498, 0.4503378042328603, 0.4470054949667689, 0.507378281693176, 0.4925921481958959, 0.467510565274484, 0.4854634148947501, 0.0918312759913289, 0.09675700861903547, 0.07293919369346025, 0.11832381611702292, 0.08009315227095282, 0.08082981988365845, 0.07936124670697464, 0.06501050349071069, 0.09767008426808443, 0.12561962699495455, 0.1694461282525772, 0.13646479021570523, 0.18853191500625233, 0.12739749371049114, 0.1598418004464215, 0.12975277831105236, 0.15696515298022296, 0.18017360992553333, 0.26617769536416225, 0.25077190528214666, 0.298798912008271, 0.2580792317911377, 0.2796979202625566, 0.31489364360818994, 0.31884586474058996, 0.3224824732290281, 0.28566760674935254, 0.23757599462458445, 0.21714276810955524, 0.1946951181508424, 0.1877960921101567, 0.18123176875689606, 0.20565715458658662, 0.23772045630582672, 0.23144245873238267, 0.22185931631860034, 0.18623249116782947, 0.17446564602036652, 0.178876227582484, 0.16876203562605774, 0.19296520150599106, 0.18057678445594905, 0.19537587884829832, 0.18255107071353738, 0.19697007611015338, 0.19032080711387678, 0.18818305484436382, 0.1915547787407218, 0.2926218437343019, 0.18439970715522136, 0.17631005525870846, 0.3071401760408403, 0.2060866635727363, 0.3824923920804659, 0.1501977259047188, 0.11179015482202559, 0.14197835736436448, 0.18881215329385792, 0.551446964810169, 0.14573933490298896, 0.15539735223261364, 0.6081370864117668, 0.18435723965599704, 0.6495319800575108, 0.20004208736619755, 0.5922796468601657, 0.20060063466209532, 0.5583222339877233, 0.1962284076602957, 0.14838353921654068, 0.20368948102111095, 0.15184929517466372, 0.17214225051480914, 0.16888091524106474, 0.17455715260583127, 0.167059260381326, 0.17723125757794156, 0.19917411442970812, 0.1920439180377831, 0.19220898639210338, 0.17907651236114075, 0.07786852292459989, 0.0704559045651767, 0.06852876831490007, 0.06856560648811594, 0.06810322438723015, 0.06678130516301484, 0.0787211744940447, 0.06837925562426594, 0.0700228624358522]}, "mutation_prompt": null}
{"id": "1d8d72c1-5d81-416c-b03e-64379c56b7e0", "solution": "import numpy as np\n\nclass HybridDENonlinear:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.F = 0.9  # Increased differential weight for exploration\n        self.CR = 0.8  # Reduced crossover probability for diversity\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR ** (1.0 / (j + 1)) or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.1, 0.9)\n                    self.CR = np.clip(self.CR, 0.1, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.05 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridDENonlinear", "description": "A self-adaptive Differential Evolution algorithm integrating nonlinear migration strategies and dynamic crossover probabilities for improved convergence.", "configspace": "", "generation": 5, "fitness": 0.22608810395355464, "feedback": "The algorithm HybridDENonlinear got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "8bea1873-dc6e-48d9-a3e8-58e715b5e67c", "metadata": {"aucs": [0.4561119108075825, 0.4353714206590855, 0.43864029764953083, 0.49765149030559463, 0.4718041578734312, 0.5497326797436153, 0.47206976738969864, 0.5000303038669649, 0.5054143644232778, 0.21026747832812498, 0.23493927906447343, 0.2023539083528315, 0.2554895845908034, 0.22841956310748202, 0.21214292242829447, 0.18494340446900026, 0.2128401644822404, 0.22195656134474528, 0.10558323348798626, 0.12272962914306806, 0.10151668682944459, 0.0995203454376582, 0.09540778344804823, 0.19415923807958013, 0.15302712998016665, 0.11759245204588364, 0.09704939296901116, 0.07782860460961205, 0.08090368542537396, 0.09525325651311212, 0.08737014162320522, 0.08434915111544672, 0.07465452624101232, 0.08449548729123868, 0.10495899887604243, 0.08332169120064647, 0.9487158259497689, 0.9495038566645673, 0.9450349070149977, 0.9733017338559303, 0.9734295158022881, 0.9263185651115107, 0.9780639909283041, 0.9585350646705736, 0.9519526726341293, 0.20511780421640324, 0.18896778989355756, 0.21394479884577344, 0.26928432170502836, 0.22073652058194715, 0.23720236372658232, 0.08019682736022915, 0.23206625732552977, 0.2160713217228004, 0.4051126947350976, 0.47103670096280226, 0.5404656310311631, 0.476898995953977, 0.40046069443172205, 0.47773207823413166, 0.3295929043084015, 0.34609224632406, 0.4452905837084372, 0.14833484298544664, 0.12811822284427687, 0.1786493276035862, 0.18423934978933654, 0.19540423744260027, 0.1830974426715305, 0.11099813326576402, 0.17262314510723686, 0.17160134527131754, 0.009177967497620565, 0.009499680826576151, 0.1372000264343871, 0.21753590546544999, 0.12575416124958483, 0.16468184042554457, 0.18703298811302382, 0.11672175920969563, 0.17986249207704297, 0.08379376139562977, 0.10458090047786739, 0.0678842224690478, 0.06482037671265484, 0.058631063069071065, 0.08835947037156056, 0.08122335075433018, 0.05637360662149471, 0.086075550231005, 0.2263845666066563, 0.2539844998647067, 0.16613654481088436, 0.17841341015832735, 0.2026487360021353, 0.1919250175548438, 0.20148270328512385, 0.27469732858003093, 0.2409000899172401, 0.03833088745868152, 0.0389166446192325, 0.009684376557547503, 0.022485201853340575, 0.02594908225791115, 0.011251761469679655, 0.04804919285063203, 0.03202121079316422, 0.023784239465669765, 0.035163949493585256, 0.11227368689448558, 0.12802766439965274, 0.10215191962335668, 0.1402057424937082, 0.12715775627065795, 0.11988930667493536, 0.09664462341357138, 0.0968742909317436, 0.3647408960623426, 0.3836353471889359, 0.4041514594499689, 0.40473685452044883, 0.4094118997256747, 0.4513572459651779, 0.4115576958069329, 0.4233643554363, 0.36429965999787406, 0.07915952792650127, 0.10013075456420206, 0.07393475923891657, 0.07737735401609602, 0.07319807903796138, 0.08282028805507036, 0.08097951868332898, 0.11809680538670819, 0.0644453988284669, 0.1518547125815417, 0.2473386122985889, 0.24018081848060224, 0.13802122749468648, 0.17053128258380024, 0.14851518966734256, 0.1622113477814493, 0.21070185206639513, 0.13392897973680862, 0.24167894751998842, 0.24116876655967212, 0.25810163149948206, 0.2602369610856303, 0.23446344746369807, 0.21881644294577407, 0.2648606425603778, 0.26687266752735506, 0.29913685243613997, 0.20596307690986493, 0.18877605732384828, 0.1765731940655163, 0.2089502666552746, 0.17028790640332903, 0.17107564641601913, 0.18007941728066001, 0.23413576597664298, 0.21406204550010666, 0.18014191717596295, 0.185936946245562, 0.15777899130472017, 0.17442806825518542, 0.17497804279774065, 0.16709019328540597, 0.16328710889589348, 0.17311388571263775, 0.18897390491884858, 0.21212873995312798, 0.18771699117145924, 0.20829880913233878, 0.1638684502740504, 0.17488215927605366, 0.1692370772435705, 0.1757037844473187, 0.18392878556788395, 0.18771152405945035, 0.14766662229638805, 0.19542009497306867, 0.16953929414517876, 0.502970796274798, 0.17272368385310888, 0.1814647923549192, 0.17561294804639982, 0.1269861906175085, 0.5998968333428364, 0.19955560741713263, 0.1923942399404467, 0.1944879761624252, 0.5256318479091642, 0.14797870631897037, 0.4785835258340627, 0.14913913780441346, 0.12520136921223202, 0.20110900587281244, 0.16973800278155127, 0.16982133303817848, 0.17472371534882114, 0.18203577104914048, 0.18199862935283195, 0.16710071232978319, 0.16641168718384092, 0.1630461817050476, 0.17124107874263594, 0.06994713335856395, 0.06847527995963898, 0.0697582511626118, 0.06547694437349272, 0.06691710820228036, 0.058845763824687314, 0.0678467865869774, 0.058574647097879295, 0.0728447514780517]}, "mutation_prompt": null}
{"id": "2908e9c9-9b3f-4530-837e-edf026d63af6", "solution": "import numpy as np\n\nclass HybridDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # New adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            # Record fitness for adaptive strategy\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  # Threshold for improvement\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.1, 0.9)\n                    self.CR = np.clip(self.CR, 0.1, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.05 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridDEAdaptive", "description": "A hybrid Differential Evolution and Adaptive Random Walk optimizer with self-adaptive control parameters that dynamically learn from past iterations for enhanced convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8bea1873-dc6e-48d9-a3e8-58e715b5e67c", "metadata": {"aucs": [0.5833113429012491, 0.5321764600137652, 0.5360363166940036, 0.6104610072082193, 0.6674642700173887, 0.6160268240877259, 0.5332148016923373, 0.5769341632003142, 0.5714147504388751, 0.2869593511433213, 0.31205219132258144, 0.31628757893143644, 0.3214448679103079, 0.30303037152935774, 0.32498320872724085, 0.2567978918286822, 0.34524718576590463, 0.3637927369946129, 0.1709480474615933, 0.12657857484831747, 0.12271400037696789, 0.12589212079318657, 0.10962585001177705, 0.11271184477566587, 0.11623136130300393, 0.10289413935851843, 0.14513140126512558, 0.11648454062192337, 0.0908912367795709, 0.1388166475152528, 0.10012715875259359, 0.09720658688572426, 0.09916993797649742, 0.08827600846564987, 0.10792275737640811, 0.08290154362610269, 0.978844527297085, 0.945789676049215, 0.9499638134517645, 0.9445488812420043, 0.9463669404961195, 0.9441436661559767, 0.9654307506483191, 0.943268417819561, 0.9488927691486342, 0.25404779292971613, 0.26546424632542076, 0.2471635081911192, 0.24870491647811088, 0.27760328263574674, 0.2773534375236749, 0.28325799350372693, 0.26577697218642804, 0.2719415191802369, 0.5609980445819999, 0.5644971367638218, 0.5587445965999123, 0.6018278139689696, 0.5938608008894706, 0.5736672524982316, 0.5410891683829734, 0.6035900288445761, 0.6037226054085982, 0.2217466301255553, 0.10443246148266294, 0.22257068883706166, 0.20638542666100368, 0.24684882283278242, 0.11695157669099021, 0.17801259080684262, 0.2630484396621422, 0.22200284617667676, 0.35419023772853075, 0.01948548727010202, 0.17626914347894473, 0.21951397358003744, 0.2568649945976683, 0.19524865176198725, 0.1919681284444169, 0.2534796697959456, 0.2789324363579494, 0.18763744129615478, 0.22769211997077676, 0.1637309541553732, 0.12515536298983043, 0.0494156889720867, 0.1727157308008287, 0.18468975938448629, 0.17186326876312652, 0.17912299771721496, 0.2919229782926783, 0.2886704332907035, 0.2481066274317053, 0.3330874901528046, 0.24014450967955858, 0.2634479937176075, 0.3470816395609386, 0.286297677475034, 0.2871892103854944, 0.05074622567292353, 0.056775656173668865, 0.03310526465932018, 0.043266168427783525, 0.032186751732842134, 0.06950512510318607, 0.056132648202647406, 0.04933486845280699, 0.06524262367027389, 0.17692484871521097, 0.16381338298520254, 0.14864613749254496, 0.17636171908085674, 0.16622148495688416, 0.18655274196294602, 0.05190918893792951, 0.1582990689063416, 0.14958957190589117, 0.47795802088743955, 0.5066563770408219, 0.4853722846411498, 0.4503378042328603, 0.4470054949667689, 0.507378281693176, 0.4925921481958959, 0.467510565274484, 0.4854634148947501, 0.09543764945001798, 0.09537828773050405, 0.0825719994069739, 0.11818442532380324, 0.0860093784896162, 0.0787050192713945, 0.07916133608136366, 0.0669967979612982, 0.09563899199614712, 0.14668300982301175, 0.16356692802442085, 0.14216268377636043, 0.18853191500625233, 0.12877008857966865, 0.1598418004464215, 0.13237763893699617, 0.13946575827725882, 0.18017360992553333, 0.26617769536416225, 0.25077190528214666, 0.298798912008271, 0.2580792317911377, 0.2796979202625566, 0.31489364360818994, 0.31884586474058996, 0.3224824732290281, 0.28566760674935254, 0.23757599462458445, 0.21714276810955524, 0.1946951181508424, 0.1877960921101567, 0.18123176875689606, 0.20565715458658662, 0.23772045630582672, 0.23144245873238267, 0.2203273695446024, 0.18623249116782947, 0.171376082877419, 0.17983743280148679, 0.17347034589027466, 0.20168615541656298, 0.17286501416217326, 0.18615923706454396, 0.19113491456427434, 0.19592003019062965, 0.19032080711387678, 0.18818305484436382, 0.1915547787407218, 0.2926218437343019, 0.18439970715522136, 0.17631005525870846, 0.3071401760408403, 0.2060866635727363, 0.3824923920804659, 0.15019772585668034, 0.11179015482202559, 0.14197835736436448, 0.18881215328413414, 0.551446964810169, 0.14573933490298896, 0.15539735223315276, 0.6081370864117668, 0.18435723965313622, 0.6495319800575108, 0.20004208731703654, 0.5922796468601657, 0.20060063467994182, 0.5583222339877233, 0.1962284076602957, 0.14838353921364011, 0.20368948102646267, 0.15184929517466372, 0.1754356056694798, 0.16641390360499442, 0.17455715260583127, 0.16940882950163727, 0.17161960181128866, 0.19917411442970812, 0.19204391803777743, 0.20331995678292192, 0.20122859857337783, 0.06783102167335786, 0.07630209728502091, 0.07107809461127512, 0.0678356527149585, 0.06816713300884569, 0.07664456504351713, 0.07620436387074936, 0.06764224102341687, 0.07156877843304388]}, "mutation_prompt": null}
{"id": "e53bab68-a5c3-4a36-a1f3-e2b88a9b7d61", "solution": "import numpy as np\n\nclass EnhancedCoEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim\n        self.F = 0.7  # Differential weight\n        self.CR = 0.85  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            # Record fitness for adaptive strategy\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 25:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:  # Threshold for improvement\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.8)\n                    self.CR = np.clip(self.CR, 0.3, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.85 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.03 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedCoEvoStrategy", "description": "An enhanced Evolutionary Strategy integrating co-evolutionary learning and adaptive hyper-parameter tuning for diverse search dynamics.", "configspace": "", "generation": 7, "fitness": 0.27608659156693266, "feedback": "The algorithm EnhancedCoEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "8bea1873-dc6e-48d9-a3e8-58e715b5e67c", "metadata": {"aucs": [0.6212730144222223, 0.5822803759825839, 0.6484738024847313, 0.6462474054231456, 0.6199306929498443, 0.6311105237302486, 0.6403644839680303, 0.6414608575605945, 0.6093203810111976, 0.2879775480152652, 0.306568127324351, 0.38424132818125056, 0.34418804651905344, 0.3581643776999416, 0.3635708904916376, 0.3644498844288845, 0.2984234221439225, 0.3435660231694606, 0.12975045279374886, 0.11021187319210735, 0.1067913511158799, 0.10847725995434898, 0.11648351075339491, 0.10746454239007741, 0.10627671136797123, 0.09607567140575357, 0.08949023664911604, 0.09285295050589015, 0.09095920635101107, 0.09305833092999294, 0.08813554701875492, 0.10074290186123414, 0.09178145566525842, 0.10070185353157135, 0.12101794980243574, 0.0771369648329, 0.9465913700349144, 0.9506048564924587, 0.9395785003260498, 0.953752093854986, 0.9503897973679744, 0.9482142210800395, 0.940607635129823, 0.9683524640771615, 0.9443931012666298, 0.2548853822370677, 0.24309142998384048, 0.2640986466969395, 0.2550764832787973, 0.2442443805156428, 0.27193364449719115, 0.279612900881695, 0.2770946564187744, 0.25979100892599183, 0.5586626829113956, 0.5026773127505443, 0.57481029293122, 0.6354151246281377, 0.6106846300638828, 0.656715167252417, 0.5651024453964892, 0.5805979804047492, 0.6344649794895563, 0.11436997630276435, 0.2493480416343008, 0.18593565274807478, 0.3142761778577804, 0.11376609072353672, 0.23814594716172532, 0.24017196448503098, 0.34020568389820705, 0.24130114752830578, 0.05067704796997008, 0.2895811709104925, 0.22832679577655024, 0.23765918713156686, 0.24645306895487296, 0.20452241548439765, 0.1103503486707128, 0.21370441656554262, 0.1846630549145749, 0.13345462711348322, 0.15003386229623905, 0.17860184854402883, 0.06793368708741854, 0.014332576615357362, 0.17505723028107856, 0.15701192492909233, 0.10247537267164242, 0.1699061843895201, 0.27235047144430313, 0.23145750192429926, 0.2586992103689315, 0.27483160324797706, 0.21933350800436346, 0.23023072783189713, 0.3435970548511236, 0.30908215505652403, 0.31163825247264854, 0.04592969537365732, 0.05226101402601202, 0.06659467726485058, 0.09200414933681, 0.06712564772088903, 0.05776334494718072, 0.05446756822964394, 0.07907116478220122, 0.07392988190054928, 0.14522243743935215, 0.17032585465867145, 0.15754744494624917, 0.1720102685288486, 0.18061078144301135, 0.1974435825891776, 0.14019311462193196, 0.17411664574513674, 0.1857476385845529, 0.5554680930932958, 0.5024507115739085, 0.5001901518542595, 0.524144238086214, 0.47682072481385407, 0.46341708460791653, 0.4821461660651637, 0.48917074597385035, 0.5506010819167293, 0.11076272250748775, 0.08892926855239913, 0.07749468724894304, 0.0861357056338029, 0.09251394806978697, 0.08650886540378866, 0.07130842269553939, 0.0799179315343006, 0.09881067252423859, 0.1345271996371935, 0.15552137095852558, 0.17356986412198128, 0.18776876785859453, 0.2589144892332256, 0.14128494159505967, 0.17102380184459143, 0.12230124553474109, 0.18505293340650142, 0.3221911956941126, 0.28163799787213206, 0.3109583844522158, 0.2828666219034768, 0.2955336706850936, 0.2713081255185904, 0.30632705276212924, 0.3335445080942899, 0.32435388546193633, 0.24847616145586093, 0.26443067675810716, 0.23514279502102542, 0.228363154878505, 0.21979199848967124, 0.17340474809422668, 0.23712637306818063, 0.22121161803738532, 0.24402909168198839, 0.19386426414955382, 0.17126559436017885, 0.18966614382683222, 0.17832181577329542, 0.17761511429783572, 0.1761647958313024, 0.1804961951728039, 0.17507194421585626, 0.1855370949515005, 0.20647360636131584, 0.1929690796676542, 0.1963572353383375, 0.18290214948486694, 0.2968620612692763, 0.190826813914026, 0.18406915673932678, 0.2032503528397368, 0.18153264941296576, 0.16741108344558087, 0.15194075215164304, 0.14760541137144667, 0.6703493790975841, 0.17828135301017978, 0.6409598761026181, 0.5620101297165006, 0.1881546038775569, 0.6103682156446708, 0.6355814337263379, 0.1922199000532524, 0.19684446723893312, 0.19800234487072998, 0.19664736657906945, 0.14061739890603808, 0.19663407492787632, 0.14491560887658506, 0.7113679380097124, 0.17579046500555073, 0.18668645980717746, 0.2119972637159504, 0.18647304254346686, 0.19771281414339992, 0.17590921611462274, 0.17380396869980907, 0.18821134992415922, 0.1891721152584489, 0.07407728173300199, 0.07463472369498636, 0.06275628744523942, 0.07270653740407618, 0.07143714111371591, 0.07111460708433748, 0.07910858605456073, 0.06765136674848071, 0.06853520596942364]}, "mutation_prompt": null}
{"id": "92fe4057-7916-4e6c-ae0f-7099e8e8c100", "solution": "import numpy as np\n\nclass EnhancedCoEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim\n        self.F = 0.7  # Differential weight\n        self.CR = 0.85  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            # Record fitness for adaptive strategy\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 25:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:  # Threshold for improvement\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.8)\n                    self.CR = np.clip(self.CR, 0.3, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.85 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.03 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedCoEvoStrategy", "description": "An enhanced Evolutionary Strategy integrating co-evolutionary learning and adaptive hyper-parameter tuning for diverse search dynamics.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e53bab68-a5c3-4a36-a1f3-e2b88a9b7d61", "metadata": {"aucs": [0.6212730144222223, 0.5822803759825839, 0.6484738024847313, 0.6462474054231456, 0.6199306929498443, 0.6311105237302486, 0.6403644839680303, 0.6414608575605945, 0.6093203810111976, 0.2879775480152652, 0.306568127324351, 0.38424132818125056, 0.34418804651905344, 0.3581643776999416, 0.3635708904916376, 0.3644498844288845, 0.2984234221439225, 0.3435660231694606, 0.12975045279374886, 0.11021187319210735, 0.1067913511158799, 0.10847725995434898, 0.11648351075339491, 0.10746454239007741, 0.10627671136797123, 0.09607567140575357, 0.08949023664911604, 0.09285295050589015, 0.09095920635101107, 0.09305833092999294, 0.08813554701875492, 0.10074290186123414, 0.09178145566525842, 0.10070185353157135, 0.12101794980243574, 0.0771369648329, 0.9465913700349144, 0.9506048564924587, 0.9395785003260498, 0.953752093854986, 0.9503897973679744, 0.9482142210800395, 0.940607635129823, 0.9683524640771615, 0.9443931012666298, 0.2548853822370677, 0.24309142998384048, 0.2640986466969395, 0.2550764832787973, 0.2442443805156428, 0.27193364449719115, 0.279612900881695, 0.2770946564187744, 0.25979100892599183, 0.5586626829113956, 0.5026773127505443, 0.57481029293122, 0.6354151246281377, 0.6106846300638828, 0.656715167252417, 0.5651024453964892, 0.5805979804047492, 0.6344649794895563, 0.11436997630276435, 0.2493480416343008, 0.18593565274807478, 0.3142761778577804, 0.11376609072353672, 0.23814594716172532, 0.24017196448503098, 0.34020568389820705, 0.24130114752830578, 0.05067704796997008, 0.2895811709104925, 0.22832679577655024, 0.23765918713156686, 0.24645306895487296, 0.20452241548439765, 0.1103503486707128, 0.21370441656554262, 0.1846630549145749, 0.13345462711348322, 0.15003386229623905, 0.17860184854402883, 0.06793368708741854, 0.014332576615357362, 0.17505723028107856, 0.15701192492909233, 0.10247537267164242, 0.1699061843895201, 0.27235047144430313, 0.23145750192429926, 0.2586992103689315, 0.27483160324797706, 0.21933350800436346, 0.23023072783189713, 0.3435970548511236, 0.30908215505652403, 0.31163825247264854, 0.04592969537365732, 0.05226101402601202, 0.06659467726485058, 0.09200414933681, 0.06712564772088903, 0.05776334494718072, 0.05446756822964394, 0.07907116478220122, 0.07392988190054928, 0.14522243743935215, 0.17032585465867145, 0.15754744494624917, 0.1720102685288486, 0.18061078144301135, 0.1974435825891776, 0.14019311462193196, 0.17411664574513674, 0.1857476385845529, 0.5554680930932958, 0.5024507115739085, 0.5001901518542595, 0.524144238086214, 0.47682072481385407, 0.46341708460791653, 0.4821461660651637, 0.48917074597385035, 0.5506010819167293, 0.11076272250748775, 0.08892926855239913, 0.07749468724894304, 0.0861357056338029, 0.09251394806978697, 0.08650886540378866, 0.07130842269553939, 0.0799179315343006, 0.09881067252423859, 0.1345271996371935, 0.15552137095852558, 0.17356986412198128, 0.18776876785859453, 0.2589144892332256, 0.14128494159505967, 0.17102380184459143, 0.12230124553474109, 0.18505293340650142, 0.3221911956941126, 0.28163799787213206, 0.3109583844522158, 0.2828666219034768, 0.2955336706850936, 0.2713081255185904, 0.30632705276212924, 0.3335445080942899, 0.32435388546193633, 0.24847616145586093, 0.26443067675810716, 0.23514279502102542, 0.228363154878505, 0.21979199848967124, 0.17340474809422668, 0.23712637306818063, 0.22121161803738532, 0.24402909168198839, 0.19386426414955382, 0.17126559436017885, 0.18966614382683222, 0.17832181577329542, 0.17761511429783572, 0.1761647958313024, 0.1804961951728039, 0.17507194421585626, 0.1855370949515005, 0.20647360636131584, 0.1929690796676542, 0.1963572353383375, 0.18290214948486694, 0.2968620612692763, 0.190826813914026, 0.18406915673932678, 0.2032503528397368, 0.18153264941296576, 0.16741108344558087, 0.15194075215164304, 0.14760541137144667, 0.6703493790975841, 0.17828135301017978, 0.6409598761026181, 0.5620101297165006, 0.1881546038775569, 0.6103682156446708, 0.6355814337263379, 0.1922199000532524, 0.19684446723893312, 0.19800234487072998, 0.19664736657906945, 0.14061739890603808, 0.19663407492787632, 0.14491560887658506, 0.7113679380097124, 0.17579046500555073, 0.18668645980717746, 0.2119972637159504, 0.18647304254346686, 0.19771281414339992, 0.17590921611462274, 0.17380396869980907, 0.18821134992415922, 0.1891721152584489, 0.07407728173300199, 0.07463472369498636, 0.06275628744523942, 0.07270653740407618, 0.07143714111371591, 0.07111460708433748, 0.07910858605456073, 0.06765136674848071, 0.06853520596942364]}, "mutation_prompt": null}
{"id": "43f09aa9-6c59-4411-aec0-059891b17ad0", "solution": "import numpy as np\n\nclass RefinedCoEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 25:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.8)\n                    self.CR = np.clip(self.CR, 0.3, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.85 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.03 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "RefinedCoEvoStrategy", "description": "A refined Co-Evolutionary Strategy with stochastic prioritization and adaptive parameters for enhanced exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.27608659156693266, "feedback": "The algorithm RefinedCoEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "e53bab68-a5c3-4a36-a1f3-e2b88a9b7d61", "metadata": {"aucs": [0.6212730144222223, 0.5822803759825839, 0.6484738024847313, 0.6462474054231456, 0.6199306929498443, 0.6311105237302486, 0.6403644839680303, 0.6414608575605945, 0.6093203810111976, 0.2879775480152652, 0.306568127324351, 0.38424132818125056, 0.34418804651905344, 0.3581643776999416, 0.3635708904916376, 0.3644498844288845, 0.2984234221439225, 0.3435660231694606, 0.12975045279374886, 0.11021187319210735, 0.1067913511158799, 0.10847725995434898, 0.11648351075339491, 0.10746454239007741, 0.10627671136797123, 0.09607567140575357, 0.08949023664911604, 0.09285295050589015, 0.09095920635101107, 0.09305833092999294, 0.08813554701875492, 0.10074290186123414, 0.09178145566525842, 0.10070185353157135, 0.12101794980243574, 0.0771369648329, 0.9465913700349144, 0.9506048564924587, 0.9395785003260498, 0.953752093854986, 0.9503897973679744, 0.9482142210800395, 0.940607635129823, 0.9683524640771615, 0.9443931012666298, 0.2548853822370677, 0.24309142998384048, 0.2640986466969395, 0.2550764832787973, 0.2442443805156428, 0.27193364449719115, 0.279612900881695, 0.2770946564187744, 0.25979100892599183, 0.5586626829113956, 0.5026773127505443, 0.57481029293122, 0.6354151246281377, 0.6106846300638828, 0.656715167252417, 0.5651024453964892, 0.5805979804047492, 0.6344649794895563, 0.11436997630276435, 0.2493480416343008, 0.18593565274807478, 0.3142761778577804, 0.11376609072353672, 0.23814594716172532, 0.24017196448503098, 0.34020568389820705, 0.24130114752830578, 0.05067704796997008, 0.2895811709104925, 0.22832679577655024, 0.23765918713156686, 0.24645306895487296, 0.20452241548439765, 0.1103503486707128, 0.21370441656554262, 0.1846630549145749, 0.13345462711348322, 0.15003386229623905, 0.17860184854402883, 0.06793368708741854, 0.014332576615357362, 0.17505723028107856, 0.15701192492909233, 0.10247537267164242, 0.1699061843895201, 0.27235047144430313, 0.23145750192429926, 0.2586992103689315, 0.27483160324797706, 0.21933350800436346, 0.23023072783189713, 0.3435970548511236, 0.30908215505652403, 0.31163825247264854, 0.04592969537365732, 0.05226101402601202, 0.06659467726485058, 0.09200414933681, 0.06712564772088903, 0.05776334494718072, 0.05446756822964394, 0.07907116478220122, 0.07392988190054928, 0.14522243743935215, 0.17032585465867145, 0.15754744494624917, 0.1720102685288486, 0.18061078144301135, 0.1974435825891776, 0.14019311462193196, 0.17411664574513674, 0.1857476385845529, 0.5554680930932958, 0.5024507115739085, 0.5001901518542595, 0.524144238086214, 0.47682072481385407, 0.46341708460791653, 0.4821461660651637, 0.48917074597385035, 0.5506010819167293, 0.11076272250748775, 0.08892926855239913, 0.07749468724894304, 0.0861357056338029, 0.09251394806978697, 0.08650886540378866, 0.07130842269553939, 0.0799179315343006, 0.09881067252423859, 0.1345271996371935, 0.15552137095852558, 0.17356986412198128, 0.18776876785859453, 0.2589144892332256, 0.14128494159505967, 0.17102380184459143, 0.12230124553474109, 0.18505293340650142, 0.3221911956941126, 0.28163799787213206, 0.3109583844522158, 0.2828666219034768, 0.2955336706850936, 0.2713081255185904, 0.30632705276212924, 0.3335445080942899, 0.32435388546193633, 0.24847616145586093, 0.26443067675810716, 0.23514279502102542, 0.228363154878505, 0.21979199848967124, 0.17340474809422668, 0.23712637306818063, 0.22121161803738532, 0.24402909168198839, 0.19386426414955382, 0.17126559436017885, 0.18966614382683222, 0.17832181577329542, 0.17761511429783572, 0.1761647958313024, 0.1804961951728039, 0.17507194421585626, 0.1855370949515005, 0.20647360636131584, 0.1929690796676542, 0.1963572353383375, 0.18290214948486694, 0.2968620612692763, 0.190826813914026, 0.18406915673932678, 0.2032503528397368, 0.18153264941296576, 0.16741108344558087, 0.15194075215164304, 0.14760541137144667, 0.6703493790975841, 0.17828135301017978, 0.6409598761026181, 0.5620101297165006, 0.1881546038775569, 0.6103682156446708, 0.6355814337263379, 0.1922199000532524, 0.19684446723893312, 0.19800234487072998, 0.19664736657906945, 0.14061739890603808, 0.19663407492787632, 0.14491560887658506, 0.7113679380097124, 0.17579046500555073, 0.18668645980717746, 0.2119972637159504, 0.18647304254346686, 0.19771281414339992, 0.17590921611462274, 0.17380396869980907, 0.18821134992415922, 0.1891721152584489, 0.07407728173300199, 0.07463472369498636, 0.06275628744523942, 0.07270653740407618, 0.07143714111371591, 0.07111460708433748, 0.07910858605456073, 0.06765136674848071, 0.06853520596942364]}, "mutation_prompt": null}
{"id": "d2e8b41c-ff06-4894-b585-f6d562115e86", "solution": "import numpy as np\n\nclass HybridAdaptiveStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 15 * dim  # Increased population size for better diversity\n        self.F = 0.75  # Adjusted differential weight for better exploration\n        self.CR = 0.9  # Higher crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # Slightly higher adaptive factor\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            d = indices[3]  # Added a fourth vector for mutation\n            return self.population[a] + self.F * (self.population[b] - self.population[c]) + self.F * (self.population[c] - self.population[d])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 25:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)  # Adjusted bounds for F\n                    self.CR = np.clip(self.CR, 0.4, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.85 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.03 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveStrategy", "description": "A hybrid strategy combining Differential Evolution and a self-adaptive mutation mechanism for robust exploration and exploitation.", "configspace": "", "generation": 10, "fitness": 0.23784115361578426, "feedback": "The algorithm HybridAdaptiveStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "e53bab68-a5c3-4a36-a1f3-e2b88a9b7d61", "metadata": {"aucs": [0.4788168666838174, 0.4306586150017754, 0.5018673386444779, 0.5107536710422896, 0.4568624973672605, 0.5230372149743344, 0.49277013208219955, 0.49511545906032106, 0.5048546190739795, 0.225403200556481, 0.23981805416429702, 0.19393500826269727, 0.21384807005915163, 0.20401169948625897, 0.22957515137510587, 0.18463739692840375, 0.208422310046939, 0.19977381911676795, 0.0794627020003481, 0.09953950558965119, 0.09953965088994898, 0.08386776126025142, 0.08492811798700417, 0.09930162071914161, 0.10298229322508601, 0.08502839143091445, 0.09928522160435915, 0.06836938078382304, 0.08515393271975535, 0.06803766121364863, 0.08548746976137789, 0.07644525693236559, 0.08915511534085196, 0.08038689088500628, 0.08058656032777889, 0.06965405489545717, 0.8900739299321078, 0.9430158849606569, 0.9588300085155289, 0.9341171183812961, 0.9499437750029582, 0.964190570951741, 0.9443755190091695, 0.9403845741765371, 0.960081135440328, 0.19104620073983247, 0.1913647739097385, 0.20191530572995386, 0.21674549503936014, 0.19218662860669633, 0.2210636602704169, 0.20354820968372933, 0.22864109226775842, 0.21622282126244274, 0.4492992502378391, 0.2722445318051818, 0.38227211179093223, 0.5740314373479534, 0.5678325728618406, 0.5116430010441344, 0.544685298011182, 0.5263914227427327, 0.3826491760961023, 0.17808137231276666, 0.166566025912819, 0.2190068575332591, 0.10672429653674931, 0.14897735437513615, 0.15102336500441527, 0.17020910951346846, 0.20690613843175765, 0.19359141493552, 0.04788793852985107, 0.02095113791079839, 0.1516410801092214, 0.1358166598147198, 0.09940840129378559, 0.1892963305247629, 0.175315184651207, 0.1745404225181013, 0.21549429134242304, 0.09845757188106186, 0.11759070473190236, 0.09514686410382878, 0.1048318279885081, 0.05066394683949005, 0.10269216321035113, 0.1006838536309822, 0.07373813800586271, 0.10370029342658904, 0.2140906028817684, 0.18467708178753284, 0.28121000800024, 0.2489730394364006, 0.22893212034457378, 0.21193185028611994, 0.2013883193889643, 0.22201109525555085, 0.20943146109645283, 0.04251437927616897, 0.02006535900821238, 0.031087945848511267, 0.01705686557230801, 0.05214753325734511, 0.031817483524231416, 0.025771893079071795, 0.02920102750973852, 0.041881576528499664, 0.10757605149336247, 0.1314147303835853, 0.11200595382325196, 0.13197690225827352, 0.13496784550062402, 0.12445196549981741, 0.12635782656314676, 0.1190559034261992, 0.10683926604697258, 0.4333529295531552, 0.4251391267102319, 0.43141532539394334, 0.4168803243497201, 0.4266038293489528, 0.4294190617667092, 0.43929729990292377, 0.3864877257061081, 0.39314891563074106, 0.08948686392404581, 0.07354619738034562, 0.08742623775063385, 0.08239652547844778, 0.0684989991398004, 0.0929514146657493, 0.06348457128940532, 0.076481609477004, 0.08040807994815513, 0.15084611522822866, 0.22900486626832395, 0.11938705905477254, 0.13751349059677687, 0.13754697355637802, 0.15566934565560586, 0.14735355813567497, 0.22521407975266083, 0.18736741314448313, 0.26829757275444177, 0.26672273737655994, 0.24559873424205803, 0.2835338820650486, 0.2962623703961196, 0.2505373070659508, 0.24206164367460392, 0.23460822385242974, 0.2646728535866122, 0.20324316178780188, 0.18817784123629366, 0.17814497679385655, 0.1877200087436538, 0.18801836494182678, 0.20685661137595412, 0.23160945749512163, 0.19957250964581374, 0.20575741296496708, 0.18035537867533802, 0.19836656108741035, 0.1642190595931866, 0.16277789562622025, 0.16367514862137234, 0.1836610745965469, 0.1983084300379262, 0.17084049059201956, 0.1885587349469432, 0.20643019505739335, 0.1903527912411903, 0.18094967803865825, 0.1850554283369471, 0.18861817633207634, 0.16748919574068155, 0.1584799776255208, 0.16768615108214147, 0.17007148376179992, 0.6107194374857168, 0.14882664626070896, 0.5702804864121002, 0.5815895259404269, 0.1599038797943153, 0.5053433270495487, 0.2793136531776177, 0.4517874542603122, 0.1403693554475618, 0.4886502152348047, 0.19069728653994356, 0.19505659507457274, 0.5520817662674017, 0.19324708740839402, 0.40343397514463397, 0.1452551279977815, 0.6169186111979814, 0.1992584642648204, 0.1784466878342852, 0.1894760412343104, 0.17106676168773338, 0.1815568069085023, 0.16869830584967693, 0.17596101836503153, 0.17439036608549974, 0.17550624436836004, 0.19366701034569678, 0.06243229972151643, 0.06595118331396932, 0.06851302369014323, 0.06547171127315721, 0.05821050447826803, 0.06938817307825973, 0.0685053201289586, 0.07643590981523118, 0.06571240861294447]}, "mutation_prompt": null}
{"id": "1eb27825-1671-4b59-9b13-485fc5a6d9bc", "solution": "import numpy as np\n\nclass HybridDEAdaptiveWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim\n        self.F = 0.7  # Differential weight\n        self.CR = 0.85  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Adaptive factor for dynamic adjustments\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = np.delete(np.arange(self.population_size), idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 25:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.8)\n                    self.CR = np.clip(self.CR, 0.3, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.85 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.03 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridDEAdaptiveWalk", "description": "A hybrid Differential Evolution and Adaptive Random Walk strategy using dynamic mutation strategies for enhanced exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.27608659156693266, "feedback": "The algorithm HybridDEAdaptiveWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "e53bab68-a5c3-4a36-a1f3-e2b88a9b7d61", "metadata": {"aucs": [0.6212730144222223, 0.5822803759825839, 0.6484738024847313, 0.6462474054231456, 0.6199306929498443, 0.6311105237302486, 0.6403644839680303, 0.6414608575605945, 0.6093203810111976, 0.2879775480152652, 0.306568127324351, 0.38424132818125056, 0.34418804651905344, 0.3581643776999416, 0.3635708904916376, 0.3644498844288845, 0.2984234221439225, 0.3435660231694606, 0.12975045279374886, 0.11021187319210735, 0.1067913511158799, 0.10847725995434898, 0.11648351075339491, 0.10746454239007741, 0.10627671136797123, 0.09607567140575357, 0.08949023664911604, 0.09285295050589015, 0.09095920635101107, 0.09305833092999294, 0.08813554701875492, 0.10074290186123414, 0.09178145566525842, 0.10070185353157135, 0.12101794980243574, 0.0771369648329, 0.9465913700349144, 0.9506048564924587, 0.9395785003260498, 0.953752093854986, 0.9503897973679744, 0.9482142210800395, 0.940607635129823, 0.9683524640771615, 0.9443931012666298, 0.2548853822370677, 0.24309142998384048, 0.2640986466969395, 0.2550764832787973, 0.2442443805156428, 0.27193364449719115, 0.279612900881695, 0.2770946564187744, 0.25979100892599183, 0.5586626829113956, 0.5026773127505443, 0.57481029293122, 0.6354151246281377, 0.6106846300638828, 0.656715167252417, 0.5651024453964892, 0.5805979804047492, 0.6344649794895563, 0.11436997630276435, 0.2493480416343008, 0.18593565274807478, 0.3142761778577804, 0.11376609072353672, 0.23814594716172532, 0.24017196448503098, 0.34020568389820705, 0.24130114752830578, 0.05067704796997008, 0.2895811709104925, 0.22832679577655024, 0.23765918713156686, 0.24645306895487296, 0.20452241548439765, 0.1103503486707128, 0.21370441656554262, 0.1846630549145749, 0.13345462711348322, 0.15003386229623905, 0.17860184854402883, 0.06793368708741854, 0.014332576615357362, 0.17505723028107856, 0.15701192492909233, 0.10247537267164242, 0.1699061843895201, 0.27235047144430313, 0.23145750192429926, 0.2586992103689315, 0.27483160324797706, 0.21933350800436346, 0.23023072783189713, 0.3435970548511236, 0.30908215505652403, 0.31163825247264854, 0.04592969537365732, 0.05226101402601202, 0.06659467726485058, 0.09200414933681, 0.06712564772088903, 0.05776334494718072, 0.05446756822964394, 0.07907116478220122, 0.07392988190054928, 0.14522243743935215, 0.17032585465867145, 0.15754744494624917, 0.1720102685288486, 0.18061078144301135, 0.1974435825891776, 0.14019311462193196, 0.17411664574513674, 0.1857476385845529, 0.5554680930932958, 0.5024507115739085, 0.5001901518542595, 0.524144238086214, 0.47682072481385407, 0.46341708460791653, 0.4821461660651637, 0.48917074597385035, 0.5506010819167293, 0.11076272250748775, 0.08892926855239913, 0.07749468724894304, 0.0861357056338029, 0.09251394806978697, 0.08650886540378866, 0.07130842269553939, 0.0799179315343006, 0.09881067252423859, 0.1345271996371935, 0.15552137095852558, 0.17356986412198128, 0.18776876785859453, 0.2589144892332256, 0.14128494159505967, 0.17102380184459143, 0.12230124553474109, 0.18505293340650142, 0.3221911956941126, 0.28163799787213206, 0.3109583844522158, 0.2828666219034768, 0.2955336706850936, 0.2713081255185904, 0.30632705276212924, 0.3335445080942899, 0.32435388546193633, 0.24847616145586093, 0.26443067675810716, 0.23514279502102542, 0.228363154878505, 0.21979199848967124, 0.17340474809422668, 0.23712637306818063, 0.22121161803738532, 0.24402909168198839, 0.19386426414955382, 0.17126559436017885, 0.18966614382683222, 0.17832181577329542, 0.17761511429783572, 0.1761647958313024, 0.1804961951728039, 0.17507194421585626, 0.1855370949515005, 0.20647360636131584, 0.1929690796676542, 0.1963572353383375, 0.18290214948486694, 0.2968620612692763, 0.190826813914026, 0.18406915673932678, 0.2032503528397368, 0.18153264941296576, 0.16741108344558087, 0.15194075215164304, 0.14760541137144667, 0.6703493790975841, 0.17828135301017978, 0.6409598761026181, 0.5620101297165006, 0.1881546038775569, 0.6103682156446708, 0.6355814337263379, 0.1922199000532524, 0.19684446723893312, 0.19800234487072998, 0.19664736657906945, 0.14061739890603808, 0.19663407492787632, 0.14491560887658506, 0.7113679380097124, 0.17579046500555073, 0.18668645980717746, 0.2119972637159504, 0.18647304254346686, 0.19771281414339992, 0.17590921611462274, 0.17380396869980907, 0.18821134992415922, 0.1891721152584489, 0.07407728173300199, 0.07463472369498636, 0.06275628744523942, 0.07270653740407618, 0.07143714111371591, 0.07111460708433748, 0.07910858605456073, 0.06765136674848071, 0.06853520596942364]}, "mutation_prompt": null}
{"id": "0dec2da5-9eee-4206-a962-e70cc27821f4", "solution": "import numpy as np\n\nclass RefinedEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 14 * dim\n        self.F = 0.6  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            # Record fitness for adaptive strategy\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  # Adjusted threshold for improvement\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.1, 0.9)\n                    self.CR = np.clip(self.CR, 0.4, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "RefinedEvoStrategy", "description": "A refined evolutionary strategy with adaptive mutation, crossover, and strategic perturbation for enhanced optimization.", "configspace": "", "generation": 12, "fitness": 0.32301098886131274, "feedback": "The algorithm RefinedEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "e53bab68-a5c3-4a36-a1f3-e2b88a9b7d61", "metadata": {"aucs": [0.6752299239159154, 0.6848610325025156, 0.6904662254095685, 0.6892534869139618, 0.6889089362446015, 0.7022481975629048, 0.6506526978529357, 0.6800624209489077, 0.7155337921424714, 0.4452919882443537, 0.4001498195904485, 0.3895423631049506, 0.3229801173873096, 0.4514669011970913, 0.44185373605386014, 0.39812601471680475, 0.4422477350390873, 0.4056622802359662, 0.09458841398766982, 0.10696016759071847, 0.1159325781599253, 0.10845132013336245, 0.10601774074308745, 0.1091970846060829, 0.11460592484416521, 0.1220265103432221, 0.11814778663640768, 0.09833543509557185, 0.12762251403889935, 0.08279677427371257, 0.10960420126000847, 0.11966325190949334, 0.092598287929891, 0.09704424885873963, 0.1083194371401538, 0.08163383286789228, 0.9532640469016798, 0.9562520201456459, 0.9251923513146536, 0.908928964121466, 0.9158710377353724, 0.883930362244618, 0.9088207565830821, 0.9394459186691637, 0.9349195371941738, 0.3151444633647128, 0.2967528102243916, 0.28501754557784886, 0.3370774256636395, 0.30717450785489453, 0.30860755784525895, 0.3114491273261434, 0.3115441372892719, 0.2873838600200863, 0.7547161830453142, 0.6188842747506134, 0.19833894233921423, 0.7191013246422003, 0.6828273738488129, 0.6917710704317821, 0.6451124410025204, 0.6904814207562314, 0.6139759399071599, 0.23944660147594732, 0.2672355150223893, 0.3511078757188407, 0.12054004461740275, 0.3292292305547867, 0.26404172891549527, 0.2370207450306947, 0.32178162519734055, 0.3146289562145035, 0.10978400979550185, 0.0512591480362542, 0.11726673660279252, 0.21339036368247644, 0.25659656993485414, 0.379351618808473, 0.3206455951272835, 0.24042127955769876, 0.35093600372631273, 0.3174715468460235, 0.2728237916201378, 0.20952203149979243, 0.22669320511162383, 0.16217550835382355, 0.2529899597838272, 0.3319375193043286, 0.2876630210255984, 0.2261710505438781, 0.4841936745077089, 0.41841490167940043, 0.31658347008360355, 0.3949547560730228, 0.4432577197251343, 0.37844278528502484, 0.46313320246615, 0.45585022004824827, 0.4300578920467697, 0.1107909455761179, 0.09450081068987615, 0.06667876814150608, 0.1569927465374441, 0.13380875865449438, 0.12247160385899447, 0.06277783952896221, 0.06861922311303137, 0.2229289463512556, 0.21346469695771741, 0.26295160710571985, 0.1985831213293191, 0.22981059546477267, 0.24612387666564728, 0.2453787672312241, 0.23881040639653606, 0.2381138486978961, 0.21638207637259865, 0.5632828435739883, 0.5472617616713586, 0.6067045336673544, 0.5355074395430107, 0.5302929620192547, 0.5800823372265739, 0.6134800833033816, 0.6293354943351134, 0.6132274491289401, 0.09032849607682825, 0.10759120454448023, 0.0816272978478868, 0.12558796174047415, 0.10317518899863132, 0.10832555501833396, 0.07550634327730454, 0.10347116645183674, 0.08716614259513389, 0.12755139226827983, 0.2076936842722964, 0.3271886953462876, 0.16236115606866153, 0.18785837499543, 0.14178572965441194, 0.19533018127084034, 0.1990619936560737, 0.14343625701584917, 0.3252992770051222, 0.317528322958909, 0.34675279415887394, 0.380523932236449, 0.3847314059404696, 0.3393673949295052, 0.34707156385354243, 0.3906424605998128, 0.39783956254156105, 0.31213664036333444, 0.29792244396540646, 0.2803912197443724, 0.28359141217814243, 0.267516401896578, 0.26533981885941116, 0.3099058288427077, 0.3179370816895002, 0.2596087398850786, 0.21942039780014133, 0.19534321291929102, 0.1769346561604005, 0.18952714344537935, 0.23412120870692754, 0.20997269598937496, 0.18988605179675389, 0.19687668175334216, 0.21667144386321135, 0.21914681001686032, 0.19077830085021685, 0.18217589891729824, 0.21589074826943644, 0.4738278402932804, 0.18971918981261227, 0.20161338628277525, 0.34471845069880735, 0.2202984378427424, 0.1529538262258826, 0.16697729018824214, 0.20677000248822575, 0.7598985037950108, 0.7609486675182362, 0.7368190243990363, 0.19272126086887453, 0.6422367525858615, 0.6883655879028006, 0.746459274386136, 0.6726956198694112, 0.716575666049514, 0.18470558393603065, 0.2043625068491619, 0.19787419765794134, 0.20772679307950226, 0.127172679616256, 0.2038016296616577, 0.181545515570401, 0.18323350727193466, 0.18183301139484465, 0.17825223183838712, 0.1993893920898694, 0.18271426714917982, 0.1767770849276743, 0.17963878752932305, 0.19527446615416733, 0.0854647501227277, 0.08549302189219521, 0.06974381262542306, 0.07129232697455279, 0.07515427220870274, 0.07340533553383888, 0.07748411671664435, 0.07851181261470175, 0.06457330873669775]}, "mutation_prompt": null}
{"id": "937f15cd-b774-4643-a551-ffec2cc5a237", "solution": "import numpy as np\n\nclass EnhancedEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 14 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.85  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.1, 0.9)\n                    self.CR = np.clip(self.CR, 0.3, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.07 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedEvoStrategy", "description": "An enhanced evolutionary strategy using adaptive parameters and local search to improve convergence on diverse optimization tasks.", "configspace": "", "generation": 13, "fitness": 0.34822864656560604, "feedback": "The algorithm EnhancedEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "0dec2da5-9eee-4206-a962-e70cc27821f4", "metadata": {"aucs": [0.7784703718905492, 0.7523529905685491, 0.7153117344590749, 0.7535762599982984, 0.6894330335029124, 0.7467161353794496, 0.7772559518757015, 0.7392205254226207, 0.7305547870588323, 0.5346418711342418, 0.5455258585813226, 0.5402920826659453, 0.5655969099559037, 0.5267982394009563, 0.5559727379744963, 0.4826345601728058, 0.47068884614997486, 0.4563127692752793, 0.12392096059634805, 0.16273466957933236, 0.13079986042276648, 0.10613438179786339, 0.1345533370368157, 0.12188091935537193, 0.12897572620731823, 0.14171096777124093, 0.10777783819899867, 0.10620586237141105, 0.10792206934122661, 0.1205670074566233, 0.13518119696111697, 0.06512649864812592, 0.10909484043892193, 0.1450716907275288, 0.13215170222345973, 0.08401038759119017, 0.9446533720121305, 0.8801237448870399, 0.926839677979272, 0.9682285754640012, 0.9575415585078886, 0.935507723003737, 0.9646588334439611, 0.9397567613055532, 0.9505820587663353, 0.3994134514986808, 0.34384075451887497, 0.4006384588678651, 0.39035374537926726, 0.35578157707855484, 0.42112447127763897, 0.37885246009118945, 0.3518058581503377, 0.35116464489895516, 0.3660931983935358, 0.7545046798248991, 0.7335030220976713, 0.690743346925887, 0.7091692752194376, 0.7047149236339861, 0.738723298339779, 0.7606217450323988, 0.755004099396446, 0.26511755041297336, 0.5346078401309391, 0.12497714253839365, 0.35565868449793125, 0.3267202359569471, 0.295256100618735, 0.3504551512295867, 0.40001018736407046, 0.3255558790355977, 0.2829711709568704, 0.36348039025507417, 0.3769167101212222, 0.23118144989109424, 0.28362553675993474, 0.17033550789337437, 0.173948811454393, 0.4221108875119951, 0.11842465296264726, 0.23607842072101126, 0.2009925893060276, 0.28284188412773825, 0.11114281478768917, 0.2615127318650998, 0.3020199713792344, 0.32994006725432645, 0.39437432268610284, 0.2729319695084229, 0.49767351645467384, 0.4734328539328593, 0.3961249030677907, 0.4365936397205653, 0.4425979377153074, 0.41246208149271346, 0.4856290423831887, 0.5278676822383617, 0.4732339937348511, 0.1557482934253107, 0.18247315301881084, 0.21000642128115132, 0.188451571488506, 0.2198849103789018, 0.11755869540120167, 0.16076358417643255, 0.1930551455961731, 0.10782026407808021, 0.2560104398162494, 0.30631128047921463, 0.2450802455818175, 0.3049695422197928, 0.27385864951411265, 0.3229677970974705, 0.2564708671908472, 0.22576618094559342, 0.24865560582422308, 0.6702826328300243, 0.6767858404600062, 0.6359136625226074, 0.5984267426452872, 0.6631417284433693, 0.6343546848670989, 0.6598682364520333, 0.599800690835632, 0.6369373557444581, 0.08784104184948904, 0.11541565561345812, 0.09410706150454629, 0.09856530934731178, 0.11889886744674782, 0.11569642398718005, 0.1158642543288173, 0.1373978915392865, 0.11723904419807119, 0.33020023875476145, 0.14903582320275177, 0.16935755196642277, 0.1866490518373901, 0.29495022850040464, 0.2144651718020043, 0.231724889536295, 0.2673969535576485, 0.26343598899630893, 0.28334828470002127, 0.3609339581137413, 0.3895029534406822, 0.3713543883634892, 0.43103799025875955, 0.41835113408779334, 0.383771631657283, 0.42327394506535054, 0.4055980250505302, 0.3252967851214926, 0.23416382143274506, 0.291841859716485, 0.20284336856651197, 0.3206699664040288, 0.21694379259659413, 0.28629982518965147, 0.2575749761408218, 0.272919835107041, 0.2091110484228702, 0.19869383919893868, 0.1847287183099976, 0.21069025374297634, 0.21060479649334352, 0.1727044673407876, 0.18523422023449332, 0.2074129180497104, 0.22897669790281217, 0.16650554522262395, 0.20741086922236196, 0.183401460971655, 0.200594007609754, 0.19018464264325619, 0.19741932098781667, 0.2067479150405246, 0.1930452709194348, 0.2244787680833542, 0.8121016390612618, 0.2003936331393017, 0.20846736818039302, 0.17139298467991482, 0.19252254505867117, 0.7206397874939798, 0.13811731189874932, 0.17401243927214727, 0.1679490340464168, 0.7218741371951071, 0.1658985224034688, 0.7600044257715, 0.6911095891865313, 0.15230712242853583, 0.12267087896736262, 0.6575889085908557, 0.73930437299855, 0.20837228749391212, 0.18870796698893288, 0.18397179510448036, 0.18190299083728467, 0.18321585458445733, 0.1821901518203436, 0.17237673610670368, 0.18374218571379142, 0.20041016222276664, 0.1868775686359344, 0.07395592085866975, 0.07875336328400484, 0.07292891786623246, 0.07191431418643568, 0.07751986916772435, 0.07880515468758786, 0.08674246851273293, 0.08274314128212046, 0.07469992659535185]}, "mutation_prompt": null}
{"id": "b15b6f14-f3f1-498a-9ff1-27c85404d224", "solution": "import numpy as np\n\nclass EnhancedEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 14 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.85  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.1, 0.9)\n                    self.CR = np.clip(self.CR, 0.3, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.07 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedEvoStrategy", "description": "An enhanced evolutionary strategy using adaptive parameters and local search to improve convergence on diverse optimization tasks.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "937f15cd-b774-4643-a551-ffec2cc5a237", "metadata": {"aucs": [0.7784703718905492, 0.7523529905685491, 0.7153117344590749, 0.7535762599982984, 0.6894330335029124, 0.7467161353794496, 0.7772559518757015, 0.7392205254226207, 0.7305547870588323, 0.5346418711342418, 0.5455258585813226, 0.5402920826659453, 0.5655969099559037, 0.5267982394009563, 0.5559727379744963, 0.4826345601728058, 0.47068884614997486, 0.4563127692752793, 0.12392096059634805, 0.16273466957933236, 0.13079986042276648, 0.10613438179786339, 0.1345533370368157, 0.12188091935537193, 0.12897572620731823, 0.14171096777124093, 0.10777783819899867, 0.10620586237141105, 0.10792206934122661, 0.1205670074566233, 0.13518119696111697, 0.06512649864812592, 0.10909484043892193, 0.1450716907275288, 0.13215170222345973, 0.08401038759119017, 0.9446533720121305, 0.8801237448870399, 0.926839677979272, 0.9682285754640012, 0.9575415585078886, 0.935507723003737, 0.9646588334439611, 0.9397567613055532, 0.9505820587663353, 0.3994134514986808, 0.34384075451887497, 0.4006384588678651, 0.39035374537926726, 0.35578157707855484, 0.42112447127763897, 0.37885246009118945, 0.3518058581503377, 0.35116464489895516, 0.3660931983935358, 0.7545046798248991, 0.7335030220976713, 0.690743346925887, 0.7091692752194376, 0.7047149236339861, 0.738723298339779, 0.7606217450323988, 0.755004099396446, 0.26511755041297336, 0.5346078401309391, 0.12497714253839365, 0.35565868449793125, 0.3267202359569471, 0.295256100618735, 0.3504551512295867, 0.40001018736407046, 0.3255558790355977, 0.2829711709568704, 0.36348039025507417, 0.3769167101212222, 0.23118144989109424, 0.28362553675993474, 0.17033550789337437, 0.173948811454393, 0.4221108875119951, 0.11842465296264726, 0.23607842072101126, 0.2009925893060276, 0.28284188412773825, 0.11114281478768917, 0.2615127318650998, 0.3020199713792344, 0.32994006725432645, 0.39437432268610284, 0.2729319695084229, 0.49767351645467384, 0.4734328539328593, 0.3961249030677907, 0.4365936397205653, 0.4425979377153074, 0.41246208149271346, 0.4856290423831887, 0.5278676822383617, 0.4732339937348511, 0.1557482934253107, 0.18247315301881084, 0.21000642128115132, 0.188451571488506, 0.2198849103789018, 0.11755869540120167, 0.16076358417643255, 0.1930551455961731, 0.10782026407808021, 0.2560104398162494, 0.30631128047921463, 0.2450802455818175, 0.3049695422197928, 0.27385864951411265, 0.3229677970974705, 0.2564708671908472, 0.22576618094559342, 0.24865560582422308, 0.6702826328300243, 0.6767858404600062, 0.6359136625226074, 0.5984267426452872, 0.6631417284433693, 0.6343546848670989, 0.6598682364520333, 0.599800690835632, 0.6369373557444581, 0.08784104184948904, 0.11541565561345812, 0.09410706150454629, 0.09856530934731178, 0.11889886744674782, 0.11569642398718005, 0.1158642543288173, 0.1373978915392865, 0.11723904419807119, 0.33020023875476145, 0.14903582320275177, 0.16935755196642277, 0.1866490518373901, 0.29495022850040464, 0.2144651718020043, 0.231724889536295, 0.2673969535576485, 0.26343598899630893, 0.28334828470002127, 0.3609339581137413, 0.3895029534406822, 0.3713543883634892, 0.43103799025875955, 0.41835113408779334, 0.383771631657283, 0.42327394506535054, 0.4055980250505302, 0.3252967851214926, 0.23416382143274506, 0.291841859716485, 0.20284336856651197, 0.3206699664040288, 0.21694379259659413, 0.28629982518965147, 0.2575749761408218, 0.272919835107041, 0.2091110484228702, 0.19869383919893868, 0.1847287183099976, 0.21069025374297634, 0.21060479649334352, 0.1727044673407876, 0.18523422023449332, 0.2074129180497104, 0.22897669790281217, 0.16650554522262395, 0.20741086922236196, 0.183401460971655, 0.200594007609754, 0.19018464264325619, 0.19741932098781667, 0.2067479150405246, 0.1930452709194348, 0.2244787680833542, 0.8121016390612618, 0.2003936331393017, 0.20846736818039302, 0.17139298467991482, 0.19252254505867117, 0.7206397874939798, 0.13811731189874932, 0.17401243927214727, 0.1679490340464168, 0.7218741371951071, 0.1658985224034688, 0.7600044257715, 0.6911095891865313, 0.15230712242853583, 0.12267087896736262, 0.6575889085908557, 0.73930437299855, 0.20837228749391212, 0.18870796698893288, 0.18397179510448036, 0.18190299083728467, 0.18321585458445733, 0.1821901518203436, 0.17237673610670368, 0.18374218571379142, 0.20041016222276664, 0.1868775686359344, 0.07395592085866975, 0.07875336328400484, 0.07292891786623246, 0.07191431418643568, 0.07751986916772435, 0.07880515468758786, 0.08674246851273293, 0.08274314128212046, 0.07469992659535185]}, "mutation_prompt": null}
{"id": "13ba038b-a955-4ad9-8ff3-596a7279a4a8", "solution": "import numpy as np\n\nclass DynamicEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.F = 0.7  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.92  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 15:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.8)\n                    self.CR = np.clip(self.CR, 0.4, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "DynamicEvoStrategy", "description": "A dynamic differential evolution strategy with adaptive crossover and mutation parameters, integrating random walks to escape stagnation.", "configspace": "", "generation": 15, "fitness": 0.32821705143147273, "feedback": "The algorithm DynamicEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "937f15cd-b774-4643-a551-ffec2cc5a237", "metadata": {"aucs": [0.6692706052947232, 0.6889632484200199, 0.6843232339772185, 0.7307894456493189, 0.6873349470510179, 0.6965857091767338, 0.6844195052206254, 0.6739466279437687, 0.736695117295727, 0.43408055479326957, 0.48839959235019736, 0.3859962049783502, 0.454457799058687, 0.43938620591534006, 0.49345509969858825, 0.46694279563128827, 0.44444694911510496, 0.4954651264326544, 0.10915336564880984, 0.13877188975090993, 0.10442093437477085, 0.2716153044194113, 0.13582786879186948, 0.1439061968988723, 0.13357167106918477, 0.15918894659603133, 0.13720747723055116, 0.12029180667825434, 0.11315188093816919, 0.09434162566966697, 0.13161717866032963, 0.10826750406328789, 0.10053488834481994, 0.1350213891099309, 0.1254865378535842, 0.11506294360427549, 0.952105951760833, 0.9405909017616545, 0.9270977455292728, 0.9740072125284301, 0.9606742911246338, 0.9480093421661233, 0.9740636130679845, 0.9599120571552171, 0.9424870345389407, 0.3066370054916413, 0.3584065922473094, 0.32472768267350716, 0.34950232767070155, 0.33617614389304595, 0.30148302465732535, 0.3296543182568058, 0.3591397500233148, 0.2975158136031285, 0.732288031500063, 0.6618281111970464, 0.6020327305986464, 0.7158062609176077, 0.7188680230031836, 0.6714726545313792, 0.6728094918399244, 0.6922532236535885, 0.6096878760670618, 0.40965589719797335, 0.22734732796220847, 0.32880348411454574, 0.23258115332331564, 0.11483009895026353, 0.2528919149575656, 0.32067534231407413, 0.25477877390104875, 0.11932108849236212, 0.33965002439983427, 0.009765797496894102, 0.49170146601011333, 0.26563890380554445, 0.2858338461699165, 0.2788069869568056, 0.28175561533758375, 0.27236510729877283, 0.31971444312559805, 0.35431758030797944, 0.28212635554599064, 0.23935476580514792, 0.2726079923135776, 0.25391382534336193, 0.27707901627400267, 0.25785502864323495, 0.24187093472658794, 0.2528606715296756, 0.4957207194398978, 0.41987268234755803, 0.40458569377245046, 0.39768715838832536, 0.4240570175996845, 0.46569290455041223, 0.44995586952960953, 0.3675213063841808, 0.45860635110528924, 0.04575723855960201, 0.1688167283321783, 0.04238754183625715, 0.14372928993971112, 0.17717642773186548, 0.17780249670892045, 0.12663404388728627, 0.11478795712047718, 0.06340578647574546, 0.26191990251197916, 0.23087719707908827, 0.2495107374419887, 0.23714115004682512, 0.2257645447413663, 0.24104964673492213, 0.25803825466192265, 0.22732929455013462, 0.22063864183478188, 0.5634443157875765, 0.5774916107209473, 0.5679178301478183, 0.5995993973947549, 0.5666062491296493, 0.582724036974206, 0.5462759967709384, 0.5814404715120545, 0.5669738644591038, 0.08766741422774527, 0.10432395501587166, 0.10690217623388654, 0.09800141153396058, 0.07765030706581888, 0.090290828957723, 0.10156910553450638, 0.08518379751210647, 0.10909372482451396, 0.1564705517773255, 0.1491398349356985, 0.1587635841366437, 0.16376899710012405, 0.1501670639992786, 0.14479659559198643, 0.14184605191824862, 0.15848542035747926, 0.24007322239495665, 0.3284259187406602, 0.3262781088041813, 0.3569644836203575, 0.3599706818281968, 0.32901081468751037, 0.3216609565210641, 0.3141670297673005, 0.3531872863014097, 0.3323612022190636, 0.2739270720012632, 0.3020038406021266, 0.2518163885665071, 0.2864072380172681, 0.28649903766153917, 0.2499280783294724, 0.2850723292895938, 0.2711429774510906, 0.2901668879450484, 0.20004162004921733, 0.18710756150315921, 0.20634109862134964, 0.1823862204245239, 0.19234378718191325, 0.2332124170559069, 0.1676049732458137, 0.19263787585382375, 0.18948326381674263, 0.20552781338330828, 0.21963931828132977, 0.39262957727948555, 0.20635252658506587, 0.1978500290035874, 0.1734284512995824, 0.32418693540250865, 0.2031757288776942, 0.19687171967372918, 0.17784690575262885, 0.16180959847154386, 0.7687089921420138, 0.7401600574903018, 0.1651787528932307, 0.17043704155975936, 0.15871434218379654, 0.2015399665908233, 0.18912437928336012, 0.7604257789173838, 0.7176492888327061, 0.6896369251081652, 0.2041418667643211, 0.7250131108901635, 0.7250577180940609, 0.12758149581972522, 0.1526267399547302, 0.21015210940545748, 0.18139506548960127, 0.17318577915343025, 0.1686598367136064, 0.20372088340844563, 0.19924189518553925, 0.1737069346373461, 0.1849726295419346, 0.1686080277571126, 0.1751414839392592, 0.0594930794785834, 0.07137864099942726, 0.07373100696572021, 0.0805075668125308, 0.08089711055477333, 0.07341106414193199, 0.08401092516944464, 0.06919072513615943, 0.07514090327160483]}, "mutation_prompt": null}
{"id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 14 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.85  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.9)\n                    self.CR = np.clip(self.CR, 0.4, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "A hybrid adaptive evolutionary strategy incorporating differential evolution and local random walks with adaptive mutation and crossover probabilities for enhanced performance.", "configspace": "", "generation": 16, "fitness": 0.3482926472352699, "feedback": "The algorithm HybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "937f15cd-b774-4643-a551-ffec2cc5a237", "metadata": {"aucs": [0.7784703718905492, 0.7523529905685491, 0.7153117344590749, 0.7535762599982984, 0.6894330335029124, 0.7467161353794496, 0.7772559518757015, 0.7392205254226207, 0.7305547870588323, 0.5346418711342418, 0.5455258585813226, 0.5402920826659453, 0.5655969099559037, 0.5267982394009563, 0.5559727379744963, 0.4826345601728058, 0.47068884614997486, 0.4563127692752793, 0.12392096059634805, 0.16273466957933236, 0.13079986042276648, 0.10613438179786339, 0.1345533370368157, 0.12188091935537193, 0.12897572620731823, 0.14171096777124093, 0.10777783819899867, 0.10620586237141105, 0.10792206934122661, 0.1205670074566233, 0.13518119696111697, 0.06512649864812592, 0.10909484043892193, 0.1450716907275288, 0.13215170222345973, 0.08401038759119017, 0.9446533720121305, 0.8801237448870399, 0.926839677979272, 0.9682285754640012, 0.9575415585078886, 0.935507723003737, 0.9646588334439611, 0.9397567613055532, 0.9505820587663353, 0.3994134514986808, 0.34384075451887497, 0.4006384588678651, 0.39035374537926726, 0.35578157707855484, 0.42112447127763897, 0.37885246009118945, 0.3518058581503377, 0.35116464489895516, 0.3660931983935358, 0.7545046798248991, 0.7335030220976713, 0.690743346925887, 0.7091692752194376, 0.7047149236339861, 0.738723298339779, 0.7606217450323988, 0.755004099396446, 0.26511755041297336, 0.5346078401309391, 0.12497714253839365, 0.35565868449793125, 0.3267202359569471, 0.295256100618735, 0.3504551512295867, 0.40001018736407046, 0.3255558790355977, 0.2829711709568704, 0.36348039025507417, 0.3769167101212222, 0.23118144989109424, 0.28362553675993474, 0.17033550789337437, 0.173948811454393, 0.4221108875119951, 0.11842465296264726, 0.23607842072101126, 0.2009925893060276, 0.28284188412773825, 0.11114281478768917, 0.2615127318650998, 0.3020199713792344, 0.32994006725432645, 0.39437432268610284, 0.2729319695084229, 0.49767351645467384, 0.4734328539328593, 0.3961249030677907, 0.4365936397205653, 0.4425979377153074, 0.41246208149271346, 0.4856290423831887, 0.5278676822383617, 0.4732339937348511, 0.1557482934253107, 0.18247315301881084, 0.21000642128115132, 0.188451571488506, 0.2198849103789018, 0.11755869540120167, 0.16076358417643255, 0.1930551455961731, 0.10782026407808021, 0.2560104398162494, 0.30631128047921463, 0.2450802455818175, 0.3049695422197928, 0.27385864951411265, 0.3229677970974705, 0.2564708671908472, 0.22576618094559342, 0.24865560582422308, 0.6702826328300243, 0.6767858404600062, 0.6359136625226074, 0.5984267426452872, 0.6631417284433693, 0.6343546848670989, 0.6598682364520333, 0.599800690835632, 0.6369373557444581, 0.08784104184948904, 0.11541565561345812, 0.09410706150454629, 0.09856530934731178, 0.11889886744674782, 0.11569642398718005, 0.1158642543288173, 0.1373978915392865, 0.11723904419807119, 0.33020023875476145, 0.14903582320275177, 0.16935755196642277, 0.1866490518373901, 0.29495022850040464, 0.2144651718020043, 0.231724889536295, 0.2673969535576485, 0.26343598899630893, 0.28334828470002127, 0.3609339581137413, 0.3895029534406822, 0.3713543883634892, 0.43103799025875955, 0.41835113408779334, 0.383771631657283, 0.42327394506535054, 0.4055980250505302, 0.3252967851214926, 0.23416382143274506, 0.291841859716485, 0.20284336856651197, 0.3206699664040288, 0.21694379259659413, 0.28629982518965147, 0.2575749761408218, 0.272919835107041, 0.2091110484228702, 0.19869383919893868, 0.1847287183099976, 0.21069025374297634, 0.21060479649334352, 0.1727044673407876, 0.1922314690234317, 0.2074129180497104, 0.22897669790281217, 0.16650554522262395, 0.20741086922236196, 0.183401460971655, 0.200594007609754, 0.19018464264325619, 0.19741932098781667, 0.2067479150405246, 0.1930452709194348, 0.2244787680833542, 0.8121016390612618, 0.2003936331393017, 0.20846736818039302, 0.17139298467991482, 0.19252254505867117, 0.7206397874939798, 0.13811731189874932, 0.17401243927214727, 0.1679490340464168, 0.7218741371951071, 0.1658985224034688, 0.7600044257715, 0.6911095891865313, 0.15230712242853583, 0.12267087896736262, 0.6575889085908557, 0.73930437299855, 0.20837228749391212, 0.18870796698893288, 0.18397179510448036, 0.18193487794012686, 0.18321585458445733, 0.18570764830373754, 0.17565424837893984, 0.18374218571379142, 0.20041016222276664, 0.1868775686359344, 0.07395592085866975, 0.07875336328400484, 0.07292891786623246, 0.07191431418643568, 0.07751986916772435, 0.07880515468758786, 0.08674246851273293, 0.08274314128212046, 0.07469992659535185]}, "mutation_prompt": null}
{"id": "543d4a87-26db-41d6-bc26-12cb4bc73c4f", "solution": "import numpy as np\n\nclass RefinedHybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 14 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # Slightly increased adaptation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)  # Slightly altered clipping range\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.06 + 0.02 * (stagnation_counter / self.population_size), self.dim)  # Adjusted walk\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "RefinedHybridAdaptiveEvoStrategy", "description": "A refined hybrid adaptive evolutionary strategy with enhanced random walk and adaptive mutation for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.3479156573378329, "feedback": "The algorithm RefinedHybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {"aucs": [0.7784703718905492, 0.7523529905685491, 0.7153117344590749, 0.7535762599982984, 0.6894330335029124, 0.7467161353794496, 0.7772559518757015, 0.7392205254226207, 0.7305547870588323, 0.5346418711342418, 0.5455258585813226, 0.5402920826659453, 0.5655969099559037, 0.5267982394009563, 0.5559727379744963, 0.4826345601728058, 0.47068884614997486, 0.4563127692752793, 0.12392096059634805, 0.16273466957933236, 0.13079986042276648, 0.10613438179786339, 0.1345533370368157, 0.12188091935537193, 0.12897572620731823, 0.14171096777124093, 0.10777783819899867, 0.10620586237141105, 0.10792206934122661, 0.1205670074566233, 0.13518119696111697, 0.06512649864812592, 0.10909484043892193, 0.1450716907275288, 0.13215170222345973, 0.08401038759119017, 0.9446533720121305, 0.8801237448870399, 0.926839677979272, 0.9682285754640012, 0.9575415585078886, 0.935507723003737, 0.9646588334439611, 0.9397567613055532, 0.9505820587663353, 0.3994134514986808, 0.34384075451887497, 0.4006384588678651, 0.39035374537926726, 0.35578157707855484, 0.42112447127763897, 0.37885246009118945, 0.3518058581503377, 0.35116464489895516, 0.3660931983935358, 0.7545046798248991, 0.7335030220976713, 0.690743346925887, 0.7091692752194376, 0.7047149236339861, 0.738723298339779, 0.7606217450323988, 0.755004099396446, 0.26511755041297336, 0.5346078401309391, 0.1249771425382109, 0.35565868449793125, 0.3267202359569471, 0.295256100618735, 0.3504551512295867, 0.40001018736407046, 0.3255558790355977, 0.2829711709568704, 0.36348039025507417, 0.3769167101212222, 0.23118144989109424, 0.28362553675993474, 0.17033550789337437, 0.173948811454393, 0.4221108875119951, 0.11842465296264726, 0.23607842072101126, 0.2009925893060276, 0.28284188412773825, 0.11114281478768917, 0.2615127318650998, 0.3020199713792344, 0.32994006725432645, 0.39437432268610284, 0.2729319695084229, 0.49767351645467384, 0.4734328539328593, 0.3961249030677907, 0.4365936397205653, 0.4425979377153074, 0.41246208149271346, 0.4856290423831887, 0.5278676822383617, 0.4732339937348511, 0.1557482934253107, 0.18247315301881084, 0.21000642128115132, 0.188451571488506, 0.2198849103789018, 0.11755869540120167, 0.16076358417643255, 0.1930551455961731, 0.10782026407808021, 0.2560104398162494, 0.30631128047921463, 0.2450802455818175, 0.3049695422197928, 0.27385864951411265, 0.3229677970974705, 0.2564708671908472, 0.22576618094559342, 0.24865560582422308, 0.6702826328300243, 0.6767858404600062, 0.636380891388311, 0.5980449411580816, 0.6631417284433693, 0.6343546848670989, 0.6599212000066557, 0.5999085851651904, 0.6369373557444581, 0.08895696464608549, 0.11541565561345812, 0.09110268370267527, 0.09856530934731178, 0.11889886744674782, 0.11569642398718005, 0.1158642543288173, 0.1373978915392865, 0.11723904419807119, 0.33020023875476145, 0.14903582320275177, 0.16935755196642277, 0.1866490518373901, 0.29495022850040464, 0.2144651718020043, 0.24094273932603139, 0.1918749748423324, 0.26343598899630893, 0.28334828470002127, 0.3609339581137413, 0.3895029534406822, 0.3713543883634892, 0.43103799025875955, 0.41835113408779334, 0.383771631657283, 0.42327394506535054, 0.4055980250505302, 0.3252967851214926, 0.23416382143274506, 0.291841859716485, 0.20284336856651197, 0.3206699664040288, 0.21694379259659413, 0.28629982518965147, 0.2575749761408218, 0.272919835107041, 0.2091110484228702, 0.1912510759083429, 0.1847287183099976, 0.20188041620625286, 0.21485617852665062, 0.1727044673407876, 0.19382457154948207, 0.2074129180497104, 0.22897669790281217, 0.1665055452226294, 0.2074108692223443, 0.183401460971655, 0.200594007609754, 0.19018464264325619, 0.19741932098781667, 0.2067479150405246, 0.19304527091945156, 0.2244787680833542, 0.8121016390612618, 0.2003936331388484, 0.20846736818039302, 0.1713929846798945, 0.1925225450588195, 0.7206397874939798, 0.13811731189874932, 0.17401243927214904, 0.16794903404641703, 0.7218741371951071, 0.16589852240344094, 0.7600044257715, 0.6911095891865313, 0.15230712242854938, 0.12267087896732043, 0.6575889085908557, 0.73930437299855, 0.20837228749390102, 0.18870796698893288, 0.18397179510448036, 0.18187871907401776, 0.18321585458445733, 0.18358382791872196, 0.17977987375340887, 0.18374218571379142, 0.20041016222276664, 0.1868775686359344, 0.07625874759572648, 0.07603382071471876, 0.07080442733276793, 0.07191431418643568, 0.07751986916772435, 0.07899588535345192, 0.08407189517952918, 0.08274314128212046, 0.07469992659535185]}, "mutation_prompt": null}
{"id": "f718ce5d-b2e5-4093-b055-3993942cc1de", "solution": "import numpy as np\n\nclass EnhancedHybridEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 16 * dim\n        self.F = 0.6  # Differential weight\n        self.CR = 0.8  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # Adaptive factor for dynamic adjustments\n        self.diversity_weight = 0.05  # Weight for diversity preservation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c]) + \\\n                   self.diversity_weight * (self.population[idx] - self.population[a])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.4, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedHybridEvoStrategy", "description": "An augmented hybrid adaptive evolutionary strategy leveraging diversity preservation and dynamic crossover for improved exploration and exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.2680586728029888, "feedback": "The algorithm EnhancedHybridEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {"aucs": [0.6308683232973431, 0.6438102259832725, 0.5895492924009595, 0.6489146272154408, 0.6116239087802908, 0.642949641199091, 0.6019374177790886, 0.5956703300437594, 0.5872927452132743, 0.3064885801337053, 0.3004795214067584, 0.3125113680014331, 0.28028701973221015, 0.335009693931536, 0.3054941411844435, 0.27956246636533055, 0.32709747684824886, 0.31069497566199833, 0.11529330602343102, 0.11108675339312413, 0.0970084245808508, 0.10037059294637929, 0.1030721953104543, 0.11381639621572193, 0.10905737164971963, 0.11596058511420038, 0.09228963017635416, 0.11152948295139464, 0.0867369155044615, 0.11447508321011368, 0.11330722251405745, 0.08666565619605704, 0.09927453627648997, 0.09704454728830281, 0.11530808722612851, 0.09766912303036135, 0.9671214313650605, 0.9299513466690776, 0.962746291622686, 0.9223449204111241, 0.8956722844680481, 0.9381193062464445, 0.9521334862898518, 0.9495031687312481, 0.9580867813119142, 0.23855632367458612, 0.2541386168381401, 0.2962456395016687, 0.2568685937383407, 0.2266255077729994, 0.24239459568482535, 0.26750433608634594, 0.2826440034426353, 0.25847070487033363, 0.4668372458252621, 0.5660788888439163, 0.604702206489315, 0.5752794797056925, 0.500108070998299, 0.5817400748947569, 0.5512005947144453, 0.636392811036849, 0.6002327473515501, 0.16892819613983867, 0.15310448950835764, 0.2313814594011988, 0.1865953444735866, 0.22531800959897197, 0.22444682110681913, 0.21346626680935588, 0.3261399815652515, 0.33518475257377744, 0.2035354545526472, 0.23414974109256126, 0.20511774955303153, 0.1124877256012281, 0.14384710301109993, 0.21271951274752499, 0.2558374842816399, 0.21704706446171074, 0.17554427266820327, 0.09862782834492878, 0.0900335249136871, 0.12769630416489886, 0.12046307286344904, 0.11657712576910961, 0.009591421861451455, 0.08644831109740858, 0.12332198106705272, 0.13079974016031648, 0.19817225711602737, 0.23048655444691235, 0.21107561914038064, 0.19420386198372164, 0.18796449128506942, 0.24324989956230592, 0.253315773595577, 0.2731254334042471, 0.2563911767161604, 0.03996903686658204, 0.029332587099752838, 0.06842070106392728, 0.03785663880941825, 0.046540312311526444, 0.06010015488669318, 0.03805949107944018, 0.057587803327873166, 0.030493779608282923, 0.17373980459027805, 0.16196657910595225, 0.16054337317948153, 0.17029146653061822, 0.16112002682027304, 0.18591282235263973, 0.12830149963787607, 0.15643274564711285, 0.1392425671809211, 0.44657194316550575, 0.49642939774970607, 0.4802361236707725, 0.47604996229707575, 0.46213841553936486, 0.46810044109101445, 0.49583643746452366, 0.5386383982428438, 0.5008153885937474, 0.09145627646064092, 0.10587483779343942, 0.08796016598668754, 0.09136325931540756, 0.11969445394597933, 0.09873826647457795, 0.1018449947286797, 0.08895733460736843, 0.08185725918477915, 0.1541754595230821, 0.2144155329141716, 0.23089347916059044, 0.18411060764283604, 0.13281560073270426, 0.14872320143189421, 0.1802897203266699, 0.13047930525424767, 0.1656836438685073, 0.23432971326743413, 0.3202514955728729, 0.33384899065483953, 0.3142736627349647, 0.32126469901596555, 0.29973580197119987, 0.33281777903844134, 0.35214313325589497, 0.3235057319472636, 0.2415436018434557, 0.23665842328342668, 0.21504138947237272, 0.2474442508441601, 0.22418158260581122, 0.2339870770342074, 0.25792272305112474, 0.2455368909477197, 0.24005850664057837, 0.2007535746483724, 0.18135275447153532, 0.18951421938758717, 0.18523349010565593, 0.16909245984252208, 0.1814333336010121, 0.20456529642018872, 0.17934102060282353, 0.19803351702756578, 0.18992494157071216, 0.19911126796648826, 0.17720301728325016, 0.20231838366338584, 0.20827946218502802, 0.19896016605295452, 0.20066340572061103, 0.1788147866065627, 0.23264479250915726, 0.18558843124454993, 0.18726571634663647, 0.15986867626037982, 0.19790684950489001, 0.6283863108063852, 0.5739316173095393, 0.15526573112246134, 0.14619158762764817, 0.6396319808531018, 0.5793499944869399, 0.19165434983725604, 0.2022078723999291, 0.5501246687932851, 0.16145988196810446, 0.19850390007298557, 0.20456511820267065, 0.550377850362606, 0.20538490094797568, 0.1997932822634073, 0.17730546883160347, 0.16443218818044136, 0.17920707589637763, 0.17695440290355802, 0.1724172805359958, 0.1699194662711767, 0.16786600502932159, 0.16741193121596953, 0.07455113712637051, 0.07866025394583576, 0.06709789723250437, 0.07642260328462303, 0.08677786023600731, 0.08246177457923454, 0.06826631447355846, 0.07795447699051472, 0.0753588981784109]}, "mutation_prompt": null}
{"id": "451d1cfb-ac81-460d-929c-191fd0b31247", "solution": "import numpy as np\n\nclass EnhancedEvoEnsemble:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim  # Adjusted size for diversity\n        self.F = 0.6  # Slightly increased differential weight\n        self.CR = 0.9  # Increased crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand-to-best'\n        self.adaptive_factor = 0.93  # Slight adjustment for dynamic changes\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'rand-to-best':\n            return self.population[a] + self.F * (self.best_solution - self.population[a] + self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 15:  # Faster adaptability check\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand-to-best'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.04 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n                    \n            if func_calls > self.budget * 0.9:\n                self.initialize_population()  # Restart mechanism\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedEvoEnsemble", "description": "An ensemble strategy combining differential evolution and enhanced local search with adaptive parameters and restart mechanisms for improved convergence.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {}, "mutation_prompt": null}
{"id": "dbbdab8b-bfec-48ca-9f98-8d824e8300f5", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategyV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 14 * dim\n        self.F = 0.6  # Adjusted differential weight\n        self.CR = 0.9  # Adjusted crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.92  # Slightly adjusted adaptive factor\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)  # Adjusted minimum F\n                    self.CR = np.clip(self.CR, 0.5, 0.95)  # Adjusted minimum CR\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.4:  # Adjusted conditions\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategyV2", "description": "An adaptive hybrid algorithm using differential evolution with periodic random walks and adaptive parameters for improved convergence stability.", "configspace": "", "generation": 20, "fitness": 0.322779395413505, "feedback": "The algorithm HybridAdaptiveEvoStrategyV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {"aucs": [0.6752299239159154, 0.6848610325025156, 0.6904662254095685, 0.6892534869139618, 0.6889089362446015, 0.7022481975629048, 0.6506526978529357, 0.6800624209489077, 0.7155337921424714, 0.4452919882443537, 0.4001498195904485, 0.3895423631049506, 0.3229801173873096, 0.4514669011970913, 0.44185373605386014, 0.39812601471680475, 0.4422477350390873, 0.4056622802359662, 0.09458841398766982, 0.10696016759071847, 0.1159325781599253, 0.10845132013336245, 0.10601774074308745, 0.1091970846060829, 0.0993847457563859, 0.1220265103432221, 0.11096704313647021, 0.09833543509557185, 0.12762251403889935, 0.08279677427371257, 0.10960420126000847, 0.11966325190949334, 0.092598287929891, 0.09704424885873963, 0.1083194371401538, 0.08163383286789228, 0.9532640469016798, 0.9562520201456459, 0.9251923513146536, 0.908928964121466, 0.9158710377353724, 0.883930362244618, 0.9088207565830821, 0.9394459186691637, 0.9349195371941738, 0.3151444633647128, 0.2967528102243916, 0.28501754557784886, 0.3370774256636395, 0.30717450785489453, 0.30860755784525895, 0.3114491273261434, 0.3115441372892719, 0.2873838600200863, 0.7547161830453142, 0.6188842747506134, 0.19833894233921423, 0.7191013246422003, 0.6828273738488129, 0.6917710704317821, 0.6451124410025204, 0.6904814207562314, 0.6139759399071599, 0.23944660147594732, 0.2672355150223893, 0.3511078757188407, 0.12054004461740275, 0.3292292305547867, 0.26404172891549527, 0.2370207450306947, 0.32178162519734055, 0.3146289562145035, 0.1097840097954742, 0.0512591480362542, 0.11726673660279252, 0.21339036368247644, 0.25659656993485414, 0.379351618808473, 0.3206455951272835, 0.24042127955769876, 0.35093600372631273, 0.3174715468460235, 0.2728237916201378, 0.20952203149979243, 0.22669320511162383, 0.16217550835382355, 0.2529899597838272, 0.3319375193043286, 0.2876630210255984, 0.2261710505438781, 0.4841936745077089, 0.41841490167940043, 0.31658347008360355, 0.3949547560730228, 0.4432577197251343, 0.37844278528502484, 0.46313320246615, 0.45585022004824827, 0.4300578920467697, 0.1107909455761179, 0.09450081068987615, 0.06667876814150608, 0.1569927465374441, 0.13380875865449438, 0.12247160385899447, 0.06277783952896221, 0.06861922311303137, 0.2229289463512556, 0.21346469695771741, 0.26295160710571985, 0.1985831213293191, 0.22981059546477267, 0.24612387666564728, 0.2453787672312241, 0.23881040639653606, 0.2381138486978961, 0.21638207637259865, 0.5632828435739883, 0.5472617616713586, 0.6066775219803989, 0.5355074395430107, 0.5302929620192547, 0.5803679843106906, 0.6139506767360609, 0.6301866553697071, 0.6133337479335574, 0.0906710034533098, 0.10759120454448023, 0.0816272978478868, 0.12558796174047415, 0.10317518899863132, 0.10832555501833396, 0.07550634327730454, 0.10347116645183674, 0.08610300619049815, 0.12628628821502774, 0.2076936842722964, 0.3271886953462876, 0.16236115606866153, 0.19155208906567467, 0.14178572965441194, 0.19533018127084034, 0.1990619936560737, 0.14343625701584917, 0.3252992770051222, 0.317528322958909, 0.34675279415887394, 0.380523932236449, 0.3847314059404696, 0.3393673949295052, 0.34707156385354243, 0.3906424605998128, 0.39783956254156105, 0.31213664036333444, 0.29792244396540646, 0.2803912197443724, 0.28359141217814243, 0.267516401896578, 0.26533981885941116, 0.3099058288427077, 0.3179370816895002, 0.2596087398850786, 0.21942039780014133, 0.19534321291929102, 0.17727158907916185, 0.18952714344537935, 0.23412120870692754, 0.20996692230774416, 0.1900243418469849, 0.19636773257579243, 0.21131060019125036, 0.21914681001686032, 0.19077830085021685, 0.18217589891729824, 0.21589074826943644, 0.4738278402932804, 0.18971918981261227, 0.20161338628277525, 0.34471845069880735, 0.2202984378427424, 0.15295382622594667, 0.16697729018800378, 0.20677000248822575, 0.7598985037950108, 0.7609486675182362, 0.7368190243990363, 0.19272126086842234, 0.6422367525858615, 0.6883655879028006, 0.746459274386136, 0.6726956198694112, 0.716575666049514, 0.18470558393599257, 0.20436250685181478, 0.19787419765752912, 0.20772679307988007, 0.12717267961619405, 0.2038016296619104, 0.18147237815924078, 0.1789601317329147, 0.18183301139484465, 0.17825223183838712, 0.18809774694882342, 0.18271426714917982, 0.1710639959248933, 0.17765962538698254, 0.19527446615416733, 0.08520672453526712, 0.07935321122699879, 0.07395541301529285, 0.07190464581580747, 0.07350015825493539, 0.07513813320705287, 0.07764546674741835, 0.07851181261470175, 0.06362101300773704]}, "mutation_prompt": null}
{"id": "df4cacf7-1a94-4745-8b20-85d5fbeff5bf", "solution": "import numpy as np\n\nclass EnhancedHybridEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim\n        self.F = 0.6  # Differential weight\n        self.CR = 0.8  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 15:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-7:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.08 + 0.015 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedHybridEvoStrategy", "description": "An enhanced hybrid evolutionary strategy combining adaptive differential evolution with stochastic perturbations for dynamic exploration and exploitation balance.", "configspace": "", "generation": 21, "fitness": 0.3192801258434618, "feedback": "The algorithm EnhancedHybridEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {"aucs": [0.7161560045520377, 0.6542022316336996, 0.6894184295389099, 0.6798605327689022, 0.6979742190552509, 0.716781696430842, 0.7059940045735439, 0.7005376720984291, 0.6815253427938828, 0.4626772882386333, 0.4494111018138518, 0.4465612821768401, 0.45925028894510045, 0.4625262271892622, 0.46686535000003204, 0.5237953071285214, 0.43307877414358265, 0.4535434953509414, 0.12143036385515993, 0.12225981659178509, 0.09618932300884575, 0.13629731021479985, 0.11944804857699287, 0.1089386364499535, 0.13728004428372953, 0.13817534849022728, 0.20266674415201757, 0.14121085765544872, 0.0924698542722675, 0.1379578566361428, 0.10133954710987214, 0.1167436796257354, 0.12737101770183745, 0.09692588431858984, 0.09415688955895007, 0.10137355829516359, 0.9526655592164663, 0.9465230530068142, 0.9484529819778365, 0.9706974805537335, 0.9004828660840483, 0.9333820080784725, 0.9693437117368674, 0.9486016301055389, 0.9580719422802934, 0.2748447766054837, 0.29314563008525496, 0.30909928301702116, 0.31116978697736764, 0.31972660497041683, 0.32047207456205073, 0.3360174556348411, 0.3264559499366889, 0.3391221673136615, 0.6712912736327763, 0.6775148950884264, 0.7099843222720192, 0.6752227146396805, 0.7563067973449282, 0.6515319263225243, 0.6058497396994326, 0.6429487525457493, 0.6882237847865976, 0.2565891334637441, 0.16695439646450816, 0.3031558392161492, 0.21598570365833025, 0.2844888898119361, 0.21531735603969082, 0.28640134073635437, 0.2591432265364376, 0.2655999052050363, 0.1121626231864018, 0.18359899674360747, 0.25822178635837356, 0.33709559770916353, 0.22540194666166435, 0.3045561040732714, 0.2531904412424629, 0.26401723656938403, 0.27571525084237847, 0.12149634808044374, 0.24080101514737695, 0.15574727748237271, 0.11020883703534834, 0.2185584612518362, 0.14436575989270783, 0.17316391570454748, 0.1324099072825795, 0.13925613875272425, 0.3179350357191997, 0.37913393865741374, 0.35811373281851633, 0.24654942092376742, 0.31323950593675254, 0.3110647710043982, 0.3268698718411214, 0.2913973218410266, 0.3420708216365518, 0.1359955631961116, 0.035231414665712335, 0.019284064892422847, 0.13678875529317158, 0.09506506836976025, 0.07674035930115786, 0.07785351923644757, 0.07882256526825204, 0.1268059288756711, 0.209412974474385, 0.16546280851244777, 0.18837850241828613, 0.21282857181562653, 0.1922714826771983, 0.21985295108269542, 0.20120808671660262, 0.19151559386677863, 0.20794638143483735, 0.5180459646024397, 0.5564561381646178, 0.6129243363738877, 0.524568500555832, 0.5187321140767169, 0.5242429644707475, 0.5591313503479441, 0.5835293948732952, 0.5365880331683776, 0.11033962888471849, 0.11119924336623133, 0.09314351793542341, 0.08828488204747864, 0.1378206839750048, 0.091294335182591, 0.09693462037311529, 0.1126285587319864, 0.09315954139549254, 0.1501801621048302, 0.1753878753264002, 0.23613960970694736, 0.18427313989827876, 0.1653061309021574, 0.1465575933235832, 0.15835810843249598, 0.149841298371311, 0.19661510768182067, 0.3334892351915816, 0.37911242647356536, 0.36361421146522044, 0.33494841688581933, 0.3862811016979596, 0.3654190721584427, 0.380388946405788, 0.3295978375741474, 0.382032874931336, 0.2436668090016122, 0.20613723795915861, 0.2700619790848744, 0.32521614292374257, 0.2095267047913505, 0.2576957233240341, 0.3153022768604271, 0.2841188342965877, 0.24147536238277056, 0.16531367911312878, 0.1958345190550047, 0.19734155914460638, 0.19932490933704416, 0.20782985929783315, 0.18468222392175015, 0.23613815994582243, 0.19010396965572596, 0.196845611114827, 0.43004497138545106, 0.21969413123341353, 0.18923319198817157, 0.4243180921102919, 0.22258854968696062, 0.4270897671819034, 0.20352945697001001, 0.1975778266407462, 0.21952785483073878, 0.1606956305496816, 0.7537753004418489, 0.16484434675201132, 0.7698480787649039, 0.1753624579154468, 0.6974715946797221, 0.17831447599583283, 0.15546228302316145, 0.6884763158100426, 0.16434233909344598, 0.16383191762213722, 0.6932656602196525, 0.6511587572222246, 0.1950205763420113, 0.6141502183813049, 0.722782084944479, 0.2010578267857288, 0.7262034818397212, 0.18727633788930675, 0.18327928969547824, 0.1760936934996089, 0.17524382662309856, 0.18970101742061196, 0.17924259044212942, 0.1840377903751531, 0.16601814773991386, 0.17335255142058736, 0.08675668329760633, 0.08902223824761912, 0.07968414027752502, 0.07758772876218667, 0.08181353062678642, 0.07911041240413874, 0.07615251534172662, 0.08652825872314174, 0.07977107739228106]}, "mutation_prompt": null}
{"id": "efcd9819-2f7f-41aa-b0df-6b897acaf392", "solution": "import numpy as np\n\nclass EnhancedAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim\n        self.F = 0.6  # Differential weight\n        self.CR = 0.8  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.92  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedAdaptiveEvoStrategy", "description": "An enhanced adaptive evolutionary strategy integrating differential evolution, adaptive random walks, and dynamic parameter tuning for robust optimization.", "configspace": "", "generation": 22, "fitness": 0.3190184172112289, "feedback": "The algorithm EnhancedAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {"aucs": [0.7161560045520377, 0.6542022316336996, 0.6894184295389099, 0.6798605327689022, 0.6979782596257138, 0.716781696430842, 0.7059940045735439, 0.7005376720984291, 0.6815253427938828, 0.4626633394408656, 0.4494111018138518, 0.4465612821768401, 0.45925028894510045, 0.4625262271892622, 0.46686535000003204, 0.5237953071285214, 0.43307877414358265, 0.4535434953509414, 0.12143036385515993, 0.11821292100654557, 0.0962819905171971, 0.13384159725258704, 0.11944804857699287, 0.1089386364499535, 0.1907495331989949, 0.13817534849022728, 0.13207624791572847, 0.14121085765544872, 0.0924698542722675, 0.1379578566361428, 0.09452880744409087, 0.10889500430359278, 0.1432814350053353, 0.09692588431858984, 0.09415688955895007, 0.10137355829516359, 0.9526655592164663, 0.9465230530068142, 0.9484529819778365, 0.9706974805537335, 0.9004828660840483, 0.9333820080784725, 0.9693437117368674, 0.9486016301055389, 0.9580719422802934, 0.2748447766054837, 0.29314563008525496, 0.30909928301702116, 0.31116978697736764, 0.31972660497041683, 0.32047207456205073, 0.3360174556348411, 0.3264559499366889, 0.3391221673136615, 0.6712912736327763, 0.6775148950884264, 0.7099843222720192, 0.6752227146396805, 0.7563067973449282, 0.6515319263225243, 0.6058497396994326, 0.6429487525457493, 0.6882237847865976, 0.2565891334637441, 0.16695439646450816, 0.3031558392161492, 0.21598570365833025, 0.2844888898119361, 0.21531735603969082, 0.28640134073635437, 0.2591432265364376, 0.2655999052050363, 0.11216262318628556, 0.18359899674360747, 0.25822178635837356, 0.33709559770916353, 0.22540194666166435, 0.3045561040732714, 0.2531904412424629, 0.26401723656938403, 0.27571525084237847, 0.12149634808044374, 0.24080101514737695, 0.15574727748237271, 0.11020883703534834, 0.2185584612518362, 0.14436575989270783, 0.17316391570454748, 0.1324099072825795, 0.13925613875272425, 0.3179350357191997, 0.37913393865741374, 0.35811373281851633, 0.24654942092376742, 0.31323950593675254, 0.3110647710043982, 0.3268698718411214, 0.2913973218410266, 0.3420708216365518, 0.1359955631961116, 0.035231414665712335, 0.019284064892422847, 0.13678875529317158, 0.09506506836976025, 0.07674035930115786, 0.07785351923644757, 0.07882256526825204, 0.1268059288756711, 0.209412974474385, 0.16546280851244777, 0.18837850241828613, 0.21282857181562653, 0.1922714826771983, 0.21985295108269542, 0.20120808671660262, 0.19151559386677863, 0.20794638143483735, 0.5180459646024397, 0.5564561381646178, 0.6106771579424853, 0.524568500555832, 0.5187321140767169, 0.5242429644707475, 0.5591313503479441, 0.5812493649262318, 0.5365880331683776, 0.09670049867899211, 0.11428743038629186, 0.0970986785007506, 0.09474891182144907, 0.1378206839750048, 0.08985220054816323, 0.08779630288421558, 0.10035914535843571, 0.09367400719142738, 0.15861181223239418, 0.1753878753264002, 0.23613960970694736, 0.18427313989827876, 0.16514602739020579, 0.13799006969145244, 0.16722670809969953, 0.18672984250884328, 0.19661510768182067, 0.3334892351915816, 0.37911242647356536, 0.36361421146522044, 0.33494841688581933, 0.3862811016979596, 0.3654190721584427, 0.380388946405788, 0.3295978375741474, 0.382032874931336, 0.2436668090016122, 0.20613723795915861, 0.2700619790848744, 0.32521614292374257, 0.2095267047913505, 0.2576957233240341, 0.3153022768604271, 0.2841188342965877, 0.24147536238277056, 0.16189971758645638, 0.1891404515510805, 0.19092380463603842, 0.19911726392169704, 0.2006472989426139, 0.17717265719233533, 0.23613815994582243, 0.17614422101931104, 0.19559098615999215, 0.43004497138545106, 0.21969413123341353, 0.18923319198817157, 0.4243180921102919, 0.22258854968696062, 0.4270897671819034, 0.203529456970031, 0.1975778266407462, 0.21952785483073878, 0.1606956305496816, 0.7537753004418489, 0.16484434675248028, 0.7698480787649039, 0.17536245791530258, 0.6974715946797221, 0.17831447599585704, 0.1554622830235194, 0.6884763158100426, 0.16434233909357265, 0.16383191762039429, 0.6932656602196525, 0.6511587572222246, 0.19502057635403525, 0.6141502183813049, 0.722782084944479, 0.20105782678810769, 0.7262034818397212, 0.18677273336706623, 0.1685771448969937, 0.1747992418413522, 0.17533774250806566, 0.18806778587759632, 0.18693665476977117, 0.1827908876148301, 0.17394646009221437, 0.17763689130185045, 0.08472292883486099, 0.08902223824761912, 0.08230855482154842, 0.075563423543205, 0.08181353062678642, 0.08023031726675922, 0.07300547998016449, 0.08045972039978766, 0.0826140076525469]}, "mutation_prompt": null}
{"id": "f42545ce-3855-4154-b94a-1a06b92b347b", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim\n        self.F = 0.6  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.elitism_rate = 0.1  # Proportion of elites retained\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            target_vector = self.best_solution\n        else:\n            target_vector = self.population[a]\n        return target_vector + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            fitness = self.evaluate_population(func)\n            func_calls += self.population_size\n\n            new_population = []\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                else:\n                    new_population.append(target)\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n\n            self.population = np.array(new_population)\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if func_calls > self.budget * 0.8:\n                elite_count = int(self.elitism_rate * self.population_size)\n                elite_indices = np.argsort(fitness)[:elite_count]\n                elite_solutions = self.population[elite_indices]\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05, self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n                self.population = np.concatenate((elite_solutions, self.population[:self.population_size - elite_count]))\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "A hybrid evolutionary algorithm integrating self-adaptive differential evolution, random walks, and elitist selection mechanisms for robust global optimization.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 48 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 48 is out of bounds for axis 0 with size 40')", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {}, "mutation_prompt": null}
{"id": "117ed461-e809-4fd8-a943-7b6f98cf366c", "solution": "import numpy as np\n\nclass EnhancedHybridEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 16 * dim\n        self.F = 0.6  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_probability = 0.2\n        self.adaptive_factor = 0.85  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c, d = indices[:4]\n        if np.random.rand() < self.mutation_probability:\n            return self.best_solution + self.F * (self.population[b] - self.population[c]) + self.F * (self.population[d] - self.population[a])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 1.0)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                self.best_solution = np.clip(self.best_solution + perturbation, self.bounds[0], self.bounds[1])\n            else:\n                self.best_solution = self.best_solution\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedHybridEvoStrategy", "description": "An enhanced hybrid adaptive evolutionary algorithm leveraging probabilistic mutation switching, multi-candidate selection, and gradient-inspired local exploitation for improved optimization efficiency.", "configspace": "", "generation": 24, "fitness": 0.18939331551763844, "feedback": "The algorithm EnhancedHybridEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {"aucs": [0.3812272303249923, 0.40194801084458975, 0.3762585186125249, 0.41929698201134813, 0.42606992030664814, 0.4174403090481267, 0.42486751058835726, 0.4275218187164773, 0.41052278032020373, 0.13581246306426842, 0.12849249590478917, 0.13539557958320114, 0.11822702552071207, 0.12325585235779468, 0.1329951301152833, 0.1360931866954086, 0.13352434719974082, 0.12790965026530354, 0.08075732401021996, 0.09094197827541817, 0.07990193142348834, 0.0828327989068477, 0.09733604400746276, 0.08333910950397039, 0.09965387141734094, 0.08127958035678462, 0.08248670520409318, 0.06413699844975362, 0.0736643610629053, 0.07311245602798266, 0.08256968707005363, 0.066661739544852, 0.06942492941381528, 0.06882007205579599, 0.07001983162427172, 0.06857257714698262, 0.9619815181719796, 0.9607726525434386, 0.96859389562792, 0.9948021991125353, 0.917921169419646, 0.954718653522902, 0.9234244252389905, 0.9762398726563576, 0.8657035308111782, 0.16418304893850366, 0.1866758071518404, 0.15886115878645446, 0.1529625766058883, 0.1736064630292441, 0.1749726072770882, 0.1606989758542532, 0.1872600535929676, 0.1828109661392504, 0.24069084165948118, 0.25534473529544544, 0.23899195599975687, 0.2888723241821626, 0.28061329761116627, 0.2808059525136709, 0.37438364463077733, 0.24606431006618446, 0.28201707908744944, 0.10188314263866838, 0.09814678761204687, 0.12838936708303517, 0.10124919302466229, 0.12562926184547796, 0.1081520982935914, 0.10977878572097033, 0.09360364677003485, 0.12597264878919634, 0.06730056951471652, 0.1676078838726831, 0.11597663199800445, 0.09937035853131015, 0.1105530309610242, 0.10341509494496837, 0.1016509099476145, 0.08753851511005817, 0.09710342434773134, 0.03607402861577025, 0.03260582412085755, 0.01139566512019552, 0.05861062807593376, 0.025260379228860486, 0.036929633031808407, 0.03485572675864501, 0.03271829443991048, 0.016219243208139056, 0.1413013064413009, 0.1533013097852547, 0.14970370007009237, 0.07590045320587269, 0.11866814967027528, 0.12512862288720517, 0.16179756655690236, 0.12933326858882865, 0.14802927484250827, 9.999999999998899e-05, 0.0019163976168805608, 9.999999999998899e-05, 9.999999999998899e-05, 0.019220085035990486, 9.999999999998899e-05, 0.001660060849932421, 9.999999999998899e-05, 0.0049420667182740186, 0.07952828380454668, 0.08764074990023041, 0.07446876921901258, 0.08152702590820593, 0.08043336978846305, 0.07157860956501538, 0.0820022119812025, 0.0890962092425116, 0.088212204257347, 0.3398317541325443, 0.3335735413734, 0.35567664020079615, 0.37545299474275085, 0.35112673892432555, 0.34330818446579847, 0.3478811764177817, 0.3438410938118692, 0.3494154323031756, 0.08468955496220332, 0.09349566444099622, 0.08089130932825772, 0.09465082002299574, 0.07669526954646388, 0.09393676511404025, 0.09168130740988012, 0.07740917652437951, 0.08399054014339469, 0.14235874619517885, 0.14517199576575912, 0.13088916904120929, 0.14069058942472912, 0.17069720537828326, 0.1275205367025477, 0.16014461691577908, 0.13636848172506633, 0.1373353103575744, 0.21007034200061359, 0.22083158334582154, 0.2268821635229583, 0.2285398882548889, 0.2192740179841357, 0.21421620150102394, 0.21730754173413147, 0.2479190205163595, 0.24549364954950825, 0.15420940740193712, 0.1758621971715626, 0.17272073115377284, 0.16414494224225762, 0.15765932171173247, 0.18103964093627478, 0.17166210835595852, 0.1716361753923582, 0.1815166502609471, 0.18077768117506277, 0.17677747161819157, 0.18503769566814166, 0.17411635679267978, 0.1629296344780652, 0.1713312444874311, 0.1726496946185211, 0.20263672640956976, 0.17474770035369547, 0.17076247375723475, 0.17292383510332654, 0.17717017128697554, 0.17340669496999506, 0.1735428069912146, 0.17120860030765472, 0.1677511349294447, 0.1732483004481894, 0.1781737146131529, 0.29415574095751706, 0.38456270710050433, 0.23697060948972748, 0.1696459743084835, 0.23200059307139154, 0.17620470715859105, 0.1681904017640039, 0.22313854575439596, 0.14086100647215039, 0.18267824321365012, 0.16916522906291742, 0.14451103325409753, 0.15492526065105106, 0.17940085783933157, 0.22592472046025536, 0.20807176854259546, 0.18269516596224222, 0.3023362060117001, 0.18173985788801383, 0.1742896177063883, 0.16090611205602967, 0.17590007947800945, 0.1910925468675848, 0.1703018164539022, 0.17424056445585334, 0.20100901337654442, 0.18232406182065364, 0.0666128783304113, 0.06576003743838232, 0.060918126385923976, 0.06924144501794904, 0.0659913837264674, 0.06335287844719983, 0.06244374742440817, 0.06333347744747841, 0.054932607948018464]}, "mutation_prompt": null}
{"id": "c0c66831-e50c-46b1-8ca6-584e790d66f2", "solution": "import numpy as np\n\nclass RefinedHybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim  # Reduced population size for exploration efficiency\n        self.F = 0.6  # Adjusted Differential weight\n        self.CR = 0.9  # Adjusted Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "RefinedHybridAdaptiveEvoStrategy", "description": "A refined hybrid adaptive evolutionary strategy with enhanced differential mutation and dynamic crossover for improved global search and convergence. ", "configspace": "", "generation": 25, "fitness": 0.32921962652290027, "feedback": "The algorithm RefinedHybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {"aucs": [0.7203273811626438, 0.714583031789186, 0.7206726391645584, 0.744861416474542, 0.7099564597652344, 0.6992431586755864, 0.7355192578117657, 0.7168763634572691, 0.7400512408002671, 0.5125114626194016, 0.4800597759185222, 0.4893333565433483, 0.585874794804371, 0.5141567003392168, 0.4852430309457775, 0.4419086176230348, 0.4990104508667872, 0.48225600584661166, 0.12430122484096517, 0.1264119520263579, 0.09670011723243643, 0.12718046566517083, 0.12565176389816357, 0.1639152973268283, 0.10426840371448431, 0.13575838435245202, 0.09909851405783521, 0.08940039049383108, 0.09301848169279381, 0.10723470625970843, 0.10319369490347763, 0.10247573683690736, 0.08603842549262586, 0.10092491191259101, 0.10628692402800721, 0.12324901378725828, 0.9329442900720781, 0.9064571174705021, 0.9298790529066201, 0.9725196197881142, 0.9568989178470678, 0.9538307461593257, 0.8228981929277184, 0.9659085104329281, 0.9512149177973178, 0.37169849206820305, 0.3267770215365804, 0.34424988577194104, 0.38527915425478676, 0.36659558106994306, 0.38410504299238823, 0.3641534925059826, 0.3604621165411258, 0.3395950840500551, 0.7597889662219276, 0.7407757890320377, 0.7057291604930949, 0.7362202362164847, 0.684998307525767, 0.740639662986528, 0.14222478755675916, 0.7717770939923957, 0.7056240581385089, 0.3037371195541235, 0.31862407805647586, 0.3227000623212479, 0.11883309207426007, 0.21855137085090692, 0.4802865093099816, 0.11565968979943064, 0.123911806873507, 0.27976307837341297, 0.32357019063956705, 0.24704732157282983, 0.12133943254265611, 0.5049581156932386, 0.3130596442648391, 0.40741036171836265, 0.39015040800914735, 0.12187612084544763, 0.358732581862797, 0.3065917787768241, 0.3158809469369116, 0.29151710780667617, 0.3180115678657147, 0.2030879382039752, 0.38665636297036654, 0.32609226879636166, 0.19973933517214537, 0.21933301537331396, 0.4762548401430724, 0.45628976559702716, 0.5039664813709455, 0.45083504946042663, 0.47182955747833777, 0.53099553140678, 0.4857460169965111, 0.4237244008647165, 0.5454530739244363, 0.06084063077123614, 0.04836145969152217, 0.06795759832035742, 0.1692176824645688, 0.17335170244157272, 0.0645711726845275, 0.08504748857038469, 0.08413320600314511, 0.13100255826772356, 0.23564974446423492, 0.2616840145445152, 0.2680298520393448, 0.28990112470238394, 0.2707131871615226, 0.2622024424097643, 0.2865511013695504, 0.2711525987196577, 0.2784294779708575, 0.6237008874823803, 0.6406948190703902, 0.6239133367528672, 0.6101226092183889, 0.6458871203659738, 0.6126054346823961, 0.6007214196917718, 0.6006909226164162, 0.6171696509889077, 0.0964790973236671, 0.11682870716396976, 0.09962326961908952, 0.10978625440932044, 0.09895802529586495, 0.11609721202284129, 0.09934002452066493, 0.07215858333456748, 0.09838258761701568, 0.1969774020449172, 0.17055586051219562, 0.13051853492595544, 0.14825844123082565, 0.13728976998033138, 0.16589651502464098, 0.1888967901247558, 0.12165972346204523, 0.19736632581834246, 0.3771498171135257, 0.36487574817387736, 0.36668213619461576, 0.39835804453964274, 0.352780125795092, 0.370339893619656, 0.37852811589212176, 0.4075543220283072, 0.42104091943849864, 0.28008092202246937, 0.2181783743035688, 0.31667421360189196, 0.30805837607382225, 0.28437090714054425, 0.26236647473119634, 0.32584714431599215, 0.3299974313613334, 0.2625272279392248, 0.1973486866438503, 0.2142096766462993, 0.19330101538591515, 0.19645419733455327, 0.17466228878560974, 0.17918806085418715, 0.1945075624256829, 0.1741788851402023, 0.19697486094407057, 0.19625788930248844, 0.18360494904663638, 0.20713086372831335, 0.1895095138258477, 0.22371980220397725, 0.19259026467455664, 0.1965710538606903, 0.19504610803587763, 0.19471639972830768, 0.19895749090856718, 0.7888851469247901, 0.16149736160643302, 0.8284760284750979, 0.7100747700135832, 0.15485787968552378, 0.18457139418998436, 0.7174943186488938, 0.1664830135480817, 0.20474958044500213, 0.2056304652418659, 0.12403008073949473, 0.16477089758204488, 0.11064723861672743, 0.20797631444922238, 0.10316066421269954, 0.2018141428462793, 0.19566613070549288, 0.17226927191656127, 0.17911913326270967, 0.16860544661386556, 0.18010557828754603, 0.18246518578078774, 0.18752449611589384, 0.18039086930055892, 0.18068313750436193, 0.1704288185461421, 0.07688400628852798, 0.07104292614518304, 0.07973888588565436, 0.07917341546321766, 0.06622209486761799, 0.0870850665417422, 0.07482817663360308, 0.07465614078219696, 0.08270024442771595]}, "mutation_prompt": null}
{"id": "93b07e2f-b6c3-484b-8eac-ace6703ad731", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategyV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim  # Reduced size for focused search\n        self.F = 0.6  # Adjusted Differential weight\n        self.CR = 0.9  # Adjusted Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'best'\n        self.adaptive_factor = 0.9  # Adaptive factor for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        base_vector = self.best_solution if self.mutation_strategy == 'best' else self.population[a]\n        return base_vector + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 15:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand'\n            else:\n                self.mutation_strategy = 'best'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.02 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategyV2", "description": "A hybrid adaptive evolutionary algorithm combining dynamic differential evolution and stochastic gradient-like local searches with adaptive parameters to optimize performance across varying landscapes.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {}, "mutation_prompt": null}
{"id": "f8551b96-47ab-49b1-98cb-504ad58ed44f", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 15 * dim\n        self.F = 0.6  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # Adaptive factor for dynamic adjustments\n        self.temperature = 1.0  # Initial temperature for simulated annealing\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def simulated_annealing(self, solution, func):\n        perturbation = np.random.normal(0, self.temperature, self.dim)\n        new_solution = np.clip(solution + perturbation, self.bounds[0], self.bounds[1])\n        new_fitness = func(new_solution)\n        if new_fitness < self.best_fitness or np.random.rand() < np.exp((self.best_fitness - new_fitness) / self.temperature):\n            self.best_solution = new_solution\n            self.best_fitness = new_fitness\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.9)\n                    self.CR = np.clip(self.CR, 0.4, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    self.simulated_annealing(self.population[i], func)\n                    func_calls += 1\n                self.temperature *= 0.95  # Cooling schedule\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "A refined hybrid adaptive evolutionary strategy combining differential evolution and simulated annealing with adaptive parameters for improved global search.", "configspace": "", "generation": 27, "fitness": 0.314547658802677, "feedback": "The algorithm HybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {"aucs": [0.6385289532267502, 0.6460934861398597, 0.6366234878540196, 0.6927151200431199, 0.6542837070225952, 0.6492142426933951, 0.6237446384601983, 0.6812144967647236, 0.6286207997845268, 0.3335075053442551, 0.4256140641571238, 0.3440667462515715, 0.3442239868157677, 0.39896297661860003, 0.36159933625895635, 0.38950265374103077, 0.33298399507645693, 0.41470705514414663, 0.1349605046810075, 0.0899059326281687, 0.10590470922750883, 0.11114312456310016, 0.09732242104302091, 0.08633576391581754, 0.12394901911623579, 0.1346512647886451, 0.1095955579702178, 0.09351999101893871, 0.09475446647361774, 0.08740742813438196, 0.09240037218609287, 0.09100847735067341, 0.087838011978008, 0.07816054669655137, 0.10583959499319573, 0.091874439762333, 0.9659537645367042, 0.9314646083251159, 0.8837840887645121, 0.9486381865937942, 0.9486766818227756, 0.8773881883199677, 0.9374200423909991, 0.9590323736596628, 0.9071122333049885, 0.2693997509537974, 0.31090569884502817, 0.2692242649872444, 0.29413797550243004, 0.3088480035540955, 0.27879498464487174, 0.2956309016217903, 0.29747999726697716, 0.28297480069224346, 0.7010955193093003, 0.6708760273820835, 0.7085989657224472, 0.702331519389678, 0.7189008358081217, 0.6379446926670955, 0.6173094288670404, 0.604395995362215, 0.7264027572001563, 0.2824733232391212, 0.2590919297603901, 0.23560215426247033, 0.2576721191906769, 0.25177366745510965, 0.29212388271761347, 0.2201571547253387, 0.20325116066755677, 0.2822158813903981, 0.218087903677616, 0.3131411757486562, 0.29910176561693336, 0.11578843917023751, 0.3106605680732464, 0.4104275358776561, 0.3026088701514901, 0.25209746458676296, 0.3541258352767649, 0.19453720407318498, 0.23175834401992268, 0.14437758150765534, 0.2297458680621305, 0.20568882697551516, 0.19482015177710132, 0.23472332304253574, 0.17448608745205496, 0.23643313461558224, 0.3841087423964651, 0.34019871452181283, 0.3825171047341618, 0.3366825561527288, 0.331033465082871, 0.4265652605384481, 0.41240762950072185, 0.35455851324571475, 0.4028907309269839, 0.09112535755095463, 0.15968311549333192, 0.1450493213952917, 0.09800677459907603, 0.14029154941583533, 0.1199898259890202, 0.08114220165725361, 0.116570338537335, 0.0771696035817695, 0.22489047975507626, 0.19729958980775897, 0.18028390596913746, 0.21099205483581618, 0.20038195617428223, 0.24948876943294773, 0.21203403182069858, 0.2347448219496302, 0.220069417191473, 0.5713058361461427, 0.5273230823021428, 0.5225842617290879, 0.609293059532626, 0.6243762220443606, 0.5468101676968219, 0.5688047556047469, 0.5663463622852608, 0.5298723822977529, 0.09704942746932432, 0.08796396344488588, 0.08245991609731496, 0.07132182850392432, 0.10674084976476117, 0.12097357510999174, 0.10022381295767446, 0.07515467889870342, 0.09815074210404473, 0.1321830662656519, 0.13301091680851096, 0.1580107006193544, 0.16690106019631368, 0.14814758327638933, 0.25198982504575973, 0.12569817131441918, 0.16788088724022343, 0.1769374256319789, 0.33856685215265325, 0.34829569411083916, 0.3412570288744534, 0.3317522769193738, 0.34200685686383525, 0.37253316309433826, 0.288952059762389, 0.3661973919993673, 0.35279680043069916, 0.2534082818591544, 0.2600362386839492, 0.29301382896486516, 0.2706423155349893, 0.28475276649779, 0.2291556637832557, 0.3005243334077392, 0.27007309266383017, 0.2729482643512954, 0.18913249561253365, 0.178132708034198, 0.20101197627633305, 0.19552695307589174, 0.21848035458370263, 0.18093309817036474, 0.18690166731583435, 0.206636956715614, 0.1798944637950648, 0.25808116668512726, 0.19297930640551408, 0.2966668370498958, 0.25942345877466855, 0.18939676283943063, 0.19034760135033613, 0.20641764561311526, 0.191697023820802, 0.3677215320869539, 0.7201040564317691, 0.18343247985825661, 0.7539193418411021, 0.7178148836409193, 0.17703784384363175, 0.7231506836134881, 0.18654391430791628, 0.15853541269301663, 0.6491134332045808, 0.16680020164990605, 0.6591829218782566, 0.14903292033466153, 0.19390972298411957, 0.5709192791710732, 0.7003919493904585, 0.1225004736083447, 0.700036379143523, 0.16042754673922077, 0.18026847293027526, 0.19707912569284058, 0.1903670760239934, 0.1881605780253348, 0.16957305475956985, 0.17631945856605913, 0.18566665804058757, 0.18293750109120288, 0.17864794680801965, 0.09482239226232336, 0.088439545622922, 0.07893577685335529, 0.07041254424480026, 0.0702078532986683, 0.07656333844835006, 0.0727334920636753, 0.08800606534555022, 0.08184214762801678]}, "mutation_prompt": null}
{"id": "fc8bb90b-fbb8-4ad9-85a1-09f04572d0c7", "solution": "import numpy as np\n\nclass SynergisticAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim\n        self.F = 0.6  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # Adaptive factor for dynamic adjustments\n        self.stochastic_factor = 0.05\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 20:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, self.stochastic_factor + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "SynergisticAdaptiveEvoStrategy", "description": "SynergisticAdaptiveEvoStrategy: An advanced adaptive hybrid strategy integrating differential evolution, dynamic local exploration, and stochastic adjustments for robustness across diverse functions.", "configspace": "", "generation": 28, "fitness": 0.32921962652290027, "feedback": "The algorithm SynergisticAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {"aucs": [0.7203273811626438, 0.714583031789186, 0.7206726391645584, 0.744861416474542, 0.7099564597652344, 0.6992431586755864, 0.7355192578117657, 0.7168763634572691, 0.7400512408002671, 0.5125114626194016, 0.4800597759185222, 0.4893333565433483, 0.585874794804371, 0.5141567003392168, 0.4852430309457775, 0.4419086176230348, 0.4990104508667872, 0.48225600584661166, 0.12430122484096517, 0.1264119520263579, 0.09670011723243643, 0.12718046566517083, 0.12565176389816357, 0.1639152973268283, 0.10426840371448431, 0.13575838435245202, 0.09909851405783521, 0.08940039049383108, 0.09301848169279381, 0.10723470625970843, 0.10319369490347763, 0.10247573683690736, 0.08603842549262586, 0.10092491191259101, 0.10628692402800721, 0.12324901378725828, 0.9329442900720781, 0.9064571174705021, 0.9298790529066201, 0.9725196197881142, 0.9568989178470678, 0.9538307461593257, 0.8228981929277184, 0.9659085104329281, 0.9512149177973178, 0.37169849206820305, 0.3267770215365804, 0.34424988577194104, 0.38527915425478676, 0.36659558106994306, 0.38410504299238823, 0.3641534925059826, 0.3604621165411258, 0.3395950840500551, 0.7597889662219276, 0.7407757890320377, 0.7057291604930949, 0.7362202362164847, 0.684998307525767, 0.740639662986528, 0.14222478755675916, 0.7717770939923957, 0.7056240581385089, 0.3037371195541235, 0.31862407805647586, 0.3227000623212479, 0.11883309207426007, 0.21855137085090692, 0.4802865093099816, 0.11565968979943064, 0.123911806873507, 0.27976307837341297, 0.32357019063956705, 0.24704732157282983, 0.12133943254265611, 0.5049581156932386, 0.3130596442648391, 0.40741036171836265, 0.39015040800914735, 0.12187612084544763, 0.358732581862797, 0.3065917787768241, 0.3158809469369116, 0.29151710780667617, 0.3180115678657147, 0.2030879382039752, 0.38665636297036654, 0.32609226879636166, 0.19973933517214537, 0.21933301537331396, 0.4762548401430724, 0.45628976559702716, 0.5039664813709455, 0.45083504946042663, 0.47182955747833777, 0.53099553140678, 0.4857460169965111, 0.4237244008647165, 0.5454530739244363, 0.06084063077123614, 0.04836145969152217, 0.06795759832035742, 0.1692176824645688, 0.17335170244157272, 0.0645711726845275, 0.08504748857038469, 0.08413320600314511, 0.13100255826772356, 0.23564974446423492, 0.2616840145445152, 0.2680298520393448, 0.28990112470238394, 0.2707131871615226, 0.2622024424097643, 0.2865511013695504, 0.2711525987196577, 0.2784294779708575, 0.6237008874823803, 0.6406948190703902, 0.6239133367528672, 0.6101226092183889, 0.6458871203659738, 0.6126054346823961, 0.6007214196917718, 0.6006909226164162, 0.6171696509889077, 0.0964790973236671, 0.11682870716396976, 0.09962326961908952, 0.10978625440932044, 0.09895802529586495, 0.11609721202284129, 0.09934002452066493, 0.07215858333456748, 0.09838258761701568, 0.1969774020449172, 0.17055586051219562, 0.13051853492595544, 0.14825844123082565, 0.13728976998033138, 0.16589651502464098, 0.1888967901247558, 0.12165972346204523, 0.19736632581834246, 0.3771498171135257, 0.36487574817387736, 0.36668213619461576, 0.39835804453964274, 0.352780125795092, 0.370339893619656, 0.37852811589212176, 0.4075543220283072, 0.42104091943849864, 0.28008092202246937, 0.2181783743035688, 0.31667421360189196, 0.30805837607382225, 0.28437090714054425, 0.26236647473119634, 0.32584714431599215, 0.3299974313613334, 0.2625272279392248, 0.1973486866438503, 0.2142096766462993, 0.19330101538591515, 0.19645419733455327, 0.17466228878560974, 0.17918806085418715, 0.1945075624256829, 0.1741788851402023, 0.19697486094407057, 0.19625788930248844, 0.18360494904663638, 0.20713086372831335, 0.1895095138258477, 0.22371980220397725, 0.19259026467455664, 0.1965710538606903, 0.19504610803587763, 0.19471639972830768, 0.19895749090856718, 0.7888851469247901, 0.16149736160643302, 0.8284760284750979, 0.7100747700135832, 0.15485787968552378, 0.18457139418998436, 0.7174943186488938, 0.1664830135480817, 0.20474958044500213, 0.2056304652418659, 0.12403008073949473, 0.16477089758204488, 0.11064723861672743, 0.20797631444922238, 0.10316066421269954, 0.2018141428462793, 0.19566613070549288, 0.17226927191656127, 0.17911913326270967, 0.16860544661386556, 0.18010557828754603, 0.18246518578078774, 0.18752449611589384, 0.18039086930055892, 0.18068313750436193, 0.1704288185461421, 0.07688400628852798, 0.07104292614518304, 0.07973888588565436, 0.07917341546321766, 0.06622209486761799, 0.0870850665417422, 0.07482817663360308, 0.07465614078219696, 0.08270024442771595]}, "mutation_prompt": null}
{"id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim  # Slightly reduced population size for faster convergence\n        self.F = 0.6  # Adjusted differential weight for enhanced diversity\n        self.CR = 0.9  # Increased crossover probability for more aggressive recombination\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # Adaptive factor fine-tuned for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 15:  # Faster adaptation by checking over a shorter window\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:  # Slightly less strict threshold\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedAdaptiveEvoStrategy", "description": "Enhanced adaptive evolutionary strategy combining differential evolution and guided local search to dynamically balance exploration and exploitation.", "configspace": "", "generation": 29, "fitness": 0.3721270468725248, "feedback": "The algorithm EnhancedAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "40f3e6d0-9585-43e3-89f5-e507f5bb533c", "metadata": {"aucs": [0.778497914161679, 0.7324022304565004, 0.7567072258707073, 0.7712159998920995, 0.7428465822308035, 0.7557846702913494, 0.7686963941750381, 0.7836187499572429, 0.7270064062858207, 0.5721171576149588, 0.575806510222135, 0.5800043579592532, 0.5759277644781569, 0.5610385786171748, 0.5986549299158369, 0.6051981982816916, 0.6171745591644415, 0.6021331995620769, 0.25394571768575225, 0.12517105969417242, 0.11041654632963505, 0.12145449148511567, 0.11183664692103978, 0.13290571642395166, 0.11200947027408581, 0.09513271434820714, 0.11820523934819871, 0.13435624517259837, 0.0953706439357902, 0.09401967533611, 0.11400854225328072, 0.13299658710507323, 0.12732619028963255, 0.15651534304778647, 0.11909608493018153, 0.10972624686775378, 0.9547513050202339, 0.9639632188900564, 0.9280235989064812, 0.9097910919215082, 0.960085257957291, 0.9370856735266859, 0.9692710643951836, 0.9522259556858735, 0.9298606148670139, 0.366310652704363, 0.4264352074260652, 0.38141192503335575, 0.44879356659576386, 0.42940988283040626, 0.4739390434998605, 0.41524019601358997, 0.4357192033625922, 0.40796027714658967, 0.7854603731185335, 0.7513677447511108, 0.7590211885695396, 0.7208131240037852, 0.8154125266457584, 0.7876709447053943, 0.7804177339134799, 0.7494452454340685, 0.775397560416881, 0.4246572466353077, 0.3415620820999893, 0.4978646071372522, 0.12955679896638939, 0.5968564320840758, 0.4563618118880799, 0.35794851221318214, 0.41821336007003507, 0.4155614164899528, 0.3803168193670182, 0.5390575538045069, 0.35794336483665046, 0.40483032177046685, 0.12782098112085405, 0.337019154676533, 0.40818637938735514, 0.3538124307100434, 0.288006295421641, 0.3426227432923997, 0.4570146269601403, 0.38902747880127775, 0.4667319955677349, 0.3186424663191939, 0.33107134674467065, 0.3986687807163286, 0.38066771033901936, 0.43828869877722487, 0.5648170013408155, 0.5557638872111261, 0.5101197744540703, 0.5880177218055065, 0.49487669348571595, 0.5446132469438318, 0.5787822178685926, 0.541603541782004, 0.5250579414594609, 0.12446810280195564, 0.08246068814916452, 0.26766386048766977, 0.2685217921671573, 0.12868592504250154, 0.12021698165908123, 0.09002397933278394, 0.10426227719921011, 0.24101746189737894, 0.3834234915978264, 0.313859757122142, 0.31997656564693955, 0.37611370105248343, 0.27950683894121353, 0.3871087477937074, 0.32801321827061647, 0.3311382136561114, 0.309636052800643, 0.6259012733917415, 0.6821742599662717, 0.655454316089725, 0.6970053066122663, 0.6142481368118397, 0.6494063116209678, 0.6565565830958279, 0.6303217271986292, 0.6441935221236027, 0.10256928103413832, 0.10777689051248796, 0.07848740541838961, 0.12620293783100056, 0.10325802906773884, 0.11453395342792083, 0.12018816262326071, 0.11259430554985117, 0.09236488872701432, 0.24691344268038617, 0.23564319983211157, 0.18583477190079412, 0.28765202576424276, 0.13200591786697402, 0.27077092531657065, 0.19280798012926537, 0.3514154147797476, 0.18971032944449506, 0.3679543908382188, 0.39493606908187495, 0.3493781602347291, 0.4173938222561788, 0.4061498363195827, 0.44289791819074487, 0.44335529931843776, 0.4599677323614384, 0.3963279135189226, 0.3350677322760425, 0.2940401510045434, 0.28411080321502313, 0.3437285360248806, 0.3172580371351118, 0.28094625726693634, 0.3817520068442134, 0.2583485168066839, 0.3572039415603653, 0.20153495846929748, 0.1892538987303194, 0.22418085043105074, 0.18185981676246932, 0.22255658269816936, 0.1975848777452035, 0.20645202400828866, 0.188113183042241, 0.2003079543862707, 0.4858359205234458, 0.18253247618462365, 0.20154208834328102, 0.23903586105792252, 0.21937841350489906, 0.21144142663489285, 0.20286879069622865, 0.21066561016683638, 0.2085051421876245, 0.18268772313434856, 0.14947286517718972, 0.1608589398240423, 0.19516708426054818, 0.16358976221360266, 0.16459384922367548, 0.15776207798001873, 0.7995425196130672, 0.15896493752898821, 0.7621398401304634, 0.20628508590609695, 0.7526641964521045, 0.7548787721085519, 0.10964302647622792, 0.11056173918146228, 0.151990363745104, 0.15282552603935984, 0.21072514167875211, 0.18894907469646127, 0.18461696849587583, 0.17637803095419002, 0.17158867839508218, 0.17067951249256152, 0.19079246402107652, 0.1803291009617597, 0.19187907863323028, 0.1792978593513337, 0.07603048514893507, 0.07600886812534513, 0.06632219538187545, 0.07878866172063059, 0.06291340185423488, 0.07186252679224947, 0.07300138565935177, 0.09365543601201864, 0.08886678035744622]}, "mutation_prompt": null}
{"id": "c9661612-85b0-46a8-97e0-0ceb5eab7876", "solution": "import numpy as np\n\nclass EnhancedAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.F = 0.6\n        self.CR = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        opposition_population = self.bounds[0] + self.bounds[1] - self.population\n        self.population = np.vstack((self.population, opposition_population))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 15:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedAdaptiveEvoStrategy", "description": "Enhanced adaptive evolutionary strategy integrating opposition-based learning and adaptive differential evolution for improved global search efficiency.", "configspace": "", "generation": 30, "fitness": 0.3721270468725248, "feedback": "The algorithm EnhancedAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {"aucs": [0.778497914161679, 0.7324022304565004, 0.7567072258707073, 0.7712159998920995, 0.7428465822308035, 0.7557846702913494, 0.7686963941750381, 0.7836187499572429, 0.7270064062858207, 0.5721171576149588, 0.575806510222135, 0.5800043579592532, 0.5759277644781569, 0.5610385786171748, 0.5986549299158369, 0.6051981982816916, 0.6171745591644415, 0.6021331995620769, 0.25394571768575225, 0.12517105969417242, 0.11041654632963505, 0.12145449148511567, 0.11183664692103978, 0.13290571642395166, 0.11200947027408581, 0.09513271434820714, 0.11820523934819871, 0.13435624517259837, 0.0953706439357902, 0.09401967533611, 0.11400854225328072, 0.13299658710507323, 0.12732619028963255, 0.15651534304778647, 0.11909608493018153, 0.10972624686775378, 0.9547513050202339, 0.9639632188900564, 0.9280235989064812, 0.9097910919215082, 0.960085257957291, 0.9370856735266859, 0.9692710643951836, 0.9522259556858735, 0.9298606148670139, 0.366310652704363, 0.4264352074260652, 0.38141192503335575, 0.44879356659576386, 0.42940988283040626, 0.4739390434998605, 0.41524019601358997, 0.4357192033625922, 0.40796027714658967, 0.7854603731185335, 0.7513677447511108, 0.7590211885695396, 0.7208131240037852, 0.8154125266457584, 0.7876709447053943, 0.7804177339134799, 0.7494452454340685, 0.775397560416881, 0.4246572466353077, 0.3415620820999893, 0.4978646071372522, 0.12955679896638939, 0.5968564320840758, 0.4563618118880799, 0.35794851221318214, 0.41821336007003507, 0.4155614164899528, 0.3803168193670182, 0.5390575538045069, 0.35794336483665046, 0.40483032177046685, 0.12782098112085405, 0.337019154676533, 0.40818637938735514, 0.3538124307100434, 0.288006295421641, 0.3426227432923997, 0.4570146269601403, 0.38902747880127775, 0.4667319955677349, 0.3186424663191939, 0.33107134674467065, 0.3986687807163286, 0.38066771033901936, 0.43828869877722487, 0.5648170013408155, 0.5557638872111261, 0.5101197744540703, 0.5880177218055065, 0.49487669348571595, 0.5446132469438318, 0.5787822178685926, 0.541603541782004, 0.5250579414594609, 0.12446810280195564, 0.08246068814916452, 0.26766386048766977, 0.2685217921671573, 0.12868592504250154, 0.12021698165908123, 0.09002397933278394, 0.10426227719921011, 0.24101746189737894, 0.3834234915978264, 0.313859757122142, 0.31997656564693955, 0.37611370105248343, 0.27950683894121353, 0.3871087477937074, 0.32801321827061647, 0.3311382136561114, 0.309636052800643, 0.6259012733917415, 0.6821742599662717, 0.655454316089725, 0.6970053066122663, 0.6142481368118397, 0.6494063116209678, 0.6565565830958279, 0.6303217271986292, 0.6441935221236027, 0.10256928103413832, 0.10777689051248796, 0.07848740541838961, 0.12620293783100056, 0.10325802906773884, 0.11453395342792083, 0.12018816262326071, 0.11259430554985117, 0.09236488872701432, 0.24691344268038617, 0.23564319983211157, 0.18583477190079412, 0.28765202576424276, 0.13200591786697402, 0.27077092531657065, 0.19280798012926537, 0.3514154147797476, 0.18971032944449506, 0.3679543908382188, 0.39493606908187495, 0.3493781602347291, 0.4173938222561788, 0.4061498363195827, 0.44289791819074487, 0.44335529931843776, 0.4599677323614384, 0.3963279135189226, 0.3350677322760425, 0.2940401510045434, 0.28411080321502313, 0.3437285360248806, 0.3172580371351118, 0.28094625726693634, 0.3817520068442134, 0.2583485168066839, 0.3572039415603653, 0.20153495846929748, 0.1892538987303194, 0.22418085043105074, 0.18185981676246932, 0.22255658269816936, 0.1975848777452035, 0.20645202400828866, 0.188113183042241, 0.2003079543862707, 0.4858359205234458, 0.18253247618462365, 0.20154208834328102, 0.23903586105792252, 0.21937841350489906, 0.21144142663489285, 0.20286879069622865, 0.21066561016683638, 0.2085051421876245, 0.18268772313434856, 0.14947286517718972, 0.1608589398240423, 0.19516708426054818, 0.16358976221360266, 0.16459384922367548, 0.15776207798001873, 0.7995425196130672, 0.15896493752898821, 0.7621398401304634, 0.20628508590609695, 0.7526641964521045, 0.7548787721085519, 0.10964302647622792, 0.11056173918146228, 0.151990363745104, 0.15282552603935984, 0.21072514167875211, 0.18894907469646127, 0.18461696849587583, 0.17637803095419002, 0.17158867839508218, 0.17067951249256152, 0.19079246402107652, 0.1803291009617597, 0.19187907863323028, 0.1792978593513337, 0.07603048514893507, 0.07600886812534513, 0.06632219538187545, 0.07878866172063059, 0.06291340185423488, 0.07186252679224947, 0.07300138565935177, 0.09365543601201864, 0.08886678035744622]}, "mutation_prompt": null}
{"id": "66c4c35a-616d-4c96-9435-dc97772ae982", "solution": "import numpy as np\n\nclass AdvancedStochasticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim  # Slightly increased population size for robustness\n        self.F = 0.5  # Balanced differential weight for diversity and convergence\n        self.CR = 0.8  # Moderated crossover probability to ensure diversity\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.8  # Adaptive factor for timely adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:  # Faster adaptation by checking over a shorter window\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-4:  # Slightly more relaxed threshold\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.8)\n                    self.CR = np.clip(self.CR, 0.6, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.5 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdvancedStochasticOptimizer", "description": "Advanced stochastic optimization integrating adaptive differential evolution with random walks and fine-tuned crossover to enhance convergence.", "configspace": "", "generation": 31, "fitness": 0.34361027089656165, "feedback": "The algorithm AdvancedStochasticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {"aucs": [0.7749510087334459, 0.7788641263522019, 0.7485415523276227, 0.7632392146555133, 0.7397940336823263, 0.7745645385828821, 0.7890507597676644, 0.793944470218493, 0.7588563731039718, 0.5602153433188155, 0.5764282569617236, 0.59068603551134, 0.5320854292762263, 0.594945703065505, 0.5902745951467024, 0.5568609703522551, 0.571068964445999, 0.5768577607578289, 0.12760006332461493, 0.11598358582385859, 0.22119755675868824, 0.14462997927097954, 0.14602143838577886, 0.15242647306797752, 0.12032416360791065, 0.14069578462984178, 0.1495639634465602, 0.07849387301070732, 0.1102370847132148, 0.13581040318063842, 0.098953612989222, 0.10387972747947116, 0.11094391108735979, 0.0897563846935796, 0.1335857704005643, 0.09044467548344359, 0.9736877865550282, 0.923958289850263, 0.9735020116071148, 0.9691234650097373, 0.9634025312360445, 0.9605536349093355, 0.9476115926443893, 0.9148078447563054, 0.9418125577601769, 0.38533528510930815, 0.3932789465073637, 0.3988088829256389, 0.41840505592895705, 0.36291655166701287, 0.42220357061262614, 0.4241753763480971, 0.44196080984467834, 0.37575635656573636, 0.6930895798651959, 0.7057833289098054, 0.7925792375357295, 0.22238242677966724, 0.7118818704523078, 0.7855048257593225, 0.6572334963422471, 0.6742891413184504, 0.8034582110358715, 0.3308878570120197, 0.22833256473200558, 0.27693744500847606, 0.24875693011165378, 0.12563771972020954, 0.21104495802564138, 0.40095809233030166, 0.3002270498196242, 0.2598420507393391, 0.38006423262105815, 0.47330427440612155, 0.11952616022620388, 0.26912459076246464, 0.29051045963705613, 0.13059275387479297, 0.4942232834014175, 0.2361016062768193, 0.3428696461886507, 0.1354728185091988, 0.30026195546700796, 0.2395191784405225, 0.2549801372389786, 0.3113386548925864, 0.3005536130721004, 0.27555133915358565, 0.10144858302220405, 0.33408081859088856, 0.36684886335930134, 0.39122990618375175, 0.4619343214780395, 0.3816178783081198, 0.4581706696797565, 0.38584167559667526, 0.4310012550708785, 0.44971776061028657, 0.38199801438978664, 0.061687819082178796, 0.05364656569348858, 0.10491963490085454, 0.14572333283088623, 0.1769563741754966, 0.08337425503053442, 0.0954775603722533, 0.19271826290792882, 0.08734167205973098, 0.2592769244250651, 0.2956269509330174, 0.24541341406137174, 0.2504254511689321, 0.27620494971397236, 0.27935707045825753, 0.25265783276094744, 0.2761573328523921, 0.21437463150432345, 0.5710925354141421, 0.6206800972602393, 0.6110089990522352, 0.5877427768930477, 0.5508093743511397, 0.5527710061625628, 0.5590799328035503, 0.56138030289577, 0.629964888629686, 0.09421466754422747, 0.12593749724817793, 0.09883930437210742, 0.09298390054088634, 0.12819399447247337, 0.12556572057149729, 0.10727060519455955, 0.1104917096416812, 0.132955942950976, 0.14088308718999598, 0.16949664652646512, 0.18006962972118057, 0.14497609507897746, 0.1654845333960866, 0.15628391386709373, 0.19918884196019826, 0.22346710107567147, 0.5332829797038077, 0.2978169147152021, 0.41830014691402917, 0.4027466404125939, 0.43396796671741655, 0.31325297561931886, 0.410661101462381, 0.44015862018062857, 0.43821402714591273, 0.4480834986060668, 0.25490358911923383, 0.2565327356754735, 0.334683893509068, 0.3199201853171413, 0.3005500720336268, 0.19080866646536665, 0.2538209121761944, 0.35153971138005236, 0.2444625256585572, 0.20279778052932262, 0.20285363405440526, 0.20447188834964414, 0.21725811032859432, 0.17694716633987606, 0.19154491864484013, 0.20494973807446548, 0.1932738809906971, 0.19381376192737443, 0.2123108851073502, 0.21566441885394516, 0.21289723491798063, 0.19980525994900022, 0.18673977732509728, 0.1879036850116288, 0.5998345321310858, 0.1953852879035105, 0.22350464423865546, 0.1745481375608744, 0.1622325764442678, 0.14243435208289734, 0.7923182587010449, 0.16605725740992727, 0.8094353035108368, 0.16788243799524205, 0.1797105373668011, 0.7770589317782093, 0.6902954313736592, 0.1533467449649044, 0.20383256093969748, 0.7272472784716286, 0.14997681957552234, 0.16572977884982998, 0.20761565277635552, 0.15147309176076074, 0.7100119895644507, 0.1826265881250726, 0.18270128442863864, 0.16784125429400942, 0.17825628767923407, 0.1686081257680646, 0.17125423163892117, 0.1970509777910605, 0.2006646528706243, 0.17526425892634911, 0.08124966181700655, 0.07000108575423258, 0.08411649434846635, 0.09087094726652944, 0.08650109379229087, 0.08828793511602329, 0.07837332359443405, 0.08716976403463284, 0.08014712464014084]}, "mutation_prompt": null}
{"id": "c122ff64-cfac-4ae1-bc62-9e011b9a17e2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Adjusted population size for improved efficiency\n        self.F = 0.7  # Slightly increased differential weight for more robust exploration\n        self.CR = 0.85  # Adjusted crossover probability for balanced recombination\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Slightly higher adaptive factor for dynamic adjustment\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def local_search(self, solution):\n        perturbed = solution + np.random.normal(0, 0.05, self.dim)\n        return np.clip(perturbed, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n                if np.random.rand() < 0.15:  # Introducing probabilistic local search\n                    local_trial = self.local_search(trial)\n                    local_fitness = func(local_trial)\n                    func_calls += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_trial\n                        if local_fitness < self.best_fitness:\n                            self.best_fitness = local_fitness\n                            self.best_solution = local_trial.copy()\n                            \n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 15:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedAdaptiveEvoStrategy", "description": "Enhanced adaptive evolutionary strategy with probabilistic local search and dynamic mutation to boost convergence in diverse optimization scenarios.", "configspace": "", "generation": 32, "fitness": 0.32630271024330787, "feedback": "The algorithm EnhancedAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {"aucs": [0.690953674496062, 0.668630157628183, 0.719452210044653, 0.6862711222263027, 0.7156340130543585, 0.7480112908170853, 0.7717295887505189, 0.705338546667833, 0.7154981219843324, 0.4741261961477192, 0.511919458585869, 0.5118148396156477, 0.5273538356905316, 0.5071396460311158, 0.56066677579792, 0.5435970331659329, 0.4892230579401752, 0.5194379771754594, 0.11179284272957357, 0.10479532649081125, 0.115402369523663, 0.21271470955885718, 0.11217087827093253, 0.06609961177554213, 0.10076677383909505, 0.14363228354630175, 0.13334192131081113, 0.11957008526283353, 0.12748582367322558, 0.09763136182926424, 0.10573842203098627, 0.12384565859504926, 0.1079977148644421, 0.10535381256021159, 0.08593036541087806, 0.09131209579022348, 0.9631488074254828, 0.9529975587381004, 0.9593213820288545, 0.958484069087406, 0.9520592390727416, 0.9565707802952289, 0.9776845853598208, 0.9669450867168166, 0.9671929911098867, 0.34709626777169866, 0.3340439521455757, 0.3420709932720779, 0.3227403248840708, 0.3282480014452138, 0.29853126209725056, 0.3409834813215683, 0.3014774137089419, 0.35867510674107084, 0.6692159833542631, 0.7446868383160538, 0.6731975622140423, 0.7175848504849721, 0.6325819132636332, 0.715842238325598, 0.699512115318708, 0.7021562368615032, 0.750109953222993, 0.28278132212373563, 0.26040704762614575, 0.2723949853255694, 0.45784224178717237, 0.35764205278574024, 0.31640998239070206, 0.44637371329596875, 0.2795373056033832, 0.23734257424316862, 0.25188169140050454, 0.24821131173688504, 0.32743057921184704, 0.30797004710931175, 0.3408556426569036, 0.34866733095737623, 0.2593063956947145, 0.11748543393233835, 0.3196312432215155, 0.2150293378617586, 0.06927433640329561, 0.2539667748968003, 0.21622645276124852, 0.048972473052554366, 0.16144254529761515, 0.1843530511874617, 0.20937837981397833, 0.23237147698926996, 0.31644503075025954, 0.224388127508532, 0.29692510812644324, 0.23885455997026162, 0.3632544899122401, 0.3152447439975724, 0.305177773729571, 0.37505160348675814, 0.3632814985186644, 0.12873874550381592, 0.04100463536391019, 0.09691123980553562, 0.17904526009281163, 0.09599274933823287, 0.07630911655709371, 0.05207975896560124, 0.09373014851281747, 0.08380143902874881, 0.2521589192084098, 0.17736326130053226, 0.22174682203431484, 0.2249617043130866, 0.21464502339406455, 0.21602483676769957, 0.17851667682628525, 0.25141679661617033, 0.21783810005939364, 0.5354105751668097, 0.542921631745775, 0.5780910043114106, 0.5498342344841083, 0.5313169350723629, 0.563760122403735, 0.5782457456680709, 0.5845423054741296, 0.5596000930849772, 0.11188076247926981, 0.10115800779506734, 0.12911600966450532, 0.10654651200632959, 0.10255513102073077, 0.10336635674716033, 0.08436804256906782, 0.0953975290054645, 0.37931085395489406, 0.3338781479202537, 0.18698895037397467, 0.2081171191582354, 0.22577436029148346, 0.38726630727401534, 0.12655702592544804, 0.21222730528811806, 0.13891322768626613, 0.21830696191352716, 0.33822588611289917, 0.3598374999200221, 0.31387029511498354, 0.38625907426315365, 0.33720834395353383, 0.3462330581847327, 0.34563223268372667, 0.3374621555601953, 0.3654090173603326, 0.2642068408599004, 0.19335578897842087, 0.23978166278667845, 0.19311044763299146, 0.25707848042584347, 0.29757170475297123, 0.30263815619617696, 0.3203552669742953, 0.31035986994871056, 0.1858697434006884, 0.1887452570256969, 0.2094747761270489, 0.21241572830513256, 0.20449321576664914, 0.17773102916944394, 0.18009100561228608, 0.1940247154183553, 0.1761606038211837, 0.19060637898419175, 0.19564558232059348, 0.22338024374618526, 0.23043554681166156, 0.2024911123070201, 0.2015518159773776, 0.19576502221912817, 0.2086665200953196, 0.20519326893986767, 0.1641688349943452, 0.20758821692279106, 0.16467078933759782, 0.7417733266920632, 0.18942824648749257, 0.7337090711455786, 0.7317006592567405, 0.1695342673121606, 0.20368487116417555, 0.6711973057407403, 0.5877683991685623, 0.5744900944104547, 0.20476497052339482, 0.6825971543144282, 0.627467085331967, 0.147616377105951, 0.14963938099246354, 0.10377896730204461, 0.17397999794075714, 0.1762827683147865, 0.1720417183210895, 0.2244827074494875, 0.1961082118867441, 0.17525968164396277, 0.18376327576784035, 0.20065450959948872, 0.17749552487238962, 0.0674750716091721, 0.08383963360784641, 0.07585181165168109, 0.0832500623589727, 0.08614122597963092, 0.07453796005312885, 0.05953225603688839, 0.085350117297324, 0.07333975719600816]}, "mutation_prompt": null}
{"id": "a5ec4ebd-abd1-48cc-903a-5c1fb5d5275c", "solution": "import numpy as np\n\nclass RefinedAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim  # Adjusted population size for improved diversity\n        self.F = 0.8  # Increased differential weight for enhanced exploration\n        self.CR = 0.85  # Slightly reduced crossover probability for balanced recombination\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Fine-tuned adaptive factor for balanced control\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:  # Shorter window for quicker adaptation\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-4:  # Relaxed threshold for adjustments\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 1.0)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.03 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "RefinedAdaptiveEvoStrategy", "description": "Refined adaptive evolutionary strategy with enhanced mutation strategies and dynamic population adjustments to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.24473252726682546, "feedback": "The algorithm RefinedAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {"aucs": [0.5122863122061041, 0.5396724880208693, 0.5216565496767402, 0.5774944741324105, 0.5584070613972114, 0.5593092872217624, 0.5944085915029006, 0.48879637925471864, 0.5615816321349251, 0.2448512057010347, 0.23235441169377435, 0.24318158496557163, 0.23502296619400243, 0.21279691001968337, 0.217863169145614, 0.3047536942027673, 0.21057377755403128, 0.21954164580192215, 0.12310858763295596, 0.1555689151488483, 0.32681395133127655, 0.11985370531394979, 0.11163900062134147, 0.13994273231503052, 0.1012065330554589, 0.1111453410936829, 0.12028319501298501, 0.09224805971174443, 0.08141365155656566, 0.08919200981244724, 0.1122943995487038, 0.10238709091204945, 0.10212516168624786, 0.11678414918872382, 0.12232887595251418, 0.13196043461614826, 0.9632856797571221, 0.9357726064016957, 0.9440412214324686, 0.9701015636371714, 0.9356570446199086, 0.9555277832741497, 0.9444843001765739, 0.9674229781595566, 0.9342749770940222, 0.2611721303723119, 0.2084095382421065, 0.21626706673945106, 0.23276592813473118, 0.1980079076426723, 0.22099744547788636, 0.23225601903544224, 0.21988624887710084, 0.21668952757961657, 0.4822655450615142, 0.40388955865127707, 0.468519094321068, 0.3548312007584479, 0.49794310104888695, 0.5388331631479906, 0.4110855890987305, 0.3647253017997164, 0.5266303572488797, 0.14552604336796615, 0.15941545403214075, 0.15582446401681593, 0.18582578026123497, 0.1257695313051942, 0.10102364051999557, 0.20489398537699777, 0.1547759335222556, 0.19316071514426536, 0.11685616504481933, 0.1815195229194374, 0.14888052617925185, 0.17388750349075022, 0.15362974035063925, 0.14645164531125465, 0.09022221426150934, 0.159998026202815, 0.1866131186565435, 0.08960853283943782, 0.06468196361966672, 0.046088022764652514, 0.055994169198528065, 0.012664083522351599, 0.011324856935417515, 0.09722051963236922, 0.027816739411424374, 0.10515955362612239, 0.24782096271379828, 0.17930127659207595, 0.20067352491529666, 0.20288984711609703, 0.16566210877306475, 0.18889600026616604, 0.1983755737318792, 0.2633513626449795, 0.2341989163671242, 0.015944787314547293, 0.010759267694922192, 0.029926807712993275, 0.02538446918718762, 0.029589121440641297, 0.018120844100994016, 0.024664215727054795, 0.01136625533696256, 0.03906767275852763, 0.09556916413745076, 0.10703517655649009, 0.13501308952782642, 0.1253809279367013, 0.11667872462666151, 0.12184485462270844, 0.1065379453483305, 0.11203075572111265, 0.11491132753880484, 0.3983163715247465, 0.4043836131890748, 0.42220569798422847, 0.4674516823654893, 0.457050089183077, 0.4265192736801028, 0.4204145321674846, 0.39673765323971044, 0.4418925837380274, 0.08508423489494255, 0.07888465164448077, 0.0861984529507912, 0.08579912880055307, 0.0843419287667524, 0.09113676785798874, 0.06878717627295594, 0.08494736737048425, 0.09526696529120893, 0.1265770001378258, 0.2334398122970588, 0.22109559266184287, 0.14023905512619916, 0.19126790771910196, 0.17301112888098247, 0.1743104369802313, 0.14863439008375756, 0.12787572694304494, 0.25137926212721984, 0.24770111440665166, 0.2525974341890842, 0.2525341949370198, 0.2402850260243372, 0.2536957647434256, 0.29543034305439675, 0.2730715319164104, 0.2843931228709432, 0.19740818912229974, 0.2093190808187274, 0.1952579634790671, 0.17980251733256047, 0.2108829388624467, 0.18621302108491378, 0.19223965078049843, 0.2268055510633401, 0.23024204597007014, 0.1688461183140294, 0.1884927024608518, 0.17445972998964787, 0.16636231217773734, 0.19836704132882665, 0.18792919809086084, 0.17885096823188706, 0.19578521547119898, 0.21295000466709757, 0.18689524118198408, 0.1759879368057733, 0.21528776155907425, 0.1873923335041795, 0.20076289513549606, 0.1894831330083624, 0.19769240358388862, 0.18841089874316397, 0.18671436419941512, 0.5036794676167506, 0.17104427367876762, 0.745579783293844, 0.5455108011685292, 0.18365426449483357, 0.4381013795533193, 0.589946923369595, 0.11980889312176735, 0.16205704329717174, 0.1632614647570404, 0.19531190248716956, 0.5650456236868853, 0.5532094866562911, 0.14851193364689752, 0.5381050527131994, 0.19995648836390123, 0.19178792563148472, 0.5365254514590263, 0.16808128364298702, 0.18057782695329683, 0.1845271251122319, 0.17006678067083647, 0.19296764978772885, 0.17379419189532275, 0.1931334210869311, 0.17583008933189337, 0.17850719808024007, 0.06837631493516505, 0.07069649196278038, 0.08040102332120547, 0.08334598170737173, 0.07183459345313714, 0.06917355084150367, 0.06914561606006542, 0.08266340871193711, 0.06978870504267942]}, "mutation_prompt": null}
{"id": "cecf3a34-bc19-41d6-b3a6-4d0bf271b1bd", "solution": "import numpy as np\n\nclass AdvancedEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim  # Increased population size for diversity\n        self.F = 0.7  # Differential weight for balancing exploration and exploitation\n        self.CR = 0.85  # Crossover probability for strategic recombination\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand-to-best'\n        self.adaptive_factor = 0.95  # Adaptive factor for fine-tuning\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'rand-to-best':\n            return self.population[a] + self.F * (self.best_solution - self.population[a]) + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:  # Faster adaptation over a shorter window\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  # Strict threshold for adaptation\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand-to-best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdvancedEvoStrategy", "description": "Advanced EvoStrategy integrating adaptive differential evolution with strategic random walks for enhanced convergence and robustness.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {}, "mutation_prompt": null}
{"id": "2c333100-3881-4b67-b1f7-bebf6dfe252b", "solution": "import numpy as np\n\nclass AdvancedAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.F = 0.6\n        self.CR = 0.8  # Adjusted crossover probability for a balanced exploration-exploitation trade-off\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Slightly altered adaptive factor for stability\n        self.random_walk_factor = 0.05  # New factor to control the random walk intensity\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:  # Adjusted adaptation window\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  # Tighter threshold for adaptation\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.8)\n                    self.CR = np.clip(self.CR, 0.6, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.5 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + self.random_walk_factor * np.random.normal(0, 0.1, self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdvancedAdaptiveEvoStrategy", "description": "Advanced evolutionary strategy integrating adaptive differential evolution and dynamic random walks for enhanced optimization stability.", "configspace": "", "generation": 35, "fitness": 0.33045005464394756, "feedback": "The algorithm AdvancedAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {"aucs": [0.7340629673512521, 0.7331144765139266, 0.7576243911803627, 0.7730705907900219, 0.7634541964285956, 0.7620488966586136, 0.7588760115724071, 0.7725646146291811, 0.7703176770929259, 0.5465707170755034, 0.5915183856715313, 0.539476277848882, 0.5643285445379949, 0.5828800736982657, 0.5265608127871177, 0.5548641919630937, 0.01690520605895285, 0.5884940741715221, 0.13414715134269317, 0.31910848675385417, 0.14532267569679502, 0.15213035114785012, 0.3120021873221035, 0.13005116446091702, 0.16652058556957838, 0.13250353945586957, 0.33945081827426116, 0.1282631382764421, 0.12519114058734648, 0.12046374956233563, 0.08971431171120225, 0.1167962242502143, 0.10028682836441183, 0.1289189405500316, 0.12063345249881097, 0.12218156175794315, 0.9683500932971912, 0.941024805080797, 0.9626942659364773, 0.9637643759874562, 0.9429073081699639, 0.9537907038936201, 0.9769924942978727, 0.9536643557951362, 0.9550618803627952, 0.3860207533303114, 0.32666270415010845, 0.3330372361457755, 0.3698612111344419, 0.38684946857436786, 0.3791426579490923, 0.3856186930720753, 0.39591820446673354, 0.3518348960814063, 0.7356995973837313, 0.7224926669384655, 0.6698461283228734, 0.7555731135739079, 0.7147020338453163, 0.7917852755648827, 0.6955209924083963, 0.777048243848506, 0.7128666242715349, 0.27333339561750525, 0.11862384766942635, 0.12481904617130546, 0.1775719605356295, 0.2626513461164496, 0.258807583185086, 0.20970863191710254, 0.3066946436584007, 0.1985352545896064, 0.32637201042294806, 0.2639354703160087, 0.2557368436959486, 0.12694235596227554, 0.30027512883584984, 0.20742010316125847, 0.32339807127149867, 0.22115742929867133, 0.26443608572065225, 0.2444021807993113, 0.21596789982527886, 0.23122449060882067, 0.07256528953019281, 0.20943139464690563, 0.17335683631927945, 0.2127712104845173, 0.25857997975446, 0.2542066440739186, 0.318081678313921, 0.34581212838669995, 0.3702852315240771, 0.45454920508533536, 0.37261403886979283, 0.4663756386688259, 0.4590167657921227, 0.37001828153936533, 0.3842446464298681, 0.09466262188120167, 0.06067183490939809, 0.03129601869938703, 0.19153626970106952, 0.14739688031358977, 0.09172600624158933, 0.08365204705894502, 0.09988856983170658, 0.07224237623061058, 0.24459008090356282, 0.2558916235821478, 0.21251805528268775, 0.26106386829452544, 0.26643862278383024, 0.2738309851427735, 0.19254230077904577, 0.27519814634652373, 0.1977928411504828, 0.5676161006002362, 0.6230014915825349, 0.6488947579878044, 0.630693202935199, 0.5973387795110776, 0.586491639760742, 0.6134919408053097, 0.5904674528163534, 0.6199520783132502, 0.11006305848782971, 0.08898120863251602, 0.0904481480992938, 0.12991078775158205, 0.12423469698221978, 0.09797196555616594, 0.14458343630200254, 0.07661828681396654, 0.12025607723202991, 0.2583552009882084, 0.13655707523456917, 0.16967073873309169, 0.1832157895678449, 0.2107712897031131, 0.18568191251682598, 0.19223757989593238, 0.14218642037378215, 0.14281782275465504, 0.37330413700635545, 0.38882108076103106, 0.3976662442190253, 0.4213924468146716, 0.4172828037548345, 0.39666528702941073, 0.45265945610522995, 0.379437739071231, 0.3939032757189047, 0.24827968131225409, 0.27288986143818583, 0.3240197393469493, 0.28512770552025724, 0.1855941489089663, 0.3023320511015063, 0.2542482859018025, 0.17016706484101907, 0.2561028569850946, 0.20052340665985613, 0.1850400740013659, 0.18353050695645912, 0.19212068524343395, 0.1827903228197716, 0.19698438397934948, 0.22165184133786064, 0.1844727435333703, 0.17038486511443462, 0.18276800949267114, 0.47972731729865237, 0.5395808633728851, 0.21505878405783552, 0.21976815153367601, 0.207166357347512, 0.2044791801481476, 0.22277752557158115, 0.2322415071759636, 0.1651741400800072, 0.19188223246862524, 0.17634754952482667, 0.19190280572980056, 0.77261342876821, 0.16248788532573466, 0.1497495330580516, 0.15323452839666463, 0.16204959184081313, 0.7429790615907432, 0.20339346087098742, 0.15075795921046242, 0.72574251859612, 0.12438454226376128, 0.2004959037388111, 0.7358785847675394, 0.15185750510264295, 0.2117434372106589, 0.18073999324728285, 0.19369246008179675, 0.1759381881752703, 0.18619681275826472, 0.1787626558350578, 0.1762379717260052, 0.1935042677418295, 0.17975439814501237, 0.18455915018693647, 0.06632256195015729, 0.07794015356148809, 0.08979987310963822, 0.07720389662085514, 0.07892130746119541, 0.07519032797615488, 0.09487479342913963, 0.08145323412854544, 0.07396466156646453]}, "mutation_prompt": null}
{"id": "d7d97fe0-23c7-4e60-b338-5796d1f5e955", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim  # Increased population size for diverse exploration\n        self.F = 0.7  # Increased differential weight for more aggressive mutation\n        self.CR = 0.8  # Reduced crossover probability for more selective recombination\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Adaptive factor fine-tuned for dynamic adjustments\n        self.random_perturbation_strength = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:  # Faster adaptation by checking over a shorter window\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  # Slightly less strict threshold\n                    self.F *= self.adaptive_factor\n                    self.random_perturbation_strength *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.85 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    perturbation = np.random.normal(0, self.random_perturbation_strength, self.dim)\n                    random_walk_solution = self.population[i] + perturbation\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "A hybrid evolutionary strategy integrating differential evolution with adaptive random perturbations to enhance convergence speed and solution quality.", "configspace": "", "generation": 36, "fitness": 0.2763919611977874, "feedback": "The algorithm HybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {"aucs": [0.566808098489584, 0.639837231758052, 0.5921757983510783, 0.620338208609527, 0.6303219847487933, 0.6590883559179157, 0.635036703375211, 0.6509816625375797, 0.6531975206747284, 0.32878383117511867, 0.34718793140150206, 0.355989347367603, 0.350874514309098, 0.3134726552520055, 0.3315932532694664, 0.36979543372520307, 0.3478975893225883, 0.34707803448493346, 0.25736363937847107, 0.11583979188859284, 0.16209953008190836, 0.11102976749427074, 0.09726638347238514, 0.13915026794292007, 0.10684250447294741, 0.10523525009450241, 0.1182359777267129, 0.10844639561596126, 0.11007822238725218, 0.09217615908781174, 0.09942717488452812, 0.12046798150775595, 0.10734046075216541, 0.10895337535747962, 0.08767161773028564, 0.11240974500904, 0.9503447845708506, 0.937657061661175, 0.9290814917337344, 0.9691154079818711, 0.9331723453711489, 0.9302826525404716, 0.9685034199036885, 0.9680586252215696, 0.9548949972754791, 0.218267594611545, 0.2602210713269437, 0.2560899857897605, 0.23388912384263594, 0.2858863360002005, 0.28135137057833015, 0.24827159511318597, 0.2718506126719159, 0.2674845243036754, 0.5368091146186554, 0.5380370074197682, 0.6797120449090616, 0.4986265635704976, 0.2993351743898398, 0.5886696361348538, 0.5128473023197304, 0.5872298882893114, 0.5455417317868343, 0.1583915505987028, 0.2950007305749721, 0.22920497373807502, 0.10436794844700048, 0.2488121722767933, 0.2599547964823774, 0.22013728113847197, 0.18940605845479142, 0.20869533547082186, 0.009881157529037066, 0.1758971724461622, 0.09951219606997763, 0.18275130030685127, 0.28810789743113974, 0.17527035967512694, 0.16802582226783302, 0.20791023815348886, 0.23594068921475175, 0.06819489581596794, 0.10049094821798554, 0.1724400187361489, 0.19487198029606878, 0.10387676875593954, 0.13734295264900176, 0.05543304090296097, 0.11579855643689352, 0.1954520067030907, 0.21850033504360566, 0.23488123719495546, 0.24555596698328386, 0.19544716468702494, 0.2285142475090245, 0.22258979506256615, 0.31214111953953616, 0.25360891796150586, 0.22408529181752013, 0.025822639047856644, 0.043297900600690054, 0.03262008223094437, 0.031035916380602657, 0.04601995344448606, 0.06450616571126244, 0.06146609546859694, 0.06031203033826893, 0.03388618074587413, 0.1494797097850351, 0.13099623900903112, 0.15193081101152717, 0.1367562913857031, 0.1432199602690445, 0.15189521490878088, 0.051486225339144265, 0.1458876399300676, 0.19793767146463226, 0.4688772521753667, 0.44998525825284774, 0.5178406325587258, 0.4785214741296313, 0.4507490853052133, 0.4324652702422983, 0.45811562651871973, 0.4679825470418969, 0.4722920477752326, 0.07470152430664734, 0.10231092819924159, 0.08878765183219983, 0.1211195461980531, 0.09894324190859338, 0.08307389484767191, 0.08438073135196811, 0.1065509026569682, 0.10178534135506001, 0.4112485831564129, 0.12595223483355678, 0.14624951539335818, 0.44309797319734767, 0.16166879085960606, 0.16928660361580372, 0.257920413460044, 0.297863681485836, 0.1123310595119783, 0.29106266046431806, 0.33045764909823405, 0.3126637876244821, 0.2849837186218086, 0.2675143748981331, 0.27051401840393086, 0.29501348617285306, 0.3412019401717046, 0.3250012491852724, 0.20304838035988226, 0.31536959706985457, 0.22374588091543435, 0.2135769597506898, 0.21665490032716028, 0.25486168817998067, 0.23205215059888007, 0.2499225878017125, 0.23537776939711852, 0.19892850552081653, 0.1766258873119525, 0.18460349261661435, 0.19373119775611758, 0.194518444992422, 0.1687765777504201, 0.20864163933861446, 0.2014235159081893, 0.20363997775811626, 0.22508950246193682, 0.39651496408170284, 0.1826586003782249, 0.2598361471883329, 0.3730370578141651, 0.17864179949082648, 0.21401112927822863, 0.1840411472924377, 0.18415590097631163, 0.16887937134944897, 0.17833128608025905, 0.6270523454245895, 0.6358682326619935, 0.5589264597039862, 0.15907059829764147, 0.5903595660021835, 0.4243702708603734, 0.6366466069519372, 0.19486932189965633, 0.2027363458984056, 0.19860117788291587, 0.1952114411339828, 0.18873732183574743, 0.19069028664890042, 0.6075559264985451, 0.5742053759111898, 0.12374115349762504, 0.18620520644576077, 0.17869139113949573, 0.18135266055347843, 0.18761364320471186, 0.16803317867114442, 0.17401438098680588, 0.18367364749635728, 0.20831051391996602, 0.1931771695932616, 0.06878596575445939, 0.08100939388476158, 0.05626446331128376, 0.08091022795797398, 0.0820777567307166, 0.08691766166556592, 0.06641450773791713, 0.06717350202020989, 0.071411644728952]}, "mutation_prompt": null}
{"id": "f9d54804-3066-47f7-98ab-9e521d77700c", "solution": "import numpy as np\n\nclass AdvancedChaoticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim  # Slightly increased population size for better diversity\n        self.F = 0.8  # Adjusted differential weight for improved convergence\n        self.CR = 0.85  # Crossover probability fine-tuned for balance\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'best'\n        self.adaptive_factor = 0.85  # Adaptive factor for fine-tuned adjustments\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.budget, dim)\n\n    def generate_chaotic_sequence(self, length, dim):\n        # Generate a chaotic sequence for enhancing diversity\n        sequence = np.zeros((length, dim))\n        sequence[0] = np.random.rand(dim)\n        for i in range(1, length):\n            sequence[i] = 4 * sequence[i - 1] * (1 - sequence[i - 1])\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        chaos = self.chaotic_sequence[idx % self.budget]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c]) + chaos\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c]) + chaos\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand'\n            else:\n                self.mutation_strategy = 'best'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdvancedChaoticEvoStrategy", "description": "Advanced adaptive evolutionary strategy utilizing chaotic sequences and self-organizing maps to enhance exploration and convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {}, "mutation_prompt": null}
{"id": "483c37fe-bdf7-4e33-9df1-fdf98193aa9d", "solution": "import numpy as np\n\nclass MomentumEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim  # Adjusted population size for enhanced diversity\n        self.F = 0.7  # Fine-tuned differential weight for balance\n        self.CR = 0.85  # Reduced crossover probability for controlled recombination\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.92  # Adaptive factor for refined dynamic adjustments\n        self.momentum = 0.3  # Momentum factor for mutation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        base = self.best_solution if self.mutation_strategy == 'best' else self.population[a]\n        mutation_vector = self.momentum * (self.population[b] - self.population[c])\n        return base + self.F * mutation_vector\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:  # Shorter historical window for rapid adaptation\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  # More sensitive threshold\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.8)\n                    self.CR = np.clip(self.CR, 0.6, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "MomentumEvoStrategy", "description": "Adaptive evolutionary strategy with momentum-inspired mutation and stochastic relaxation for improved exploration and convergence.", "configspace": "", "generation": 38, "fitness": 0.27648001083386936, "feedback": "The algorithm MomentumEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {"aucs": [0.8867966152067458, 0.8528626600010419, 0.8039016408979028, 0.8996476629134632, 0.8683372823535779, 0.887319035258416, 0.8890981448348436, 0.8383887783352213, 0.8721257304434664, 0.10363961091516627, 0.29357675144260487, 0.7938365118460116, 0.6898153561178224, 0.3375791091023177, 0.4764962525279621, 0.6795146664278138, 0.1135657118183524, 0.7780187399808687, 0.10059545421810812, 0.11844434994557962, 0.10577924783113701, 0.4105169019354189, 0.12163575076769617, 0.13571021006757933, 0.11025654855287359, 0.10731112659720088, 0.11449896410800431, 0.11969040160071909, 0.16993592399625346, 0.09923512498095188, 0.1272223805545376, 0.11126355684707867, 0.07484350069764645, 0.1084020751162097, 0.06280724517818093, 0.17521498495545074, 0.9221705720575626, 0.9347495593771369, 0.9421469566846049, 0.9364719411992763, 0.9253948669237497, 0.9114814777656426, 0.4716052030169203, 0.9066932443340024, 0.8816425188209979, 0.6762127252036406, 0.6135904898720466, 0.6595180983655953, 0.3910998632089683, 0.3031490817162211, 0.16560477967339848, 0.4173271802738666, 0.22990676811177901, 0.5945768465357819, 0.2220513077920726, 0.20737747965835907, 0.16820014892352797, 0.21198151518450703, 0.3438334977213593, 0.331951260900912, 0.2225578231458657, 0.22930643793114647, 0.2313157561494782, 0.0855576102819654, 0.11565376576462294, 0.12921929260070775, 0.1997652465466977, 0.15193978121790497, 0.2124250309224751, 0.14407569274061138, 0.28049319356626057, 0.13207513098478252, 0.13209866732468145, 0.13966590132141188, 0.19800156755633858, 0.1366799781069854, 0.12183046538098408, 0.185461287305002, 0.13220837458788248, 0.12502180919744077, 0.18953398550898337, 0.07186058748066904, 9.999999999998899e-05, 9.999999999998899e-05, 0.22752042610190015, 0.0724472690464818, 9.999999999998899e-05, 0.0023344057891278025, 0.13751685260648938, 0.11401591685241219, 0.17840800821529046, 0.1693122733249709, 0.20019370822850835, 0.09735791964183338, 0.10078363526210943, 0.19181565813435641, 0.06244213986450464, 0.2674789311036525, 0.05723147372976345, 0.23574113913322692, 0.06293912994853113, 0.19190225618437884, 0.0816408994975425, 0.36496617713090407, 0.17197779997797535, 0.11089758856933662, 0.12762110041347097, 0.07760116774710879, 0.16512155783918947, 0.23833415839494587, 0.11309565109814435, 0.25153031042263885, 0.1586523936315103, 0.11481079868585398, 0.3934365854257821, 0.1523176327358584, 0.16307221761352686, 0.49273488900825424, 0.6279897015541942, 0.6939857583914847, 0.4396056636263417, 0.518247905302162, 0.5435100286525716, 0.5465128825347543, 0.5800644079820085, 0.5385763298793973, 0.1261565503650074, 0.15851000684332062, 0.07776136474554873, 0.10329148930259147, 0.11755274324140186, 0.12908313029803153, 0.057644233420443, 0.08800903047498287, 0.12148421125990749, 0.2823924017427659, 0.17740546543922975, 0.1993829691509813, 0.19161744778997514, 0.16971050033118518, 0.21942231373285626, 0.2690964941498728, 0.24368159612971063, 0.2342629379280623, 0.20219160342606068, 0.3296669061631936, 0.2381012002453181, 0.19320625201510744, 0.19224753157811225, 0.158677629571356, 0.43321896072688537, 0.39240673686297667, 0.16480995961665668, 0.1862077562169393, 0.24304823544543053, 0.13100389855830996, 0.2344758296868621, 0.16544500253088112, 0.24561901015290744, 0.16211443273758264, 0.2168415809684121, 0.18418941040235193, 0.18722577167856091, 0.2267832087116276, 0.19514720908420236, 0.24667984040803137, 0.18823503872229252, 0.2182507256683942, 0.19589720460832016, 0.18075252804952435, 0.21470950688575052, 0.17810868270010072, 0.18127112782523103, 0.2059238823971793, 0.19351214458836263, 0.8132610692995612, 0.17594889527622948, 0.18689557978846172, 0.20789905186562674, 0.21018602365015426, 0.18497607821796136, 0.16447694630997334, 0.18529847548657807, 0.16771163260086308, 0.18365985781341454, 0.900813110824226, 0.1860787511387625, 0.17484443717662657, 0.20785248759459318, 0.20680335957859808, 0.1806905376762683, 0.4501772014497295, 0.16426302090138345, 0.12667969642440824, 0.16458027062598957, 0.3874571201583388, 0.48168676293734625, 0.10356837944445907, 0.1762334820034921, 0.1731835537418761, 0.18710114451129078, 0.18840874828533172, 0.19311942092460999, 0.1831315104568615, 0.17449314071494193, 0.17817587522275058, 0.21613611305665226, 0.08374599399835858, 0.08950217544837191, 0.08171898380884135, 0.08822581493755643, 0.08803025358223127, 0.11117187013561125, 0.08070684637772407, 0.08113450338721018, 0.06780694210217375]}, "mutation_prompt": null}
{"id": "172de071-8d7e-44af-87ba-2933358e1deb", "solution": "import numpy as np\n\nclass EnhancedProbabilisticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim  # Adjusted population size for maintaining diversity\n        self.F = 0.5  # Differential weight for controlled mutation impact\n        self.CR = 0.85  # Moderated crossover probability to enhance trial diversity\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Adaptive factor for parameter fine-tuning\n        self.local_search_prob = 0.2  # Probability to engage local search refinement\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def local_search(self, solution, func):\n        perturbation = np.random.normal(0, 0.01, self.dim)\n        new_solution = solution + perturbation\n        new_solution = np.clip(new_solution, self.bounds[0], self.bounds[1])\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n                # Local search with a certain probability\n                if np.random.rand() < self.local_search_prob:\n                    self.population[i] = self.local_search(self.population[i], func)\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1, self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedProbabilisticEvoStrategy", "description": "Adaptive evolutionary strategy enhanced with probabilistic local search and dynamic parameter adjustment for balanced exploration-exploitation.", "configspace": "", "generation": 39, "fitness": 0.3321802933424894, "feedback": "The algorithm EnhancedProbabilisticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {"aucs": [0.7743480993168617, 0.7065141666944952, 0.7240070882921834, 0.7533630953509152, 0.7090190653367989, 0.7672877770100623, 0.7096729947446438, 0.717937651671589, 0.7653154465434339, 0.5801075054430951, 0.5500940404932242, 0.4671809849592816, 0.541220905975379, 0.5278537775942783, 0.5231670040524284, 0.5264332915100696, 0.5054480596174955, 0.4837454405061501, 0.12515590537330357, 0.10518554169581762, 0.14157844237847672, 0.1385217787044256, 0.26068000407902037, 0.1325927312026577, 0.1391158249936003, 0.10517546773931774, 0.14314364952717984, 0.129460508796304, 0.10296148320201137, 0.14852823063300968, 0.1142131336313873, 0.11901681073538639, 0.11186093632135219, 0.1413167054060488, 0.08923174752525231, 0.12353683854716857, 0.8799858293667088, 0.9178968215627432, 0.9588191520337374, 0.9259854631172172, 0.9586467255298048, 0.8847259347484011, 0.9235335075647332, 0.9529331355943259, 0.8880231488425072, 0.414804778697349, 0.39454611622613966, 0.3810993871771834, 0.34531826911227903, 0.3637810614857352, 0.39092078099407723, 0.33902298459066993, 0.31318735774385253, 0.33294011908805465, 0.22127789305222267, 0.7376278497074028, 0.7094595215326099, 0.2513828502439114, 0.7583392967362417, 0.6712471025977464, 0.7148365327419102, 0.7556641204761717, 0.7702134720008988, 0.39667640263190174, 0.24617608878037955, 0.2581647733490877, 0.22252751898457357, 0.1823067562505083, 0.22616212217340337, 0.27123594816394736, 0.18275392667757173, 0.3420284620797972, 0.1208275265483062, 0.20287292430241977, 0.45049771450472065, 0.29635235909280855, 0.2813834380715642, 0.17021549993028962, 0.2267069409838689, 0.12090524649838785, 0.2774852370681138, 0.24527025753416143, 0.3010240129477384, 0.08597771171399615, 0.21281893857540668, 0.2623571251001421, 0.13363107589363443, 0.3300028830275925, 0.20826658704708723, 0.28004058015233213, 0.4172927782329794, 0.45310472406066227, 0.40032749373246657, 0.40336242684554735, 0.355188218883732, 0.35751826726324953, 0.4539823546221011, 0.4181949112093606, 0.4540687578595882, 0.16865698282441577, 0.20195961034078058, 0.14868469486042835, 0.1558572856838789, 0.14944492009768162, 0.08504921561858392, 0.12345251657190548, 0.09962811128467819, 0.07658548466702175, 0.2713345691428418, 0.23240686494660912, 0.2651579357601108, 0.2574354799365782, 0.2923717131896659, 0.21852607455891215, 0.27413945527458783, 0.208312994773442, 0.21025167977068648, 0.6176766583523098, 0.6425547422204971, 0.6261253547245673, 0.5824984858483837, 0.5918359906330296, 0.5928981837381294, 0.5734776911203584, 0.6030037823619618, 0.5755239436569637, 0.0797156828688661, 0.09557479130646751, 0.12520336085343897, 0.11266223910872852, 0.08470583068524207, 0.107321959766568, 0.1004106223900948, 0.12374558290091986, 0.09762440707306885, 0.13653420209919442, 0.3433270969580763, 0.19023626460226595, 0.15621178282751857, 0.2446867981784442, 0.13204820992675026, 0.17263903331517994, 0.15859557751627185, 0.2599867965881769, 0.32779386906549324, 0.32041148133933095, 0.35325959377933336, 0.4236183573897936, 0.4059343023905392, 0.4088541204401791, 0.4140348973237702, 0.3961082347564089, 0.39731866394740545, 0.3079448730278386, 0.243368097097867, 0.2895328158108662, 0.3668726176491789, 0.2700395730706233, 0.29385089797870856, 0.2504616086665825, 0.36577794313751677, 0.30452030928244844, 0.1911000169998489, 0.20073907988115303, 0.1963313712779472, 0.18098330208819868, 0.2226755356054343, 0.19466525502474274, 0.21322261040034496, 0.18026272011637479, 0.22622647645900784, 0.23755162173691868, 0.2198192379192967, 0.20152162079201752, 0.18746838417276757, 0.18993780999364474, 0.20725821276251977, 0.38342605910068905, 0.21122336084217008, 0.20833550762666075, 0.1896331472399041, 0.7455150484402991, 0.16828878014912296, 0.7432006221079559, 0.19239359654570853, 0.18505737520323773, 0.7990213307519168, 0.13367869455492198, 0.7920189216733282, 0.16658479661937475, 0.2063908391759368, 0.20228491326941633, 0.6778243655340936, 0.19995064392813966, 0.14788095951701374, 0.7115406496012553, 0.15349020437104632, 0.20704017245401185, 0.19109643754091044, 0.1829585813899065, 0.19018656272024992, 0.20031252812598588, 0.19921042254970467, 0.18648126532421305, 0.20011099207499672, 0.1833760999510612, 0.19285664069225772, 0.08759894867800444, 0.08514734362771337, 0.07338535824971681, 0.07728090887743078, 0.07247677277513553, 0.08599291465804049, 0.08982539395697764, 0.08647454046038783, 0.07792615034824835]}, "mutation_prompt": null}
{"id": "4d877411-10a1-4aab-b430-7e109bb0ddda", "solution": "import numpy as np\n\nclass EnhancedAggressiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Further reduced population size for aggressive convergence\n        self.F = 0.7  # Increased differential weight for enhanced exploitation\n        self.CR = 0.85  # Adjusted crossover probability for balanced recombination\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand-to-best'\n        self.adaptive_factor = 0.85  # Adjusted adaptive factor for more frequent adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'rand-to-best':\n            return self.population[a] + self.F * (self.best_solution - self.population[a]) + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:  # Shortened window for more responsive adaptation\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  # Stricter improvement threshold\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand-to-best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedAggressiveEvoStrategy", "description": "Aggressively adaptive evolutionary strategy combining differential evolution with stochastic local perturbations to dynamically enhance search performance.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {}, "mutation_prompt": null}
{"id": "37e2daee-0f50-496c-9b35-9c3429db8669", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Slightly reduced population size for faster convergence\n        self.F = 0.5  # Adjusted differential weight for enhanced diversity\n        self.CR = 0.85  # Slightly increased crossover probability for enhanced recombination\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Adaptive factor fine-tuned for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:  # Faster adaptation by checking over a shorter window\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  # Slightly less strict threshold\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.8)\n                    self.CR = np.clip(self.CR, 0.4, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "Hybrid Differential Evolution with Adaptive Mutation blending global and local strategies to enhance optimization efficiency.", "configspace": "", "generation": 41, "fitness": 0.3921490174804358, "feedback": "The algorithm HybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "a3208a5a-54c2-4ea7-9bc5-75dfa535becf", "metadata": {"aucs": [0.8388660738605211, 0.8316009362958845, 0.8667480016072511, 0.830784640375345, 0.8577940949132372, 0.8528751595192565, 0.8654695239712702, 0.8270066495190155, 0.8426870392609822, 0.5431849171367835, 0.7070888082858111, 0.7167020231320826, 0.6626812744025705, 0.6113156732084936, 0.7083617824617933, 0.7125548213488846, 0.6855668086517708, 0.7133068685081747, 0.09090054228113875, 0.17233566291928404, 0.14903945179642164, 0.13173564954140582, 0.15884311291934805, 0.1380904524815424, 0.13215829255424927, 0.5413684758717054, 0.6170056981893481, 0.6203197688773008, 0.10261317550028615, 0.12285582330041889, 0.10873165089759385, 0.08637221597857392, 0.13074494670632686, 0.14303837844181222, 0.10930680802302106, 0.10670591093145687, 0.9180550345745563, 0.9660534007490047, 0.9215161163263672, 0.9762367643317975, 0.9376493666616212, 0.9302151974569002, 0.9140017150107597, 0.9494961256965725, 0.8873731856806703, 0.5853966991441346, 0.6116931436040508, 0.5854907790875802, 0.605276334943928, 0.6122005883510193, 0.6031906950094372, 0.5651512621343961, 0.50402805616818, 0.6226181066383581, 0.22380570543400313, 0.7951159263334162, 0.8570371982737033, 0.3726706880545766, 0.8685501297367415, 0.8571226989157072, 0.20480035206529879, 0.8450644156747308, 0.8456009894554755, 0.4913186929251575, 0.6093588228253477, 0.22979453970555108, 0.12767070040675121, 0.12861717483716817, 0.3296319323094845, 0.48328946949760565, 0.5007122465689573, 0.5137594016292069, 0.23499393928293932, 0.39366272467784713, 0.33577772533941064, 0.31368405265871524, 0.2365562588634097, 0.3957012851712971, 0.6190097354176494, 0.46278466219254344, 0.5680421888068865, 0.3132253996613661, 0.06668242178889483, 0.5014652368956308, 0.31305129759556927, 0.34846120212046294, 0.06364333586715043, 0.4238621904135723, 0.37136883669464926, 0.24831819785070064, 0.642372346867411, 0.6468467849234791, 0.58879459802113, 0.37697726156660194, 0.5839253786173797, 0.5759472846903422, 0.6560911079689469, 0.542780801106526, 0.6430143509204982, 0.07847932659676338, 0.11136034389231575, 0.07549466777226532, 0.17962062234309217, 0.42293560066178537, 0.48946740580160153, 0.27104014214487826, 0.19799520368103063, 0.1590020903381677, 0.3802540102293076, 0.41781408175307155, 0.3028366206068781, 0.45287658176184664, 0.3786817727145061, 0.4061713205458929, 0.38111205824394767, 0.33971359202402285, 0.36469508269654605, 0.743993799518023, 0.6901250657404943, 0.7199681739467545, 0.709078751034258, 0.7203625494366578, 0.6934754936701616, 0.72720145605525, 0.5927256531980403, 0.6820953794091571, 0.11296971581176163, 0.10211299888014858, 0.08043118778092717, 0.10826243759332688, 0.12269976333759003, 0.11169095443838506, 0.07155292386148393, 0.1425139199959029, 0.14111463799357826, 0.183020059862262, 0.16458995917611463, 0.2128658048956159, 0.1901876924344822, 0.20224296521538476, 0.21693561794986616, 0.4722462124130331, 0.33053029351631946, 0.1724978253765843, 0.44534214500057745, 0.2535447820925647, 0.506433775305003, 0.4458051210725663, 0.44329585165711216, 0.3763001822594364, 0.4573325393464489, 0.39422156373608364, 0.6138855037911974, 0.28359555528525315, 0.20150681983811103, 0.2668982784315893, 0.474109244816172, 0.26251424964382464, 0.27781227068275915, 0.24519452224438687, 0.20717119501326886, 0.20173353098867441, 0.18376447543680574, 0.1884113188498271, 0.20551817391768912, 0.19716387048315287, 0.2111331092140566, 0.2164378770666946, 0.19298104521826975, 0.1950719898954889, 0.2059617331327589, 0.1934787590825171, 0.1839584059286158, 0.1872128275922994, 0.20576516951317858, 0.19018086895194264, 0.21775118998011378, 0.2389524775611459, 0.2398188491616443, 0.2058199001214116, 0.1835337366231663, 0.18604182992450646, 0.17055514803892624, 0.8627510574510897, 0.16425114211116942, 0.1530887538094159, 0.1541112588617518, 0.17187483731337194, 0.1647937898585593, 0.11312517963141311, 0.20984723583917286, 0.1510224688370494, 0.8462658315608806, 0.20816711700930957, 0.8021587354257844, 0.7756574203154495, 0.16280758234029458, 0.21058710928363822, 0.1847794799979311, 0.18418887340100387, 0.1830405918400546, 0.18622122397380758, 0.175601884978293, 0.1880527880485071, 0.18889837509493568, 0.16694037515582028, 0.19580468650121963, 0.09012712506972076, 0.08965318065153571, 0.08514235850581975, 0.07087899435208311, 0.07196869426280139, 0.07953833628249918, 0.08527294634082538, 0.07683212039579324, 0.0841191421548192]}, "mutation_prompt": null}
{"id": "d091d8e7-0926-42b7-b79d-d50c0c085283", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim  # Increased population size for better diversity\n        self.F = 0.6  # Increased differential weight for better exploration\n        self.CR = 0.8  # Slightly decreased crossover probability for balanced exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'best'\n        self.adaptive_factor = 0.9  # Adjusted for more aggressive adaptation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 5:  # Shortened adaptation window\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:  # Adjusted threshold for fitness improvement\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand'\n            else:\n                self.mutation_strategy = 'best'\n\n            if func_calls > self.budget * 0.6 and stagnation_counter > self.population_size * 0.4:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.03 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedHybridAdaptiveEvoStrategy", "description": "Enhanced Hybrid Differential Evolution with Adaptive Local Search and Dynamic Strategy Adjustment for Robust Optimization.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "37e2daee-0f50-496c-9b35-9c3429db8669", "metadata": {}, "mutation_prompt": null}
{"id": "b6f3943b-6e46-4746-be68-c00d92cb0e75", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  \n        self.F = 0.5  \n        self.CR = 0.85  \n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  \n        self.learning_rate = 0.1  # New adaptive learning rate for increased flexibility\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:  \n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  \n                    self.F *= (self.adaptive_factor + self.learning_rate)\n                    self.CR *= (self.adaptive_factor - self.learning_rate)\n                    self.F = np.clip(self.F, 0.2, 0.8)\n                    self.CR = np.clip(self.CR, 0.4, 0.9)\n                \n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "Enhanced Hybrid Evolution Strategy with Adaptive Learning Rates blending exploration and exploitation for robust optimization.", "configspace": "", "generation": 43, "fitness": 0.3900004936849882, "feedback": "The algorithm HybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "37e2daee-0f50-496c-9b35-9c3429db8669", "metadata": {"aucs": [0.8388000892949632, 0.8315756050131302, 0.8667480016072511, 0.8294728152683094, 0.8572081951665282, 0.8528751595192565, 0.8653470425409591, 0.827061857744259, 0.8431187588240718, 0.5432970654053646, 0.7069498502763045, 0.7172636316419327, 0.6626812744025705, 0.6112457942717585, 0.7083775044487566, 0.7125541505589215, 0.6855490889160872, 0.7128603226072694, 0.09090054228095701, 0.17233566291854951, 0.14903945179564781, 0.13173564953375205, 0.15884311291722875, 0.1380904524862706, 0.13215829255645928, 0.5413684758717054, 0.6170056981893481, 0.6202721751287572, 0.10261317549876425, 0.12285582329766453, 0.10873165089730197, 0.08637221597869904, 0.13074494670338632, 0.13308603993017987, 0.10930680802140436, 0.10670594034132297, 0.9180550345745563, 0.9660534007490047, 0.9215161163263672, 0.9762367643317975, 0.9376493666616212, 0.9302151974569002, 0.9140017150107597, 0.9494961256965725, 0.8873731856806703, 0.5811466342172672, 0.6104731787782651, 0.581652864631925, 0.5991083764589765, 0.6077539163900173, 0.5987361457001728, 0.5435096283094045, 0.40623444494073346, 0.6345564638049925, 0.22380570543400313, 0.7951159263334162, 0.8570371982737033, 0.3726706880545766, 0.8685501297367415, 0.8571226989157072, 0.20480035206529879, 0.8450644156747308, 0.8456009894554755, 0.49066510135426744, 0.6075150650925332, 0.22979453970555108, 0.12767070039611972, 0.12861717483024127, 0.3295443723069734, 0.48290228756736786, 0.500285018816751, 0.5133519358562018, 0.23499393928293932, 0.3934774512519186, 0.33451923268010164, 0.31368405265871524, 0.2365562588634097, 0.3927352388996366, 0.609358642644367, 0.4557532385547596, 0.5680421888068865, 0.31251762631829705, 0.06668242179173833, 0.4948057267008341, 0.313181172053119, 0.34343295356051873, 0.06364333586715043, 0.42344481578039694, 0.369922182422759, 0.24831819785070064, 0.6515053163011282, 0.6311058976120831, 0.5808777300669762, 0.3781588201103513, 0.5747411508478406, 0.5798063532966915, 0.6648824091200434, 0.5273408475515156, 0.6288657166065728, 0.07847932659676338, 0.11136034389231575, 0.07549466777226532, 0.17962062234309217, 0.424812020645318, 0.48943781197447733, 0.27104014214487826, 0.19799520368103063, 0.1590020903381677, 0.3802540102293076, 0.4174552464503416, 0.3028366206068781, 0.4529400300115972, 0.3786817727145061, 0.40617631404306764, 0.38111205824394767, 0.33971359202402285, 0.36469508269654605, 0.7194387272364527, 0.6886912418296238, 0.7264717359931724, 0.7017811039854791, 0.717559384532814, 0.6958292581936463, 0.7167115230199381, 0.5951599542366215, 0.6831972611376902, 0.11296971580747828, 0.10211299887952996, 0.08043118777914404, 0.10654067449480153, 0.11102079967816858, 0.11578303031956771, 0.0894007548970962, 0.12679124242246997, 0.13998476768663637, 0.18302005985401637, 0.18489182579116503, 0.15582771134859708, 0.38923886040312605, 0.22365014837064012, 0.21290466628205518, 0.16961665165925766, 0.19108352028903686, 0.24116506839045715, 0.4453278101471363, 0.2535447820925647, 0.5062971722644942, 0.4457688758026037, 0.44329375633426427, 0.3762979010453821, 0.45732920152519574, 0.39422156373608364, 0.6246581790185955, 0.28359555528525315, 0.20150681983811103, 0.2668982784315893, 0.4765555202111834, 0.26251424964382464, 0.27781227068275915, 0.24519452224438687, 0.20717119501326886, 0.20173353098867441, 0.17646524079829795, 0.18084636745307703, 0.1916397710026546, 0.22513207318514183, 0.2069899363967843, 0.23183749203842785, 0.1907911345939034, 0.1786374453084021, 0.19801187043109736, 0.19347875907994583, 0.18395840592628243, 0.1872128275360525, 0.20386003794521335, 0.1901808689517217, 0.21775118997130793, 0.23895247754878768, 0.23981884917234886, 0.2058199001222576, 0.18353373662239092, 0.1860418299230182, 0.17055514804029226, 0.8627510574510897, 0.16425114209258684, 0.15308875377441578, 0.15411125881992016, 0.17187483731290887, 0.16479378987787496, 0.11312517962989421, 0.20984723578531916, 0.15102246884662673, 0.8462658315608806, 0.208167116918052, 0.8021587354257844, 0.7756574203154495, 0.1628075823122368, 0.2105871093073659, 0.18298972516584688, 0.1707833996495115, 0.1947678056990918, 0.18651520973719082, 0.1701900293745181, 0.18131061506819746, 0.19167072058662094, 0.17544674131123594, 0.19580468650121963, 0.08284318090792053, 0.08506632422775184, 0.07513080988907694, 0.08139189286728321, 0.07840135970599749, 0.08080721131570279, 0.08201449163108632, 0.08900118643514654, 0.08045625022745007]}, "mutation_prompt": null}
{"id": "724dd86f-b17f-40d3-a659-508262f10024", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 7 * dim  # Modified population size for quicker adaptation\n        self.F = 0.6  # Adjusted differential weight for better exploration\n        self.CR = 0.8  # Adjusted crossover probability to balance exploration and exploitation\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # Adaptation factor refined for better responsiveness\n        self.learning_rate = 0.1  # Introduced learning rate for adaptive adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= (self.adaptive_factor + self.learning_rate)\n                    self.CR *= (self.adaptive_factor + self.learning_rate)\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedHybridAdaptiveEvoStrategy", "description": "Enhanced Hybrid Adaptive Evolutionary Strategy with Adaptive Learning Rate for Improved Exploration.", "configspace": "", "generation": 44, "fitness": 0.36982339274341264, "feedback": "The algorithm EnhancedHybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "37e2daee-0f50-496c-9b35-9c3429db8669", "metadata": {"aucs": [0.7947300829746001, 0.8075315259262645, 0.8362864249267559, 0.8299421797853521, 0.8426936428627386, 0.8423439268795737, 0.8117473145917224, 0.8277414419141411, 0.8507889656557462, 0.6921043681165724, 0.6692202316165181, 0.7150823116772111, 0.6873232006697314, 0.6829793390521246, 0.6895494534272972, 0.6856651176444404, 0.658350943821667, 0.6854961329621776, 0.11347922599916149, 0.14820236793749464, 0.15641182362138406, 0.13814933136131968, 0.07316128918989018, 0.13719262364795026, 0.12678083518948646, 0.1711233206963616, 0.14900959446703932, 0.1347620340987945, 0.138374859331016, 0.13358933223680014, 0.09686189720268779, 0.11714029378140312, 0.08738604788782889, 0.15524152177512407, 0.14947296010825772, 0.10106223492338884, 0.9561352470109598, 0.9462739310301495, 0.9444598355507199, 0.9476685695760936, 0.9586094418263866, 0.9714000398844176, 0.9425571558046808, 0.9821597187511141, 0.9292395071189984, 0.47641327100112096, 0.4827109528043452, 0.5100186405827208, 0.5188529970552245, 0.5575666134396176, 0.4823328819754984, 0.5271457205552421, 0.4567688849829208, 0.5264388318669002, 0.3645268912873221, 0.7797046144142625, 0.2123351640076937, 0.7675188848172512, 0.3639253978950925, 0.8152624201746095, 0.8145077783029232, 0.7999328644922442, 0.2361036539864272, 0.4130271511356167, 0.30903425723399014, 0.5602671961957766, 0.4124532063303006, 0.12762224516012521, 0.12704141976687455, 0.3982633378313367, 0.4466456948120241, 0.5284546751325692, 0.4526526301250524, 0.21719117452909587, 0.56092615379595, 0.2897471070576556, 0.379821238095326, 0.6188589047370018, 0.3037994157452508, 0.30086497856650607, 0.4017528170044422, 0.18495709725143095, 0.06280651170684415, 0.39642634482390526, 0.37069400785266304, 0.2742069455156868, 0.3558443083050161, 0.22473526386290155, 0.22797065910232128, 0.27691178088822177, 0.49064495108813566, 0.5186129276676035, 0.5161816148654601, 0.4016112098251201, 0.5920682728956271, 0.4081651183646361, 0.447616106171818, 0.576260141316774, 0.45934676109165506, 0.14517342771519437, 0.05593855768809375, 0.24552204828464086, 0.12392105741838311, 0.1298536706391027, 0.1879856137416661, 0.1342301245524271, 0.24173187285426656, 0.09387616243830399, 0.2801451825156781, 0.2825463658049253, 0.2694339115508606, 0.34570756808844894, 0.365703008175263, 0.32822353747678523, 0.3236168287694584, 0.2993905914074777, 0.3752501306169119, 0.7093487015630418, 0.7182392507128004, 0.7466492306468142, 0.7319888738675657, 0.6973261572602256, 0.6856748322110691, 0.6951603601786026, 0.6879211427418999, 0.6633800436888619, 0.1348885296812381, 0.09977356990279607, 0.09384791950836846, 0.09119647795441155, 0.10108358860451605, 0.10040835911071277, 0.08247780789216597, 0.12896919912532578, 0.10926572122437961, 0.16550719052136487, 0.2550636665452206, 0.18620066144653025, 0.15449820585306773, 0.21738979115545776, 0.15288340481255747, 0.1941363490488316, 0.14502326399351206, 0.11625706026711302, 0.3355425186153873, 0.5000152910076243, 0.4412340894836241, 0.3566986443730601, 0.4682939041768096, 0.35553518967480713, 0.2830827591177797, 0.47187707345570984, 0.401366866942116, 0.3169148821257538, 0.3209375311377227, 0.27447587096291803, 0.42399368425920425, 0.3739039049001667, 0.27178397646562547, 0.35643399674577037, 0.34891188681873586, 0.2323573923221215, 0.1697032861900245, 0.2239421652675434, 0.1996710379224701, 0.19741760485112325, 0.1741428574494014, 0.19270299044171235, 0.1938058016501023, 0.1882312984784602, 0.19212074133634582, 0.21478052892196986, 0.21745977456901533, 0.19890553531000232, 0.2116189068256663, 0.21134278045465604, 0.5572339595460876, 0.6775497777626163, 0.19363272723692282, 0.21103397082973374, 0.15837042207256402, 0.14648132861523577, 0.1920525206085234, 0.1959183828678316, 0.20753226278164327, 0.17444255479222903, 0.1624878453334372, 0.16258130995365772, 0.160614045868697, 0.7613870611601486, 0.20769726580902004, 0.7834717460875409, 0.8061369004359089, 0.8281686725666202, 0.2049894702726539, 0.20881078149279664, 0.1628553952890528, 0.1633601979753716, 0.17393928399466752, 0.19034202037231973, 0.18961368963988523, 0.17855633962950723, 0.1657683059926549, 0.17440862555314274, 0.18591496941843566, 0.18380832876482167, 0.19289568113385935, 0.0833558996256275, 0.07246146288594069, 0.07601464076867037, 0.07913130453904782, 0.07508923234797238, 0.07547559379014346, 0.06378489443100444, 0.06230673024037536, 0.07913170457530705]}, "mutation_prompt": null}
{"id": "6ab8e00c-b8fc-4f83-997e-4de446291776", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Slightly reduced population size for faster convergence\n        self.F = 0.5  # Adjusted differential weight for enhanced diversity\n        self.CR = 0.85  # Slightly increased crossover probability for enhanced recombination\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Adaptive factor fine-tuned for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:  # Faster adaptation by checking over a shorter window\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  # Slightly less strict threshold\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.8)\n                    self.CR = np.clip(self.CR, 0.4, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "Hybrid Differential Evolution with Adaptive Mutation blending global and local strategies to enhance optimization efficiency.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "37e2daee-0f50-496c-9b35-9c3429db8669", "metadata": {"aucs": [0.8388660738605211, 0.8316009362958845, 0.8667480016072511, 0.830784640375345, 0.8577940949132372, 0.8528751595192565, 0.8654695239712702, 0.8270066495190155, 0.8426870392609822, 0.5431849171367835, 0.7070888082858111, 0.7167020231320826, 0.6626812744025705, 0.6113156732084936, 0.7083617824617933, 0.7125548213488846, 0.6855668086517708, 0.7133068685081747, 0.09090054228113875, 0.17233566291928404, 0.14903945179642164, 0.13173564954140582, 0.15884311291934805, 0.1380904524815424, 0.13215829255424927, 0.5413684758717054, 0.6170056981893481, 0.6203197688773008, 0.10261317550028615, 0.12285582330041889, 0.10873165089759385, 0.08637221597857392, 0.13074494670632686, 0.14303837844181222, 0.10930680802302106, 0.10670591093145687, 0.9180550345745563, 0.9660534007490047, 0.9215161163263672, 0.9762367643317975, 0.9376493666616212, 0.9302151974569002, 0.9140017150107597, 0.9494961256965725, 0.8873731856806703, 0.5853966991441346, 0.6116931436040508, 0.5854907790875802, 0.605276334943928, 0.6122005883510193, 0.6031906950094372, 0.5651512621343961, 0.50402805616818, 0.6226181066383581, 0.22380570543400313, 0.7951159263334162, 0.8570371982737033, 0.3726706880545766, 0.8685501297367415, 0.8571226989157072, 0.20480035206529879, 0.8450644156747308, 0.8456009894554755, 0.4913186929251575, 0.6093588228253477, 0.22979453970555108, 0.12767070040675121, 0.12861717483716817, 0.3296319323094845, 0.48328946949760565, 0.5007122465689573, 0.5137594016292069, 0.23499393928293932, 0.39366272467784713, 0.33577772533941064, 0.31368405265871524, 0.2365562588634097, 0.3957012851712971, 0.6190097354176494, 0.46278466219254344, 0.5680421888068865, 0.3132253996613661, 0.06668242178889483, 0.5014652368956308, 0.31305129759556927, 0.34846120212046294, 0.06364333586715043, 0.4238621904135723, 0.37136883669464926, 0.24831819785070064, 0.642372346867411, 0.6468467849234791, 0.58879459802113, 0.37697726156660194, 0.5839253786173797, 0.5759472846903422, 0.6560911079689469, 0.542780801106526, 0.6430143509204982, 0.07847932659676338, 0.11136034389231575, 0.07549466777226532, 0.17962062234309217, 0.42293560066178537, 0.48946740580160153, 0.27104014214487826, 0.19799520368103063, 0.1590020903381677, 0.3802540102293076, 0.41781408175307155, 0.3028366206068781, 0.45287658176184664, 0.3786817727145061, 0.4061713205458929, 0.38111205824394767, 0.33971359202402285, 0.36469508269654605, 0.743993799518023, 0.6901250657404943, 0.7199681739467545, 0.709078751034258, 0.7203625494366578, 0.6934754936701616, 0.72720145605525, 0.5927256531980403, 0.6820953794091571, 0.11296971581176163, 0.10211299888014858, 0.08043118778092717, 0.10826243759332688, 0.12269976333759003, 0.11169095443838506, 0.07155292386148393, 0.1425139199959029, 0.14111463799357826, 0.183020059862262, 0.16458995917611463, 0.2128658048956159, 0.1901876924344822, 0.20224296521538476, 0.21693561794986616, 0.4722462124130331, 0.33053029351631946, 0.1724978253765843, 0.44534214500057745, 0.2535447820925647, 0.506433775305003, 0.4458051210725663, 0.44329585165711216, 0.3763001822594364, 0.4573325393464489, 0.39422156373608364, 0.6138855037911974, 0.28359555528525315, 0.20150681983811103, 0.2668982784315893, 0.474109244816172, 0.26251424964382464, 0.27781227068275915, 0.24519452224438687, 0.20717119501326886, 0.20173353098867441, 0.18376447543680574, 0.1884113188498271, 0.20551817391768912, 0.19716387048315287, 0.2111331092140566, 0.2164378770666946, 0.19298104521826975, 0.1950719898954889, 0.2059617331327589, 0.1934787590825171, 0.1839584059286158, 0.1872128275922994, 0.20576516951317858, 0.19018086895194264, 0.21775118998011378, 0.2389524775611459, 0.2398188491616443, 0.2058199001214116, 0.1835337366231663, 0.18604182992450646, 0.17055514803892624, 0.8627510574510897, 0.16425114211116942, 0.1530887538094159, 0.1541112588617518, 0.17187483731337194, 0.1647937898585593, 0.11312517963141311, 0.20984723583917286, 0.1510224688370494, 0.8462658315608806, 0.20816711700930957, 0.8021587354257844, 0.7756574203154495, 0.16280758234029458, 0.21058710928363822, 0.1847794799979311, 0.18418887340100387, 0.1830405918400546, 0.18622122397380758, 0.175601884978293, 0.1880527880485071, 0.18889837509493568, 0.16694037515582028, 0.19580468650121963, 0.09012712506972076, 0.08965318065153571, 0.08514235850581975, 0.07087899435208311, 0.07196869426280139, 0.07953833628249918, 0.08527294634082538, 0.07683212039579324, 0.0841191421548192]}, "mutation_prompt": null}
{"id": "4b0ea8c9-40af-4efa-b11e-1fab03039517", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Slightly reduced population size for faster convergence\n        self.F = 0.5  # Adjusted differential weight for enhanced diversity\n        self.CR = 0.85  # Slightly increased crossover probability for enhanced recombination\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Adaptive factor fine-tuned for dynamic adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:  # Faster adaptation by checking over a shorter window\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:  # Slightly less strict threshold\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.8)\n                    self.CR = np.clip(self.CR, 0.4, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "Hybrid Differential Evolution with Adaptive Mutation blending global and local strategies to enhance optimization efficiency.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "37e2daee-0f50-496c-9b35-9c3429db8669", "metadata": {"aucs": [0.8388660738605211, 0.8316009362958845, 0.8667480016072511, 0.830784640375345, 0.8577940949132372, 0.8528751595192565, 0.8654695239712702, 0.8270066495190155, 0.8426870392609822, 0.5431849171367835, 0.7070888082858111, 0.7167020231320826, 0.6626812744025705, 0.6113156732084936, 0.7083617824617933, 0.7125548213488846, 0.6855668086517708, 0.7133068685081747, 0.09090054228113875, 0.17233566291928404, 0.14903945179642164, 0.13173564954140582, 0.15884311291934805, 0.1380904524815424, 0.13215829255424927, 0.5413684758717054, 0.6170056981893481, 0.6203197688773008, 0.10261317550028615, 0.12285582330041889, 0.10873165089759385, 0.08637221597857392, 0.13074494670632686, 0.14303837844181222, 0.10930680802302106, 0.10670591093145687, 0.9180550345745563, 0.9660534007490047, 0.9215161163263672, 0.9762367643317975, 0.9376493666616212, 0.9302151974569002, 0.9140017150107597, 0.9494961256965725, 0.8873731856806703, 0.5853966991441346, 0.6116931436040508, 0.5854907790875802, 0.605276334943928, 0.6122005883510193, 0.6031906950094372, 0.5651512621343961, 0.50402805616818, 0.6226181066383581, 0.22380570543400313, 0.7951159263334162, 0.8570371982737033, 0.3726706880545766, 0.8685501297367415, 0.8571226989157072, 0.20480035206529879, 0.8450644156747308, 0.8456009894554755, 0.4913186929251575, 0.6093588228253477, 0.22979453970555108, 0.12767070040675121, 0.12861717483716817, 0.3296319323094845, 0.48328946949760565, 0.5007122465689573, 0.5137594016292069, 0.23499393928293932, 0.39366272467784713, 0.33577772533941064, 0.31368405265871524, 0.2365562588634097, 0.3957012851712971, 0.6190097354176494, 0.46278466219254344, 0.5680421888068865, 0.3132253996613661, 0.06668242178889483, 0.5014652368956308, 0.31305129759556927, 0.34846120212046294, 0.06364333586715043, 0.4238621904135723, 0.37136883669464926, 0.24831819785070064, 0.642372346867411, 0.6468467849234791, 0.58879459802113, 0.37697726156660194, 0.5839253786173797, 0.5759472846903422, 0.6560911079689469, 0.542780801106526, 0.6430143509204982, 0.07847932659676338, 0.11136034389231575, 0.07549466777226532, 0.17962062234309217, 0.42293560066178537, 0.48946740580160153, 0.27104014214487826, 0.19799520368103063, 0.1590020903381677, 0.3802540102293076, 0.41781408175307155, 0.3028366206068781, 0.45287658176184664, 0.3786817727145061, 0.4061713205458929, 0.38111205824394767, 0.33971359202402285, 0.36469508269654605, 0.743993799518023, 0.6901250657404943, 0.7199681739467545, 0.709078751034258, 0.7203625494366578, 0.6934754936701616, 0.72720145605525, 0.5927256531980403, 0.6820953794091571, 0.11296971581176163, 0.10211299888014858, 0.08043118778092717, 0.10826243759332688, 0.12269976333759003, 0.11169095443838506, 0.07155292386148393, 0.1425139199959029, 0.14111463799357826, 0.183020059862262, 0.16458995917611463, 0.2128658048956159, 0.1901876924344822, 0.20224296521538476, 0.21693561794986616, 0.4722462124130331, 0.33053029351631946, 0.1724978253765843, 0.44534214500057745, 0.2535447820925647, 0.506433775305003, 0.4458051210725663, 0.44329585165711216, 0.3763001822594364, 0.4573325393464489, 0.39422156373608364, 0.6138855037911974, 0.28359555528525315, 0.20150681983811103, 0.2668982784315893, 0.474109244816172, 0.26251424964382464, 0.27781227068275915, 0.24519452224438687, 0.20717119501326886, 0.20173353098867441, 0.18376447543680574, 0.1884113188498271, 0.20551817391768912, 0.19716387048315287, 0.2111331092140566, 0.2164378770666946, 0.19298104521826975, 0.1950719898954889, 0.2059617331327589, 0.1934787590825171, 0.1839584059286158, 0.1872128275922994, 0.20576516951317858, 0.19018086895194264, 0.21775118998011378, 0.2389524775611459, 0.2398188491616443, 0.2058199001214116, 0.1835337366231663, 0.18604182992450646, 0.17055514803892624, 0.8627510574510897, 0.16425114211116942, 0.1530887538094159, 0.1541112588617518, 0.17187483731337194, 0.1647937898585593, 0.11312517963141311, 0.20984723583917286, 0.1510224688370494, 0.8462658315608806, 0.20816711700930957, 0.8021587354257844, 0.7756574203154495, 0.16280758234029458, 0.21058710928363822, 0.1847794799979311, 0.18418887340100387, 0.1830405918400546, 0.18622122397380758, 0.175601884978293, 0.1880527880485071, 0.18889837509493568, 0.16694037515582028, 0.19580468650121963, 0.09012712506972076, 0.08965318065153571, 0.08514235850581975, 0.07087899435208311, 0.07196869426280139, 0.07953833628249918, 0.08527294634082538, 0.07683212039579324, 0.0841191421548192]}, "mutation_prompt": null}
{"id": "22f61d2b-4dfa-4189-aa69-454bca611395", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Adjusted population size for strategic convergence\n        self.F = 0.6  # Slightly increased differential weight for better exploration\n        self.CR = 0.8  # Tuned crossover probability for balanced recombination\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9  # More dynamic factor for adaptive adjustments\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 8:  # Further reduced window for rapid adaptation\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:  # More relaxed threshold for adaptation\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.2:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedHybridAdaptiveEvoStrategy", "description": "Enhanced Hybrid Differential Evolution with Adaptive Mutation and Strategic Random Walk for improved convergence speed and solution quality.", "configspace": "", "generation": 47, "fitness": 0.3637539887737312, "feedback": "The algorithm EnhancedHybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "37e2daee-0f50-496c-9b35-9c3429db8669", "metadata": {"aucs": [0.8543943560996796, 0.82454537523671, 0.857218215363482, 0.8308876942375685, 0.8339551641839208, 0.8368853505766825, 0.8526441913051636, 0.8467612496812884, 0.8591214983242658, 0.7015060212737922, 0.638824046389501, 0.692025384204747, 0.7128943817296951, 9.999999999998899e-05, 0.7391760561578464, 0.7307813958713824, 0.7383987965422826, 0.7047352593093381, 0.15215686925198701, 0.14232800726889694, 0.14684353118833404, 0.1684880484264084, 0.1377060181973937, 0.14734823056067037, 0.16202892072850805, 0.16212538720563063, 0.13998088946516274, 0.16413683450372196, 0.10641457206718863, 0.1454199348193419, 0.13295906599777185, 0.13579858280526658, 0.11583613627841605, 0.09085978198872346, 0.135072666776356, 0.13755132553769567, 0.9680849786402846, 0.9595193997631918, 0.9643857760680521, 0.9352124663378114, 0.9674130965748318, 0.9614810734534257, 0.9812721887997061, 0.9817268424984187, 0.9789422571523497, 0.5688419747046736, 0.5986426923853321, 0.5677122220077293, 0.6117386149272774, 0.6214555007632321, 0.5999303288005626, 0.5878064240822041, 0.5839303880289523, 0.5482809814777911, 0.9113593721283383, 0.36649471152836266, 0.8198303801171747, 0.866728140250622, 0.8451652260684992, 0.7982276993303689, 0.764739900229811, 0.8007609761120267, 0.2237813353296092, 0.12862317846244298, 0.3931188623679138, 0.32372647479716077, 0.4824291361156655, 0.12749650294146542, 0.37040091751798465, 0.38242047839722515, 0.46196252032441565, 0.12837337239046942, 0.2552628105427811, 0.5157322797938813, 0.4502516619994441, 0.12962935891490923, 0.2643794838367729, 0.5102455256205763, 0.39239944944664373, 0.3691088153990374, 0.40076152717244407, 0.28871724663597975, 0.33226997750975895, 0.07724361908158084, 0.046689591755755155, 0.05646030482913034, 0.032868099491427216, 0.4484235623553279, 0.05853015312262866, 0.07045732628302015, 0.4879366313164276, 0.25277421546068346, 0.5273009099927126, 0.4381082559099607, 0.32904783418654737, 0.49903459324692545, 0.14708930106596818, 0.06822762365626822, 0.4880326374379427, 0.16137063120144435, 0.2910577514626381, 0.1011051060048258, 0.32317739336982987, 0.29927076352123183, 0.3292764732959026, 0.13850660467447373, 0.12327073917024423, 0.0903549240402064, 0.3937294158020477, 0.3127273221699123, 0.3461398966012631, 0.4174963995492056, 0.3228837869207344, 0.40506347072304794, 0.3049577149277032, 0.31961543671664505, 0.35677390275958965, 0.6294364919997151, 0.6739606287172071, 0.6840203286707349, 0.6618185673360746, 0.6243133583828284, 0.5908615081301811, 0.6980496022417504, 0.6211134085980252, 0.6868191734065905, 0.13160244292116352, 0.12769555604302518, 0.12443524805714623, 0.09893157414565645, 0.1224998206571365, 0.1460168136357164, 0.12207860109117596, 0.1369290711405583, 0.08895112439955277, 0.2189975990733838, 0.26613486254637175, 0.1600326317268358, 0.2362862321493554, 0.2507162182181141, 0.2352721439717932, 0.15923557619789985, 0.2095612961910014, 0.17617417296423554, 0.3738498395675025, 0.44542963446665107, 0.4178623277111322, 0.2968103691482826, 0.5027917783202092, 0.3427121728959339, 0.22708817536834802, 0.5210784851444943, 0.4962420380341056, 0.21927000475078162, 0.3108443806519946, 0.36569569863010476, 0.2999888672694425, 0.27093371165761715, 0.22519619882685993, 0.22174561742512566, 0.3674910444792404, 0.3218769991143525, 0.204148338564467, 0.1851939029688212, 0.20350927946326047, 0.17842893790580494, 0.18494542588851504, 0.1925299751357905, 0.1751450733639096, 0.24571973021603066, 0.18585972208098134, 0.20407057191602473, 0.18373465458002214, 0.1835991847308741, 0.2180635320694786, 0.2149449875188203, 0.21502138916721392, 0.23609921318327365, 0.2426459593702498, 0.20155435992772008, 0.1862911664954806, 0.1843239847525412, 0.8674373503641667, 0.1776130417733608, 0.8247135614242027, 0.16853098965134228, 0.110437707635757, 0.8282868712249192, 0.13391759867844066, 0.15527087241640092, 0.21039859276007933, 0.12065549215012394, 0.7219447671389776, 0.16666874947319266, 0.16425199536591395, 0.2080237901830485, 0.1366287513018246, 0.11244310165218174, 0.16705619411423644, 0.16764627994836423, 0.2003983187181123, 0.180652771459901, 0.18574221595430862, 0.17572642886196788, 0.17132667675469404, 0.17988941845697914, 0.19095823218663543, 0.07489180525682315, 0.08815841710432726, 0.09103584546092824, 0.0887895344174402, 0.08315508267951333, 0.10488589221521105, 0.08467831571795414, 0.0779050440496789, 0.08237492379456546]}, "mutation_prompt": null}
{"id": "1e5947a0-22c2-4809-be92-5d969ece059f", "solution": "import numpy as np\n\nclass AdaptiveRandomWalkEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim  # Adjusted population size\n        self.F = 0.6  # Slightly increased differential weight\n        self.CR = 0.9  # Further increased crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.8  # Adaptive factor fine-tuned\n        self.stagnation_threshold = 5  # Threshold for stagnation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def random_walk(self, solution, stddev):\n        return np.clip(solution + np.random.normal(0, stddev, self.dim), self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            if stagnation_counter > self.stagnation_threshold:\n                self.F *= self.adaptive_factor\n                self.CR *= self.adaptive_factor\n                self.F = np.clip(self.F, 0.4, 0.9)\n                self.CR = np.clip(self.CR, 0.5, 1.0)\n\n            if stagnation_counter > self.population_size // 2:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.random_walk(self.population[i], 0.5 * self.F)\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveRandomWalkEvoStrategy", "description": "Adaptive Differential Evolution incorporating random walk strategy for enhanced global search and dynamic local exploitation.", "configspace": "", "generation": 48, "fitness": 0.19586566807572628, "feedback": "The algorithm AdaptiveRandomWalkEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "37e2daee-0f50-496c-9b35-9c3429db8669", "metadata": {"aucs": [0.5171098394101881, 0.5691639364667476, 0.5360793641586317, 0.5284411630255104, 0.5485570032574834, 0.5460231212719755, 0.5296854442031342, 0.548067409710445, 0.5073386622716023, 0.22905427771061293, 0.23928444392957293, 0.23349297627500065, 0.23479753898474098, 0.25181911714273864, 0.28162761354831645, 0.239257265331694, 0.2365555839571044, 0.24244808758942427, 0.10696485659167576, 0.11394884363797386, 0.10201774177045664, 0.10679012504825236, 0.10987496949536801, 0.10290045099035128, 0.12180500282048856, 0.10111414496958693, 0.0953660702846717, 0.09324074297065876, 0.09756048179483534, 0.10164037716774998, 0.08869193471257297, 0.09563801746702316, 0.10130115996424194, 0.09000055648415417, 0.08804355878118753, 0.09686010022182545, 0.8780110993171779, 0.8604803425818207, 0.8191927761366838, 0.8641361493793078, 0.7596291730191405, 0.8477961953768789, 0.861009000915965, 0.890450943925188, 0.8781160001480455, 0.1368906432977749, 0.18220969001149556, 0.1447340018520905, 0.17459001639963445, 0.16441638724882157, 0.18877548131045563, 0.12941897208178377, 0.17068218983287264, 0.16741133701838573, 0.22903230167280053, 0.23749571566937833, 0.19527675391880905, 0.2550173939206666, 0.23898512498676439, 0.21151970210204007, 0.23626097916409627, 0.2025594740996347, 0.21781296865090294, 0.1123703799717376, 0.1393655748625663, 0.13123978610632026, 0.09934858236877575, 0.12522149225196522, 0.0852650755669121, 0.1076704139321355, 0.1357505798840699, 0.12131926205358379, 0.11508951224820152, 0.11430923283640293, 0.1246237760423986, 0.12588839099025095, 0.12521210963156537, 0.10863481162557309, 0.10817689575153056, 0.1175866068749587, 0.12472558276704981, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007563702650528192, 0.01008934913230164, 0.0867136755063912, 0.09217759191272268, 0.08247376325596811, 0.06754037062267326, 0.06302478415543433, 0.07217968043466916, 0.09967961713221485, 0.07820679644722606, 0.06824461578278374, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07293385140039466, 0.06425906052576225, 0.06480836357904352, 0.08100273613171138, 0.06945884791422796, 0.0672165938179331, 0.09807973155135807, 0.05711724699892873, 0.05926904490564322, 0.38058209760358697, 0.3955907480332935, 0.3763382388830073, 0.3965902093076513, 0.3704860479287859, 0.4014850996472529, 0.3883368146641525, 0.3924675700028346, 0.3949604826997113, 0.0851019414612545, 0.10305038687776236, 0.08716526451390982, 0.09985844443770997, 0.07823069835333718, 0.08834680309706311, 0.08743554054613867, 0.08557660298605974, 0.09102180065992271, 0.14907588476386902, 0.15127083932769236, 0.14632057180576807, 0.14904385941594633, 0.1648168497048177, 0.17334244437170765, 0.15708790438157394, 0.18855413901976226, 0.19481617816666996, 0.2440288660709401, 0.22602985973660616, 0.22567236777670918, 0.24270022475948905, 0.23447059511178747, 0.25055012409754596, 0.23804810991801473, 0.25508385438987713, 0.2507803384532694, 0.16091236674522302, 0.17984720188491776, 0.18709472503804847, 0.1764486081804738, 0.1525582615226564, 0.16713187954734676, 0.17827040166111185, 0.18525765140965134, 0.17268682880699493, 0.20345051161758143, 0.18807973863002014, 0.18294492685654984, 0.18712085957883995, 0.17871714449303067, 0.1978700571608869, 0.18785984443364567, 0.1793317597735533, 0.19743921477424442, 0.17528627336778646, 0.17907952889594492, 0.17431235472365825, 0.17574504289426895, 0.17499736373570118, 0.1840036105179923, 0.17900772318260538, 0.17625445125134664, 0.1809302094503653, 0.17023006013052122, 0.28990854677107336, 0.16757113489880304, 0.19051590471136626, 0.23034197192591754, 0.1419734478987279, 0.22937819073805243, 0.15651118960352595, 0.23056813179285807, 0.3034956226791433, 0.165885197246895, 0.20680628755705943, 0.21694006349319217, 0.24244015665173557, 0.16382961546609365, 0.21735359404322718, 0.21267337243086615, 0.19807019686626726, 0.19295457730656485, 0.17864177842282458, 0.17480697079506535, 0.1812525444645524, 0.18486444214261788, 0.183175832034994, 0.17860920619008813, 0.18876430239118258, 0.1778335493646087, 0.07525025296259025, 0.07253337326807707, 0.0794332367549676, 0.07005211196191863, 0.07307560179517836, 0.07129765749241868, 0.07392665643713336, 0.07805096094510977, 0.07790926691668287]}, "mutation_prompt": null}
{"id": "b4303812-3599-49d7-9ba2-28643886bb39", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.F = 0.6  # Moderate differential weight for balance\n        self.CR = 0.9  # Increased crossover probability for better exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.90  # Adaptive factor for consistent adjustment\n        self.diversity_threshold = 0.1  # Explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Adaptive Learning Rate utilizing explicit diversity maintenance to improve convergence.", "configspace": "", "generation": 49, "fitness": 0.3930771124910674, "feedback": "The algorithm EnhancedMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "37e2daee-0f50-496c-9b35-9c3429db8669", "metadata": {"aucs": [0.8732766226181966, 0.8642243016655347, 0.8659935461581776, 0.8547781410271569, 0.8489843434467998, 0.8291276393042519, 0.8542008358345242, 0.8671068584652082, 0.8460371044231281, 0.754998745647667, 0.6685360222833198, 0.7094896514843003, 0.7032145651648585, 0.682277274361005, 0.6957365976649358, 0.7782177807854866, 0.7414169653758014, 0.7488975639652787, 0.1260365113730908, 0.11863917586582173, 0.12282585325225315, 0.1730225647967698, 0.17523928355619023, 0.13816749343700052, 0.13605050692107412, 0.12476910900380311, 0.13292032060456171, 0.13829873376169632, 0.11018068180767204, 0.1442854808839329, 0.11288557073308203, 0.1733192939832332, 0.09969463812954271, 0.11619831825062776, 0.12149586278962365, 0.10815664397811064, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6290162284567968, 0.5922781557132764, 0.588780814996684, 0.6670225256780604, 0.644425863156447, 0.6348853304366482, 0.51465906649409, 0.6482033543525607, 0.605582459343158, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5206291164262296, 0.12125465973297, 0.12861577462045204, 0.5617507875338423, 0.12736644596554436, 0.7265431498207405, 0.39518306870503206, 0.5366229774522695, 0.40288428683431365, 0.44784254744102214, 0.1288152535756879, 0.49586790605034203, 0.5368670185254014, 0.575537508950831, 0.5203924925143957, 0.5831511620691582, 0.1264497201800464, 0.5038099392266262, 0.49934707714237136, 0.5284834725514336, 9.999999999998899e-05, 0.6010321473736554, 0.382485077859132, 0.36935365984943236, 0.48364233848944393, 0.4198517361019898, 0.27367132718451503, 0.5963278370603864, 0.5224253748143389, 0.4653302118007083, 0.6831886960244166, 0.580173927849811, 0.4952337541702897, 0.5792440662318769, 0.08123422967530491, 0.7078451166151098, 0.0739010626179103, 0.1084619212107013, 0.3855359850948187, 0.3521518163304569, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.43403222200219826, 0.42711740183650415, 0.46483801601092856, 0.03805354803257921, 0.4661126798316374, 0.40871735786607777, 0.3718109253001566, 0.3371319365795915, 0.6948568389807652, 0.6245302587707393, 0.6884578786474407, 0.7321140615795139, 0.6024203182118643, 0.6730790023229437, 0.6518467238363761, 0.6501001592558935, 0.7801717998256352, 0.14314049685128938, 0.09503011201524791, 0.11130418714052726, 0.14066098435242724, 0.10992720434210046, 0.12329404616465311, 0.13665658230927002, 0.13308825011320846, 0.11906316999336908, 0.18600333865198404, 0.2673014954593603, 0.2556784400268317, 0.1639969500449312, 0.16418829342256847, 0.24061537736670835, 0.15552857239351547, 0.20594675517067074, 0.31461537770532055, 0.49199369420021233, 0.34834637766463405, 0.5467715808924283, 0.43074953391482973, 0.500392811902082, 0.40577304191016295, 0.24173248114034063, 0.20595781597406315, 0.5485168868695214, 0.19453192043951406, 0.2703873449117091, 0.4117133465805445, 0.24211103021888292, 0.39158270919502947, 0.4408556271588616, 0.214665216511152, 0.3326676085837589, 0.3686769563545761, 0.22406086113739287, 0.2162592903384254, 0.26643093577723, 0.22076107381384635, 0.2130608649876382, 0.21791115593653, 0.21324382202328362, 0.1841692469811571, 0.23955364122471723, 0.7758472744891161, 0.19081196702814418, 0.20592291284862474, 0.18665042546779664, 0.20165006658640328, 0.19146475586217948, 0.196949486636246, 0.18052241226414334, 0.199244686156535, 0.16398331650145992, 0.18666358427992769, 0.9130595737841963, 0.10337077808419859, 0.16896991770819714, 0.16737607409133837, 0.1865383984864062, 0.12487727769843693, 0.8394302306900628, 0.8918762231358082, 0.15613242217346068, 0.886246531723765, 0.20984586224128066, 0.8537568020847193, 0.1615534138203335, 0.10458026021234912, 0.16621803419387982, 0.8676933569508227, 0.1801010290889843, 0.1861849159422556, 0.1810781877376637, 0.17079458853552554, 0.18721586379369282, 0.1805003181901007, 0.16824230993890488, 0.1735854651922597, 0.18195722678289739, 0.10159357200343222, 0.0960010997993137, 0.09013961566952788, 0.08537947729245021, 0.09032768963826765, 0.11212037078744308, 0.08284381425380383, 0.08679771977119677, 0.07310908540901806]}, "mutation_prompt": null}
{"id": "92b26c88-74c3-41ba-967f-d8f6f87057c7", "solution": "import numpy as np\n\nclass AdaptiveMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 5 * dim  # Adjusted population size for enhanced diversity\n        self.F = 0.7  # Adjusted differential weight for improved mutation strength\n        self.CR = 0.8  # Adjusted crossover probability for better balance\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Modified adaptive factor for enhanced performance\n        self.diversity_threshold = 0.15  # Increased diversity threshold for stronger diversity maintenance\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-4:  # Slightly relaxed convergence criteria\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.9)  # Expanded clipping range for adaptability\n                    self.CR = np.clip(self.CR, 0.4, 0.95)\n\n            if stagnation_counter > self.population_size * 0.5:  # Adjusted stagnation condition\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.2:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticEvoStrategy", "description": "Adaptive Memetic Evolutionary Strategy with Stochastic Gradient Adaptation and Diversity Reinforcement.", "configspace": "", "generation": 50, "fitness": 0.35915043363953775, "feedback": "The algorithm AdaptiveMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8517089881107662, 0.8509066938672518, 0.865305212740048, 0.8474779154678824, 0.8409253867449997, 0.8590342568785861, 0.8786897479360198, 0.8462304293031082, 0.8567794667765882, 0.7669460324580455, 0.6376094841504811, 0.7512481876796051, 0.7363201580068196, 0.7542116740803236, 0.74748652159107, 0.6628705261218577, 0.7347009131179899, 0.7313277254716382, 0.14662857747337854, 0.13527409651517341, 0.12373927583908206, 0.14567008308525786, 0.14501208355039874, 0.11946035299888302, 0.14799337569153903, 0.6946390626901469, 0.7170324328848415, 0.11576152236396808, 0.10675865888559166, 0.16646388648491262, 0.1350541358330022, 0.09534174963255815, 0.11299307133210346, 0.12435933836799018, 0.07760369541124457, 0.1335489444098351, 0.987316918582881, 0.9683085803662954, 0.9845501481163322, 0.9887357032519734, 0.9760738081100311, 0.9822505324363713, 0.9739731980525776, 0.9725390011806537, 0.9928554853024926, 0.5367987939676004, 0.058102891832461534, 0.5118346189551143, 0.6264760064154957, 0.5675150251047003, 0.5988555713045837, 0.541810196380865, 0.4900108443917791, 0.5081343620885979, 0.2088794625827558, 0.3532981220941781, 0.22329726219554558, 0.21159887859133175, 0.7323226100378613, 0.202306483049973, 0.7897622718044094, 0.8291115157029488, 0.8241760789853525, 0.3767650819899927, 0.37894684527426303, 0.5466822537956825, 0.10697938177646882, 0.5863761449952649, 0.5098167614790294, 0.659950367899091, 0.6370122915219125, 0.4741955039430492, 0.5694311329917816, 0.44742169539940746, 0.12960977632734394, 0.12512966221588906, 0.48914342130337196, 0.3814312230880512, 0.4541750173136968, 0.5002445829365797, 0.42741773355456547, 0.20334612825873255, 0.37809002627163035, 0.32445345109594625, 9.999999999998899e-05, 0.3260908242287436, 0.2581491114604574, 0.3859781127949041, 0.08069953630725979, 0.06280856306951643, 0.42587802866298397, 0.3756112772331931, 0.2847950314176154, 0.08857411201696652, 0.23817750651546232, 0.18015499796700463, 0.5589408366721732, 0.22055538184116463, 0.28882462498831674, 0.24304149536240316, 0.06934142316931124, 0.23487421926657093, 0.2156222540772602, 0.07504249269201158, 0.2855649816832382, 0.10907273153591301, 0.09923267093826837, 0.2577531354723226, 0.29387577964595835, 0.19243151368504297, 0.35329395771803196, 0.3868125719571279, 0.2232170658127819, 0.3394271938623914, 0.31896276715161, 0.296382007986455, 0.26738118410187384, 0.5960182422638918, 0.5784089345606246, 0.662837031575721, 0.6226484920381673, 0.5988269440970214, 0.5562712213171228, 0.6206144229955687, 0.6307355382578037, 0.585912670109124, 0.06890216168498664, 0.07800084453797174, 0.12538052432903224, 0.12987307146989147, 0.09088886063657142, 0.11993240772629166, 0.10481651460882513, 0.11214483526898233, 0.13947864235776342, 0.32942930361612865, 0.18818564598396592, 0.17814333576635633, 0.1608584868350632, 0.18386542273458617, 0.12679203141669604, 0.15544979280469795, 0.2107881033138128, 0.2505624101564581, 0.4596923645852886, 0.5770984725654, 0.4972669511946334, 0.43982866692578504, 0.39596542780826405, 0.43511349567617685, 0.5210365127923877, 0.5054377662523748, 0.4248908418642432, 0.17677024260359175, 0.2889701039647816, 0.16997399262286506, 0.3171599737697398, 0.24994914800432144, 0.22422489730428863, 0.39001798092759477, 0.3440104046780298, 0.4021012909633753, 0.19804543839529998, 0.19471034692702005, 0.22141632413713686, 0.19284515875957864, 0.19188246973453282, 0.16634351176296136, 0.1961300591549514, 0.1876874974936955, 0.2003146216404833, 0.21374576390234856, 0.7015220835134294, 0.24666578853160115, 0.22077994422108327, 0.18944554557202897, 0.20321618429458688, 0.22075616365787365, 0.1961225811292322, 0.24410719485604437, 0.16177115745935566, 0.1398345534122284, 0.8175501553859472, 0.12906132265824033, 0.17750217207210572, 0.1863139871934575, 0.16792318532023842, 0.18554195478045832, 0.1868985913410135, 0.08221790831702236, 0.15495836084231707, 0.7672590058817682, 0.1116830602394846, 0.1656812256648249, 0.16643239348953887, 0.129501558204972, 0.10882464362748667, 0.11119588694779536, 0.18102929738095808, 0.183509792143969, 0.17941754550056122, 0.18444564148429476, 0.1773989921351753, 0.16769713717857127, 0.17573299237752982, 0.18545000942759648, 0.17872959293798107, 0.07503068565620452, 0.09478804519985151, 0.08230232107093072, 0.07464294588557119, 0.07995584918221843, 0.09183712892197471, 0.0936340139771995, 0.08009040480715268, 0.08234513381975539]}, "mutation_prompt": null}
{"id": "defe359d-5e3f-45d6-8319-79c604c7d9ac", "solution": "import numpy as np\n\nclass AdaptiveMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 5 * dim  # Smaller size for more focused search\n        self.F = 0.7  # Adjusted differential weight for better adaptation\n        self.CR = 0.85  # Slightly reduced crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.92  # Adjusted adaptive factor\n        self.diversity_threshold = 0.05  # Tightened diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-4:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.2 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticEvoStrategy", "description": "Adaptive Memetic Evolution Strategy with Stochastic Restart and Dynamic Scaling for Enhanced Exploitation and Exploration Balance.", "configspace": "", "generation": 51, "fitness": 0.3634598086784828, "feedback": "The algorithm AdaptiveMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.84173039948515, 0.8489463097724728, 0.8731579458278209, 0.8263118886701231, 0.8319361218776379, 0.8426383200921194, 0.8493819805889211, 0.8463255485904224, 0.8345201711363837, 0.7165892026948135, 0.0763109798073599, 0.6039363401158688, 0.6592729797784809, 0.6964577101215434, 0.6810649338900094, 0.7324111283723937, 0.7366034938978617, 0.5589286633221062, 0.17625231183068024, 0.1724629729515873, 0.5940142613917292, 0.18145729484973794, 0.1305461032373283, 0.15417234427689042, 0.13578188825742077, 0.14122151241254255, 0.1242847519055964, 0.14063017521850885, 0.0906794310874458, 0.14453654603966826, 0.09501515591693555, 0.10511067354751036, 0.12483568488977814, 0.13351590424609983, 0.10357618103453192, 0.14982695337938, 0.9524502876002671, 0.9867041138738536, 0.9496221199032098, 0.9537402884468, 0.9643615321459208, 0.9422141832044887, 0.9700506542334519, 0.9651059060822351, 0.9587213031692111, 0.5995040073778543, 0.5549903863687258, 0.5153084136441153, 0.5572649332062267, 0.6007909928531641, 0.6085833942775185, 0.650005028156226, 0.5669153537298168, 0.6701474956971237, 0.8154145102287288, 0.3614272344620455, 0.11824046934948695, 0.8602330458380565, 0.20882887767868585, 0.21205177747360104, 0.22720827100690943, 0.23995257477443532, 0.7719565719364849, 0.4470273657665019, 0.5396921161297972, 0.49943811752247813, 0.35268192044658797, 0.1281728418536926, 0.5771704256817923, 0.43672998595544055, 0.43260635942768977, 0.518983177047751, 0.45811520774008285, 0.5434481409522676, 0.11763281119730551, 0.12887879204892816, 0.553334724884337, 0.668066078141802, 0.3885593951486793, 0.5359982858983068, 0.47338248173896214, 0.3780694240372414, 0.22541729665365973, 0.18389431201228257, 0.5204890019541453, 0.09487923925875641, 0.3937545895163723, 0.1445893470615225, 0.5171635315579906, 0.0619761842700387, 0.41972320270880903, 0.08818266051512147, 0.49192969232666117, 0.02488885720316447, 0.07039193914882691, 0.3829368661332283, 0.6214686600065509, 0.05610950178876628, 0.5938038560919884, 0.07238805340619658, 0.06866646605701121, 0.06964300938529211, 0.265767046227696, 0.2837230859676865, 0.23567960016101952, 0.27576207699319877, 0.10280956469531632, 0.18427339791683084, 0.3893787818110076, 0.3591556913844849, 0.34309166030097527, 0.41197453526568917, 0.3188973245326565, 0.3167831214445824, 0.3446233292790123, 0.3256314323300741, 0.4000170207349518, 0.7377124255573224, 0.623906807614856, 0.5856832096455127, 0.6017288914502616, 0.5975706210544343, 0.6246091593664108, 0.6567171783378964, 0.5461339980431599, 0.6352983383339762, 0.11700094263220895, 0.14967304247765656, 0.1277300199425706, 0.09158420774082421, 0.1119682893108287, 0.14971833589122374, 0.11131333828340062, 0.14300216015176903, 0.111554860046988, 0.2207299296387617, 0.20361420106673012, 0.16646677540905908, 0.18381185002425415, 0.18808129406553642, 0.11883509232925282, 0.17854320709286453, 0.1085015714951938, 0.3202978494239016, 0.41646264597007665, 0.24913310724714188, 0.33508092905166864, 0.5125723444768695, 0.23160265104348854, 0.45474587804043964, 0.44483526449668476, 0.28714201690897545, 0.3093906282598189, 0.24600625923613428, 0.4046686197419431, 0.2657525742216126, 0.22726457455771565, 0.2577447595503788, 0.20481869134876984, 0.33533230942542247, 0.3981672116332483, 0.2197464069079611, 0.21951261841510827, 0.17651759455558913, 0.20234405570889946, 0.18166759257689902, 0.19124389195810043, 0.19575571245667367, 0.1872571592266732, 0.21648660204204284, 0.20382340689111167, 0.24476173448423844, 0.2161848441399974, 0.19002932052860078, 0.2190938309675846, 0.2278058508433507, 0.1826841646994677, 0.19346904497304462, 0.24461637297764027, 0.24281535490481476, 0.19676410902919628, 0.1504587496716584, 0.16632529580363442, 0.15593370722076083, 0.8927265232295001, 0.18869393734834716, 0.1681319529723041, 0.10633393185680595, 0.16376606052095666, 0.8658789806892908, 0.836957088580322, 0.854384067930884, 0.16160357799377967, 0.16299207124526216, 0.8429340705475297, 0.10525332814151811, 0.45207930489315673, 0.1640290550499467, 0.17356032852786807, 0.17594588126787858, 0.1898684732177821, 0.20154864682894202, 0.17937143244801557, 0.17529708487923779, 0.1777995678096086, 0.16891742661638742, 0.17422623551932703, 0.07978646678142887, 0.0878066937402906, 0.07948507784736958, 0.07368293059051378, 0.08617141375735915, 0.07810435785572467, 0.08333865621003755, 0.0778076968476884, 0.08694129123221772]}, "mutation_prompt": null}
{"id": "7225af1d-24d3-4c2e-96bd-69655663951d", "solution": "import numpy as np\n\nclass SelfAdaptiveMemeticStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim\n        self.F = 0.5\n        self.CR = 0.8\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85\n        self.diversity_threshold = 0.15\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.4, 0.95)\n\n            if stagnation_counter > self.population_size * 0.5:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "SelfAdaptiveMemeticStrategy", "description": "Self-Adaptive Memetic Strategy utilizing dynamic diversity control and incremental mutation to improve global search efficacy.", "configspace": "", "generation": 52, "fitness": 0.368257745339089, "feedback": "The algorithm SelfAdaptiveMemeticStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.909575180349356, 0.8915268710323363, 0.9024090302746948, 0.888572866908343, 0.8929335039394801, 0.8749520304717661, 0.8906595284649108, 0.8976020901920371, 0.9108663271266815, 0.798725654686202, 0.7954039057045958, 0.8136604080675746, 0.7639020898286233, 0.7713003351678889, 0.741417917105631, 0.7769848736667802, 0.8376508246759478, 0.7711059307603751, 0.08236410152320517, 0.17696851187815388, 0.09605496212723197, 0.6572687407299568, 0.7041198753043902, 0.096050927039113, 0.08031295690294082, 0.18612294594759415, 0.15169652332393346, 0.1067621263780234, 0.08561756975888513, 0.11462235819323507, 0.1070591496455352, 0.11293721390123301, 0.11237443367617672, 0.1277316270891794, 0.17276929571627408, 0.135293102591155, 0.9841206181546536, 0.9678791487559685, 0.9621028108658282, 0.967244352307516, 0.9561532594070073, 0.9754072360545897, 0.9685093252963087, 0.9880726327874257, 0.9902417251262393, 0.6926487380699103, 0.7121930757888814, 0.7268589866726345, 0.6610669492118213, 0.6642857811318283, 0.7025072225035303, 0.6707148829652047, 0.6940870678994266, 0.700744614313563, 0.38494552897896284, 0.862509124337292, 0.35562362218397314, 0.3761765299141787, 0.1895516907087299, 0.8870812988282955, 0.1430941711877427, 0.17246948354756964, 0.36744017535769513, 0.6130766539855119, 0.7561926761808109, 0.47800271495174507, 0.3744905952765344, 0.12113804721164068, 0.13338370198596872, 0.13130226372738596, 0.38288067819337923, 0.5231592720249334, 0.48125353986952246, 0.19218850907176244, 0.12977219513224048, 0.499201277331236, 0.7449595191467917, 0.4989989086587867, 0.617514822911555, 0.13381368084024503, 0.48293033444290856, 0.08651120364151177, 0.18391395037276315, 0.027690036440684018, 0.0001360747535290585, 0.05753200856935259, 0.11931982880751235, 0.11468009385966238, 0.09870595951306826, 0.0497040467309362, 0.26041634302995165, 0.23959515264531683, 0.4188318187971346, 0.29315239883660893, 0.08766446477528622, 0.07963352404179036, 0.10911291769712606, 0.32346947708860185, 0.20267944993413334, 0.09314386146662268, 0.07852989498493823, 0.39056503519887853, 0.31904303633050746, 0.23927428792820926, 0.19603413796890856, 0.24853889782494942, 0.15741268385344143, 0.07430214695875714, 0.30406811371885756, 0.35696978860832285, 0.4112649027962709, 0.3561046155924591, 0.3797229182148856, 0.35615749233152316, 0.30834032627012664, 0.21028600639792805, 0.24039367574611226, 0.6103240736953829, 0.6347214259459751, 0.6804891094125128, 0.6678447092609163, 0.6476283421861231, 0.680544541377176, 0.5804113629853184, 0.6206282023484504, 0.6226666106768612, 0.10698147394263302, 0.18145475676329437, 0.140377407487973, 0.12516785258328678, 0.13366472550384845, 0.1421381061470598, 0.1264489270381315, 0.10276068629639923, 0.12773254236610188, 0.1711889360365667, 0.29854622431574185, 0.2656007009453206, 0.18874576875032567, 0.16523187959604324, 0.21498617300417677, 0.2697484086295636, 0.2157877517418616, 0.1664282298708022, 0.4586118452458601, 0.4584528931339539, 0.3252770022708046, 0.3303105225380395, 0.40237098663452264, 0.6284774225784204, 0.3361616489002447, 0.2759187064056956, 0.2375068364007702, 0.3730534829123582, 0.3727911915027198, 0.11672985163089855, 0.17472871588152994, 0.44375529469382935, 0.1270971481480344, 0.25466222613937406, 0.23764913723986159, 0.1542893756489122, 0.21817873130978516, 0.19219480268115707, 0.19470388862751442, 0.1793585004028655, 0.20390961697864252, 0.19770852233305836, 0.2002961059912467, 0.19718202606144497, 0.19599414173968677, 0.19632208720675715, 0.18301378430058868, 0.19710175087662352, 0.19714771184785018, 0.20254592634043267, 0.1885976239083189, 0.17437232216802312, 0.19558178029644024, 0.1727614438019791, 0.18692580612621623, 0.9054871685545068, 0.15812717484255567, 0.09771375960631812, 0.9095972138743111, 0.17343612570237, 0.15980338118414927, 0.16560933332123018, 0.16850072324842003, 0.8922910452323748, 0.16821746528980608, 0.8725218102928483, 0.781585251462199, 0.20851289044296073, 0.8758595426518834, 0.10473237156577486, 0.15523936783480052, 0.12821883362122422, 0.16863441719045746, 0.16725536095841398, 0.2130407837947248, 0.1752687176493093, 0.17240205766796335, 0.1829246346723037, 0.17218628565850014, 0.18283839830651916, 0.16670143271543003, 0.08780474690868523, 0.0769856104643808, 0.08472776295580475, 0.11065629065789162, 0.10306420717161058, 0.08916957255537727, 0.08086838689340403, 0.09093895626685533, 0.09649631703970407]}, "mutation_prompt": null}
{"id": "5e0d48d9-0a7f-46b9-91f2-9f7ef63fb835", "solution": "import numpy as np\n\nclass AdaptiveMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 4 * dim  # Further reduced population size for agility\n        self.F = 0.5  # Balanced differential weight\n        self.CR = 0.8  # Moderate crossover probability for exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand-to-best'\n        self.adaptive_factor = 0.85  # Lower adaptive factor for stability\n        self.diversity_threshold = 0.2  # Broader diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'rand-to-best':\n            return self.population[a] + self.F * (self.best_solution - self.population[a]) + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 5:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand-to-best'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1, self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticEvoStrategy", "description": "Adaptive Memetic Evolutionary Strategy with Stochastic Learning Rate and Diversity-driven Mutation for improved convergence.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {}, "mutation_prompt": null}
{"id": "b346df0f-dfe4-4ab4-bdd5-e44815c5d440", "solution": "import numpy as np\n\nclass AdaptiveMemeticDiffStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 5 * dim  # Adjusted population size for efficiency\n        self.F = 0.7  # Adjusted differential weight for improved exploration\n        self.CR = 0.85  # Adjusted crossover probability for effective exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Adaptive factor for gradual adjustments\n        self.diversity_threshold = 0.05  # Stricter diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 5:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.4, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.5 and stagnation_counter > self.population_size * 0.5:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticDiffStrategy", "description": "Adaptive Memetic Differential Strategy with Dynamic Mutation and Stagnation-Aware Walks for Improved Convergence.", "configspace": "", "generation": 54, "fitness": 0.31525538053598007, "feedback": "The algorithm AdaptiveMemeticDiffStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8495398493860649, 0.8337050751034032, 0.8704397243011422, 0.8203977949945367, 0.8344087589830187, 0.836980406268748, 0.8576086362199419, 0.8425819570462947, 0.8442483903005878, 0.7268350772023782, 0.07631097996999836, 0.6250808332141703, 0.6727280901096133, 0.704152675418418, 0.6754104718064426, 0.7275469290143723, 0.7404334370370045, 0.5540401845905953, 0.17995604066347637, 0.17530320653498244, 0.6613861600236517, 0.15739641169779295, 0.1387260754463714, 0.1561121324957343, 0.17430392601062306, 0.12034654265855538, 0.15017080964117335, 0.12304570998240927, 0.14087861284562186, 0.1351645742303339, 0.11540019548951364, 0.14514475679097616, 0.13765271660318068, 0.11210198495047552, 0.14719066618508891, 0.1737240521770822, 0.9524502876002671, 0.9867041138738536, 0.9496221199032098, 0.9537402884468, 0.9643615321459208, 0.9422141832044887, 0.9700506542334519, 0.9651059060822351, 0.9587213031692111, 0.5789191670762777, 0.5978451223410421, 0.625429696707671, 0.5661224233450267, 0.5857612986085154, 0.5750742131940181, 0.44347881292114444, 0.471108846065892, 0.5304730017243624, 0.36935246911863995, 0.8016904113768814, 0.13956446873827588, 0.7381574082487548, 0.20878319087124186, 0.2120564987241611, 0.22665201474119645, 0.235434409687449, 0.2317600494363351, 0.2325007707345319, 0.5094006750809728, 0.4403226975795749, 0.36436982950941355, 0.12827174006330133, 0.2585358584291356, 0.2768557546562065, 0.34424324227503356, 0.22572412208491055, 0.20583736841453915, 0.20761556068865372, 0.10615341507768794, 0.30794016734743235, 0.3161517142817023, 0.47220766212910414, 0.12988384577826562, 0.30588325122388693, 0.29587315450486273, 0.0032664674378629632, 0.07423037300222224, 0.07610185443773387, 0.010571404295517284, 0.05968655212124341, 0.06874293989449909, 0.2632145179204921, 0.031992861728254884, 0.08517662025524753, 0.12365400999823961, 0.03933793149525222, 0.08149029592202384, 0.0844381481966946, 0.06798163801650248, 0.07466955865332636, 0.3473701195004777, 0.08368270839018366, 0.10141192011241706, 0.05507799346077624, 0.02481260030468513, 0.03503713603407088, 0.11472714341477408, 0.15020645515466313, 0.10054236284636231, 0.11368095625625885, 0.09309728220263547, 0.14520630297943748, 0.21544965086650436, 0.2577368711634346, 0.22136520306510377, 0.3595866894124733, 0.14142096033446683, 0.29999641609347727, 0.17354027420531926, 0.1083956335391737, 0.24511591182879777, 0.6967891476401062, 0.5652238309083204, 0.5870958256750932, 0.6217536534810968, 0.6165359663674542, 0.6086557107921513, 0.5821438873651443, 0.6104572425687079, 0.6051264435435242, 0.09020446532245274, 0.1594218705113173, 0.10316035036637228, 0.10265853314324447, 0.09624234349430683, 0.1322531308811531, 0.09990913531632573, 0.13973851644513635, 0.09271036786395692, 0.16411177181890357, 0.1498833451648448, 0.15432644629782355, 0.22789803845650536, 0.21895134282912498, 0.1354975017875435, 0.18041059601816212, 0.1965396053825672, 0.224264775115112, 0.44628395856702574, 0.24121061846905456, 0.37923105174949445, 0.34153142544730253, 0.21381733502183953, 0.306334452860486, 0.3888744620288648, 0.2861841488957999, 0.40480741720175606, 0.21187855038117698, 0.15696694427801428, 0.1872459800201639, 0.22175071579526395, 0.19848216926412132, 0.20231118591914332, 0.2224201877450649, 0.25244874304716525, 0.19687989702481778, 0.21525772494669304, 0.17916636987676537, 0.18811425506802282, 0.19932250063171497, 0.18291761988856647, 0.17538612136488463, 0.22954144139238064, 0.18504738226174033, 0.22535469410692766, 0.22203801813732105, 0.21796726552596002, 0.19726291760842418, 0.21953845021041063, 0.19813766062919003, 0.18343982464960118, 0.21471785681689082, 0.24353676678342995, 0.22752385120319107, 0.19843820917415955, 0.15045874960587458, 0.14065355240545563, 0.15594016967026292, 0.865371891257765, 0.18871074636936924, 0.1682344584301274, 0.18395166421795817, 0.16427323838339414, 0.855667217137259, 0.7137570294981503, 0.7999981605159303, 0.16234085067424364, 0.1633854748487492, 0.7448702204433719, 0.10525344054821673, 0.4520696678019095, 0.16441240681428537, 0.18516644459157428, 0.18045815468861381, 0.18685863307623163, 0.19516064272973832, 0.17606131381974843, 0.17576599981810725, 0.1637702164767355, 0.17571193545570474, 0.17018511282894255, 0.0811371190986594, 0.0799314943686783, 0.07649120147905597, 0.06984271021293353, 0.07371999518246064, 0.07841293773913327, 0.06949923526408963, 0.08739891028652114, 0.0900348501032413]}, "mutation_prompt": null}
{"id": "0cabe948-67b2-4793-a2ac-3ed11140f29c", "solution": "import numpy as np\n\nclass StochasticMemeticDifferentialStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Slightly larger population for diversity\n        self.F = 0.5  # Lower differential weight for finer adjustments\n        self.CR = 0.85  # High crossover probability but slightly reduced\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Slightly higher adaptive factor\n        self.diversity_threshold = 0.05  # Lower diversity threshold for more innovation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.7)\n                    self.CR = np.clip(self.CR, 0.6, 0.9)\n\n            if stagnation_counter > self.population_size / 2:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.5 and stagnation_counter > self.population_size * 0.2:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "StochasticMemeticDifferentialStrategy", "description": "Stochastic Memetic Differential Strategy with Adaptive Crossover and Mutation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 55, "fitness": 0.3778100650326425, "feedback": "The algorithm StochasticMemeticDifferentialStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8641208531798673, 0.8626424688705274, 0.8868439562123267, 0.8656683773360151, 0.8713110921383489, 0.8798876909180146, 0.8812649645361399, 0.8457169693477057, 0.8849099317767065, 0.8058760047675225, 0.7512175454498073, 0.7796703659249332, 0.727149678994293, 0.6535433296540111, 0.7606430812907972, 0.7648792056216398, 0.7378965979488865, 0.7794099833724797, 0.12850043138896472, 0.15093493874689434, 0.04290366471384277, 0.1290115322037445, 0.15018912285767272, 0.13715531638365297, 0.1549938496232971, 0.15721609745967124, 0.09060383787829196, 0.17654662009307465, 0.10445075904630485, 0.1292750698453703, 0.11472273923427545, 0.1068816843375131, 0.10157357694773017, 0.14184539455158862, 0.09479399151401935, 0.09604069063680132, 0.9387293943015591, 0.9575516347232472, 0.9616863016826497, 0.9846516090585838, 0.9740523524887679, 0.9644390326400022, 0.9679255026575643, 0.9494961256965725, 0.9762264806102366, 0.6528241405948682, 0.6618597009880098, 0.6425818428387606, 0.6736214236503049, 0.6867575825327998, 0.6156052053280041, 0.6767600481442404, 0.6132091527821366, 0.6558055649140406, 0.20829445470427488, 0.8681905826319267, 0.22251029139560663, 0.2719227923098255, 0.8620273509568289, 0.8872173050307608, 0.16558167297563964, 0.8534925198243724, 0.17654781822227306, 0.4860164982754699, 0.530919412183136, 0.4903413329183073, 0.6502272843094348, 0.13262763442040126, 0.4280141259873973, 0.46834707682237176, 0.6782752438201307, 0.6348055021434624, 0.5386645762810699, 0.4595834302604427, 0.590497894051262, 0.5978614315519152, 0.3800921531407131, 0.46135335056006865, 0.6815884659648386, 0.5847111600232187, 0.45957875220957456, 0.4197487879538433, 0.06708776809732586, 0.41585251704077697, 0.00459051071237937, 0.15223845707886197, 0.005400401082816808, 0.5063697326418175, 0.4029266695162169, 0.547072078148753, 0.30161680377492517, 0.439842302237168, 0.24256914548019903, 0.18454832341586414, 0.23325187020719573, 0.38954773718844204, 0.7122818797025972, 0.27524498702980327, 0.6096913271055007, 0.2442296823361817, 0.06750771173681513, 0.14830600448783038, 0.430526102032025, 0.2201678496162509, 0.1357086968958463, 0.10084217396252171, 0.13380445811273167, 0.13079542801983302, 0.45626571231905855, 0.32436431175599323, 0.4242270171382335, 0.3748861655451994, 0.1559056743512669, 0.38642198534702454, 0.0812015546423952, 0.2692140771708076, 0.33216789573734895, 0.6636898357469705, 0.669450495605143, 0.7241266639642351, 0.6293618248062631, 0.7253918643659116, 0.6616177856707022, 0.6723126655115952, 0.673612591007724, 0.7077884450500358, 0.1042222578465346, 0.1097066658580721, 0.07904942052375696, 0.1836752332896311, 0.14693074492978253, 0.1378886941265024, 0.06958818066685124, 0.10896275410163503, 0.15022253491849336, 0.17696756526404678, 0.19922781262827038, 0.17242589059202984, 0.41113828607711844, 0.2752094274615683, 0.2538447442330979, 0.24241858030583852, 0.23212343988572381, 0.15521750051616068, 0.2549212017008028, 0.2744527009358543, 0.5099183487418978, 0.4665208713584711, 0.4411868454444253, 0.5007496484986876, 0.4536903968051216, 0.30486636893549723, 0.487276627456123, 0.14940810719093822, 0.32539005527858866, 0.2221037615004683, 0.2586020681394092, 0.32442555542108253, 0.2847076739366071, 0.2570088154267093, 0.29349620916608976, 0.21966106769523275, 0.2176468075757264, 0.18673295070173235, 0.20992739190054188, 0.24487500581575516, 0.22829522384704326, 0.18694278246461882, 0.21010510730944776, 0.2046457269163945, 0.24673688829888563, 0.21568185796991268, 0.24039796613466202, 0.24458862879467946, 0.21767566650145231, 0.2115845214675478, 0.19516961064010563, 0.21959651574643257, 0.24051433933904032, 0.20782521877434257, 0.1831497370962345, 0.15570616721780484, 0.17054822539094183, 0.8966319917512879, 0.1977085654636408, 0.15317041628236805, 0.16121254927366613, 0.17206704469774237, 0.16471546327088038, 0.11312543399784958, 0.20968477406558228, 0.11271764544621088, 0.1678689334138811, 0.21103979270448736, 0.15485163643502386, 0.8691490604502425, 0.16344202032367772, 0.16399375942304217, 0.19067220351301462, 0.20065872033233934, 0.1825774840500819, 0.18626690408120505, 0.1727749808458191, 0.20335095938715309, 0.17808570871709672, 0.18540777022914612, 0.17620489862383815, 0.0947385439812164, 0.08847688657829289, 0.07450383510931202, 0.09173680183998001, 0.07819147055516873, 0.10826944842830821, 0.08121417178891166, 0.07385829772112718, 0.06591288274852325]}, "mutation_prompt": null}
{"id": "47d52917-4c55-4e7d-9464-5f77806f08c0", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.F = 0.6  # Moderate differential weight for balance\n        self.CR = 0.9  # Increased crossover probability for better exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.90  # Adaptive factor for consistent adjustment\n        self.diversity_threshold = 0.1  # Explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Adaptive Learning Rate utilizing explicit diversity maintenance to improve convergence.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8732766226181966, 0.8642243016655347, 0.8659935461581776, 0.8547781410271569, 0.8489843434467998, 0.8291276393042519, 0.8542008358345242, 0.8671068584652082, 0.8460371044231281, 0.754998745647667, 0.6685360222833198, 0.7094896514843003, 0.7032145651648585, 0.682277274361005, 0.6957365976649358, 0.7782177807854866, 0.7414169653758014, 0.7488975639652787, 0.1260365113730908, 0.11863917586582173, 0.12282585325225315, 0.1730225647967698, 0.17523928355619023, 0.13816749343700052, 0.13605050692107412, 0.12476910900380311, 0.13292032060456171, 0.13829873376169632, 0.11018068180767204, 0.1442854808839329, 0.11288557073308203, 0.1733192939832332, 0.09969463812954271, 0.11619831825062776, 0.12149586278962365, 0.10815664397811064, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6290162284567968, 0.5922781557132764, 0.588780814996684, 0.6670225256780604, 0.644425863156447, 0.6348853304366482, 0.51465906649409, 0.6482033543525607, 0.605582459343158, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5206291164262296, 0.12125465973297, 0.12861577462045204, 0.5617507875338423, 0.12736644596554436, 0.7265431498207405, 0.39518306870503206, 0.5366229774522695, 0.40288428683431365, 0.44784254744102214, 0.1288152535756879, 0.49586790605034203, 0.5368670185254014, 0.575537508950831, 0.5203924925143957, 0.5831511620691582, 0.1264497201800464, 0.5038099392266262, 0.49934707714237136, 0.5284834725514336, 9.999999999998899e-05, 0.6010321473736554, 0.382485077859132, 0.36935365984943236, 0.48364233848944393, 0.4198517361019898, 0.27367132718451503, 0.5963278370603864, 0.5224253748143389, 0.4653302118007083, 0.6831886960244166, 0.580173927849811, 0.4952337541702897, 0.5792440662318769, 0.08123422967530491, 0.7078451166151098, 0.0739010626179103, 0.1084619212107013, 0.3855359850948187, 0.3521518163304569, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.43403222200219826, 0.42711740183650415, 0.46483801601092856, 0.03805354803257921, 0.4661126798316374, 0.40871735786607777, 0.3718109253001566, 0.3371319365795915, 0.6948568389807652, 0.6245302587707393, 0.6884578786474407, 0.7321140615795139, 0.6024203182118643, 0.6730790023229437, 0.6518467238363761, 0.6501001592558935, 0.7801717998256352, 0.14314049685128938, 0.09503011201524791, 0.11130418714052726, 0.14066098435242724, 0.10992720434210046, 0.12329404616465311, 0.13665658230927002, 0.13308825011320846, 0.11906316999336908, 0.18600333865198404, 0.2673014954593603, 0.2556784400268317, 0.1639969500449312, 0.16418829342256847, 0.24061537736670835, 0.15552857239351547, 0.20594675517067074, 0.31461537770532055, 0.49199369420021233, 0.34834637766463405, 0.5467715808924283, 0.43074953391482973, 0.500392811902082, 0.40577304191016295, 0.24173248114034063, 0.20595781597406315, 0.5485168868695214, 0.19453192043951406, 0.2703873449117091, 0.4117133465805445, 0.24211103021888292, 0.39158270919502947, 0.4408556271588616, 0.214665216511152, 0.3326676085837589, 0.3686769563545761, 0.22406086113739287, 0.2162592903384254, 0.26643093577723, 0.22076107381384635, 0.2130608649876382, 0.21791115593653, 0.21324382202328362, 0.1841692469811571, 0.23955364122471723, 0.7758472744891161, 0.19081196702814418, 0.20592291284862474, 0.18665042546779664, 0.20165006658640328, 0.19146475586217948, 0.196949486636246, 0.18052241226414334, 0.199244686156535, 0.16398331650145992, 0.18666358427992769, 0.9130595737841963, 0.10337077808419859, 0.16896991770819714, 0.16737607409133837, 0.1865383984864062, 0.12487727769843693, 0.8394302306900628, 0.8918762231358082, 0.15613242217346068, 0.886246531723765, 0.20984586224128066, 0.8537568020847193, 0.1615534138203335, 0.10458026021234912, 0.16621803419387982, 0.8676933569508227, 0.1801010290889843, 0.1861849159422556, 0.1810781877376637, 0.17079458853552554, 0.18721586379369282, 0.1805003181901007, 0.16824230993890488, 0.1735854651922597, 0.18195722678289739, 0.10159357200343222, 0.0960010997993137, 0.09013961566952788, 0.08537947729245021, 0.09032768963826765, 0.11212037078744308, 0.08284381425380383, 0.08679771977119677, 0.07310908540901806]}, "mutation_prompt": null}
{"id": "bff6d03a-ab8f-4c60-b213-6f267b24577c", "solution": "import numpy as np\n\nclass HybridMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 5 * dim  # Adjusted population size for efficiency\n        self.F = 0.5  # Balanced differential weight for exploration\n        self.CR = 0.85  # High crossover probability for diversity\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'target-to-best'\n        self.adaptive_factor = 0.92  # Adaptive factor for dynamic adjustment\n        self.diversity_threshold = 0.15  # Increased diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'target-to-best':\n            return self.population[idx] + self.F * (self.best_solution - self.population[idx]) + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.7)\n                    self.CR = np.clip(self.CR, 0.5, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'target-to-best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.2:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridMemeticDE", "description": "Hybrid Memetic Differential Evolution with Adaptive Mutation and Crossover for Enhanced Global Search and Local Exploitation", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {}, "mutation_prompt": null}
{"id": "498c0ed5-10a3-46b2-9559-946b6ee67ec4", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.F = 0.6  # Moderate differential weight for balance\n        self.CR = 0.9  # Increased crossover probability for better exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.90  # Adaptive factor for consistent adjustment\n        self.diversity_threshold = 0.1  # Explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Adaptive Learning Rate utilizing explicit diversity maintenance to improve convergence.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8732766226181966, 0.8642243016655347, 0.8659935461581776, 0.8547781410271569, 0.8489843434467998, 0.8291276393042519, 0.8542008358345242, 0.8671068584652082, 0.8460371044231281, 0.754998745647667, 0.6685360222833198, 0.7094896514843003, 0.7032145651648585, 0.682277274361005, 0.6957365976649358, 0.7782177807854866, 0.7414169653758014, 0.7488975639652787, 0.1260365113730908, 0.11863917586582173, 0.12282585325225315, 0.1730225647967698, 0.17523928355619023, 0.13816749343700052, 0.13605050692107412, 0.12476910900380311, 0.13292032060456171, 0.13829873376169632, 0.11018068180767204, 0.1442854808839329, 0.11288557073308203, 0.1733192939832332, 0.09969463812954271, 0.11619831825062776, 0.12149586278962365, 0.10815664397811064, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6290162284567968, 0.5922781557132764, 0.588780814996684, 0.6670225256780604, 0.644425863156447, 0.6348853304366482, 0.51465906649409, 0.6482033543525607, 0.605582459343158, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5206291164262296, 0.12125465973297, 0.12861577462045204, 0.5617507875338423, 0.12736644596554436, 0.7265431498207405, 0.39518306870503206, 0.5366229774522695, 0.40288428683431365, 0.44784254744102214, 0.1288152535756879, 0.49586790605034203, 0.5368670185254014, 0.575537508950831, 0.5203924925143957, 0.5831511620691582, 0.1264497201800464, 0.5038099392266262, 0.49934707714237136, 0.5284834725514336, 9.999999999998899e-05, 0.6010321473736554, 0.382485077859132, 0.36935365984943236, 0.48364233848944393, 0.4198517361019898, 0.27367132718451503, 0.5963278370603864, 0.5224253748143389, 0.4653302118007083, 0.6831886960244166, 0.580173927849811, 0.4952337541702897, 0.5792440662318769, 0.08123422967530491, 0.7078451166151098, 0.0739010626179103, 0.1084619212107013, 0.3855359850948187, 0.3521518163304569, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.43403222200219826, 0.42711740183650415, 0.46483801601092856, 0.03805354803257921, 0.4661126798316374, 0.40871735786607777, 0.3718109253001566, 0.3371319365795915, 0.6948568389807652, 0.6245302587707393, 0.6884578786474407, 0.7321140615795139, 0.6024203182118643, 0.6730790023229437, 0.6518467238363761, 0.6501001592558935, 0.7801717998256352, 0.14314049685128938, 0.09503011201524791, 0.11130418714052726, 0.14066098435242724, 0.10992720434210046, 0.12329404616465311, 0.13665658230927002, 0.13308825011320846, 0.11906316999336908, 0.18600333865198404, 0.2673014954593603, 0.2556784400268317, 0.1639969500449312, 0.16418829342256847, 0.24061537736670835, 0.15552857239351547, 0.20594675517067074, 0.31461537770532055, 0.49199369420021233, 0.34834637766463405, 0.5467715808924283, 0.43074953391482973, 0.500392811902082, 0.40577304191016295, 0.24173248114034063, 0.20595781597406315, 0.5485168868695214, 0.19453192043951406, 0.2703873449117091, 0.4117133465805445, 0.24211103021888292, 0.39158270919502947, 0.4408556271588616, 0.214665216511152, 0.3326676085837589, 0.3686769563545761, 0.22406086113739287, 0.2162592903384254, 0.26643093577723, 0.22076107381384635, 0.2130608649876382, 0.21791115593653, 0.21324382202328362, 0.1841692469811571, 0.23955364122471723, 0.7758472744891161, 0.19081196702814418, 0.20592291284862474, 0.18665042546779664, 0.20165006658640328, 0.19146475586217948, 0.196949486636246, 0.18052241226414334, 0.199244686156535, 0.16398331650145992, 0.18666358427992769, 0.9130595737841963, 0.10337077808419859, 0.16896991770819714, 0.16737607409133837, 0.1865383984864062, 0.12487727769843693, 0.8394302306900628, 0.8918762231358082, 0.15613242217346068, 0.886246531723765, 0.20984586224128066, 0.8537568020847193, 0.1615534138203335, 0.10458026021234912, 0.16621803419387982, 0.8676933569508227, 0.1801010290889843, 0.1861849159422556, 0.1810781877376637, 0.17079458853552554, 0.18721586379369282, 0.1805003181901007, 0.16824230993890488, 0.1735854651922597, 0.18195722678289739, 0.10159357200343222, 0.0960010997993137, 0.09013961566952788, 0.08537947729245021, 0.09032768963826765, 0.11212037078744308, 0.08284381425380383, 0.08679771977119677, 0.07310908540901806]}, "mutation_prompt": null}
{"id": "f0ea0406-4ea1-4449-8f26-b628db3fd960", "solution": "import numpy as np\n\nclass AdaptiveMemeticDiffEvo:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 7 * dim  # Slightly increased population size for diversity\n        self.F = 0.7  # Adjusted differential weight for exploration\n        self.CR = 0.85  # Slightly reduced crossover probability to fine-tune exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Slightly reduced adaptive factor\n        self.diversity_threshold = 0.12  # Adjusted diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticDiffEvo", "description": "Adaptive Memetic Differential Evolution with Dynamic Stagnation Management and Multi-strategy Exploration for robust optimization.", "configspace": "", "generation": 59, "fitness": 0.35602156976302635, "feedback": "The algorithm AdaptiveMemeticDiffEvo got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.7533210949627268, 0.7686226769907524, 0.799012282890275, 0.7822514848702886, 0.7929356963578411, 0.7994784119085521, 0.8103562758939471, 0.8086182200114471, 0.7895647376412392, 0.6047671606548234, 0.6448269032591041, 0.6286815501034766, 0.5957568915744678, 0.5936516487048313, 0.6072829547732868, 0.6084292098577573, 0.5868850115958955, 0.5801945163183786, 0.15756849607232704, 0.4494397839361962, 0.14395783067933443, 0.14065756375603922, 0.10878293037103925, 0.1627380081895713, 0.3850271081376634, 0.15557954077633807, 0.13271445017866668, 0.1402641736289597, 0.1281554916910732, 0.09915399071089304, 0.14402767173358333, 0.1383041335279973, 0.12452888104243465, 0.14379706341710485, 0.15548707583499055, 0.1289274515522173, 0.9474284294869215, 0.9204609952452475, 0.9594353579190945, 0.9172976996619904, 0.9845725404904614, 0.9859063938483758, 0.9341621311675355, 0.9846860925978806, 0.9399510665089442, 0.4393399467628053, 0.4089034444238877, 0.45554247118535784, 0.46388999944191334, 0.4340230377063543, 0.37473119608881456, 0.46987304614399616, 0.3954353511198103, 0.4413423444687584, 0.7467309248372456, 0.7303069558353421, 0.3542457339440873, 0.7571990581415389, 0.7338681435146672, 0.7772169692191169, 0.8032212861110033, 0.7392440509706546, 0.7459098950380488, 0.4980421295276538, 0.30031345627156125, 0.1263454339530723, 0.11937217968960645, 0.3991159979750101, 0.43001130049671776, 0.3007212171240289, 0.35463710670059667, 0.422223927698937, 0.12554117506385154, 0.25248111408598817, 0.10638530053324669, 0.2760181942238952, 0.4221980106302955, 0.5561439667280069, 0.4382895509950736, 0.12410418791567113, 0.422854457564229, 0.38380298691139225, 0.3159119616814189, 0.2669171134119389, 0.19652416781706494, 0.21284436424312725, 0.3044499863128095, 0.35859638222211687, 0.3144266667587734, 0.14071051691631642, 0.4921903916567649, 0.4782204575172283, 0.4060718079386022, 0.3885247457192933, 0.46399581977025106, 0.13404040486377122, 0.44552254016393333, 0.44580505439596396, 0.15161213371203097, 0.06717243483909241, 0.05021406756973701, 0.10211618688536095, 0.16192693610402675, 0.07920602394182263, 0.2505556906746378, 0.16985329661294746, 0.09243976167707502, 0.21028655794308293, 0.2734172628246111, 0.25745387187978463, 0.31329071676761766, 0.3248100002263985, 0.30547485749732584, 0.3260244717682559, 0.2994045805450929, 0.27997566727441736, 0.295174350577848, 0.6112064780472113, 0.6390153006452968, 0.7077549758453764, 0.6314086257096028, 0.625430157578807, 0.5858373019054657, 0.613060311317323, 0.6049101129564227, 0.5906106901123275, 0.09306335511608144, 0.11439235250548885, 0.1124229849436118, 0.1111618962304366, 0.08887581886970897, 0.12540575385919295, 0.14379282097491164, 0.09815618497982903, 0.0838487446559899, 0.4048687355046787, 0.15130021198479282, 0.3567441774246328, 0.117176233168929, 0.2690475370801817, 0.2199755262334503, 0.1455288700984615, 0.20782379134848594, 0.12075385265688943, 0.41167026767706516, 0.37482135082765256, 0.3961466847161118, 0.3869566816797958, 0.3975181617772441, 0.4548152896891754, 0.44838074291001817, 0.44429521621949974, 0.4020415291177555, 0.3121576163888159, 0.2064667767093914, 0.22601485165294422, 0.18505627780304235, 0.1962170251756813, 0.3114374178367787, 0.3305571296752684, 0.3060644600323277, 0.3916337233095286, 0.19237310085271142, 0.1813945666685126, 0.21326889298129592, 0.22686524294168375, 0.18915640640704645, 0.20425322725880357, 0.20552009664658233, 0.19913169827970767, 0.20413588557214601, 0.19301331499511531, 0.20112840888297345, 0.196811820830877, 0.6089847077573036, 0.2409610221076962, 0.20277152797940812, 0.22965123819953037, 0.20386188582567688, 0.20565757879658764, 0.1617683748519505, 0.1507249504790943, 0.1603475894199493, 0.169372378517053, 0.16651759118562182, 0.18992587143372686, 0.7015410417962868, 0.11493659396682776, 0.1563895770078243, 0.20499122382779755, 0.7879086748587552, 0.12567421031105208, 0.7624254058907325, 0.207265482848092, 0.20154379534024958, 0.7239474976455553, 0.15927013567211468, 0.7413111163864345, 0.1888799233629198, 0.1761312517306376, 0.18547310325686972, 0.18191115065493324, 0.182968593925235, 0.18016253781254, 0.17294773455141077, 0.17232170842428474, 0.17501365711777672, 0.08212796027649982, 0.07901451680585292, 0.07488719878444172, 0.07454517012957618, 0.07514981689799605, 0.06085080344469551, 0.08229202849694794, 0.07346239054563375, 0.06945750293622965]}, "mutation_prompt": null}
{"id": "fd8168fd-1a93-4275-a3c4-7fdb9ec4be24", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 7 * dim  # Adjusted population size\n        self.F = 0.5  # Adjusted differential weight for balance\n        self.CR = 0.85  # Adjusted crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Adjusted adaptive factor\n        self.diversity_threshold = 0.15  # Adjusted diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            d = indices[3] if len(indices) > 3 else a\n            return self.population[a] + self.F * (self.population[b] - self.population[c]) + self.F * (self.population[d] - self.population[idx])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Adaptive Learning Rate utilizing explicit diversity maintenance and dynamic mutation strategy for improved convergence and exploration.", "configspace": "", "generation": 60, "fitness": 0.3827475377030633, "feedback": "The algorithm EnhancedMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8593133047829841, 0.8398622501172142, 0.8797660801199408, 0.8492361590262543, 0.865733120084173, 0.8567815181788816, 0.8495974325445291, 0.8561862637787999, 0.8662615603876154, 0.6024272245859748, 0.7164703191187161, 0.7025032494147315, 0.6770275269252701, 0.6955656749103973, 0.7505798266100898, 0.6989178153351383, 0.7218996646089669, 0.7062378831955505, 0.11691617117635855, 0.1492587362692961, 0.140331834409122, 0.1323429735638365, 0.1470075176891702, 0.18079523576025747, 0.15100204997436883, 0.13716184989018987, 0.14276088940715503, 0.10720198750500076, 0.09498712433395307, 0.11293572532483065, 0.09692894357007042, 0.14376727878463202, 0.13835899532063956, 0.06112539807204631, 0.13280889726089884, 0.12297496600797475, 0.9771979852511172, 0.9649209122639584, 0.9502821474001907, 0.9493216508447321, 0.9463399902308022, 0.9764985175845392, 0.9793433192160835, 0.9312042572446446, 0.9644402987952395, 0.5595641585130486, 0.6274931524926581, 0.6230951579502988, 0.5883913528791265, 0.5157361297804839, 0.5297472270591581, 0.4893259720767261, 0.5777239237120012, 0.5318426548207674, 0.8179880700281509, 0.8162315314632949, 0.22019507779546277, 0.8135216173119626, 0.8378307810494398, 0.3718784326093496, 0.2298552235809761, 0.23175024343767914, 0.8790083633841321, 0.33836777720559963, 0.12422097979185442, 0.5628597221899907, 0.41593971417098763, 0.4186182342635729, 0.5560446394015033, 0.12858971928230656, 0.522645462302501, 0.38561412510086857, 0.1816734849835746, 0.12700483006876462, 0.332599952377846, 0.46303715591990535, 0.4368181814221499, 0.49908505905537315, 0.40240434138253756, 0.5167390682623287, 0.5203958125960364, 0.30703968275458027, 0.44496878308671195, 0.2047430755630919, 0.5121772665317462, 0.47204458374906366, 0.25074302447846253, 0.23884889068795223, 0.24175286140263796, 0.08191626949960151, 0.6750435344946977, 0.5353778592379377, 0.649088934702662, 0.5076483978619943, 0.5630379742426019, 0.5265226097666786, 0.6404003908249696, 0.6307036492608992, 0.6261525140271873, 0.2448772549153747, 0.060071611960184734, 0.26004418447893685, 0.26814642419020585, 0.13311614390419546, 0.18662480396356484, 0.17404733867917654, 0.1140737020521807, 0.3465632396784344, 0.3989448624140163, 0.3079492775286016, 0.4094557100959564, 0.3889227096767255, 0.3717714344574924, 0.4166671237005808, 0.22732289711890385, 0.29333038958407354, 0.41350840330890526, 0.7027868086828035, 0.7240443655690362, 0.6640213837704246, 0.6275881181330558, 0.7103778528212098, 0.67205812181805, 0.6666268750497106, 0.6240232059118347, 0.6832487737063787, 0.14770210342732915, 0.11400449242276267, 0.09875713108349882, 0.13563835031396088, 0.12591778039784418, 0.11916943930957735, 0.11270889210132717, 0.12508879088271374, 0.12635672423131705, 0.14194534930134728, 0.1663809374521832, 0.24455739709798086, 0.1527167975084741, 0.3565925406309176, 0.14922343928713921, 0.5710517709618794, 0.3889991288789464, 0.14309164246999262, 0.3280241953784184, 0.2676715751203492, 0.4601903636746417, 0.3171665236073321, 0.4317639878664885, 0.41256105298666124, 0.518405353041704, 0.4363091030814701, 0.48404815213904173, 0.26808363241928923, 0.25107288882870515, 0.19176249508130072, 0.16416438205832184, 0.23153770452395117, 0.385355474047375, 0.2697555828322633, 0.3098061647107504, 0.2360534038570743, 0.20935000158153672, 0.2036297989949274, 0.18204026063068046, 0.1808083924869346, 0.19434342140152439, 0.1935147696610522, 0.18748250905070774, 0.1927819179316942, 0.26990445922477446, 0.24520624733175223, 0.20655750339077772, 0.214835284791286, 0.2013576636293486, 0.20678605647553727, 0.20339440863666347, 0.19440861935621878, 0.23579866259023907, 0.1823557441913778, 0.16551164651119088, 0.2068618223491525, 0.18079684455233125, 0.18632792663069442, 0.16426968550962828, 0.1640524237920028, 0.8491004834585362, 0.18616292733927953, 0.1458807377049154, 0.16888952493534837, 0.7996010595914522, 0.827278433406617, 0.8655420603953898, 0.20782149633505242, 0.1658883069307432, 0.19681555977637433, 0.21125327940944394, 0.2138972130647322, 0.17248439681796246, 0.17695146638514758, 0.18323083544761243, 0.19089271485508685, 0.17957000098351872, 0.17401101579755518, 0.185057639961819, 0.17133485889017852, 0.1768820374380119, 0.07869739663341346, 0.08394277695340446, 0.07540603719436079, 0.0842022997092583, 0.0847735146255969, 0.08084734534427229, 0.0781591768946206, 0.07771547931405753, 0.09032407860930092]}, "mutation_prompt": null}
{"id": "88139ded-c3d8-49c6-af58-ea93e7797170", "solution": "import numpy as np\n\nclass AdaptiveMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim\n        self.F = 0.6\n        self.CR = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95\n        self.diversity_threshold = 0.15\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.015 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticEvoStrategy", "description": "Adaptive Memetic Evolutionary Strategy with Enhanced Random Walk and Adaptive Diversity Maintenance for Improved Convergence.", "configspace": "", "generation": 61, "fitness": 0.39301501726237326, "feedback": "The algorithm AdaptiveMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8738415888663826, 0.8610914959367205, 0.8654830051085287, 0.8518557706915213, 0.8472178451580341, 0.8288212684624292, 0.8534300791229487, 0.8671068584652082, 0.846304202186964, 0.7538099581652704, 0.6680607685722642, 0.7107939306974211, 0.7038993829680339, 0.6773534156062184, 0.6942981572601536, 0.7778281202852197, 0.7459071011787639, 0.7473077595599292, 0.1260365113741927, 0.11863917588618844, 0.13458368126874232, 0.09437124608282388, 0.10876983227040704, 0.11389641947916773, 0.16828918402699877, 0.12476910900089666, 0.13292032028955436, 0.15809636481342937, 0.07856373145126361, 0.12844680111464912, 0.11288557073244321, 0.17029999549561947, 0.09969463813228197, 0.11020913621481354, 0.12928446631932367, 0.10815664394655633, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6248711783999488, 0.6103503301849011, 0.6048191888382872, 0.673507131177156, 0.6502659347505257, 0.612337140501122, 0.5282589274902676, 0.6365963316157464, 0.6161935341590385, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5435470022217161, 0.12125466042659971, 0.12861577439999894, 0.5639022557562279, 0.12736644612027959, 0.7331108474497827, 0.39605538343668156, 0.5255689072181815, 0.4129538667930639, 0.44735384620426233, 0.1288152543547496, 0.5075939278075416, 0.5446023195266545, 0.5575162207898989, 0.5219884390144345, 0.5966181497929899, 0.12644971976669273, 0.5143376968030359, 0.5038753725871359, 0.534920710586233, 9.999999999998899e-05, 0.5919651642579058, 0.382204389653642, 0.3845098589883026, 0.5040628669710492, 0.44221012000080584, 0.27367132718451503, 0.5914833042290449, 0.5543736256693244, 0.4686976658543587, 0.6789392307209258, 0.5482076062548955, 0.5077221768965878, 0.6027611913540781, 0.08123422967530491, 0.6512973650500119, 0.0739010626179103, 0.1084619212107013, 0.38311591979285253, 0.35185743416351445, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.4350655235895683, 0.42701053749999374, 0.47660606461024857, 0.038053548067236265, 0.4581564253557211, 0.41106599407312483, 0.37206765207711334, 0.3371319365795915, 0.7056310226643141, 0.7043627068092395, 0.733200410397544, 0.7793769204816716, 0.6143663864181874, 0.6988647965167034, 0.658809237045385, 0.6530140184843016, 0.749334393076883, 0.11901304255336276, 0.12833998962548776, 0.12063469736258903, 0.11339059723999778, 0.10759810320637186, 0.09035766696366787, 0.14279339283668724, 0.1456122656789297, 0.167308755652268, 0.18163154261758885, 0.26730149435325734, 0.22175203573267288, 0.16399695004315928, 0.14497265245380275, 0.24061537721466397, 0.15552857239303375, 0.20594675508179394, 0.31490808910743795, 0.4918426952634529, 0.3504867723134153, 0.548251149804291, 0.4314652352526366, 0.49910101444092136, 0.4057464233845759, 0.24173254245947828, 0.23424288096554124, 0.5451288393217468, 0.19453475348253446, 0.2943753787419888, 0.4123094341585629, 0.23546481282688825, 0.39197459152901404, 0.44109183556453513, 0.21466521568917019, 0.3327021950728296, 0.3688276029034625, 0.22406086113739287, 0.231251954285698, 0.18857364474370608, 0.21456854205633846, 0.19645532409110578, 0.2054785580333831, 0.2191570649359874, 0.17363856068575456, 0.19545023741706558, 0.7749610686858791, 0.1908119669759364, 0.20592291273323549, 0.18665042559747858, 0.20165006662164642, 0.19146475567979182, 0.19668938752669451, 0.18031582180249295, 0.19924468648128735, 0.1639833170595102, 0.18666358427940244, 0.9130595737841963, 0.10337077810532358, 0.16896991760251734, 0.16737607403665866, 0.18653839841467657, 0.1248772778475935, 0.8394302306900628, 0.891873607034766, 0.15613242224248658, 0.8872552627238702, 0.20984586242494718, 0.8520681527403942, 0.16155341386661715, 0.10458026022009559, 0.16621803418547532, 0.8666247374111147, 0.17951373236093082, 0.17996198817176046, 0.18473465031194514, 0.1717724573077576, 0.18321752562341265, 0.18559860713481113, 0.18275437549663864, 0.17202383822477896, 0.1761131205095562, 0.08728859723004623, 0.08566786654049663, 0.09992681327275499, 0.0866837027523889, 0.07687029700467096, 0.1076117946381584, 0.08893011146411822, 0.07179702989013781, 0.07051984374657327]}, "mutation_prompt": null}
{"id": "2c3e0fb6-3fae-405d-9b11-8f5fe06cc652", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategyV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Increased population size for diversity\n        self.F = 0.7  # Modified differential weight for balance\n        self.CR = 0.85  # Slightly reduced crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand-to-best'\n        self.adaptive_factor = 0.92  # Slightly increased adaptive factor\n        self.diversity_threshold = 0.15  # Increased diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        elif self.mutation_strategy == 'rand-to-best':\n            return self.population[idx] + self.F * (self.best_solution - self.population[idx]) + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand-to-best'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategyV2", "description": "Enhanced Memetic Evolutionary Strategy with Adaptive Learning Rate and Random Walks for improved exploration and exploitation balance.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {}, "mutation_prompt": null}
{"id": "5957a08c-9dd7-4be1-96e3-1ffe2fe42e49", "solution": "import numpy as np\n\nclass HybridEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 5 * dim  # Adjusted population size for balance\n        self.F = 0.7  # Self-adaptive differential weight\n        self.CR = 0.85  # Crossover probability for exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.92  # Adaptive factor for quick adjustment\n        self.diversity_threshold = 0.05  # Lower explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridEvoStrategy", "description": "Hybrid Evolutionary Strategy with Self-Adaptive Differential Mutation and Dynamic Diversity Mechanism for Enhanced Global Search.", "configspace": "", "generation": 63, "fitness": 0.3669686829431073, "feedback": "The algorithm HybridEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8387491911101842, 0.8355566486481145, 0.870768097852026, 0.8234248079470674, 0.8292783071574412, 0.836722811899866, 0.8341227449318017, 0.8430075391600587, 0.8300744979603653, 0.7133685062902524, 0.07631097997347858, 0.5920328722769141, 0.654942465609937, 0.6930344612003732, 0.6729323654741497, 0.7278817851870472, 0.7217202374445366, 0.5542036347023596, 0.17625231073185865, 0.14857559275404508, 0.5900141734142126, 0.18145729476578631, 0.13054610338226214, 0.17745729168807156, 0.148258541724259, 0.14122151248247172, 0.12428475232953329, 0.14063017687423685, 0.09067943102344833, 0.14453654590800324, 0.0950151553399452, 0.10511067338793656, 0.12483568484564944, 0.13351590379630396, 0.10357618074140174, 0.14982695280811908, 0.9524502876002671, 0.9867041138738536, 0.9496221199032098, 0.9537402884468, 0.9643615321459208, 0.9422141832044887, 0.9700506542334519, 0.9651059060822351, 0.9587213031692111, 0.6056116052129241, 0.6236222250551918, 0.5778144109214085, 0.6243796578435583, 0.5909189293120232, 0.5902870390719044, 0.6549583594244673, 0.5615815504970219, 0.6511085180471665, 0.8154145102287288, 0.3614272344620455, 0.11824046934948695, 0.8602330458380565, 0.20882887767868585, 0.21205177747360104, 0.22720827100690943, 0.23995257477443532, 0.7719565719364849, 0.4543161966755629, 0.5583912173261225, 0.4902828535306525, 0.3721916636919699, 0.12817284823813302, 0.5726143677504113, 0.4631590306579506, 0.42356761854400726, 0.5060396706693917, 0.47556122596203154, 0.5386417591826145, 0.11763281126400538, 0.12887880726901235, 0.5638845592813141, 0.6720914332716277, 0.3987245548466867, 0.5290144655940867, 0.49515779416264494, 0.39795031211816423, 0.2254358114505326, 0.18389431201228257, 0.5724416738379532, 0.09487923925875641, 0.4182611805613421, 0.1445893470615225, 0.4832176391335343, 0.0619761842700387, 0.5945669746714622, 0.08818266051512147, 0.5399907123023809, 0.024888857087356886, 0.07464014187772516, 0.400282376025186, 0.5466026745212987, 0.13049160957756123, 0.5430623696560073, 0.07238805340619658, 0.06866646605701121, 0.06964300938529211, 0.2658190723102827, 0.2837230859676865, 0.2413850221782441, 0.2749016701003586, 0.10280956469531632, 0.18427339791683084, 0.3900922811774358, 0.3573100099123173, 0.3752708232717952, 0.4244340617782847, 0.33585723571619563, 0.3178752303993493, 0.3464267456365967, 0.32925299769959426, 0.40046392984024926, 0.7079514235324051, 0.6945278691924552, 0.6208553445848435, 0.5872832033278689, 0.6538296480376908, 0.6579609016693251, 0.7179513862953235, 0.6250016967748453, 0.6890234970899466, 0.1328190742515175, 0.14897835333673248, 0.12643105782188901, 0.11332505071076415, 0.11088835171493971, 0.14971833337414442, 0.11769394834557023, 0.14300215553000895, 0.11155486006276027, 0.21930148703960384, 0.1625682190679134, 0.17423749036799785, 0.28048863614998965, 0.18646286857135752, 0.11883509233481504, 0.18496850216998084, 0.10850157149519168, 0.1730444802281248, 0.41579282833350995, 0.2491232147078828, 0.3349920907051921, 0.4951500158257971, 0.2316015094080056, 0.5013691063539473, 0.43650844557397905, 0.2871413847291151, 0.30944456747656923, 0.24610741281721948, 0.3964068233878476, 0.2777891357820549, 0.22748210880620057, 0.24871401620001454, 0.2047716001721348, 0.3367386469009681, 0.36893784565351506, 0.21974681006106556, 0.20719029956655843, 0.18596730852144705, 0.1928476261046902, 0.20247950434134487, 0.19090820918170726, 0.21094512860933667, 0.18353126573981637, 0.1865669611868378, 0.19955815800261967, 0.24476169046384688, 0.21618483339636474, 0.19002932118040494, 0.21924224544035487, 0.22780584412226834, 0.18268416089396833, 0.19346904310658042, 0.24461634855097192, 0.2428153590142429, 0.19676410657851473, 0.1504587496022517, 0.1663252957552177, 0.15593370652459038, 0.8923440625791309, 0.1886939362973199, 0.16813194862834535, 0.10633393288357584, 0.16376606278176475, 0.8603721053298607, 0.8318835327779311, 0.8485168248828723, 0.16160357925514235, 0.16299207011313976, 0.8357910293466484, 0.10525332810060739, 0.45207903974868724, 0.16402886556566987, 0.1890274337435257, 0.1749237778207403, 0.18255284350679613, 0.2023505247248477, 0.18959703203895228, 0.1683141993253202, 0.1777995678096086, 0.17488830476584483, 0.1678029604542498, 0.07684475418364345, 0.08304942438341056, 0.07328627274569366, 0.08221413981557923, 0.0812558809778946, 0.08208702006543922, 0.08327702218548272, 0.09133189164629729, 0.09997305444765203]}, "mutation_prompt": null}
{"id": "2f98d6f5-4512-4abe-ac1e-d89ff33b6184", "solution": "import numpy as np\n\nclass AdaptiveMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim\n        self.F = 0.7  # Increased differential weight for more aggressive mutation\n        self.CR = 0.85  # Balanced crossover probability for exploration/exploitation trade-off\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.92  # Slightly refined adaptive factor\n        self.diversity_threshold = 0.15  # Enhanced diversity threshold\n        self.reinit_period = 50  # Period for population re-initialization to maintain diversity\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def reinitialize_population(self):\n        random_indices = np.random.choice(self.population_size, size=self.population_size // 4, replace=False)\n        for idx in random_indices:\n            self.population[idx] = np.random.uniform(self.bounds[0], self.bounds[1], self.dim)\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls % self.reinit_period == 0:\n                self.reinitialize_population()\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticEvoStrategy", "description": "Adaptive Memetic Evolutionary Strategy with Periodic Re-initialization to Maintain Diversity and Accelerate Convergence.", "configspace": "", "generation": 64, "fitness": 0.3288467284998394, "feedback": "The algorithm AdaptiveMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.7842489850953651, 0.7920115282834025, 0.7946688407088713, 0.743571605458536, 0.7727691101019502, 0.769661391445227, 0.7601893858276293, 0.7581860448524029, 0.8047552886188486, 0.5784158359961339, 0.6030564239205531, 0.6128689289133721, 0.5925013321730996, 0.5997156513823207, 0.5644148283668644, 0.6119556579822334, 0.6010405963955965, 0.5106362152676076, 0.15578081826884682, 0.3350806351530313, 0.15614416259022346, 0.14949565455334046, 0.15771504093269906, 0.13524516478961546, 0.13078114744754332, 0.1538510513881738, 0.14555587549060633, 0.14480484330433285, 0.12997138054449897, 0.10728408593463534, 0.11076457819286478, 0.10921987487375862, 0.1474003547674143, 0.3884240588143554, 0.13610019269871299, 0.10500721101676158, 0.9401333191127386, 0.9728461392022013, 0.9674015028918621, 0.9424874422679153, 0.9872481130183535, 0.9670220454642477, 0.9679904940216906, 0.9630469970110813, 0.9839614848902066, 0.37102336808907155, 0.38704068979951267, 0.40382087287876556, 0.3533582814886368, 0.3016690098019912, 0.3723726674835993, 0.3740642418622889, 0.3648179692280964, 0.4340001303798622, 0.730341175322455, 0.7469397821235528, 0.3473936258367222, 0.7508987782857276, 0.18926443141307792, 0.8007413061885732, 0.7827756589733934, 0.7295011046666745, 0.7687199201922555, 0.5317716391377687, 0.3353593102240524, 0.27083551389401184, 0.4990854948174871, 0.2857604814335496, 0.12938048972376326, 0.16391557486166852, 0.2777826042611524, 0.29269959531529377, 0.07441572193412305, 0.06354058631044612, 0.3210533811143581, 0.4654286583960614, 0.12182487570922274, 0.37093906792582443, 0.08797368226815439, 0.29892470299579177, 0.39261069454338315, 0.2697501097528071, 0.07035855674122449, 0.2010415566263175, 0.3394571906408158, 0.05099195505649168, 9.999999999998899e-05, 0.08323111107500503, 0.1178657106987987, 0.013488485963297547, 0.3396453618575537, 0.0754349148607304, 0.2611788737255565, 0.12843917949873285, 0.016586616435589008, 0.3605914252023191, 0.32124716316219626, 0.16403606570352836, 0.3878791615963245, 0.19843265477186867, 0.0480280151524185, 0.07413455597186436, 0.1643517820482504, 0.12553975808204154, 0.17090747941369178, 0.09356239508406794, 0.09022260115821468, 0.07326542988040896, 0.2562375619278021, 0.2275466935677507, 0.2232173047464293, 0.2582813612592707, 0.2995301300305556, 0.30973645310467046, 0.28819744422372695, 0.22195757987977582, 0.2453956255426939, 0.5667421211263413, 0.5745358959798861, 0.5684690327921096, 0.5751336003281073, 0.5580825045779398, 0.5588973239372566, 0.5818013390229643, 0.5717674790041445, 0.5830140011281522, 0.15881546885991826, 0.09973455461932768, 0.1256550706831593, 0.12378882300135541, 0.10608370501020659, 0.08499726561524767, 0.4912076467686053, 0.12299060084958313, 0.12889111936936148, 0.23653955718098418, 0.20909828304811806, 0.280164797425686, 0.16466084988419893, 0.18127266200160552, 0.20815360919209647, 0.18935654888748132, 0.21796917649160696, 0.13472268218665162, 0.3806765906253947, 0.40547907074104883, 0.2416630099256426, 0.33573790028556816, 0.3860563589794269, 0.4060748034764361, 0.4553335114493672, 0.406161636341527, 0.3573707211829543, 0.19957471762910095, 0.22342717088892816, 0.21484096731058766, 0.16658873237865668, 0.283915515381171, 0.2748268440502696, 0.2924963073690058, 0.28858912111119284, 0.3208721331598159, 0.19538079784925877, 0.18645937072936214, 0.19677654219025908, 0.199958078897715, 0.1957258496279778, 0.19120924999058464, 0.2078728233752286, 0.18843506988113257, 0.1901742164774728, 0.19919403366395705, 0.20581199990441978, 0.21263889926757107, 0.21831225540359467, 0.1837595053229456, 0.20151485701503247, 0.23214298053288562, 0.19930956463194527, 0.20053410579064246, 0.19229839479468525, 0.18443590148115485, 0.18195968381209182, 0.17832341824058717, 0.7596481680699534, 0.19744276292498786, 0.12938148058880683, 0.14905277701025532, 0.16407502278697617, 0.7615057014625085, 0.1103388811247289, 0.7143241674923737, 0.727656152825189, 0.7531720639942954, 0.12561453959364788, 0.20492412937112237, 0.31121465275899163, 0.5694813087892715, 0.18564841993065706, 0.20376418991706224, 0.18583077117016966, 0.17288067893164372, 0.17530233173301513, 0.16904436760866925, 0.1803180529774523, 0.17320592158441883, 0.17943563501218618, 0.09338813494136955, 0.07089745313550833, 0.08116443710722376, 0.07566403265479416, 0.08163729260305497, 0.08503469782658579, 0.08586230805533646, 0.09230769017503337, 0.06987202891444466]}, "mutation_prompt": null}
{"id": "6638a8c5-d102-457b-affc-af927351d5d6", "solution": "import numpy as np\n\nclass AdaptiveDirectionalEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 5 * dim  # Adjusted population size\n        self.F = 0.7  # Adjusted differential weight\n        self.CR = 0.85  # Adjusted crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.92  # Slightly tweaked adaptive factor\n        self.diversity_threshold = 0.05  # Adjusted diversity threshold\n        self.stagnation_limit = 1.2 * self.population_size  # New stagnation limit\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n        diversity_measure = np.inf\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            diversity_measure = np.mean(np.std(self.population, axis=0))\n            if diversity_measure < self.diversity_threshold or (func_calls > self.budget * 0.75 and stagnation_counter > self.stagnation_limit):\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    perturbation = np.random.normal(0, 0.2 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = self.population[i] + perturbation\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveDirectionalEvoStrategy", "description": "Adaptive Memetic Evolutionary Strategy with Directional Diversity and Stagnation-based Perturbation to enhance global exploration and local refinement.", "configspace": "", "generation": 65, "fitness": 0.35697009778988825, "feedback": "The algorithm AdaptiveDirectionalEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8275566966618623, 0.8288899207199321, 0.8431315240094399, 0.780395404608356, 0.8055272390281365, 0.7979563157986613, 0.8044387467497959, 0.8047747747486261, 0.8106885229364125, 0.6621038333358631, 0.07630345211312395, 0.5490923447648581, 0.6256922264349838, 0.6406652653724542, 0.6458828876086495, 0.6655345996176645, 0.674128071751595, 0.5655922047334017, 0.17436153779095387, 0.12345222188777716, 0.5476176931223965, 0.1805746946957395, 0.13054374656820733, 0.1544974844116812, 0.6415886760737823, 0.14119588135378325, 0.13337343642892607, 0.14141915445070374, 0.09067418217349199, 0.13056625057263105, 0.09500936721868036, 0.12584974179862152, 0.12482284264773535, 0.13349247000651576, 0.1035643599804913, 0.1497496772208562, 0.9524502876002671, 0.9867041138738536, 0.9496221199032098, 0.9537402884468, 0.9643615321459208, 0.9422141832044887, 0.9700506542334519, 0.9651059060822351, 0.9587213031692111, 0.5189114136374704, 0.5275284365147427, 0.44959868319205876, 0.5149090091991553, 0.533266232228941, 0.5145592939501641, 0.5388090329567692, 0.5150672834624604, 0.5653482248489929, 0.8154145102287288, 0.7752577962666891, 0.11824046934948695, 0.8602330458380565, 0.20882887767868585, 0.2574147040000496, 0.22720827100690943, 0.5655887348340434, 0.7719565719364849, 0.3614205874795996, 0.5638526400217558, 0.36843484080207445, 0.23151291157475717, 0.1281679071015851, 0.4951744433343266, 0.33158196569725573, 0.4615873574627849, 0.3469104541860931, 0.2719586633356005, 0.38719438588497035, 0.11759591404745495, 0.12862711849379227, 0.49448382803780955, 0.4811246538866448, 0.33294440151943083, 0.3122851314591988, 0.4006556972323233, 0.37668082077421405, 0.26358738737577436, 0.25423338535511864, 0.46444911114470666, 0.1050760002903095, 0.3057294726836681, 0.27725801213876133, 0.4155619098874058, 0.06271808045337535, 0.44587112435537046, 0.08328472116453445, 0.5546134868856939, 0.10146649053991674, 0.19769058766958325, 0.451635599160348, 0.5718260576631831, 0.06320860633778325, 0.5191334789133468, 0.06205806341974873, 0.06494317860621635, 0.042442553797161775, 0.294350543157998, 0.2352950680440843, 0.2655965429980648, 0.25617588909212186, 0.08986513752204939, 0.19194023746567535, 0.2897508960010372, 0.25399185487345854, 0.34536046828019673, 0.36573948640132004, 0.3434989462191006, 0.314682040885933, 0.35221222720914314, 0.26695581239255994, 0.3104480414004217, 0.6540163502982026, 0.6500045397612915, 0.689598287016365, 0.6099878906188299, 0.6540164513433913, 0.5949961296579882, 0.5951716366844004, 0.6336541618921585, 0.6539645650154502, 0.11739424079990934, 0.1323747817239047, 0.1260450123337432, 0.09833489123688144, 0.10665994805278967, 0.14940382425607457, 0.117301636683393, 0.14298282357289482, 0.11108652395159402, 0.21431690933905023, 0.22542038768407346, 0.29233662328442234, 0.2872029248437533, 0.18031392385811218, 0.18413728893923786, 0.1849336377425238, 0.1687230413191093, 0.1974975751472835, 0.37422959063226824, 0.24847534469705002, 0.40691106115269793, 0.35649948544007015, 0.22895418842099358, 0.4079006241672709, 0.4591659941545361, 0.28559810594478974, 0.4042703147383818, 0.2466102364360211, 0.33095402617410696, 0.2668562794053765, 0.22399873121393243, 0.2532440597322486, 0.20440686789185725, 0.30603389426675054, 0.34807844842008095, 0.21619494384703608, 0.21466764692107176, 0.18352958392994623, 0.215127995977752, 0.1826398227513083, 0.18860218637333082, 0.20128939589595252, 0.19250611141268814, 0.17853948179310974, 0.1948795647605105, 0.2447543964015415, 0.21617101168852992, 0.19002936337244747, 0.21873492016385543, 0.22774118529869525, 0.18269658064513283, 0.19342713771417996, 0.2445635740526031, 0.2427892281044547, 0.19755937154386694, 0.15045714526210507, 0.18417977919001793, 0.1559331295156413, 0.8822941408610103, 0.18869000462530472, 0.16813234126167242, 0.10687102777683855, 0.1637657937015662, 0.8500832731525403, 0.841804291167708, 0.845123011466534, 0.16160306212188247, 0.16299074829061788, 0.8326192691671477, 0.11113355127781921, 0.8165569750679973, 0.16402888872242016, 0.18248900531768242, 0.17602156990721196, 0.20000266506938058, 0.19516064272973832, 0.1695250967303613, 0.181108869900779, 0.1777995678096086, 0.16619729050972398, 0.17147133515233526, 0.08528445718654531, 0.07790369718414691, 0.07678631294645843, 0.0743863219075791, 0.0813035781170498, 0.07668244000365887, 0.08218226608198143, 0.08545329317905759, 0.08234686635750788]}, "mutation_prompt": null}
{"id": "82e7d883-96d7-4e18-9ad0-31d8f39b0e22", "solution": "import numpy as np\n\nclass AdaptiveMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 5 * dim  # Adjusted population size for balance\n        self.F = 0.5  # Adjusted differential weight for subtle changes\n        self.CR = 0.8  # Adjusted crossover rate for better balance\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Adjusted adaptive factor for sensitivity\n        self.diversity_threshold = 0.2  # Adjusted diversity threshold\n        self.dynamic_population = True  # Enable dynamic population management\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def adjust_population(self):\n        if self.dynamic_population:\n            # Reduce population size when close to convergence to intensify search\n            self.population_size = max(3 * self.dim, self.population_size // 2)\n            self.population = self.population[:self.population_size]\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.7)\n                    self.CR = np.clip(self.CR, 0.4, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.2:\n                self.adjust_population()\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticEvoStrategy", "description": "Adaptive Memetic Evolutionary Strategy with Dynamic Population Management enhancing exploration and exploitation balance.", "configspace": "", "generation": 66, "fitness": 0.3305835186159265, "feedback": "The algorithm AdaptiveMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8649106581175133, 0.8759664607441081, 0.8222086530525, 0.8607020729664272, 0.8921537443982432, 0.7326545064477512, 0.871725204251788, 0.9025398633561611, 0.8749097078787351, 0.8085506404382, 0.042364383947906425, 0.7150723716372756, 0.756057546601849, 0.5676823414645031, 0.7533655056247028, 0.7994531182011068, 0.7943106121762247, 0.8085754931514448, 0.11425999136836729, 0.08290749105090822, 0.17226457522721828, 0.08831104369126275, 0.13558193288074183, 0.13971027958925042, 0.15847937375154686, 0.14414267283112148, 0.115181196815759, 0.18241692246990615, 0.11646963179417913, 0.17430421369206994, 0.10315033487274339, 0.09121808139896947, 0.10271725744631655, 0.10524692979836037, 0.08970710807420579, 0.14290873244014035, 0.9355416852225342, 0.9635589435797027, 0.9138551030372373, 0.9477487856653037, 0.9698565033264376, 0.9601806930986625, 0.9477961511948723, 0.9371391794347101, 0.9533942096017158, 0.689108366939176, 0.6569002212615769, 0.6642628532639514, 0.7347965127533653, 0.6923119762134565, 0.6711867576864656, 0.6699456660422973, 0.6735221474359452, 0.681369000589478, 0.16712681042169097, 0.38584985182238596, 0.2259970849437819, 0.20826415491622918, 0.18069205448609593, 0.8364452360694006, 0.14989345531672194, 0.2322105976963056, 0.9102803254341159, 0.35458469141623217, 0.17923023760930212, 0.6077973832480952, 0.3896580474911506, 0.20179096973041233, 0.1318347584032381, 0.19861217600709447, 0.4909368563774017, 0.6165218588947261, 0.4357405181999574, 0.18492853787978836, 0.1331485261892036, 0.3817393167862356, 0.4697295081416303, 0.14884924657256726, 0.18925235364493254, 0.2046533004178851, 0.3675404972673766, 0.1787343890891685, 0.1032238351118776, 0.0997110849640328, 0.044797647513061034, 0.035978697887492084, 0.0006943874143887641, 0.017652754296640705, 0.2833661487917176, 0.0705386672917433, 0.20131402918791585, 0.2653870082477049, 0.0760138985752612, 0.10769223528841976, 0.06700063470374384, 0.13116239147453146, 0.49397069315655107, 0.15089690724581428, 0.09771292311191171, 0.152953985991522, 0.12042214510248361, 0.17524616679970617, 0.0804556784412036, 0.164790963092733, 0.19306936330319535, 0.15837414178373843, 0.10085197509201937, 0.1502661912031381, 0.2671787722462676, 0.2680456618788757, 0.25548898431017464, 0.29785223207182066, 0.3705933595652694, 0.40693308288068286, 0.2841220282618191, 0.04926378080527738, 0.33455923190556647, 0.6088008645514724, 0.6528749590969609, 0.7285875965698094, 0.6779458234276297, 0.6654136615938955, 0.6197911392437769, 0.64601202505403, 0.6172767055123153, 0.6690115664457081, 0.10363541145631638, 0.09529634574718548, 0.07166655258482502, 0.10166245935890328, 0.12037370769832556, 0.09647662748812313, 0.11089676926031644, 0.1403773791319527, 0.11304749134608172, 0.4728182753151625, 0.18764181694788662, 0.2666092094259549, 0.16640865647140768, 0.1348574221936124, 0.1368514761190177, 0.24008031390235995, 0.15079538683813465, 0.19399439256180262, 0.4158759128075974, 0.24720840129521549, 0.3597664137755181, 0.5409809080690486, 0.28527856314855227, 0.4782382568991974, 0.30515579253952607, 0.4209237691547212, 0.5789847376256076, 0.2685952824266563, 0.26159600358428436, 0.26130506125832464, 0.24236267219876761, 0.1806319270951804, 0.26163969540548015, 0.1594666851233777, 0.2255237236668438, 0.2298798579171979, 0.18098299183817212, 0.19883107802875544, 0.18948298518058648, 0.20114604681263437, 0.1859433327278497, 0.20277439618146387, 0.20653997087548515, 0.24804359340776583, 0.20465962817356953, 0.19565942353263077, 0.2163190185698981, 0.18562566649427248, 0.19463004724037936, 0.1985995668459155, 0.24613373760766466, 0.2083701802168776, 0.1964724113997709, 0.18206137091272023, 0.18674367372370382, 0.16728058245523914, 0.11411435948925319, 0.15699271451104146, 0.16827994142942393, 0.16809854117155287, 0.15530769838491032, 0.8880469405472825, 0.18293939417460647, 0.8047059918272476, 0.15457221295745693, 0.9097874783925063, 0.20789069432354768, 0.20237477994154918, 0.167668978345192, 0.10478846994770452, 0.1292698762609933, 0.10341227291959643, 0.16194641743323557, 0.19138468416425447, 0.17856324444144955, 0.18421050351875456, 0.1746625826503494, 0.19179316412284075, 0.18283854150078982, 0.17628083177661724, 0.1764931936617644, 0.09227952414393092, 0.07341928896192074, 0.08711071270960913, 0.08304500623562816, 0.08243447612309118, 0.08977717212143888, 0.07977526400777757, 0.08390443969652917, 0.0846733841190318]}, "mutation_prompt": null}
{"id": "11118d06-1fde-4b13-83b9-9e92d5a532ca", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Adjusted for better exploration\n        self.F = 0.5  # Differential weight for balanced adaptation\n        self.CR = 0.8  # Crossover probability for exploration-exploitation balance\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'adaptive'\n        self.adaptive_factor = 0.85  # Adaptive factor for dynamic adjustment\n        self.diversity_threshold = 0.2  # Enhanced diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        elif self.mutation_strategy == 'current-to-best':\n            return self.population[idx] + self.F * (self.best_solution - self.population[idx]) + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'current-to-best'\n            else:\n                self.mutation_strategy = 'adaptive'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with Diversity Mechanism and Multi-Strategy Mutation for Robust Convergence.", "configspace": "", "generation": 67, "fitness": 0.34397068254760643, "feedback": "The algorithm AdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.7808216714169717, 0.7722492320854324, 0.8020180794084188, 0.7898720438881977, 0.7820703628875517, 0.811165695549387, 0.7871266164611868, 0.764364474944779, 0.8040601856889333, 0.6016048601902663, 0.6037486746251178, 0.6081935841095321, 0.5732498815284441, 0.5053096270245199, 0.6370066249313799, 0.6452996802758945, 0.6487855842968867, 0.6073407549134369, 0.14833535268262987, 0.12085412532883733, 0.11190315522888938, 0.12200383554380023, 0.13680900797646822, 0.10779787593166434, 0.12699868389302138, 0.13538234003526928, 0.11183599450511028, 0.11444880975803717, 0.08315369788971161, 0.10334336619705631, 0.10896419084821285, 0.09088783264412592, 0.10293699925396527, 0.11773555317689621, 0.0891409484134339, 0.11023048551371217, 0.8103122902205531, 0.7157932738925202, 0.7680952440005101, 0.9030373627979764, 0.8782822715136833, 0.7739096030786211, 0.914565306623494, 0.7917404122096493, 0.8915766625616582, 0.48053084960895553, 0.4142467213472084, 0.5403657222261675, 0.4814035984031686, 0.4681291874768564, 0.5000394185157642, 0.4785544631575902, 0.4777344556407598, 0.5047320167309242, 0.8156314238483027, 0.7464644123115776, 0.7771763274352037, 0.7484105926073346, 0.6860941399590355, 0.8362411872225515, 0.7631570518927994, 0.7555632008919954, 0.7600346778547585, 0.1427250408859958, 0.21069252125959315, 0.20909860029983884, 0.5084339764278252, 0.2261436468519682, 0.14089180493541187, 0.16833674973777346, 0.18410360199122622, 0.5631400014820138, 0.13854385023136895, 0.17438929189386654, 0.14655609305683226, 0.20892419432617693, 0.142285571726116, 0.18884975216427335, 0.18469326941315867, 0.16511270579102388, 0.15512501852269056, 0.3102208572779731, 0.3044048663770982, 0.18008385953583728, 0.28895114890705986, 0.09612793513654616, 0.07239891869545045, 0.27746171985921875, 0.18472955192096596, 0.3068461537997298, 0.43586593658150996, 0.45218327914583145, 0.46243241301308713, 0.4387919883808129, 0.4182985907474799, 0.18998606841434795, 0.4860170730847455, 0.4450894217100616, 0.4713587795585802, 0.08442570028651097, 0.06952923312966997, 0.08689126989313245, 0.08240615629182779, 0.16750746089265744, 0.17070666802884849, 0.1841214461286229, 0.2120025357592551, 0.26421865830116653, 0.29836159440312804, 0.2729651657928208, 0.23556198414908014, 0.2916996589577391, 0.22757132080511167, 0.3203814420435971, 0.2918700731690972, 0.29592511098862107, 0.15013918013472316, 0.6179922766729216, 0.623631243003899, 0.6386068781372416, 0.5849061344703679, 0.6230861986244884, 0.5955403031399613, 0.6171451666313297, 0.6299681133531445, 0.5906679492784661, 0.10920029049776658, 0.11690538464076561, 0.10001383686694698, 0.11286868071248013, 0.10789128482767396, 0.10258815233633745, 0.10586305326331202, 0.10134314224837127, 0.10388484338410964, 0.15556555209986433, 0.13208890839732468, 0.14296072470324073, 0.13348563391119772, 0.1512722137875524, 0.12977874361850572, 0.1263748430937549, 0.14765731199394982, 0.14108872071765688, 0.41157011312576497, 0.3742131146767631, 0.43179773987359293, 0.3969995676185175, 0.38171884290908265, 0.4439597458985871, 0.4400393977989968, 0.4807993035714755, 0.4711374460142662, 0.3131976316439735, 0.2540237776519205, 0.3203421324544926, 0.27554184678735183, 0.3232061106121754, 0.3102702796698791, 0.34415218113392987, 0.3563512721956815, 0.35697643056260175, 0.21425689089477373, 0.21831065881624656, 0.18943398981654724, 0.2060437086221225, 0.18851207687070104, 0.226502985398628, 0.2039304795684448, 0.1885035385050956, 0.19770482240020149, 0.1968186087595546, 0.17420418941470128, 0.19924197313679692, 0.18500693352146846, 0.2165791078890812, 0.27748748401826906, 0.18154779782416852, 0.4683724336649341, 0.18371583233201616, 0.18156973872383364, 0.17398547049099766, 0.1683893641696801, 0.8180933213044205, 0.1743941705341091, 0.5432256446787995, 0.5973864070111619, 0.18974128188198636, 0.16419698359988566, 0.7465029317664655, 0.41564868183186077, 0.6000765349316282, 0.3034206759968976, 0.20184257900329616, 0.6648000045959779, 0.1517546806356702, 0.20553000858800596, 0.656441822873267, 0.1668072544826189, 0.17664413871467133, 0.17252533281323323, 0.18335148434780657, 0.18781064458812924, 0.17449230979022412, 0.18486747176017826, 0.19570394336373242, 0.1749470229697495, 0.07579879191593808, 0.08723198665732979, 0.0855377765589419, 0.09019271480778401, 0.08395365261655119, 0.0775097969920242, 0.07877421905951798, 0.08291352733554558, 0.08230835344973131]}, "mutation_prompt": null}
{"id": "e3b109c0-3864-4b7b-b193-7995ff3c4fe1", "solution": "import numpy as np\n\nclass AdaptiveMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Adjusted population size for better exploration\n        self.F = 0.7  # Increased differential weight for enhanced exploration\n        self.CR = 0.85  # Slightly reduced crossover probability to maintain solution quality\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Adaptive factor for more flexible adjustment\n        self.diversity_threshold = 0.15  # Increased diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.2:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticEvoStrategy", "description": "Adaptive Memetic Evolutionary Strategy with Dynamic Strategy Adaptation and Enhanced Diversity Mechanism for Improved Global Exploration and Convergence.", "configspace": "", "generation": 68, "fitness": 0.33419756643357573, "feedback": "The algorithm AdaptiveMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.742976716230385, 0.7349224993661421, 0.7326827375151743, 0.7342179183325155, 0.730065317162772, 0.7405956071041155, 0.7906911146719664, 0.7426443144674817, 0.7358184885932929, 0.5244406287625667, 0.4906938290800099, 0.5637054117762799, 0.06242161566221016, 0.5310436467712314, 0.5108355963442124, 0.5774676850515403, 0.5645944575963453, 0.5728577716906388, 0.31073683286067266, 0.42323081882214, 0.12921824333879628, 0.12424696193593476, 0.13616837605254972, 0.14718025265386436, 0.157850190239461, 0.15467598248417957, 0.14408560509993407, 0.11458152246731645, 0.09814336840734539, 0.14655066547784523, 0.11610104882765504, 0.0996009234867532, 0.1404711699881389, 0.1209812326756744, 0.11550047394337248, 0.11010363048652327, 0.9465102524096796, 0.974509608671675, 0.9695910372812586, 0.9388212042673773, 0.9640215881142207, 0.9736769075890246, 0.9685247480218943, 0.9707291201660023, 0.948368029375216, 0.4344008789905761, 0.40285965110338917, 0.39412772402966456, 0.3583722312980634, 0.3855591975280408, 0.36515985279853636, 0.39683292784215696, 0.36155120195078083, 0.4131231096300365, 0.7832101285571493, 0.6985308278059719, 0.6733878502513684, 0.6784743951753718, 0.20143901680685028, 0.7163209530093892, 0.6612919468189641, 0.7216822976525862, 0.7680170366314816, 0.5208631948014665, 0.3557517009201846, 0.32948752795267233, 0.4013616177474968, 0.11816833435698537, 0.371753801356394, 0.2686635882752444, 0.3942167663471363, 0.26191993597324503, 0.204186853065617, 0.3392312589234291, 0.471028355633865, 0.422917534325553, 0.1145375559272841, 0.23252411198820577, 0.3175723722780954, 0.2830470058394746, 0.26114021642563445, 0.17621231969025153, 0.24499638679929814, 0.29326762600855294, 0.26327676843872305, 0.2345002956123622, 0.23045625704567763, 0.305783544988653, 0.23141663114624023, 0.134011777627992, 0.42508261014381765, 0.4015232865905405, 0.41223875555823253, 0.37479573993002835, 0.380006230343523, 0.4234935655886952, 0.5312235536211932, 0.40432080082263233, 0.46332795269977556, 0.19457170095423815, 0.09355292695272799, 0.08733787778125113, 0.21636358490264107, 9.999999999998899e-05, 0.0982363403115587, 0.17601792690833862, 0.07726295813101969, 0.14503522818045478, 0.23681786435884356, 0.23318951697551704, 0.2680387822215814, 0.24815938389988523, 0.23191597334769876, 0.3228567418473365, 0.23962086827524787, 0.1969552350969992, 0.26072722988355335, 0.5584571351522123, 0.5785103290149086, 0.5951625389498956, 0.6291524269688097, 0.5741364413905, 0.5919697441012355, 0.6022108833988431, 0.5666423791657138, 0.5651287175780604, 0.11609482831558016, 0.12348486413285609, 0.10192234074753392, 0.15918670484962316, 0.10110080663108378, 0.09988495396563757, 0.1172652748050006, 0.09457321263676999, 0.11390358756749663, 0.17612391658950433, 0.1579697696814053, 0.15398939626089903, 0.1634914028884954, 0.18332466944110481, 0.19549736014298025, 0.19740190993676454, 0.21097714278671464, 0.17097426946777194, 0.36151484494900743, 0.39296150197965873, 0.3534895625306954, 0.3590123113625673, 0.3763111052020952, 0.3673670939685243, 0.3670841457038134, 0.4072778554506664, 0.40177502642031715, 0.29083604857560774, 0.2664065368229268, 0.28400288797824036, 0.20411329667712108, 0.24001369094753078, 0.3134803292740186, 0.31654144254679073, 0.30390006319479745, 0.2891627376309742, 0.1840524816298773, 0.18289367494753428, 0.17488884009864758, 0.17014130459764387, 0.1871271595332078, 0.18510470474340124, 0.17232535310851638, 0.20119443855446717, 0.19849254546789608, 0.1887860507722694, 0.2068307337493953, 0.189364224407513, 0.20737272542318708, 0.22374732208890546, 0.20202096458108676, 0.475416420580713, 0.20132308000930177, 0.21403724827268666, 0.16806411401857746, 0.15667337016790028, 0.8135228013972262, 0.1512936068822942, 0.1841928031834329, 0.7262681481408871, 0.18756874564507775, 0.1683571558720125, 0.7378480476609693, 0.7888959351401379, 0.1654626633447357, 0.19918691796889898, 0.16005115758646116, 0.1112506852557541, 0.19231489766714227, 0.15912309230061206, 0.2089235636836857, 0.09218125138373467, 0.17450673553431717, 0.19148911669996493, 0.1821919151697845, 0.18066866154867856, 0.21900529265442314, 0.17717706682388557, 0.18221899990643453, 0.1830534294563333, 0.19978814370482756, 0.07774975877386403, 0.07779147269272924, 0.07445604769735714, 0.07537129239639018, 0.07201935096479883, 0.0823124040982246, 0.08824600243409952, 0.07541412481591847, 0.07686646260495822]}, "mutation_prompt": null}
{"id": "a7c91a4e-511d-4535-be60-69e325d4e11a", "solution": "import numpy as np\n\nclass ImprovedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Slightly increased population size for diversity\n        self.F = 0.7  # Adjusted differential weight for better exploration\n        self.CR = 0.85  # Slightly adjusted crossover probability for exploration-exploitation balance\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand_to_best'\n        self.adaptive_factor = 0.85  # Adaptive factor adjusted for smoother convergence\n        self.diversity_threshold = 0.15  # Increased diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'rand_to_best':\n            return self.population[a] + self.F * (self.best_solution - self.population[a]) + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand_to_best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "ImprovedMemeticEvoStrategy", "description": "Adaptive Memetic Evolutionary Strategy with Enhanced Mutation Strategy and Diversity Preservation for Robust Optimization.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {}, "mutation_prompt": null}
{"id": "b499e3d2-522a-457d-aae9-568cb4e91db6", "solution": "import numpy as np\n\nclass StochasticAdaptiveMemeticStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 5 * dim  # Reduced initial population size for efficiency\n        self.F = 0.7  # Adjusted differential weight\n        self.CR = 0.8  # Modified crossover probability for balance\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.92  # Slightly adjusted adaptive factor\n        self.diversity_threshold = 0.15  # Increased diversity threshold\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n    \n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n    \n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n    \n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n    \n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n        \n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n            \n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n            \n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n                self.population_size = max(4 * self.dim, self.population_size // 2)\n            else:\n                self.mutation_strategy = 'rand'\n            \n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n    \n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "StochasticAdaptiveMemeticStrategy", "description": "Stochastic Adaptive Memetic Strategy with Dynamic Population Adjustment for Enhanced Exploration-Exploitation Balance.", "configspace": "", "generation": 70, "fitness": 0.3582262897506243, "feedback": "The algorithm StochasticAdaptiveMemeticStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8614236477863965, 0.8639961584383585, 0.8706732588190754, 0.8889625286601947, 0.8752770529710263, 0.855300085762033, 0.8778853437537176, 0.8563228077626348, 0.8449239588910277, 0.7607809034657296, 0.7469809381628671, 0.7729291419408665, 0.046374952376414647, 0.7366768596985025, 0.7669435270590912, 0.7691245617872209, 0.7826086208671459, 0.7698756178020838, 0.1359915965445576, 0.15152708267617732, 0.15734478508507233, 0.16331614547143725, 0.12887546892297375, 0.1538877748043347, 0.72045184349167, 0.10948071663118153, 0.13748015707031913, 0.10593055506233795, 0.11302223448732895, 0.10476326307118888, 0.12010884527328214, 0.07854175841448885, 0.1530769550670017, 0.14566378863315144, 0.10595516138807948, 0.174593458722902, 0.9796839331431153, 0.958327352495594, 0.9757598236505404, 0.9589796733198427, 0.9665175722889114, 0.957466265994245, 0.9618860270237004, 0.9549671490953932, 0.9490837441449327, 0.5541740586583939, 0.5888136684391252, 0.059224516767683255, 0.6376814710937965, 0.6943585237225303, 0.6658813816253966, 0.6264404396032273, 0.6377376633944829, 0.08834238120387505, 0.2252722474969694, 0.8236130256403604, 0.3628415034827992, 0.8744018788079985, 0.3690431995636728, 0.8713940793745018, 0.2325031473739857, 0.8230139000004141, 0.2352778208350096, 9.999999999998899e-05, 0.45746564748103824, 0.5317091767492466, 0.1274340408382495, 0.12769948695479305, 0.13406452274631175, 0.45771320756519096, 0.5142885362357247, 0.4352244416733979, 0.4674882582283464, 0.4797170434243524, 0.45183457482906475, 0.5265081841385673, 0.5227625676613261, 0.5247077602628661, 0.3851229921526095, 0.41151008220838625, 0.5551340863155263, 0.06733526492882447, 0.3577123755933811, 0.30564714305582963, 0.10941623762202257, 0.06536210189736269, 9.999999999998899e-05, 0.0035204595266741245, 9.999999999998899e-05, 0.28871055008459945, 0.07406378740168962, 0.4104697223027469, 0.16174603321826342, 0.11063167676699015, 0.30090874229521436, 0.2542826814109932, 0.3529810411383866, 0.46295118266952506, 0.3326892470810757, 0.18596498124981997, 0.06758395084017488, 9.999999999998899e-05, 0.21085273516879455, 0.39507355440731995, 0.10971750226997812, 0.4244239673873501, 0.13059827215412156, 0.10132186210408378, 0.28691793843937086, 0.25089153440872647, 0.2740151140327308, 0.3485856600101481, 0.45297943216578773, 0.39253628733942325, 0.2622585420478175, 0.2637432334535934, 0.18440437504343887, 0.6431143621713431, 0.5637634501765059, 0.6457342689775376, 0.5787110857078883, 0.664087049810163, 0.6399871686570997, 0.6221088729562843, 0.6515056186580148, 0.7653366676772566, 0.06723721121096404, 0.08732818234592121, 0.12707846874703077, 0.14600055090165842, 0.09965516593474244, 0.10845433774953184, 0.13637490877636338, 0.15111883766452427, 0.13583354566360162, 0.23096078337202175, 0.17939857141788162, 0.17909639227009544, 0.12039284133760697, 0.1510274379681723, 0.21499896735427515, 0.23175710981537723, 0.23384531498004735, 0.19775031683987498, 0.4940918178246415, 0.25210851332169504, 0.5309067345932377, 0.323277667487052, 0.5370029571716568, 0.4162884177809606, 0.5697971603147037, 0.3984071406797931, 0.5470041623333911, 0.30621541746384473, 0.34624631274105966, 0.13422124393784585, 0.3521468327542815, 0.42597153803071475, 0.3340717877836139, 0.2956557856367713, 0.37916081247670474, 0.14488032303603682, 0.21147273024941993, 0.19713493697046525, 0.23360740047728623, 0.21956846852355316, 0.1917665194927558, 0.195099319407669, 0.19918036199506028, 0.19582303533484335, 0.2573563946900044, 0.17166376376116477, 0.17332969247842722, 0.2125271873711223, 0.1856352077625839, 0.6979989761221839, 0.1855022855479046, 0.18973216861870268, 0.1858033697213346, 0.2239443265357851, 0.17101799909214166, 0.152402052793288, 0.18289316342711237, 0.16404400483363335, 0.16660731811878304, 0.17605838058393997, 0.16197152739574217, 0.18312406981901497, 0.1549029670879385, 0.7262220251326665, 0.15571689371016784, 0.1531539019508844, 0.8416141462199475, 0.16206789338655092, 0.8547028030820026, 0.10886568039195077, 0.11269682852138196, 0.8383892451075685, 0.17594291445741894, 0.17506945341846603, 0.17458374279666278, 0.19394869665158043, 0.18548243575502465, 0.19132170061162013, 0.20501020472477693, 0.1736791373876484, 0.17117500840383182, 0.09141296677069699, 0.08035225696753678, 0.07712175186503867, 0.0740282424061035, 0.0694651479802616, 0.09521109886303003, 0.08104492313655987, 0.07205736721733103, 0.08542257245286533]}, "mutation_prompt": null}
{"id": "8b9f751b-47e0-4cd9-bcec-f8d065db779a", "solution": "import numpy as np\n\nclass DynamicMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Population size for sufficient exploration\n        self.F = 0.7  # Adjusted differential weight for enhanced balance\n        self.CR = 0.85  # Adjusted crossover probability for efficient exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'best'\n        self.adaptive_factor = 0.95  # Adaptive factor for precise adjustment\n        self.diversity_threshold = 0.05  # Lowered diversity threshold for sharper convergence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.9)\n                    self.CR = np.clip(self.CR, 0.4, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand'\n            else:\n                self.mutation_strategy = 'best'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.005 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "DynamicMemeticEvoStrategy", "description": "Dynamic Memetic Evolutionary Strategy with Stochastic Adaptation and Diversity-driven Intensification.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {}, "mutation_prompt": null}
{"id": "e9236955-d7fb-4833-a05a-11467647808a", "solution": "import numpy as np\n\nclass AdaptiveMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim\n        self.F = 0.7  # Adjusted differential weight\n        self.CR = 0.85  # Slightly reduced crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'best'\n        self.adaptive_factor = 0.85  # Adjusted adaptive factor\n        self.diversity_threshold = 0.15  # Increased diversity threshold for exploration\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand'\n            else:\n                self.mutation_strategy = 'best'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticEvoStrategy", "description": "Adaptive Memetic Evolutionary Strategy with enhanced diversity control and dynamic learning rates to optimize convergence and exploration balance.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {}, "mutation_prompt": null}
{"id": "70ffc1dd-3b80-4b56-9f16-91b3eb281768", "solution": "import numpy as np\n\nclass DynamicAdaptiveMemeticStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Larger population for increased diversity\n        self.F = 0.7  # Adjusted differential weight for balance\n        self.CR = 0.8  # Balanced crossover probability for exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Adaptive factor for consistent adjustment\n        self.diversity_threshold = 0.15  # Enhanced explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.9)  # Adjusted range for F\n                    self.CR = np.clip(self.CR, 0.4, 0.95)  # Adjusted range for CR\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "DynamicAdaptiveMemeticStrategy", "description": "Dynamic Adaptive Memetic Strategy with Fitness-Based Recombination and Enhanced Stagnation Mitigation.", "configspace": "", "generation": 73, "fitness": 0.3177377322512382, "feedback": "The algorithm DynamicAdaptiveMemeticStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.7772013656230694, 0.7398038535704184, 0.7669339404448102, 0.7359033645988322, 0.754568188317309, 0.7645093100526286, 0.716019888270193, 0.7212886264747775, 0.7445639029096311, 0.5591098072792445, 0.5192208742073832, 0.5193553167009113, 0.49350471950648234, 0.4774812951597245, 0.508726180575517, 0.5636540085161261, 0.5192288849944536, 0.5416298053099775, 0.16051174245589517, 0.32039106070301204, 0.30103289740926076, 0.11688718328654013, 0.45870802416220957, 0.4112629987521683, 0.30366836133591124, 0.15321931073502182, 0.15778067103935267, 0.28407113521075833, 0.11825522263371113, 0.13875714777768866, 0.1370372881809777, 0.14749300244001584, 0.11764545187231723, 0.13352723473931205, 0.1108152963164366, 0.13689318609343304, 0.9586042610935519, 0.970044206538375, 0.9680896859211675, 0.9665400380095832, 0.9622387782273444, 0.9736772916015622, 0.9740464261794707, 0.966700118489161, 0.9655548620911425, 0.3696760297997467, 0.34173582572441574, 0.3924442586048126, 0.3711333184839346, 0.3697435240074072, 0.3900798318214165, 0.33113889170947464, 0.35964763287331813, 0.33544488293803965, 0.64823036894829, 0.3322317674840759, 0.341762375459019, 0.7797584663454342, 0.6609920114596721, 0.6805186268748236, 0.711544471326423, 0.6486266292208349, 0.2245700041153833, 0.27744018105610135, 0.12290551749864609, 0.26428385834719303, 0.11925386406600758, 0.30536082285064037, 0.2787077117313129, 0.2291507593433797, 0.2829160319526952, 0.2340705634907908, 0.3660921675925145, 0.3372993826847053, 0.11368419430201793, 0.4163099590285164, 0.23511269108419786, 0.3337088370173976, 0.3207289839702331, 0.25175182161086673, 0.3846780100061864, 0.16049060223366574, 0.11562234393000237, 0.12882485264689258, 0.0007315316006157868, 0.18583640863372752, 0.10889865422882339, 0.25777246229487005, 0.165425182049998, 0.15626126152086783, 0.35614923607006954, 0.2957582854137619, 0.3222562444483632, 0.04380054798519506, 0.10784590071918787, 0.3182713358410173, 0.46138537766865784, 0.37082490996122797, 0.3622294201355837, 0.08510682548405457, 0.030281480494350754, 0.0267918920105098, 0.0758970267016641, 0.10403823130821077, 0.12738369141312034, 0.10499148617591214, 0.037878809207397945, 0.1288484709875316, 0.22981456862255145, 0.20152778735346788, 0.20031383287014792, 0.24836054734261848, 0.2290547448193644, 0.17474774583372332, 0.05372374287030712, 0.046319382825487976, 0.20696002870863306, 0.5031453324464885, 0.5532861868433948, 0.5806834009787305, 0.5525305064962593, 0.5387776365015378, 0.5394070491086149, 0.5810930355216402, 0.5773224939265931, 0.5510541709717611, 0.12150928556567309, 0.1288154861363746, 0.13753741506499262, 0.09397730042739261, 0.11400444164764012, 0.11144949272384364, 0.11311170847550989, 0.13758077875183083, 0.12890999543778436, 0.13600250376812728, 0.15011331902037606, 0.24518325105171357, 0.1863290401043619, 0.17010881307886772, 0.14357604872702845, 0.11843652704949326, 0.19595048959336758, 0.1520809929864113, 0.36214591318242073, 0.3449588458420495, 0.32319801822365357, 0.37003338017861487, 0.30096707306253423, 0.3515001041998499, 0.3815632157718645, 0.42076876296654, 0.3641061107735313, 0.2852368657805582, 0.26238230367155047, 0.17962879395652886, 0.25528508729721733, 0.213787090207343, 0.2982268070585684, 0.3134400553680152, 0.29604211597535646, 0.33331414313493646, 0.18629298588695464, 0.22246607788829453, 0.19197578988372954, 0.21625138114459475, 0.18545902952226645, 0.18936144259205634, 0.21893832442315675, 0.18274411758650988, 0.19469750769993432, 0.2286381774636056, 0.23065738345010878, 0.21269427953298936, 0.19615186509627813, 0.2062447559129701, 0.5658206203519429, 0.22694134353226014, 0.36871990114766307, 0.20529142659429223, 0.15551176829810265, 0.7835403582664453, 0.7491410335665319, 0.18527641157196817, 0.7544711544093607, 0.18482771973575063, 0.13888954946893228, 0.16904849069885042, 0.15706619397123944, 0.46288294059462365, 0.198009480032302, 0.186113286425856, 0.1622388961713186, 0.11135701470458226, 0.20365120697287298, 0.6110395085280407, 0.2054825134783611, 0.20563329206100256, 0.16763154155214366, 0.20380150296897126, 0.18811041362729286, 0.18739950713303732, 0.17855799173378017, 0.1798362894064336, 0.17644704021667856, 0.17447545990544788, 0.16986980814059427, 0.0814139432611859, 0.07335527036978806, 0.07664545346171292, 0.07722751581640552, 0.07850694780298495, 0.08855727472673569, 0.07486083665045695, 0.07443682196722234, 0.07881258675550962]}, "mutation_prompt": null}
{"id": "d616f840-bcfc-4581-b468-a366ebe92242", "solution": "import numpy as np\n\nclass DynamicAdaptiveMemeticStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Increased population size for diverse exploration\n        self.F = 0.5  # Adjusted differential weight for better balance\n        self.CR = 0.85  # Crossover probability set for efficient exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand-to-best'\n        self.adaptive_factor = 0.88  # Slightly more aggressive adaptive factor\n        self.diversity_threshold = 0.15  # Increased diversity threshold for exploration\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'rand-to-best':\n            return self.population[a] + self.F * (self.best_solution - self.population[a] + self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.7)\n                    self.CR = np.clip(self.CR, 0.6, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand-to-best'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "DynamicAdaptiveMemeticStrategy", "description": "Dynamic Adaptive Memetic Strategy with Stochastic Local Search to enhance exploration-exploitation balance in optimization.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {}, "mutation_prompt": null}
{"id": "790ef815-9625-40cc-b802-196a4de05ecd", "solution": "import numpy as np\n\nclass HybridEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Increased population size for better exploration\n        self.F = 0.5  # Moderate differential weight to maintain balance\n        self.CR = 0.8  # Moderate crossover probability for reliable exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand-to-best'\n        self.adaptive_factor = 0.85  # Slightly reduced adaptive factor for finer adjustment\n        self.diversity_threshold = 0.15  # Increased diversity threshold for wider exploration\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'rand-to-best':\n            return self.population[idx] + self.F * (self.best_solution - self.population[idx] + self.population[a] - self.population[b])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.7)\n                    self.CR = np.clip(self.CR, 0.6, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand-to-best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.80 and stagnation_counter > self.population_size * 0.20:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridEvoStrategy", "description": "Hybrid Evolutionary Strategy with Adaptive Mutation and Diversity Control to Enhance Global Search Efficiency.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {}, "mutation_prompt": null}
{"id": "891c4cfc-56ab-4264-9319-35be0185005f", "solution": "import numpy as np\n\nclass AdaptiveMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Increased population size for diversity\n        self.F = 0.5  # Lower differential weight for granular steps\n        self.CR = 0.85  # Balanced crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand-to-best'\n        self.adaptive_factor = 0.95  # Stronger adaptive factor\n        self.diversity_threshold = 0.15  # Slightly higher diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'rand-to-best':\n            return self.population[a] + self.F * (self.best_solution - self.population[a]) + self.F * (self.population[b] - self.population[c])\n        elif self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 12:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-6:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.7)\n                    self.CR = np.clip(self.CR, 0.6, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand-to-best'\n\n            if func_calls > self.budget * 0.5 and stagnation_counter > self.population_size * 0.2:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticEvoStrategy", "description": "Adaptive Memetic EvoStrategy with Self-organizing Hyper-parameters and Multi-Stage Mutation Strategy.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {}, "mutation_prompt": null}
{"id": "8bea06d8-9445-4fc2-a47d-fcd7c450bf7f", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.F = 0.6  # Moderate differential weight for balance\n        self.CR = 0.9  # Increased crossover probability for better exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.90  # Adaptive factor for consistent adjustment\n        self.diversity_threshold = 0.1  # Explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Adaptive Learning Rate utilizing explicit diversity maintenance to improve convergence.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8732766226181966, 0.8642243016655347, 0.8659935461581776, 0.8547781410271569, 0.8489843434467998, 0.8291276393042519, 0.8542008358345242, 0.8671068584652082, 0.8460371044231281, 0.754998745647667, 0.6685360222833198, 0.7094896514843003, 0.7032145651648585, 0.682277274361005, 0.6957365976649358, 0.7782177807854866, 0.7414169653758014, 0.7488975639652787, 0.1260365113730908, 0.11863917586582173, 0.12282585325225315, 0.1730225647967698, 0.17523928355619023, 0.13816749343700052, 0.13605050692107412, 0.12476910900380311, 0.13292032060456171, 0.13829873376169632, 0.11018068180767204, 0.1442854808839329, 0.11288557073308203, 0.1733192939832332, 0.09969463812954271, 0.11619831825062776, 0.12149586278962365, 0.10815664397811064, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6290162284567968, 0.5922781557132764, 0.588780814996684, 0.6670225256780604, 0.644425863156447, 0.6348853304366482, 0.51465906649409, 0.6482033543525607, 0.605582459343158, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5206291164262296, 0.12125465973297, 0.12861577462045204, 0.5617507875338423, 0.12736644596554436, 0.7265431498207405, 0.39518306870503206, 0.5366229774522695, 0.40288428683431365, 0.44784254744102214, 0.1288152535756879, 0.49586790605034203, 0.5368670185254014, 0.575537508950831, 0.5203924925143957, 0.5831511620691582, 0.1264497201800464, 0.5038099392266262, 0.49934707714237136, 0.5284834725514336, 9.999999999998899e-05, 0.6010321473736554, 0.382485077859132, 0.36935365984943236, 0.48364233848944393, 0.4198517361019898, 0.27367132718451503, 0.5963278370603864, 0.5224253748143389, 0.4653302118007083, 0.6831886960244166, 0.580173927849811, 0.4952337541702897, 0.5792440662318769, 0.08123422967530491, 0.7078451166151098, 0.0739010626179103, 0.1084619212107013, 0.3855359850948187, 0.3521518163304569, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.43403222200219826, 0.42711740183650415, 0.46483801601092856, 0.03805354803257921, 0.4661126798316374, 0.40871735786607777, 0.3718109253001566, 0.3371319365795915, 0.6948568389807652, 0.6245302587707393, 0.6884578786474407, 0.7321140615795139, 0.6024203182118643, 0.6730790023229437, 0.6518467238363761, 0.6501001592558935, 0.7801717998256352, 0.14314049685128938, 0.09503011201524791, 0.11130418714052726, 0.14066098435242724, 0.10992720434210046, 0.12329404616465311, 0.13665658230927002, 0.13308825011320846, 0.11906316999336908, 0.18600333865198404, 0.2673014954593603, 0.2556784400268317, 0.1639969500449312, 0.16418829342256847, 0.24061537736670835, 0.15552857239351547, 0.20594675517067074, 0.31461537770532055, 0.49199369420021233, 0.34834637766463405, 0.5467715808924283, 0.43074953391482973, 0.500392811902082, 0.40577304191016295, 0.24173248114034063, 0.20595781597406315, 0.5485168868695214, 0.19453192043951406, 0.2703873449117091, 0.4117133465805445, 0.24211103021888292, 0.39158270919502947, 0.4408556271588616, 0.214665216511152, 0.3326676085837589, 0.3686769563545761, 0.22406086113739287, 0.2162592903384254, 0.26643093577723, 0.22076107381384635, 0.2130608649876382, 0.21791115593653, 0.21324382202328362, 0.1841692469811571, 0.23955364122471723, 0.7758472744891161, 0.19081196702814418, 0.20592291284862474, 0.18665042546779664, 0.20165006658640328, 0.19146475586217948, 0.196949486636246, 0.18052241226414334, 0.199244686156535, 0.16398331650145992, 0.18666358427992769, 0.9130595737841963, 0.10337077808419859, 0.16896991770819714, 0.16737607409133837, 0.1865383984864062, 0.12487727769843693, 0.8394302306900628, 0.8918762231358082, 0.15613242217346068, 0.886246531723765, 0.20984586224128066, 0.8537568020847193, 0.1615534138203335, 0.10458026021234912, 0.16621803419387982, 0.8676933569508227, 0.1801010290889843, 0.1861849159422556, 0.1810781877376637, 0.17079458853552554, 0.18721586379369282, 0.1805003181901007, 0.16824230993890488, 0.1735854651922597, 0.18195722678289739, 0.10159357200343222, 0.0960010997993137, 0.09013961566952788, 0.08537947729245021, 0.09032768963826765, 0.11212037078744308, 0.08284381425380383, 0.08679771977119677, 0.07310908540901806]}, "mutation_prompt": null}
{"id": "1766b24e-fe02-42a1-98f5-b64e298b4a4d", "solution": "import numpy as np\n\nclass AdaptiveEnhancedMemeticStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85\n        self.diversity_threshold = 0.15\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.2 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveEnhancedMemeticStrategy", "description": "Adaptive Enhanced Memetic Strategy with Dynamic Mutation and Random Walks for Improved Exploration.", "configspace": "", "generation": 78, "fitness": 0.3740222306464915, "feedback": "The algorithm AdaptiveEnhancedMemeticStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8521118392558243, 0.8238460312970916, 0.8582640417284958, 0.8306155985523442, 0.8344850846126968, 0.8364943178285995, 0.8525100730414987, 0.8470251355367588, 0.8616104567742566, 0.7004698137166148, 0.6370522033713294, 0.6943399975162755, 0.7087752962385456, 9.999999999998899e-05, 0.740356610559211, 0.7271685801180647, 0.7359955727157942, 0.7062829878896069, 0.15215686908160098, 0.13828213097406605, 0.16298974146354106, 0.14477315912484479, 0.14381233415717398, 0.17170929935681867, 0.14372999915627638, 0.16483682268497546, 0.15332204274593164, 0.1547085918907467, 0.10270751775645748, 0.16331982289992486, 0.13321042895303503, 0.13206960640305276, 0.12060297776019324, 0.09085978202369716, 0.13507266649509342, 0.14621455169208497, 0.9680849786402846, 0.9595193997631918, 0.9643857760680521, 0.9352124663378114, 0.9674130965748318, 0.9614810734534257, 0.9812721887997061, 0.9817268424984187, 0.9789422571523497, 0.5769573181245853, 0.6147755248388459, 0.5921891393753664, 0.555810118393524, 0.5950163281975522, 0.5988658301266425, 0.6015270085863784, 0.5861443175463379, 0.5453669898151479, 0.9113593721283383, 0.36649471152836266, 0.8198303801171747, 0.866728140250622, 0.8451652260684992, 0.8403478828305304, 0.764739900229811, 0.8007609761120267, 0.2237813353296092, 0.12862317616038432, 0.39553214662206737, 0.3231182271785674, 0.4922743657788269, 0.1274965061886857, 0.3556194480609032, 0.38568179306049866, 0.47581482338072323, 0.1283733739877827, 0.2552628105427811, 0.528922522778634, 0.4812204926204171, 0.12969551197037277, 0.2643794838367729, 0.5203221450443534, 0.3996340717720609, 0.3722094020467208, 0.4100809231046122, 0.28784430382441006, 0.35159759098856747, 0.07724361908158084, 0.0703649012909795, 0.07116131486850608, 0.15334170228864719, 0.4587009735842352, 0.05853015312262866, 0.07045732628302015, 0.5250050600739811, 0.484441111344325, 0.5643534055964206, 0.4233362625012095, 0.3306529108489914, 0.5077126045573195, 0.14708930106596818, 0.2869710127039746, 0.4967675363607451, 0.16137063120144435, 0.2910577514626381, 0.11384580438705705, 0.32331482831126335, 0.3081572907638983, 0.3302951318636548, 0.13850660467447373, 0.12327073917024423, 0.0903549240402064, 0.4050576166462584, 0.3131134592637532, 0.34619516321260524, 0.4242501869465003, 0.3234873990815068, 0.40591109784595236, 0.305088213512664, 0.3219561497649238, 0.3646485395788265, 0.682722551934309, 0.6658387339730762, 0.6906026257413878, 0.6993894020493852, 0.6191720353916613, 0.6091933244644887, 0.7306993435606034, 0.6646866475896251, 0.7050415043459352, 0.11430259139619536, 0.13507667277515034, 0.13199264246803089, 0.1180384781521372, 0.10039938123624637, 0.11634481204830549, 0.12167347000410844, 0.11632104854191316, 0.09729878661256985, 0.1636001200393794, 0.2668745796485026, 0.15197923464846574, 0.23475300084159467, 0.2892612139255496, 0.23680277074636513, 0.32639128088126, 0.22510700962032737, 0.17614568019808519, 0.37384668086074957, 0.44496967395969456, 0.4188417787520381, 0.39581847450999863, 0.5229600511461883, 0.46611399090316463, 0.44492383185615514, 0.5144521024622151, 0.5180070592678268, 0.22021485139475716, 0.2708986064322667, 0.36605332612619623, 0.2981111708789914, 0.2707727409966654, 0.24938587944461088, 0.17307326830870262, 0.43204855630207917, 0.37739373039082724, 0.20342701421731846, 0.2021109412168921, 0.19810287562768025, 0.17318704914014393, 0.17936930521975913, 0.16612272322023747, 0.179103248373369, 0.22752071307369004, 0.20130195097286419, 0.20407057205344536, 0.18406417392788055, 0.6346649642262228, 0.21806353229076192, 0.19188932749076482, 0.21502139197776438, 0.23608113581513368, 0.24264595972828729, 0.20331842311342208, 0.18629116570014825, 0.1843239847550291, 0.868028501877851, 0.17761304178861193, 0.8489117538218245, 0.168530989657679, 0.1104377076506442, 0.8292037498492486, 0.13329746511156004, 0.15527087363033365, 0.21039858531816058, 0.12064877438770727, 0.7285740754468877, 0.16666875012340165, 0.16425199550256042, 0.20802379024857742, 0.1366287510839468, 0.11244310167872085, 0.18203373130537215, 0.17170891035270963, 0.18150030277581342, 0.18330268569799557, 0.18594789821729574, 0.18276854538409149, 0.24587026960657565, 0.17451742272371285, 0.18690919996151956, 0.07097065592936147, 0.07648008818669239, 0.07255023291893214, 0.06732952939933334, 0.08059908923964854, 0.10438552573142656, 0.09050692491774592, 0.09634439684455387, 0.08237492379456546]}, "mutation_prompt": null}
{"id": "967924da-ec6b-43ab-b61b-89c77084a230", "solution": "import numpy as np\n\nclass DynamicMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim\n        self.F = 0.7  # Slightly increased differential weight\n        self.CR = 0.85  # Slightly decreased crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.92  # Adjusted adaptive factor\n        self.diversity_threshold = 0.15  # Increased diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.4, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.12 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "DynamicMemeticEvoStrategy", "description": "Dynamic Memetic Evolutionary Strategy with Adaptive Mutation and Crossover for improved exploration and exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.3767515652227599, "feedback": "The algorithm DynamicMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.7925760945615186, 0.8092946628977767, 0.8146883056679018, 0.8122618506253677, 0.8196850458719143, 0.8128511163319998, 0.8100392698412008, 0.8105706493043401, 0.8045602845017483, 0.6490644845452307, 0.6743929731985552, 0.6615801863774067, 0.6596129842759306, 0.6672986840018297, 0.662556515746235, 0.659461529092806, 0.6478187353949034, 0.6369445395032796, 0.5017219706319935, 0.13252495056708358, 0.16016363493820485, 0.12225284559008942, 0.132086587619765, 0.1356135356212177, 0.1520921964255867, 0.1344458074269418, 0.16915573754247348, 0.10136257605542487, 0.16279952959865873, 0.16518725662910982, 0.10116208522598957, 0.10853741768434833, 0.11204809462372867, 0.11114409876049436, 0.10829463760416946, 0.13512434994111278, 0.9277174934035897, 0.9728461392022013, 0.9601785200764744, 0.9554127202704289, 0.9872481130183535, 0.9670513829628764, 0.9417376433594046, 0.9228919175438305, 0.9839614848902066, 0.4485221420131347, 0.4807582564407291, 0.4714658279255576, 0.49900198141877605, 0.5384636738246016, 0.5072459566969689, 0.4852379823791062, 0.47093266339245055, 0.3964446503986214, 0.7605015987392502, 0.8342860586117865, 0.3668588375826224, 0.7864098399557622, 0.14195515992050955, 0.7994765344071587, 0.8166038753095695, 0.7795630295285173, 0.7524374236966496, 0.34396755450142646, 0.12921234819979743, 0.4629506401777884, 0.4984705807615236, 0.47567349085393584, 0.3704865886887301, 0.3783656156516989, 0.496920696965337, 0.4602895263143463, 0.05163302004077819, 0.051644293436080235, 0.1252782812694948, 0.40886880619641974, 0.12514345145427141, 0.548651479477944, 0.46499075378463894, 0.25014809027347806, 0.4511918447629001, 0.3901871240530278, 9.999999999998899e-05, 0.3509769673974068, 0.320027119078526, 0.08763606216504527, 0.0005549220655515219, 0.4992765623288361, 0.3374911501226605, 0.016035821238506887, 0.430232278866144, 0.47931780354115117, 0.39887412529083055, 0.5152247127167002, 0.3590025000445056, 0.47438399241705465, 0.44992663198585825, 0.5049055040653897, 0.5545793017029184, 0.09490524292111202, 0.07872529319570842, 9.999999999998899e-05, 0.10720368951038983, 0.26690303047541664, 0.3769447577545425, 0.16085301394190776, 0.10218152274855907, 0.2567086853156154, 0.28944873785180913, 0.010655523247615206, 0.2587923392867316, 0.3221467089060176, 0.29703100032881, 0.33744674471498926, 0.15755865262865332, 0.33045585967757973, 0.3057707378330481, 0.635295748121872, 0.6365994640503818, 0.6076050570083424, 0.6212304139293053, 0.6476568494462889, 0.6263803063914486, 0.6165351364017483, 0.5964027898276341, 0.6024314364090142, 0.09387376294742611, 0.09177514014713728, 0.12299699386865026, 0.14692842734558453, 0.12441658935553246, 0.1223542847708432, 0.13562880408283096, 0.12421995376535178, 0.09907589554053597, 0.29542324276133747, 0.17557079926440533, 0.6141627589685995, 0.14055316871789436, 0.16495003725420387, 0.21523172217642939, 0.16902668183463443, 0.27152359373613455, 0.1484976539411973, 0.49104907323021585, 0.21285827323862505, 0.41093070424446154, 0.4586687756474972, 0.40199770196419715, 0.42968117545609785, 0.4748401353334716, 0.2787175371337538, 0.43618326096951565, 0.18466540550518518, 0.28600403805526, 0.23788199993666825, 0.26944136358322035, 0.30451998710807726, 0.28476441644188955, 0.3290099810009506, 0.3506705194427159, 0.3270099216510175, 0.223662507258923, 0.18972193251332514, 0.20005290558199162, 0.21569483718556304, 0.21091345953093288, 0.2058409268086504, 0.18846079021540318, 0.18306417210271086, 0.19533982611511114, 0.21164529529927234, 0.23085781004750183, 0.1852694026949665, 0.22759099721735643, 0.19983596144338223, 0.2147176583048268, 0.1856237913302049, 0.1975166295590336, 0.6306251387117534, 0.19318997465742782, 0.7886287333833483, 0.15258904899457215, 0.1783034252137713, 0.8131888603351809, 0.19745964024691787, 0.8344787260776642, 0.16460579279782628, 0.2008172651832396, 0.8032750328465108, 0.11302804872644678, 0.8185459300678433, 0.21542264339714934, 0.8364062187316212, 0.7787774244256123, 0.20701233263101382, 0.8397852229144407, 0.8689507300930187, 0.1770019102257434, 0.18047420856949592, 0.1762833277399355, 0.20946942467081597, 0.1694822691982879, 0.17476545618676187, 0.18049577752791668, 0.17108502009604676, 0.17038532429955067, 0.06516095713322556, 0.07877506443567583, 0.06901231161719112, 0.09039991054816543, 0.1010891384075645, 0.07403591098323736, 0.08145602896725723, 0.08418373773538623, 0.08600492169709306]}, "mutation_prompt": null}
{"id": "42873e3a-6662-418d-9202-a1de35caa4d7", "solution": "import numpy as np\n\nclass AdaptiveMemeticHybridStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 4 + int(3 * np.log(dim))  # Dynamic population size based on dimension\n        self.F = 0.5  # Moderate differential weight\n        self.CR = 0.8  # Reasonable crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Slightly increased adaptive factor\n        self.diversity_threshold = 0.05  # Lowered diversity threshold\n        self.hybridize_rate = 0.3  # Probability of hybrid crossover strategy\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def hybridize(self, target, mutant):\n        if np.random.rand() < self.hybridize_rate:\n            weight = np.random.rand()\n            trial = weight * target + (1 - weight) * mutant\n            return np.clip(trial, self.bounds[0], self.bounds[1])\n        else:\n            return self.crossover(target, mutant)\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.hybridize(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.7)\n                    self.CR = np.clip(self.CR, 0.4, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.15:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticHybridStrategy", "description": "Novel Adaptive Memetic Strategy with Dynamic Population and Stochastic Hybridization for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 80, "fitness": 0.10171173279954296, "feedback": "The algorithm AdaptiveMemeticHybridStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.09.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.15811078197014072, 0.19970781383859904, 0.18261050892449426, 0.07982386933928376, 0.11324003387313186, 0.11981023101567967, 0.18788738302515662, 0.27573255783130757, 0.184012921107214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07005369969004382, 0.09758078907805234, 0.052012550122529366, 0.11622052684021511, 0.0839070651614644, 0.064795571782307, 0.07346442943840215, 0.0829706056197721, 0.05507358246645855, 0.07578637420840806, 0.01297460981904408, 0.036076861307902997, 0.12206149608439087, 0.0437312907019074, 0.06539400570193665, 0.009454402662682826, 0.01879265379142181, 0.03435857573940193, 0.10634076271231929, 0.06660397394053252, 0.06785295535993596, 0.07037605631716293, 0.10301036890328963, 0.0719935689985336, 0.04051444135938764, 0.122518074595659, 0.3577401054372461, 0.04103875342813501, 0.041515326588803525, 0.05373769313143617, 9.999999999998899e-05, 0.06265502280479873, 9.999999999998899e-05, 0.0932204855158758, 0.06275602327814345, 9.999999999998899e-05, 0.13701737436449513, 0.09881486675178475, 0.09371886455400835, 0.08428136213192516, 0.1640801047256264, 0.10951269809798336, 0.07604893105334909, 0.0903394110845751, 0.054982068641485915, 9.999999999998899e-05, 9.999999999998899e-05, 0.08736802969778923, 0.004223712568240945, 9.999999999998899e-05, 9.999999999998899e-05, 0.08600161759867675, 9.999999999998899e-05, 0.015160563593368037, 9.999999999998899e-05, 9.999999999998899e-05, 0.00958182562362142, 0.12555491514357586, 0.12168684651484041, 0.014514244476300564, 0.04700260321994121, 9.999999999998899e-05, 0.12832552341280534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05863386300325968, 0.03793113547787508, 0.16952249882880277, 0.09445585985590244, 0.004871645269010516, 9.999999999998899e-05, 0.11032705462356207, 0.051210277172592966, 0.07334495355727633, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020758074949978056, 0.015025453500680075, 9.999999999998899e-05, 0.014656766911750885, 9.999999999998899e-05, 0.040736278130268144, 9.999999999998899e-05, 9.999999999998899e-05, 0.2269526987607141, 0.18738249395291395, 0.190401115248355, 0.13095557022591442, 0.19298039991303018, 0.13541296538545955, 0.12874579873419223, 0.18424116805288326, 0.2819246780386113, 0.14973408723843262, 0.14497229318675686, 0.029573696781427294, 0.025130113406780952, 0.06011930762798079, 0.05560986311371363, 0.053742476517319115, 0.04448139816288477, 0.08336859555525189, 0.12540225207824263, 0.15613646996388675, 0.1509221003675537, 0.19734895394084595, 0.2348308493824025, 0.1476142229283769, 0.3265192770284462, 0.10760906313486318, 0.14580336605954547, 0.2230322274592973, 0.21590755528947048, 0.14336386494289577, 0.17669139861191963, 0.21230901273303948, 0.21313585131281665, 0.160852202407327, 0.14729884150780903, 0.18536309166854137, 0.12368788382155527, 0.18826046404651886, 0.11502014732469346, 0.1467246837247076, 0.1664968079951603, 0.136063367991887, 0.20862630774655266, 0.11751408992166745, 0.09115204048541414, 0.2062538002049542, 0.23764588794810804, 0.24773013296196866, 0.278542131395342, 0.24196235416002776, 0.2123801591640817, 0.20851715760296985, 0.18647551913470695, 0.20964794717990243, 0.1482581998680529, 0.18819467204218432, 0.17989542095309774, 0.16383585052065486, 0.17050796940336188, 0.18193277351862336, 0.06844088817388894, 9.999999999998899e-05, 0.16394537421421596, 0.4950412756364313, 0.1682050637367456, 0.17387471463532478, 0.17211562685168846, 0.1575963252675069, 0.2561665094582578, 0.08915720070898026, 0.1707005733031518, 0.14418851479348593, 0.37862966332554926, 0.16646937013730845, 0.1040298150996325, 0.10474138609053774, 0.11382254637653222, 0.16958237262282982, 0.10482178027109057, 0.07690500580569315, 0.10601085894037765, 0.2110412368972825, 0.18617281302554045, 0.196793560079778, 0.21383990565725208, 0.18300041034497283, 0.19574287165269455, 0.19101547217631998, 0.1731406141615225, 0.1881913960776357, 0.0893435676299621, 0.0784959652827143, 0.09096358739587318, 0.07583355814824011, 0.07348230465305006, 0.08786163989022622, 0.06952565125409516, 0.0567405565815885, 0.071200990459246]}, "mutation_prompt": null}
{"id": "ab94fa13-cc23-496a-b115-22e2534eb550", "solution": "import numpy as np\n\nclass AdaptiveMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 7 * dim\n        self.F = 0.7\n        self.CR = 0.85\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85\n        self.diversity_threshold = 0.15\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.7 and stagnation_counter > self.population_size * 0.2:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1, self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveMemeticEvoStrategy", "description": "Adaptive Memetic Evolutionary Strategy with diversity-aware mutation and strategic crossover adjustments for robust optimization.", "configspace": "", "generation": 81, "fitness": 0.35602156976302635, "feedback": "The algorithm AdaptiveMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.7533210949627268, 0.7686226769907524, 0.799012282890275, 0.7822514848702886, 0.7929356963578411, 0.7994784119085521, 0.8103562758939471, 0.8086182200114471, 0.7895647376412392, 0.6047671606548234, 0.6448269032591041, 0.6286815501034766, 0.5957568915744678, 0.5936516487048313, 0.6072829547732868, 0.6084292098577573, 0.5868850115958955, 0.5801945163183786, 0.15756849607232704, 0.4494397839361962, 0.14395783067933443, 0.14065756375603922, 0.10878293037103925, 0.1627380081895713, 0.3850271081376634, 0.15557954077633807, 0.13271445017866668, 0.1402641736289597, 0.1281554916910732, 0.09915399071089304, 0.14402767173358333, 0.1383041335279973, 0.12452888104243465, 0.14379706341710485, 0.15548707583499055, 0.1289274515522173, 0.9474284294869215, 0.9204609952452475, 0.9594353579190945, 0.9172976996619904, 0.9845725404904614, 0.9859063938483758, 0.9341621311675355, 0.9846860925978806, 0.9399510665089442, 0.4393399467628053, 0.4089034444238877, 0.45554247118535784, 0.46388999944191334, 0.4340230377063543, 0.37473119608881456, 0.46987304614399616, 0.3954353511198103, 0.4413423444687584, 0.7467309248372456, 0.7303069558353421, 0.3542457339440873, 0.7571990581415389, 0.7338681435146672, 0.7772169692191169, 0.8032212861110033, 0.7392440509706546, 0.7459098950380488, 0.4980421295276538, 0.30031345627156125, 0.1263454339530723, 0.11937217968960645, 0.3991159979750101, 0.43001130049671776, 0.3007212171240289, 0.35463710670059667, 0.422223927698937, 0.12554117506385154, 0.25248111408598817, 0.10638530053324669, 0.2760181942238952, 0.4221980106302955, 0.5561439667280069, 0.4382895509950736, 0.12410418791567113, 0.422854457564229, 0.38380298691139225, 0.3159119616814189, 0.2669171134119389, 0.19652416781706494, 0.21284436424312725, 0.3044499863128095, 0.35859638222211687, 0.3144266667587734, 0.14071051691631642, 0.4921903916567649, 0.4782204575172283, 0.4060718079386022, 0.3885247457192933, 0.46399581977025106, 0.13404040486377122, 0.44552254016393333, 0.44580505439596396, 0.15161213371203097, 0.06717243483909241, 0.05021406756973701, 0.10211618688536095, 0.16192693610402675, 0.07920602394182263, 0.2505556906746378, 0.16985329661294746, 0.09243976167707502, 0.21028655794308293, 0.2734172628246111, 0.25745387187978463, 0.31329071676761766, 0.3248100002263985, 0.30547485749732584, 0.3260244717682559, 0.2994045805450929, 0.27997566727441736, 0.295174350577848, 0.6112064780472113, 0.6390153006452968, 0.7077549758453764, 0.6314086257096028, 0.625430157578807, 0.5858373019054657, 0.613060311317323, 0.6049101129564227, 0.5906106901123275, 0.09306335511608144, 0.11439235250548885, 0.1124229849436118, 0.1111618962304366, 0.08887581886970897, 0.12540575385919295, 0.14379282097491164, 0.09815618497982903, 0.0838487446559899, 0.4048687355046787, 0.15130021198479282, 0.3567441774246328, 0.117176233168929, 0.2690475370801817, 0.2199755262334503, 0.1455288700984615, 0.20782379134848594, 0.12075385265688943, 0.41167026767706516, 0.37482135082765256, 0.3961466847161118, 0.3869566816797958, 0.3975181617772441, 0.4548152896891754, 0.44838074291001817, 0.44429521621949974, 0.4020415291177555, 0.3121576163888159, 0.2064667767093914, 0.22601485165294422, 0.18505627780304235, 0.1962170251756813, 0.3114374178367787, 0.3305571296752684, 0.3060644600323277, 0.3916337233095286, 0.19237310085271142, 0.1813945666685126, 0.21326889298129592, 0.22686524294168375, 0.18915640640704645, 0.20425322725880357, 0.20552009664658233, 0.19913169827970767, 0.20413588557214601, 0.19301331499511531, 0.20112840888297345, 0.196811820830877, 0.6089847077573036, 0.2409610221076962, 0.20277152797940812, 0.22965123819953037, 0.20386188582567688, 0.20565757879658764, 0.1617683748519505, 0.1507249504790943, 0.1603475894199493, 0.169372378517053, 0.16651759118562182, 0.18992587143372686, 0.7015410417962868, 0.11493659396682776, 0.1563895770078243, 0.20499122382779755, 0.7879086748587552, 0.12567421031105208, 0.7624254058907325, 0.207265482848092, 0.20154379534024958, 0.7239474976455553, 0.15927013567211468, 0.7413111163864345, 0.1888799233629198, 0.1761312517306376, 0.18547310325686972, 0.18191115065493324, 0.182968593925235, 0.18016253781254, 0.17294773455141077, 0.17232170842428474, 0.17501365711777672, 0.08212796027649982, 0.07901451680585292, 0.07488719878444172, 0.07454517012957618, 0.07514981689799605, 0.06085080344469551, 0.08229202849694794, 0.07346239054563375, 0.06945750293622965]}, "mutation_prompt": null}
{"id": "3e136877-6300-4a0a-b50b-1e369286f1a6", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.F = 0.6  # Moderate differential weight for balance\n        self.CR = 0.9  # Increased crossover probability for better exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.90  # Adaptive factor for consistent adjustment\n        self.diversity_threshold = 0.1  # Explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Adaptive Learning Rate utilizing explicit diversity maintenance to improve convergence.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8732766226181966, 0.8642243016655347, 0.8659935461581776, 0.8547781410271569, 0.8489843434467998, 0.8291276393042519, 0.8542008358345242, 0.8671068584652082, 0.8460371044231281, 0.754998745647667, 0.6685360222833198, 0.7094896514843003, 0.7032145651648585, 0.682277274361005, 0.6957365976649358, 0.7782177807854866, 0.7414169653758014, 0.7488975639652787, 0.1260365113730908, 0.11863917586582173, 0.12282585325225315, 0.1730225647967698, 0.17523928355619023, 0.13816749343700052, 0.13605050692107412, 0.12476910900380311, 0.13292032060456171, 0.13829873376169632, 0.11018068180767204, 0.1442854808839329, 0.11288557073308203, 0.1733192939832332, 0.09969463812954271, 0.11619831825062776, 0.12149586278962365, 0.10815664397811064, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6290162284567968, 0.5922781557132764, 0.588780814996684, 0.6670225256780604, 0.644425863156447, 0.6348853304366482, 0.51465906649409, 0.6482033543525607, 0.605582459343158, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5206291164262296, 0.12125465973297, 0.12861577462045204, 0.5617507875338423, 0.12736644596554436, 0.7265431498207405, 0.39518306870503206, 0.5366229774522695, 0.40288428683431365, 0.44784254744102214, 0.1288152535756879, 0.49586790605034203, 0.5368670185254014, 0.575537508950831, 0.5203924925143957, 0.5831511620691582, 0.1264497201800464, 0.5038099392266262, 0.49934707714237136, 0.5284834725514336, 9.999999999998899e-05, 0.6010321473736554, 0.382485077859132, 0.36935365984943236, 0.48364233848944393, 0.4198517361019898, 0.27367132718451503, 0.5963278370603864, 0.5224253748143389, 0.4653302118007083, 0.6831886960244166, 0.580173927849811, 0.4952337541702897, 0.5792440662318769, 0.08123422967530491, 0.7078451166151098, 0.0739010626179103, 0.1084619212107013, 0.3855359850948187, 0.3521518163304569, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.43403222200219826, 0.42711740183650415, 0.46483801601092856, 0.03805354803257921, 0.4661126798316374, 0.40871735786607777, 0.3718109253001566, 0.3371319365795915, 0.6948568389807652, 0.6245302587707393, 0.6884578786474407, 0.7321140615795139, 0.6024203182118643, 0.6730790023229437, 0.6518467238363761, 0.6501001592558935, 0.7801717998256352, 0.14314049685128938, 0.09503011201524791, 0.11130418714052726, 0.14066098435242724, 0.10992720434210046, 0.12329404616465311, 0.13665658230927002, 0.13308825011320846, 0.11906316999336908, 0.18600333865198404, 0.2673014954593603, 0.2556784400268317, 0.1639969500449312, 0.16418829342256847, 0.24061537736670835, 0.15552857239351547, 0.20594675517067074, 0.31461537770532055, 0.49199369420021233, 0.34834637766463405, 0.5467715808924283, 0.43074953391482973, 0.500392811902082, 0.40577304191016295, 0.24173248114034063, 0.20595781597406315, 0.5485168868695214, 0.19453192043951406, 0.2703873449117091, 0.4117133465805445, 0.24211103021888292, 0.39158270919502947, 0.4408556271588616, 0.214665216511152, 0.3326676085837589, 0.3686769563545761, 0.22406086113739287, 0.2162592903384254, 0.26643093577723, 0.22076107381384635, 0.2130608649876382, 0.21791115593653, 0.21324382202328362, 0.1841692469811571, 0.23955364122471723, 0.7758472744891161, 0.19081196702814418, 0.20592291284862474, 0.18665042546779664, 0.20165006658640328, 0.19146475586217948, 0.196949486636246, 0.18052241226414334, 0.199244686156535, 0.16398331650145992, 0.18666358427992769, 0.9130595737841963, 0.10337077808419859, 0.16896991770819714, 0.16737607409133837, 0.1865383984864062, 0.12487727769843693, 0.8394302306900628, 0.8918762231358082, 0.15613242217346068, 0.886246531723765, 0.20984586224128066, 0.8537568020847193, 0.1615534138203335, 0.10458026021234912, 0.16621803419387982, 0.8676933569508227, 0.1801010290889843, 0.1861849159422556, 0.1810781877376637, 0.17079458853552554, 0.18721586379369282, 0.1805003181901007, 0.16824230993890488, 0.1735854651922597, 0.18195722678289739, 0.10159357200343222, 0.0960010997993137, 0.09013961566952788, 0.08537947729245021, 0.09032768963826765, 0.11212037078744308, 0.08284381425380383, 0.08679771977119677, 0.07310908540901806]}, "mutation_prompt": null}
{"id": "5227d9cf-2ed5-4a8f-a0a1-c0ae89e68f51", "solution": "import numpy as np\n\nclass HybridMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Population size for effective exploration\n        self.F = 0.8  # Larger differential weight for improved exploration\n        self.CR = 0.85  # Slightly decreased crossover probability for balance\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'best'\n        self.adaptive_factor = 0.95  # Adaptive factor for fine-tuning adjustment\n        self.diversity_threshold = 0.15  # Enhanced explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.9)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand'\n            else:\n                self.mutation_strategy = 'best'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.2:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridMemeticEvoStrategy", "description": "Hybrid Memetic Evolutionary Strategy with Stochastic Adaptive Mechanisms for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {}, "mutation_prompt": null}
{"id": "8d315ae9-c008-4905-a735-11ab0956cc6e", "solution": "import numpy as np\n\nclass AdaptiveDiffEvoStagnationRecovery:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 5 * dim  # Adjusted population size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.85  # Crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Adaptive factor\n        self.diversity_threshold = 0.15  # Adjusted diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.7)  # Adjusted range\n                    self.CR = np.clip(self.CR, 0.4, 0.9)  # Adjusted range\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.2:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveDiffEvoStagnationRecovery", "description": "Adaptive Differential Evolution with Enhanced Diversity and Stagnation Recovery using Random Walks for robust optimization performance.", "configspace": "", "generation": 84, "fitness": 0.32454590771744773, "feedback": "The algorithm AdaptiveDiffEvoStagnationRecovery got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8791127473545781, 0.8577739606984249, 0.8768361776361872, 0.9049678785213947, 0.8782577385425046, 0.8984607314713136, 0.8798325697223359, 0.9009124923959684, 0.8903154336925799, 0.7589685109827817, 0.8032196276522785, 0.7934217237769365, 0.7734936089172316, 0.8224784537863251, 0.7657741804130154, 0.8248394966353356, 0.6249129168817107, 0.7845512177226606, 0.11528186137409957, 0.1571223294020372, 0.14494548349837422, 0.14092510496824506, 0.18159674764384326, 0.0766560676055591, 0.1801550644078046, 0.10957762960585571, 0.1158651081911003, 0.11097006343548055, 0.10946213828329343, 0.11193561625778892, 0.12133948000959283, 0.12926627018551584, 0.07947376355757041, 0.10081916075357056, 0.09248676794501298, 0.1039391529186463, 0.9658326227567525, 0.9550370550631223, 0.9718746137277322, 0.9558820592283811, 0.9366510564667333, 0.9674031031301344, 0.9511440490468398, 0.9680789177983289, 0.9588129266398925, 0.5736639976663593, 0.6707349850588862, 0.5544515337102762, 0.4953215459600838, 0.6959017189671663, 0.694599440317041, 0.7485549704081659, 0.4931853886473526, 0.5484357860532929, 0.3413639100615167, 0.8911526793704894, 0.16838871429294955, 0.4077181083360124, 0.277288713256176, 0.9097182568179236, 0.17790196176706363, 0.37563030835936184, 0.2347441091249456, 0.12768946437268536, 0.20610132862640707, 0.17708349810437707, 0.09938104697669004, 0.13072674631607728, 0.13254625958385946, 0.5918105946931961, 0.13121170718840913, 0.15040852177878983, 0.24612429971915328, 0.5210864541913544, 0.18293197930152572, 0.46709422059156847, 0.24666509694362526, 0.38693639636351906, 0.4905770293536832, 0.20790070167432873, 0.13380762175999594, 0.07117435113099113, 0.0909448733656838, 0.13162385044406621, 0.059037383140649546, 0.1650802352977525, 0.00779250483280125, 0.08019562339956943, 0.11077465541167453, 0.1001248204242503, 0.07868228960633805, 0.1328745499365347, 0.14448465929249554, 0.09688295023482973, 0.24761144603599128, 0.1754801852768122, 0.058668970334554094, 0.276600526657547, 0.17236384718210318, 0.25185256551200064, 0.12288477942552833, 0.053595075213198284, 0.21359929421543433, 0.28765605005472494, 0.11378562202236919, 0.15066663857574836, 0.11080069318838792, 0.08675876938212845, 0.2530074460617969, 0.31126353596247314, 0.30560967145217754, 0.2901201533642619, 0.09279879360165888, 0.3690412659097312, 0.23850281788250582, 0.43263718751489266, 0.34539019120525005, 0.6390944200180202, 0.611226710747032, 0.5728561826410862, 0.7113618832736153, 0.5604669412178975, 0.5895075122100506, 0.5819033950690683, 0.6162469251849847, 0.5051890373785659, 0.11069238572554219, 0.11436291031808399, 0.13920256459602365, 0.12249689814409992, 0.07493867736470805, 0.10764766323596686, 0.1529164666723356, 0.10992713704355261, 0.12090202315394694, 0.3543386534302173, 0.5321196047876766, 0.23263834911647818, 0.1744246657856886, 0.23736942636054414, 0.16046083549611923, 0.30980375764941814, 0.18197784495922398, 0.24468933239647217, 0.298155503507166, 0.2705027706344353, 0.47072057639979115, 0.3864329773966708, 0.33318601114010427, 0.4212386509908327, 0.36638100628420245, 0.19618576164578727, 0.3411869402685308, 0.22884674577616115, 0.3892825090958092, 0.2570222078341027, 0.11951986116495139, 0.15866311293845725, 0.28128462194652415, 0.3762004233229017, 0.241046430634841, 0.2145083242877759, 0.19166167808977275, 0.18719421673231684, 0.20753625777687323, 0.1925794296816643, 0.19471499349053634, 0.2072054349283512, 0.19181222913763452, 0.1880697701292955, 0.21701385553769947, 0.2229264056939585, 0.21387914749126558, 0.19159096088236527, 0.19966375771292266, 0.19120146806520089, 0.17112113947991348, 0.17904330945787728, 0.207308028433413, 0.17887587554725615, 0.12577161873597398, 0.18501926921527823, 0.11280824050259941, 0.15780916890370011, 0.16959742250453547, 0.17606440280990032, 0.16514235150863765, 0.18518469218120537, 0.161445373542768, 0.0829867697093647, 0.15565970127145634, 0.7303569306491303, 0.2059884434968401, 0.12082965815415314, 0.8873442001478931, 0.20763366247804338, 0.127187873584792, 0.16492805196285776, 0.1873660533572572, 0.17040400471359585, 0.1832545956983438, 0.1737963827708462, 0.16515476899340154, 0.17675267732642042, 0.1614866890650174, 0.1773041826427072, 0.19389958071048496, 0.09420956632586508, 0.08940241078488453, 0.10411854852478342, 0.07947760974560403, 0.0829176819938875, 0.08708452191620131, 0.07344472102400179, 0.09485939922448938, 0.0828291943099162]}, "mutation_prompt": null}
{"id": "3c6885ba-f60b-4160-99ec-3f17f769faa4", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.F = 0.6  # Moderate differential weight for balance\n        self.CR = 0.9  # Increased crossover probability for better exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.90  # Adaptive factor for consistent adjustment\n        self.diversity_threshold = 0.1  # Explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Adaptive Learning Rate utilizing explicit diversity maintenance to improve convergence.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8732766226181966, 0.8642243016655347, 0.8659935461581776, 0.8547781410271569, 0.8489843434467998, 0.8291276393042519, 0.8542008358345242, 0.8671068584652082, 0.8460371044231281, 0.754998745647667, 0.6685360222833198, 0.7094896514843003, 0.7032145651648585, 0.682277274361005, 0.6957365976649358, 0.7782177807854866, 0.7414169653758014, 0.7488975639652787, 0.1260365113730908, 0.11863917586582173, 0.12282585325225315, 0.1730225647967698, 0.17523928355619023, 0.13816749343700052, 0.13605050692107412, 0.12476910900380311, 0.13292032060456171, 0.13829873376169632, 0.11018068180767204, 0.1442854808839329, 0.11288557073308203, 0.1733192939832332, 0.09969463812954271, 0.11619831825062776, 0.12149586278962365, 0.10815664397811064, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6290162284567968, 0.5922781557132764, 0.588780814996684, 0.6670225256780604, 0.644425863156447, 0.6348853304366482, 0.51465906649409, 0.6482033543525607, 0.605582459343158, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5206291164262296, 0.12125465973297, 0.12861577462045204, 0.5617507875338423, 0.12736644596554436, 0.7265431498207405, 0.39518306870503206, 0.5366229774522695, 0.40288428683431365, 0.44784254744102214, 0.1288152535756879, 0.49586790605034203, 0.5368670185254014, 0.575537508950831, 0.5203924925143957, 0.5831511620691582, 0.1264497201800464, 0.5038099392266262, 0.49934707714237136, 0.5284834725514336, 9.999999999998899e-05, 0.6010321473736554, 0.382485077859132, 0.36935365984943236, 0.48364233848944393, 0.4198517361019898, 0.27367132718451503, 0.5963278370603864, 0.5224253748143389, 0.4653302118007083, 0.6831886960244166, 0.580173927849811, 0.4952337541702897, 0.5792440662318769, 0.08123422967530491, 0.7078451166151098, 0.0739010626179103, 0.1084619212107013, 0.3855359850948187, 0.3521518163304569, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.43403222200219826, 0.42711740183650415, 0.46483801601092856, 0.03805354803257921, 0.4661126798316374, 0.40871735786607777, 0.3718109253001566, 0.3371319365795915, 0.6948568389807652, 0.6245302587707393, 0.6884578786474407, 0.7321140615795139, 0.6024203182118643, 0.6730790023229437, 0.6518467238363761, 0.6501001592558935, 0.7801717998256352, 0.14314049685128938, 0.09503011201524791, 0.11130418714052726, 0.14066098435242724, 0.10992720434210046, 0.12329404616465311, 0.13665658230927002, 0.13308825011320846, 0.11906316999336908, 0.18600333865198404, 0.2673014954593603, 0.2556784400268317, 0.1639969500449312, 0.16418829342256847, 0.24061537736670835, 0.15552857239351547, 0.20594675517067074, 0.31461537770532055, 0.49199369420021233, 0.34834637766463405, 0.5467715808924283, 0.43074953391482973, 0.500392811902082, 0.40577304191016295, 0.24173248114034063, 0.20595781597406315, 0.5485168868695214, 0.19453192043951406, 0.2703873449117091, 0.4117133465805445, 0.24211103021888292, 0.39158270919502947, 0.4408556271588616, 0.214665216511152, 0.3326676085837589, 0.3686769563545761, 0.22406086113739287, 0.2162592903384254, 0.26643093577723, 0.22076107381384635, 0.2130608649876382, 0.21791115593653, 0.21324382202328362, 0.1841692469811571, 0.23955364122471723, 0.7758472744891161, 0.19081196702814418, 0.20592291284862474, 0.18665042546779664, 0.20165006658640328, 0.19146475586217948, 0.196949486636246, 0.18052241226414334, 0.199244686156535, 0.16398331650145992, 0.18666358427992769, 0.9130595737841963, 0.10337077808419859, 0.16896991770819714, 0.16737607409133837, 0.1865383984864062, 0.12487727769843693, 0.8394302306900628, 0.8918762231358082, 0.15613242217346068, 0.886246531723765, 0.20984586224128066, 0.8537568020847193, 0.1615534138203335, 0.10458026021234912, 0.16621803419387982, 0.8676933569508227, 0.1801010290889843, 0.1861849159422556, 0.1810781877376637, 0.17079458853552554, 0.18721586379369282, 0.1805003181901007, 0.16824230993890488, 0.1735854651922597, 0.18195722678289739, 0.10159357200343222, 0.0960010997993137, 0.09013961566952788, 0.08537947729245021, 0.09032768963826765, 0.11212037078744308, 0.08284381425380383, 0.08679771977119677, 0.07310908540901806]}, "mutation_prompt": null}
{"id": "30771367-729a-46d4-8926-ca8eeb729c15", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = 8 * dim  # Increased initial population size for diversity\n        self.population_size = self.initial_population_size\n        self.F = 0.7  # Modified differential weight for exploration\n        self.CR = 0.85  # Slightly decreased crossover probability for balance\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Adjusted adaptive factor\n        self.diversity_threshold = 0.05  # Lowered diversity threshold\n        self.adaptive_population_size = True\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n                    if self.adaptive_population_size:\n                        self.population_size = max(4, int(self.population_size * self.adaptive_factor))\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "Hybrid Adaptive Differential Evolution with Random Walk and Adaptive Population Size for Efficient Global Optimization.", "configspace": "", "generation": 86, "fitness": 0.33073301324672144, "feedback": "The algorithm HybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.7456433195015828, 0.7394463072597451, 0.7349942101936244, 0.7380951009936487, 0.7312310223988907, 0.7388732701464217, 0.79171385124054, 0.7434454720457855, 0.7393890474719323, 0.5265965363893879, 0.4935333122672011, 0.5689000693498425, 0.06242161566703941, 0.5377158261224351, 0.5132101989979625, 0.581074830036403, 0.5654784443216687, 0.5781313535036234, 0.1340978921070196, 0.4952807839714499, 0.11439614822578514, 0.12424696079872433, 0.1428920024153395, 0.12091142265064903, 0.15806711723296973, 0.15987350061294914, 0.1341429147237979, 0.09494223203432961, 0.12667367196235335, 0.1305720791700805, 0.11692233567778876, 0.10134862463977878, 0.12934591297645437, 0.13764087742494813, 0.10309450054801383, 0.11093610722640401, 0.9465102524096796, 0.974509608671675, 0.9695910372812586, 0.9388212042673773, 0.9640215881142207, 0.9736769075890246, 0.9685247480218943, 0.9707291201660023, 0.948368029375216, 0.434144807283646, 0.43511151258163827, 0.3796748861746555, 0.3583722312980634, 0.4077050720389581, 0.36515985279853636, 0.44123116213171565, 0.3675362397999773, 0.4185677790497446, 0.7832101285571493, 0.7027523920522096, 0.6733878502513684, 0.6784743951753718, 0.20143901680685028, 0.7163209530093892, 0.6612919468189641, 0.7216822976525862, 0.7680170366314816, 0.5154858399084439, 0.35721255872325974, 0.33292143272593344, 0.3860682129352031, 0.11816832834299529, 0.36348414107218086, 0.2686635882752444, 0.3887544037750893, 0.26191993597324503, 0.204186853065617, 0.33909879536933063, 0.4614154381978537, 0.4245470223619474, 0.1145375559272841, 0.23252411198820577, 0.31635086627446884, 0.28324443994932136, 0.26114021642563445, 0.17621231969025153, 0.24499638679929814, 0.29326762600855294, 0.1407103789737555, 0.2345002956123622, 0.012332998427941666, 0.3102089008659402, 0.23141663114624023, 0.09432094379778466, 0.43629702784852464, 0.40420994506521957, 0.42355804798533736, 0.10556524745150053, 0.37768578444158885, 0.4243409768641314, 0.525790871981507, 0.4114451085444244, 0.4560413556349374, 0.19457170095423815, 0.09355292695272799, 0.08733787778125113, 0.21636358490264107, 9.999999999998899e-05, 0.10856775344319447, 0.17601792690833862, 0.07726295813101969, 0.14503522818045478, 0.24275791886529774, 0.23318951697551704, 0.2680387822215814, 0.24815938389988523, 0.23191597334769876, 0.3228567418473365, 0.23962086827524787, 0.2596127554674511, 0.26072722988355335, 0.5300204064910164, 0.5586866400078215, 0.568168506943391, 0.590546064545215, 0.5729412556978243, 0.5661548306678996, 0.5677118526933179, 0.5393327765319789, 0.5674054571984408, 0.09044819449821895, 0.08778268101358777, 0.10752590664765105, 0.11503768839173101, 0.07841747790884424, 0.0822738878230872, 0.0992598502195553, 0.08736897192330306, 0.08935480191525347, 0.1577824432463496, 0.15661674159138872, 0.12786069350928086, 0.16349140288417496, 0.1571904755638852, 0.19540620021588073, 0.13348676260279846, 0.21326608809570735, 0.15719288206402815, 0.3704754608505626, 0.46170037559556054, 0.3429822249306619, 0.35892281048297714, 0.3815567262283309, 0.3658392046240916, 0.3670841457038134, 0.40731195340238335, 0.3967213152657445, 0.23969690400728727, 0.2664065368229268, 0.28400288797824036, 0.2059119965660623, 0.2397009739322281, 0.18377022324682923, 0.3189554798885771, 0.30390006319479745, 0.2891627376309742, 0.18708713411854683, 0.1927377798454144, 0.1971095731507233, 0.18436568643760942, 0.1733878908487635, 0.18013824465847483, 0.20040486545595804, 0.20333514751146242, 0.1979796520528655, 0.1956767674555021, 0.2068307345829029, 0.5737875119077311, 0.2075500942054963, 0.2222966767325395, 0.22111967203851013, 0.5435098414058475, 0.1919400682408502, 0.17877813012783894, 0.16806410465591604, 0.15506214854814848, 0.8135485445733455, 0.14505814881641688, 0.18419280347618805, 0.7286507942156181, 0.18756874201567642, 0.16835715429529208, 0.7387188305352004, 0.7927406303259892, 0.1654626630738345, 0.1991869167655833, 0.160051158097398, 0.1112506853824814, 0.19231489885163344, 0.15912308691826116, 0.20892356287315783, 0.09218125141292821, 0.17450673553431717, 0.19148911669996493, 0.1725123790203088, 0.18066866154867856, 0.20261203365739788, 0.1722054614156504, 0.19730588411572603, 0.17689739373070223, 0.18673751318836485, 0.07852184368645432, 0.07807181722553347, 0.08298852597164186, 0.07701254041097472, 0.06558739729439855, 0.10351843988667786, 0.09097821037198339, 0.07287333541802532, 0.0880943704780287]}, "mutation_prompt": null}
{"id": "d7b71e05-89f9-4fa0-b9ab-6180ef4024a8", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Increased initial population for diversity\n        self.F = 0.5  # Lower differential weight for more stable exploration\n        self.CR = 0.85  # Slightly decreased crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand-to-best'\n        self.adaptive_factor = 0.92  # Fine-tuned adaptive factor\n        self.diversity_threshold = 0.15  # Increased diversity threshold for broader search\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'rand-to-best':\n            return self.population[a] + self.F * (self.best_solution - self.population[a] + self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def dynamic_population_resize(self):\n        self.population_size = max(4 * self.dim, self.population_size - 2)\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'rand-to-best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n            if stagnation_counter > self.population_size * 0.5:\n                self.dynamic_population_resize()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "Hybrid Adaptive Evolutionary Strategy with Dynamic Population Resizing for Enhanced Convergence and Diversity.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {}, "mutation_prompt": null}
{"id": "c3f13c42-1363-4182-965a-fc76bd185e65", "solution": "import numpy as np\n\nclass AdaptiveEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Increased population size for diversity\n        self.F = 0.7  # Adjusted differential weight for exploration\n        self.CR = 0.85  # Slightly reduced crossover probability for exploitation\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.95  # Slightly increased adaptive factor\n        self.diversity_threshold = 0.15  # Increased diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            fitness = self.evaluate_population(func)\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveEvolutionaryStrategy", "description": "Adaptive Evolutionary Strategy employing stochastic perturbation and elitism to maintain diversity and prevent premature convergence.", "configspace": "", "generation": 88, "fitness": 0.3302027016954946, "feedback": "The algorithm AdaptiveEvolutionaryStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.7574061064691866, 0.7324595227993496, 0.7306282445259928, 0.7326980222706272, 0.7285067831302491, 0.7388467358023509, 0.7889933724812503, 0.7410864154963566, 0.7339197278654688, 0.5225350892481212, 0.4888550117337155, 0.5615268678579628, 0.062322673219173286, 0.5371214698324107, 0.5195110440215469, 0.5755111474309286, 0.5623075813839232, 0.5382422181265208, 0.30871017599040673, 0.14473479893910257, 0.12879992361692094, 0.12393803134277004, 0.14904579761498493, 0.1468034440584708, 0.11705857893518345, 0.15427842163824768, 0.3081538244197626, 0.13034584049022613, 0.09791513519656014, 0.4298405072475123, 0.12035446051315268, 0.09934000474831284, 0.14009171975732027, 0.12067007142278785, 0.08901284857073899, 0.1098232644319056, 0.945382867963531, 0.9726766613733391, 0.9666994832921934, 0.9375866672187566, 0.963478187149168, 0.9718859468406014, 0.9669588618847884, 0.9673162409220213, 0.9460275585270663, 0.42026605059696953, 0.4012367665895519, 0.3927357533081681, 0.3568594133990084, 0.3580075173528585, 0.36352433748230195, 0.3951255747069632, 0.08664709232396439, 0.41167933991610284, 0.16906946286562197, 0.6953991278699527, 0.3531031453477136, 0.7964275731731812, 0.2010447895473323, 0.7142602275565245, 0.659177422399505, 0.6161611471486305, 0.7660559493854175, 0.5187750236339577, 0.39405118053646815, 0.32783832548050884, 0.39981935864918816, 0.33328422734208263, 0.37022842620931884, 0.2995839820066222, 0.3925231518357767, 0.26047688545931513, 0.4028648062179482, 0.31740112561858314, 0.46899940142602004, 0.330493839582627, 0.11432074679727089, 0.3929697310524912, 0.3159510492946017, 0.2814289806512287, 0.2598078178906136, 0.1752501432046243, 0.24398642634001177, 0.2914518306967856, 0.10607051454469252, 0.3200894016205058, 0.22925146694197363, 0.11905699234097977, 0.23012418574529658, 0.13345481488666633, 0.42366036912049043, 0.4321829980936748, 0.410680144510847, 0.4175703654264342, 0.37819255475757907, 0.4218251639608932, 0.5292270473974421, 0.3846489875779844, 0.445506567829862, 0.19351768844139494, 0.09305941316590527, 0.08690731799918483, 0.16445391661822972, 9.999999999998899e-05, 0.1305064919737552, 0.17507000730363176, 0.07696424003658453, 0.14429461340440997, 0.26647832442384156, 0.23218593532497567, 0.24698062979366342, 0.24687352363967308, 0.2783743567922944, 0.3038077893784614, 0.2387220648417332, 0.21382837099765528, 0.24995745355135335, 0.5887263259619142, 0.5998843651449743, 0.6149987918558493, 0.6274090426686205, 0.572936613795687, 0.5904044709813576, 0.5867611333753385, 0.5652332749827105, 0.5636000480375348, 0.11570788408472832, 0.12329602508429327, 0.13752593334811247, 0.15882809839989753, 0.10090238914108429, 0.09967336430692153, 0.1169228048497325, 0.09430130829926953, 0.11358770404764507, 0.17559569803770303, 0.29064618118115415, 0.16103063008401874, 0.19523510262772126, 0.20242204181690204, 0.1953508671208385, 0.12555503094254894, 0.15305230286129068, 0.17055064081829896, 0.36064784749275447, 0.39193636753535077, 0.35596577925479134, 0.34791833748995615, 0.37530164889287476, 0.3664905584995416, 0.3959757290115773, 0.43591855225888254, 0.38952544254022226, 0.3213056565415483, 0.2655966329719245, 0.283259989030456, 0.20377998552066579, 0.23941525195855962, 0.3008027371707914, 0.31550559399738254, 0.3088035749046488, 0.2881393794409177, 0.17882263680566635, 0.18256474700849756, 0.21005978214265153, 0.20987392103241032, 0.18693476348176374, 0.18507078635582963, 0.19263512870479804, 0.20084385529507742, 0.19830697061046998, 0.18825779292218736, 0.20635351468797025, 0.1887860569621227, 0.20915070190489615, 0.22296828585904038, 0.2016720619842216, 0.47359600336506336, 0.20057204120539074, 0.21332176724213103, 0.1678149430472604, 0.18430414012883667, 0.1524540875183118, 0.15106188829824418, 0.19422442677607066, 0.7244080125799759, 0.1811573412047799, 0.1680901052594589, 0.6895723961621002, 0.7330360228867271, 0.6942848371662234, 0.19875520590198426, 0.15973758588403997, 0.11116336375816682, 0.19207673887228816, 0.15888442303002248, 0.20855365162236872, 0.09206619891178502, 0.17441703937731012, 0.19138095570039904, 0.18212883580265593, 0.1805636868868853, 0.21883195843036696, 0.17713047726018372, 0.1710146781580295, 0.18290963620375156, 0.16703837638489694, 0.07754293301581816, 0.07766016364005679, 0.07433839873817882, 0.07527880360874373, 0.07373085827565029, 0.0805904905948841, 0.08806961141574099, 0.07523019138913511, 0.07674492525746501]}, "mutation_prompt": null}
{"id": "3531b348-cd97-4b53-be62-0116d5912d1e", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim\n        self.F = 0.6\n        self.CR = 0.9\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.9\n        self.diversity_threshold = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Dynamic Adaptive Learning Rates and Stagnation Mitigation through Diversity Reintroduction.", "configspace": "", "generation": 89, "fitness": 0.3930771124910674, "feedback": "The algorithm EnhancedMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8732766226181966, 0.8642243016655347, 0.8659935461581776, 0.8547781410271569, 0.8489843434467998, 0.8291276393042519, 0.8542008358345242, 0.8671068584652082, 0.8460371044231281, 0.754998745647667, 0.6685360222833198, 0.7094896514843003, 0.7032145651648585, 0.682277274361005, 0.6957365976649358, 0.7782177807854866, 0.7414169653758014, 0.7488975639652787, 0.1260365113730908, 0.11863917586582173, 0.12282585325225315, 0.1730225647967698, 0.17523928355619023, 0.13816749343700052, 0.13605050692107412, 0.12476910900380311, 0.13292032060456171, 0.13829873376169632, 0.11018068180767204, 0.1442854808839329, 0.11288557073308203, 0.1733192939832332, 0.09969463812954271, 0.11619831825062776, 0.12149586278962365, 0.10815664397811064, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6290162284567968, 0.5922781557132764, 0.588780814996684, 0.6670225256780604, 0.644425863156447, 0.6348853304366482, 0.51465906649409, 0.6482033543525607, 0.605582459343158, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5206291164262296, 0.12125465973297, 0.12861577462045204, 0.5617507875338423, 0.12736644596554436, 0.7265431498207405, 0.39518306870503206, 0.5366229774522695, 0.40288428683431365, 0.44784254744102214, 0.1288152535756879, 0.49586790605034203, 0.5368670185254014, 0.575537508950831, 0.5203924925143957, 0.5831511620691582, 0.1264497201800464, 0.5038099392266262, 0.49934707714237136, 0.5284834725514336, 9.999999999998899e-05, 0.6010321473736554, 0.382485077859132, 0.36935365984943236, 0.48364233848944393, 0.4198517361019898, 0.27367132718451503, 0.5963278370603864, 0.5224253748143389, 0.4653302118007083, 0.6831886960244166, 0.580173927849811, 0.4952337541702897, 0.5792440662318769, 0.08123422967530491, 0.7078451166151098, 0.0739010626179103, 0.1084619212107013, 0.3855359850948187, 0.3521518163304569, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.43403222200219826, 0.42711740183650415, 0.46483801601092856, 0.03805354803257921, 0.4661126798316374, 0.40871735786607777, 0.3718109253001566, 0.3371319365795915, 0.6948568389807652, 0.6245302587707393, 0.6884578786474407, 0.7321140615795139, 0.6024203182118643, 0.6730790023229437, 0.6518467238363761, 0.6501001592558935, 0.7801717998256352, 0.14314049685128938, 0.09503011201524791, 0.11130418714052726, 0.14066098435242724, 0.10992720434210046, 0.12329404616465311, 0.13665658230927002, 0.13308825011320846, 0.11906316999336908, 0.18600333865198404, 0.2673014954593603, 0.2556784400268317, 0.1639969500449312, 0.16418829342256847, 0.24061537736670835, 0.15552857239351547, 0.20594675517067074, 0.31461537770532055, 0.49199369420021233, 0.34834637766463405, 0.5467715808924283, 0.43074953391482973, 0.500392811902082, 0.40577304191016295, 0.24173248114034063, 0.20595781597406315, 0.5485168868695214, 0.19453192043951406, 0.2703873449117091, 0.4117133465805445, 0.24211103021888292, 0.39158270919502947, 0.4408556271588616, 0.214665216511152, 0.3326676085837589, 0.3686769563545761, 0.22406086113739287, 0.2162592903384254, 0.26643093577723, 0.22076107381384635, 0.2130608649876382, 0.21791115593653, 0.21324382202328362, 0.1841692469811571, 0.23955364122471723, 0.7758472744891161, 0.19081196702814418, 0.20592291284862474, 0.18665042546779664, 0.20165006658640328, 0.19146475586217948, 0.196949486636246, 0.18052241226414334, 0.199244686156535, 0.16398331650145992, 0.18666358427992769, 0.9130595737841963, 0.10337077808419859, 0.16896991770819714, 0.16737607409133837, 0.1865383984864062, 0.12487727769843693, 0.8394302306900628, 0.8918762231358082, 0.15613242217346068, 0.886246531723765, 0.20984586224128066, 0.8537568020847193, 0.1615534138203335, 0.10458026021234912, 0.16621803419387982, 0.8676933569508227, 0.1801010290889843, 0.1861849159422556, 0.1810781877376637, 0.17079458853552554, 0.18721586379369282, 0.1805003181901007, 0.16824230993890488, 0.1735854651922597, 0.18195722678289739, 0.10159357200343222, 0.0960010997993137, 0.09013961566952788, 0.08537947729245021, 0.09032768963826765, 0.11212037078744308, 0.08284381425380383, 0.08679771977119677, 0.07310908540901806]}, "mutation_prompt": null}
{"id": "3b93e704-d48b-4d52-8d50-6e7a12afd589", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 4 * dim  \n        self.F = 0.5  \n        self.CR = 0.8\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  \n        self.diversity_threshold = 0.2  \n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.6, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "Hybrid Self-Adaptive Memetic Evolutionary Strategy with Dynamic Convergence Acceleration leveraging population diversity and mutation strategy adaptation.", "configspace": "", "generation": 90, "fitness": 0.32992182580927565, "feedback": "The algorithm HybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.9203789159611818, 0.894609709593781, 0.9157000511626492, 0.8979646091048391, 0.8987092945956423, 0.9204824668896817, 0.9023692654456709, 0.9154106495216773, 0.9151090844780283, 0.7983062033401215, 0.7118809472080956, 0.8421140316170106, 0.8168802727251191, 0.6664248701918993, 0.8479605123634973, 0.8443065938992673, 0.7094368701167935, 0.8457237665985046, 0.10884915357066471, 0.14378546568635941, 0.07931359442097963, 0.13160465403721877, 0.15274582009674464, 0.14540285801939423, 0.1450523705134259, 0.11623990983091204, 0.09858006567590205, 0.06244644250152942, 0.08373604755061659, 0.1167902888120178, 0.08158730967632677, 0.10404180602191138, 0.09570061253275852, 0.09082816340216426, 0.1086567900562212, 0.10985477985110703, 0.9476099993037468, 0.9414407917836635, 0.9820075127636151, 0.9703531290361453, 0.9308751807873, 0.9761412460562928, 0.9621934448109546, 0.9558755342806097, 0.9283492842824856, 0.6357662290025166, 0.31967110632074014, 0.7514145516471791, 0.6225769580838545, 0.6076693392488742, 0.4546572674590338, 0.6263984413217987, 0.33011098611743706, 0.6852200980307771, 0.21110818754960314, 0.3810545160530322, 0.3620156352099785, 0.9136845108351882, 0.2804517653900819, 0.9175378523116812, 0.9120009393225892, 0.14931101292122073, 0.17277325445486913, 0.13234757794970664, 0.1636189483705266, 0.13238020594374234, 0.13167126001711638, 0.13539317522730066, 0.12214469850542664, 0.7017814051139097, 0.12056448286289578, 0.576331908098451, 0.3261534071355717, 0.19275117134561237, 0.6305840876275071, 0.14946270746154078, 0.2369767085666603, 0.24750451204967583, 0.13161718572494718, 0.16497412472308137, 0.19708741505609184, 0.05556291481328257, 0.24046940295014907, 9.999999999998899e-05, 0.006103924093276314, 0.1705644058976331, 0.04971678967108839, 0.08940959245647917, 0.02926328186174809, 0.09437424250539028, 0.12105364202114177, 0.11016618268474176, 0.2783429594188336, 0.07814878557222671, 0.14938436195910176, 0.04121097006895613, 0.12697009235727275, 0.05873162756299877, 0.28154212365744835, 0.13832425933502857, 0.17867506176372228, 0.09336321144411763, 0.10100259590442007, 0.25319078315392385, 0.1650152708524818, 0.1312382018811148, 0.10631635845915044, 0.11823331614548582, 0.2512818990442147, 0.3400947502615175, 0.10753197860341357, 0.3330803821461584, 0.38659251234479086, 0.19764842024319706, 0.20718385783992088, 0.049936155720369246, 0.2705931557472616, 0.6669680584457642, 0.6796570252146603, 0.7470401755155671, 0.6334897852745427, 0.5906597372678416, 0.5684069500814894, 0.5548394827673562, 0.6704095019248875, 0.5037757657911823, 0.0862016618358884, 0.09162781964331501, 0.11046179522171429, 0.09915164870374937, 0.07055287858055326, 0.14847595367494126, 0.09271160914228427, 0.12877810875272067, 0.09267829737876432, 0.21464646809774313, 0.2814642980426696, 0.26540508581656297, 0.166226952462727, 0.40096633760976463, 0.27601616792784167, 0.29917548759329304, 0.23415521105975512, 0.206958713946924, 0.3303318560079631, 0.38264189840097873, 0.20357649255338095, 0.4005779398185557, 0.2882966128284269, 0.39986432203545197, 0.288779888105945, 0.450921439918586, 0.38738021326790273, 0.4061056886899296, 0.394988463263519, 0.3966197162326186, 0.300203468201625, 0.24064320448576215, 0.29176239279075655, 0.22452722095138256, 0.19921901368190942, 0.1909864423070371, 0.20514419098180292, 0.19274290527258242, 0.19832280582620998, 0.17869128164869819, 0.1781449081482115, 0.20926428272744135, 0.19088850342487462, 0.18837084859135367, 0.1895635858285959, 0.18218711293035406, 0.17423597706244032, 0.1871543776375475, 0.20973701761136498, 0.2536365987777415, 0.1901410460129762, 0.20891948289362228, 0.19411699177155706, 0.19304548651841702, 0.18636449127343324, 0.19910573146890242, 0.18627253342833205, 0.12267556176957894, 0.9181030345503959, 0.17679193012522543, 0.16828161204936476, 0.11425905213563547, 0.1691949127354757, 0.8168142224589912, 0.21234324222307832, 0.1546923358295007, 0.16645255006330295, 0.11137606035206915, 0.1648138229083721, 0.19168784676372774, 0.7102111835959293, 0.8083747860871845, 0.17443699568806115, 0.19322172927165715, 0.1836073315391369, 0.18514033622540027, 0.17345200547252804, 0.1869583747535375, 0.19185525095668576, 0.20037008715099935, 0.17521894723071785, 0.09963570819182732, 0.10452616846386587, 0.0912397899441888, 0.09126464396432477, 0.07584254674371971, 0.06446339673114632, 0.06862722906938667, 0.08137300837203476, 0.09041578655697047]}, "mutation_prompt": null}
{"id": "b2076c63-d6df-4048-b037-7d5d83fe3e33", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Increased population size for better diversity\n        self.F = 0.5  # Lower differential weight for stability\n        self.CR = 0.85  # High crossover probability for exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.93  # Slightly adjusted adaptive factor\n        self.diversity_threshold = 0.2  # Increased diversity threshold\n        self.local_search_prob = 0.1  # Probability of applying local search\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def local_search(self, individual, func):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(individual + perturbation, self.bounds[0], self.bounds[1])\n        candidate_fitness = func(candidate)\n        return candidate, candidate_fitness\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n                if np.random.rand() < self.local_search_prob:\n                    candidate, candidate_fitness = self.local_search(trial, func)\n                    func_calls += 1\n                    if candidate_fitness < trial_fitness:\n                        self.population[i] = candidate\n                        if candidate_fitness < self.best_fitness:\n                            self.best_fitness = candidate_fitness\n                            self.best_solution = candidate.copy()\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.2, self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Stochastic Local Search and Diversity Preservation for Enhanced Global Exploration.", "configspace": "", "generation": 91, "fitness": 0.3670102689363472, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8396506269115422, 0.8261935430576131, 0.864086677004172, 0.8378457026986553, 0.8263594018728111, 0.8340391684126022, 0.8476687997246035, 0.8167566039401789, 0.8321882206558093, 0.6883662209697232, 0.6675568782600335, 0.6951591135815822, 0.6629184564981982, 0.6599713408598709, 0.70204109200814, 0.7326474852172491, 0.6756877699646604, 0.69656909353816, 0.1012307393456191, 0.13342137719517655, 0.14243363586403335, 0.11425342933369464, 0.11646624282589435, 0.13489711720750563, 0.1395177664843451, 0.10486794690191359, 0.14350028713153828, 0.11464892320934472, 0.0688147402268856, 0.14152093823563605, 0.10566931745116526, 0.12391389411811593, 0.1035167761588115, 0.1302770820302298, 0.12715000603680748, 0.12662943575540064, 0.967525447543962, 0.9251321546884623, 0.9766372635315519, 0.9576112594611834, 0.9526485817949987, 0.9426934834178818, 0.9554647816317767, 0.9644937545228917, 0.892182061506468, 0.6031303428882455, 0.6135700029629936, 0.58762542506577, 0.6605736616288299, 0.5874012640053137, 0.5628482330247214, 0.6132188286797303, 0.5486022433920097, 0.6021456708857659, 0.20513113573724995, 0.8485062345377588, 0.31064501963766544, 0.3680743346849972, 0.3623998246119118, 0.8974218188033924, 0.17540901504300377, 0.2324956365011499, 0.22824737146711283, 0.4474659978049652, 0.12375489056202527, 0.33014822265586186, 0.26509388758028996, 0.47355930514001965, 0.2877547287960607, 0.12877576612110264, 0.6130407828592901, 0.43155010106859903, 0.4499159238787416, 0.23303448598365706, 0.128809807480181, 0.44034617416622523, 0.29469512427614675, 0.41256670439185905, 0.5653017573520304, 0.46007391003476916, 0.42343992144602505, 0.43664934084055895, 0.19215314658901583, 0.06740943368927987, 0.2918111517145119, 0.40719803491408557, 0.035070897052492, 0.21231212987638137, 0.4415365625798763, 0.40048102893239945, 0.2166595192921824, 0.39905922178782893, 0.22112805036067562, 0.5670782556144366, 0.5807947759178438, 0.4586159196768358, 0.26707832602690307, 0.6100527949873853, 0.5817097370535855, 0.09550551451700173, 0.1962663809746069, 0.08289375840112012, 0.17320760022416182, 0.11718223641892855, 0.29415947007496357, 0.1264520751538828, 0.10907172922111785, 0.0843662572823971, 0.2907212818913677, 0.3942129585985782, 0.31326829184918925, 0.3127943158653399, 0.3011144942031918, 0.4166454307278984, 0.22785516874036105, 0.3346812224928263, 0.22958748558200237, 0.6899576691338083, 0.6839001329736654, 0.659488899231852, 0.7314795357701402, 0.6271207530410561, 0.638628577602729, 0.668439257487358, 0.6257789174080965, 0.685809492742566, 0.1343443600478912, 0.5775859977505535, 0.07611156530505736, 0.07596541164191117, 0.11899682255053268, 0.10281187751257548, 0.09806876697579081, 0.1520065505304281, 0.12661021090514735, 0.17131420816479315, 0.12400828947751341, 0.29917910074304443, 0.1732429519394718, 0.168639928235644, 0.424162449221793, 0.5220965110160405, 0.1664593283332746, 0.16509108919662885, 0.3907180545083889, 0.4622092667926958, 0.3444469127284485, 0.30849535580327114, 0.5092135773413746, 0.5151231273704324, 0.5279695683036417, 0.5687665037977081, 0.3748014530054392, 0.3533400820873993, 0.2596817355723916, 0.426062604004688, 0.21393325415287012, 0.2933859778385922, 0.3390394806860145, 0.4740115423980549, 0.31298893474390155, 0.24727560771734314, 0.184926061342653, 0.19242489439871124, 0.17192303212297233, 0.18350208843365767, 0.18998386133149425, 0.18426425935926882, 0.22359075234795356, 0.19041800727848623, 0.18303284182452062, 0.2155295126058503, 0.20400711111278036, 0.21511677292168674, 0.20423015578814085, 0.190112717522828, 0.24301067201913884, 0.21313948480001932, 0.19284439110823093, 0.18609948965162715, 0.16337053195084916, 0.8841484800313507, 0.17568893311850609, 0.7997503423769575, 0.168000257167358, 0.13519595783827976, 0.1869274573983899, 0.8641701646190303, 0.20945527413287823, 0.8165926885898465, 0.12710853764188834, 0.1561471282648399, 0.11137735080719036, 0.12554454884571764, 0.16210881719636494, 0.12610489990486207, 0.7732165630978299, 0.16506508840454626, 0.19980814675687075, 0.18849150978665974, 0.1882355641485407, 0.18132190335203247, 0.1833023209631549, 0.17651359899129837, 0.18055554504693827, 0.19550072608890068, 0.18563356114684204, 0.06278042756700908, 0.09126006324573233, 0.08885460929197908, 0.10025390491111796, 0.07598040100724446, 0.09560091645653934, 0.13082355041518223, 0.1196600624571138, 0.08636826440154055]}, "mutation_prompt": null}
{"id": "e10a8a91-59c2-4119-a44d-7d232800db09", "solution": "import numpy as np\n\nclass HybridAdaptiveEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 5 * dim  # Slightly reduced population size for balance\n        self.F = 0.7  # Adjusted differential weight for exploration\n        self.CR = 0.8  # Lower crossover probability to allow more mutation impact\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.85  # Adaptive factor for gradual adjustment\n        self.diversity_threshold = 0.15  # Slightly increased diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.9)\n                    self.CR = np.clip(self.CR, 0.4, 0.9)\n\n            if stagnation_counter > self.population_size / 2:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.2:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.05 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "HybridAdaptiveEvoStrategy", "description": "Hybrid Adaptive Evolutionary Strategy blending differential evolution and random walks with dynamic strategy adjustment to enhance diversity and convergence efficiency.", "configspace": "", "generation": 92, "fitness": 0.36535625083031475, "feedback": "The algorithm HybridAdaptiveEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8496055558758602, 0.8451362883335676, 0.8591109758466628, 0.8390139000827491, 0.8349520490265406, 0.8580596247229753, 0.8684531980687904, 0.8465061984839753, 0.857462631066441, 0.7614413855108962, 0.6377585725166124, 0.745989971354049, 0.7314141398332966, 0.7514157602973535, 0.7450754419531674, 0.6497217209664388, 0.7315456303705011, 0.7219673383945069, 0.1466285770380984, 0.1352740965547935, 0.12373927572915688, 0.14567008371517254, 0.14501208339612204, 0.11946035295728397, 0.1479933756214974, 0.7395284196360477, 0.7202625630348402, 0.11576152234282999, 0.10675865864683054, 0.11012378259438771, 0.13505413581968428, 0.09534174934889639, 0.5835563396214702, 0.12435933834423374, 0.07760369527567268, 0.13354894419395136, 0.987316918582881, 0.9683085803662954, 0.9845501481163322, 0.9887357032519734, 0.9760738081100311, 0.9822505324363713, 0.9739731980525776, 0.9725390011806537, 0.9928554853024926, 0.5181408938358344, 0.058102893496494445, 0.5608859163404613, 0.5726415793486509, 0.6059629018201294, 0.5764675911400798, 0.5937516411542549, 0.5478666671581344, 0.5230560783245359, 0.2088794625827558, 0.3532981220941781, 0.22329726219554558, 0.21159887859133175, 0.7323226100378613, 0.202306483049973, 0.7897622718044094, 0.8291115157029488, 0.8241760789853525, 0.37851322310996405, 0.38137211075966304, 0.5976647984879, 0.10697938164345289, 0.6013110627425509, 0.5006981278299465, 0.6770319026308322, 0.7042756649055136, 0.5320292068348513, 0.5350337844404407, 0.4316211508902359, 0.12960978576309135, 0.1251296658123161, 0.5229418009567355, 0.37555468045385987, 0.4901587420852578, 0.5403821087019663, 0.442836640892046, 0.19857215503168968, 0.38964662354296475, 0.33094494369421723, 9.999999999998899e-05, 0.3088825232483805, 0.26934018926143977, 0.40667612963917144, 0.08069954297696946, 0.06280856306951643, 0.5137520339966857, 0.45082178414741914, 0.2936641129625115, 0.08603373421724558, 0.2370396575540733, 0.18023922874367404, 0.5608467359991514, 0.30031362897139824, 0.29182973149158165, 0.24304149536240316, 0.06934142316931124, 0.24334580610448253, 0.2156222540772602, 0.0750424926513108, 0.2935933077761058, 0.10907273153591301, 0.09923267093457122, 0.258184240153261, 0.2927170220114663, 0.19243151368504297, 0.3618964541836809, 0.3886610756631751, 0.2232170658127819, 0.3395642008852804, 0.31839256677364336, 0.2981505290353673, 0.2687926495778168, 0.6431045171739302, 0.637954479640017, 0.58274913798872, 0.6219907852724817, 0.6148098486260203, 0.574500839750133, 0.63883971796927, 0.6614629948010438, 0.6286608429469194, 0.06895521732238596, 0.08997275803186333, 0.12069273662541546, 0.12347475124056018, 0.08415243714235932, 0.1264319836666309, 0.10481651326094288, 0.11565454057198754, 0.1412715411134382, 0.22524321464487074, 0.18800383146691524, 0.17814333576040553, 0.1481321125839271, 0.19257441548519272, 0.12679203136544037, 0.15797118533239796, 0.18723830405910957, 0.23887564004965312, 0.459273656106306, 0.5694257574654495, 0.4992954922437003, 0.45421175976686634, 0.39529407786896587, 0.4609651901641245, 0.5487630126062619, 0.52789713649685, 0.4244272775156981, 0.17594614417578747, 0.30338750639294443, 0.1688375199180029, 0.3178933090145293, 0.29973404210901644, 0.2424802432183495, 0.41522825210019887, 0.353905220538412, 0.3895185497410196, 0.1959208203097721, 0.20479726497816275, 0.20025578729900273, 0.20533382648006338, 0.192355395142786, 0.19459162081621129, 0.18727542867611258, 0.21843053418537262, 0.18298015840969006, 0.21407583903624805, 0.7378148407197258, 0.2466657874554914, 0.2207799368634381, 0.18944554544077596, 0.20321618495503657, 0.22066970314339862, 0.19612258022712092, 0.20764299403374198, 0.1617711525302984, 0.13983455325373506, 0.8677908260122389, 0.1290613219967076, 0.1775021733967298, 0.18631398781362263, 0.16792318611297274, 0.18554195261704176, 0.18689858083681188, 0.08221790784246563, 0.1549583602282013, 0.7578535751868412, 0.11168305912991472, 0.16568122588007916, 0.16643239042972402, 0.12950155913639627, 0.10882464364178668, 0.11119588713787798, 0.17320165515201447, 0.17486406774605734, 0.17390629136081048, 0.17582194837335463, 0.1857808037144102, 0.1770398321004104, 0.18127552925825863, 0.1759071245295405, 0.17970408240239888, 0.0810179636285211, 0.08837970604616674, 0.08285300912186244, 0.0795877281257431, 0.0787885820602835, 0.09245697698356303, 0.08401448305728432, 0.07770272214665552, 0.09213896433105861]}, "mutation_prompt": null}
{"id": "95afb03b-cb31-4174-b4ca-3dae02745c7b", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Adjusted population size for exploration\n        self.F = 0.5  # Adjusted differential weight for exploration balance\n        self.CR = 0.85  # Slightly reduced crossover probability for diversity\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.92  # Slightly increased adaptive factor for fine-tuning\n        self.diversity_threshold = 0.15  # Increased explicit diversity threshold\n        self.subpop_size = max(1, int(0.1 * self.population_size))  # Subpopulation size for rotation\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            # Dynamic subpopulation rotation\n            if func_calls > self.budget * 0.5:\n                subpop_indices = np.random.choice(self.population_size, self.subpop_size, replace=False)\n                subpop = self.population[subpop_indices]\n                np.random.shuffle(subpop)\n                self.population[subpop_indices] = subpop\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Dynamic Subpopulation Rotation and Adaptive Mutation for improved exploration and convergence balance.", "configspace": "", "generation": 93, "fitness": 0.3913249177457524, "feedback": "The algorithm EnhancedMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8393889353905727, 0.8312822333301173, 0.8663173176188207, 0.8306954102097378, 0.8608636385937565, 0.8527047988760623, 0.8656139320224406, 0.8244041388091459, 0.8446093425552537, 0.5439431365857941, 0.7047682037175889, 0.7164887859151962, 0.6610293728273368, 0.6125068738626445, 0.7082383686568203, 0.7121183108545943, 0.6808515444479493, 0.7114520743489672, 0.0909005422714454, 0.1723356629202939, 0.1490394517797755, 0.1317356495606058, 0.15884311292096487, 0.13809045268667575, 0.13215829258146006, 0.5412200298799679, 0.6168346685863937, 0.6193357441371359, 0.10261317549836513, 0.1228558233250735, 0.10873165089795334, 0.08637221597926725, 0.13074494670601866, 0.12960856236121998, 0.10930680802138648, 0.10669604930002774, 0.9180550345745563, 0.9660534007490047, 0.9215161163263672, 0.9762367643317975, 0.9376493666616212, 0.9302151974569002, 0.9140017150107597, 0.9494961256965725, 0.8873731856806703, 0.5845852477020093, 0.6120889969256476, 0.5884451819520762, 0.6147166303302752, 0.5954505798277778, 0.6012064917832565, 0.5884563771033307, 0.5151234995848839, 0.627098853475853, 0.22380570543400313, 0.7951159263334162, 0.8570371982737033, 0.3726706880545766, 0.8685501297367415, 0.8571226989157072, 0.20480035206529879, 0.8450644156747308, 0.8456009894554755, 0.4642744573110045, 0.6016362281246903, 0.22979453970555108, 0.1276707003022609, 0.1286171746690845, 0.32923916748562165, 0.4763914046238573, 0.489818186637634, 0.5069387371667942, 0.23499393928293932, 0.3870020210764531, 0.33740129762411286, 0.3134401690512413, 0.2365562588634097, 0.3938990361134834, 0.6122646768933482, 0.45341522659906797, 0.5507793859833965, 0.306348260303939, 0.06668242174156203, 0.46255687268341894, 0.3119874007613881, 0.34013197156143027, 0.06364333586715043, 0.3917828593803878, 0.3697388538459241, 0.24831819785070064, 0.6422189845263113, 0.6489392429544271, 0.5791754472196291, 0.3723311379958295, 0.5551787852004539, 0.5623316963421284, 0.6052309754604619, 0.5403598984418054, 0.640513424496366, 0.07847932659676338, 0.11136034389231575, 0.07549466777226532, 0.17962062234309217, 0.4374139745617499, 0.4645209953415518, 0.27104014214487826, 0.19799520368103063, 0.1590020903381677, 0.3803112124793109, 0.4072272407177022, 0.3028748106884148, 0.4136691550131132, 0.3789510369057526, 0.4056550870565878, 0.38075821730921133, 0.3369289715171814, 0.3608052889521679, 0.7047439378291129, 0.6602430517729334, 0.7019662869599954, 0.6848334297029237, 0.6398157689647423, 0.668372917119737, 0.7357202405253782, 0.5885829866135109, 0.6923675560099352, 0.11296971580947957, 0.10211299887080627, 0.08043118778552583, 0.1239366459358805, 0.12465045730556612, 0.13726261842102083, 0.11798576574806063, 0.14339185667054122, 0.14132428973910005, 0.18302006031160134, 0.2546059458248796, 0.15276264753947144, 0.2592906543548116, 0.2761445676460461, 0.22481954432103068, 0.1672281075510258, 0.6029698143077828, 0.23334100126083357, 0.45243706047189547, 0.2535447820925647, 0.5078525623863701, 0.44568203347013535, 0.44308866884074627, 0.3762692912444552, 0.4573251686181351, 0.3941941252935268, 0.619413569980646, 0.28359550611153816, 0.20150681983811103, 0.2668982784315893, 0.4658271954245785, 0.26251424964382464, 0.2778120983657354, 0.24519452224438687, 0.20717120445164328, 0.20173353098867441, 0.19328058628390032, 0.18262882339325626, 0.19580426599438383, 0.2283011880466458, 0.2702850311456433, 0.21550122068014899, 0.19429090441543817, 0.20075837606726632, 0.19632747711188836, 0.19347875906936796, 0.18395840591154033, 0.18721282764995328, 0.20610021682358592, 0.19018086894500585, 0.2177511900387572, 0.2389524776228038, 0.23981884925193364, 0.20581990011682083, 0.18353373660399797, 0.1860418298972465, 0.1705551480365579, 0.8627510574510897, 0.16425114219130243, 0.15308875390544996, 0.15411125884727084, 0.1718748370824067, 0.1647937897130558, 0.11312517966464397, 0.20984723588563425, 0.15102246868325797, 0.8462658315608806, 0.208167117219888, 0.8020207058222876, 0.7756574203154495, 0.16280758238787985, 0.21058710937553893, 0.18127440977433584, 0.17209534274114668, 0.18398400770122114, 0.17999540361202104, 0.16920441110013595, 0.17473997558004228, 0.19212929316056415, 0.17639674687022167, 0.19580468650121963, 0.08556701117919807, 0.0949748679280823, 0.07829317980576977, 0.07978109363722652, 0.07398362566710925, 0.08558115543577294, 0.0929538112973709, 0.0766134382888094, 0.08895458817743418]}, "mutation_prompt": null}
{"id": "63a75e4a-dc75-4fe8-8704-bc55c7807edc", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.F = 0.6  # Moderate differential weight for balance\n        self.CR = 0.9  # Increased crossover probability for better exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.90  # Adaptive factor for consistent adjustment\n        self.diversity_threshold = 0.1  # Explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Dynamic Mutation and Stagnation-Driven Exploration to improve convergence and diversity.", "configspace": "", "generation": 94, "fitness": 0.3930771124910674, "feedback": "The algorithm EnhancedMemeticEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8732766226181966, 0.8642243016655347, 0.8659935461581776, 0.8547781410271569, 0.8489843434467998, 0.8291276393042519, 0.8542008358345242, 0.8671068584652082, 0.8460371044231281, 0.754998745647667, 0.6685360222833198, 0.7094896514843003, 0.7032145651648585, 0.682277274361005, 0.6957365976649358, 0.7782177807854866, 0.7414169653758014, 0.7488975639652787, 0.1260365113730908, 0.11863917586582173, 0.12282585325225315, 0.1730225647967698, 0.17523928355619023, 0.13816749343700052, 0.13605050692107412, 0.12476910900380311, 0.13292032060456171, 0.13829873376169632, 0.11018068180767204, 0.1442854808839329, 0.11288557073308203, 0.1733192939832332, 0.09969463812954271, 0.11619831825062776, 0.12149586278962365, 0.10815664397811064, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6290162284567968, 0.5922781557132764, 0.588780814996684, 0.6670225256780604, 0.644425863156447, 0.6348853304366482, 0.51465906649409, 0.6482033543525607, 0.605582459343158, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5206291164262296, 0.12125465973297, 0.12861577462045204, 0.5617507875338423, 0.12736644596554436, 0.7265431498207405, 0.39518306870503206, 0.5366229774522695, 0.40288428683431365, 0.44784254744102214, 0.1288152535756879, 0.49586790605034203, 0.5368670185254014, 0.575537508950831, 0.5203924925143957, 0.5831511620691582, 0.1264497201800464, 0.5038099392266262, 0.49934707714237136, 0.5284834725514336, 9.999999999998899e-05, 0.6010321473736554, 0.382485077859132, 0.36935365984943236, 0.48364233848944393, 0.4198517361019898, 0.27367132718451503, 0.5963278370603864, 0.5224253748143389, 0.4653302118007083, 0.6831886960244166, 0.580173927849811, 0.4952337541702897, 0.5792440662318769, 0.08123422967530491, 0.7078451166151098, 0.0739010626179103, 0.1084619212107013, 0.3855359850948187, 0.3521518163304569, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.43403222200219826, 0.42711740183650415, 0.46483801601092856, 0.03805354803257921, 0.4661126798316374, 0.40871735786607777, 0.3718109253001566, 0.3371319365795915, 0.6948568389807652, 0.6245302587707393, 0.6884578786474407, 0.7321140615795139, 0.6024203182118643, 0.6730790023229437, 0.6518467238363761, 0.6501001592558935, 0.7801717998256352, 0.14314049685128938, 0.09503011201524791, 0.11130418714052726, 0.14066098435242724, 0.10992720434210046, 0.12329404616465311, 0.13665658230927002, 0.13308825011320846, 0.11906316999336908, 0.18600333865198404, 0.2673014954593603, 0.2556784400268317, 0.1639969500449312, 0.16418829342256847, 0.24061537736670835, 0.15552857239351547, 0.20594675517067074, 0.31461537770532055, 0.49199369420021233, 0.34834637766463405, 0.5467715808924283, 0.43074953391482973, 0.500392811902082, 0.40577304191016295, 0.24173248114034063, 0.20595781597406315, 0.5485168868695214, 0.19453192043951406, 0.2703873449117091, 0.4117133465805445, 0.24211103021888292, 0.39158270919502947, 0.4408556271588616, 0.214665216511152, 0.3326676085837589, 0.3686769563545761, 0.22406086113739287, 0.2162592903384254, 0.26643093577723, 0.22076107381384635, 0.2130608649876382, 0.21791115593653, 0.21324382202328362, 0.1841692469811571, 0.23955364122471723, 0.7758472744891161, 0.19081196702814418, 0.20592291284862474, 0.18665042546779664, 0.20165006658640328, 0.19146475586217948, 0.196949486636246, 0.18052241226414334, 0.199244686156535, 0.16398331650145992, 0.18666358427992769, 0.9130595737841963, 0.10337077808419859, 0.16896991770819714, 0.16737607409133837, 0.1865383984864062, 0.12487727769843693, 0.8394302306900628, 0.8918762231358082, 0.15613242217346068, 0.886246531723765, 0.20984586224128066, 0.8537568020847193, 0.1615534138203335, 0.10458026021234912, 0.16621803419387982, 0.8676933569508227, 0.1801010290889843, 0.1861849159422556, 0.1810781877376637, 0.17079458853552554, 0.18721586379369282, 0.1805003181901007, 0.16824230993890488, 0.1735854651922597, 0.18195722678289739, 0.10159357200343222, 0.0960010997993137, 0.09013961566952788, 0.08537947729245021, 0.09032768963826765, 0.11212037078744308, 0.08284381425380383, 0.08679771977119677, 0.07310908540901806]}, "mutation_prompt": null}
{"id": "59bdbc61-620a-4a0d-8234-666441f73d17", "solution": "import numpy as np\n\nclass AdaptiveHybridEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 5 * dim  # Adjusted population size for balance\n        self.F = 0.5  # Initial differential weight\n        self.CR = 0.8  # Initial crossover probability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.85  # Adaptive factor for parameter tuning\n        self.diversity_threshold = 0.15  # Adjusted diversity threshold\n        self.dynamic_adjustment = True  # Dynamic adjustment flag\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    if self.dynamic_adjustment:\n                        self.F *= self.adaptive_factor\n                        self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.2, 0.9)\n                    self.CR = np.clip(self.CR, 0.4, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.dynamic_adjustment = not self.dynamic_adjustment\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.2 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveHybridEvoStrategy", "description": "Adaptive Hybrid Evolutionary Strategy with Dynamic Mutation and Crossover Rates for Enhanced Convergence Stability.", "configspace": "", "generation": 95, "fitness": 0.32323801343485986, "feedback": "The algorithm AdaptiveHybridEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8308829799999413, 0.827510961889446, 0.8192325720957172, 0.8147831016797511, 0.8330457054580271, 0.8286966318076053, 0.808619961440789, 0.804963653513494, 0.8104423980450179, 0.6902298467120553, 0.6808513676152517, 0.668556377601399, 0.661756663751075, 0.6779003110625037, 0.6396253686311788, 0.09793370607165486, 0.6683350019051579, 0.6831154176003533, 0.144389584939965, 0.1661936797111524, 0.1620935332050072, 0.20123830258669317, 0.4565683885251203, 0.5657346984434515, 0.5113343268005671, 0.25713814871214635, 0.17442651628640393, 0.13240076491245367, 0.14518636139187202, 0.10682819480702455, 0.26002882763217006, 0.20823786428814306, 0.1501304797533981, 0.13775300464303852, 0.16253961623227497, 0.10777613336093983, 0.8468822724369709, 0.8535162531209157, 0.9034594658440941, 0.8906303832303157, 0.8924464927427127, 0.9601806930986625, 0.9601255405187679, 0.9478819121354395, 0.9205033714055395, 0.36808416792966003, 0.42686767933501635, 0.4233512763026147, 0.3878030611272344, 0.30559783298261334, 0.34675411469352724, 0.3475582241055907, 0.43036200304996386, 0.4353797463637483, 0.739336262574809, 0.3373954925566953, 0.535622296581458, 0.7592381406817459, 0.7634470635931944, 0.7944267265395684, 0.787098047085047, 0.6950659332509633, 0.6464634513232765, 0.3950227545084112, 0.16628627468185664, 0.15169275154016926, 0.16398598748455628, 0.1647462702270015, 0.2470076562940985, 0.14241701952196073, 0.2136194246237505, 0.16656471094651437, 0.15574652589937654, 0.14074473934642884, 0.15914305358051573, 0.12687843387193043, 0.1515315579175851, 0.20365484133718637, 0.17987903642232472, 0.16324594827264827, 0.24191500667167964, 0.16182722804218452, 0.0799385051888366, 0.023688007042475534, 0.1817463553167098, 0.26212077581368487, 9.999999999998899e-05, 0.09179223246305734, 0.021841691026217136, 0.014658745045723287, 0.12069364462113741, 0.08888480592018388, 0.15622961160256, 0.1369933586970168, 0.21724936673453699, 0.134087012074523, 0.1907141521397666, 0.15576974349951522, 0.2720746529652086, 0.024545461432849858, 0.03686256764997087, 0.07285606010773393, 0.1721227379264264, 0.11965000697086903, 0.06908226127567885, 0.12155877016086325, 0.06407811202989122, 0.028503850521882645, 0.21396845762321315, 0.28140125832031593, 0.2321324104814385, 0.1842179031695388, 0.2590300906995995, 0.25087691694299263, 0.14547589493057933, 0.1487199398128891, 0.21035581743534115, 0.552782944135265, 0.568463251070176, 0.5047456007501404, 0.5630460103466031, 0.5079961372927471, 0.5005677800597164, 0.5448924189162521, 0.5441509641115299, 0.508963179054631, 0.12528779563460524, 0.11782883032019709, 0.094910529865733, 0.08726231708935361, 0.09755703338533805, 0.1085148378987908, 0.10976684827705863, 0.10921899005911584, 0.10766145998528032, 0.136965537616903, 0.14757169386438163, 0.1399428896980598, 0.14790015608619833, 0.12379489521546116, 0.1352759664107398, 0.13922634829562452, 0.20557074021229782, 0.1437853857164917, 0.4055472255319227, 0.335280295148904, 0.4060575339126814, 0.3889522084579843, 0.4132876476342153, 0.4233876338704745, 0.4694175817977594, 0.4880797259631623, 0.453855733092271, 0.2406745350014885, 0.22055402414625846, 0.25511496305749404, 0.19395718574591314, 0.28641276191554277, 0.26582348793642796, 0.30708475125305323, 0.26856199864026953, 0.2897129049555367, 0.1898162434175249, 0.18172648805887803, 0.18309599409803767, 0.18632226788906803, 0.19392993551571125, 0.1900170590255411, 0.18372786393938356, 0.1974236593647678, 0.20940941338221786, 0.19919129084586917, 0.2162406449039035, 0.23578901809075103, 0.20069104235539337, 0.6194507083202714, 0.4007336975352155, 0.22423798804823047, 0.227410263680893, 0.2093434363308564, 0.724798748103574, 0.1889027381738435, 0.3767971702012505, 0.7138622359184739, 0.5332338910355119, 0.8279098114501497, 0.31675998189212706, 0.431203794197605, 0.6319506973236162, 0.2667860337906983, 0.16094915265344512, 0.5139001407383121, 0.45379918646077044, 0.18480735429425799, 0.29039847290954124, 0.20929302653532755, 0.15335722153073006, 0.14367865064866725, 0.17128574339524383, 0.1890892092115074, 0.1735343779370816, 0.19029918454895256, 0.18023639926273205, 0.20517998197766252, 0.19176899136863446, 0.1938110938897466, 0.19235074101685767, 0.08202310089651543, 0.08358219692827185, 0.08160754663799996, 0.07234680664176174, 0.0752052257206608, 0.07067810606810021, 0.07624731508101867, 0.08060805486025202, 0.07131000784047081]}, "mutation_prompt": null}
{"id": "0e63b137-1755-48d0-b71d-6e97880d7808", "solution": "import numpy as np\n\nclass AdaptiveCoopEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 8 * dim  # Increased population size for diversity\n        self.F = 0.7  # Increased differential weight for exploration\n        self.CR = 0.85  # Slightly reduced crossover probability for stability\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.88  # Slightly adjusted adaptive factor for fine-tuning\n        self.diversity_threshold = 0.2  # Increased diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.4, 0.9)\n                    self.CR = np.clip(self.CR, 0.4, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.8 and stagnation_counter > self.population_size * 0.3:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.15 + 0.02 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "AdaptiveCoopEvoStrategy", "description": "Adaptive Cooperative Co-evolutionary Strategy with Dynamic Population and Stagnation-based Mutation for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 96, "fitness": 0.3270084504335981, "feedback": "The algorithm AdaptiveCoopEvoStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.7460002537234114, 0.7391340891927398, 0.7328506302338058, 0.7368924883018965, 0.7287236836504576, 0.7396251072038524, 0.786195166619528, 0.7416553190388457, 0.7341672083675226, 0.5236841803319396, 0.49149112255679706, 0.5668859936677364, 0.06242161565882565, 0.533899106178277, 0.5131713856420353, 0.5780214766975356, 0.565769558586113, 0.5784700451494266, 0.15715219488115195, 0.28194014963145897, 0.12316811835199681, 0.12424696221945486, 0.13083809649583023, 0.3883314447497077, 0.15742347585213778, 0.1279517602821325, 0.16913451020988668, 0.11905390646653236, 0.11349019116364012, 0.14307790916221386, 0.11884654378246817, 0.1212376981563904, 0.12570506513046475, 0.11656828681498466, 0.09694158402396935, 0.10213925725149653, 0.9465102524096796, 0.974509608671675, 0.9695910372812586, 0.9388212042673773, 0.9640215881142207, 0.9736769075890246, 0.9685247480218943, 0.9707291201660023, 0.948368029375216, 0.42244225360887777, 0.361929774271079, 0.3807189713840007, 0.3583722312980634, 0.3989011065091582, 0.36515985279853636, 0.40236119215616073, 0.3635344546136715, 0.4126698473089978, 0.7832101285571493, 0.6985308278059719, 0.6733878502513684, 0.6784743951753718, 0.20143901680685028, 0.7163209530093892, 0.6612919468189641, 0.7216822976525862, 0.7680170366314816, 0.4976357081050474, 0.3550428223019022, 0.32981174025947146, 0.3820397342599309, 0.11816833143290262, 0.3575211879194179, 0.2686635882752444, 0.3891326566450266, 0.26191993597324503, 0.204186853065617, 0.33375224065728704, 0.46899312787888614, 0.40477776933437837, 0.1145375559272841, 0.23252411198820577, 0.31447085293918664, 0.2834596777255217, 0.26114021642563445, 0.17621231969025153, 0.24499638679929814, 0.29326762600855294, 0.03764040174501937, 0.2345002956123622, 0.10633612831337869, 0.3062265037555095, 0.23141663114624023, 0.0866760181058247, 0.40714173694473244, 0.40044768595133473, 0.4123149985329587, 0.26881306518738846, 0.3721067682263549, 0.42408736849085793, 0.5148159795574709, 0.3926105290767916, 0.46109087069975185, 0.19457170095423815, 0.09355292695272799, 0.08733787778125113, 0.21636358490264107, 9.999999999998899e-05, 0.08984435945975988, 0.17601792690833862, 0.07726295813101969, 0.14503522818045478, 0.23204375961884893, 0.23318951697551704, 0.2680387822215814, 0.24815938389988523, 0.23191597334769876, 0.3228567418473365, 0.23962086827524787, 0.1520592344505256, 0.26072722988355335, 0.5228941076070242, 0.5497491909437651, 0.5700050714089435, 0.5936103524653831, 0.5477613034538522, 0.5634560154769463, 0.5486250020702128, 0.5223299853650087, 0.5565838698541128, 0.10664506097087922, 0.14132966767381439, 0.10108709287508577, 0.13995327505789534, 0.08526122665715863, 0.09680041689274099, 0.08410029486352, 0.13257723634622343, 0.12775384254325184, 0.1646091268051847, 0.1475830939102003, 0.14368877578590677, 0.16349140289067288, 0.14654576076473858, 0.1958343694517093, 0.162425378522438, 0.2112009303380994, 0.14102346095242213, 0.3536031549875349, 0.4189251188305212, 0.16416124045164415, 0.35900190840301127, 0.3797392811606882, 0.36815852615507816, 0.3670841457038134, 0.4072751912989092, 0.39883877506538223, 0.2598723019755693, 0.2664065368229268, 0.28400288797824036, 0.195497258574862, 0.23973649293632038, 0.25429421928693585, 0.31021985116091455, 0.30390006319479745, 0.2891627376309742, 0.17518216020470556, 0.18213997784352465, 0.169417044206575, 0.1873153420977386, 0.1676635814403109, 0.16932225697020298, 0.19125183060338513, 0.19533478416091088, 0.21058432650276926, 0.2079939220724376, 0.20683073287492815, 0.18456749735844646, 0.20730512504019416, 0.21982081842164902, 0.21915003721442372, 0.5167137056627116, 0.20065455515679842, 0.19114419011455963, 0.16806412834123163, 0.15626240534188673, 0.8134834018716202, 0.12826326540157296, 0.18419280314695274, 0.7296822927729526, 0.1875687476684389, 0.16835715554684738, 0.7392014911228724, 0.7948677883996529, 0.16546266338648674, 0.19918691750193562, 0.1600511578592334, 0.11125068416295747, 0.19231489970542148, 0.15912309054010043, 0.2089235632115578, 0.09218125139424771, 0.17482366671293825, 0.19586730481517167, 0.17954216098871023, 0.1808582251434977, 0.20261203365739788, 0.1722054614156504, 0.17385492796238144, 0.17936530926867378, 0.18284067596411369, 0.07860517374060105, 0.07387428920804884, 0.06905598912730804, 0.07496545160320711, 0.07010182079589888, 0.07457191107345151, 0.07758338279936483, 0.07418530518918975, 0.09459790857444828]}, "mutation_prompt": null}
{"id": "e710079e-a7cb-494d-9e9c-4b723c68393e", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.F = 0.6  # Moderate differential weight for balance\n        self.CR = 0.9  # Increased crossover probability for better exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.90  # Adaptive factor for consistent adjustment\n        self.diversity_threshold = 0.1  # Explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Adaptive Learning Rate utilizing explicit diversity maintenance to improve convergence.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8732766226181966, 0.8642243016655347, 0.8659935461581776, 0.8547781410271569, 0.8489843434467998, 0.8291276393042519, 0.8542008358345242, 0.8671068584652082, 0.8460371044231281, 0.754998745647667, 0.6685360222833198, 0.7094896514843003, 0.7032145651648585, 0.682277274361005, 0.6957365976649358, 0.7782177807854866, 0.7414169653758014, 0.7488975639652787, 0.1260365113730908, 0.11863917586582173, 0.12282585325225315, 0.1730225647967698, 0.17523928355619023, 0.13816749343700052, 0.13605050692107412, 0.12476910900380311, 0.13292032060456171, 0.13829873376169632, 0.11018068180767204, 0.1442854808839329, 0.11288557073308203, 0.1733192939832332, 0.09969463812954271, 0.11619831825062776, 0.12149586278962365, 0.10815664397811064, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6290162284567968, 0.5922781557132764, 0.588780814996684, 0.6670225256780604, 0.644425863156447, 0.6348853304366482, 0.51465906649409, 0.6482033543525607, 0.605582459343158, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5206291164262296, 0.12125465973297, 0.12861577462045204, 0.5617507875338423, 0.12736644596554436, 0.7265431498207405, 0.39518306870503206, 0.5366229774522695, 0.40288428683431365, 0.44784254744102214, 0.1288152535756879, 0.49586790605034203, 0.5368670185254014, 0.575537508950831, 0.5203924925143957, 0.5831511620691582, 0.1264497201800464, 0.5038099392266262, 0.49934707714237136, 0.5284834725514336, 9.999999999998899e-05, 0.6010321473736554, 0.382485077859132, 0.36935365984943236, 0.48364233848944393, 0.4198517361019898, 0.27367132718451503, 0.5963278370603864, 0.5224253748143389, 0.4653302118007083, 0.6831886960244166, 0.580173927849811, 0.4952337541702897, 0.5792440662318769, 0.08123422967530491, 0.7078451166151098, 0.0739010626179103, 0.1084619212107013, 0.3855359850948187, 0.3521518163304569, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.43403222200219826, 0.42711740183650415, 0.46483801601092856, 0.03805354803257921, 0.4661126798316374, 0.40871735786607777, 0.3718109253001566, 0.3371319365795915, 0.6948568389807652, 0.6245302587707393, 0.6884578786474407, 0.7321140615795139, 0.6024203182118643, 0.6730790023229437, 0.6518467238363761, 0.6501001592558935, 0.7801717998256352, 0.14314049685128938, 0.09503011201524791, 0.11130418714052726, 0.14066098435242724, 0.10992720434210046, 0.12329404616465311, 0.13665658230927002, 0.13308825011320846, 0.11906316999336908, 0.18600333865198404, 0.2673014954593603, 0.2556784400268317, 0.1639969500449312, 0.16418829342256847, 0.24061537736670835, 0.15552857239351547, 0.20594675517067074, 0.31461537770532055, 0.49199369420021233, 0.34834637766463405, 0.5467715808924283, 0.43074953391482973, 0.500392811902082, 0.40577304191016295, 0.24173248114034063, 0.20595781597406315, 0.5485168868695214, 0.19453192043951406, 0.2703873449117091, 0.4117133465805445, 0.24211103021888292, 0.39158270919502947, 0.4408556271588616, 0.214665216511152, 0.3326676085837589, 0.3686769563545761, 0.22406086113739287, 0.2162592903384254, 0.26643093577723, 0.22076107381384635, 0.2130608649876382, 0.21791115593653, 0.21324382202328362, 0.1841692469811571, 0.23955364122471723, 0.7758472744891161, 0.19081196702814418, 0.20592291284862474, 0.18665042546779664, 0.20165006658640328, 0.19146475586217948, 0.196949486636246, 0.18052241226414334, 0.199244686156535, 0.16398331650145992, 0.18666358427992769, 0.9130595737841963, 0.10337077808419859, 0.16896991770819714, 0.16737607409133837, 0.1865383984864062, 0.12487727769843693, 0.8394302306900628, 0.8918762231358082, 0.15613242217346068, 0.886246531723765, 0.20984586224128066, 0.8537568020847193, 0.1615534138203335, 0.10458026021234912, 0.16621803419387982, 0.8676933569508227, 0.1801010290889843, 0.1861849159422556, 0.1810781877376637, 0.17079458853552554, 0.18721586379369282, 0.1805003181901007, 0.16824230993890488, 0.1735854651922597, 0.18195722678289739, 0.10159357200343222, 0.0960010997993137, 0.09013961566952788, 0.08537947729245021, 0.09032768963826765, 0.11212037078744308, 0.08284381425380383, 0.08679771977119677, 0.07310908540901806]}, "mutation_prompt": null}
{"id": "0919ce8f-303a-4e60-9e39-8b6bc8ad3c33", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.F = 0.6  # Moderate differential weight for balance\n        self.CR = 0.9  # Increased crossover probability for better exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.90  # Adaptive factor for consistent adjustment\n        self.diversity_threshold = 0.1  # Explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Adaptive Learning Rate utilizing explicit diversity maintenance to improve convergence.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8732766226181966, 0.8642243016655347, 0.8659935461581776, 0.8547781410271569, 0.8489843434467998, 0.8291276393042519, 0.8542008358345242, 0.8671068584652082, 0.8460371044231281, 0.754998745647667, 0.6685360222833198, 0.7094896514843003, 0.7032145651648585, 0.682277274361005, 0.6957365976649358, 0.7782177807854866, 0.7414169653758014, 0.7488975639652787, 0.1260365113730908, 0.11863917586582173, 0.12282585325225315, 0.1730225647967698, 0.17523928355619023, 0.13816749343700052, 0.13605050692107412, 0.12476910900380311, 0.13292032060456171, 0.13829873376169632, 0.11018068180767204, 0.1442854808839329, 0.11288557073308203, 0.1733192939832332, 0.09969463812954271, 0.11619831825062776, 0.12149586278962365, 0.10815664397811064, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6290162284567968, 0.5922781557132764, 0.588780814996684, 0.6670225256780604, 0.644425863156447, 0.6348853304366482, 0.51465906649409, 0.6482033543525607, 0.605582459343158, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5206291164262296, 0.12125465973297, 0.12861577462045204, 0.5617507875338423, 0.12736644596554436, 0.7265431498207405, 0.39518306870503206, 0.5366229774522695, 0.40288428683431365, 0.44784254744102214, 0.1288152535756879, 0.49586790605034203, 0.5368670185254014, 0.575537508950831, 0.5203924925143957, 0.5831511620691582, 0.1264497201800464, 0.5038099392266262, 0.49934707714237136, 0.5284834725514336, 9.999999999998899e-05, 0.6010321473736554, 0.382485077859132, 0.36935365984943236, 0.48364233848944393, 0.4198517361019898, 0.27367132718451503, 0.5963278370603864, 0.5224253748143389, 0.4653302118007083, 0.6831886960244166, 0.580173927849811, 0.4952337541702897, 0.5792440662318769, 0.08123422967530491, 0.7078451166151098, 0.0739010626179103, 0.1084619212107013, 0.3855359850948187, 0.3521518163304569, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.43403222200219826, 0.42711740183650415, 0.46483801601092856, 0.03805354803257921, 0.4661126798316374, 0.40871735786607777, 0.3718109253001566, 0.3371319365795915, 0.6948568389807652, 0.6245302587707393, 0.6884578786474407, 0.7321140615795139, 0.6024203182118643, 0.6730790023229437, 0.6518467238363761, 0.6501001592558935, 0.7801717998256352, 0.14314049685128938, 0.09503011201524791, 0.11130418714052726, 0.14066098435242724, 0.10992720434210046, 0.12329404616465311, 0.13665658230927002, 0.13308825011320846, 0.11906316999336908, 0.18600333865198404, 0.2673014954593603, 0.2556784400268317, 0.1639969500449312, 0.16418829342256847, 0.24061537736670835, 0.15552857239351547, 0.20594675517067074, 0.31461537770532055, 0.49199369420021233, 0.34834637766463405, 0.5467715808924283, 0.43074953391482973, 0.500392811902082, 0.40577304191016295, 0.24173248114034063, 0.20595781597406315, 0.5485168868695214, 0.19453192043951406, 0.2703873449117091, 0.4117133465805445, 0.24211103021888292, 0.39158270919502947, 0.4408556271588616, 0.214665216511152, 0.3326676085837589, 0.3686769563545761, 0.22406086113739287, 0.2162592903384254, 0.26643093577723, 0.22076107381384635, 0.2130608649876382, 0.21791115593653, 0.21324382202328362, 0.1841692469811571, 0.23955364122471723, 0.7758472744891161, 0.19081196702814418, 0.20592291284862474, 0.18665042546779664, 0.20165006658640328, 0.19146475586217948, 0.196949486636246, 0.18052241226414334, 0.199244686156535, 0.16398331650145992, 0.18666358427992769, 0.9130595737841963, 0.10337077808419859, 0.16896991770819714, 0.16737607409133837, 0.1865383984864062, 0.12487727769843693, 0.8394302306900628, 0.8918762231358082, 0.15613242217346068, 0.886246531723765, 0.20984586224128066, 0.8537568020847193, 0.1615534138203335, 0.10458026021234912, 0.16621803419387982, 0.8676933569508227, 0.1801010290889843, 0.1861849159422556, 0.1810781877376637, 0.17079458853552554, 0.18721586379369282, 0.1805003181901007, 0.16824230993890488, 0.1735854651922597, 0.18195722678289739, 0.10159357200343222, 0.0960010997993137, 0.09013961566952788, 0.08537947729245021, 0.09032768963826765, 0.11212037078744308, 0.08284381425380383, 0.08679771977119677, 0.07310908540901806]}, "mutation_prompt": null}
{"id": "116ceac6-c633-4997-8d4a-e797caacdd81", "solution": "import numpy as np\n\nclass EnhancedMemeticEvoStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.F = 0.6  # Moderate differential weight for balance\n        self.CR = 0.9  # Increased crossover probability for better exploration\n        self.population = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.mutation_strategy = 'rand'\n        self.adaptive_factor = 0.90  # Adaptive factor for consistent adjustment\n        self.diversity_threshold = 0.1  # Explicit diversity threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.population])\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.best_fitness = fitness[min_idx]\n            self.best_solution = self.population[min_idx].copy()\n        return fitness\n\n    def mutate(self, idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        np.random.shuffle(indices)\n        a, b, c = indices[:3]\n        if self.mutation_strategy == 'best':\n            return self.best_solution + self.F * (self.population[b] - self.population[c])\n        else:\n            return self.population[a] + self.F * (self.population[b] - self.population[c])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.array([mutant[j] if np.random.rand() < self.CR or j == j_rand else target[j] for j in range(self.dim)])\n        return np.clip(trial, self.bounds[0], self.bounds[1])\n\n    def optimize(self, func):\n        self.initialize_population()\n        func_calls = 0\n        stagnation_counter = 0\n        historical_fitness = []\n\n        while func_calls < self.budget:\n            for i in range(self.population_size):\n                if func_calls >= self.budget:\n                    break\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                func_calls += 1\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial.copy()\n                    stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n\n            historical_fitness.append(self.best_fitness)\n            if len(historical_fitness) > 10:\n                historical_fitness.pop(0)\n                fitness_improvement = np.std(historical_fitness)\n                if fitness_improvement < 1e-5:\n                    self.F *= self.adaptive_factor\n                    self.CR *= self.adaptive_factor\n                    self.F = np.clip(self.F, 0.3, 0.8)\n                    self.CR = np.clip(self.CR, 0.5, 0.95)\n\n            if stagnation_counter > self.population_size:\n                self.mutation_strategy = 'best'\n            else:\n                self.mutation_strategy = 'rand'\n\n            if func_calls > self.budget * 0.75 and stagnation_counter > self.population_size * 0.25:\n                for i in range(self.population_size):\n                    if func_calls >= self.budget:\n                        break\n                    random_walk_solution = self.population[i] + np.random.normal(0, 0.1 + 0.01 * (stagnation_counter / self.population_size), self.dim)\n                    random_walk_solution = np.clip(random_walk_solution, self.bounds[0], self.bounds[1])\n                    random_walk_fitness = func(random_walk_solution)\n                    func_calls += 1\n                    if random_walk_fitness < self.best_fitness:\n                        self.best_fitness = random_walk_fitness\n                        self.best_solution = random_walk_solution.copy()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution", "name": "EnhancedMemeticEvoStrategy", "description": "Enhanced Memetic Evolutionary Strategy with Adaptive Learning Rate utilizing explicit diversity maintenance to improve convergence.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4303812-3599-49d7-9ba2-28643886bb39", "metadata": {"aucs": [0.8732766226181966, 0.8642243016655347, 0.8659935461581776, 0.8547781410271569, 0.8489843434467998, 0.8291276393042519, 0.8542008358345242, 0.8671068584652082, 0.8460371044231281, 0.754998745647667, 0.6685360222833198, 0.7094896514843003, 0.7032145651648585, 0.682277274361005, 0.6957365976649358, 0.7782177807854866, 0.7414169653758014, 0.7488975639652787, 0.1260365113730908, 0.11863917586582173, 0.12282585325225315, 0.1730225647967698, 0.17523928355619023, 0.13816749343700052, 0.13605050692107412, 0.12476910900380311, 0.13292032060456171, 0.13829873376169632, 0.11018068180767204, 0.1442854808839329, 0.11288557073308203, 0.1733192939832332, 0.09969463812954271, 0.11619831825062776, 0.12149586278962365, 0.10815664397811064, 0.9678121446268062, 0.9854085632218513, 0.9729065597785156, 0.9103762912818095, 0.9820157488206231, 0.985269394999056, 0.9637126292295584, 0.9659424798200463, 0.9610032855266553, 0.6290162284567968, 0.5922781557132764, 0.588780814996684, 0.6670225256780604, 0.644425863156447, 0.6348853304366482, 0.51465906649409, 0.6482033543525607, 0.605582459343158, 0.3902008458670324, 0.3698444481405251, 0.8716159909258816, 0.8736711792727909, 0.2028727953933548, 0.372962052988532, 0.3437384728855998, 0.23360847512064742, 0.138250097719258, 0.5206291164262296, 0.12125465973297, 0.12861577462045204, 0.5617507875338423, 0.12736644596554436, 0.7265431498207405, 0.39518306870503206, 0.5366229774522695, 0.40288428683431365, 0.44784254744102214, 0.1288152535756879, 0.49586790605034203, 0.5368670185254014, 0.575537508950831, 0.5203924925143957, 0.5831511620691582, 0.1264497201800464, 0.5038099392266262, 0.49934707714237136, 0.5284834725514336, 9.999999999998899e-05, 0.6010321473736554, 0.382485077859132, 0.36935365984943236, 0.48364233848944393, 0.4198517361019898, 0.27367132718451503, 0.5963278370603864, 0.5224253748143389, 0.4653302118007083, 0.6831886960244166, 0.580173927849811, 0.4952337541702897, 0.5792440662318769, 0.08123422967530491, 0.7078451166151098, 0.0739010626179103, 0.1084619212107013, 0.3855359850948187, 0.3521518163304569, 0.2198841579218649, 0.1697140507408147, 0.19391229199658333, 0.11779030989750516, 0.08765893799733915, 0.30881000670955494, 0.43403222200219826, 0.42711740183650415, 0.46483801601092856, 0.03805354803257921, 0.4661126798316374, 0.40871735786607777, 0.3718109253001566, 0.3371319365795915, 0.6948568389807652, 0.6245302587707393, 0.6884578786474407, 0.7321140615795139, 0.6024203182118643, 0.6730790023229437, 0.6518467238363761, 0.6501001592558935, 0.7801717998256352, 0.14314049685128938, 0.09503011201524791, 0.11130418714052726, 0.14066098435242724, 0.10992720434210046, 0.12329404616465311, 0.13665658230927002, 0.13308825011320846, 0.11906316999336908, 0.18600333865198404, 0.2673014954593603, 0.2556784400268317, 0.1639969500449312, 0.16418829342256847, 0.24061537736670835, 0.15552857239351547, 0.20594675517067074, 0.31461537770532055, 0.49199369420021233, 0.34834637766463405, 0.5467715808924283, 0.43074953391482973, 0.500392811902082, 0.40577304191016295, 0.24173248114034063, 0.20595781597406315, 0.5485168868695214, 0.19453192043951406, 0.2703873449117091, 0.4117133465805445, 0.24211103021888292, 0.39158270919502947, 0.4408556271588616, 0.214665216511152, 0.3326676085837589, 0.3686769563545761, 0.22406086113739287, 0.2162592903384254, 0.26643093577723, 0.22076107381384635, 0.2130608649876382, 0.21791115593653, 0.21324382202328362, 0.1841692469811571, 0.23955364122471723, 0.7758472744891161, 0.19081196702814418, 0.20592291284862474, 0.18665042546779664, 0.20165006658640328, 0.19146475586217948, 0.196949486636246, 0.18052241226414334, 0.199244686156535, 0.16398331650145992, 0.18666358427992769, 0.9130595737841963, 0.10337077808419859, 0.16896991770819714, 0.16737607409133837, 0.1865383984864062, 0.12487727769843693, 0.8394302306900628, 0.8918762231358082, 0.15613242217346068, 0.886246531723765, 0.20984586224128066, 0.8537568020847193, 0.1615534138203335, 0.10458026021234912, 0.16621803419387982, 0.8676933569508227, 0.1801010290889843, 0.1861849159422556, 0.1810781877376637, 0.17079458853552554, 0.18721586379369282, 0.1805003181901007, 0.16824230993890488, 0.1735854651922597, 0.18195722678289739, 0.10159357200343222, 0.0960010997993137, 0.09013961566952788, 0.08537947729245021, 0.09032768963826765, 0.11212037078744308, 0.08284381425380383, 0.08679771977119677, 0.07310908540901806]}, "mutation_prompt": null}
