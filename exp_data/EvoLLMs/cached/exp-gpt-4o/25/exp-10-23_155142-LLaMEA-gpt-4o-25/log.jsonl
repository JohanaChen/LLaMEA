{"id": "95bf1369-736a-418b-919c-76b865559f39", "solution": "import numpy as np\n\nclass MADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MADE", "description": "A Memory-Enhanced Adaptive Differential Evolution (MADE) algorithm combines differential evolution with adaptive mutation strategies and a memory mechanism to dynamically adjust strategies based on past performance.", "configspace": "", "generation": 0, "fitness": 0.36668327298900144, "feedback": "The algorithm MADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7682514559171263, 0.7600569239394717, 0.7636466400645218, 0.7671130477310657, 0.7903514481991641, 0.7698013354620454, 0.7783020555132691, 0.790128072452183, 0.7725187976041927, 0.6070142561843653, 0.5999766406812317, 0.5930099218524881, 0.609165449710199, 0.5986266298359444, 0.5933003434821107, 0.6033410541785547, 0.5916098030647285, 0.6125672881831984, 0.11765755949175039, 0.13764649380087812, 0.10754787854158998, 0.11041475356892316, 0.12793253089688805, 0.11186811498992377, 0.11773515236663612, 0.1268426449185126, 0.10712749750129191, 0.11010807657988642, 0.10353425203005373, 0.10618315082661012, 0.09516264772335858, 0.10244872689336515, 0.10410660466004229, 0.10886741672597577, 0.1065638383619888, 0.10566866554008392, 0.843387462913374, 0.9318153667770599, 0.9028707220583045, 0.833671880929729, 0.8953041935846743, 0.7751276813997141, 0.8337610872159981, 0.9266829117991846, 0.9174362807125387, 0.4562292454741471, 0.46304418336731534, 0.40688519607119134, 0.36776747785100805, 0.41949839152693924, 0.42128520410524795, 0.44741521780700877, 0.4171351961370585, 0.41082050235208634, 0.7696242456416582, 0.7394768409738849, 0.7498063378668416, 0.7637263916342989, 0.7293935812495511, 0.7531314203704407, 0.7493579042710876, 0.7583082771128605, 0.7755397563786, 0.20323817305490854, 0.25233930919685954, 0.3119664004767315, 0.18126442682195, 0.2330154701635786, 0.15850898877356268, 0.2633561439527775, 0.19986847384059947, 0.25585762486516983, 0.12945569201743745, 0.30365124613915795, 0.2527874282555711, 0.24221055941297231, 0.18276529011579412, 0.23630155683960863, 0.21087936699393495, 0.17735612606551132, 0.17619480867540238, 0.35649562791729505, 0.36364099539790484, 0.3516950186031409, 0.36357128419417706, 0.4019782097458269, 0.35684144628021264, 0.35057972353925726, 0.36521981059608666, 0.3908636554648567, 0.4699731528077583, 0.5264963824892643, 0.5139566136682838, 0.5177661720789491, 0.49858608316856157, 0.5230836675100352, 0.530573111650668, 0.5428474131084177, 0.5224494378890268, 0.09185074423997175, 0.11101280167946659, 0.16013991892928703, 0.1331751162058168, 0.21968972505527107, 0.27175874494461794, 0.14362090000517969, 0.19067936451354006, 0.1904920167866193, 0.29676896683826437, 0.2740721746581428, 0.2984817041631156, 0.3111043223219291, 0.2988481478177829, 0.3075155621110415, 0.3093955612127943, 0.3015167940390755, 0.31474025111636605, 0.6873365961767945, 0.670295165150394, 0.6964220136085257, 0.6847736314023929, 0.6696602828918757, 0.6877950945271007, 0.6793435945045185, 0.6687848211330003, 0.7066041693552487, 0.0951133787332159, 0.09941361368856072, 0.10023326398095611, 0.11449028470234279, 0.0960646971880662, 0.11200560661954495, 0.09253293754180691, 0.09786519987934517, 0.1019393142244518, 0.1351654912966178, 0.14031334394462758, 0.13790709755623343, 0.14503245091636585, 0.19563849096779762, 0.14763153587201172, 0.16759510705845604, 0.12584116070581564, 0.12811159688156937, 0.41476751248425703, 0.3867939582226131, 0.43667067940871784, 0.3893126873665629, 0.3874100936633277, 0.39749426549979705, 0.4002765883584455, 0.39651710476619406, 0.39531639984436207, 0.28988170382182266, 0.32509227190029, 0.329165856869472, 0.3099028251603716, 0.28695955335921697, 0.3239306586481122, 0.3574828649862468, 0.32641965323458744, 0.34686477466077803, 0.1993764788145811, 0.1796048275216382, 0.1839126056756133, 0.18336399034042472, 0.19876449768764015, 0.19616669801279008, 0.17224169109791543, 0.19108975961282915, 0.213520491208937, 0.44470633739978327, 0.23698288028737857, 0.1924479996011056, 0.19231799608915, 0.187759898605242, 0.18432290924299133, 0.19550269983769064, 0.19404719121219516, 0.2066630403504417, 0.7151219584718407, 0.6647251113681625, 0.17752954850982228, 0.732719776953036, 0.6930154034812326, 0.7604333097297, 0.6809846423271633, 0.6613829862696836, 0.48242159398900486, 0.6067629645337731, 0.20501842371603707, 0.7024397961139044, 0.5557044687646955, 0.19680264144190718, 0.20039762171316655, 0.20484166596415998, 0.6926483855966181, 0.20997647839541334, 0.18674682884606653, 0.18939125143027136, 0.18923422321395245, 0.19651006379909353, 0.18099086880525084, 0.18394216934907404, 0.18994090430746513, 0.1787039000899846, 0.23350007951757212, 0.0966824927280262, 0.08057947651813269, 0.07621410621555735, 0.07316557039156413, 0.07585839128582739, 0.07550947938882635, 0.07504783358507572, 0.08005832775687927, 0.08442500023025823]}, "mutation_prompt": null}
{"id": "1d660538-1ba7-420d-918f-717cb5476594", "solution": "import numpy as np\n\nclass DSMCDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.Cr = 0.9\n        self.memory = []\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            avg_fitness = np.mean(fitness)\n            diversity = np.std(population, axis=0).mean()\n            self.F = 0.4 + 0.2 * np.exp(-diversity)\n            self.Cr = 0.9 - 0.4 * (np.std(fitness) / avg_fitness)\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "DSMCDE", "description": "A Dynamic Scaled Mutation and Crossover Differential Evolution (DSM-CDE) algorithm enhances the exploration capabilities by dynamically scaling mutation and crossover rates based on population diversity and convergence speed to improve performance in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": 0.21713522529586016, "feedback": "The algorithm DSMCDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.25.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.752545291733727, 0.761799676456946, 0.7525814427549293, 0.7589644953131129, 0.7607716698699489, 0.7488067073132153, 0.7597025786043814, 0.7568599093129982, 0.7505511785303158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12056799224420978, 0.10556791013354994, 0.13243895585794652, 0.05735523914267038, 0.1131001921557594, 0.11626220610260463, 0.03497090142625203, 0.1166326513132313, 0.11540556716580486, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0649493721016674, 0.10915176839320961, 0.11862943571023388, 0.11032328141563086, 0.11277048819319002, 0.11199664920860253, 0.15655353772107938, 0.1394451946079014, 0.3161916953390098, 0.8735614138197133, 0.9023412028474146, 0.9171544642120208, 0.8839551886176789, 0.8650749247586214, 0.9434966379627712, 0.11722932747439752, 0.041986298801194644, 0.08882711218244999, 0.038916459877944565, 0.12381686189210306, 0.06575552990483957, 0.061970789908671775, 0.08563788464301925, 0.053964761076641166, 0.7286656889049572, 0.6741326754166659, 0.7377522727993775, 0.7239388553053272, 0.7488728809216711, 0.7716446869682099, 0.60416918756742, 0.6818799711499093, 0.6376197816081162, 9.999999999998899e-05, 0.20980330340699782, 0.07491487194372781, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.28021699977038805, 0.0046067220467286285, 9.999999999998899e-05, 0.2878135413507128, 9.999999999998899e-05, 0.23917995522269075, 0.22951706183536347, 0.2564682253313433, 0.07279047723397103, 0.2126217264700515, 0.22831253778683158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010259155987241142, 0.018628053272071732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02437804674822741, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2346904952659581, 0.2324650936849746, 0.2353561203453567, 0.04928474817883943, 0.07378707641862725, 0.07452175877461231, 9.999999999998899e-05, 0.0003590280825542802, 0.013921712031430777, 0.10941942073320166, 0.15756555760738078, 0.15850860548237966, 0.6484660508606579, 0.6109577326826869, 0.09580441870675127, 0.6476138039527546, 0.6269795305228336, 0.6411274532482774, 0.10731897150543879, 0.102907701863576, 0.0880950808805051, 0.1174859917604435, 0.09475829507478573, 0.09928269349341023, 0.05647003834046482, 0.05191119856283, 0.057495109638864283, 0.17123102045179217, 0.1417617185123432, 0.17254292509697466, 0.13312921808906353, 0.148790651396831, 0.16380122777418094, 0.1495796120759627, 0.13128408444136763, 0.13165116850552294, 0.14104583072309107, 0.12529330625815305, 0.1613932299901244, 0.3642834613502587, 0.366170749936949, 0.37870517837310436, 0.37454221866035775, 0.37684559158456143, 0.3525243280550562, 0.14952430914344805, 0.10070104618380393, 0.08398582550377798, 0.30024645681794426, 0.2913681482787127, 0.26978655440475086, 0.2972414406366797, 0.3007280192264691, 0.29282716136047926, 0.20127459290419414, 0.1878586036111084, 0.2143083119112862, 0.20304824050412784, 0.19729212689177322, 0.21975756176725425, 0.2136352377147016, 0.225301442393403, 0.21052650966820574, 0.15420514865277113, 0.1274328942740116, 0.15961447567700493, 0.21343127759633718, 0.20025032303761314, 0.19326063554572692, 0.15313529796285585, 0.189380439280747, 0.1530139316771314, 0.752523128707641, 0.17826030972047624, 0.19042226309227617, 0.27184747242761953, 0.3141098346266714, 0.23125133870545167, 0.6026930585054566, 0.17108248624926348, 0.7281709852714588, 0.7364986560720692, 0.6947314877437816, 0.19772596707923218, 0.18954817976427807, 0.19876027342018066, 0.2586410480418123, 0.20653057309585376, 0.10568314718623328, 0.08994662784658214, 0.18557832562422327, 0.1957913013702971, 0.21028912082902973, 0.17789893356132147, 0.1807199763052484, 0.18437752295147958, 0.18563162805405753, 0.18968423482265184, 0.18403031241902634, 0.0806267467473677, 0.08741197224580488, 0.07534120261704991, 0.0926975712458219, 0.08253040559698965, 0.077954992340179, 0.07709707998792636, 0.07855047177018659, 0.08113328110957185]}, "mutation_prompt": null}
{"id": "db4984a7-e34f-42a9-bb63-a01ab177f2e9", "solution": "import numpy as np\n\nclass MADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MADE", "description": "A Memory-Enhanced Adaptive Differential Evolution (MADE) algorithm combines differential evolution with adaptive mutation strategies and a memory mechanism to dynamically adjust strategies based on past performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7682514559171263, 0.7600569239394717, 0.7636466400645218, 0.7671130477310657, 0.7903514481991641, 0.7698013354620454, 0.7783020555132691, 0.790128072452183, 0.7725187976041927, 0.6070142561843653, 0.5999766406812317, 0.5930099218524881, 0.609165449710199, 0.5986266298359444, 0.5933003434821107, 0.6033410541785547, 0.5916098030647285, 0.6125672881831984, 0.11765755949175039, 0.13764649380087812, 0.10754787854158998, 0.11041475356892316, 0.12793253089688805, 0.11186811498992377, 0.11773515236663612, 0.1268426449185126, 0.10712749750129191, 0.11010807657988642, 0.10353425203005373, 0.10618315082661012, 0.09516264772335858, 0.10244872689336515, 0.10410660466004229, 0.10886741672597577, 0.1065638383619888, 0.10566866554008392, 0.843387462913374, 0.9318153667770599, 0.9028707220583045, 0.833671880929729, 0.8953041935846743, 0.7751276813997141, 0.8337610872159981, 0.9266829117991846, 0.9174362807125387, 0.4562292454741471, 0.46304418336731534, 0.40688519607119134, 0.36776747785100805, 0.41949839152693924, 0.42128520410524795, 0.44741521780700877, 0.4171351961370585, 0.41082050235208634, 0.7696242456416582, 0.7394768409738849, 0.7498063378668416, 0.7637263916342989, 0.7293935812495511, 0.7531314203704407, 0.7493579042710876, 0.7583082771128605, 0.7755397563786, 0.20323817305490854, 0.25233930919685954, 0.3119664004767315, 0.18126442682195, 0.2330154701635786, 0.15850898877356268, 0.2633561439527775, 0.19986847384059947, 0.25585762486516983, 0.12945569201743745, 0.30365124613915795, 0.2527874282555711, 0.24221055941297231, 0.18276529011579412, 0.23630155683960863, 0.21087936699393495, 0.17735612606551132, 0.17619480867540238, 0.35649562791729505, 0.36364099539790484, 0.3516950186031409, 0.36357128419417706, 0.4019782097458269, 0.35684144628021264, 0.35057972353925726, 0.36521981059608666, 0.3908636554648567, 0.4699731528077583, 0.5264963824892643, 0.5139566136682838, 0.5177661720789491, 0.49858608316856157, 0.5230836675100352, 0.530573111650668, 0.5428474131084177, 0.5224494378890268, 0.09185074423997175, 0.11101280167946659, 0.16013991892928703, 0.1331751162058168, 0.21968972505527107, 0.27175874494461794, 0.14362090000517969, 0.19067936451354006, 0.1904920167866193, 0.29676896683826437, 0.2740721746581428, 0.2984817041631156, 0.3111043223219291, 0.2988481478177829, 0.3075155621110415, 0.3093955612127943, 0.3015167940390755, 0.31474025111636605, 0.6873365961767945, 0.670295165150394, 0.6964220136085257, 0.6847736314023929, 0.6696602828918757, 0.6877950945271007, 0.6793435945045185, 0.6687848211330003, 0.7066041693552487, 0.0951133787332159, 0.09941361368856072, 0.10023326398095611, 0.11449028470234279, 0.0960646971880662, 0.11200560661954495, 0.09253293754180691, 0.09786519987934517, 0.1019393142244518, 0.1351654912966178, 0.14031334394462758, 0.13790709755623343, 0.14503245091636585, 0.19563849096779762, 0.14763153587201172, 0.16759510705845604, 0.12584116070581564, 0.12811159688156937, 0.41476751248425703, 0.3867939582226131, 0.43667067940871784, 0.3893126873665629, 0.3874100936633277, 0.39749426549979705, 0.4002765883584455, 0.39651710476619406, 0.39531639984436207, 0.28988170382182266, 0.32509227190029, 0.329165856869472, 0.3099028251603716, 0.28695955335921697, 0.3239306586481122, 0.3574828649862468, 0.32641965323458744, 0.34686477466077803, 0.1993764788145811, 0.1796048275216382, 0.1839126056756133, 0.18336399034042472, 0.19876449768764015, 0.19616669801279008, 0.17224169109791543, 0.19108975961282915, 0.213520491208937, 0.44470633739978327, 0.23698288028737857, 0.1924479996011056, 0.19231799608915, 0.187759898605242, 0.18432290924299133, 0.19550269983769064, 0.19404719121219516, 0.2066630403504417, 0.7151219584718407, 0.6647251113681625, 0.17752954850982228, 0.732719776953036, 0.6930154034812326, 0.7604333097297, 0.6809846423271633, 0.6613829862696836, 0.48242159398900486, 0.6067629645337731, 0.20501842371603707, 0.7024397961139044, 0.5557044687646955, 0.19680264144190718, 0.20039762171316655, 0.20484166596415998, 0.6926483855966181, 0.20997647839541334, 0.18674682884606653, 0.18939125143027136, 0.18923422321395245, 0.19651006379909353, 0.18099086880525084, 0.18394216934907404, 0.18994090430746513, 0.1787039000899846, 0.23350007951757212, 0.0966824927280262, 0.08057947651813269, 0.07621410621555735, 0.07316557039156413, 0.07585839128582739, 0.07550947938882635, 0.07504783358507572, 0.08005832775687927, 0.08442500023025823]}, "mutation_prompt": null}
{"id": "ac5a3540-0e28-40fc-895e-13cdbef04372", "solution": "import numpy as np\n\nclass EMADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.Cr = 0.9\n        self.memory = []\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n        global_best = np.min(fitness)\n\n        while eval_count < self.budget:\n            if len(self.memory) > 0:\n                best_entries = sorted(self.memory, key=lambda x: x[2])[:5]\n                self.F = np.mean([entry[0] for entry in best_entries])\n                self.Cr = np.mean([entry[1] for entry in best_entries])\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr, trial_fitness))\n                    if len(self.memory) > 50:\n                        self.memory.pop(0)\n\n                if trial_fitness < global_best:\n                    global_best = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EMADE", "description": "An Enhanced Memory-Guided Adaptive Differential Evolution (EMADE) algorithm that utilizes a dynamic adaptation of crossover probability and differential weight guided by best-performing past strategies.", "configspace": "", "generation": 3, "fitness": 0.36668327298900144, "feedback": "The algorithm EMADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7682514559171263, 0.7600569239394717, 0.7636466400645218, 0.7671130477310657, 0.7903514481991641, 0.7698013354620454, 0.7783020555132691, 0.790128072452183, 0.7725187976041927, 0.6070142561843653, 0.5999766406812317, 0.5930099218524881, 0.609165449710199, 0.5986266298359444, 0.5933003434821107, 0.6033410541785547, 0.5916098030647285, 0.6125672881831984, 0.11765755949175039, 0.13764649380087812, 0.10754787854158998, 0.11041475356892316, 0.12793253089688805, 0.11186811498992377, 0.11773515236663612, 0.1268426449185126, 0.10712749750129191, 0.11010807657988642, 0.10353425203005373, 0.10618315082661012, 0.09516264772335858, 0.10244872689336515, 0.10410660466004229, 0.10886741672597577, 0.1065638383619888, 0.10566866554008392, 0.843387462913374, 0.9318153667770599, 0.9028707220583045, 0.833671880929729, 0.8953041935846743, 0.7751276813997141, 0.8337610872159981, 0.9266829117991846, 0.9174362807125387, 0.4562292454741471, 0.46304418336731534, 0.40688519607119134, 0.36776747785100805, 0.41949839152693924, 0.42128520410524795, 0.44741521780700877, 0.4171351961370585, 0.41082050235208634, 0.7696242456416582, 0.7394768409738849, 0.7498063378668416, 0.7637263916342989, 0.7293935812495511, 0.7531314203704407, 0.7493579042710876, 0.7583082771128605, 0.7755397563786, 0.20323817305490854, 0.25233930919685954, 0.3119664004767315, 0.18126442682195, 0.2330154701635786, 0.15850898877356268, 0.2633561439527775, 0.19986847384059947, 0.25585762486516983, 0.12945569201743745, 0.30365124613915795, 0.2527874282555711, 0.24221055941297231, 0.18276529011579412, 0.23630155683960863, 0.21087936699393495, 0.17735612606551132, 0.17619480867540238, 0.35649562791729505, 0.36364099539790484, 0.3516950186031409, 0.36357128419417706, 0.4019782097458269, 0.35684144628021264, 0.35057972353925726, 0.36521981059608666, 0.3908636554648567, 0.4699731528077583, 0.5264963824892643, 0.5139566136682838, 0.5177661720789491, 0.49858608316856157, 0.5230836675100352, 0.530573111650668, 0.5428474131084177, 0.5224494378890268, 0.09185074423997175, 0.11101280167946659, 0.16013991892928703, 0.1331751162058168, 0.21968972505527107, 0.27175874494461794, 0.14362090000517969, 0.19067936451354006, 0.1904920167866193, 0.29676896683826437, 0.2740721746581428, 0.2984817041631156, 0.3111043223219291, 0.2988481478177829, 0.3075155621110415, 0.3093955612127943, 0.3015167940390755, 0.31474025111636605, 0.6873365961767945, 0.670295165150394, 0.6964220136085257, 0.6847736314023929, 0.6696602828918757, 0.6877950945271007, 0.6793435945045185, 0.6687848211330003, 0.7066041693552487, 0.0951133787332159, 0.09941361368856072, 0.10023326398095611, 0.11449028470234279, 0.0960646971880662, 0.11200560661954495, 0.09253293754180691, 0.09786519987934517, 0.1019393142244518, 0.1351654912966178, 0.14031334394462758, 0.13790709755623343, 0.14503245091636585, 0.19563849096779762, 0.14763153587201172, 0.16759510705845604, 0.12584116070581564, 0.12811159688156937, 0.41476751248425703, 0.3867939582226131, 0.43667067940871784, 0.3893126873665629, 0.3874100936633277, 0.39749426549979705, 0.4002765883584455, 0.39651710476619406, 0.39531639984436207, 0.28988170382182266, 0.32509227190029, 0.329165856869472, 0.3099028251603716, 0.28695955335921697, 0.3239306586481122, 0.3574828649862468, 0.32641965323458744, 0.34686477466077803, 0.1993764788145811, 0.1796048275216382, 0.1839126056756133, 0.18336399034042472, 0.19876449768764015, 0.19616669801279008, 0.17224169109791543, 0.19108975961282915, 0.213520491208937, 0.44470633739978327, 0.23698288028737857, 0.1924479996011056, 0.19231799608915, 0.187759898605242, 0.18432290924299133, 0.19550269983769064, 0.19404719121219516, 0.2066630403504417, 0.7151219584718407, 0.6647251113681625, 0.17752954850982228, 0.732719776953036, 0.6930154034812326, 0.7604333097297, 0.6809846423271633, 0.6613829862696836, 0.48242159398900486, 0.6067629645337731, 0.20501842371603707, 0.7024397961139044, 0.5557044687646955, 0.19680264144190718, 0.20039762171316655, 0.20484166596415998, 0.6926483855966181, 0.20997647839541334, 0.18674682884606653, 0.18939125143027136, 0.18923422321395245, 0.19651006379909353, 0.18099086880525084, 0.18394216934907404, 0.18994090430746513, 0.1787039000899846, 0.23350007951757212, 0.0966824927280262, 0.08057947651813269, 0.07621410621555735, 0.07316557039156413, 0.07585839128582739, 0.07550947938882635, 0.07504783358507572, 0.08005832775687927, 0.08442500023025823]}, "mutation_prompt": null}
{"id": "5d13543d-d941-43ac-b46b-3b1bf6057fd0", "solution": "import numpy as np\n\nclass EMDDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size to enhance exploration\n        self.F = 0.6  # Modified differential weight for better diversity\n        self.Cr = 0.85  # Adjusted crossover probability\n        self.memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection based on memory\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory]) + 0.05  # Slight adjustment for Cr\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation with dynamically selected strategy\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover with adjusted probability\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection with memory update\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 60:  # Increased memory size for more refined strategy adaptation\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EMDDE", "description": "An Enhanced Memory-Driven Differential Evolution (EMDDE) that adjusts mutation and crossover strategies using memory of past trials and dynamically balances exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.32118684663892433, "feedback": "The algorithm EMDDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.21.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.6699579182875421, 0.6586396229503486, 0.643909749125295, 0.6670891685153948, 0.6775986091028288, 0.6735834159868483, 0.6888107364312377, 0.6803800975314686, 0.6741857485992309, 0.42971431157480966, 0.42562681496689425, 0.4109005420162092, 0.3868587367772448, 0.3832246258560903, 0.4197280414459038, 0.441244937696195, 0.4155649992571697, 0.40121592136442064, 0.0911130019368811, 0.09164379244079013, 0.10152121670473557, 0.0878748147204127, 0.08961452502233691, 0.09670752020516471, 0.09724941845086799, 0.08929980236565882, 0.0866172849100254, 0.08052964997032508, 0.07611370113706983, 0.08654095182142807, 0.09620592233750735, 0.09393862609476633, 0.09069011053942999, 0.0734390290830812, 0.07332736087230929, 0.0809440225458411, 0.9314567821330103, 0.24477493633705072, 0.7548336474468612, 0.8517504435280379, 0.11421054123367991, 0.2811736029749047, 0.40339431707869533, 0.8154726675321133, 0.29230841182272493, 0.3040367913020441, 0.31334900053543346, 0.35532935489624784, 0.3247726809347148, 0.3412980578961732, 0.36329280593165536, 0.31369019586146696, 0.3617619135636656, 0.3326302557550579, 0.7174843187095605, 0.6720104450498994, 0.7134602096572816, 0.7636490838935686, 0.7589936317948499, 0.7578878704316203, 0.7140639044691304, 0.7164510436097227, 0.686954398503983, 0.22482762696063863, 0.2620844391495425, 0.33345124782751456, 0.18438336137059286, 0.20443610946503177, 0.21998987279739024, 0.18071545360056984, 0.20631616691928178, 0.2410479509287926, 0.274998149183196, 0.21180892690530262, 0.18779770504066717, 0.22306989584668957, 0.17471422104909673, 0.1944861129954163, 0.2937705949194619, 0.34466398881423865, 0.19131325909327201, 0.3888044061333874, 0.35953636230458774, 0.39362542246521903, 0.39187626017883836, 0.3705949726646327, 0.3565774801596917, 0.3387191890102609, 0.40381652338469043, 0.42977858531358337, 0.5407211838544277, 0.5114460527804406, 0.5213620813442263, 0.542331874589383, 0.5107904171802925, 0.49393474564853046, 0.5561600606138379, 0.5467469037129689, 0.509792043474952, 0.1460524651011359, 0.12484391726483368, 0.10794424882638198, 0.21163161058124447, 0.20602993861988717, 0.22836266563390384, 0.1343540185210781, 0.13031387164311314, 0.18770240789698378, 0.2573980356094713, 0.2901205915507442, 0.2544598211086232, 0.27769882802148227, 0.26192700883797937, 0.28689249975793696, 0.264966087066704, 0.2829644402527143, 0.27780560841919755, 0.6075924793481853, 0.6059141821937448, 0.6191274903858137, 0.6086064646909308, 0.6270934249367697, 0.6194427557779216, 0.6210786479021473, 0.6042437328218635, 0.634643448070976, 0.08739603565435627, 0.09576386101161205, 0.09464137763991587, 0.1015543752029393, 0.09062689301260196, 0.09800938435437145, 0.0866699306569928, 0.08648768987194067, 0.08302500847541794, 0.14839118839156618, 0.20503992439008334, 0.14594550700123432, 0.17970525073375887, 0.23579240862568351, 0.25198874539170957, 0.13588598376495065, 0.1383246230646772, 0.14966009881602638, 0.3411082738530653, 0.33375128472962157, 0.3192347769724946, 0.33072054697811204, 0.30141152011111094, 0.32964581553703765, 0.34399058974938135, 0.33310209818225034, 0.35488325213663996, 0.27011279758750273, 0.2629357132404463, 0.2737940188645607, 0.2793590616737681, 0.24797331613230522, 0.2593821501725947, 0.2827733927428493, 0.29300714407924733, 0.28382801751720677, 0.18991091148048544, 0.1880850485009139, 0.1855274958584736, 0.181705724306214, 0.1840873765594082, 0.19325250651334214, 0.18981226852288124, 0.2067237745010796, 0.192558212284339, 0.19260599052622274, 0.18571269340189578, 0.1848552812484764, 0.1989557817482328, 0.18537590835086826, 0.1804103993696593, 0.1861940326601702, 0.1845629851552567, 0.17677202936674408, 0.19576948198710264, 0.18818588127787705, 0.658533916278067, 0.5993970366255561, 0.1911740002807556, 0.6006789416793648, 0.632826428661301, 0.5192802273121649, 0.690384410363958, 0.681019080808978, 0.6468087608022302, 0.6269410094788834, 0.5580156030096249, 0.5875991394270633, 0.47969884829566956, 0.2062016760666474, 0.19528371107506226, 0.21076973851670633, 0.17779503073251812, 0.1835607253722249, 0.18140844480197715, 0.1835797950700585, 0.18508313800518572, 0.19700706231070975, 0.18038823235341528, 0.17183312083710822, 0.18813026593918036, 0.08146036950361868, 0.07056942631957686, 0.07296644303193245, 0.07413996262582023, 0.08028476482041702, 0.07424611141135717, 0.08366411467467261, 0.06793321591489365, 0.07891388161194524]}, "mutation_prompt": null}
{"id": "2344369d-2abb-48b8-ac11-6531a9f9963f", "solution": "import numpy as np\n\nclass MESADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.memory_size = 100  # Increased memory size for more adaptive learning\n        self.memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Self-adaptive parameter control\n            if len(self.memory) > 0:\n                self.F = np.clip(np.mean([entry[0] for entry in self.memory]) + np.random.normal(0, 0.1), 0, 1)\n                self.Cr = np.clip(np.mean([entry[1] for entry in self.memory]) + np.random.normal(0, 0.1), 0, 1)\n            else:\n                self.F = np.random.rand()\n                self.Cr = np.random.rand()\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > self.memory_size:\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MESADE", "description": "A Memory-Enhanced Self-Adaptive Differential Evolution (MESADE) algorithm incorporates self-adaptive parameter control alongside memory mechanisms to dynamically fine-tune mutation and crossover strategies based on historical success.", "configspace": "", "generation": 5, "fitness": 0.21779929276234428, "feedback": "The algorithm MESADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.8116347429576662, 0.37595379475339397, 0.3187088573737663, 0.7969338324503193, 0.25176485078084443, 0.3031255242797922, 0.8015058339499869, 0.42879302179501966, 0.18698599224394885, 0.6192971102740232, 9.999999999998899e-05, 9.999999999998899e-05, 0.6212900877064235, 9.999999999998899e-05, 9.999999999998899e-05, 0.606276183277368, 9.999999999998899e-05, 9.999999999998899e-05, 0.2170702153953875, 0.15563398585228227, 0.15157455343036108, 0.3056424642696657, 0.11411927776976483, 0.10099634363218846, 0.21074999224669544, 0.18172913906283095, 0.15356008496524587, 0.1492936872014512, 0.06151455985771048, 0.09155385045370712, 0.15879814133099823, 0.09725455501034774, 0.08622020737867075, 0.23026904487952438, 0.1361842928754764, 0.08638301391852787, 0.876087588984167, 0.12322347689262658, 0.10318220243915655, 0.881268204628467, 0.11181524982912072, 0.2682674089185617, 0.834796080871368, 0.14917931924959138, 0.18092378366652284, 0.24950910148840177, 0.04964724995284309, 0.05847861972295609, 0.37567763145918287, 0.05375326690187343, 0.09202888065601422, 0.3216973925419445, 0.06171645198917208, 0.11396003371049368, 0.8350221159186485, 0.22659616463083077, 0.16455195757987562, 0.7984846387996967, 0.1687551469380243, 0.16168740416250327, 0.6472526641825462, 0.14244046473086636, 0.17809877322403023, 0.18013048581923996, 0.09506212717060392, 0.007845241225089006, 0.3235709497552478, 0.12572864794100647, 0.09526727864026308, 0.1700744580867567, 0.0455776695373441, 0.12819045634828508, 0.15454720897332952, 0.07009199940787458, 0.14802839985582594, 0.1905447843661059, 0.0052031540026453715, 0.04290854282908618, 0.19317628590970515, 0.05542350052209044, 0.06269790839528233, 0.4193517677009624, 9.999999999998899e-05, 9.999999999998899e-05, 0.48597523393903874, 9.999999999998899e-05, 9.999999999998899e-05, 0.325599297789237, 9.999999999998899e-05, 0.05586151554627139, 0.5350993188838866, 0.02487466542777861, 0.08079486339092767, 0.20242381789677177, 0.013584496653898936, 0.08522795558106588, 0.667365116480624, 0.05377254420570576, 0.05224422494484893, 0.07376447331685121, 9.999999999998899e-05, 9.999999999998899e-05, 0.2447487885807096, 0.07618770912767692, 9.999999999998899e-05, 0.17339364546887537, 9.999999999998899e-05, 9.999999999998899e-05, 0.28818982422927486, 0.05616720016076593, 0.010789137355705858, 0.3175958726771816, 0.057949100636027984, 0.09853118862991672, 0.30832460632417047, 0.25555262803484224, 0.047048736793745216, 0.713710853820123, 0.2826704787627978, 0.2683175309971847, 0.6834849676787405, 0.527211510159883, 0.2274164907542452, 0.7091892254605376, 0.21350468807732992, 0.2733346244997762, 0.13375687797085922, 0.04852413864341221, 0.08110179345987178, 0.13722629751000948, 0.0680121042447287, 0.10023212301430029, 0.1256183424960322, 0.040679019698881214, 0.0820020579545846, 0.14871881743975157, 0.09273829290061808, 0.1585246065488778, 0.16548751490387692, 0.23140652297986974, 0.1562591192490932, 0.14412894021506595, 0.18158165460783637, 0.23072027617968482, 0.4326392492985638, 0.18920819528748534, 0.2321684769714435, 0.4681055451935492, 0.17062307570552004, 0.2587299449482682, 0.4693355614098754, 0.2999731742751157, 0.208074817926441, 0.3387124528168741, 0.2327387725126936, 0.15379762934819596, 0.3558708390752988, 0.1201787918401489, 0.1307584755932214, 0.37192390431991773, 0.2953148746006373, 0.20192380584242164, 0.21168435869098035, 0.1735574601447708, 0.23604608095452118, 0.21742363750850335, 0.1756397540180109, 0.19509516293822216, 0.219327693042916, 0.18624320541119543, 0.1817532331372954, 0.2698583184682277, 0.27562829673553446, 0.20814431859433458, 0.20955824597979367, 0.20445215520614324, 0.20617783744763896, 0.3934899614284202, 0.18972021126766936, 0.17831818433874336, 0.7405461293094322, 0.12328684050752914, 0.33283268827234547, 0.17461020565576824, 0.18789967664349772, 0.1713037609701028, 0.7990987561087068, 0.16881424217870555, 0.16988287384777445, 0.7932212547217189, 0.18028705474308337, 0.48883636569676014, 0.20101420602468234, 0.17756766351660358, 0.11056415056603053, 0.20762053031300598, 0.15137609474184188, 0.245335835431008, 0.17658355683539084, 0.17704962192327645, 0.1790536633295149, 0.19889416078072686, 0.16903315590704804, 0.16863334232904903, 0.18335735353086557, 0.2120647975587483, 0.18099237642673793, 0.0942928021253936, 0.07027357828074077, 0.12687137221616995, 0.08292762533525033, 0.07501310296500507, 0.06898924817808039, 0.0817537428353724, 0.07976128068947141, 0.062244209658939176]}, "mutation_prompt": null}
{"id": "54d62abc-b219-4830-89ec-96a38500a3f4", "solution": "import numpy as np\n\nclass ESC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.reinit_prob = 0.1  # Probability to reinitialize an individual\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory]) * np.random.uniform(0.9, 1.1)\n                self.Cr = np.mean([entry[1] for entry in self.memory]) * np.random.uniform(0.9, 1.1)\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Random reinitialization\n                if np.random.rand() < self.reinit_prob:\n                    new_population[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    fitness[i] = func(new_population[i])\n                    eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ESC", "description": "Enhanced Stochastic Convergence (ESC) algorithm integrates random reinitialization and dynamic crossover adaptation to improve exploration and convergence balance.", "configspace": "", "generation": 6, "fitness": 0.21746425730688693, "feedback": "The algorithm ESC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.5479198494756103, 0.6480996352672812, 0.5994944054249447, 0.5853688928034304, 0.6180326355558211, 0.5741798019936457, 0.552888062394371, 0.6142243238726752, 0.5720588579967772, 0.26126187899313524, 0.33032122607999603, 0.24588901113466233, 0.22908274308268328, 0.293688296864136, 0.2685001110776175, 0.2556158579225024, 0.3151159325942363, 0.33816395863199344, 0.08267072722936353, 0.10792696257783141, 0.09472567566286338, 0.09950587671936828, 0.12996757129359227, 0.09285905106537407, 0.0837212095111095, 0.10640557475692203, 0.08502511235132537, 0.07901192557764058, 0.10834492003190355, 0.09856530068212654, 0.07901927496684891, 0.09979808959706438, 0.08201271152191825, 0.07683346624837795, 0.10561337937320203, 0.08502251146895046, 0.9171510960177611, 0.8931729173957254, 0.6987978071210199, 0.8848267093793387, 0.919546283873947, 0.6786645857436752, 0.8984968122355551, 0.9083748633160229, 0.8711520899952565, 0.16634736218253543, 0.17888014624332205, 0.24115291978360653, 0.1832498522751438, 0.15128240337441878, 0.246268615202496, 0.20624178083848432, 0.18362716337301488, 0.21269197712364663, 0.24110652380956044, 0.1952316298942035, 0.3840436843621584, 0.26105000615712415, 0.1944169732137383, 0.5766974930211748, 0.2510783637977304, 0.17738471514048892, 0.7227721264718554, 0.10108326193853612, 0.12501900003401356, 0.2275769762799894, 0.13943006361814625, 0.12264240960095196, 0.22154616579942876, 0.12292489393004147, 0.13736436027765409, 0.23027525941937388, 0.1295915520477794, 0.04168588046909427, 0.18593931497480654, 0.1358637135416666, 0.12729470545481236, 0.17577083700838758, 0.10752214152704398, 0.0986216667798524, 0.2152370688067341, 0.0009055653990348578, 9.999999999998899e-05, 0.14915185424378852, 0.06938732616686227, 9.999999999998899e-05, 0.1723586234726614, 0.0006095295785740751, 9.999999999998899e-05, 0.18099898017280958, 0.08022847536499977, 0.06784856883954493, 0.3317759208996074, 0.26344139195906446, 0.05141914969013195, 0.2572071320432746, 0.0939029323340963, 0.04500588142928941, 0.3319857072739656, 9.999999999998899e-05, 9.999999999998899e-05, 0.07026625664410147, 9.999999999998899e-05, 9.999999999998899e-05, 0.11241204642928604, 9.999999999998899e-05, 9.999999999998899e-05, 0.0308856818343618, 0.07080860789617449, 0.06718182290976205, 0.15930753907189754, 0.06661513541916264, 0.053587126873332114, 0.17024475849288756, 0.05859892133619138, 0.04931852321358676, 0.18698628978074183, 0.3863613451403993, 0.39239481131403997, 0.49384105164587244, 0.3993222233432703, 0.41254047869628485, 0.5092935919273112, 0.3975209260794551, 0.3999657401520377, 0.48606485699229807, 0.08784672801263405, 0.07487423324032239, 0.0852340260651745, 0.07950599861900354, 0.08061798852005009, 0.09587554103075091, 0.07779075721751083, 0.07559599270631856, 0.08524055636542638, 0.1557468528236131, 0.12485081863142955, 0.14795067840667164, 0.12021074001099008, 0.18625125843776813, 0.15107163362873288, 0.12455642896819175, 0.13423022446892774, 0.13732241651461496, 0.23727921822532227, 0.24013493419647303, 0.30353081136786575, 0.22246742057100077, 0.2261296633822547, 0.2874145548818515, 0.2582283076293258, 0.2786701260671065, 0.26537037098018834, 0.1822427953781306, 0.16629399062246497, 0.19092710206686547, 0.15429896232203677, 0.1455303127721016, 0.22117475126953978, 0.18848865235499068, 0.19515284760951257, 0.21286626413498655, 0.19622012349398232, 0.1769471057051908, 0.2063670253202975, 0.17965686104491574, 0.18334526814080043, 0.18859545879795991, 0.17085700683635952, 0.18839248990480428, 0.1951843469645712, 0.17936880625656582, 0.1879859890226223, 0.1683849099939957, 0.17744471207744206, 0.18127809256006577, 0.17730843409372832, 0.17576232365544275, 0.19753220097368307, 0.17812413844819475, 0.15263663693090435, 0.18555122081816589, 0.3466723383954212, 0.16856608052758038, 0.2521253537447403, 0.17052579864416817, 0.1577407401545684, 0.19458995990650696, 0.1954275242432435, 0.27525744959161424, 0.156815062924063, 0.19048446181123058, 0.1635887458267884, 0.158478756347457, 0.23549043408661818, 0.2041580768008695, 0.22535083584617588, 0.2047098361201215, 0.18092802337592961, 0.18625015367031106, 0.19314899380738504, 0.18607540919394483, 0.18485013205604395, 0.1787963587906899, 0.19493837673658077, 0.19484144598599917, 0.18680434759984532, 0.07179614225923814, 0.07086826388012357, 0.06057908391250366, 0.07357741493524739, 0.07238692946122993, 0.07387041129576066, 0.06500267688579531, 0.06683364062188646, 0.07615743959527044]}, "mutation_prompt": null}
{"id": "6e4ed66a-2604-436d-b11d-a304cc1261b4", "solution": "import numpy as np\n\nclass MADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MADE", "description": "A Memory-Enhanced Adaptive Differential Evolution (MADE) algorithm combines differential evolution with adaptive mutation strategies and a memory mechanism to dynamically adjust strategies based on past performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7682514559171263, 0.7600569239394717, 0.7636466400645218, 0.7671130477310657, 0.7903514481991641, 0.7698013354620454, 0.7783020555132691, 0.790128072452183, 0.7725187976041927, 0.6070142561843653, 0.5999766406812317, 0.5930099218524881, 0.609165449710199, 0.5986266298359444, 0.5933003434821107, 0.6033410541785547, 0.5916098030647285, 0.6125672881831984, 0.11765755949175039, 0.13764649380087812, 0.10754787854158998, 0.11041475356892316, 0.12793253089688805, 0.11186811498992377, 0.11773515236663612, 0.1268426449185126, 0.10712749750129191, 0.11010807657988642, 0.10353425203005373, 0.10618315082661012, 0.09516264772335858, 0.10244872689336515, 0.10410660466004229, 0.10886741672597577, 0.1065638383619888, 0.10566866554008392, 0.843387462913374, 0.9318153667770599, 0.9028707220583045, 0.833671880929729, 0.8953041935846743, 0.7751276813997141, 0.8337610872159981, 0.9266829117991846, 0.9174362807125387, 0.4562292454741471, 0.46304418336731534, 0.40688519607119134, 0.36776747785100805, 0.41949839152693924, 0.42128520410524795, 0.44741521780700877, 0.4171351961370585, 0.41082050235208634, 0.7696242456416582, 0.7394768409738849, 0.7498063378668416, 0.7637263916342989, 0.7293935812495511, 0.7531314203704407, 0.7493579042710876, 0.7583082771128605, 0.7755397563786, 0.20323817305490854, 0.25233930919685954, 0.3119664004767315, 0.18126442682195, 0.2330154701635786, 0.15850898877356268, 0.2633561439527775, 0.19986847384059947, 0.25585762486516983, 0.12945569201743745, 0.30365124613915795, 0.2527874282555711, 0.24221055941297231, 0.18276529011579412, 0.23630155683960863, 0.21087936699393495, 0.17735612606551132, 0.17619480867540238, 0.35649562791729505, 0.36364099539790484, 0.3516950186031409, 0.36357128419417706, 0.4019782097458269, 0.35684144628021264, 0.35057972353925726, 0.36521981059608666, 0.3908636554648567, 0.4699731528077583, 0.5264963824892643, 0.5139566136682838, 0.5177661720789491, 0.49858608316856157, 0.5230836675100352, 0.530573111650668, 0.5428474131084177, 0.5224494378890268, 0.09185074423997175, 0.11101280167946659, 0.16013991892928703, 0.1331751162058168, 0.21968972505527107, 0.27175874494461794, 0.14362090000517969, 0.19067936451354006, 0.1904920167866193, 0.29676896683826437, 0.2740721746581428, 0.2984817041631156, 0.3111043223219291, 0.2988481478177829, 0.3075155621110415, 0.3093955612127943, 0.3015167940390755, 0.31474025111636605, 0.6873365961767945, 0.670295165150394, 0.6964220136085257, 0.6847736314023929, 0.6696602828918757, 0.6877950945271007, 0.6793435945045185, 0.6687848211330003, 0.7066041693552487, 0.0951133787332159, 0.09941361368856072, 0.10023326398095611, 0.11449028470234279, 0.0960646971880662, 0.11200560661954495, 0.09253293754180691, 0.09786519987934517, 0.1019393142244518, 0.1351654912966178, 0.14031334394462758, 0.13790709755623343, 0.14503245091636585, 0.19563849096779762, 0.14763153587201172, 0.16759510705845604, 0.12584116070581564, 0.12811159688156937, 0.41476751248425703, 0.3867939582226131, 0.43667067940871784, 0.3893126873665629, 0.3874100936633277, 0.39749426549979705, 0.4002765883584455, 0.39651710476619406, 0.39531639984436207, 0.28988170382182266, 0.32509227190029, 0.329165856869472, 0.3099028251603716, 0.28695955335921697, 0.3239306586481122, 0.3574828649862468, 0.32641965323458744, 0.34686477466077803, 0.1993764788145811, 0.1796048275216382, 0.1839126056756133, 0.18336399034042472, 0.19876449768764015, 0.19616669801279008, 0.17224169109791543, 0.19108975961282915, 0.213520491208937, 0.44470633739978327, 0.23698288028737857, 0.1924479996011056, 0.19231799608915, 0.187759898605242, 0.18432290924299133, 0.19550269983769064, 0.19404719121219516, 0.2066630403504417, 0.7151219584718407, 0.6647251113681625, 0.17752954850982228, 0.732719776953036, 0.6930154034812326, 0.7604333097297, 0.6809846423271633, 0.6613829862696836, 0.48242159398900486, 0.6067629645337731, 0.20501842371603707, 0.7024397961139044, 0.5557044687646955, 0.19680264144190718, 0.20039762171316655, 0.20484166596415998, 0.6926483855966181, 0.20997647839541334, 0.18674682884606653, 0.18939125143027136, 0.18923422321395245, 0.19651006379909353, 0.18099086880525084, 0.18394216934907404, 0.18994090430746513, 0.1787039000899846, 0.23350007951757212, 0.0966824927280262, 0.08057947651813269, 0.07621410621555735, 0.07316557039156413, 0.07585839128582739, 0.07550947938882635, 0.07504783358507572, 0.08005832775687927, 0.08442500023025823]}, "mutation_prompt": null}
{"id": "0e1f9852-448e-4f11-8dc4-2dd0fceea6fe", "solution": "import numpy as np\n\nclass EnhancedMADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.scaling_factor_range = (0.4, 0.9)  # Updated differential weight range\n        self.crossover_prob_range = (0.1, 0.9)  # Updated crossover probability range\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Self-adaptive mutation strategy\n            if len(self.memory) > 0:\n                self.F = np.clip(np.mean([entry[0] for entry in self.memory]) + np.random.normal(0, 0.1), *self.scaling_factor_range)\n                self.Cr = np.clip(np.mean([entry[1] for entry in self.memory]) + np.random.normal(0, 0.1), *self.crossover_prob_range)\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover with more dynamic crossover probability\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EnhancedMADE", "description": "An enhanced version of MADE with self-adaptive differential weight and crossover probability mechanisms to improve convergence.", "configspace": "", "generation": 8, "fitness": 0.31938587158699355, "feedback": "The algorithm EnhancedMADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7120207169718387, 0.7378974723465559, 0.7633071547624891, 0.7120835020938994, 0.7540185970650418, 0.7737061565019236, 0.7408883609833481, 0.764583446898194, 0.781656512032587, 0.5388634986914765, 0.5222783641126453, 0.5583147575710964, 0.48941386348841975, 0.49794454162454016, 0.5701687656213454, 0.4829492937465809, 0.5147476222104592, 0.5714609094619946, 0.2746998839597672, 0.19216743481566767, 0.18916453655496712, 0.30591892679182997, 0.2921173034094928, 0.19775996053741973, 0.2547977244550098, 0.26537886887839834, 0.1546512267247555, 0.19714715683349326, 0.1857271280494619, 0.14622019932303942, 0.1904988478819597, 0.14642144983776673, 0.1565898564601259, 0.1805672197225653, 0.2262470735591714, 0.1442281350346588, 0.9170471853372679, 0.9227306659757066, 0.9333739132425072, 0.9376941587916638, 0.9503658268237891, 0.8769846693457805, 0.9448393043625252, 0.9321160389202845, 0.9372195225965702, 0.3228678005087383, 0.27879831086877616, 0.30895810537666, 0.3280858719496872, 0.3129583925341368, 0.3450199270452752, 0.3299314295742748, 0.29713152223284756, 0.36588650457895067, 0.527369269490455, 0.6593968705744508, 0.7209196801522458, 0.6678524590046659, 0.5037874775065851, 0.7653518284913158, 0.6302760734321373, 0.6594520864446469, 0.7050206731810538, 0.1745152910310822, 0.14013538549543614, 0.2507977056667542, 0.167034551317361, 0.20534373943918427, 0.16689388153575202, 0.167505599284838, 0.1465274733818216, 0.22518336447713216, 0.14306645806197626, 0.16690107455423764, 0.24195149800926863, 0.18507423297270098, 0.1939295331963633, 0.14131052845560266, 0.15658410577813064, 0.17742452107405515, 0.20435068921541055, 0.1507563199674936, 0.21882485145367925, 0.28053924507455863, 0.18016591611734167, 0.2042648253604682, 0.2589008904241006, 0.19943572129279308, 0.21056149512447309, 0.2593124228646857, 0.3168615579904298, 0.3665780792079215, 0.3491192308890896, 0.3356665679423724, 0.35885455700334956, 0.40326487024233504, 0.3458901483773067, 0.3830876451236671, 0.3810850885819218, 0.03927634164180194, 0.08666724388186908, 0.11566701239107602, 0.015569925596707224, 0.04545498275216375, 0.09548309443221659, 0.04520440949903681, 0.04299763124724609, 0.11522144006464785, 0.16908528509494047, 0.17746445378611175, 0.2400338574812999, 0.19457602813849362, 0.13128854425654357, 0.25003192408294395, 0.17129014555360078, 0.18530878745659263, 0.23015439373149515, 0.4731453798443589, 0.5587951206515749, 0.6203689117810833, 0.5470999377830148, 0.5390147013580275, 0.5845506124913554, 0.4651995363167354, 0.5105074961464846, 0.6226710504741197, 0.09229498926662583, 0.11543635767272131, 0.11659638226985158, 0.09314179404875345, 0.11134244508752067, 0.09436406054218438, 0.0923787568622294, 0.09736154585604728, 0.10062651670752387, 0.2088058543209973, 0.13672611247571897, 0.1374505041209897, 0.15997141606831033, 0.17841554154029549, 0.15330245867866, 0.14230177116402754, 0.16148981742651558, 0.1391950995500214, 0.3279334159999615, 0.3263529225094046, 0.3454823715297103, 0.30340119287844514, 0.321815551957917, 0.35974807541235243, 0.33166109020158185, 0.35051629487020064, 0.4037223325629229, 0.24698840246046805, 0.25730974026637765, 0.2736491659256235, 0.2185614052784305, 0.24332085285431682, 0.28578951154875165, 0.25356457473969385, 0.24816918103074892, 0.29467407507710996, 0.18910946805213835, 0.18300760048367448, 0.19403691250062727, 0.21343348042024612, 0.19434084726724843, 0.18630208911712887, 0.18997349737019908, 0.19593960271579436, 0.22392703451664597, 0.22836033273592993, 0.2242362625395815, 0.20660072152177522, 0.19935729199705243, 0.21945380539879356, 0.2100088939554261, 0.21138553484888511, 0.22644431511391527, 0.20584899022265613, 0.5297635326744452, 0.5286275893261507, 0.19848286490188705, 0.4904141084349565, 0.5006506131628667, 0.18693807951526153, 0.4104883780433902, 0.5400674125627991, 0.6012581016461278, 0.18956732473757865, 0.19540591373097504, 0.44025046575223137, 0.18418215587698528, 0.5141641602325342, 0.6556839684924052, 0.20491790939632637, 0.5844289473242474, 0.20985625213905945, 0.19483610290571862, 0.195869115696234, 0.18636209083590716, 0.17332554605119144, 0.18055787543725133, 0.17551936223140185, 0.18946210065134073, 0.1770421400582871, 0.19584782626136332, 0.07486043134620946, 0.07812489050493643, 0.07933656422930979, 0.0821055598726107, 0.07854570683203987, 0.07784623050002992, 0.08541000796538878, 0.08706717582642465, 0.08658414481638299]}, "mutation_prompt": null}
{"id": "46dddb8c-536e-4840-8157-40495700b2fb", "solution": "import numpy as np\n\nclass EMADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.success_rate_memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive strategy selection based on memory\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n                success_rate = np.mean(self.success_rate_memory) if self.success_rate_memory else 0.5\n                self.pop_size = max(4, int(10 * self.dim * success_rate))  # Dynamic population size\n\n            new_population = np.copy(population)\n            success_count = 0\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover control\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    success_count += 1\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            self.success_rate_memory.append(success_count / self.pop_size if self.pop_size else 0)\n            if len(self.success_rate_memory) > 50:  # Maintain limited success rate memory size\n                self.success_rate_memory.pop(0)\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EMADE", "description": "Enhanced Memory-Driven Adaptive Differential Evolution (EMADE) introduces adaptive crossover control and dynamic population resizing based on historical success rates to improve convergence efficiency.", "configspace": "", "generation": 9, "fitness": 0.3031850119565487, "feedback": "The algorithm EMADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.9072463505100721, 0.9116261912074315, 0.903883051522897, 0.9047682163873788, 0.9010021109668557, 0.910969648460582, 0.9098970204079825, 0.9090579841394826, 0.8938311540288557, 0.8322776272441962, 0.7937999325453715, 0.8456036437212386, 0.8271728724429864, 0.8436082002478494, 0.8528973863026029, 0.835392350799242, 0.8012796604905497, 0.8541792130594964, 0.11790813925951371, 0.11925894296438144, 0.8803389718530932, 0.0894158239640479, 0.1871432264395524, 0.18343035784877937, 0.16112699699673572, 0.12646581346908203, 0.0895675573829654, 0.12624637752992351, 0.0629802638848922, 0.09849577228780215, 0.1356561992353732, 0.08359016049242363, 0.10830786053535668, 0.1016754142953269, 0.15661528193364016, 0.09432731210851741, 0.9312594157056739, 0.9013531857621697, 0.9148933764642571, 0.9349665104091613, 0.9197774206030142, 0.8880166441571455, 0.9189055904038331, 0.8899843560538454, 0.9187626944323881, 0.1291101293169189, 0.17163355173025607, 0.5104407660595649, 0.21329231362283296, 0.4475394984966592, 0.14381967995537692, 0.21444117682447994, 0.1857489758119366, 0.22968841658072148, 0.3840562697581077, 0.36643539277126547, 0.2282363350886495, 0.27732982336047407, 0.9355789502171854, 0.9173870459452346, 0.36193041470299325, 0.2883112210898672, 0.3442204585351071, 0.13426122757461512, 0.13008021622137278, 0.14036697917080476, 0.1701984067583462, 0.2730466499931784, 0.13572740886549817, 0.16664140176015085, 0.1394605191790499, 0.1452003202708846, 0.12971000722244952, 0.22375149196156174, 0.16466657778445137, 0.14085799093236506, 0.1529927232036985, 0.19973107329012496, 0.16443033087833825, 0.14097607435068626, 0.16795547964785051, 0.05351212761726598, 0.4873650624406146, 0.0773638705641535, 9.999999999998899e-05, 0.1022648433835901, 0.010579840159993026, 0.04589157234042396, 0.16468957951186491, 0.05492101718645681, 0.10987140184888122, 0.13011242570999493, 0.09673138068129905, 0.09216085185788958, 0.08477796474643506, 0.10859029859284841, 0.1281433705653724, 0.1855906709042311, 0.22291354217375603, 0.17260073251864927, 0.07609605499750927, 0.18814263244419716, 0.16576331053627513, 0.16799576727489474, 0.1509573064560673, 0.3553767985466142, 0.199670186676163, 0.14829001790165497, 0.26346037648124854, 0.3516460908507475, 0.3707070726976237, 0.270191505082802, 0.2479000306344964, 0.28111465694809323, 0.276443832568965, 0.17326424744095326, 0.21641555348113695, 0.5450724373772338, 0.6983236489584159, 0.5726783526348385, 0.559492124197557, 0.5970319667040747, 0.5337015246381753, 0.47280477387224584, 0.5891809175662905, 0.623079214413577, 0.11582135991013143, 0.14327001165775133, 0.07792785740386132, 0.10454081047811237, 0.08613771883635835, 0.08422259574832536, 0.10526727903112332, 0.08249567362762322, 0.1305341849380186, 0.0999483368119074, 0.13173034710503584, 0.17004582339381247, 0.1144487564736113, 0.11538895157126494, 0.16393079355789597, 0.15585776695268416, 0.1494604026815588, 0.17856720916115987, 0.34430211567781754, 0.36074399233957644, 0.3530880078349302, 0.204824367347463, 0.30761194100985956, 0.2606635235860596, 0.35938274154990135, 0.3092346426144026, 0.3115808212170834, 0.33904351221192586, 0.3266486620912825, 0.29824269177051244, 0.23568172443166246, 0.23727267984761158, 0.2732841562189242, 0.39087911096937367, 0.2617222808832992, 0.2366500775961603, 0.16421499867545686, 0.17492940517248756, 0.17986012672187712, 0.17042620207595394, 0.1863462528650518, 0.2526965781364858, 0.20547628054412048, 0.20855003504890723, 0.1897261409742489, 0.2293114147471924, 0.18896259951017103, 0.2501893379507909, 0.20737345131333507, 0.19501657947418427, 0.17452086537919753, 0.21119685934600374, 0.23504804617761188, 0.20023142523857673, 0.20907577738527539, 0.182189545952246, 0.1508540572058188, 0.20012485944726655, 0.43151735640404154, 0.19757131807222705, 0.18464492349313755, 0.183023609288117, 0.1671057148299715, 0.20913870649665833, 0.1695830534824625, 0.7470630330429788, 0.37291775139986616, 0.21138768990993917, 0.39378999458245467, 0.11819197979490381, 0.16548750251618916, 0.258872357075139, 0.1712798559912102, 0.17731377577339658, 0.16840874299518838, 0.1874243433897872, 0.15349271309412726, 0.18308102761065492, 0.17763613131738332, 0.1761381690628785, 0.1857564181499316, 0.06795366325831276, 0.06430864152502869, 0.0771126493021822, 0.07911669117053077, 0.06925537976128704, 0.06570646035465633, 0.06805760190483001, 0.08110760279527862, 0.0665454228128256]}, "mutation_prompt": null}
{"id": "e891e768-03a5-4803-86dd-75a26b41a9fb", "solution": "import numpy as np\n\nclass MADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MADE", "description": "A Memory-Enhanced Adaptive Differential Evolution (MADE) algorithm combines differential evolution with adaptive mutation strategies and a memory mechanism to dynamically adjust strategies based on past performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7682514559171263, 0.7600569239394717, 0.7636466400645218, 0.7671130477310657, 0.7903514481991641, 0.7698013354620454, 0.7783020555132691, 0.790128072452183, 0.7725187976041927, 0.6070142561843653, 0.5999766406812317, 0.5930099218524881, 0.609165449710199, 0.5986266298359444, 0.5933003434821107, 0.6033410541785547, 0.5916098030647285, 0.6125672881831984, 0.11765755949175039, 0.13764649380087812, 0.10754787854158998, 0.11041475356892316, 0.12793253089688805, 0.11186811498992377, 0.11773515236663612, 0.1268426449185126, 0.10712749750129191, 0.11010807657988642, 0.10353425203005373, 0.10618315082661012, 0.09516264772335858, 0.10244872689336515, 0.10410660466004229, 0.10886741672597577, 0.1065638383619888, 0.10566866554008392, 0.843387462913374, 0.9318153667770599, 0.9028707220583045, 0.833671880929729, 0.8953041935846743, 0.7751276813997141, 0.8337610872159981, 0.9266829117991846, 0.9174362807125387, 0.4562292454741471, 0.46304418336731534, 0.40688519607119134, 0.36776747785100805, 0.41949839152693924, 0.42128520410524795, 0.44741521780700877, 0.4171351961370585, 0.41082050235208634, 0.7696242456416582, 0.7394768409738849, 0.7498063378668416, 0.7637263916342989, 0.7293935812495511, 0.7531314203704407, 0.7493579042710876, 0.7583082771128605, 0.7755397563786, 0.20323817305490854, 0.25233930919685954, 0.3119664004767315, 0.18126442682195, 0.2330154701635786, 0.15850898877356268, 0.2633561439527775, 0.19986847384059947, 0.25585762486516983, 0.12945569201743745, 0.30365124613915795, 0.2527874282555711, 0.24221055941297231, 0.18276529011579412, 0.23630155683960863, 0.21087936699393495, 0.17735612606551132, 0.17619480867540238, 0.35649562791729505, 0.36364099539790484, 0.3516950186031409, 0.36357128419417706, 0.4019782097458269, 0.35684144628021264, 0.35057972353925726, 0.36521981059608666, 0.3908636554648567, 0.4699731528077583, 0.5264963824892643, 0.5139566136682838, 0.5177661720789491, 0.49858608316856157, 0.5230836675100352, 0.530573111650668, 0.5428474131084177, 0.5224494378890268, 0.09185074423997175, 0.11101280167946659, 0.16013991892928703, 0.1331751162058168, 0.21968972505527107, 0.27175874494461794, 0.14362090000517969, 0.19067936451354006, 0.1904920167866193, 0.29676896683826437, 0.2740721746581428, 0.2984817041631156, 0.3111043223219291, 0.2988481478177829, 0.3075155621110415, 0.3093955612127943, 0.3015167940390755, 0.31474025111636605, 0.6873365961767945, 0.670295165150394, 0.6964220136085257, 0.6847736314023929, 0.6696602828918757, 0.6877950945271007, 0.6793435945045185, 0.6687848211330003, 0.7066041693552487, 0.0951133787332159, 0.09941361368856072, 0.10023326398095611, 0.11449028470234279, 0.0960646971880662, 0.11200560661954495, 0.09253293754180691, 0.09786519987934517, 0.1019393142244518, 0.1351654912966178, 0.14031334394462758, 0.13790709755623343, 0.14503245091636585, 0.19563849096779762, 0.14763153587201172, 0.16759510705845604, 0.12584116070581564, 0.12811159688156937, 0.41476751248425703, 0.3867939582226131, 0.43667067940871784, 0.3893126873665629, 0.3874100936633277, 0.39749426549979705, 0.4002765883584455, 0.39651710476619406, 0.39531639984436207, 0.28988170382182266, 0.32509227190029, 0.329165856869472, 0.3099028251603716, 0.28695955335921697, 0.3239306586481122, 0.3574828649862468, 0.32641965323458744, 0.34686477466077803, 0.1993764788145811, 0.1796048275216382, 0.1839126056756133, 0.18336399034042472, 0.19876449768764015, 0.19616669801279008, 0.17224169109791543, 0.19108975961282915, 0.213520491208937, 0.44470633739978327, 0.23698288028737857, 0.1924479996011056, 0.19231799608915, 0.187759898605242, 0.18432290924299133, 0.19550269983769064, 0.19404719121219516, 0.2066630403504417, 0.7151219584718407, 0.6647251113681625, 0.17752954850982228, 0.732719776953036, 0.6930154034812326, 0.7604333097297, 0.6809846423271633, 0.6613829862696836, 0.48242159398900486, 0.6067629645337731, 0.20501842371603707, 0.7024397961139044, 0.5557044687646955, 0.19680264144190718, 0.20039762171316655, 0.20484166596415998, 0.6926483855966181, 0.20997647839541334, 0.18674682884606653, 0.18939125143027136, 0.18923422321395245, 0.19651006379909353, 0.18099086880525084, 0.18394216934907404, 0.18994090430746513, 0.1787039000899846, 0.23350007951757212, 0.0966824927280262, 0.08057947651813269, 0.07621410621555735, 0.07316557039156413, 0.07585839128582739, 0.07550947938882635, 0.07504783358507572, 0.08005832775687927, 0.08442500023025823]}, "mutation_prompt": null}
{"id": "c57609a4-2b21-4ebe-b8e1-bb2faf9c43bb", "solution": "import numpy as np\n\nclass MADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 15 * dim  # Increased population size\n        self.F = 0.5\n        self.Cr = 0.9\n        self.memory = []\n        self.adaptive_memory_size = 100  # Adaptive memory size\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive parameter adjustment\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory]) + np.random.normal(0, 0.1)\n                self.Cr = np.mean([entry[1] for entry in self.memory]) + np.random.normal(0, 0.1)\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation with dynamic scaling factor\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_dynamic = self.F * (1 + np.random.uniform(-0.1, 0.1))\n                mutant = np.clip(x1 + F_dynamic * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((F_dynamic, self.Cr))\n                    if len(self.memory) > self.adaptive_memory_size:\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MADE", "description": "An Enhanced Memory-Adapted Differential Evolution algorithm with adaptive parameter adjustment and a self-adaptive population scaling factor.", "configspace": "", "generation": 11, "fitness": 0.2872992398151816, "feedback": "The algorithm MADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.6919759665821217, 0.7096234640202366, 0.562334978829818, 0.6499614521604742, 0.7131263474311922, 0.5057078142380229, 0.6760382785398346, 0.7194851206430042, 0.611768324372957, 0.45265796149346726, 0.4670304359784687, 0.32755416984721164, 0.4169187544969656, 0.4603911562984142, 0.32979952848904615, 0.3671990973340792, 0.4371969655038428, 0.2887455758589691, 0.17628340983052837, 0.39528807933303656, 0.17157972965332868, 0.16581274506850152, 0.40717719243590367, 0.12155945078717867, 0.1204071945875399, 0.3633494779961711, 0.14808947125690153, 0.10534496328844944, 0.2929185501136736, 0.16119742092181333, 0.1127702048207011, 0.3164460091132777, 0.1357926761143935, 0.11975051680176108, 0.3108808727974023, 0.11179233396881139, 0.9110330789208647, 0.8978397731626432, 0.8310079069419322, 0.9383045984369995, 0.8935407608119728, 0.9049900793240641, 0.903246078127912, 0.9283729060965165, 0.9156828773064392, 0.22980694749505326, 0.21193501137714876, 0.13858268775471883, 0.1931134357927835, 0.15772221969569977, 0.13386706373471025, 0.25496063880585274, 0.15972944149670332, 0.18815080064569878, 0.6774125699639413, 0.6005263917175093, 0.7207668923995096, 0.6192625082399816, 0.6509448551483186, 0.7332962573446655, 0.6155131315123776, 0.5896175404297122, 0.6902853932029054, 0.1619231056557423, 0.16743829509186803, 0.2023236435272806, 0.15061609756471683, 0.14356700236051434, 0.16762070927682104, 0.16719977753111392, 0.1800229294735134, 0.15281152436660572, 0.17517954608065556, 0.17140049673095947, 0.2022250408252585, 0.1723739177429614, 0.15271498193152144, 0.15749768575057588, 0.1502473390607023, 0.1381983282187923, 0.12894781366346197, 0.2560357589674571, 0.14485994520875245, 0.09748825335063993, 0.15576389896355303, 0.049674723281359134, 0.2560413869898742, 0.17473807131142238, 0.053029818036587906, 0.22779233009603883, 0.31687606760133236, 0.19847254743468346, 0.4048009623121076, 0.27698258552811206, 0.1947147830446182, 0.32262419280129906, 0.29098620184058843, 0.16483432676601917, 0.36676002654040096, 0.026431922067948865, 0.046172071435076956, 0.09157424170760409, 0.00017790263979566845, 0.07959718646906677, 0.10832587670496141, 0.12397097488029363, 0.054169468651631525, 0.05524465920225141, 0.15402089241211503, 0.1328293298184804, 0.18426512695538, 0.18904125892091383, 0.15500878759680858, 0.18415984719414868, 0.15667237754478758, 0.13023580690912295, 0.20363564642315835, 0.49134878865664666, 0.4449747462645034, 0.4992638662198291, 0.5103061475740587, 0.46896372928397456, 0.5456506877615479, 0.513404288195834, 0.44224765643410713, 0.5399435194556177, 0.07809054131241233, 0.10971443403268, 0.09730203227109091, 0.08839651600977871, 0.1015801878961885, 0.11868893861306473, 0.10963952367011354, 0.12015548629321016, 0.10745972629876976, 0.13904109667238118, 0.15951300458452367, 0.12708084518137652, 0.14354267991041192, 0.13842972431526557, 0.1561065275944291, 0.16202311106713674, 0.14895722782423093, 0.157536495669939, 0.30308440185970587, 0.3194635185435887, 0.3364677726017071, 0.34019113439068127, 0.30867855243968145, 0.34964823986601934, 0.3404771937985509, 0.3336156870439708, 0.3371707296898495, 0.24211356471592071, 0.24458499112502208, 0.2910844556735215, 0.26532854650783333, 0.24215079075129897, 0.2862183743317298, 0.2671558815781405, 0.2546822787817564, 0.24310526759291384, 0.20521056106663838, 0.2109806823809779, 0.21924057914866935, 0.17730566734272457, 0.192097033800264, 0.20738461465324665, 0.20847033153165295, 0.21007124917071496, 0.18720179033875395, 0.24995188370944976, 0.2150374792787556, 0.28111801503996936, 0.185512433155393, 0.4140504925690558, 0.23572479905181598, 0.21300005191694615, 0.22131789612188368, 0.21064934916904776, 0.6231070288678252, 0.1904703438472457, 0.17503219109665935, 0.4144879359264986, 0.5796147375394753, 0.4765347774809213, 0.34589168948268056, 0.5897125253464564, 0.3507741808612558, 0.266510618545692, 0.255366260471416, 0.2575070782645196, 0.18844463802184697, 0.16445542120040224, 0.18658537983796608, 0.2035647969389347, 0.3584711275061978, 0.19905498173613556, 0.17941550105205684, 0.1861926322427886, 0.19294885054504063, 0.17223010682904916, 0.16736758648503602, 0.1806944983983627, 0.18645898645779624, 0.20161523518224134, 0.18912688679512202, 0.07715800704803966, 0.07578699033010416, 0.08621298014812495, 0.0768733914693488, 0.07851520502744203, 0.08460049506635203, 0.07878423967868076, 0.07748664900576163, 0.08688899618917933]}, "mutation_prompt": null}
{"id": "11e89823-f38a-4c10-bbd7-d6fa6702d523", "solution": "import numpy as np\n\nclass MADE_DP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection and diversity check\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n                elif np.linalg.norm(trial - population[i]) > self.diversity_threshold:\n                    # Diversity preservation: accept worse solutions if they are diverse\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MADE_DP", "description": "A Memory-Enhanced Adaptive Differential Evolution with Diversity Preservation (MADE-DP) algorithm enhances MADE by introducing a diversity preservation mechanism to maintain solution diversity and avoid premature convergence.", "configspace": "", "generation": 12, "fitness": 0.09224477019677968, "feedback": "The algorithm MADE_DP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.18467459549812204, 0.19037772494584648, 0.14418145499093138, 0.14269789061136084, 0.1508671327146789, 0.14604162859723402, 0.1603875884364897, 0.14492470241432875, 0.16421028999938447, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01191921762553061, 9.999999999998899e-05, 9.999999999998899e-05, 0.04378067897887561, 0.032489754582662456, 0.030837183324066042, 0.049000279906630695, 0.03925363577910068, 0.03366352718624199, 0.05702706972365523, 0.04180259393946528, 0.03404414412493528, 0.032139086046741205, 0.019244137196787192, 0.021840624156639787, 0.01959972157639278, 0.021926687839267656, 0.027862759200173448, 0.022033357999983627, 0.02608834934669846, 0.03140689449215206, 0.887521483235238, 0.14714339795580378, 0.16435902099961675, 0.5680512429542468, 0.18345592292153468, 0.12484282393763713, 0.1606309614770649, 0.24307978834078392, 0.14463883265564637, 0.06416721719037721, 0.08843621122195855, 0.08205683328183555, 0.0846473101408376, 0.04014086800851169, 0.06371543915239164, 0.07574649632086217, 0.09606892710314074, 0.06631809363513419, 0.10292428540221266, 0.10499788446069847, 0.1610206849922775, 0.13857449561745894, 0.1096967053787764, 0.12429092816054432, 0.1331308688898145, 0.0948496491501426, 0.13892048962100156, 9.999999999998899e-05, 0.0005551818157356614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031002315272662728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005645548693267277, 9.999999999998899e-05, 0.005374962579716924, 0.010972202712158485, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03337901841765323, 0.021573878810168035, 0.043887352033459504, 0.04061720200848762, 0.057638702372455386, 0.06133003679110349, 0.0359699621494598, 0.05289472887676039, 0.030825034306433685, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005970110039750787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17383988059227762, 0.16249843859140678, 0.20782423025606644, 0.17154493895453138, 0.17579620643813687, 0.18555367636332798, 0.18581402803023395, 0.1777972521772011, 0.17020740490160047, 0.029614153043306723, 0.03410163123033594, 0.04767288266742775, 0.034620072731970875, 0.031619013191181655, 0.05459348729037161, 0.03121505167921046, 0.027673353527334466, 0.033267237410354755, 0.16943669954935447, 0.14427250474072095, 0.13112891625398793, 0.12722850894266102, 0.13403319674342784, 0.14472140903944042, 0.13792796248688666, 0.13530754283166646, 0.15278926364026302, 0.1686803665536527, 0.14557510164732723, 0.1613932299901244, 0.1517707474524439, 0.1494040464797598, 0.1530261415078672, 0.1407224796952511, 0.17643666335045183, 0.15987134746342413, 0.12297800830522776, 0.10059931890762142, 0.10436711488649963, 0.09591420292609276, 0.09798889824836066, 0.10305357570982066, 0.08984763546884966, 0.10401320803679881, 0.11059665486343206, 0.16994194372005478, 0.1475980217626811, 0.14596309144576913, 0.1475571493059259, 0.13910851085923748, 0.14325811240421993, 0.14464888327430236, 0.1298560280867752, 0.13839758588299667, 0.14583080087620015, 0.13291925566761875, 0.16230273232127423, 0.13551814172452692, 0.1457003994672197, 0.13417497383446297, 0.14633380036201926, 0.14799813298577225, 0.12925890441669885, 0.15489922007872314, 0.1551635300670554, 0.1377350266817432, 0.1465842042819422, 0.1861133191832195, 0.16337175098296253, 0.1458172510450657, 0.15425447619701194, 0.17819444653072292, 0.11552240808867942, 0.15213812557388118, 0.16479565246177375, 0.1741209913637164, 0.15662349043471113, 0.19199187997606149, 0.15126075352026036, 0.1308842339507229, 0.15964493646878586, 0.18898826034674687, 0.17391332975832663, 0.18256685753391944, 0.1902171599724597, 0.19515659383055872, 0.19765334438020754, 0.1816742857929099, 0.18060713920757065, 0.19003045635838145, 0.04471941052105033, 0.04616138280931714, 0.0528232289759053, 0.03824516154500324, 0.04386243612398344, 0.04409000499206994, 0.038379143564991725, 0.07306966897123801, 0.04880683741808556]}, "mutation_prompt": null}
{"id": "0a93d48f-3ac4-4adb-8dd6-55b2d056c67f", "solution": "import numpy as np\n\nclass HMADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.local_search_prob = 0.1  # Probability to apply local search\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = max(0.1, np.mean([entry[0] for entry in self.memory]))\n                self.Cr = min(0.9, np.mean([entry[1] for entry in self.memory]))\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                # Greedy local search\n                if np.random.rand() < self.local_search_prob and eval_count < self.budget:\n                    local_step = np.random.uniform(-0.1, 0.1, self.dim)\n                    local_candidate = np.clip(new_population[i] + local_step, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    eval_count += 1\n                    if local_fitness < fitness[i]:\n                        new_population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HMADE", "description": "A Hybrid Memory-Enhanced Adaptive Differential Evolution (HMADE) algorithm enhances performance by combining memory-driven parameter adaptation with a greedy local search strategy.", "configspace": "", "generation": 13, "fitness": 0.3540010646400752, "feedback": "The algorithm HMADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7645486514696948, 0.7403793545687443, 0.7549581428125909, 0.7512278415803191, 0.7441785521986938, 0.759478762201999, 0.746297937743405, 0.7430549526303847, 0.7589322161504791, 0.5675178876394038, 0.5508017740692968, 0.5552449777358184, 0.5427250374983507, 0.5575410093982889, 0.5631367184190696, 0.5462037613006391, 0.5744738190776071, 0.5607516241106059, 0.1277824663888818, 0.10601855007329908, 0.11681335702847062, 0.12182717975979829, 0.1171951277155926, 0.13444229055112578, 0.10842749805207041, 0.13083212322193594, 0.10390938501318336, 0.11787199763831335, 0.10123312993505174, 0.10025279091024131, 0.09449412701823856, 0.10227618104253966, 0.10637653089709931, 0.11360567543672895, 0.10810242651241275, 0.11011386208353202, 0.9138018270101352, 0.9147633401434512, 0.8539940495659964, 0.8261001128574125, 0.917302992481386, 0.8775964918179252, 0.8592783660703085, 0.8663610094892341, 0.9226590680881229, 0.38513008505916513, 0.3925385222266107, 0.3959358649817819, 0.40761346385512487, 0.3804006115612798, 0.3984021177271938, 0.4057935016836688, 0.41922228302233766, 0.42116342764227943, 0.7282291297996717, 0.7327028602298518, 0.7537828352528403, 0.7428822478961943, 0.766333716481814, 0.7423390162932899, 0.7030294900629364, 0.7312359457235071, 0.7224682172381267, 0.23803943378096915, 0.15933939847205203, 0.14772484746644332, 0.2674082834752063, 0.1454647945097104, 0.24058507776670512, 0.17586562148433516, 0.2255220094452226, 0.1972463332156984, 0.21045830118450093, 0.4300863606153089, 0.21320031766856096, 0.24156783470561294, 0.22982536794778297, 0.20790394468653717, 0.18601325214153153, 0.42111693078846546, 0.1816293374370046, 0.3408505845030644, 0.3482204979471525, 0.3167175844604214, 0.33864666849237257, 0.38832730135647775, 0.28884146218305273, 0.3660747136151128, 0.3603931871110879, 0.32838994231191243, 0.4546377527354363, 0.5240061359021528, 0.42400956277622515, 0.5050517154678771, 0.4799113867859195, 0.453507207181126, 0.478935280245401, 0.5083463492046255, 0.47561617212269347, 0.068668207950215, 0.16580587443309303, 0.08597458213045606, 0.17574368549650754, 0.1338568999704256, 0.1681605460954595, 0.15015599616316444, 0.13488189291293406, 0.11575053278989911, 0.2530814590953623, 0.26046152510336473, 0.2876226041933273, 0.2942149428748023, 0.2946607570975619, 0.2818999711128247, 0.2398656009411485, 0.27148620224556297, 0.25852053562852784, 0.6524311923979254, 0.632822355133364, 0.6607188974358191, 0.6800739030399903, 0.6559011202165078, 0.6559384953532886, 0.6695387185882143, 0.6481599689891534, 0.6561612603881872, 0.10069493509411476, 0.0982372706033997, 0.11731592751142339, 0.10047354403708664, 0.10743038813467554, 0.10384744540061108, 0.10424471978392014, 0.1081751023426556, 0.12485958119830354, 0.15220380334707206, 0.16224481605717578, 0.17639174317379425, 0.17123698407142585, 0.19332567509626164, 0.16668261111058713, 0.1666627890600123, 0.17720487950352382, 0.16494232395186537, 0.3615227937628338, 0.380720190236451, 0.36340704687012026, 0.39705500293629103, 0.3663506075158549, 0.3717435102040424, 0.41226129093887875, 0.4142878172657819, 0.41568250178932087, 0.29192070698717576, 0.30010069665743, 0.2992856221086325, 0.2816382564132369, 0.28797928026552966, 0.3015394075178933, 0.31407899394875827, 0.316299580373658, 0.28470797192400976, 0.20517897935705898, 0.18623791105021792, 0.18157082486866716, 0.21047714057614908, 0.19920624476187054, 0.1977069310161902, 0.19621506445704517, 0.18908168074008336, 0.1983271655199368, 0.19902611629181233, 0.1978129335723181, 0.2254313030561379, 0.2440964139579862, 0.23375437213392758, 0.19133505960120767, 0.2209442093832923, 0.21567387554990036, 0.2101901419949258, 0.689475624791857, 0.19861806112123326, 0.6183782112821028, 0.6917883906374687, 0.7179179441557222, 0.6058312888097358, 0.7355655302736139, 0.73945547465519, 0.6451672249943488, 0.6294202242997256, 0.20190554252935333, 0.699304360992548, 0.19507968167145817, 0.20351618031072805, 0.19848196720281308, 0.2058420650368381, 0.37283961568611934, 0.2021888965936196, 0.22296040254098337, 0.18995339914713205, 0.1840170480522324, 0.19047187155177914, 0.20823104200021736, 0.20957415066517948, 0.19745245920054888, 0.20877459942919308, 0.1897867823847199, 0.0829210594021702, 0.07265326217777024, 0.07763695584246033, 0.07795358487255799, 0.07362773504730036, 0.09489657617107228, 0.07879371975084448, 0.08004261248511646, 0.07855723829156924]}, "mutation_prompt": null}
{"id": "0fc23ece-ad06-4347-beca-86951cec5c9d", "solution": "import numpy as np\n\nclass MADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MADE", "description": "A Memory-Enhanced Adaptive Differential Evolution (MADE) algorithm combines differential evolution with adaptive mutation strategies and a memory mechanism to dynamically adjust strategies based on past performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7682514559171263, 0.7600569239394717, 0.7636466400645218, 0.7671130477310657, 0.7903514481991641, 0.7698013354620454, 0.7783020555132691, 0.790128072452183, 0.7725187976041927, 0.6070142561843653, 0.5999766406812317, 0.5930099218524881, 0.609165449710199, 0.5986266298359444, 0.5933003434821107, 0.6033410541785547, 0.5916098030647285, 0.6125672881831984, 0.11765755949175039, 0.13764649380087812, 0.10754787854158998, 0.11041475356892316, 0.12793253089688805, 0.11186811498992377, 0.11773515236663612, 0.1268426449185126, 0.10712749750129191, 0.11010807657988642, 0.10353425203005373, 0.10618315082661012, 0.09516264772335858, 0.10244872689336515, 0.10410660466004229, 0.10886741672597577, 0.1065638383619888, 0.10566866554008392, 0.843387462913374, 0.9318153667770599, 0.9028707220583045, 0.833671880929729, 0.8953041935846743, 0.7751276813997141, 0.8337610872159981, 0.9266829117991846, 0.9174362807125387, 0.4562292454741471, 0.46304418336731534, 0.40688519607119134, 0.36776747785100805, 0.41949839152693924, 0.42128520410524795, 0.44741521780700877, 0.4171351961370585, 0.41082050235208634, 0.7696242456416582, 0.7394768409738849, 0.7498063378668416, 0.7637263916342989, 0.7293935812495511, 0.7531314203704407, 0.7493579042710876, 0.7583082771128605, 0.7755397563786, 0.20323817305490854, 0.25233930919685954, 0.3119664004767315, 0.18126442682195, 0.2330154701635786, 0.15850898877356268, 0.2633561439527775, 0.19986847384059947, 0.25585762486516983, 0.12945569201743745, 0.30365124613915795, 0.2527874282555711, 0.24221055941297231, 0.18276529011579412, 0.23630155683960863, 0.21087936699393495, 0.17735612606551132, 0.17619480867540238, 0.35649562791729505, 0.36364099539790484, 0.3516950186031409, 0.36357128419417706, 0.4019782097458269, 0.35684144628021264, 0.35057972353925726, 0.36521981059608666, 0.3908636554648567, 0.4699731528077583, 0.5264963824892643, 0.5139566136682838, 0.5177661720789491, 0.49858608316856157, 0.5230836675100352, 0.530573111650668, 0.5428474131084177, 0.5224494378890268, 0.09185074423997175, 0.11101280167946659, 0.16013991892928703, 0.1331751162058168, 0.21968972505527107, 0.27175874494461794, 0.14362090000517969, 0.19067936451354006, 0.1904920167866193, 0.29676896683826437, 0.2740721746581428, 0.2984817041631156, 0.3111043223219291, 0.2988481478177829, 0.3075155621110415, 0.3093955612127943, 0.3015167940390755, 0.31474025111636605, 0.6873365961767945, 0.670295165150394, 0.6964220136085257, 0.6847736314023929, 0.6696602828918757, 0.6877950945271007, 0.6793435945045185, 0.6687848211330003, 0.7066041693552487, 0.0951133787332159, 0.09941361368856072, 0.10023326398095611, 0.11449028470234279, 0.0960646971880662, 0.11200560661954495, 0.09253293754180691, 0.09786519987934517, 0.1019393142244518, 0.1351654912966178, 0.14031334394462758, 0.13790709755623343, 0.14503245091636585, 0.19563849096779762, 0.14763153587201172, 0.16759510705845604, 0.12584116070581564, 0.12811159688156937, 0.41476751248425703, 0.3867939582226131, 0.43667067940871784, 0.3893126873665629, 0.3874100936633277, 0.39749426549979705, 0.4002765883584455, 0.39651710476619406, 0.39531639984436207, 0.28988170382182266, 0.32509227190029, 0.329165856869472, 0.3099028251603716, 0.28695955335921697, 0.3239306586481122, 0.3574828649862468, 0.32641965323458744, 0.34686477466077803, 0.1993764788145811, 0.1796048275216382, 0.1839126056756133, 0.18336399034042472, 0.19876449768764015, 0.19616669801279008, 0.17224169109791543, 0.19108975961282915, 0.213520491208937, 0.44470633739978327, 0.23698288028737857, 0.1924479996011056, 0.19231799608915, 0.187759898605242, 0.18432290924299133, 0.19550269983769064, 0.19404719121219516, 0.2066630403504417, 0.7151219584718407, 0.6647251113681625, 0.17752954850982228, 0.732719776953036, 0.6930154034812326, 0.7604333097297, 0.6809846423271633, 0.6613829862696836, 0.48242159398900486, 0.6067629645337731, 0.20501842371603707, 0.7024397961139044, 0.5557044687646955, 0.19680264144190718, 0.20039762171316655, 0.20484166596415998, 0.6926483855966181, 0.20997647839541334, 0.18674682884606653, 0.18939125143027136, 0.18923422321395245, 0.19651006379909353, 0.18099086880525084, 0.18394216934907404, 0.18994090430746513, 0.1787039000899846, 0.23350007951757212, 0.0966824927280262, 0.08057947651813269, 0.07621410621555735, 0.07316557039156413, 0.07585839128582739, 0.07550947938882635, 0.07504783358507572, 0.08005832775687927, 0.08442500023025823]}, "mutation_prompt": null}
{"id": "e9e68010-9c95-4719-ba20-f1e579337ab7", "solution": "import numpy as np\n\nclass EMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F_min, self.F_max = 0.4, 0.9  # Dynamic differential weight range\n        self.Cr_min, self.Cr_max = 0.7, 0.95  # Dynamic crossover probability range\n        self.memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive parameter strategy based on memory\n            if len(self.memory) > 0:\n                self.F = np.clip(np.mean([entry[0] for entry in self.memory]), self.F_min, self.F_max)\n                self.Cr = np.clip(np.mean([entry[1] for entry in self.memory]), self.Cr_min, self.Cr_max)\n            else:\n                self.F = (self.F_min + self.F_max) / 2\n                self.Cr = (self.Cr_min + self.Cr_max) / 2\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_dynamic = np.random.uniform(self.F_min, self.F_max)\n                mutant = np.clip(x1 + F_dynamic * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                j_rand = np.random.randint(self.dim)\n                crossover_mask[j_rand] = True  # Ensure at least one dimension is swapped\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((F_dynamic, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EMDE", "description": "An Enhanced Memory-Based Differential Evolution (EMDE) algorithm that refines mutation and crossover strategies using success history and introduces dynamic scaling factors.", "configspace": "", "generation": 15, "fitness": 0.30407110448308267, "feedback": "The algorithm EMDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7032393834153575, 0.7149837379128312, 0.7170795530108378, 0.7265535445343145, 0.714574942497687, 0.7338749869971517, 0.7263853747072526, 0.7409592739997567, 0.715879927792486, 0.491378814012293, 0.5144916651674338, 0.5004711183957226, 0.4639926363907577, 0.4815497814090913, 0.4953818368197752, 0.4991505286849489, 0.5182757108997273, 0.5028670505921711, 0.10640544582137723, 0.10627905066535315, 0.11945587238190125, 0.10006371816489767, 0.11277558709948388, 0.099541851492296, 0.1049483501388353, 0.12443976370597887, 0.10880568689442915, 0.09265302673717402, 0.09377653744190029, 0.10611138401335463, 0.09799687647976807, 0.09445503230925334, 0.10329329424265721, 0.09881313749715415, 0.09782633749384073, 0.10868102196491558, 0.9595125667159943, 0.9338277998305947, 0.9069241595793118, 0.9022619513636954, 0.9567333325038063, 0.8878457413177098, 0.9411375874748692, 0.9531792197032329, 0.947458964875979, 0.3474079363593492, 0.3560777192749087, 0.3321941623095068, 0.3336259318507093, 0.33333121979109237, 0.31745432654754613, 0.32788424969444685, 0.3586933651646864, 0.35684232732377963, 0.6935289797680915, 0.6674523251262028, 0.6148874787070084, 0.6118850937526304, 0.6408863979127248, 0.694816303946432, 0.6425224890552608, 0.6270808077285543, 0.6707529102538191, 0.3043606772714684, 0.2638207637164396, 0.24215328037565997, 0.2062830407934615, 0.23786792314727612, 0.20224325328145343, 0.2753068528426029, 0.24444223204842286, 0.20988109973516644, 0.20527004856435127, 0.167121389134827, 0.1460725744193021, 0.22932842127939534, 0.1991856982653739, 0.26972905046502205, 0.21467317021733734, 0.20820536629377762, 0.16313875715511605, 0.19147316359049082, 0.19379749580093053, 0.15051010965671152, 0.19317214405136784, 0.17251118850482106, 0.15541597704946375, 0.18869628944517713, 0.1568990426760536, 0.2059369405947329, 0.3151820797925954, 0.3093116424791801, 0.35494645126357405, 0.29937254592878293, 0.24892562266149776, 0.2869047331149167, 0.34299425732590993, 0.33357052253756325, 0.342084928483515, 0.04139231363187923, 0.0391123727684104, 0.03582898935667145, 0.07082166829184511, 0.0586892319270077, 0.06110170064622, 0.08245633179774936, 0.0665600016264214, 0.06773905003303882, 0.17830424025220104, 0.18874192322655137, 0.18532607270181356, 0.22259022035839804, 0.21813892987589756, 0.2063014693422015, 0.1809302275216491, 0.20089129057635413, 0.1741362644052522, 0.5478516648352434, 0.5598048220880807, 0.5608259581757875, 0.5703606580692226, 0.5324170504047793, 0.5555576036876282, 0.5561446037620081, 0.5364592431172024, 0.5478914895467082, 0.0970148841992079, 0.0960654438431291, 0.10291621761935277, 0.0886946816823232, 0.11086934300986195, 0.09092075545906575, 0.0851593726786477, 0.09605667937897722, 0.09953514653105577, 0.15363698057386976, 0.13427007015003, 0.13674040110282804, 0.1413104396963074, 0.23558782982207405, 0.14048631140717993, 0.1411021396232479, 0.1297670467534381, 0.14916159306337284, 0.3031926391999551, 0.3283054145314904, 0.32120817323500384, 0.3342792462184697, 0.3097362349448859, 0.3242142661834416, 0.34708959857049726, 0.35705220910185476, 0.3497615963219959, 0.24209590733329722, 0.22694022689735116, 0.24251495283389846, 0.2311877185771114, 0.22125341799493292, 0.22451897500616913, 0.2660757692259419, 0.2632714024067372, 0.2641216332412395, 0.17957856809096506, 0.1919178285501676, 0.18861404971413764, 0.2010569735563026, 0.19255517582027448, 0.1973148826937302, 0.2022956760065333, 0.1706863474414747, 0.19030756906671908, 0.19030443425315147, 0.19400764930173098, 0.19134441540142, 0.18387131721273908, 0.1891816796482494, 0.20334585934743732, 0.18588041077175876, 0.19233325215577757, 0.1773819201520459, 0.6149411505910791, 0.14955214665970162, 0.669313151377744, 0.17921302432375064, 0.1823615287289252, 0.345415061850861, 0.17013457287399392, 0.5357670973741442, 0.40474770139778415, 0.16425723193811703, 0.4947735854695702, 0.4641839582868733, 0.5176259244044926, 0.18147150361734643, 0.18756675864150596, 0.5972394552594135, 0.6659711666846784, 0.20581649271493796, 0.20508773100214617, 0.1807948928547467, 0.1824247940853062, 0.18049968688693463, 0.1754665625996189, 0.1749017537340971, 0.1763453748242828, 0.18994767444220073, 0.1844620409533534, 0.07806040872327014, 0.0731718557035993, 0.0753270778999835, 0.07088628172668632, 0.07026682255906258, 0.07650171382349069, 0.07050022608340678, 0.07485650361185203, 0.07063161132798379]}, "mutation_prompt": null}
{"id": "cc20daca-5a8c-4cd1-bbf2-1cb857218dad", "solution": "import numpy as np\n\nclass EMADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F_base = 0.5\n        self.Cr_base = 0.9\n        self.memory = []\n        self.memory_size = 100\n        self.F_adapt = 0.7\n        self.Cr_adapt = 0.7\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory) > 0:\n                self.F_base = np.clip(np.mean([entry[0] for entry in self.memory]) + np.random.normal(0, 0.1), 0.1, 0.9)\n                self.Cr_base = np.clip(np.mean([entry[1] for entry in self.memory]) + np.random.normal(0, 0.1), 0.1, 0.9)\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F = self.F_base if np.random.rand() > 0.25 else self.F_adapt\n                mutant = np.clip(x1 + F * (x2 - x3), self.lower_bound, self.upper_bound)\n                Cr = self.Cr_base if np.random.rand() > 0.25 else self.Cr_adapt\n                crossover_mask = np.random.rand(self.dim) < Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((F, Cr))\n                    if len(self.memory) > self.memory_size:\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EMADE", "description": "An Enhanced Memory-Driven Adaptive Differential Evolution (EMADE) algorithm improves differential evolution by incorporating a more dynamic memory-based strategy and adaptive parameter tuning for efficient exploration and exploitation.", "configspace": "", "generation": 16, "fitness": 0.27277844859720723, "feedback": "The algorithm EMADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.723603518977537, 0.7002656119778123, 0.7222206607916932, 0.7297188481428247, 0.7099650703638749, 0.7066343005693436, 0.7367597781383906, 0.7214431410641897, 0.7086128127406008, 0.5360569854375913, 0.4599631684288912, 0.5165939146963443, 0.5093216245368306, 0.45795610987270274, 0.4915571323199829, 0.5038509395272421, 0.457496909997124, 0.5081533212264844, 0.15401461451141063, 0.12285962678343598, 0.12165522480326596, 0.1421377766061067, 0.11705487431218786, 0.11604647762069875, 0.15164549408194383, 0.12143692312404697, 0.10956143500648918, 0.10451788716158661, 0.1052957394925923, 0.09970985989285819, 0.12256122503939093, 0.10734761000887172, 0.11271707723980928, 0.12503277215107633, 0.10964220206469055, 0.10729237373247158, 0.9382754430997622, 0.9280995710794637, 0.9508532882688737, 0.9117133069613894, 0.9305721770935552, 0.935859487182439, 0.9455292324542404, 0.9477838808538085, 0.9285444886517514, 0.31630673770526474, 0.31686193397122653, 0.3182257843289914, 0.30175542648923626, 0.2883324272830383, 0.32220290123956896, 0.28803759816028573, 0.3082564308666148, 0.32244422705634, 0.4640806202472769, 0.48221939002563863, 0.5740707614785376, 0.5419191489874043, 0.5921840002810523, 0.573205298245013, 0.5126781445849377, 0.5549806762720192, 0.608678546491797, 0.20228640912087958, 0.1877136917379093, 0.1942838102254505, 0.17987843820968463, 0.15949574317859128, 0.19898826089695942, 0.17450341162752725, 0.19174852922336516, 0.19760903911174077, 0.1528363810463812, 0.14084740805406637, 0.14135179168120826, 0.1554282473993529, 0.15535492215530122, 0.18231547153022043, 0.1932425392496635, 0.16811931041466832, 0.17491618576790802, 0.05300539234060275, 0.05465885193785702, 0.08799710134665162, 0.06604428224352576, 0.0714403215913264, 0.11929166562693372, 0.06486389208973942, 0.10421743281279283, 0.11056818646380762, 0.1879166438481299, 0.21969084482073342, 0.24861075826295664, 0.15031255456465753, 0.24650554988546414, 0.24086610306134348, 0.1955971429141078, 0.2578215940681783, 0.29239815621433385, 0.014739678055418648, 0.010019485951680673, 0.05594529283354199, 0.015234887151274634, 0.0207944068558501, 0.03251491964164599, 0.0341382395201536, 0.03117013914695066, 0.04575061866564589, 0.1279919365858001, 0.1540772958866089, 0.1517967678819525, 0.13105806677616694, 0.14598908926194576, 0.1803271975714228, 0.12398569392421666, 0.142783887980392, 0.14671431061764184, 0.4938008861280765, 0.5014224071082707, 0.5374562175913401, 0.4833994642590176, 0.49218988441365563, 0.4936864469839647, 0.49257085868139183, 0.48412294413605594, 0.5096463542745051, 0.09283142561783075, 0.101397036134388, 0.08497145709219334, 0.09449933359535967, 0.09371793656556149, 0.08066321978888025, 0.08880409201615569, 0.08515698716551856, 0.08979214362318744, 0.20795103914612, 0.16033824981313505, 0.1361907166914772, 0.15194296075763492, 0.14003899568326783, 0.1376512304289096, 0.1597029271868896, 0.13854135733625894, 0.13912775965748336, 0.3131472549993448, 0.2976707163720784, 0.30976646084520953, 0.3027790878524107, 0.2965674501428507, 0.29886106042189475, 0.32493245297752615, 0.3411585255334597, 0.3199375376268977, 0.2284495831575718, 0.2118333321662128, 0.22826746675012777, 0.1939778927776057, 0.19221896297888874, 0.21471767488877458, 0.23237056753767904, 0.24257632940276153, 0.23314189295577803, 0.19132529274633792, 0.18615258318396277, 0.181507980369073, 0.1837419524829329, 0.1983753301005835, 0.18299657257740087, 0.18810556572506099, 0.18161329099666157, 0.2208285671571375, 0.18576152081013975, 0.1871659733383101, 0.187764152573892, 0.19910670592544, 0.19335684985293478, 0.1947528035833469, 0.1962398935064792, 0.20856455994670386, 0.18160281480080287, 0.16792797477782684, 0.24931868938144064, 0.2240432606499667, 0.3759280430210462, 0.4101026717773387, 0.4880671222586336, 0.18328126605196204, 0.37588301913653854, 0.3275604927264575, 0.1649770901955826, 0.19952218169148261, 0.5426001463434756, 0.23714327408147085, 0.16495509990511115, 0.22222003149756986, 0.2011270133673504, 0.2022357818442263, 0.2015746445927935, 0.18123961787185994, 0.185773786227711, 0.19162024806762712, 0.19654604967442346, 0.16623164551060998, 0.18918008253504992, 0.1957781006081044, 0.17824829523588415, 0.22052435135578363, 0.07729837227992098, 0.07572886783920707, 0.08762502889035373, 0.07732314143168073, 0.085225578704194, 0.07616440164867033, 0.07835862983667863, 0.0843010856375579, 0.08942686856611615]}, "mutation_prompt": null}
{"id": "cccf008b-55f3-432f-881f-9c6018dc5cdf", "solution": "import numpy as np\n\nclass EM_MADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.perturbation_prob = 0.2  # Probability to apply stochastic perturbation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory]) + np.random.uniform(-0.05, 0.05)\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover with potential perturbation\n                if np.random.rand() < self.perturbation_prob:\n                    perturb = np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant + perturb, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EM_MADE", "description": "An Enhanced Memory-Enhanced Adaptive Differential Evolution (EM-MADE) algorithm that integrates stochastic perturbations and adaptive scaling to improve convergence and exploration.", "configspace": "", "generation": 17, "fitness": 0.33483092639376366, "feedback": "The algorithm EM_MADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7546585526000262, 0.760696250574171, 0.7527700221930829, 0.7654471276144701, 0.7489740460717654, 0.7553127203864548, 0.747939406319409, 0.7420621940637635, 0.74565021270752, 0.5502254034314134, 0.5383970124822977, 0.5404606288051448, 0.5496258356739605, 0.5345774558359685, 0.5370906118796703, 0.5332538909120073, 0.5416194507829257, 0.5395344217144495, 0.09715989010664416, 0.11226182655239059, 0.1346299733665548, 0.09514048993942958, 0.10245706493264739, 0.11181315689924198, 0.10645671611561536, 0.10644506233466111, 0.12339582172451136, 0.09131524712231354, 0.1104991336937986, 0.12604953508303296, 0.0939976295055347, 0.10516576289636248, 0.11183024826629828, 0.09785525403015505, 0.097056773774861, 0.10777517257099611, 0.8630456610965234, 0.8928285783296742, 0.8726517887009015, 0.8026906247783123, 0.8951840127154956, 0.904254219862459, 0.8196230379084672, 0.8424198401387684, 0.8742868551392269, 0.3609498716416423, 0.3964408636670479, 0.3584268895190421, 0.3511658767590041, 0.3953950414632844, 0.3692574526563678, 0.3326911225655491, 0.393404637935193, 0.3703122969452064, 0.7840833335773595, 0.7327862426651328, 0.6356237500062731, 0.766744641507439, 0.7754829980554865, 0.6059598471185963, 0.787478653515761, 0.7012364303632143, 0.7290605613526383, 0.24105188509377007, 0.19719772239544264, 0.1926928694484621, 0.23935627789136116, 0.19881928754012557, 0.2256660689855694, 0.1968407030043493, 0.18038390993548037, 0.19132223450428865, 0.20338031467502093, 0.15744619148692052, 0.17855096497152212, 0.2971561323558276, 0.1758713458511042, 0.17637516578891754, 0.23504868925523703, 0.21039230637915685, 0.22853680324431325, 0.48119967962048493, 0.2869786807148317, 0.22565881969465296, 0.5261890161530289, 0.373776784251063, 0.22988160481892095, 0.5056843228614898, 0.3788208258967677, 0.20015529231985452, 0.5443222872521116, 0.4335841299748956, 0.384046508499685, 0.5585890913627498, 0.4801464854046379, 0.3845982067558925, 0.5694808992183813, 0.5250995462672807, 0.3372232423300563, 0.1680065616638633, 0.08989601471219488, 0.0832634861413808, 0.3031656956609532, 0.1283275830100159, 0.056271235175186174, 0.1813671646714119, 0.11842532894480395, 0.0907490196473838, 0.3402478572211344, 0.23093025571833115, 0.1705252253920091, 0.34595501084873814, 0.2549408108271596, 0.1952192123473393, 0.3291114830068437, 0.21427563235232672, 0.19462719048392596, 0.708226543928752, 0.6012027575538441, 0.5252411228940341, 0.678119110795741, 0.6064097821894501, 0.5401985146622329, 0.7142784167437759, 0.633386629579582, 0.5369460300577358, 0.11891637793456444, 0.0994675580438561, 0.11738461460983485, 0.12146173850320352, 0.09345207478334827, 0.10112332849713546, 0.08790711496516701, 0.10626744710365199, 0.09869798864790391, 0.1701282745396373, 0.13833177739475666, 0.13370068373135313, 0.15622018805831905, 0.1542768443508885, 0.15885140231771544, 0.14318911810754575, 0.1318680459358409, 0.16307882204731705, 0.3891068789574611, 0.3463989386262546, 0.36379246754438876, 0.39570428130302393, 0.3493300792119446, 0.3553161635657821, 0.3562734683203197, 0.3773923674042331, 0.3720046667157948, 0.3117501310154802, 0.27950286816075653, 0.26105938939985907, 0.2943442246927257, 0.2790747376540539, 0.24754036864137874, 0.31669225249969335, 0.28226671282051174, 0.26412760372409116, 0.21174193914368877, 0.19881689303894534, 0.1866534960157753, 0.1952208273521917, 0.21279614616382392, 0.25521334069948165, 0.1832731982014415, 0.20296870063635375, 0.20314709431276456, 0.20183412603330497, 0.18979849500620627, 0.24186991813363912, 0.18895019655686052, 0.20505596348539257, 0.18987807299583115, 0.1819832522740661, 0.18480416067260774, 0.19233548675446555, 0.7515260227820133, 0.7798719101649061, 0.18903250865713894, 0.17129618950065195, 0.18801518106063364, 0.6535203021362196, 0.7102945488494764, 0.18355815859868918, 0.1881368096052134, 0.20315406308689954, 0.200330649067891, 0.19829883734558273, 0.7175412895650892, 0.19407248052257053, 0.582586472781753, 0.20345621935823455, 0.4474480603033598, 0.204864791419907, 0.17850725662650824, 0.1918332441308761, 0.18596823736751633, 0.18771374892706294, 0.18809982789385438, 0.18455855609723648, 0.19647011494448552, 0.17402289887274713, 0.19139876246549203, 0.08362229492377116, 0.08052651039170466, 0.07978532906705327, 0.08456429087101913, 0.0812455421438193, 0.08144859847635999, 0.08140389185399965, 0.07488149025699453, 0.09415959824816911]}, "mutation_prompt": null}
{"id": "3546540b-f12d-469f-a6ff-2115b3d23f46", "solution": "import numpy as np\n\nclass IMADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.history = []  # Added history to track past successful solutions\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n        best_fitness = np.min(fitness)\n        \n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.random.choice([entry[0] for entry in self.memory])\n                self.Cr = np.random.choice([entry[1] for entry in self.memory])\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation with iterative learning\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                \n                if np.random.rand() < 0.1 and len(self.history) > 0:  # Occasionally use a past successful solution\n                    past_solution = self.history[np.random.randint(0, len(self.history))]\n                    mutant = np.clip(x1 + self.F * (past_solution - x2), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    self.history.append(trial)\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n                    if len(self.history) > 100:  # Maintain limited history size\n                        self.history.pop(0)\n                \n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "IMADE", "description": "An Iterative Memory-Enhanced Adaptive Differential Evolution (IMADE) that incorporates iterative learning from past successful strategies, enhancing mutation and crossover operations adaptively for improved convergence.", "configspace": "", "generation": 18, "fitness": 0.3650857338243734, "feedback": "The algorithm IMADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7827878669098224, 0.758598133829191, 0.7747028073826362, 0.7816720766074916, 0.7805590612845372, 0.7702985111452323, 0.7651563537557586, 0.7662542140451092, 0.7732051661243905, 0.5943463024051137, 0.593141903102437, 0.5838964534002589, 0.6189795355203584, 0.5816017180033279, 0.6043624910972567, 0.5899793106639047, 0.61079500136898, 0.5879188563144238, 0.11195489977814144, 0.12301681226532746, 0.12019383196517541, 0.12903041292392048, 0.1274055133060379, 0.11346176827848398, 0.1123796044119868, 0.11446570184159677, 0.10399861808825916, 0.11128595367082794, 0.09377129286200414, 0.10686458007820021, 0.10727477297377785, 0.11344468627811022, 0.11944857240085016, 0.11215283956397615, 0.11633834636406826, 0.11115392691191517, 0.9093543837413749, 0.9215141287578112, 0.9186174992328778, 0.8869038407552476, 0.8677058717907508, 0.9130284071135029, 0.8809464237894477, 0.9260760734925542, 0.9083596022356342, 0.4347140802673596, 0.39587893477288505, 0.45446441297323503, 0.42429067473840565, 0.3748824027334329, 0.38937100595620655, 0.43691370140068253, 0.39732223221260243, 0.3022826364151311, 0.7531845297509664, 0.7773381498554665, 0.770319089827734, 0.7709012833084208, 0.7963207339178923, 0.7020154335261728, 0.7900886912325903, 0.7603602601338104, 0.7726558021226786, 0.16046433681523053, 0.1699526375482563, 0.414694743163069, 0.19611619741814879, 0.215530363917383, 0.15385202358179684, 0.2654475313314043, 0.2532952568082294, 0.2989419113291192, 0.2722607701994272, 0.1872096760185289, 0.2360655723621372, 0.3149486790608188, 0.36992404419233704, 0.20477489615052358, 0.24205418315562133, 0.18298315220440164, 0.1874634375755383, 0.24730592639202365, 0.3664679795616589, 0.4090534536128333, 0.3714262710344566, 0.3526452288272165, 0.3372545011374194, 0.3647423627016033, 0.3607236417111862, 0.34033450687015643, 0.5535266420835387, 0.5135779732505339, 0.5328797994224603, 0.5145043125981024, 0.5074646491965351, 0.48104241738948317, 0.5302464034307561, 0.5272863254169833, 0.519373911334341, 0.20891800983958675, 0.1068245699570578, 0.154455720222206, 0.24442026745100132, 0.19509304391599536, 0.2469334635230277, 0.13642009666387744, 0.11512570462427207, 0.1519941653020176, 0.26407052218614857, 0.27776394130902904, 0.2672587168316267, 0.2983900615996218, 0.28653605034271323, 0.31274909709297505, 0.2820098038131299, 0.270217835795201, 0.31482965909060023, 0.6535698056447149, 0.709203285829779, 0.6679953804861767, 0.6867846548286107, 0.684696856188457, 0.6805293362882179, 0.6868703254661938, 0.6694666939844856, 0.6853240822131501, 0.10724440142127079, 0.1001897808943708, 0.09440445469137071, 0.10220992924566419, 0.10227075779983774, 0.0853174790852117, 0.09622880125694677, 0.0854260993014706, 0.11133843646746022, 0.16275197905508942, 0.14766479371396812, 0.17218643858179117, 0.13477992040026476, 0.14119148194618214, 0.17838570204063575, 0.14185152426449055, 0.15065913654552365, 0.1411178388846469, 0.36406961594573994, 0.4151872907257461, 0.37016804999673514, 0.4137865967383101, 0.38139830426135746, 0.3589059694282465, 0.41665899079049973, 0.3930513708876592, 0.42805897659126235, 0.3059046175605591, 0.28492502232879724, 0.29161797312269155, 0.3114003470366884, 0.3091237298458207, 0.2882293939653032, 0.3143694857136514, 0.31726823284367534, 0.33691073741954425, 0.1937809740771087, 0.18891443482568215, 0.21513565167109305, 0.1993389567060192, 0.19813083460650838, 0.18770286184435558, 0.20566989495045795, 0.18824015384653336, 0.204646369371965, 0.23182202013195907, 0.22675483608512592, 0.19656363186494807, 0.20248132136462782, 0.19466411695481156, 0.19983542937225507, 0.21608943228727562, 0.2529730764866095, 0.18259771933804025, 0.6619960496447375, 0.16758211083263008, 0.6717541831533695, 0.748203473483559, 0.6765618214616713, 0.6627625579529572, 0.6626900415475928, 0.5384461300353556, 0.7124208957995879, 0.6644921999178763, 0.2031438756894215, 0.6227586614614685, 0.20245540923942495, 0.2019492088815873, 0.6992303181556032, 0.19025856985626532, 0.20615907691445112, 0.20964881289808412, 0.17930698428372183, 0.19251506639390503, 0.1858057427088735, 0.19236594079109715, 0.20426111198047425, 0.18632038410325014, 0.19926750932421877, 0.1862114371195569, 0.20397126059990434, 0.07919327122799202, 0.09100119487560909, 0.08376409129636408, 0.07944554870315768, 0.0867035370846474, 0.07792954192483015, 0.09506006138240664, 0.08344613458894634, 0.09184586189529909]}, "mutation_prompt": null}
{"id": "2bd8faff-73c9-4760-9a20-dacf6437fcf5", "solution": "import numpy as np\n\nclass ADEIL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = max(10, 10 * dim)  # Ensure a minimum population size\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.inertia = 0.7  # Inertia factor for mutation\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n        historical_best = np.copy(population[np.argmin(fitness)])\n\n        while eval_count < self.budget:\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.inertia * self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < func(historical_best):\n                historical_best = np.copy(population[best_idx])\n\n        return historical_best, func(historical_best)", "name": "ADEIL", "description": "An Adaptive Differential Evolution with Inertial Learning (ADEIL) improves MADE by introducing an inertia factor in mutation and synthetic population memory for dynamic strategy adaptation.", "configspace": "", "generation": 19, "fitness": 0.3596635706627147, "feedback": "The algorithm ADEIL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.8024383356044972, 0.7970684361509411, 0.8241327226251514, 0.8069371808065664, 0.7944198895636507, 0.8078906660118595, 0.8063370278600107, 0.7985665451726571, 0.8161400640891081, 0.6768360458006195, 0.6594732837754387, 0.6438938122784019, 0.6713254940127198, 0.6608737323878708, 0.6548899129512724, 0.6803117618993126, 0.6482663238633217, 0.6738036247299535, 0.19115958964918323, 0.11967197195727464, 0.3655073200665787, 0.23082170630276155, 0.1571328807213458, 0.1302396913956969, 0.11155875906606638, 0.15964418163534244, 0.13735586836911062, 0.1450434110419525, 0.1166923061284959, 0.12275385817603834, 0.1359813353440935, 0.10964271446673646, 0.10873848876032532, 0.10876843677417569, 0.11002465656481253, 0.1291272328747275, 0.8023762182644985, 0.8201743744959594, 0.731357267901934, 0.7801652924119344, 0.7374683752186191, 0.8200178212344047, 0.8418821057381661, 0.7721445399750085, 0.8786349151898228, 0.26991259547795377, 0.13829019612284232, 0.18685921319142496, 0.31503142797029626, 0.24028041959741164, 0.18654870641791566, 0.17409933280858036, 0.25013679893862706, 0.220546546442545, 0.7094486040470365, 0.8281332076039071, 0.8313925662031877, 0.7893881090266246, 0.8231940751245634, 0.7595220913284513, 0.7852526372828247, 0.7855632968537153, 0.809640889545631, 0.13455808873497388, 0.5260309764822413, 0.15490065242282636, 0.18297366216613153, 0.12944531446138063, 0.21959821180288963, 0.21251944439073178, 0.2843198448758403, 0.14477299738802973, 0.1854148387453718, 0.18686383321910405, 0.13416004174378426, 0.15852696452572113, 0.16123863675198313, 0.14438645995004318, 0.14705241501187627, 0.18864458496510828, 0.14541099983810457, 0.45479704685831535, 0.12097082033166973, 0.4578005893691953, 0.5017181903659216, 0.4317926194358269, 0.38042196282835816, 0.47316038601364974, 0.2597762557702544, 0.2727013185347129, 0.3777912919707538, 0.18462447492529832, 0.14456290786773263, 0.5024278661156887, 0.04414784509652492, 0.5152526791735009, 0.4242432889308623, 0.18824116695778315, 0.27723423885372045, 0.0963500300666359, 0.13297451313690978, 0.08824493466743955, 0.19387674164942292, 0.22635971277791955, 0.32295711762815127, 0.166311446766235, 0.09598032290989233, 0.20487331585396673, 0.3029873267057164, 0.4248235688585047, 0.285898144249644, 0.37917513629776756, 0.4035894193523737, 0.3894806516295667, 0.37083589562314623, 0.3809344129754949, 0.14740685935126274, 0.6721241898352788, 0.6141019775802798, 0.6860200083089321, 0.729307912140224, 0.5108679131842453, 0.7423995997146235, 0.7422437067883731, 0.6612095097838835, 0.7456346053673497, 0.1127715331971102, 0.11151826408486198, 0.10697299669608451, 0.10338615949069518, 0.1430433247435542, 0.1116513868181217, 0.10988595216883168, 0.10413506364961955, 0.10894454636399098, 0.14317563292146118, 0.1504898620373044, 0.2476203781833365, 0.23457036955200716, 0.15353853003933904, 0.13775226663379503, 0.188791379795598, 0.18097831457989666, 0.15102742876943487, 0.49496608803711073, 0.4510602948566741, 0.5049120820541275, 0.4729731037225361, 0.499818360910372, 0.4917360417849109, 0.5367913328356572, 0.4953800684743779, 0.5074768381426933, 0.3685078908392636, 0.3851094322040205, 0.3912281939550746, 0.39037427446512507, 0.3737191544291256, 0.42337422969006866, 0.43692304815189786, 0.4091279860037499, 0.4350567692103956, 0.21577641520358504, 0.22741366043429811, 0.2189262077143015, 0.21484127731222447, 0.19641964115305433, 0.19809846115938545, 0.21803236986371044, 0.19347636909505417, 0.20818122546651785, 0.3157436667349336, 0.3181062398275535, 0.22490834095769008, 0.36720065020636083, 0.3036408312740616, 0.46993250481138016, 0.25046793578203197, 0.4591081330707196, 0.5465031088178882, 0.1813770931760429, 0.18165209279311045, 0.7621594495064912, 0.8272271913288304, 0.606520933839936, 0.7970754041963106, 0.1670712789390567, 0.19259402061175623, 0.7618331758229301, 0.33019684918339764, 0.33555834961373954, 0.42330941071815165, 0.19780620935046944, 0.20262737336723313, 0.19894151293489792, 0.20809076748389177, 0.4802424515739211, 0.20817711555800889, 0.18298315090028905, 0.17687307012959885, 0.1689521577098443, 0.21149258687991823, 0.19186406619344576, 0.17706498887714295, 0.21029409609868732, 0.17661488846417428, 0.17518446796741993, 0.08006834445089439, 0.08173930937262397, 0.08240553886222257, 0.0849085381458119, 0.09301782603266273, 0.08800678937971584, 0.08464763845369527, 0.09267216063434969, 0.0801325628476296]}, "mutation_prompt": null}
{"id": "ea3fbba2-1e56-4f37-b0da-98c42e1f5165", "solution": "import numpy as np\n\nclass MADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MADE", "description": "A Memory-Enhanced Adaptive Differential Evolution (MADE) algorithm combines differential evolution with adaptive mutation strategies and a memory mechanism to dynamically adjust strategies based on past performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7682514559171263, 0.7600569239394717, 0.7636466400645218, 0.7671130477310657, 0.7903514481991641, 0.7698013354620454, 0.7783020555132691, 0.790128072452183, 0.7725187976041927, 0.6070142561843653, 0.5999766406812317, 0.5930099218524881, 0.609165449710199, 0.5986266298359444, 0.5933003434821107, 0.6033410541785547, 0.5916098030647285, 0.6125672881831984, 0.11765755949175039, 0.13764649380087812, 0.10754787854158998, 0.11041475356892316, 0.12793253089688805, 0.11186811498992377, 0.11773515236663612, 0.1268426449185126, 0.10712749750129191, 0.11010807657988642, 0.10353425203005373, 0.10618315082661012, 0.09516264772335858, 0.10244872689336515, 0.10410660466004229, 0.10886741672597577, 0.1065638383619888, 0.10566866554008392, 0.843387462913374, 0.9318153667770599, 0.9028707220583045, 0.833671880929729, 0.8953041935846743, 0.7751276813997141, 0.8337610872159981, 0.9266829117991846, 0.9174362807125387, 0.4562292454741471, 0.46304418336731534, 0.40688519607119134, 0.36776747785100805, 0.41949839152693924, 0.42128520410524795, 0.44741521780700877, 0.4171351961370585, 0.41082050235208634, 0.7696242456416582, 0.7394768409738849, 0.7498063378668416, 0.7637263916342989, 0.7293935812495511, 0.7531314203704407, 0.7493579042710876, 0.7583082771128605, 0.7755397563786, 0.20323817305490854, 0.25233930919685954, 0.3119664004767315, 0.18126442682195, 0.2330154701635786, 0.15850898877356268, 0.2633561439527775, 0.19986847384059947, 0.25585762486516983, 0.12945569201743745, 0.30365124613915795, 0.2527874282555711, 0.24221055941297231, 0.18276529011579412, 0.23630155683960863, 0.21087936699393495, 0.17735612606551132, 0.17619480867540238, 0.35649562791729505, 0.36364099539790484, 0.3516950186031409, 0.36357128419417706, 0.4019782097458269, 0.35684144628021264, 0.35057972353925726, 0.36521981059608666, 0.3908636554648567, 0.4699731528077583, 0.5264963824892643, 0.5139566136682838, 0.5177661720789491, 0.49858608316856157, 0.5230836675100352, 0.530573111650668, 0.5428474131084177, 0.5224494378890268, 0.09185074423997175, 0.11101280167946659, 0.16013991892928703, 0.1331751162058168, 0.21968972505527107, 0.27175874494461794, 0.14362090000517969, 0.19067936451354006, 0.1904920167866193, 0.29676896683826437, 0.2740721746581428, 0.2984817041631156, 0.3111043223219291, 0.2988481478177829, 0.3075155621110415, 0.3093955612127943, 0.3015167940390755, 0.31474025111636605, 0.6873365961767945, 0.670295165150394, 0.6964220136085257, 0.6847736314023929, 0.6696602828918757, 0.6877950945271007, 0.6793435945045185, 0.6687848211330003, 0.7066041693552487, 0.0951133787332159, 0.09941361368856072, 0.10023326398095611, 0.11449028470234279, 0.0960646971880662, 0.11200560661954495, 0.09253293754180691, 0.09786519987934517, 0.1019393142244518, 0.1351654912966178, 0.14031334394462758, 0.13790709755623343, 0.14503245091636585, 0.19563849096779762, 0.14763153587201172, 0.16759510705845604, 0.12584116070581564, 0.12811159688156937, 0.41476751248425703, 0.3867939582226131, 0.43667067940871784, 0.3893126873665629, 0.3874100936633277, 0.39749426549979705, 0.4002765883584455, 0.39651710476619406, 0.39531639984436207, 0.28988170382182266, 0.32509227190029, 0.329165856869472, 0.3099028251603716, 0.28695955335921697, 0.3239306586481122, 0.3574828649862468, 0.32641965323458744, 0.34686477466077803, 0.1993764788145811, 0.1796048275216382, 0.1839126056756133, 0.18336399034042472, 0.19876449768764015, 0.19616669801279008, 0.17224169109791543, 0.19108975961282915, 0.213520491208937, 0.44470633739978327, 0.23698288028737857, 0.1924479996011056, 0.19231799608915, 0.187759898605242, 0.18432290924299133, 0.19550269983769064, 0.19404719121219516, 0.2066630403504417, 0.7151219584718407, 0.6647251113681625, 0.17752954850982228, 0.732719776953036, 0.6930154034812326, 0.7604333097297, 0.6809846423271633, 0.6613829862696836, 0.48242159398900486, 0.6067629645337731, 0.20501842371603707, 0.7024397961139044, 0.5557044687646955, 0.19680264144190718, 0.20039762171316655, 0.20484166596415998, 0.6926483855966181, 0.20997647839541334, 0.18674682884606653, 0.18939125143027136, 0.18923422321395245, 0.19651006379909353, 0.18099086880525084, 0.18394216934907404, 0.18994090430746513, 0.1787039000899846, 0.23350007951757212, 0.0966824927280262, 0.08057947651813269, 0.07621410621555735, 0.07316557039156413, 0.07585839128582739, 0.07550947938882635, 0.07504783358507572, 0.08005832775687927, 0.08442500023025823]}, "mutation_prompt": null}
{"id": "c5f27299-6d09-485d-a9f1-3b96d32b049f", "solution": "import numpy as np\n\nclass MADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MADE", "description": "A Memory-Enhanced Adaptive Differential Evolution (MADE) algorithm combines differential evolution with adaptive mutation strategies and a memory mechanism to dynamically adjust strategies based on past performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7682514559171263, 0.7600569239394717, 0.7636466400645218, 0.7671130477310657, 0.7903514481991641, 0.7698013354620454, 0.7783020555132691, 0.790128072452183, 0.7725187976041927, 0.6070142561843653, 0.5999766406812317, 0.5930099218524881, 0.609165449710199, 0.5986266298359444, 0.5933003434821107, 0.6033410541785547, 0.5916098030647285, 0.6125672881831984, 0.11765755949175039, 0.13764649380087812, 0.10754787854158998, 0.11041475356892316, 0.12793253089688805, 0.11186811498992377, 0.11773515236663612, 0.1268426449185126, 0.10712749750129191, 0.11010807657988642, 0.10353425203005373, 0.10618315082661012, 0.09516264772335858, 0.10244872689336515, 0.10410660466004229, 0.10886741672597577, 0.1065638383619888, 0.10566866554008392, 0.843387462913374, 0.9318153667770599, 0.9028707220583045, 0.833671880929729, 0.8953041935846743, 0.7751276813997141, 0.8337610872159981, 0.9266829117991846, 0.9174362807125387, 0.4562292454741471, 0.46304418336731534, 0.40688519607119134, 0.36776747785100805, 0.41949839152693924, 0.42128520410524795, 0.44741521780700877, 0.4171351961370585, 0.41082050235208634, 0.7696242456416582, 0.7394768409738849, 0.7498063378668416, 0.7637263916342989, 0.7293935812495511, 0.7531314203704407, 0.7493579042710876, 0.7583082771128605, 0.7755397563786, 0.20323817305490854, 0.25233930919685954, 0.3119664004767315, 0.18126442682195, 0.2330154701635786, 0.15850898877356268, 0.2633561439527775, 0.19986847384059947, 0.25585762486516983, 0.12945569201743745, 0.30365124613915795, 0.2527874282555711, 0.24221055941297231, 0.18276529011579412, 0.23630155683960863, 0.21087936699393495, 0.17735612606551132, 0.17619480867540238, 0.35649562791729505, 0.36364099539790484, 0.3516950186031409, 0.36357128419417706, 0.4019782097458269, 0.35684144628021264, 0.35057972353925726, 0.36521981059608666, 0.3908636554648567, 0.4699731528077583, 0.5264963824892643, 0.5139566136682838, 0.5177661720789491, 0.49858608316856157, 0.5230836675100352, 0.530573111650668, 0.5428474131084177, 0.5224494378890268, 0.09185074423997175, 0.11101280167946659, 0.16013991892928703, 0.1331751162058168, 0.21968972505527107, 0.27175874494461794, 0.14362090000517969, 0.19067936451354006, 0.1904920167866193, 0.29676896683826437, 0.2740721746581428, 0.2984817041631156, 0.3111043223219291, 0.2988481478177829, 0.3075155621110415, 0.3093955612127943, 0.3015167940390755, 0.31474025111636605, 0.6873365961767945, 0.670295165150394, 0.6964220136085257, 0.6847736314023929, 0.6696602828918757, 0.6877950945271007, 0.6793435945045185, 0.6687848211330003, 0.7066041693552487, 0.0951133787332159, 0.09941361368856072, 0.10023326398095611, 0.11449028470234279, 0.0960646971880662, 0.11200560661954495, 0.09253293754180691, 0.09786519987934517, 0.1019393142244518, 0.1351654912966178, 0.14031334394462758, 0.13790709755623343, 0.14503245091636585, 0.19563849096779762, 0.14763153587201172, 0.16759510705845604, 0.12584116070581564, 0.12811159688156937, 0.41476751248425703, 0.3867939582226131, 0.43667067940871784, 0.3893126873665629, 0.3874100936633277, 0.39749426549979705, 0.4002765883584455, 0.39651710476619406, 0.39531639984436207, 0.28988170382182266, 0.32509227190029, 0.329165856869472, 0.3099028251603716, 0.28695955335921697, 0.3239306586481122, 0.3574828649862468, 0.32641965323458744, 0.34686477466077803, 0.1993764788145811, 0.1796048275216382, 0.1839126056756133, 0.18336399034042472, 0.19876449768764015, 0.19616669801279008, 0.17224169109791543, 0.19108975961282915, 0.213520491208937, 0.44470633739978327, 0.23698288028737857, 0.1924479996011056, 0.19231799608915, 0.187759898605242, 0.18432290924299133, 0.19550269983769064, 0.19404719121219516, 0.2066630403504417, 0.7151219584718407, 0.6647251113681625, 0.17752954850982228, 0.732719776953036, 0.6930154034812326, 0.7604333097297, 0.6809846423271633, 0.6613829862696836, 0.48242159398900486, 0.6067629645337731, 0.20501842371603707, 0.7024397961139044, 0.5557044687646955, 0.19680264144190718, 0.20039762171316655, 0.20484166596415998, 0.6926483855966181, 0.20997647839541334, 0.18674682884606653, 0.18939125143027136, 0.18923422321395245, 0.19651006379909353, 0.18099086880525084, 0.18394216934907404, 0.18994090430746513, 0.1787039000899846, 0.23350007951757212, 0.0966824927280262, 0.08057947651813269, 0.07621410621555735, 0.07316557039156413, 0.07585839128582739, 0.07550947938882635, 0.07504783358507572, 0.08005832775687927, 0.08442500023025823]}, "mutation_prompt": null}
{"id": "6f7ed837-11f0-4d32-b289-38f1135e8ef7", "solution": "import numpy as np\n\nclass MADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MADE", "description": "A Memory-Enhanced Adaptive Differential Evolution (MADE) algorithm combines differential evolution with adaptive mutation strategies and a memory mechanism to dynamically adjust strategies based on past performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.7682514559171263, 0.7600569239394717, 0.7636466400645218, 0.7671130477310657, 0.7903514481991641, 0.7698013354620454, 0.7783020555132691, 0.790128072452183, 0.7725187976041927, 0.6070142561843653, 0.5999766406812317, 0.5930099218524881, 0.609165449710199, 0.5986266298359444, 0.5933003434821107, 0.6033410541785547, 0.5916098030647285, 0.6125672881831984, 0.11765755949175039, 0.13764649380087812, 0.10754787854158998, 0.11041475356892316, 0.12793253089688805, 0.11186811498992377, 0.11773515236663612, 0.1268426449185126, 0.10712749750129191, 0.11010807657988642, 0.10353425203005373, 0.10618315082661012, 0.09516264772335858, 0.10244872689336515, 0.10410660466004229, 0.10886741672597577, 0.1065638383619888, 0.10566866554008392, 0.843387462913374, 0.9318153667770599, 0.9028707220583045, 0.833671880929729, 0.8953041935846743, 0.7751276813997141, 0.8337610872159981, 0.9266829117991846, 0.9174362807125387, 0.4562292454741471, 0.46304418336731534, 0.40688519607119134, 0.36776747785100805, 0.41949839152693924, 0.42128520410524795, 0.44741521780700877, 0.4171351961370585, 0.41082050235208634, 0.7696242456416582, 0.7394768409738849, 0.7498063378668416, 0.7637263916342989, 0.7293935812495511, 0.7531314203704407, 0.7493579042710876, 0.7583082771128605, 0.7755397563786, 0.20323817305490854, 0.25233930919685954, 0.3119664004767315, 0.18126442682195, 0.2330154701635786, 0.15850898877356268, 0.2633561439527775, 0.19986847384059947, 0.25585762486516983, 0.12945569201743745, 0.30365124613915795, 0.2527874282555711, 0.24221055941297231, 0.18276529011579412, 0.23630155683960863, 0.21087936699393495, 0.17735612606551132, 0.17619480867540238, 0.35649562791729505, 0.36364099539790484, 0.3516950186031409, 0.36357128419417706, 0.4019782097458269, 0.35684144628021264, 0.35057972353925726, 0.36521981059608666, 0.3908636554648567, 0.4699731528077583, 0.5264963824892643, 0.5139566136682838, 0.5177661720789491, 0.49858608316856157, 0.5230836675100352, 0.530573111650668, 0.5428474131084177, 0.5224494378890268, 0.09185074423997175, 0.11101280167946659, 0.16013991892928703, 0.1331751162058168, 0.21968972505527107, 0.27175874494461794, 0.14362090000517969, 0.19067936451354006, 0.1904920167866193, 0.29676896683826437, 0.2740721746581428, 0.2984817041631156, 0.3111043223219291, 0.2988481478177829, 0.3075155621110415, 0.3093955612127943, 0.3015167940390755, 0.31474025111636605, 0.6873365961767945, 0.670295165150394, 0.6964220136085257, 0.6847736314023929, 0.6696602828918757, 0.6877950945271007, 0.6793435945045185, 0.6687848211330003, 0.7066041693552487, 0.0951133787332159, 0.09941361368856072, 0.10023326398095611, 0.11449028470234279, 0.0960646971880662, 0.11200560661954495, 0.09253293754180691, 0.09786519987934517, 0.1019393142244518, 0.1351654912966178, 0.14031334394462758, 0.13790709755623343, 0.14503245091636585, 0.19563849096779762, 0.14763153587201172, 0.16759510705845604, 0.12584116070581564, 0.12811159688156937, 0.41476751248425703, 0.3867939582226131, 0.43667067940871784, 0.3893126873665629, 0.3874100936633277, 0.39749426549979705, 0.4002765883584455, 0.39651710476619406, 0.39531639984436207, 0.28988170382182266, 0.32509227190029, 0.329165856869472, 0.3099028251603716, 0.28695955335921697, 0.3239306586481122, 0.3574828649862468, 0.32641965323458744, 0.34686477466077803, 0.1993764788145811, 0.1796048275216382, 0.1839126056756133, 0.18336399034042472, 0.19876449768764015, 0.19616669801279008, 0.17224169109791543, 0.19108975961282915, 0.213520491208937, 0.44470633739978327, 0.23698288028737857, 0.1924479996011056, 0.19231799608915, 0.187759898605242, 0.18432290924299133, 0.19550269983769064, 0.19404719121219516, 0.2066630403504417, 0.7151219584718407, 0.6647251113681625, 0.17752954850982228, 0.732719776953036, 0.6930154034812326, 0.7604333097297, 0.6809846423271633, 0.6613829862696836, 0.48242159398900486, 0.6067629645337731, 0.20501842371603707, 0.7024397961139044, 0.5557044687646955, 0.19680264144190718, 0.20039762171316655, 0.20484166596415998, 0.6926483855966181, 0.20997647839541334, 0.18674682884606653, 0.18939125143027136, 0.18923422321395245, 0.19651006379909353, 0.18099086880525084, 0.18394216934907404, 0.18994090430746513, 0.1787039000899846, 0.23350007951757212, 0.0966824927280262, 0.08057947651813269, 0.07621410621555735, 0.07316557039156413, 0.07585839128582739, 0.07550947938882635, 0.07504783358507572, 0.08005832775687927, 0.08442500023025823]}, "mutation_prompt": null}
{"id": "f556c6c5-eb35-423b-ac9f-e4005fb32465", "solution": "import numpy as np\n\nclass EMADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.dynamic_F = [0.4, 0.5, 0.6]  # Dynamic scaling factors\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy selection\n            if len(self.memory) > 0:\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n                self.F = np.random.choice(self.dynamic_F)\n            \n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 100:  # Maintain larger memory size\n                        self.memory.pop(0)\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EMADE", "description": "An Enhanced Memory Adaptive Differential Evolution (EMADE) algorithm integrating a dynamic scaling factor and adaptive crossover strategy for improved convergence.", "configspace": "", "generation": 23, "fitness": 0.3541172745806917, "feedback": "The algorithm EMADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.754232228207832, 0.7787312313334153, 0.7613020107056858, 0.7556818489697416, 0.7913024109099941, 0.7562436080266096, 0.740331958451482, 0.7928813124955789, 0.7692132797843414, 0.6030246266027246, 0.6000668404966452, 0.6279728727202221, 0.5672490296047206, 0.6126344818645615, 0.5961245496279397, 0.6051387321163697, 0.6054134636471917, 0.6049109598734357, 0.108879793997946, 0.10954784939332785, 0.11701506275743068, 0.10175026249362928, 0.11536454322026979, 0.10887791505830302, 0.1089133405792494, 0.1106310130486523, 0.10784375655459366, 0.09844613278749914, 0.10097891105331402, 0.09989233245394336, 0.09234414463961016, 0.09074263169587415, 0.0991237485084161, 0.11037309339210677, 0.10170364096574758, 0.10922836552149384, 0.9074913468443204, 0.8690895071820036, 0.9129890274260332, 0.9216710639492137, 0.8619770223107548, 0.9128839781387894, 0.8755064972285934, 0.9108026244004872, 0.9197377930373642, 0.4375400930548615, 0.4149386387866254, 0.41487661225728567, 0.4715292780957939, 0.4336194712956709, 0.46031858537992754, 0.4404006378928911, 0.4193846957716846, 0.3940058562115011, 0.7656022806251299, 0.7324129688497076, 0.7379270011508478, 0.7330339111033342, 0.801489270945185, 0.7927798724702598, 0.72750114444942, 0.7625461968975034, 0.7577437302100279, 0.21980065455241204, 0.18377229267111983, 0.29881086474166085, 0.31891432326450286, 0.19676850736002593, 0.19517589376265743, 0.21078865401078817, 0.3048709441576981, 0.24567069965952937, 0.15202718332711507, 0.19107461761717237, 0.4892231635335387, 0.2074442046343551, 0.30126587766319546, 0.18808491173680086, 0.173114137109593, 0.16720681651260239, 0.16188957918149116, 0.30139666603286286, 0.37989686369462006, 0.4444630609038531, 0.33980601151501755, 0.3916486277133032, 0.358441520483776, 0.3317522787156114, 0.42255839722226163, 0.3555569202217702, 0.49609047809359874, 0.5960064362237826, 0.5191297341414027, 0.4768676449331257, 0.47012898419984706, 0.546912964492098, 0.5089546079315568, 0.5425239758066953, 0.5326331080245167, 0.108617333621012, 0.08561527735184149, 0.15656070659004184, 0.20023413190983896, 0.15930270415738756, 0.2522341805619105, 0.1030094457909978, 0.1334742672605309, 0.17757349221626262, 0.2812372566724458, 0.3022304150681002, 0.302636247844396, 0.3068555623522813, 0.31181122590459565, 0.32655959254293143, 0.29522339768441974, 0.2861333203367308, 0.29365475118173723, 0.660242141833449, 0.6873550680078344, 0.673191609522005, 0.6660273443004983, 0.6681521721890844, 0.6759145523723527, 0.6837159445622254, 0.6732888890169537, 0.7130978160960958, 0.10213005448410473, 0.10346724156078835, 0.09301537532593807, 0.10346220978154397, 0.08944270398731091, 0.1029369032296712, 0.10833130067825492, 0.09354249845935358, 0.09248533342434506, 0.14260793939445937, 0.12543179895116574, 0.15046985422615655, 0.16224966784169215, 0.14038109828818124, 0.14148760962706297, 0.14973496150697096, 0.16455874473150722, 0.12567618907605504, 0.3678535611241692, 0.39649152372754803, 0.37665490388680056, 0.3958901489297013, 0.41517885844649594, 0.409403613214559, 0.3995482868458574, 0.4267428978485077, 0.4142678200879619, 0.31239400083840374, 0.34444873242037677, 0.3120157048096336, 0.27301353329044764, 0.3006256582464826, 0.2987737491359146, 0.3235156006813854, 0.33767481959012324, 0.3357369874995171, 0.186957532795072, 0.18656472767174792, 0.2061774312816237, 0.23027016850234727, 0.19369556833993862, 0.18061718713024288, 0.1783190351653513, 0.19244354617934978, 0.19271600648132237, 0.1979434956129058, 0.2177309985971504, 0.2060805454068737, 0.22343922094682356, 0.18029676845416676, 0.32690365215556616, 0.1987937204759722, 0.19508775738166872, 0.21283288345014562, 0.17420908735393592, 0.7368208642847723, 0.19331867099851174, 0.6137659088152114, 0.18875691349866797, 0.17547510578477854, 0.3559741841199401, 0.6965046478255774, 0.1708688498414178, 0.6012197443074362, 0.19727927302018333, 0.20160799901593807, 0.6209679174579396, 0.1880266733832232, 0.19832872520190836, 0.6108381529149217, 0.15114563920796376, 0.20744758229785476, 0.2017234396334706, 0.1746507340209602, 0.18202945134769777, 0.19096184516531678, 0.18864802417231608, 0.19182061604581158, 0.19165387305638482, 0.20277637086951772, 0.1796967961349104, 0.07766261209045455, 0.08650364280565515, 0.0755563957324975, 0.08305469700379853, 0.08571918318065985, 0.08140471215987599, 0.07977786552506272, 0.09528347968300555, 0.09080795792607566]}, "mutation_prompt": null}
{"id": "a5486483-74d7-44a3-8bff-01a4fe3cbba1", "solution": "import numpy as np\n\nclass HQADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n\n    def quantum_initialize(self):\n        # Quantum-inspired initialization\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation with best individual consideration\n                if self.best_solution is not None:\n                    # Use the best solution for mutation guidance\n                    x_best = self.best_solution\n                else:\n                    x_best = population[np.argmin(fitness)]\n                \n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                    # Update best solution\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HQADE", "description": "The Hybrid Quantum-Inspired Adaptive Differential Evolution (HQADE) algorithm integrates quantum-inspired initialization and adaptive mutation control for enhanced exploration and exploitation.", "configspace": "", "generation": 24, "fitness": 0.4445626982591574, "feedback": "The algorithm HQADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.31.", "error": "", "parent_id": "95bf1369-736a-418b-919c-76b865559f39", "metadata": {"aucs": [0.8842640863808741, 0.883899044054407, 0.8886627063207696, 0.8855090954232592, 0.8869843626584002, 0.8890228262375042, 0.8805840574712426, 0.8764053448004824, 0.8926901667522695, 0.7806376014039913, 0.770651108774141, 0.7389906911370805, 0.7717241044991554, 0.7579698632705907, 0.7308316995877338, 0.7784772950661242, 0.720341492454824, 0.7587551884526138, 0.11327624125404434, 0.12926420940182992, 0.15362474840868112, 0.14167173047748038, 0.1157502301871064, 0.11950984128619169, 0.15592840736274283, 0.10801854517849496, 0.15522436391988936, 0.08908030036230141, 0.10615027089184292, 0.10869033535624861, 0.11187815804183576, 0.10680014618409928, 0.13686128210754656, 0.05969714430749007, 0.13772014765256047, 0.08095591037480443, 0.9836830017554209, 0.9859329194783967, 0.9858709187819495, 0.9810465135759643, 0.9779150889492112, 0.9869618126098814, 0.9843712975537428, 0.9842171043114838, 0.9868436051201018, 0.7742857976594071, 0.7666398039892717, 0.7476905803216634, 0.780821767296433, 0.798144823010646, 0.7382702677366337, 0.7465453631562227, 0.7444960213095307, 0.7540795987381117, 0.21927419156881112, 0.22804592099648158, 0.8897009272607233, 0.2779522446873768, 0.2111876453070981, 0.2776825842762817, 0.8986024671685774, 0.9090442636516916, 0.8790730247963248, 0.13065815336639464, 0.13170583244617518, 0.12742004084795733, 0.681077589290994, 0.695272293075778, 0.7267037068420126, 0.7451292138921911, 0.7444965505028045, 0.7406354311615826, 0.7494411595334689, 0.7462329087085167, 0.7422458253511484, 0.7533741013073976, 0.767243917155394, 0.7292235733012473, 0.13188870977745337, 0.724927965050431, 0.13286565937385553, 0.6303948913673167, 0.5826151756759246, 0.6774888019587142, 0.7533275016160212, 0.5926793078574859, 0.720552117197171, 0.6253833171349235, 0.6899093337290559, 0.7219240182498086, 0.7540679360077198, 0.7351168644525384, 0.7701089225887581, 0.7610960526787327, 0.018517248271945896, 0.72345197351987, 0.6576325459407404, 0.6620137854366949, 0.759629224924905, 0.1775681519516824, 0.08989157628086653, 0.6247265919750349, 0.46471345465999236, 0.07659668266808672, 0.4871587306973306, 0.4518836953947337, 0.14657404564897025, 0.2466039237217449, 0.6300342968440023, 0.5872249378053847, 0.6314145513239096, 0.6009213527344013, 0.6370667265445398, 0.6175040800026887, 0.5232053936606378, 0.5607234161977646, 0.6240087940317021, 0.8450564232086041, 0.8355083550633, 0.8457034219454184, 0.8233656214260852, 0.8418101240182152, 0.8360998954291328, 0.8602688514203268, 0.8410427850526965, 0.8403146105114817, 0.10363415078441307, 0.09927295992586627, 0.17590459973893557, 0.10507782137467037, 0.08444145774827105, 0.09658064701146674, 0.15260568943581876, 0.1037185777436942, 0.07101579286474247, 0.15650849775597053, 0.2883977108075303, 0.16719008222225784, 0.17701805133915371, 0.17376327736529906, 0.2692548820135475, 0.18943587806589313, 0.18608252471756914, 0.26277616984075414, 0.4795929832646221, 0.4071837462846374, 0.5818413202118111, 0.5862113626025665, 0.36732219830122503, 0.4308867891266782, 0.5394036871985944, 0.6212485838240527, 0.30879229645643913, 0.2675046369731233, 0.243021726688328, 0.4058548763601394, 0.5120902404900637, 0.3591104857758084, 0.3042297900427203, 0.3101650206902875, 0.2435123005614872, 0.37392405797529016, 0.17785334970059996, 0.19286150381444622, 0.19978527797849532, 0.20516907410553176, 0.2203952726164493, 0.18944761004511346, 0.20328411802907054, 0.22782105226379912, 0.21921550387914912, 0.19722455821952833, 0.1900645564574288, 0.202499707527949, 0.19430345102387914, 0.2262885517742388, 0.25003229002052485, 0.18676274662569003, 0.8305168320200473, 0.1890374963419582, 0.1746361317664843, 0.1678729493223785, 0.10631527801624818, 0.17188735126748067, 0.15267471170163538, 0.19804986237495148, 0.13637931632729472, 0.17022484102444269, 0.9219657290135962, 0.15697710058310477, 0.1134477081592773, 0.21172347087677612, 0.21003189580298542, 0.16820901275161737, 0.16822191642212125, 0.10504255690197317, 0.10457341830888345, 0.08202793555212373, 0.23079298077266075, 0.19762444112865296, 0.20083311197537923, 0.1904200655954611, 0.21680643813143619, 0.2000076993984291, 0.23721301759512348, 0.22777551929897577, 0.21807663274748756, 0.11116491275394946, 0.08672568344829501, 0.10574834788115384, 0.09745137899920042, 0.09431700976437829, 0.09783891619155782, 0.10115348496331555, 0.0990095438200036, 0.09686018493157611]}, "mutation_prompt": null}
{"id": "2af39d6f-a9ca-44bc-88d2-4728a81ece3a", "solution": "import numpy as np\n\nclass HQADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n\n    def quantum_initialize(self):\n        # Quantum-inspired initialization\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation with best individual consideration\n                if self.best_solution is not None:\n                    # Use the best solution for mutation guidance\n                    x_best = self.best_solution\n                else:\n                    x_best = population[np.argmin(fitness)]\n                \n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                    # Update best solution\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HQADE", "description": "The Hybrid Quantum-Inspired Adaptive Differential Evolution (HQADE) algorithm integrates quantum-inspired initialization and adaptive mutation control for enhanced exploration and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a5486483-74d7-44a3-8bff-01a4fe3cbba1", "metadata": {"aucs": [0.8842640863808741, 0.883899044054407, 0.8886627063207696, 0.8855090954232592, 0.8869843626584002, 0.8890228262375042, 0.8805840574712426, 0.8764053448004824, 0.8926901667522695, 0.7806376014039913, 0.770651108774141, 0.7389906911370805, 0.7717241044991554, 0.7579698632705907, 0.7308316995877338, 0.7784772950661242, 0.720341492454824, 0.7587551884526138, 0.11327624125404434, 0.12926420940182992, 0.15362474840868112, 0.14167173047748038, 0.1157502301871064, 0.11950984128619169, 0.15592840736274283, 0.10801854517849496, 0.15522436391988936, 0.08908030036230141, 0.10615027089184292, 0.10869033535624861, 0.11187815804183576, 0.10680014618409928, 0.13686128210754656, 0.05969714430749007, 0.13772014765256047, 0.08095591037480443, 0.9836830017554209, 0.9859329194783967, 0.9858709187819495, 0.9810465135759643, 0.9779150889492112, 0.9869618126098814, 0.9843712975537428, 0.9842171043114838, 0.9868436051201018, 0.7742857976594071, 0.7666398039892717, 0.7476905803216634, 0.780821767296433, 0.798144823010646, 0.7382702677366337, 0.7465453631562227, 0.7444960213095307, 0.7540795987381117, 0.21927419156881112, 0.22804592099648158, 0.8897009272607233, 0.2779522446873768, 0.2111876453070981, 0.2776825842762817, 0.8986024671685774, 0.9090442636516916, 0.8790730247963248, 0.13065815336639464, 0.13170583244617518, 0.12742004084795733, 0.681077589290994, 0.695272293075778, 0.7267037068420126, 0.7451292138921911, 0.7444965505028045, 0.7406354311615826, 0.7494411595334689, 0.7462329087085167, 0.7422458253511484, 0.7533741013073976, 0.767243917155394, 0.7292235733012473, 0.13188870977745337, 0.724927965050431, 0.13286565937385553, 0.6303948913673167, 0.5826151756759246, 0.6774888019587142, 0.7533275016160212, 0.5926793078574859, 0.720552117197171, 0.6253833171349235, 0.6899093337290559, 0.7219240182498086, 0.7540679360077198, 0.7351168644525384, 0.7701089225887581, 0.7610960526787327, 0.018517248271945896, 0.72345197351987, 0.6576325459407404, 0.6620137854366949, 0.759629224924905, 0.1775681519516824, 0.08989157628086653, 0.6247265919750349, 0.46471345465999236, 0.07659668266808672, 0.4871587306973306, 0.4518836953947337, 0.14657404564897025, 0.2466039237217449, 0.6300342968440023, 0.5872249378053847, 0.6314145513239096, 0.6009213527344013, 0.6370667265445398, 0.6175040800026887, 0.5232053936606378, 0.5607234161977646, 0.6240087940317021, 0.8450564232086041, 0.8355083550633, 0.8457034219454184, 0.8233656214260852, 0.8418101240182152, 0.8360998954291328, 0.8602688514203268, 0.8410427850526965, 0.8403146105114817, 0.10363415078441307, 0.09927295992586627, 0.17590459973893557, 0.10507782137467037, 0.08444145774827105, 0.09658064701146674, 0.15260568943581876, 0.1037185777436942, 0.07101579286474247, 0.15650849775597053, 0.2883977108075303, 0.16719008222225784, 0.17701805133915371, 0.17376327736529906, 0.2692548820135475, 0.18943587806589313, 0.18608252471756914, 0.26277616984075414, 0.4795929832646221, 0.4071837462846374, 0.5818413202118111, 0.5862113626025665, 0.36732219830122503, 0.4308867891266782, 0.5394036871985944, 0.6212485838240527, 0.30879229645643913, 0.2675046369731233, 0.243021726688328, 0.4058548763601394, 0.5120902404900637, 0.3591104857758084, 0.3042297900427203, 0.3101650206902875, 0.2435123005614872, 0.37392405797529016, 0.17785334970059996, 0.19286150381444622, 0.19978527797849532, 0.20516907410553176, 0.2203952726164493, 0.18944761004511346, 0.20328411802907054, 0.22782105226379912, 0.21921550387914912, 0.19722455821952833, 0.1900645564574288, 0.202499707527949, 0.19430345102387914, 0.2262885517742388, 0.25003229002052485, 0.18676274662569003, 0.8305168320200473, 0.1890374963419582, 0.1746361317664843, 0.1678729493223785, 0.10631527801624818, 0.17188735126748067, 0.15267471170163538, 0.19804986237495148, 0.13637931632729472, 0.17022484102444269, 0.9219657290135962, 0.15697710058310477, 0.1134477081592773, 0.21172347087677612, 0.21003189580298542, 0.16820901275161737, 0.16822191642212125, 0.10504255690197317, 0.10457341830888345, 0.08202793555212373, 0.23079298077266075, 0.19762444112865296, 0.20083311197537923, 0.1904200655954611, 0.21680643813143619, 0.2000076993984291, 0.23721301759512348, 0.22777551929897577, 0.21807663274748756, 0.11116491275394946, 0.08672568344829501, 0.10574834788115384, 0.09745137899920042, 0.09431700976437829, 0.09783891619155782, 0.10115348496331555, 0.0990095438200036, 0.09686018493157611]}, "mutation_prompt": null}
{"id": "73829dce-d7ad-4e75-a884-750ffda709dd", "solution": "import numpy as np\n\nclass EQIADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F_min, self.F_max = 0.4, 0.9  # Differential weight bounds\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n\n    def hybrid_initialize(self):\n        # Hybrid quantum-greedy initialization\n        q_population = np.random.rand(self.pop_size, self.dim)\n        greedy_factor = 0.7\n        random_part = self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n        greedy_part = np.clip(self.best_solution + greedy_factor * (self.upper_bound - self.lower_bound) * (np.random.rand(self.pop_size, self.dim) - 0.5), self.lower_bound, self.upper_bound)\n        return np.where(np.random.rand(self.pop_size, 1) < 0.5, random_part, greedy_part)\n\n    def __call__(self, func):\n        # Initialize population\n        if self.best_solution is None:\n            population = self.hybrid_initialize()\n        else:\n            population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy\n            self.F = np.random.uniform(self.F_min, self.F_max)\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation with random individual consideration\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                    # Update best solution\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EQIADE", "description": "The Enhanced Quantum-Inspired Adaptive Differential Evolution (EQIADE) algorithm optimizes exploration with adaptive differential weights and hybrid quantum-greedy initialization.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "a5486483-74d7-44a3-8bff-01a4fe3cbba1", "metadata": {}, "mutation_prompt": null}
{"id": "15299c98-aa04-4d67-ba83-773545714fb2", "solution": "import numpy as np\n\nclass EQADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 5 * dim  # Adjusted initial population size\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n\n    def quantum_initialize(self):\n        # Quantum-inspired initialization\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy with elitist adjustment\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n                if eval_count % (self.pop_size * 2) == 0:  # Adjust population size dynamically\n                    self.pop_size = max(5, int(self.pop_size * 0.9))\n                    population = population[:self.pop_size]\n                    fitness = fitness[:self.pop_size]\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation with best individual consideration\n                if self.best_solution is not None:\n                    x_best = self.best_solution\n                else:\n                    x_best = population[np.argmin(fitness)]\n                \n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 100:  # Maintain limited memory size\n                        self.memory = sorted(self.memory, key=lambda x: x[0])[:50]  # Elitist memory culling\n\n                    # Update best solution\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EQADE", "description": "The Enhanced Quantum-Inspired Adaptive Differential Evolution (EQADE) algorithm incorporates dynamic population size adjustment and elitist memory management for improved convergence and solution quality.", "configspace": "", "generation": 27, "fitness": 0.36713214379894893, "feedback": "The algorithm EQADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.31.", "error": "", "parent_id": "a5486483-74d7-44a3-8bff-01a4fe3cbba1", "metadata": {"aucs": [0.9425541600853242, 0.94140875950253, 0.9460778226336334, 0.9408534082897324, 0.9276727491465029, 0.9456414263181442, 0.18340709976474467, 0.9422712353459304, 0.9402392944379486, 0.8404134221354972, 9.999999999998899e-05, 0.8646351078735497, 0.8637427000423032, 0.780178323938874, 0.8879912357148579, 0.8811370644380816, 0.8763015931672957, 0.8599438806533118, 0.16407076901551032, 0.10064198657614687, 0.08605489196560323, 0.16295006407567436, 0.11855841827716218, 0.12554102235974263, 0.1475030361452655, 0.10112949325676746, 0.11857803599764771, 0.09702005096645883, 0.11815972120749407, 0.09304688448032561, 0.12609222363897132, 0.09707634400416731, 0.07245502672597448, 0.11064907774998978, 0.11132281189481252, 0.09723476703938905, 0.9741959819313177, 0.990541416319099, 0.9547979133254885, 0.9818860007486103, 0.9804562286928966, 0.9852034109746324, 0.9796571691794426, 0.9794703795450225, 0.9897804917257692, 0.8241285642550373, 0.8822050850364263, 0.8927576328409192, 0.8765947850829083, 0.8687870316343977, 0.8871036012217826, 0.8727525708318146, 0.8710881723769457, 0.8825040758633874, 0.39178570403526425, 0.2157797584711868, 0.21344834578981786, 0.19473306659258927, 0.19397710442852345, 0.21113380398418535, 0.12461743335921127, 0.4082340052957337, 0.13589760488266367, 0.7550413519508371, 0.7334072149192656, 0.7451865759635892, 0.13424121743000672, 0.10923954346337272, 0.664321084605311, 0.1367723519987314, 0.8980331583249973, 0.7702369657123909, 0.5034399878972855, 0.13611349385843674, 0.135507896893446, 0.13606274386998207, 0.8052285043530727, 0.7203685051948165, 0.7814037949375525, 0.7946103171515231, 0.7206389208595577, 0.16974456067653632, 0.06878569054246231, 0.2564905373465296, 0.07513234020116966, 0.061925554948487616, 0.27183595914520986, 0.15700629096659335, 0.04574568198725959, 0.2557853626447423, 0.1944125858119815, 0.12226053768045242, 0.1927336138029594, 0.12772399231703346, 0.012331656981635075, 0.03561288527928641, 0.16317653970385504, 0.09553050426080523, 0.09140671214990614, 0.18976011366379963, 0.22204739230765447, 0.22601963763812372, 0.5079694299781701, 0.08409148039063308, 0.35294255512224504, 0.10809363810924533, 0.19134347107277827, 0.43606824471765504, 0.4777580507809045, 0.3253082576111007, 0.419136369095335, 0.23918027181963863, 0.5115412665268542, 0.4678093669661285, 0.4079339231771143, 0.32217377477626274, 0.40540399498199475, 0.7345114914230267, 0.6813176464757107, 0.6401466460504952, 0.7063255113171738, 0.7535078050688068, 0.7243884707926668, 0.7204139953536031, 0.7442299474265289, 0.6648192891446507, 0.11810552561158039, 0.11944054950647154, 0.09696364842269545, 0.08667243235079225, 0.05769385521446835, 0.1273695137791785, 0.12227414576940532, 0.08074528325173747, 0.12710930363222628, 0.26664585822312137, 0.21929535447923698, 0.22131345950653936, 0.24803824750321457, 0.36942558441046514, 0.4504262980746033, 0.22901299451719348, 0.20613086308346928, 0.2978827588883469, 0.2611419054605528, 0.2841160872179672, 0.3494517585302076, 0.3354232822743629, 0.22303194086477973, 0.1951183529287065, 0.1797096976584246, 0.21734588610421757, 0.26174683716151625, 0.10386459679401383, 0.11359558062047559, 0.1610554184959605, 0.16520266523217475, 0.25978660910764884, 0.3482941845406099, 0.25473016770579193, 0.2894932483745756, 0.30532595279568, 0.1835180728364687, 0.17472823974550777, 0.2126735011590074, 0.204333338972581, 0.1398057670163223, 0.19834017786290337, 0.20917546726198621, 0.2547289259907751, 0.20059370754062233, 0.2123394521411922, 0.17086624300444508, 0.19095678465785948, 0.189631501244792, 0.17211377771040404, 0.194090813248592, 0.22759328149756197, 0.19835302426565082, 0.18513025510481562, 0.18880676627851511, 0.17062346126367411, 0.12469842504375939, 0.17777365288883396, 0.17961214304343942, 0.9458974080076493, 0.16986171419127172, 0.13732659069800024, 0.958615402179705, 0.9230655681541832, 0.15756455367044764, 0.11335681602103631, 0.2128405232439684, 0.16944071041368747, 0.9197486847655142, 0.10504564670976702, 0.15672248494784302, 0.09461507111392331, 0.17965849503070552, 0.18299997823022163, 0.2227052975570336, 0.18424164807698984, 0.19614429646681397, 0.1926483499598981, 0.17198960605228164, 0.18827042076266298, 0.19938727728581085, 0.08600005383538245, 0.06721905163697484, 0.05308328059281753, 0.05789148543386635, 0.08297440072296813, 0.07874878116867001, 0.05937984613515168, 0.09776562833851221, 0.10395943638726346]}, "mutation_prompt": null}
{"id": "5f623ee1-d359-409d-9f90-a871f3119fd8", "solution": "import numpy as np\n\nclass HQADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n\n    def quantum_initialize(self):\n        # Quantum-inspired initialization\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation with best individual consideration\n                if self.best_solution is not None:\n                    # Use the best solution for mutation guidance\n                    x_best = self.best_solution\n                else:\n                    x_best = population[np.argmin(fitness)]\n                \n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                    # Update best solution\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HQADE", "description": "The Hybrid Quantum-Inspired Adaptive Differential Evolution (HQADE) algorithm integrates quantum-inspired initialization and adaptive mutation control for enhanced exploration and exploitation.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a5486483-74d7-44a3-8bff-01a4fe3cbba1", "metadata": {"aucs": [0.8842640863808741, 0.883899044054407, 0.8886627063207696, 0.8855090954232592, 0.8869843626584002, 0.8890228262375042, 0.8805840574712426, 0.8764053448004824, 0.8926901667522695, 0.7806376014039913, 0.770651108774141, 0.7389906911370805, 0.7717241044991554, 0.7579698632705907, 0.7308316995877338, 0.7784772950661242, 0.720341492454824, 0.7587551884526138, 0.11327624125404434, 0.12926420940182992, 0.15362474840868112, 0.14167173047748038, 0.1157502301871064, 0.11950984128619169, 0.15592840736274283, 0.10801854517849496, 0.15522436391988936, 0.08908030036230141, 0.10615027089184292, 0.10869033535624861, 0.11187815804183576, 0.10680014618409928, 0.13686128210754656, 0.05969714430749007, 0.13772014765256047, 0.08095591037480443, 0.9836830017554209, 0.9859329194783967, 0.9858709187819495, 0.9810465135759643, 0.9779150889492112, 0.9869618126098814, 0.9843712975537428, 0.9842171043114838, 0.9868436051201018, 0.7742857976594071, 0.7666398039892717, 0.7476905803216634, 0.780821767296433, 0.798144823010646, 0.7382702677366337, 0.7465453631562227, 0.7444960213095307, 0.7540795987381117, 0.21927419156881112, 0.22804592099648158, 0.8897009272607233, 0.2779522446873768, 0.2111876453070981, 0.2776825842762817, 0.8986024671685774, 0.9090442636516916, 0.8790730247963248, 0.13065815336639464, 0.13170583244617518, 0.12742004084795733, 0.681077589290994, 0.695272293075778, 0.7267037068420126, 0.7451292138921911, 0.7444965505028045, 0.7406354311615826, 0.7494411595334689, 0.7462329087085167, 0.7422458253511484, 0.7533741013073976, 0.767243917155394, 0.7292235733012473, 0.13188870977745337, 0.724927965050431, 0.13286565937385553, 0.6303948913673167, 0.5826151756759246, 0.6774888019587142, 0.7533275016160212, 0.5926793078574859, 0.720552117197171, 0.6253833171349235, 0.6899093337290559, 0.7219240182498086, 0.7540679360077198, 0.7351168644525384, 0.7701089225887581, 0.7610960526787327, 0.018517248271945896, 0.72345197351987, 0.6576325459407404, 0.6620137854366949, 0.759629224924905, 0.1775681519516824, 0.08989157628086653, 0.6247265919750349, 0.46471345465999236, 0.07659668266808672, 0.4871587306973306, 0.4518836953947337, 0.14657404564897025, 0.2466039237217449, 0.6300342968440023, 0.5872249378053847, 0.6314145513239096, 0.6009213527344013, 0.6370667265445398, 0.6175040800026887, 0.5232053936606378, 0.5607234161977646, 0.6240087940317021, 0.8450564232086041, 0.8355083550633, 0.8457034219454184, 0.8233656214260852, 0.8418101240182152, 0.8360998954291328, 0.8602688514203268, 0.8410427850526965, 0.8403146105114817, 0.10363415078441307, 0.09927295992586627, 0.17590459973893557, 0.10507782137467037, 0.08444145774827105, 0.09658064701146674, 0.15260568943581876, 0.1037185777436942, 0.07101579286474247, 0.15650849775597053, 0.2883977108075303, 0.16719008222225784, 0.17701805133915371, 0.17376327736529906, 0.2692548820135475, 0.18943587806589313, 0.18608252471756914, 0.26277616984075414, 0.4795929832646221, 0.4071837462846374, 0.5818413202118111, 0.5862113626025665, 0.36732219830122503, 0.4308867891266782, 0.5394036871985944, 0.6212485838240527, 0.30879229645643913, 0.2675046369731233, 0.243021726688328, 0.4058548763601394, 0.5120902404900637, 0.3591104857758084, 0.3042297900427203, 0.3101650206902875, 0.2435123005614872, 0.37392405797529016, 0.17785334970059996, 0.19286150381444622, 0.19978527797849532, 0.20516907410553176, 0.2203952726164493, 0.18944761004511346, 0.20328411802907054, 0.22782105226379912, 0.21921550387914912, 0.19722455821952833, 0.1900645564574288, 0.202499707527949, 0.19430345102387914, 0.2262885517742388, 0.25003229002052485, 0.18676274662569003, 0.8305168320200473, 0.1890374963419582, 0.1746361317664843, 0.1678729493223785, 0.10631527801624818, 0.17188735126748067, 0.15267471170163538, 0.19804986237495148, 0.13637931632729472, 0.17022484102444269, 0.9219657290135962, 0.15697710058310477, 0.1134477081592773, 0.21172347087677612, 0.21003189580298542, 0.16820901275161737, 0.16822191642212125, 0.10504255690197317, 0.10457341830888345, 0.08202793555212373, 0.23079298077266075, 0.19762444112865296, 0.20083311197537923, 0.1904200655954611, 0.21680643813143619, 0.2000076993984291, 0.23721301759512348, 0.22777551929897577, 0.21807663274748756, 0.11116491275394946, 0.08672568344829501, 0.10574834788115384, 0.09745137899920042, 0.09431700976437829, 0.09783891619155782, 0.10115348496331555, 0.0990095438200036, 0.09686018493157611]}, "mutation_prompt": null}
{"id": "f7045e9d-6e68-4bf6-9fbe-daa4a834751b", "solution": "import numpy as np\n\nclass HQADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n        self.archive = []  # Archive to store promising solutions\n\n    def quantum_initialize(self):\n        # Quantum-inspired initialization\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy with archive influence\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n\n            if len(self.archive) > 0:\n                archive_choice = np.random.choice(self.archive)\n                archive_influence = True\n            else:\n                archive_choice = None\n                archive_influence = False\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation with best individual consideration\n                if self.best_solution is not None:\n                    x_best = self.best_solution\n                else:\n                    x_best = population[np.argmin(fitness)]\n                \n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                if archive_influence:\n                    mutant = mutant + 0.1 * (archive_choice - mutant)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                    self.archive.append(trial)\n                    if len(self.archive) > 20:  # Maintain limited archive size\n                        self.archive.pop(0)\n\n                    # Update best solution\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HQADE", "description": "The Hybrid Quantum-Inspired Adaptive Differential Evolution (HQADE) algorithm optimizes by combining quantum-inspired initialization, adaptive strategies, and dynamic archive-based exploitation.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "a5486483-74d7-44a3-8bff-01a4fe3cbba1", "metadata": {}, "mutation_prompt": null}
{"id": "7570d163-2e49-4c72-958d-7b937d6077b8", "solution": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n\n    def quantum_initialize(self):\n        # Quantum-inspired initialization\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            # Adaptive mutation strategy\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory]) - 0.1 * np.random.rand()\n\n            new_population = np.copy(population)\n            for i in range(self.pop_size):\n                # Mutation with random individual consideration\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                # Crossover with dynamic strategy\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:  # Maintain limited memory size\n                        self.memory.pop(0)\n\n                    # Update best solution\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            # Dynamic population resizing\n            if eval_count < self.budget and np.random.rand() < 0.1:\n                extra_pop_size = int(self.pop_size * 0.1)\n                extra_population = self.quantum_initialize()[:extra_pop_size]\n                extra_fitness = np.array([func(ind) for ind in extra_population])\n                population = np.vstack((new_population, extra_population))\n                fitness = np.concatenate((fitness, extra_fitness))\n                self.pop_size += extra_pop_size\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE", "description": "The Adaptive Quantum-Inspired Differential Evolution (AQIDE) enhances diversity and convergence by integrating adaptive scaling factors and dynamic population resizing.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 53 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 53 is out of bounds for axis 0 with size 50')", "parent_id": "a5486483-74d7-44a3-8bff-01a4fe3cbba1", "metadata": {}, "mutation_prompt": null}
{"id": "36840476-1388-4f1e-b675-38fe4f31bd3a", "solution": "import numpy as np\n\nclass HQADE_EP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n        self.elite_percentage = 0.1  # Preserve top 10% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:\n                        self.memory.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HQADE_EP", "description": "The Hybrid Quantum-Inspired Adaptive Differential Evolution with Elite Preservation (HQADE-EP) enhances exploration, adapts strategy parameters, and preserves elite solutions for improved convergence.", "configspace": "", "generation": 31, "fitness": 0.4539804130398884, "feedback": "The algorithm HQADE_EP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.31.", "error": "", "parent_id": "a5486483-74d7-44a3-8bff-01a4fe3cbba1", "metadata": {"aucs": [0.8837157770846177, 0.8865520139739698, 0.8837013547025891, 0.881943392133784, 0.8897431351415097, 0.8889482803429659, 0.892466745131764, 0.8892515368590049, 0.885565209314652, 0.78283780195957, 0.6946045766167843, 0.7523968220157217, 0.7716996587910347, 0.7776733644088087, 0.7849774073486733, 0.7590656974234158, 0.747551784030061, 0.690551659833988, 0.1504306269315997, 0.09519016918020529, 0.14029163105948173, 0.17416987331813183, 0.13973453840736927, 0.11652459674081439, 0.12616651291977177, 0.14907136287008305, 0.11352531406764388, 0.15112888544276815, 0.1072606720691952, 0.11500676968411461, 0.12123079309903928, 0.09468918573724583, 0.11840717113956745, 0.15705997197193033, 0.1264354392006244, 0.06967339558827057, 0.9783563112015343, 0.9775667648687938, 0.9821172028245514, 0.978349087901538, 0.9762803180366033, 0.9857508209654378, 0.9644348864438096, 0.9711352523700939, 0.9866675474024609, 0.7793087477187026, 0.7768749443706655, 0.7866241899062392, 0.7760849503222527, 0.7763946152934379, 0.767651740689718, 0.7826999884068333, 0.7761794423091871, 0.7609583229484601, 0.2290752957506046, 0.2253634217719639, 0.3560800170966987, 0.921307139457348, 0.8862747248528482, 0.9054055434881918, 0.23441221400074086, 0.3767879029245115, 0.8949101299000972, 0.7956938648454817, 0.6654248876171776, 0.1314275294884918, 0.6809228174882984, 0.7751542643173405, 0.7341428933877236, 0.13296041747542053, 0.7527722990550669, 0.7179184695705164, 0.7032451013154306, 0.6807705047290181, 0.6754826932693292, 0.7984087636671222, 0.7615099382828932, 0.6446763829349054, 0.6817035738359527, 0.7984107836341259, 0.1330187698486086, 0.7084422723803339, 0.6771628562646161, 0.5087035434536902, 0.5325657561804535, 0.04408390639019655, 0.7314991374572468, 0.7151273332487227, 0.7429259311950699, 0.08356110339466938, 0.7968729404350333, 0.8114300905033758, 0.08710240921366386, 0.7737704437490992, 0.6949949163089423, 0.5668588838863178, 0.6778891829776414, 0.8017712321012125, 0.7826572146131889, 0.3423974094837714, 0.12213621581808276, 0.09256312850165016, 0.4649143969666413, 0.19122202067088678, 0.5852624294427253, 0.16204015861892818, 0.2055922510212621, 0.2782466629981124, 0.6513394959104203, 0.6059540206743834, 0.568492140103281, 0.6491552432087621, 0.6606847450013009, 0.6137350005567941, 0.42322123092782604, 0.6199428872380333, 0.648226981846203, 0.8490444791570642, 0.8526758096894658, 0.8562580971269927, 0.8603194713346934, 0.8526372185701924, 0.8254629057811103, 0.8500910471092247, 0.8535907570462159, 0.8533630569031065, 0.12211548034209596, 0.12721601340951216, 0.10324363945947335, 0.08216425986375087, 0.115630064808667, 0.0680024752017141, 0.1791733969843825, 0.11785914165392786, 0.13059830426557784, 0.22079384855634754, 0.16426429913693974, 0.23501730116673603, 0.1863682457839212, 0.18171857852012274, 0.32825996271196456, 0.2818288239176998, 0.1982737548609027, 0.2535637182328546, 0.5183031455137299, 0.45138856436884744, 0.23915534119425652, 0.5328361862258658, 0.5589741095574261, 0.20889775986065962, 0.3075656211855209, 0.3396048021146474, 0.49194760856511244, 0.30276551939084106, 0.28587425216858386, 0.44809001966618467, 0.3733848100266912, 0.23292497641354115, 0.30022971368859885, 0.23509999145279759, 0.27692203129366166, 0.2839734889894223, 0.19306092516984064, 0.21691980343932482, 0.20810403206857564, 0.23169969463370443, 0.23755902963434306, 0.25469348351624965, 0.23230603982279185, 0.2173847263150095, 0.2639115052058214, 0.19928663942185665, 0.19017620693989234, 0.20523594141903878, 0.20120647757170496, 0.1907296167916076, 0.19711322056621383, 0.22456059172165121, 0.1888149790925423, 0.18153094072335507, 0.17671935185807275, 0.08863974160896393, 0.12276655225628641, 0.9207049800924187, 0.20016521515383578, 0.16919138157999003, 0.13656491433119078, 0.14819711393819868, 0.9220943492920719, 0.9225438648521384, 0.21176274658747452, 0.1685090062557958, 0.21202457085664828, 0.16754345816371918, 0.8914915005807815, 0.10518225544444215, 0.21229958636424795, 0.8894864046878594, 0.22634648843290828, 0.20178207898287737, 0.2253378580551877, 0.19914985099322224, 0.22413335686525393, 0.18695889124228338, 0.16716751257048945, 0.1778980515443802, 0.20959976584376017, 0.10648356812569748, 0.0925282326586605, 0.08264156110187681, 0.10533265752362386, 0.09966214057801259, 0.13626234953041838, 0.08845301439194553, 0.09389644269243946, 0.08999827698461416]}, "mutation_prompt": null}
{"id": "fab9f11f-794f-4a94-aa72-36dde6e596b9", "solution": "import numpy as np\n\nclass HQADE_EP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n        self.elite_percentage = 0.1  # Preserve top 10% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:\n                        self.memory.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HQADE_EP", "description": "The Hybrid Quantum-Inspired Adaptive Differential Evolution with Elite Preservation (HQADE-EP) enhances exploration, adapts strategy parameters, and preserves elite solutions for improved convergence.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "36840476-1388-4f1e-b675-38fe4f31bd3a", "metadata": {"aucs": [0.8837157770846177, 0.8865520139739698, 0.8837013547025891, 0.881943392133784, 0.8897431351415097, 0.8889482803429659, 0.892466745131764, 0.8892515368590049, 0.885565209314652, 0.78283780195957, 0.6946045766167843, 0.7523968220157217, 0.7716996587910347, 0.7776733644088087, 0.7849774073486733, 0.7590656974234158, 0.747551784030061, 0.690551659833988, 0.1504306269315997, 0.09519016918020529, 0.14029163105948173, 0.17416987331813183, 0.13973453840736927, 0.11652459674081439, 0.12616651291977177, 0.14907136287008305, 0.11352531406764388, 0.15112888544276815, 0.1072606720691952, 0.11500676968411461, 0.12123079309903928, 0.09468918573724583, 0.11840717113956745, 0.15705997197193033, 0.1264354392006244, 0.06967339558827057, 0.9783563112015343, 0.9775667648687938, 0.9821172028245514, 0.978349087901538, 0.9762803180366033, 0.9857508209654378, 0.9644348864438096, 0.9711352523700939, 0.9866675474024609, 0.7793087477187026, 0.7768749443706655, 0.7866241899062392, 0.7760849503222527, 0.7763946152934379, 0.767651740689718, 0.7826999884068333, 0.7761794423091871, 0.7609583229484601, 0.2290752957506046, 0.2253634217719639, 0.3560800170966987, 0.921307139457348, 0.8862747248528482, 0.9054055434881918, 0.23441221400074086, 0.3767879029245115, 0.8949101299000972, 0.7956938648454817, 0.6654248876171776, 0.1314275294884918, 0.6809228174882984, 0.7751542643173405, 0.7341428933877236, 0.13296041747542053, 0.7527722990550669, 0.7179184695705164, 0.7032451013154306, 0.6807705047290181, 0.6754826932693292, 0.7984087636671222, 0.7615099382828932, 0.6446763829349054, 0.6817035738359527, 0.7984107836341259, 0.1330187698486086, 0.7084422723803339, 0.6771628562646161, 0.5087035434536902, 0.5325657561804535, 0.04408390639019655, 0.7314991374572468, 0.7151273332487227, 0.7429259311950699, 0.08356110339466938, 0.7968729404350333, 0.8114300905033758, 0.08710240921366386, 0.7737704437490992, 0.6949949163089423, 0.5668588838863178, 0.6778891829776414, 0.8017712321012125, 0.7826572146131889, 0.3423974094837714, 0.12213621581808276, 0.09256312850165016, 0.4649143969666413, 0.19122202067088678, 0.5852624294427253, 0.16204015861892818, 0.2055922510212621, 0.2782466629981124, 0.6513394959104203, 0.6059540206743834, 0.568492140103281, 0.6491552432087621, 0.6606847450013009, 0.6137350005567941, 0.42322123092782604, 0.6199428872380333, 0.648226981846203, 0.8490444791570642, 0.8526758096894658, 0.8562580971269927, 0.8603194713346934, 0.8526372185701924, 0.8254629057811103, 0.8500910471092247, 0.8535907570462159, 0.8533630569031065, 0.12211548034209596, 0.12721601340951216, 0.10324363945947335, 0.08216425986375087, 0.115630064808667, 0.0680024752017141, 0.1791733969843825, 0.11785914165392786, 0.13059830426557784, 0.22079384855634754, 0.16426429913693974, 0.23501730116673603, 0.1863682457839212, 0.18171857852012274, 0.32825996271196456, 0.2818288239176998, 0.1982737548609027, 0.2535637182328546, 0.5183031455137299, 0.45138856436884744, 0.23915534119425652, 0.5328361862258658, 0.5589741095574261, 0.20889775986065962, 0.3075656211855209, 0.3396048021146474, 0.49194760856511244, 0.30276551939084106, 0.28587425216858386, 0.44809001966618467, 0.3733848100266912, 0.23292497641354115, 0.30022971368859885, 0.23509999145279759, 0.27692203129366166, 0.2839734889894223, 0.19306092516984064, 0.21691980343932482, 0.20810403206857564, 0.23169969463370443, 0.23755902963434306, 0.25469348351624965, 0.23230603982279185, 0.2173847263150095, 0.2639115052058214, 0.19928663942185665, 0.19017620693989234, 0.20523594141903878, 0.20120647757170496, 0.1907296167916076, 0.19711322056621383, 0.22456059172165121, 0.1888149790925423, 0.18153094072335507, 0.17671935185807275, 0.08863974160896393, 0.12276655225628641, 0.9207049800924187, 0.20016521515383578, 0.16919138157999003, 0.13656491433119078, 0.14819711393819868, 0.9220943492920719, 0.9225438648521384, 0.21176274658747452, 0.1685090062557958, 0.21202457085664828, 0.16754345816371918, 0.8914915005807815, 0.10518225544444215, 0.21229958636424795, 0.8894864046878594, 0.22634648843290828, 0.20178207898287737, 0.2253378580551877, 0.19914985099322224, 0.22413335686525393, 0.18695889124228338, 0.16716751257048945, 0.1778980515443802, 0.20959976584376017, 0.10648356812569748, 0.0925282326586605, 0.08264156110187681, 0.10533265752362386, 0.09966214057801259, 0.13626234953041838, 0.08845301439194553, 0.09389644269243946, 0.08999827698461416]}, "mutation_prompt": null}
{"id": "efc8a9bc-db04-470c-8f51-aadc8f978ff0", "solution": "import numpy as np\n\nclass HQADE_DEP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n        self.elite_percentage = 0.1  # Preserve top 10% elites\n        self.dynamic_adaptation_rate = 0.05  # Adaptation rate for elite percentage\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory]) * (1 + self.dynamic_adaptation_rate * (np.random.rand() - 0.5))\n\n            new_population = np.copy(population)\n            elite_count = max(1, int(self.pop_size * self.elite_percentage))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:\n                        self.memory.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n            self.elite_percentage = min(0.2, self.elite_percentage * (1 + self.dynamic_adaptation_rate * (np.random.rand() - 0.5)))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HQADE_DEP", "description": "The Hybrid Quantum-Inspired Adaptive Differential Evolution with Dynamic Elite Preservation (HQADE-DEP) introduces dynamic elite sizing and adaptive crossover for balanced exploration and exploitation.", "configspace": "", "generation": 33, "fitness": 0.3369307823615115, "feedback": "The algorithm HQADE_DEP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.23.", "error": "", "parent_id": "36840476-1388-4f1e-b675-38fe4f31bd3a", "metadata": {"aucs": [0.7199797141702506, 0.7193895203463974, 0.7039227397346002, 0.7157131550354653, 0.7099792927307105, 0.6947671145080495, 0.7052983863545901, 0.7354806611903422, 0.7014389118665529, 0.4863420112411192, 0.46367894435002877, 0.48230991492551656, 0.4833166166616354, 0.46922868880060753, 0.4817946807699819, 0.5276869434827127, 0.5045133689417711, 0.49644381033572305, 0.12269666452126893, 0.11430952070978107, 0.1159424714086672, 0.12379912515454272, 0.10565641971400397, 0.11468093423454595, 0.11395683122077449, 0.11155394447813227, 0.1057773439062557, 0.0997396437172482, 0.10965215591141897, 0.10406673355945806, 0.09856939261173647, 0.09885832556144747, 0.08912487895321797, 0.09818018648859073, 0.11144198450117115, 0.10603000597227019, 0.8233417192184884, 0.8735439028104476, 0.7124308440641184, 0.9232073216955072, 0.8653412269828539, 0.77170457339466, 0.8329295812203272, 0.8462703349649185, 0.9081523679551526, 0.3757185947108175, 0.2696341383702895, 0.31538304655695526, 0.33676068349199817, 0.3447251979711098, 0.33166720517182835, 0.3224119501432695, 0.38116860542827513, 0.2977882770014273, 0.6904804777061906, 0.6950264352334489, 0.6957099508277382, 0.7333062836704547, 0.7326453758599062, 0.7129575519949656, 0.7433966958025853, 0.6983323479973234, 0.7361549323048624, 0.27704504602906943, 0.16513395312566403, 0.26650235230839303, 0.19744040828545806, 0.14355010037351967, 0.17875995714976378, 0.3277937576428793, 0.18438316313629588, 0.2176525908789938, 0.10918411056649169, 0.19023023946838102, 0.1406297555414472, 0.18056679720537538, 0.21840222992448544, 0.23503156810895953, 0.22210675125951818, 0.1800690126447485, 0.1500479491754637, 0.3392255222133409, 0.2755281441433738, 0.26977463576142036, 0.3936447794381973, 0.29515201559743587, 0.2670561292988861, 0.2888085231883535, 0.2812290608868451, 0.3465107517926973, 0.47867269098252296, 0.48469192064739575, 0.49110698396721575, 0.5341743713844855, 0.4265255105388075, 0.45360705935377654, 0.5076515419037164, 0.4427047178713718, 0.39685479564362347, 0.08937107670569389, 0.154685989543217, 0.10544418212328077, 0.17742357222933425, 0.19630101076574158, 0.1493032243407395, 0.10208971950518886, 0.10040722857390483, 0.11196425961196144, 0.2577269630282012, 0.22786312486082694, 0.21816824414928926, 0.2658131628088686, 0.22781045955996404, 0.27465195199503756, 0.25657640491841016, 0.23074405182047109, 0.25099742600176533, 0.6453739687629361, 0.6275839515464093, 0.6297083410778344, 0.6392876734350121, 0.5975248013611625, 0.6343541278097484, 0.6367427215551398, 0.5871225636834765, 0.6056410807583014, 0.10983269531971707, 0.09389963896632725, 0.0832247045520893, 0.10094750705838029, 0.09570653107922567, 0.10252318338982946, 0.1083359659660853, 0.10291162739978243, 0.09857855844117147, 0.1616140172590509, 0.132693420900455, 0.14703651567049314, 0.14753946884636449, 0.14058805749669068, 0.15420977002779912, 0.13093584530659153, 0.1496082260680085, 0.14710199463067475, 0.3846208267979381, 0.37381111540391043, 0.3753042504967571, 0.3942704427008201, 0.3452209180311041, 0.3462092547607968, 0.3772780697982949, 0.4239288746554868, 0.3871518194113005, 0.3145568524720642, 0.27897257779007045, 0.2847626934804477, 0.27853206944326214, 0.2884446719270408, 0.29906010646850933, 0.29174319983014196, 0.3089770161669624, 0.3040172397982327, 0.22907128063414917, 0.1986704946927964, 0.19081111170965082, 0.18505500359161997, 0.18728040628608855, 0.19798759388261855, 0.20162257668897055, 0.19975574778744387, 0.1994571666650531, 0.19882378145613122, 0.20491540550351361, 0.23128930584040575, 0.18039436940613596, 0.18860598381663107, 0.2000643103987525, 0.1788651883568364, 0.18251587796478042, 0.28358082628174386, 0.6314687157193313, 0.7009794717887903, 0.1504464708175659, 0.7321472903544953, 0.690920049127177, 0.7741034254376538, 0.5615622334919947, 0.6053729475436049, 0.677109702048668, 0.6450849052873485, 0.20342874751200557, 0.6171841787037409, 0.20470721712444184, 0.1945090233980742, 0.6529327382124552, 0.7062176744472315, 0.19909532100587735, 0.20230895507456903, 0.18869879063318162, 0.19421936204886325, 0.20503837261573676, 0.19009870322280242, 0.1822454690583507, 0.20721504812952707, 0.1826348680021178, 0.1919420725750337, 0.18517985934368408, 0.0745341511262737, 0.07683517317498212, 0.07489597275583548, 0.08384115068714415, 0.07910528162732589, 0.08536719487965638, 0.07899986532129111, 0.08648658988168678, 0.08357499854197925]}, "mutation_prompt": null}
{"id": "33acda75-0948-4ff1-9736-20f1fa38afd9", "solution": "import numpy as np\n\nclass QADE_MEP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solutions = []  # Store multiple elite solutions\n        self.elite_percentage = 0.2  # Preserve top 20% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if not self.best_solutions else self.best_solutions[np.random.randint(len(self.best_solutions))]\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:\n                        self.memory.pop(0)\n\n                    if not self.best_solutions or trial_fitness < min(fitness[elite_indices]):\n                        self.best_solutions.append(trial)\n                        self.best_solutions.sort(key=func)\n                        if len(self.best_solutions) > 5:\n                            self.best_solutions.pop()\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QADE_MEP", "description": "The Quantum-Inspired Adaptive Differential Evolution with Multi-Elite Preservation (QADE-MEP) leverages multiple elite solutions for diversity, adapts parameters dynamically, and refines exploration for enhanced performance.", "configspace": "", "generation": 34, "fitness": 0.4479441209204814, "feedback": "The algorithm QADE_MEP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.31.", "error": "", "parent_id": "36840476-1388-4f1e-b675-38fe4f31bd3a", "metadata": {"aucs": [0.8894443938468382, 0.8921969237579835, 0.8999220900995231, 0.8967063524816058, 0.9005199196799341, 0.8835578362784834, 0.8930261033465167, 0.8885726440945634, 0.8842138011733811, 0.8101105815700049, 0.7987188877221862, 0.795788519177226, 0.7937838423190101, 9.999999999998899e-05, 0.8063822764387366, 0.798313739749374, 0.7705223287754213, 0.7942822499579365, 0.16395929345000437, 0.5572699408238079, 0.1420488493185027, 0.13023872021102656, 0.14283540613411716, 0.14889166031452772, 0.14380794594135582, 0.17313825994553533, 0.13588997286975724, 0.1371486454341737, 0.11271616509156679, 0.12006932728174946, 0.13609913006989105, 0.14560348599425366, 0.10367410465289373, 0.127347048268322, 0.0875195770329148, 0.16790448443421324, 0.9445938814089672, 0.9113245142208342, 0.9390317828489206, 0.9617534475367074, 0.9755586791813932, 0.9576698287777492, 0.9767588812017378, 0.9764838759950388, 0.9602916325917219, 0.06274794416174423, 0.7483071089276584, 0.7280223822818881, 0.7681459317918194, 0.7825896098589437, 0.7742136829182193, 0.7827620883907866, 0.7398824867385665, 0.7510983681475946, 0.22783631251174097, 0.3622579989103609, 0.7987205109381346, 0.21426061850694877, 0.07285119553694963, 0.9129164105515237, 0.8278615154409008, 0.882436373947623, 0.8346010696381939, 0.6108562984649617, 0.1330837795489348, 0.13351975422901619, 0.6209751545701412, 0.5034493247900595, 0.6290056314541556, 0.4926962316753657, 0.7163561588741816, 0.13391419560778195, 0.6636575559817661, 0.7824331249193683, 0.6919405187404841, 0.6982127639262548, 0.7524402141205546, 0.5573173737579162, 0.6920470531008196, 0.11982404074275677, 0.5095788964815513, 0.41190684564463753, 9.999999999998899e-05, 0.5906377418972185, 0.02096102781455722, 0.7201568850564216, 0.7254785036345279, 0.06541719027924642, 0.576052133428826, 0.6969375165724876, 0.8183710265425308, 0.7672856831136393, 0.7381261385021489, 0.6980049406948545, 0.8130451178770332, 0.7734024267817905, 0.7137736945797899, 0.7578222732759609, 0.664000213875633, 0.06933075110984133, 0.07430329223252208, 0.14489377850175478, 9.999999999998899e-05, 0.31595924069848846, 0.5121534609997302, 0.10652046910104196, 0.43671648505065785, 0.41810762077511066, 0.3507869286051831, 0.6434148639267963, 0.6462925618636286, 0.42258644035227766, 0.659405664833113, 0.6627875749389252, 0.6071481940222039, 0.5805006003902029, 0.6148403740008656, 0.8483379296437885, 0.8169293584889116, 0.8474347506967874, 0.8463954451113241, 0.858567479789325, 0.8475275671117851, 0.8406983309094443, 0.8526788163728103, 0.837853127773754, 0.118656987371339, 0.1173153939682181, 0.12122947103577608, 0.09564749322726906, 0.12323823202895168, 0.1204434739955863, 0.13481968674414602, 0.08730005431291066, 0.11795091094450905, 0.1761246719666567, 0.20024374853171234, 0.22709513559244987, 0.7293560381385413, 0.15248531922853004, 0.22026329753403362, 0.2763496603816029, 0.20997894098049807, 0.2506921604382616, 0.6622806413695377, 0.6567073930534024, 0.47765006330996307, 0.5593928517948981, 0.4440454785019008, 0.33889245595450646, 0.22858360305854497, 0.17377774300845283, 0.5225156334674934, 0.21766455381734018, 0.26391890504147075, 0.5030189660088412, 0.3297030609745023, 0.3049857659304418, 0.5823626320980558, 0.21411068363828423, 0.0997711199450243, 0.3220726698127566, 0.2400183687719315, 0.20491907625416905, 0.18644279918434414, 0.1891922714163461, 0.21571789261748753, 0.19384267429105084, 0.20217292330574932, 0.2128088354755201, 0.2469343189626939, 0.2037700678328963, 0.2153340188561954, 0.1922421164064031, 0.1835146883367934, 0.19302758984514312, 0.20535542299052734, 0.2442718563329811, 0.21842324994356455, 0.7734389589862486, 0.9146802334975663, 0.17413790805804563, 0.15381766045731604, 0.8636705602303074, 0.1565312782069621, 0.16926261011315058, 0.9074282291229929, 0.15046871420747443, 0.9284518370427177, 0.11045734838606058, 0.21171818818738253, 0.21144447469173888, 0.888405014826716, 0.16802816669717557, 0.15384443776208823, 0.21219342342946323, 0.8987748060046131, 0.1669162665364191, 0.2157952043318021, 0.21533983819772873, 0.19961747121672635, 0.20438067797010506, 0.1868555090558125, 0.19900445634337327, 0.20192960363869628, 0.19851157292896415, 0.1935654570623948, 0.0983655313591022, 0.0958574887125706, 0.09701667550898707, 0.09898050107103606, 0.0992253296780109, 0.08931454100257163, 0.09369070862686679, 0.03803354422653826, 0.0857816448603933]}, "mutation_prompt": null}
{"id": "106f4190-9123-4ed1-a059-31592301f562", "solution": "import numpy as np\n\nclass HQADE_EP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n        self.elite_percentage = 0.1  # Preserve top 10% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:\n                        self.memory.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HQADE_EP", "description": "The Hybrid Quantum-Inspired Adaptive Differential Evolution with Elite Preservation (HQADE-EP) enhances exploration, adapts strategy parameters, and preserves elite solutions for improved convergence.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "36840476-1388-4f1e-b675-38fe4f31bd3a", "metadata": {"aucs": [0.8837157770846177, 0.8865520139739698, 0.8837013547025891, 0.881943392133784, 0.8897431351415097, 0.8889482803429659, 0.892466745131764, 0.8892515368590049, 0.885565209314652, 0.78283780195957, 0.6946045766167843, 0.7523968220157217, 0.7716996587910347, 0.7776733644088087, 0.7849774073486733, 0.7590656974234158, 0.747551784030061, 0.690551659833988, 0.1504306269315997, 0.09519016918020529, 0.14029163105948173, 0.17416987331813183, 0.13973453840736927, 0.11652459674081439, 0.12616651291977177, 0.14907136287008305, 0.11352531406764388, 0.15112888544276815, 0.1072606720691952, 0.11500676968411461, 0.12123079309903928, 0.09468918573724583, 0.11840717113956745, 0.15705997197193033, 0.1264354392006244, 0.06967339558827057, 0.9783563112015343, 0.9775667648687938, 0.9821172028245514, 0.978349087901538, 0.9762803180366033, 0.9857508209654378, 0.9644348864438096, 0.9711352523700939, 0.9866675474024609, 0.7793087477187026, 0.7768749443706655, 0.7866241899062392, 0.7760849503222527, 0.7763946152934379, 0.767651740689718, 0.7826999884068333, 0.7761794423091871, 0.7609583229484601, 0.2290752957506046, 0.2253634217719639, 0.3560800170966987, 0.921307139457348, 0.8862747248528482, 0.9054055434881918, 0.23441221400074086, 0.3767879029245115, 0.8949101299000972, 0.7956938648454817, 0.6654248876171776, 0.1314275294884918, 0.6809228174882984, 0.7751542643173405, 0.7341428933877236, 0.13296041747542053, 0.7527722990550669, 0.7179184695705164, 0.7032451013154306, 0.6807705047290181, 0.6754826932693292, 0.7984087636671222, 0.7615099382828932, 0.6446763829349054, 0.6817035738359527, 0.7984107836341259, 0.1330187698486086, 0.7084422723803339, 0.6771628562646161, 0.5087035434536902, 0.5325657561804535, 0.04408390639019655, 0.7314991374572468, 0.7151273332487227, 0.7429259311950699, 0.08356110339466938, 0.7968729404350333, 0.8114300905033758, 0.08710240921366386, 0.7737704437490992, 0.6949949163089423, 0.5668588838863178, 0.6778891829776414, 0.8017712321012125, 0.7826572146131889, 0.3423974094837714, 0.12213621581808276, 0.09256312850165016, 0.4649143969666413, 0.19122202067088678, 0.5852624294427253, 0.16204015861892818, 0.2055922510212621, 0.2782466629981124, 0.6513394959104203, 0.6059540206743834, 0.568492140103281, 0.6491552432087621, 0.6606847450013009, 0.6137350005567941, 0.42322123092782604, 0.6199428872380333, 0.648226981846203, 0.8490444791570642, 0.8526758096894658, 0.8562580971269927, 0.8603194713346934, 0.8526372185701924, 0.8254629057811103, 0.8500910471092247, 0.8535907570462159, 0.8533630569031065, 0.12211548034209596, 0.12721601340951216, 0.10324363945947335, 0.08216425986375087, 0.115630064808667, 0.0680024752017141, 0.1791733969843825, 0.11785914165392786, 0.13059830426557784, 0.22079384855634754, 0.16426429913693974, 0.23501730116673603, 0.1863682457839212, 0.18171857852012274, 0.32825996271196456, 0.2818288239176998, 0.1982737548609027, 0.2535637182328546, 0.5183031455137299, 0.45138856436884744, 0.23915534119425652, 0.5328361862258658, 0.5589741095574261, 0.20889775986065962, 0.3075656211855209, 0.3396048021146474, 0.49194760856511244, 0.30276551939084106, 0.28587425216858386, 0.44809001966618467, 0.3733848100266912, 0.23292497641354115, 0.30022971368859885, 0.23509999145279759, 0.27692203129366166, 0.2839734889894223, 0.19306092516984064, 0.21691980343932482, 0.20810403206857564, 0.23169969463370443, 0.23755902963434306, 0.25469348351624965, 0.23230603982279185, 0.2173847263150095, 0.2639115052058214, 0.19928663942185665, 0.19017620693989234, 0.20523594141903878, 0.20120647757170496, 0.1907296167916076, 0.19711322056621383, 0.22456059172165121, 0.1888149790925423, 0.18153094072335507, 0.17671935185807275, 0.08863974160896393, 0.12276655225628641, 0.9207049800924187, 0.20016521515383578, 0.16919138157999003, 0.13656491433119078, 0.14819711393819868, 0.9220943492920719, 0.9225438648521384, 0.21176274658747452, 0.1685090062557958, 0.21202457085664828, 0.16754345816371918, 0.8914915005807815, 0.10518225544444215, 0.21229958636424795, 0.8894864046878594, 0.22634648843290828, 0.20178207898287737, 0.2253378580551877, 0.19914985099322224, 0.22413335686525393, 0.18695889124228338, 0.16716751257048945, 0.1778980515443802, 0.20959976584376017, 0.10648356812569748, 0.0925282326586605, 0.08264156110187681, 0.10533265752362386, 0.09966214057801259, 0.13626234953041838, 0.08845301439194553, 0.09389644269243946, 0.08999827698461416]}, "mutation_prompt": null}
{"id": "e8d98ae7-b4d3-44ca-9abf-8e3b769a44bb", "solution": "import numpy as np\n\nclass HQADE_EP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n        self.elite_percentage = 0.1  # Preserve top 10% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:\n                        self.memory.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HQADE_EP", "description": "The Hybrid Quantum-Inspired Adaptive Differential Evolution with Elite Preservation (HQADE-EP) enhances exploration, adapts strategy parameters, and preserves elite solutions for improved convergence.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "36840476-1388-4f1e-b675-38fe4f31bd3a", "metadata": {"aucs": [0.8837157770846177, 0.8865520139739698, 0.8837013547025891, 0.881943392133784, 0.8897431351415097, 0.8889482803429659, 0.892466745131764, 0.8892515368590049, 0.885565209314652, 0.78283780195957, 0.6946045766167843, 0.7523968220157217, 0.7716996587910347, 0.7776733644088087, 0.7849774073486733, 0.7590656974234158, 0.747551784030061, 0.690551659833988, 0.1504306269315997, 0.09519016918020529, 0.14029163105948173, 0.17416987331813183, 0.13973453840736927, 0.11652459674081439, 0.12616651291977177, 0.14907136287008305, 0.11352531406764388, 0.15112888544276815, 0.1072606720691952, 0.11500676968411461, 0.12123079309903928, 0.09468918573724583, 0.11840717113956745, 0.15705997197193033, 0.1264354392006244, 0.06967339558827057, 0.9783563112015343, 0.9775667648687938, 0.9821172028245514, 0.978349087901538, 0.9762803180366033, 0.9857508209654378, 0.9644348864438096, 0.9711352523700939, 0.9866675474024609, 0.7793087477187026, 0.7768749443706655, 0.7866241899062392, 0.7760849503222527, 0.7763946152934379, 0.767651740689718, 0.7826999884068333, 0.7761794423091871, 0.7609583229484601, 0.2290752957506046, 0.2253634217719639, 0.3560800170966987, 0.921307139457348, 0.8862747248528482, 0.9054055434881918, 0.23441221400074086, 0.3767879029245115, 0.8949101299000972, 0.7956938648454817, 0.6654248876171776, 0.1314275294884918, 0.6809228174882984, 0.7751542643173405, 0.7341428933877236, 0.13296041747542053, 0.7527722990550669, 0.7179184695705164, 0.7032451013154306, 0.6807705047290181, 0.6754826932693292, 0.7984087636671222, 0.7615099382828932, 0.6446763829349054, 0.6817035738359527, 0.7984107836341259, 0.1330187698486086, 0.7084422723803339, 0.6771628562646161, 0.5087035434536902, 0.5325657561804535, 0.04408390639019655, 0.7314991374572468, 0.7151273332487227, 0.7429259311950699, 0.08356110339466938, 0.7968729404350333, 0.8114300905033758, 0.08710240921366386, 0.7737704437490992, 0.6949949163089423, 0.5668588838863178, 0.6778891829776414, 0.8017712321012125, 0.7826572146131889, 0.3423974094837714, 0.12213621581808276, 0.09256312850165016, 0.4649143969666413, 0.19122202067088678, 0.5852624294427253, 0.16204015861892818, 0.2055922510212621, 0.2782466629981124, 0.6513394959104203, 0.6059540206743834, 0.568492140103281, 0.6491552432087621, 0.6606847450013009, 0.6137350005567941, 0.42322123092782604, 0.6199428872380333, 0.648226981846203, 0.8490444791570642, 0.8526758096894658, 0.8562580971269927, 0.8603194713346934, 0.8526372185701924, 0.8254629057811103, 0.8500910471092247, 0.8535907570462159, 0.8533630569031065, 0.12211548034209596, 0.12721601340951216, 0.10324363945947335, 0.08216425986375087, 0.115630064808667, 0.0680024752017141, 0.1791733969843825, 0.11785914165392786, 0.13059830426557784, 0.22079384855634754, 0.16426429913693974, 0.23501730116673603, 0.1863682457839212, 0.18171857852012274, 0.32825996271196456, 0.2818288239176998, 0.1982737548609027, 0.2535637182328546, 0.5183031455137299, 0.45138856436884744, 0.23915534119425652, 0.5328361862258658, 0.5589741095574261, 0.20889775986065962, 0.3075656211855209, 0.3396048021146474, 0.49194760856511244, 0.30276551939084106, 0.28587425216858386, 0.44809001966618467, 0.3733848100266912, 0.23292497641354115, 0.30022971368859885, 0.23509999145279759, 0.27692203129366166, 0.2839734889894223, 0.19306092516984064, 0.21691980343932482, 0.20810403206857564, 0.23169969463370443, 0.23755902963434306, 0.25469348351624965, 0.23230603982279185, 0.2173847263150095, 0.2639115052058214, 0.19928663942185665, 0.19017620693989234, 0.20523594141903878, 0.20120647757170496, 0.1907296167916076, 0.19711322056621383, 0.22456059172165121, 0.1888149790925423, 0.18153094072335507, 0.17671935185807275, 0.08863974160896393, 0.12276655225628641, 0.9207049800924187, 0.20016521515383578, 0.16919138157999003, 0.13656491433119078, 0.14819711393819868, 0.9220943492920719, 0.9225438648521384, 0.21176274658747452, 0.1685090062557958, 0.21202457085664828, 0.16754345816371918, 0.8914915005807815, 0.10518225544444215, 0.21229958636424795, 0.8894864046878594, 0.22634648843290828, 0.20178207898287737, 0.2253378580551877, 0.19914985099322224, 0.22413335686525393, 0.18695889124228338, 0.16716751257048945, 0.1778980515443802, 0.20959976584376017, 0.10648356812569748, 0.0925282326586605, 0.08264156110187681, 0.10533265752362386, 0.09966214057801259, 0.13626234953041838, 0.08845301439194553, 0.09389644269243946, 0.08999827698461416]}, "mutation_prompt": null}
{"id": "a064af93-5e6e-43f4-9ad7-b8f534cfb48e", "solution": "import numpy as np\n\nclass HQADE_EP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory = []\n        self.best_solution = None\n        self.elite_percentage = 0.1  # Preserve top 10% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory) > 0:\n                self.F = np.mean([entry[0] for entry in self.memory])\n                self.Cr = np.mean([entry[1] for entry in self.memory])\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:\n                        self.memory.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HQADE_EP", "description": "The Hybrid Quantum-Inspired Adaptive Differential Evolution with Elite Preservation (HQADE-EP) enhances exploration, adapts strategy parameters, and preserves elite solutions for improved convergence.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "36840476-1388-4f1e-b675-38fe4f31bd3a", "metadata": {"aucs": [0.8837157770846177, 0.8865520139739698, 0.8837013547025891, 0.881943392133784, 0.8897431351415097, 0.8889482803429659, 0.892466745131764, 0.8892515368590049, 0.885565209314652, 0.78283780195957, 0.6946045766167843, 0.7523968220157217, 0.7716996587910347, 0.7776733644088087, 0.7849774073486733, 0.7590656974234158, 0.747551784030061, 0.690551659833988, 0.1504306269315997, 0.09519016918020529, 0.14029163105948173, 0.17416987331813183, 0.13973453840736927, 0.11652459674081439, 0.12616651291977177, 0.14907136287008305, 0.11352531406764388, 0.15112888544276815, 0.1072606720691952, 0.11500676968411461, 0.12123079309903928, 0.09468918573724583, 0.11840717113956745, 0.15705997197193033, 0.1264354392006244, 0.06967339558827057, 0.9783563112015343, 0.9775667648687938, 0.9821172028245514, 0.978349087901538, 0.9762803180366033, 0.9857508209654378, 0.9644348864438096, 0.9711352523700939, 0.9866675474024609, 0.7793087477187026, 0.7768749443706655, 0.7866241899062392, 0.7760849503222527, 0.7763946152934379, 0.767651740689718, 0.7826999884068333, 0.7761794423091871, 0.7609583229484601, 0.2290752957506046, 0.2253634217719639, 0.3560800170966987, 0.921307139457348, 0.8862747248528482, 0.9054055434881918, 0.23441221400074086, 0.3767879029245115, 0.8949101299000972, 0.7956938648454817, 0.6654248876171776, 0.1314275294884918, 0.6809228174882984, 0.7751542643173405, 0.7341428933877236, 0.13296041747542053, 0.7527722990550669, 0.7179184695705164, 0.7032451013154306, 0.6807705047290181, 0.6754826932693292, 0.7984087636671222, 0.7615099382828932, 0.6446763829349054, 0.6817035738359527, 0.7984107836341259, 0.1330187698486086, 0.7084422723803339, 0.6771628562646161, 0.5087035434536902, 0.5325657561804535, 0.04408390639019655, 0.7314991374572468, 0.7151273332487227, 0.7429259311950699, 0.08356110339466938, 0.7968729404350333, 0.8114300905033758, 0.08710240921366386, 0.7737704437490992, 0.6949949163089423, 0.5668588838863178, 0.6778891829776414, 0.8017712321012125, 0.7826572146131889, 0.3423974094837714, 0.12213621581808276, 0.09256312850165016, 0.4649143969666413, 0.19122202067088678, 0.5852624294427253, 0.16204015861892818, 0.2055922510212621, 0.2782466629981124, 0.6513394959104203, 0.6059540206743834, 0.568492140103281, 0.6491552432087621, 0.6606847450013009, 0.6137350005567941, 0.42322123092782604, 0.6199428872380333, 0.648226981846203, 0.8490444791570642, 0.8526758096894658, 0.8562580971269927, 0.8603194713346934, 0.8526372185701924, 0.8254629057811103, 0.8500910471092247, 0.8535907570462159, 0.8533630569031065, 0.12211548034209596, 0.12721601340951216, 0.10324363945947335, 0.08216425986375087, 0.115630064808667, 0.0680024752017141, 0.1791733969843825, 0.11785914165392786, 0.13059830426557784, 0.22079384855634754, 0.16426429913693974, 0.23501730116673603, 0.1863682457839212, 0.18171857852012274, 0.32825996271196456, 0.2818288239176998, 0.1982737548609027, 0.2535637182328546, 0.5183031455137299, 0.45138856436884744, 0.23915534119425652, 0.5328361862258658, 0.5589741095574261, 0.20889775986065962, 0.3075656211855209, 0.3396048021146474, 0.49194760856511244, 0.30276551939084106, 0.28587425216858386, 0.44809001966618467, 0.3733848100266912, 0.23292497641354115, 0.30022971368859885, 0.23509999145279759, 0.27692203129366166, 0.2839734889894223, 0.19306092516984064, 0.21691980343932482, 0.20810403206857564, 0.23169969463370443, 0.23755902963434306, 0.25469348351624965, 0.23230603982279185, 0.2173847263150095, 0.2639115052058214, 0.19928663942185665, 0.19017620693989234, 0.20523594141903878, 0.20120647757170496, 0.1907296167916076, 0.19711322056621383, 0.22456059172165121, 0.1888149790925423, 0.18153094072335507, 0.17671935185807275, 0.08863974160896393, 0.12276655225628641, 0.9207049800924187, 0.20016521515383578, 0.16919138157999003, 0.13656491433119078, 0.14819711393819868, 0.9220943492920719, 0.9225438648521384, 0.21176274658747452, 0.1685090062557958, 0.21202457085664828, 0.16754345816371918, 0.8914915005807815, 0.10518225544444215, 0.21229958636424795, 0.8894864046878594, 0.22634648843290828, 0.20178207898287737, 0.2253378580551877, 0.19914985099322224, 0.22413335686525393, 0.18695889124228338, 0.16716751257048945, 0.1778980515443802, 0.20959976584376017, 0.10648356812569748, 0.0925282326586605, 0.08264156110187681, 0.10533265752362386, 0.09966214057801259, 0.13626234953041838, 0.08845301439194553, 0.09389644269243946, 0.08999827698461416]}, "mutation_prompt": null}
{"id": "af8ab0f8-dbe5-4e5a-83ae-1eefd07243b7", "solution": "import numpy as np\n\nclass QISAD_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5\n        self.Cr = 0.9\n        self.memory = []\n        self.best_solution = None\n        self.elite_percentage = 0.1\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def update_parameters(self):\n        if len(self.memory) > 0:\n            self.F = np.tanh(np.mean([entry[0] for entry in self.memory]))\n            self.Cr = np.tanh(np.mean([entry[1] for entry in self.memory]))\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            self.update_parameters()\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x_best - x2 + x3 - x1), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((self.F, self.Cr))\n                    if len(self.memory) > 50:\n                        self.memory.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QISAD_DE", "description": "Quantum-Inspired Self-Adaptive DE with Dynamic Elite Preservation enhances local search and adapts parameters based on a stochastic scheme.", "configspace": "", "generation": 38, "fitness": 0.2612883710545197, "feedback": "The algorithm QISAD_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "36840476-1388-4f1e-b675-38fe4f31bd3a", "metadata": {"aucs": [0.7677866389700465, 0.7905076678163042, 0.7746367252997275, 0.7655548156836347, 0.7839537430730817, 0.7650882388844064, 0.7660461751710287, 0.7803789139855359, 0.738175896385062, 0.5377049115160264, 0.5392190351431088, 0.5306860378461413, 0.5106405794786204, 0.524193470418181, 0.5666916666460802, 0.03680767950851749, 0.5168571818974028, 0.47687586740426846, 0.48837578378031876, 0.4539194070925763, 0.15930425501687573, 0.4789182393689172, 0.33224449918572185, 0.39539084826448334, 0.16852388097392013, 0.4081365913062811, 0.16230407598363394, 0.24356993644354707, 0.13802602225028182, 0.18286697997064583, 0.1420104617212401, 0.16664332254168035, 0.16013896524023385, 0.13052726842849316, 0.1584445622121522, 0.12970705235126412, 0.9169009401870403, 0.8381652034370297, 0.8458738002749364, 0.8641194015186588, 0.8526306481600647, 0.8355003982231188, 0.22268538510348368, 0.8488395214554332, 0.9162476460231577, 0.11555559031956875, 0.2371684140564323, 0.12090922557927464, 0.2598350262868139, 0.2610108385971994, 0.2717941925076388, 0.18146679343075334, 0.21239878761774833, 0.14795526934042103, 0.3332728825521295, 0.31002611060246155, 0.23667072566452485, 0.34014392450999986, 0.27735379193405263, 0.33279960186522295, 0.2275768859057311, 0.2687404076553953, 0.3201725385500894, 0.14874150662017782, 0.12204769650057001, 0.15296306059595222, 0.17619741176750736, 0.17274662876082403, 0.14529771968230032, 0.1484876616478148, 0.16614876609200913, 0.1404858487968932, 0.13308877900509564, 0.12907263090028231, 0.1425018774578326, 0.17262417676952568, 0.14899441452780915, 0.13535695114655177, 0.1465577994758691, 0.13081984180149608, 0.13226511710911404, 0.00834700230181007, 9.999999999998899e-05, 9.999999999998899e-05, 0.005760044188996782, 0.0005075393968112518, 0.0015567912863807543, 0.007842954673464186, 9.999999999998899e-05, 0.0026711065891238395, 0.12364037348529833, 0.1215247791313212, 0.11181948566788813, 0.09293720231802927, 0.04288186204266442, 0.06653070491991708, 0.08556264482684695, 0.07782054448346043, 0.05424192537096639, 0.045008112404941514, 0.0060489261828330365, 0.028572004762239867, 0.03120241821294034, 0.03379043655196712, 0.015143102072523451, 0.018223558543350782, 0.039206182872291495, 0.028341593923604025, 0.11066158997696252, 0.10280730904806312, 0.10941074664608719, 0.11303591889504494, 0.1029819861043052, 0.1322032684774107, 0.12038531045369805, 0.10086160436029856, 0.10447572458433008, 0.4509501449087032, 0.4834168341212225, 0.4612893194659776, 0.46279799828764134, 0.4622292703150963, 0.46700750128377866, 0.4781984631070272, 0.48470970176729933, 0.4380146089708461, 0.10505101807816886, 0.11933968529022965, 0.08039809572361212, 0.11461214015909482, 0.11426871805371552, 0.11715574309823529, 0.13407579470167874, 0.11381090183202303, 0.10608949743613971, 0.15540161183441537, 0.17614033406237617, 0.15133425686664614, 0.13937975330657226, 0.14926286447361492, 0.14042370420671346, 0.1682463499120035, 0.13698013704318057, 0.13806622108025224, 0.32809268077323095, 0.3362792413157911, 0.3364788539752612, 0.31966820906584625, 0.3175274336070154, 0.2950522818959699, 0.3030502546806917, 0.29687400700690036, 0.3329277044518517, 0.2126658105075152, 0.2425156605640092, 0.23855773345274345, 0.19285546025694666, 0.2386672446466911, 0.21794950042573924, 0.19556046155807216, 0.24998011525470343, 0.17620583089708686, 0.2071944163503303, 0.2165219106804408, 0.23469696658638195, 0.22125439411598913, 0.2053149336271779, 0.20482662041755428, 0.20612032055742635, 0.21420421698452097, 0.18963090801325166, 0.22717536651450854, 0.234704503071138, 0.2300953113349009, 0.3080703530330021, 0.28882841384212865, 0.21303538622959672, 0.2575941134141658, 0.22094361952684172, 0.24062952227120693, 0.6412114783463086, 0.18601527918192684, 0.3932369660712228, 0.7758445974831414, 0.567207463815198, 0.14547946509113951, 0.5955605009362104, 0.1719590441365364, 0.47666678033505094, 0.4916787060790653, 0.3809360844649491, 0.4184616486105799, 0.2830753816143373, 0.2654244665833573, 0.16627510193706807, 0.16251583055505925, 0.27949441527275753, 0.16318843320095688, 0.18161527702429126, 0.17711145529399597, 0.180989796111931, 0.18024658852026465, 0.19114951875157526, 0.19690661548274258, 0.18138836431143968, 0.1800806440603825, 0.1679934195540954, 0.07931849362185317, 0.09025557252380445, 0.07632414885756167, 0.09194392964906806, 0.0915810460387424, 0.0909347208784449, 0.08222478581117487, 0.08098410838663672, 0.09523359685916966]}, "mutation_prompt": null}
{"id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 39, "fitness": 0.4804062752827884, "feedback": "The algorithm AQIDE_DM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.32.", "error": "", "parent_id": "36840476-1388-4f1e-b675-38fe4f31bd3a", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "c321fafd-ad56-4495-b23c-92e256b8f451", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "ffb31540-8961-4cc8-9260-b7eddb60e4b9", "solution": "import numpy as np\n\nclass AQIDE_DMAE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = max(4, 10 * dim)  # Ensure minimum population size \n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n        self.adaptive_elite_rate = 0.05  # Adaptive rate for elite selection\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = max(1, int(self.pop_size * self.elite_percentage))\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                non_elite_indices = [j for j in range(self.pop_size) if j not in elite_indices]\n                indices = np.random.choice(non_elite_indices, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n            self.elite_percentage = min(0.5, self.elite_percentage + self.adaptive_elite_rate)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DMAE", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory and Adaptive Elite Reinforcement (AQIDE-DMAE) introduces adaptive elite selection and enhanced diversity maintenance for improved robustness.", "configspace": "", "generation": 41, "fitness": 0.2095965879941053, "feedback": "The algorithm AQIDE_DMAE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.14.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.5681355059181583, 0.5506734326461524, 0.5633584433426579, 0.5344156077250988, 0.545103122920165, 0.5548082018146676, 0.5571071197924415, 0.5514096965173018, 0.5343612297811839, 0.2997243070746425, 0.27792946484482195, 0.2628372418544531, 0.29022359865763214, 0.3027452505415106, 0.32816119308375313, 0.29130391092186847, 0.3117648520155184, 0.28370471776777206, 0.09884474516651554, 0.10005561286960152, 0.09531559928030142, 0.10934054378943836, 0.13434154973597745, 0.08974288041777545, 0.10340162924831342, 0.10071371707830945, 0.10556864528563714, 0.08590449641199105, 0.08842546965826314, 0.08290223903670302, 0.08274264230820827, 0.08208581009205862, 0.08368198039536123, 0.08754749857096811, 0.08718822106655477, 0.08435096405057407, 0.24169195289218437, 0.24821911283305242, 0.2537709710606193, 0.22401081819474966, 0.24899324749615115, 0.24331129388676442, 0.23660813025459315, 0.23729046516111796, 0.2699658373838596, 0.07771200127420363, 0.09334881254285787, 0.12464602290984406, 0.0779906413903072, 0.10039075051489621, 0.11137449946750311, 0.12747908034935207, 0.13848326236289266, 0.14543679242278518, 0.5317804598089244, 0.5271098843224913, 0.5433717208597164, 0.5751776211091625, 0.6418388141238668, 0.49049838052198613, 0.5446063664140766, 0.5441687754502167, 0.5446876822625346, 0.14215789349507724, 0.14097152245457656, 0.15267478282237512, 0.12057062816736375, 0.1472720815598002, 0.11773188993479267, 0.14274330204404528, 0.158049346759907, 0.11295586124778689, 0.08775614846346347, 0.1602085657406398, 0.12312792934047323, 0.13653874394767884, 0.12672305913944948, 0.17538212856721436, 0.12549074998261733, 0.11976212745896542, 0.1514433499224952, 0.14038848325104814, 0.12782097850932073, 0.12956130759486872, 0.15775516460412387, 0.09123462087307943, 0.1338348841142537, 0.15047828782707273, 0.1310028636424202, 0.1281160118648138, 0.2972918359453769, 0.3056195340416916, 0.321380018341634, 0.26804921558065475, 0.2450706507368443, 0.21562120676056407, 0.3085697164859045, 0.2883566821122707, 0.2810745365535402, 0.02577449269110288, 0.024282942917313033, 0.038157343269133004, 0.0346332644776699, 0.03742007667081437, 0.03913535562782777, 0.048980681007002924, 0.04233441714330477, 0.02969056966958561, 0.14427166649741663, 0.1301331200434639, 0.1193197737818964, 0.1369215672332088, 0.1526905169320184, 0.13783163725794378, 0.1197156008348329, 0.12960431252713756, 0.13570244301547807, 0.46569042692388907, 0.4716323593426821, 0.4758089435855163, 0.45279928182516926, 0.4567585294669141, 0.4638468984313797, 0.4729444725563723, 0.48519998718177426, 0.47634067843513406, 0.09323903939399136, 0.08167661914902002, 0.09194778411574556, 0.09027727813317765, 0.07738626766668799, 0.08530026320579687, 0.07613734996967636, 0.0798524703455209, 0.08735063442082225, 0.15457919526271813, 0.14437577127934287, 0.14635332970247605, 0.1479318318994638, 0.13262725594093427, 0.13542133330020956, 0.14329721302304077, 0.17403888825466196, 0.1369931396959535, 0.2748222252328436, 0.2854770521461314, 0.30313923642858676, 0.27674501603399526, 0.2761788509514026, 0.2883388430736521, 0.28899013762201964, 0.2993727513357268, 0.2909390179288822, 0.22105137280184617, 0.23176802148261344, 0.21273339239822797, 0.2026713501266867, 0.2173914590432714, 0.20080318208417425, 0.21009049888721476, 0.2261803788216904, 0.23927024470951297, 0.1944664202536478, 0.19787196715738897, 0.20888040677718434, 0.19139068952435423, 0.19926017376563443, 0.18453863696616613, 0.19498863452490744, 0.19497962461608664, 0.18768670179502545, 0.17237019287371858, 0.17309880558515833, 0.17722680533042146, 0.1769405737028179, 0.18547940457382706, 0.17329570695675156, 0.17950625484654137, 0.16998026978426684, 0.1741715756159039, 0.25476601001508414, 0.22459953942987387, 0.2111271283452345, 0.18688819040784255, 0.18274903607794235, 0.23729295409308593, 0.2572669333751967, 0.13756096210031232, 0.1729894412748223, 0.177690838760439, 0.16871899376970956, 0.19699010211752277, 0.16186664963853803, 0.20695587090051148, 0.21600407686485168, 0.20050648145157968, 0.1671950244873056, 0.19810978388127298, 0.19149095990494702, 0.1965897195799896, 0.18816077079319693, 0.1794331522965258, 0.19039377086192588, 0.1765582324019631, 0.18966265108541902, 0.18609243620390514, 0.19441338636574312, 0.08178731988049037, 0.0761473314779394, 0.06996064689109593, 0.07204936929677719, 0.07827480460614045, 0.07390409347625937, 0.08360539642791465, 0.07972219619133869, 0.08016520328928001]}, "mutation_prompt": null}
{"id": "d685d3d4-6015-489c-97ff-4065e474e2df", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "4eefc87b-2d1c-47b6-9341-9a4ad410e88e", "solution": "import numpy as np\n\nclass AQIDE_DM_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = max(10 * dim, 50)  # Ensure a reasonable population size\n        self.F = 0.7  # Differential weight adjustment\n        self.Cr = 0.8  # Crossover probability adjustment\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.2  # Increased elite percentage for more exploration\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.mean(self.memory_F)  # Use mean instead of median\n                self.Cr = np.mean(self.memory_Cr)  # Use mean instead of median\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM_Improved", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dynamic Memory (AQIDE-DM) uses adaptive parameters and dynamic elite selection for improved convergence.", "configspace": "", "generation": 43, "fitness": 0.2531089025301161, "feedback": "The algorithm AQIDE_DM_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.6286648806316557, 0.610529473508017, 0.6254301920722118, 0.6045726424820025, 0.6252243233523245, 0.6591736532082659, 0.6294929482920948, 0.6322367455743334, 0.628331934139793, 0.40321285331643775, 0.36822600175436115, 0.3528042454673438, 0.35924807098888245, 0.39329108323337547, 0.36780656217964713, 0.39623126375554596, 0.3778377238513734, 0.3690462188139404, 0.102465961532346, 0.10381945876246013, 0.10374282049527306, 0.10666246980455385, 0.09727992780285588, 0.11222799139561557, 0.10838804565948268, 0.10578868219822235, 0.10181710661139054, 0.09326944681927729, 0.08703659511850315, 0.09300520154204517, 0.08699867979255926, 0.09489363834895137, 0.09351920694624283, 0.0999438160389069, 0.1010876193284097, 0.10103221459144685, 0.9648430611084766, 0.8591936482662121, 0.9169356307868664, 0.9377572948302006, 0.8761866029107038, 0.9340094445691326, 0.9012737347562205, 0.9659939335607493, 0.9083764644621829, 0.26627899572279634, 0.2688756773979799, 0.25424248332977173, 0.3105705674237109, 0.25552805544384005, 0.27222968277208937, 0.28453905083668574, 0.2967266477169962, 0.2931527534561793, 0.5131507352969051, 0.5034614897649651, 0.40791636545502996, 0.5224960284505861, 0.47392791793266065, 0.45871919900316194, 0.4978792709666868, 0.4926786673149387, 0.5314453650849231, 0.1681903939705266, 0.16320704245221018, 0.18386672888830258, 0.16758433519340432, 0.17097396502806972, 0.1643500897432908, 0.17521671279095918, 0.1640848333895374, 0.18575829549800016, 0.16775806794871861, 0.10348710112779869, 0.12894151738970994, 0.18694608458692885, 0.18224090199251408, 0.1659028616225442, 0.173101423023433, 0.17463555326092506, 0.16422717466348435, 0.07493525881258079, 0.0643465255511233, 0.0702967012933795, 0.08684994049792638, 0.08374706769611417, 0.07630593893739657, 0.11232989450989461, 0.0685074601451976, 0.0731648971867973, 0.1887934137350712, 0.2236545853023686, 0.21736870464802316, 0.1964854045972012, 0.20153720257908758, 0.1716478731112262, 0.2453693902499986, 0.24510556170570175, 0.21119551452820218, 0.02845782760018223, 0.01784233159788784, 0.01788144402394387, 0.013640560983667505, 0.039274493549488754, 0.024938841727839778, 0.03533058574950587, 0.03705670599410238, 0.031570598577745135, 0.12609500278511554, 0.13162229285663873, 0.1353834074867747, 0.13569177163955115, 0.12467698739684818, 0.1419771047629298, 0.1283333466526172, 0.14200727049025097, 0.14032341249685487, 0.47764759711039606, 0.4598024658109092, 0.47838696162102035, 0.4734201409320846, 0.45539809427896527, 0.4490337826592723, 0.49370084745005627, 0.4766058329047631, 0.46756720812781816, 0.08368627282067576, 0.08941661568847137, 0.07954044133829852, 0.0962717551106842, 0.08690348274948045, 0.09948676745431928, 0.08930018429343378, 0.10089193888732662, 0.10316416442722309, 0.12763527429176025, 0.14042565256532724, 0.1454342895330787, 0.13487828359773646, 0.16248889986275405, 0.14099968381547368, 0.1426803351776862, 0.17814146946174392, 0.1536973501886879, 0.26652822127136155, 0.26290566671932636, 0.2957140784008613, 0.2841737698637329, 0.2875689048716815, 0.2964179626722594, 0.31581128891066523, 0.30996979662871904, 0.29363933573174883, 0.2169828067788543, 0.20257390049155588, 0.21884701723598643, 0.20436802733658999, 0.186858401385258, 0.1986149820126507, 0.23528101796905554, 0.2306835970134279, 0.2112565946082856, 0.20196994115719913, 0.1854901785655031, 0.16827600130027653, 0.1844803063506405, 0.2057991307813104, 0.17851341240386742, 0.21257699477027547, 0.1726839312504408, 0.1782372075634756, 0.18305925905965803, 0.17729966287492083, 0.1865403693209169, 0.179386923524964, 0.17930978632546213, 0.17384601183909565, 0.17462979241240428, 0.17093438093687308, 0.1943995065043843, 0.1866335772003499, 0.5219813883196246, 0.1562858458530827, 0.45510860130963016, 0.4710450571428959, 0.1810009117080067, 0.2150549090167364, 0.17748272360539508, 0.25690485701898713, 0.19077277349276356, 0.1982138269683592, 0.15929698207595433, 0.1905945589506981, 0.4349831035980041, 0.4211625432431688, 0.4634358159015788, 0.20291908740790243, 0.20619563229191507, 0.17483472593214067, 0.1933080337243095, 0.18418582747770085, 0.18125842293792094, 0.18317565001159286, 0.17880207022505945, 0.19153793984133316, 0.17804075317625234, 0.19321678749211135, 0.0716334147602018, 0.07134306418735992, 0.07873302986606667, 0.0713253900361015, 0.06579902585330877, 0.0693286828813392, 0.07972287435693692, 0.08199549368635417, 0.07502873389041165]}, "mutation_prompt": null}
{"id": "ccaaad4f-0bc7-40d0-bf2d-5c258069e157", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "9fa01282-5e75-4821-810a-b53321582ee0", "solution": "import numpy as np\n\nclass QIDE_MA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.10  # Preserve top 10% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.random.choice(self.memory_F)\n                self.Cr = np.random.choice(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.random.choice(np.argsort(fitness)[:elite_count], elite_count // 2, replace=False)\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x3 - x2), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 50:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 50:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QIDE_MA", "description": "The Quantum-Inspired Differential Evolution with Memory-based Adaptation (QIDE_MA) utilizes enhanced memory-based parameter adaptation and randomized elite retention for robust optimization performance.", "configspace": "", "generation": 45, "fitness": 0.32532048437449085, "feedback": "The algorithm QIDE_MA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.6904530223814738, 0.655147430172877, 0.7000917700628793, 0.7329866758008775, 0.7029782582183861, 0.7034935376002455, 0.7264207771992495, 0.7185323715811234, 0.697915573906037, 0.4733871804118177, 0.4312063396761914, 0.4504101528693635, 0.39935033562224775, 0.46725403967861967, 0.42693572124404655, 0.4462004687456239, 0.4233608514997641, 0.47738582202178936, 0.11036789835695004, 0.10146425923615843, 0.11148464188366036, 0.10963872057150259, 0.12588700545905562, 0.10189934166300885, 0.0932988194692731, 0.0979865585533527, 0.12541379240516848, 0.0959340541928454, 0.09660146562261707, 0.09085090270131224, 0.09136159145186917, 0.08929430115728842, 0.08723096942459074, 0.10411127955744637, 0.07952106284279703, 0.08817218932914439, 0.9308975936305596, 0.953013658099349, 0.9657028556577755, 0.9934597286323628, 0.9748030359738712, 0.9617861936864566, 0.974650555197864, 0.9701815602142667, 0.9901732882292648, 0.39447312718992167, 0.405940039102448, 0.3780792182003303, 0.40234623783866785, 0.38311903707444495, 0.3723113833101296, 0.416120356878392, 0.42716278316689626, 0.3974433984786375, 0.6852879294563186, 0.6573904810275878, 0.6348245497777172, 0.6837888075071994, 0.7280993528219133, 0.702139199206758, 0.6849939680307465, 0.7394842885818206, 0.680312363211237, 0.3791427372399343, 0.36206461117265154, 0.37806169372755905, 0.34180563828901767, 0.3423928083815104, 0.33311077018283786, 0.43391004055479565, 0.3277502981443037, 0.3761733247795177, 0.41198018201976583, 0.3410433599500501, 0.43036303365001316, 0.3755801773619777, 0.3402389794322713, 0.28953372203252237, 0.3155034805574516, 0.3465098721893731, 0.3686011546385619, 0.24844727582894444, 0.3020008373315817, 0.29500509176264156, 0.22063293584149435, 0.24613427315436098, 0.2566742701332809, 0.340573557585793, 0.25362045107437825, 0.2829761524195634, 0.4152269150194756, 0.4307584344768488, 0.4033194676761179, 0.3813803910596535, 0.4009735963756583, 0.38716938342237295, 0.41839980992216175, 0.408891007404407, 0.41453450398571645, 0.14909458200129178, 0.10328463706149982, 0.09564068309664231, 0.12360661972969078, 0.08106115739261599, 0.16251470078123753, 0.07557245722201189, 0.07841378486011963, 0.09283929835863525, 0.23845784145836346, 0.21566883762111388, 0.20860837379584452, 0.23716749946862148, 0.23560524392702087, 0.2256654199039836, 0.248100088492205, 0.22437969670953772, 0.23294477974817474, 0.5916309929289425, 0.5963910888147342, 0.5844167721545169, 0.5768110254685275, 0.6220417008212169, 0.5975886832179824, 0.6070833004715384, 0.561736864714266, 0.5551255976246128, 0.08641440367703357, 0.10130475093729441, 0.08985712743640906, 0.08397174492241988, 0.09391326863766358, 0.10169890239510682, 0.0860819746940168, 0.08814895974383163, 0.08902493766704178, 0.13093609902994863, 0.12336715626013084, 0.14197439797082556, 0.1358357234734926, 0.4364111526114143, 0.13659948059062077, 0.38015690217151166, 0.21509762239520547, 0.13411058290545863, 0.36651482339317454, 0.3353560250562042, 0.31364776192978416, 0.3199720892866521, 0.33874807102379223, 0.33833325075288034, 0.3643090957331707, 0.3594223908938168, 0.3413202360899352, 0.25403047707272297, 0.25751120798891725, 0.27232085486177016, 0.2657213202968546, 0.22463691881211056, 0.25385231266457076, 0.26451642176329515, 0.28312893078972345, 0.28568670648403227, 0.18765443194395115, 0.18216289398019336, 0.20331323257409217, 0.18673678218501477, 0.1734814685713273, 0.192099688672703, 0.188153036457821, 0.1859212414761673, 0.18161965010863812, 0.3251133632163127, 0.2028873333377511, 0.20793063943283696, 0.28932896683668485, 0.21505073772623018, 0.2019613098045494, 0.22832106648084904, 0.17940994974915958, 0.1955358875607197, 0.1630973273019608, 0.19112986927503972, 0.1525136429362226, 0.18470227732624234, 0.5589412992152694, 0.19472831883991437, 0.15748729829056607, 0.6933818205189173, 0.6644893356004216, 0.12655547353831265, 0.1662159216898048, 0.16559686928023654, 0.19867761045672372, 0.12546882002203852, 0.16348720144885087, 0.2091003921522423, 0.21132491720277902, 0.15384147656240588, 0.18301073731065098, 0.18389556251084815, 0.19085862224964778, 0.1760368906125308, 0.1956255133790168, 0.20104076796361192, 0.18908426151048352, 0.21211314568196982, 0.2049021705647296, 0.08213026606577822, 0.08322033090024339, 0.08271453545490148, 0.08405878641907805, 0.06684465741542367, 0.07915148089310786, 0.07350814601018407, 0.07474570037185535, 0.07097727601308257]}, "mutation_prompt": null}
{"id": "e9225930-6e36-4039-aa9c-0a3df40151ac", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "7fb33d4e-2da2-4c66-9fb4-8730d8af93f6", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "77475e57-9b79-4611-9d24-0a048d751b3a", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "c465ad7f-1435-4de9-aa6e-9a672f168954", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "f9a3b40c-d35d-47d3-8a5c-bd2a5624c56f", "solution": "import numpy as np\n\nclass HyQAD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 10 and len(self.memory_Cr) > 10:  # Increased memory requirement for adjustment\n                self.F = np.mean(self.memory_F[-10:])  # Use mean instead of median for smoother adaptation\n                self.Cr = np.mean(self.memory_Cr[-10:])  # Use mean instead of median for smoother adaptation\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x3), self.lower_bound, self.upper_bound)  # Altered mutation strategy\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if len(self.memory_F) < 100:\n                        self.memory_F.append(self.F)\n                    if len(self.memory_Cr) < 100:\n                        self.memory_Cr.append(self.Cr)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HyQAD", "description": "Hybrid Quantum-Inspired Adaptive Differential Evolution (HyQAD) utilizes adaptive differential weights and memory-enhanced crossover probabilities for balanced exploration and exploitation.", "configspace": "", "generation": 50, "fitness": 0.48036981433499454, "feedback": "The algorithm HyQAD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.32.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008672001, 0.8811045025054896, 0.8814109125958407, 0.8920476672400512, 0.8885594722580704, 0.8863754981124068, 0.8967279277722808, 0.8932665236501451, 0.8909558911183563, 0.7734451302185659, 0.770945846067342, 0.7548947814506897, 0.786404111859842, 0.7577255343007666, 0.7748037767538032, 0.7871648382603806, 0.7734794244798805, 0.7616182919306534, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.7844751131036775, 0.7700590138818355, 0.7683426880541412, 0.7934376439618549, 0.772846438206457, 0.7876605070155289, 0.779375804409699, 0.7814322534908743, 0.7715255096162319, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795644, 0.7850045098506321, 0.7273607202010706, 0.7337614872824099, 0.7557501760486034, 0.13447001646079892, 0.7063334285848921, 0.13279554117168957, 0.13028309330432242, 0.7712965256462694, 0.7453364502698578, 0.7024580089125321, 0.7791270914493723, 0.7299059391170216, 0.721757525695744, 0.7418431798875402, 0.7050597824148938, 0.1328996319977146, 0.6815732886321875, 0.5441516652313938, 0.2134606497086392, 0.7469660459325944, 0.7373169423542032, 0.03970787869433312, 0.7358985115222699, 0.6239283500994142, 0.33833198230750783, 0.8016724644479951, 0.8059541147087811, 0.8090478193878422, 0.7673039754011334, 0.6803634870181046, 0.7836609685675299, 0.8031761885705789, 0.781827744757801, 0.8158767010432082, 0.31751729727213307, 0.6230796578192235, 0.0992528590217644, 0.5830088400025399, 0.18521716170513292, 0.614207920146943, 0.143484018202518, 0.14653578509625553, 0.1310112434157994, 0.6360253848936153, 0.6352712133902603, 0.65081995139068, 0.6658294156176088, 0.6482821810909766, 0.6371281062981904, 0.6223740511202762, 0.5285512050190364, 0.6327576476806122, 0.8510179434045635, 0.8527860478836907, 0.8335287059345968, 0.8547892810368403, 0.8573070267477053, 0.8326196135531304, 0.8707300317796993, 0.8525526860246047, 0.8465535034448248, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.23058134058927604, 0.1694348594046312, 0.25024342025810087, 0.23924202953093887, 0.19330938303449852, 0.19944600125381107, 0.5016411853400589, 0.4981325578433755, 0.7795987906213915, 0.36898885151795924, 0.4565436058201815, 0.42041415565470464, 0.3533383908934292, 0.44452745027326723, 0.5740619892135108, 0.6048519620645751, 0.30416416724426387, 0.3945263812538399, 0.22961849192610773, 0.2623566384081947, 0.3525836925840202, 0.4979359732725479, 0.23894180725590108, 0.38880496348738347, 0.222034095496075, 0.2668534122525411, 0.43109292493178963, 0.22280995919292623, 0.22790597959482728, 0.20571078746971494, 0.20246450776213176, 0.21304679787770198, 0.17116899442910105, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574562, 0.9124422689478195, 0.9173387322055917, 0.8969433430449778, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21620877298012742, 0.19990640409359617, 0.19530976209543283, 0.4788477487871785, 0.2029707395248822, 0.21885786694679155, 0.20431892272022034, 0.22085157974904168, 0.20534675503388766, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09174779987706638, 0.09858937330530171, 0.07666227902954559, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "ed77e96e-7983-4e05-b615-623b8790acad", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "55a61a04-05a3-4e72-a311-f7f069ece38c", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "609e1104-055b-4cec-807d-1b1b1dfb1f0a", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "21d4994b-9839-435f-a98d-b351d7b88995", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "9bd62331-d0c8-4c76-a977-5393227772b7", "solution": "import numpy as np\n\nclass EQIDE_MC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15\n        self.memory_limit = 50  # Limit for compressed memory\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def compress_memory(self, memory):\n        return np.median(memory[-self.memory_limit:]) if len(memory) > self.memory_limit else np.median(memory)\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = self.compress_memory(self.memory_F)\n                self.Cr = self.compress_memory(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)]\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x3 - x1), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > self.memory_limit:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > self.memory_limit:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EQIDE_MC", "description": "The Enhanced Quantum-Inspired Differential Evolution with Memory Compression (EQIDE-MC) introduces memory compression and adaptive strategy selection to improve adaptability and exploitation.", "configspace": "", "generation": 55, "fitness": 0.38804690239792605, "feedback": "The algorithm EQIDE_MC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8418566943723521, 0.8222927394351891, 0.853407122477003, 0.8451590756955838, 0.8506281733156565, 0.8460247826352869, 0.8485499162688167, 0.8351360131688887, 0.8226089539150769, 0.7199718334152049, 0.047896114940712664, 0.6905175014593536, 0.6301845138988995, 0.6489156564761307, 9.999999999998899e-05, 0.5582617914821402, 0.6409747743871445, 0.6113748038202669, 0.11644694471344497, 0.12985099240920372, 0.12103132288112317, 0.17113338330566652, 0.10263632567937298, 0.14070114866935968, 0.12601546934315067, 0.08482396022427152, 0.1358418698501488, 0.10797529010750184, 0.10412734547294789, 0.10431277285808882, 0.08735176714894166, 0.1367041452909753, 0.1334967825088863, 0.14002634671935832, 0.18036873347307825, 0.10416545578640146, 0.9355420258778016, 0.8739604472441946, 0.8870141992530194, 0.8265891341420253, 0.8451013736942975, 0.9250386400246206, 0.9474014681590432, 0.8453794900890736, 0.9450454194975795, 0.7222261376724544, 0.68082400139675, 0.7057858539686651, 0.7067903674056419, 0.6826538554527619, 0.6640613421022663, 0.48165201869634444, 0.6928087178242746, 0.6443589058958298, 0.8669765802100797, 0.8544240170938496, 0.8977849210683577, 0.8759086358808221, 0.27472285609644476, 0.8664852690013906, 0.3869845894482792, 0.2132196510969493, 0.8262588940028502, 0.6683744090658592, 0.11852875822148057, 9.999999999998899e-05, 0.7230392710010869, 0.13033228524164586, 0.15444732288534158, 0.3602316606629449, 0.1995969883793005, 0.18221786055440015, 0.3797959102098435, 0.12843370937714027, 0.16545317254873648, 0.2418430204995402, 0.1760901454317687, 0.3099867236252529, 0.21308459999459528, 0.12884846228876434, 0.1955031436252861, 0.08080262406383587, 0.5324323438087686, 0.6068983809634305, 0.5822623391367459, 0.15411366212952526, 0.11427499466199609, 0.603209454805213, 0.416950496243366, 0.6111694889255603, 0.746031521111568, 0.681235332151239, 0.18315905095591412, 0.7017974591158416, 0.20428880045900533, 0.7246546003670138, 0.11398422486101878, 0.5760023850100634, 0.6520126084279589, 0.20721364708285328, 0.07433965873072157, 0.11656875551750345, 0.3780504911621809, 0.16136935070361236, 0.4303311238228531, 0.11335491748716764, 0.1170703545961631, 0.17811355633124182, 0.2597494567787212, 0.4197635262224281, 0.28942381405922146, 0.5516030121941591, 0.45245183715117077, 0.27848909462357396, 0.2730774959287514, 0.20903513693054887, 0.14743949889867713, 0.7929153260443027, 0.8018298092886644, 0.7349679935469018, 0.7828863811817307, 0.7250333685839807, 0.8050908552735605, 0.7837068127076714, 0.7940028841993166, 0.7747701201236304, 0.09014452011876417, 0.07856053783862516, 0.06425986177799403, 0.12220835696752708, 0.08443132773366147, 0.12914060781689407, 0.13540267172588483, 0.08822393296193731, 0.15794220814872428, 0.43604538675833915, 0.18704821862153742, 0.3851139086136963, 0.65291062265002, 0.7369300439113641, 0.7583147781761352, 0.35468366612040303, 0.2902482428347506, 0.26449541436887347, 0.2954481451580001, 0.5360922359328396, 0.3720301124447154, 0.381833455876321, 0.5663289120195076, 0.5028036621288527, 0.6752424271464696, 0.4472207717940435, 0.25338124368224857, 0.21882658959822499, 0.1927191051809244, 0.2782683430263351, 0.36111222603438986, 0.26661916458204893, 0.40924198762305086, 0.30296653197948964, 0.19712003415276258, 0.4177431419812394, 0.2596832768535944, 0.1887432641630714, 0.22891102998216062, 0.22366709330899082, 0.20810588317404088, 0.2241855947208503, 0.20180289891150616, 0.2197577245205311, 0.2004793574563073, 0.1944900982937432, 0.20766814796044009, 0.1814096153091268, 0.19245499538575062, 0.20461310336844318, 0.1907245419191993, 0.1985525854743565, 0.24439570194911864, 0.18986179594586683, 0.8971626463319284, 0.16715894677636423, 0.1475488597039608, 0.8971860613012912, 0.1993888079937357, 0.19823903916164487, 0.9140130120363873, 0.16288492275877575, 0.20601255440698074, 0.8986483901032837, 0.2099688466236752, 0.07344651685124082, 0.21055479943303312, 0.20502557664999677, 0.1554647417994367, 0.10441246276804672, 0.21134842385454056, 0.8774565761214096, 0.2012994610094757, 0.20254081656116363, 0.23583772200880815, 0.1938329173070028, 0.2373329299488084, 0.22110324072405585, 0.2081442063040405, 0.21293133084207727, 0.22391835772229318, 0.09649130548589924, 0.08950811282134197, 0.1018506892886718, 0.08721259123383884, 0.10153113122123836, 0.09772847600325929, 0.09436177389175826, 0.09708132941368619, 0.09918941542153115]}, "mutation_prompt": null}
{"id": "d9e310db-b3b9-46d5-bbd8-92af52887232", "solution": "import numpy as np\n\nclass AQIDE_ED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F_base = 0.5  # Base differential weight\n        self.Cr_base = 0.9  # Base crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def dynamic_parameters(self):\n        # Dynamically adjust F and Cr based on memory and diversity\n        diversity = np.var(self.memory_F) if self.memory_F else 0.1\n        self.F = self.F_base * (1 + diversity)\n        self.Cr = self.Cr_base * (1 - diversity)\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n        self.best_solution = population[np.argmin(fitness)]\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.dynamic_parameters()\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)]\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_ED", "description": "The Adaptive Quantum-Inspired Differential Evolution with Enhanced Diversity (AQIDE-ED) incorporates dynamic strategy selection and diversity boosting mechanisms for improved exploration and exploitation balance.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'AQIDE_ED' object has no attribute 'F'\").", "error": "AttributeError(\"'AQIDE_ED' object has no attribute 'F'\")", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {}, "mutation_prompt": null}
{"id": "a7d1f249-8176-4ba8-a9c4-59c6f1d4daa4", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "b10c4a30-9365-4841-93b8-f7f369465be8", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "f5ee33a6-17a7-4079-a8e8-7a87c09e6597", "solution": "import numpy as np\n\nclass HQGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Differential weight, adjusted for diversity\n        self.Cr = 0.85  # Crossover probability, slightly decreased for exploration\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.20  # Preserve top 20% elites\n        self.mutation_probability = 0.05  # Probability of mutation in genetic operation\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def mutate(self, individual):\n        mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n        return np.clip(individual + mutation_vector, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Apply mutation with a certain probability\n                if np.random.rand() < self.mutation_probability:\n                    trial = self.mutate(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "HQGA", "description": "The Hybrid Quantum Genetic Algorithm (HQGA) combines quantum-inspired initialization with genetic operations for enhanced exploration and convergence.", "configspace": "", "generation": 59, "fitness": 0.4541850841624874, "feedback": "The algorithm HQGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8556047216182712, 0.8377894817477975, 0.8372818299229593, 0.8660349923586825, 0.863434599613844, 0.8499494110041398, 0.8452973838458924, 0.8599249320720301, 0.8484514812017349, 0.7293176522502227, 0.6979610733900316, 0.7178684711326685, 0.7085755230053027, 0.719532568087154, 0.6936256503171774, 0.7151513597940183, 0.7058786315913592, 0.709550936480325, 0.1378881019441729, 0.1495446826072473, 0.1491025866151987, 0.17327970816213767, 0.12648081051931737, 0.13479425941196022, 0.13115903106284243, 0.1203645250099773, 0.12142455193432011, 0.1466412369103688, 0.12392479661134825, 0.10719195372630763, 0.1066062679285733, 0.1158731211408971, 0.12287103558946422, 0.1347091067257612, 0.10483036654270417, 0.1686555943653757, 0.9914683570609873, 0.9836161698404018, 0.9874242952082585, 0.9799971758984003, 0.9809716164149281, 0.9777006664967994, 0.9798723858476405, 0.9760167395454638, 0.9822423705554273, 0.6537549887806515, 0.6744461951604344, 0.6468105792387356, 0.689225355056893, 0.6609422142154515, 0.677727932268838, 0.6802863085180515, 0.657843963216459, 0.6827837789120615, 0.831107689083628, 0.8577331152546294, 0.2084333438284688, 0.8693130517468295, 0.8552658576408417, 0.8484299748775744, 0.8828154794882437, 0.8222320350661725, 0.8581933351612425, 0.6277183163301742, 0.12465601117566327, 0.6724983203458885, 0.645000722137453, 0.671202367312961, 0.6404463560468077, 0.6801208304341715, 0.7303910749182341, 0.6715889205777064, 0.12680349408924196, 0.6449512168006651, 0.41805010143065235, 0.6402009213088382, 0.5896526144533647, 0.6965184939176786, 0.7099458630150548, 0.12238518317860836, 0.6738615392689695, 0.04110133467126065, 0.5258765480420169, 0.5897823234995312, 0.0012421490581715489, 0.640294051081845, 0.46730759883321205, 0.6540393297915132, 0.5119652825075041, 0.6259542602939558, 0.6463609443040514, 0.6939020998443673, 0.6339962256471281, 0.6994776220485293, 0.656723642267921, 0.7013719304719981, 0.6799962348505066, 0.6892351791216659, 0.6805583281926326, 0.28446944417247455, 0.16646692555443987, 0.4511125171816056, 0.4105250579390145, 0.5190643699495604, 0.26267567205249276, 0.3911579549176172, 0.2415236908619015, 0.2998140414204862, 0.5079138918244577, 0.45261829830901434, 0.4761011037610958, 0.5273090018977596, 0.511221661685487, 0.49645920092307694, 0.4797775465091415, 0.5008194267051878, 0.4880148397702465, 0.7729655978900557, 0.7946723349050075, 0.7993809828216224, 0.7825210392264531, 0.7980230546858247, 0.7692891575118926, 0.802609766953048, 0.7709484560517257, 0.7955799988280364, 0.11039143516715189, 0.14346304211742733, 0.13258843184775637, 0.12134999155505244, 0.13500989749414893, 0.12532991196268106, 0.11898410179980423, 0.11266449639050713, 0.10337381040937232, 0.3133015516575227, 0.1963498702953006, 0.6340351974721221, 0.21971720589991184, 0.2661099862820474, 0.6632529602556402, 0.2133739148203827, 0.5478275959145704, 0.6769944658583963, 0.5052216976226835, 0.2546153171693323, 0.5640778822413808, 0.610857847886997, 0.5820488864665055, 0.4185168206254941, 0.5335617201920624, 0.5073749365442559, 0.49333230564294295, 0.18224433277476193, 0.24636376828171014, 0.24374755271784965, 0.29757216793886476, 0.4066927915530304, 0.4804880077197544, 0.1385297014829976, 0.31976360712876173, 0.29337882988741026, 0.19803056927514595, 0.19908680938461842, 0.19559526972115004, 0.18771542343279646, 0.19809575031576643, 0.19302193105716714, 0.19642338787624425, 0.17473457486197952, 0.2018079655600633, 0.19300627981430618, 0.21928727435509832, 0.20340757541088128, 0.19418043121784812, 0.24364111866408766, 0.20378879909752046, 0.20461055199155376, 0.24752565803894577, 0.7384592801183201, 0.9091603663132759, 0.1074381958804439, 0.15319440791102767, 0.8742856541355726, 0.13199787733211832, 0.1311809085954232, 0.9029896907536857, 0.14167447479647832, 0.1140476137304478, 0.8803573875947279, 0.2111485177395822, 0.8706913525127017, 0.15542989617491054, 0.20754265365839886, 0.15457965341616164, 0.11283676501334483, 0.16489664538780346, 0.21182744389223074, 0.2163353945263532, 0.17337565033879943, 0.20373612911938133, 0.18546105907048827, 0.17693164337022904, 0.18436204016639046, 0.1918477252797144, 0.1731961970161079, 0.18286544579911324, 0.07527721893960804, 0.07370722693739695, 0.09932604442198611, 0.09338148157877735, 0.07622063831791637, 0.09816088511049825, 0.07655688254755444, 0.08708389102811431, 0.08450855321664696]}, "mutation_prompt": null}
{"id": "1f0fddeb-91f2-456d-9d27-7a656cc33644", "solution": "import numpy as np\n\nclass Enhanced_AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F_mean = 0.5  # Initial mean for differential weight\n        self.Cr_mean = 0.9  # Initial mean for crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.20  # Preserve top 20% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F_mean = np.mean(self.memory_F) + 0.1 * np.std(self.memory_F)\n                self.Cr_mean = np.mean(self.memory_Cr) + 0.1 * np.std(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F = np.random.normal(loc=self.F_mean, scale=0.1)\n                mutant = np.clip(x_best + F * (x1 - x2 + x3 - x1), self.lower_bound, self.upper_bound)\n\n                Cr = np.random.normal(loc=self.Cr_mean, scale=0.1)\n                crossover_mask = np.random.rand(self.dim) < Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(F)\n                    self.memory_Cr.append(Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "Enhanced_AQIDE", "description": "Enhanced AQIDE with self-adaptive quantum mutation and elite targeted reinforcement.", "configspace": "", "generation": 60, "fitness": 0.46404328599627703, "feedback": "The algorithm Enhanced_AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.32.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.9148909145141995, 0.8919871428709525, 0.8922730435789886, 0.9078567418217686, 0.8900796357696115, 0.8933022721879351, 0.9150731346491946, 0.8938247501500403, 0.901833045619051, 0.7783646227226826, 0.7832423794656378, 0.7575971194035166, 0.7645740457567496, 0.7915890481074087, 0.7306368563538594, 0.6984267414739769, 0.7756057795521378, 0.7633699319878693, 0.08549785932637755, 0.15411226301652658, 0.10395299344607212, 0.09915261223979921, 0.15708761244268865, 0.10695567875211198, 0.12152205580369735, 0.1348681272702401, 0.1166021434957909, 0.15810067043372877, 0.13764486764527517, 0.15668083431854807, 0.11651593806715865, 0.1284883701483195, 0.15332542957494333, 0.08800994607746726, 0.15426387540261766, 0.08789390690949983, 0.9820135105876251, 0.9795546210206514, 0.9765623473057546, 0.9733534216187683, 0.986253864981967, 0.9648084037630108, 0.9744104443958616, 0.9756312728934433, 0.9813779749293305, 0.825173472101407, 0.8161753220064767, 0.8112033825238578, 0.8388555406956262, 0.8104320503254266, 0.8326670162866031, 0.8174488766044095, 0.7933416695067359, 0.8310721842143282, 0.398017564192198, 0.20955972022784253, 0.8957800946795995, 0.9232137818877681, 0.9078273362021934, 0.19254347193109755, 0.13794655528848654, 0.17396582240240954, 0.164499474243612, 0.7258175045359374, 0.7347403950274829, 0.6465285409904666, 0.7581815324501935, 0.7703465295113422, 0.7244545533445321, 0.6971927778416591, 0.7574263006488016, 0.8143527673948958, 0.7773611819643593, 0.7642090331151398, 0.1171229690166592, 0.7591693301860827, 0.791231368571822, 0.7637443563673312, 0.7686624241854163, 0.6769914821877416, 0.13277726937249923, 0.6249051127120493, 0.4366682707877555, 0.7245640235137376, 0.6978907961669052, 0.7188066942766629, 0.0516478349232351, 0.8360613383611409, 0.3423258915376999, 0.7835159512997852, 0.8515701749415732, 0.8379097431201976, 0.8176256714313228, 0.8222101333409216, 0.8211654398307543, 0.7565809535193648, 0.8265719522861352, 0.8348904455543489, 0.7991831305770362, 0.27642144765949395, 0.5310578788695465, 0.26583284858921474, 0.5194823655531409, 0.7278182583306416, 0.716043600801632, 0.6378875240511799, 0.5397723479130414, 0.5427364432288899, 0.6917510715945804, 0.6244732424829544, 0.7163692712130767, 0.7467994811317193, 0.7018198210518023, 0.707393486635799, 0.0575047419819491, 0.668877345956258, 0.3890743099489731, 0.8669997180364729, 0.873941514892203, 0.8676088527712438, 0.8776583486071916, 0.8634064676462739, 0.8874298269427968, 0.8735344667448882, 0.8478585622302647, 0.8748151936035469, 0.09560488840240555, 0.08077374748730604, 0.1348616869461262, 0.13387512082237885, 0.041062014583134854, 0.1229819790048925, 0.08519428077930402, 0.10923871073913283, 0.0881864180685985, 0.1483874261057725, 0.16520702926451236, 0.786866464751022, 0.236514144764432, 0.1856072938884712, 0.21634953822875058, 0.20784460034640206, 0.2689842492469626, 0.22699794763168757, 0.5341935899295314, 0.3355757973033767, 0.34875482666584434, 0.316735400015129, 0.2587232511124391, 0.3222845307745744, 0.400660414476949, 0.5089758431787113, 0.48627320204380375, 0.42348777488913136, 0.2663958780405885, 0.2321948670256857, 0.2783090952335998, 0.2238505885695562, 0.2994919359456095, 0.23421709607032903, 0.39759288928051795, 0.25208376057547877, 0.24053625688001612, 0.24141248927500192, 0.1984682494364739, 0.23088901293867947, 0.2097846854691885, 0.23030028249640022, 0.18771940966000478, 0.22015190313146482, 0.1821790935273021, 0.1677902359703607, 0.17726501672286743, 0.1741884725215932, 0.2243523177851574, 0.2266727666140369, 0.1889019453484887, 0.1992644443624223, 0.1965907131171768, 0.18472354945526548, 0.9438435537819202, 0.1982863585864113, 0.15392224415995037, 0.15776506601424267, 0.16648618039690577, 0.17792270149072464, 0.17893507615165727, 0.16229632021614615, 0.15785406219051767, 0.16955387154116996, 0.16886825280274076, 0.1268130355321524, 0.2111990559555328, 0.08276448100940192, 0.1557449663989099, 0.10444597677454148, 0.21210862515930085, 0.9054965148698114, 0.20120601224258006, 0.1757263102162544, 0.21189750395832585, 0.2112421111970081, 0.17798522129875016, 0.18285610974607946, 0.22547706858246042, 0.18400013597365528, 0.17223272436416281, 0.10158462374888455, 0.07668941480711089, 0.10566497067831004, 0.1486610187938029, 0.08353655542838423, 0.07174348964138477, 0.11084744146682057, 0.09005792131718793, 0.09444177126388753]}, "mutation_prompt": null}
{"id": "af9a14c8-b1f6-403e-a577-e4f80b36c1a3", "solution": "import numpy as np\n\nclass QEADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.2  # Preserve top 20% elites\n        self.quantum_prob = 0.25  # Probability of quantum-inspired mutation\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.mean(self.memory_F)\n                self.Cr = np.mean(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.quantum_prob:\n                    mutant = self.quantum_initialize()[0]\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QEADE", "description": "The Quantum-Enhanced Adaptive Differential Evolution (QEADE) optimizes convergence by dynamically adjusting quantum-inspired mechanisms and leveraging elite preservation.", "configspace": "", "generation": 61, "fitness": 0.4493982898158365, "feedback": "The algorithm QEADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8771671048910756, 0.8668818811107301, 0.8708558304344689, 0.8781874106161752, 0.8672014693861717, 0.8773704956896384, 0.8615652235664569, 0.8806035341969003, 0.888194343036082, 0.7455916917350254, 0.5960923221261105, 0.730257622610953, 0.754483001081854, 0.7538126197775985, 0.7635408490527503, 0.7261768331714452, 0.6472946218181089, 0.7692197755531837, 0.09066481388033376, 0.15011852501302436, 0.09479516113067188, 0.15544020317112828, 0.1283645243566054, 0.15160161722475574, 0.14216610925411866, 0.18056884340230173, 0.15799911684935597, 0.13729268661286298, 0.13912396831395157, 0.10527405616180618, 0.11498695257292824, 0.10704446304977633, 0.09385294544571499, 0.1240685414993562, 0.13896274870338787, 0.10513714192033663, 0.9810478430861259, 0.9780295952389548, 0.9830656160661478, 0.9807605204008624, 0.9746631286467837, 0.9682254846705819, 0.9883365373601781, 0.968812469495222, 0.9736651916377216, 0.7507550769427197, 0.7417128904231536, 0.7423945093242709, 0.7154449490999912, 0.7333348085766578, 0.7271202622054865, 0.7297831823153114, 0.6949331943011687, 0.7098904392567986, 0.22634504885377238, 0.22748819500625173, 0.22922281271148626, 0.22084177701073182, 0.20735322567510472, 0.2785347087516068, 0.3713099154946181, 0.1744384261496429, 0.9045317245558686, 0.765064541215783, 0.6623006421341794, 0.7306556605313007, 0.633636416396668, 0.7050496913325132, 0.6576479261691806, 0.684670522020273, 0.7042814989003283, 0.13198710728864393, 0.7514575236561273, 0.69134360674494, 0.743108824894891, 0.7767977343144978, 0.12925084298002498, 0.6810455154480591, 0.5539795485471652, 0.6845399430902936, 0.7708823182392759, 0.7007134257230053, 0.43080945632214884, 0.626073538468759, 0.4011593862054931, 0.5954665823641019, 0.6788829876342688, 0.7432607180521217, 0.6984227432301244, 0.685369825758274, 0.7788291837387262, 0.733376628566948, 0.7887895565475519, 0.6934224494105055, 0.5891129622167088, 0.7113040922141988, 0.7707473640105982, 0.7180071869309155, 0.7800570990993703, 0.13581647739235236, 0.10384196415171576, 0.12610082338785666, 0.07704621837169001, 0.5745767810109067, 0.138911037202891, 0.11654023597968777, 0.12411347959979979, 0.22269679678254628, 0.5859515870249634, 0.510523631328876, 0.6106097265976682, 0.5595162268354454, 0.5649573495096735, 0.6338968024888886, 0.6193197811204103, 0.6222006219766854, 0.5833327717560176, 0.8488746520609556, 0.831820841416524, 0.8355712737861611, 0.8292277018391732, 0.802844442475394, 0.8242983185394632, 0.8330373643561475, 0.8220312171343773, 0.8316783158203132, 0.09032587664585678, 0.14747211899995216, 0.10856112451306033, 0.09731398472788255, 0.1289245052215683, 0.17632054200024394, 0.04910793792963053, 0.13906576647287694, 0.13605126093738706, 0.1635982097920673, 0.7024399151778976, 0.21497625749665228, 0.37205493056889904, 0.25057897565126774, 0.2107707316991052, 0.40325896692811225, 0.684172585544737, 0.23729939134169364, 0.3611261484458107, 0.2748823194731994, 0.2769663013628505, 0.46508083953350465, 0.3331835112350514, 0.5948406210808804, 0.28584784091420345, 0.45470632526192967, 0.536785314933941, 0.29231352892830875, 0.2833394537852837, 0.22934598619247826, 0.3627318364573635, 0.23019026762390726, 0.1890715964319345, 0.5003564279518535, 0.3026480284747103, 0.26513313719249976, 0.2017412899785037, 0.20666870997416387, 0.2007496612853401, 0.21049780426657905, 0.22094070116690323, 0.1952016734917864, 0.2148693428561158, 0.21679430352080942, 0.20344729345582924, 0.19882470085683024, 0.7973078520842027, 0.22162185301054194, 0.2009004843635599, 0.18795636438393504, 0.19275003621260334, 0.22793897100157579, 0.1914199776626594, 0.20529514124222537, 0.15732264635406812, 0.15783159738808294, 0.8575808029549739, 0.1689234940472033, 0.21295867371048072, 0.1993444105386415, 0.13306141262800142, 0.8953412544149638, 0.17148393682439034, 0.16045682505541303, 0.21216484713226003, 0.9045488768722283, 0.20866136439820326, 0.1671341903868614, 0.1668087854609165, 0.8981904106841215, 0.15754057767688523, 0.8894201182869363, 0.20145279859076626, 0.2722606951170624, 0.1810029407185273, 0.20983587605721832, 0.2075479872217536, 0.21305803772631948, 0.20956170822639386, 0.19277863644845472, 0.21106657826833142, 0.08382967456300061, 0.08998513391199126, 0.0771211678912831, 0.08560981004082568, 0.0733793846411338, 0.08334302756688572, 0.11766461405998652, 0.08758081476167445, 0.10356668983276462]}, "mutation_prompt": null}
{"id": "8077f68e-0251-482c-81b7-142c18490292", "solution": "import numpy as np\n\nclass AQIDE_MM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for diversity\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F1 = []\n        self.memory_F2 = []\n        self.memory_Cr1 = []\n        self.memory_Cr2 = []\n        self.best_solution = None\n        self.elite_percentage = 0.20  # Increased elite preservation to 20%\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F1) > 0 and len(self.memory_Cr1) > 0:\n                self.F = np.median(self.memory_F1 + self.memory_F2)\n                self.Cr = np.median(self.memory_Cr1 + self.memory_Cr2)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if np.random.rand() > 0.5:\n                        self.memory_F1.append(self.F)\n                        self.memory_Cr1.append(self.Cr)\n                    else:\n                        self.memory_F2.append(self.F)\n                        self.memory_Cr2.append(self.Cr)\n\n                    if len(self.memory_F1) > 50:\n                        self.memory_F1.pop(0)\n                    if len(self.memory_F2) > 50:\n                        self.memory_F2.pop(0)\n                    if len(self.memory_Cr1) > 50:\n                        self.memory_Cr1.pop(0)\n                    if len(self.memory_Cr2) > 50:\n                        self.memory_Cr2.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_MM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Multi-Memory (AQIDE-MM) utilizes multiple memory pools for parameter adaptation and dynamic elite reinforcement to improve convergence efficiency.", "configspace": "", "generation": 62, "fitness": 0.46067427095665586, "feedback": "The algorithm AQIDE_MM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.30.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8758596636380461, 0.8646669828184643, 0.8724818398558862, 0.8816688791228164, 0.8795945986503064, 0.8704407212671292, 0.8758760079272139, 0.8743866209440098, 0.8668199354801002, 0.7291511974735407, 0.7181668749974334, 0.7556717826082329, 0.7478576183756479, 0.7426124874176621, 0.7720297730969278, 0.747741272145502, 0.7304776672588218, 0.7346742942381612, 0.1400075595745024, 0.11865915588197407, 0.10331615948717954, 0.11909802123345359, 0.12504587615625296, 0.12878844858199168, 0.15802005045464151, 0.11362013984439379, 0.10916161711410588, 0.11474144973019407, 0.10403888211544798, 0.107514828099328, 0.11039109979563855, 0.08933244667798712, 0.07669143644517373, 0.0833216381877191, 0.15474726521202697, 0.15125274446928416, 0.9726526364424519, 0.9785181014896392, 0.974664304922701, 0.978863075149472, 0.9850778893480738, 0.9657742526609552, 0.9854737215773269, 0.9786733226357793, 0.9629299824989215, 0.7489338300719952, 0.7272039993149537, 0.7466578090148446, 0.7334253248520884, 0.7360758076933938, 0.7389198388675872, 0.7565922664021271, 0.7508544530807554, 0.7509765561101895, 0.8899589991409743, 0.3901802907658176, 0.22502470353075033, 0.19183876655897347, 0.2784107522020026, 0.885137897046084, 0.880549027051288, 0.17809761005772307, 0.24577935453795674, 0.1302702351023789, 0.6701227119050716, 0.6704961861897948, 0.12916396746265524, 0.7198500065682041, 0.13348848645942202, 0.13005415328751202, 0.7588596643136146, 0.6839696520379338, 0.7238809356717901, 0.7234893146855226, 0.7183907067623907, 0.6547737360638493, 0.7093229559084779, 0.7185142473916293, 0.6583060315286747, 0.6415045205224377, 0.13113845498941823, 0.5671118409713605, 0.7254547191892391, 0.6552328263518219, 0.23094162231211945, 0.6969158188217524, 0.6382726266067691, 0.6720448044109213, 0.696686678536538, 0.5758812046207413, 0.6742018039214727, 0.698575856515378, 0.7543711655628722, 0.7647774309702312, 0.7461498278192132, 0.7302636019810265, 0.6603023280664093, 0.7823271120934616, 0.7617696631594316, 0.6280786456218568, 0.41381447892790724, 0.6565767004171743, 0.601314389395831, 0.6112563752480362, 0.2287258576670853, 0.2236670815331001, 0.08495681349294137, 0.38101511285973777, 0.5883987154634576, 0.6151896016596001, 0.48323668660917196, 0.6117837477989094, 0.6347145549136639, 0.5997851230494657, 0.6105427153907319, 0.6131135142543567, 0.5724786845415206, 0.8240724014522575, 0.8389328019816726, 0.8303580592940183, 0.8337775143744741, 0.8408742743240368, 0.8421501577869543, 0.8370456159036604, 0.8253582976080057, 0.8250629244508942, 0.11636811697060878, 0.10841151002268945, 0.0840901811848358, 0.11239339157045836, 0.15376094408715268, 0.10349789688394662, 0.13702766866764182, 0.18413750100913462, 0.1399602260895907, 0.19789917888474307, 0.17763671168980477, 0.33728799308167223, 0.30220124996862685, 0.2062146182957144, 0.7740907658326043, 0.36580916447082057, 0.713540885466841, 0.3419663026337111, 0.2899113581530982, 0.2568159119908041, 0.31816854349662316, 0.4163689983942277, 0.44432381462822546, 0.6685970241405619, 0.4270049572925404, 0.35215215292253743, 0.5451998460732073, 0.25965097091321354, 0.23265447457335975, 0.2665726910660924, 0.28537683392789825, 0.2466232576356847, 0.34974269977747685, 0.2684697890481499, 0.5029269403383658, 0.213749836259572, 0.20608526528347637, 0.2026349941770278, 0.19763199910653595, 0.19050347476538376, 0.22673328914284163, 0.17458728735299756, 0.22715496466227714, 0.22259819783859114, 0.19054294093386603, 0.1827229001472508, 0.20399502952331316, 0.22055109107540072, 0.20330619707505626, 0.19626831803211187, 0.19539266416808443, 0.20800681957960232, 0.22232901856427623, 0.18911644529125027, 0.18530989105989848, 0.21091042633997248, 0.1990301918267937, 0.9239550088572029, 0.1989340975337225, 0.19834210566628674, 0.1419904472950695, 0.10872222593858227, 0.2101212777188377, 0.1553936873938061, 0.2123713516911031, 0.8823928532150497, 0.9065659553102327, 0.16729171171806956, 0.9057224006807667, 0.8954916196056271, 0.20990076654467882, 0.8983104719656608, 0.22474554558261128, 0.2252258513315405, 0.20259181219196776, 0.19890789682064192, 0.21009499226968542, 0.19790723872524252, 0.21550311120289412, 0.15988472009970212, 0.2249770004692554, 0.0896051868737543, 0.09585723410883384, 0.07568607872827793, 0.07170981052857384, 0.10046233868913745, 0.09651110180853739, 0.07865499521115504, 0.10820719730277939, 0.0792592659860607]}, "mutation_prompt": null}
{"id": "196682fd-aea6-497d-9cee-05cc78cc8d8f", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "232ad2e5-2cb2-4b7b-8d0a-843f8931953a", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "7f406a4c-6fb9-41a7-bf2a-d57dc9fa0b52", "solution": "import numpy as np\n\nclass QIDEDL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.7  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.20  # Preserve top 20% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def adaptive_parameters(self):\n        if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n            self.F = np.random.choice(self.memory_F)\n            self.Cr = np.random.choice(self.memory_Cr)\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            self.adaptive_parameters()\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x3 + x2 - x1), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QIDEDL", "description": "The Quantum-Inspired Differential Evolution with Dynamic Learning (QIDEDL) enhances convergence by integrating adaptive parameter learning and dynamic memory for improved exploration-exploitation balance.", "configspace": "", "generation": 65, "fitness": 0.3963116957027576, "feedback": "The algorithm QIDEDL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.27.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8677280973211481, 0.8541172514187281, 0.8639751839012846, 0.8600039189721899, 0.8659142057960713, 0.8705832253756096, 0.8505152302024074, 0.84275246655657, 0.861099822441947, 0.738636692970707, 0.7222160224970504, 0.7245767479997502, 0.7473237304540137, 0.7509441996919858, 0.757325365448279, 0.74008360252414, 0.7079274968783177, 0.7553829489327863, 0.6045845666086289, 0.1750816805837263, 0.09473766679947926, 0.6195221154207737, 0.14997819939229318, 0.17483603822421445, 0.61297266258673, 0.1538242177033078, 0.6899771153271663, 0.1420531948663052, 0.17808216914420605, 0.11759686554590976, 0.1329182931414281, 0.115845042000705, 0.11925266786637856, 0.08947759664155197, 0.1133167480133277, 0.15290646327206237, 0.9703425348197791, 0.9741354743290158, 0.970449571491031, 0.975882233383798, 0.9707668888013357, 0.9649909446133274, 0.9605653171689553, 0.9677830944862642, 0.9661961695996396, 0.6645609817610469, 0.6578069582581404, 0.6553325022869978, 0.6638039099254736, 0.6711457343255847, 0.6629740294798293, 0.6170657748162007, 0.6634678203548006, 0.6565309385096361, 0.8483344804970305, 0.3782731215697518, 0.8353107632263964, 0.19303398372616243, 0.8516399614932242, 0.20611609154354305, 0.23650005252790318, 0.232612960393624, 0.38970242252791243, 0.1307878237362574, 0.13105688253630832, 0.5623046849123061, 0.4618737389846288, 0.528232518859264, 0.4614616817046333, 0.5418348719539721, 0.5709171844160851, 0.6045540958197057, 0.12848872414620305, 0.5113426506747094, 0.47897090479785887, 0.5689450990125615, 0.6885784299880116, 0.5610205824235786, 0.566336248867573, 0.5118933929919022, 0.5406991943549877, 0.3871689416313945, 0.47411804912599564, 0.24286911362920138, 0.17860191508379253, 0.27060763372575547, 0.4899285670589114, 0.0584162261375375, 0.44556842847651246, 0.09397789263150536, 0.33286694163226616, 0.5490790405197008, 0.4767308209630604, 0.4757387095252993, 0.15061635866427114, 0.39427728966690145, 0.37278025323731256, 0.4571217959972027, 0.17050094903205026, 0.07154260729886086, 0.2633959967493773, 0.11467312559780674, 0.23139443244250746, 0.11609970656902535, 0.23227142113933186, 0.08881253992546079, 0.13191236298656772, 0.1872634509238652, 0.3357516553742702, 0.3494440601388329, 0.38469773644873384, 0.40393130244288267, 0.3511487849185593, 0.39935422738807946, 0.3525822044397894, 0.326628180408716, 0.33316491791982983, 0.773448382029138, 0.7505364599813618, 0.7606784117155474, 0.7273532487863521, 0.69985335115917, 0.7492594814595304, 0.7388348942283388, 0.7824430879941744, 0.7505278413482942, 0.09497777669921015, 0.1198942918622421, 0.09034444195721192, 0.1354461559299176, 0.13000711474630267, 0.13466744988702362, 0.12816628752824322, 0.12412525087155302, 0.1360320914014468, 0.5731799329081261, 0.1776666178198668, 0.211318472001657, 0.24103053644128802, 0.20502115604506888, 0.2035301941894474, 0.23505218452904697, 0.1694833704735078, 0.1648473782076908, 0.5753048301590991, 0.5205930790519558, 0.4284177075586897, 0.4907272411035699, 0.404090345924051, 0.6101697465069894, 0.5553738549746673, 0.5107236063260583, 0.6618144967002623, 0.1948604510521985, 0.23332457814306895, 0.23856237011897252, 0.4766738417304299, 0.21503001231476826, 0.2781783123052336, 0.2794036793368845, 0.26279103178609353, 0.21579754586359046, 0.1968841212653174, 0.21966854041726736, 0.2228095056063183, 0.2113404715508559, 0.19512271613618426, 0.22242166960077403, 0.20950506439890793, 0.1935799225901238, 0.20947189369248698, 0.2074546718653586, 0.24307511305717244, 0.24611393576671325, 0.2041991415682679, 0.24654581111811058, 0.21269974319003537, 0.21874117591721776, 0.21731476171608355, 0.195035280037961, 0.17030671937165898, 0.15271315534289387, 0.17483826143801184, 0.16924079430279415, 0.1207914665021157, 0.16426441387547697, 0.17627235966406318, 0.13105079168864564, 0.20955271255009134, 0.8986644730549294, 0.2113031010903169, 0.21052450545015022, 0.12744034116690361, 0.16724261368803417, 0.8814519219344246, 0.15526126969708787, 0.11218739289653934, 0.8461722113241874, 0.20924156181120646, 0.19567958201645375, 0.20395349036429689, 0.20027941765471668, 0.19419230062976867, 0.18828685271274082, 0.18862280947657084, 0.18197504044192125, 0.21131611488022073, 0.09268713889652025, 0.08547221879614375, 0.08981416601725101, 0.09018006185534655, 0.10132588354604455, 0.09913910268548776, 0.11396118069646977, 0.08658577060739558, 0.09205836254695476]}, "mutation_prompt": null}
{"id": "cf6f6ba8-2413-4916-9b97-6a94561ed6c0", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "db576765-fb3b-48e9-84e6-c481cb357c04", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "e21e9af3-035c-4cae-abbd-7aa128b2aa84", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "1ef938ca-e9d2-46e3-a978-298a892e8443", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "346d1d2f-96e0-4d10-b61f-59834f09adae", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "d4773cac-9fe3-4476-ac6c-5b5c37535a6e", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "81a99452-9fec-4371-9122-8370cc1d1421", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "9eed6a80-c03f-4148-9029-bc17408f6fb2", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "1087df72-5e60-4c5c-b85b-b587a03d67a2", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "0c5b5740-2db4-4d68-b5f5-49161d11d465", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "5a67999d-53cc-4fa5-8da8-92023976049c", "solution": "import numpy as np\n\nclass QI_DE_MOM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                # Multi-objective mutation strategy\n                F_mutated = np.random.uniform(0, 1.0) * self.F\n                mutant = np.clip(x_best + F_mutated * (x1 - x2 + x3 - x2), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(F_mutated)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QI_DE_MOM", "description": "The Quantum-Inspired Adaptive Differential Evolution with Multi-Objective Mutation (QI_DE-MOM) integrates multi-objective mutation strategy to enhance diversity and convergence in optimization.", "configspace": "", "generation": 76, "fitness": 0.1663387143088331, "feedback": "The algorithm QI_DE_MOM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.5491656826716345, 0.5982556294181277, 0.30412130562607376, 0.375613915372886, 0.7423739669053169, 0.4306649218774157, 0.410045045754013, 0.7440108968764669, 0.7959982793686176, 9.999999999998899e-05, 9.999999999998899e-05, 0.01714893915663329, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0640778217449599, 9.999999999998899e-05, 0.062035437069603905, 0.0663668909385311, 0.1135833132731523, 0.042805683417843854, 0.04304237864526805, 0.10462110312367512, 0.11972448276930647, 0.1122588003466477, 0.0515905617085487, 0.06880071108467967, 0.055890957559604826, 0.06630652479125998, 0.043378964813716836, 0.08933737734595815, 0.03503980851278776, 0.10816147444019919, 0.02807770697587242, 0.057599312736272834, 0.9842183052722433, 0.9839678815318277, 0.17893960796017128, 0.1704065431652223, 0.9424725315539532, 0.3877431940977112, 0.12139335093272385, 0.976879712800261, 0.9878957054114985, 0.11408693625478517, 0.25925879616295455, 0.07756299197703687, 0.042393887902101635, 0.15627700658774157, 0.1558439428826478, 0.09743899636622555, 0.15584463223749845, 0.06297094202641895, 0.21160689533246246, 0.1365557113755005, 0.13265059113177236, 0.1102943966949641, 0.16508595381097568, 0.21268575247175803, 0.07567377553115207, 0.17559378017128968, 0.13906336274507358, 0.1425529406799757, 0.1547521922790447, 9.999999999998899e-05, 0.2673193414708449, 0.17653407628180318, 9.999999999998899e-05, 0.10402876751608348, 9.999999999998899e-05, 0.0823688333730459, 0.21811283012306448, 0.023195984030633388, 0.09867468882870178, 9.999999999998899e-05, 0.1688526716077886, 0.13265559318365505, 0.010022091097871666, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02468662811030331, 0.06092107554438919, 0.07378536098576738, 0.09559873389092444, 0.05659188788521019, 0.01158521844052085, 0.03679278419496079, 0.018315095234926027, 0.012135177732003677, 0.2007437379768704, 0.2445122950089531, 0.047485400710575276, 0.047818538337033756, 0.2021197051051904, 9.999999999998899e-05, 0.20129678210182167, 0.19897542626841125, 0.030270273564062533, 0.16099394441931614, 0.08646202287037486, 0.10502005908403333, 0.06584175060252873, 0.07743623235508434, 0.0633773359851153, 0.11224922568848994, 0.05805661474799528, 0.0800284614742337, 0.29305494266994114, 0.3884259212952814, 0.4342694235655553, 0.3315437293847018, 0.37900881459185065, 0.383575993336871, 0.25152768212276044, 0.410840290212826, 0.3773896812963119, 0.09296421537664046, 0.0453984146755827, 0.0901680439307303, 0.0658475263253806, 0.1456009453577739, 0.1352957270250954, 0.059019872584191946, 0.09179401125076236, 0.07693124607388213, 0.13683428470023695, 0.18479271439036427, 0.22933727703184603, 0.16859637373926084, 0.1378063704583683, 0.1763572842336606, 0.12217987477655823, 0.2996808602943477, 0.2161934882623051, 0.18786479695852876, 0.22651276329687597, 0.20436240174754472, 0.167645379671859, 0.21907904148607638, 0.1376079157042328, 0.1944236377890518, 0.241709070385687, 0.14638088283883421, 0.17109314923155927, 0.12629616238024377, 0.1667618864478163, 0.11984355038816596, 0.09559404541158056, 0.17903595556113827, 0.1662152641481327, 0.2074679890941098, 0.06694469032467187, 0.20711473206796116, 0.2637985934001412, 0.14689440102040008, 0.1574035303872906, 0.2135008897871432, 0.17180452624036113, 0.17656696550991147, 0.22248348657168748, 0.1261963614278906, 0.16447053292909897, 0.17915437869839024, 0.17939514264253376, 0.19551684644031142, 0.17828889369132306, 0.18680752591468286, 0.16275469460264325, 0.1731022801786738, 0.18498243976448003, 0.07066862705546906, 0.18788079214728626, 0.15438870255648107, 0.11944288020038674, 0.1698522425265543, 0.16969195652996172, 0.1070176662487543, 0.16534956814654744, 0.18731764615845636, 0.17263458182098057, 0.37570737022245726, 0.164237536684824, 0.16874195810072667, 0.169715804362233, 0.11021891025335029, 0.15856563592330053, 0.09410266962278169, 0.18914081141677952, 0.20048976491382664, 0.1909150591321368, 0.17292203156249797, 0.21099669619504235, 0.22387955952933958, 0.18481185532932987, 0.2115265735996833, 0.22033282082106342, 0.22358924307591121, 0.06839028119400659, 0.07142140842892386, 0.09261714238259322, 0.056833154837374944, 0.07588413949991313, 0.07853269969629806, 0.06574633757849535, 0.07681980457598625, 0.05989568776942178]}, "mutation_prompt": null}
{"id": "e53f8cd3-91d1-4244-b9c5-30ff3cbd55a1", "solution": "import numpy as np\n\nclass QE_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F_base = 0.5\n        self.Cr_base = 0.9\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.2  # Preserve top 20% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def adapt_parameters(self):\n        if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n            self.F = np.median(self.memory_F) + np.random.normal(0, 0.1)\n            self.Cr = np.median(self.memory_Cr) + np.random.normal(0, 0.1)\n        else:\n            self.F = self.F_base\n            self.Cr = self.Cr_base\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            self.adapt_parameters()\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QE_ADE", "description": "The Quantum-Enhanced Adaptive Differential Evolution (QE-ADE) incorporates quantum-inspired initialization with adaptive mutation and crossover strategies for robust optimization performance.", "configspace": "", "generation": 77, "fitness": 0.35943223819758613, "feedback": "The algorithm QE_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.30.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.9298017725908856, 0.8458760595412311, 0.9304631688822047, 0.9313283578876436, 0.8651049446408723, 0.9193615613500847, 0.9299529948665497, 0.8624655939866649, 0.9162301376080315, 0.023273549882750877, 0.7729737349390364, 0.7083817914013162, 0.07535339131595664, 0.7586458360561026, 0.7876738358667634, 0.1366812114732069, 0.742874078175622, 0.7754575501917377, 0.09632073501638638, 0.11757358458354261, 0.1014940474058178, 0.12379527728705275, 0.14648792322525328, 0.11753713506795849, 0.14739354187627118, 0.1478730595971559, 0.1311048493406075, 0.11646760008904189, 0.11295075466752513, 0.042137815826769676, 0.06439381164448676, 0.07861906984030742, 0.04180043766948094, 0.09638755257726095, 0.09111863428751854, 0.12366407216422426, 0.9689778691913099, 0.9793678144712851, 0.9683581393028426, 0.9790279921651566, 0.974809373057188, 0.9596800600761982, 0.9778847155477779, 0.976836927100461, 0.9808741668544579, 0.5082867652772536, 0.6080455765475175, 0.77220651068308, 0.4535731155635395, 0.7858548327414875, 0.8177935484585495, 0.42949967304959613, 0.7970884002292593, 0.8185367899750255, 0.22648179790618894, 0.8640972659778244, 0.2293673583176239, 0.9286262081730402, 0.8853003643180144, 0.14982716094647308, 0.23417466950422405, 0.8642181534651145, 0.13847657478097375, 0.1635692228446909, 0.12741424179634853, 0.5207520905488109, 0.13463923668251754, 0.3404795045795509, 0.5283502530769497, 0.17043288933486378, 0.3003647663693243, 0.7989480294704424, 0.20718312262222816, 0.3676693716165642, 0.37590216268277477, 0.15793715615451587, 0.782109156865217, 0.7471260612237309, 0.13078123735619085, 0.12647258130028527, 0.6391292554164698, 0.10440912233619004, 0.7773576104453965, 0.1185369631222919, 0.02206342852369869, 0.775876171487289, 0.053888228062593746, 0.0555644765976403, 0.76833296655066, 0.08499741937307848, 0.12703072026203177, 0.8141903169842836, 0.2337129685897028, 0.06753252804075349, 0.8046613262438491, 0.7810435886048179, 0.21874173284211818, 0.7421529646200387, 0.343461388307873, 0.3216675443840513, 0.1153960735402556, 0.16218921326338642, 0.08267137318209139, 0.07774091626101531, 0.3147294280965933, 0.14407581036377382, 0.0823057407351232, 0.09619455496680007, 0.11671452801618487, 0.18619053395105467, 0.17596290153633576, 0.07303789632822755, 0.5062423777049478, 0.4513555066042393, 0.3232815206990115, 0.5134906422673758, 0.2898978155129335, 0.5565492045153272, 0.6923354060876532, 0.7166695421686002, 0.5731553960809972, 0.6905586446331267, 0.8339778512872162, 0.6226629151567055, 0.7796555948910514, 0.8725498854331364, 0.07151794884040552, 0.14104185415877835, 0.10453936901547789, 0.12417104887472419, 0.13590544597920473, 0.1465054371521055, 0.06992804452222956, 0.0988829733404264, 0.07778242105245914, 0.17830675416889685, 0.3088599177256697, 0.41928319022176386, 0.26892632832362995, 0.2113068454802728, 0.3673741469492472, 0.1605084672372119, 0.2625688988656225, 0.29126311863655996, 0.3193420786460932, 0.4810577336711004, 0.17721174851754984, 0.2185311887548682, 0.405735137029831, 0.3429350160518687, 0.20116013954369394, 0.34750457323809936, 0.1828786520988247, 0.22387565927559627, 0.3237074267517732, 0.21825238423138527, 0.2190240463520462, 0.2956069177566656, 0.19993111307053946, 0.18194149502854007, 0.3258867646079331, 0.2679616608110147, 0.20087414125879055, 0.22404178173225353, 0.23606837326535235, 0.1899953967490986, 0.201077294531527, 0.2692922487141777, 0.2129160734415514, 0.20036659072917484, 0.19337848428772209, 0.17414929223678954, 0.24434975865455988, 0.18037498485620562, 0.17985165185138263, 0.24892922629385228, 0.21207829062894235, 0.17587789009499688, 0.20422383269253253, 0.22901570335237686, 0.16507016220045367, 0.1578108817256798, 0.15471192718205984, 0.17208725009348258, 0.1990874669914957, 0.114458893779541, 0.12670886725492436, 0.17435395582986146, 0.1426002021703474, 0.15721886798079687, 0.8691615211975803, 0.12786904875383776, 0.9334913238271676, 0.9022829781979765, 0.15585047437733124, 0.10504357910329598, 0.10435294913386495, 0.16790836801629427, 0.20300314140759002, 0.1873152649785197, 0.18451065106475306, 0.18797882381107767, 0.18944284210212603, 0.17758871736195359, 0.1893480810462672, 0.1848261152362095, 0.22387230424194182, 0.09798950762845693, 0.07629465800138291, 0.09850818093220803, 0.09001563153249559, 0.07751699577559734, 0.12271499123171237, 0.09273173000483037, 0.10719299429767015, 0.09800276574664624]}, "mutation_prompt": null}
{"id": "444d6911-739e-47bc-aa36-fc2bc2632977", "solution": "import numpy as np\n\nclass QIDE_RPE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Differential weight\n        self.Cr = 0.85  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.2  # Preserve top 20% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 5 and len(self.memory_Cr) > 5:\n                self.F = np.mean(self.memory_F)\n                self.Cr = np.mean(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 50:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 50:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QIDE_RPE", "description": "Quantum-Inspired Differential Evolution with Dynamic Parameter Tuning and Reinforced Elite Selection for Robust Convergence.", "configspace": "", "generation": 78, "fitness": 0.4527745950526485, "feedback": "The algorithm QIDE_RPE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8421649630627304, 0.8485544521047509, 0.8535918404705933, 0.8586857576974658, 0.8673761798876315, 0.850560693648987, 0.8543665241734523, 0.8481148493006407, 0.8522042544906128, 0.7126003469180302, 0.7204045689284277, 0.7406369645474689, 0.698808305899871, 0.7192055850641986, 0.7270843683843109, 0.7014392630703287, 0.6728148224644401, 0.05116703798666533, 0.11576792838447869, 0.1373900032998261, 0.13541158416604981, 0.1122763480840675, 0.1349108139203139, 0.14306189335245434, 0.13904932652252644, 0.14465027155199495, 0.09399628728005605, 0.12435143870897902, 0.08866865938507695, 0.13391369446487755, 0.13117695948979258, 0.07492002347788296, 0.11319544816814542, 0.15013855688191668, 0.1262605671847481, 0.11958857239234999, 0.9701170483838644, 0.9876332021512394, 0.9754710877478364, 0.9715589714475446, 0.9763627426560465, 0.9728549439750758, 0.9808289397696994, 0.9762000698560502, 0.9901561385821083, 0.7057332376173385, 0.6686547864139458, 0.671256267826466, 0.6708176626599249, 0.6792572969652446, 0.7015414711172907, 0.6862580427923601, 0.6583328387092942, 0.6524916252965802, 0.8831323874089368, 0.8508172972840696, 0.22450832685279953, 0.8691205645596004, 0.2122112219564537, 0.8631310983048, 0.8410310274828956, 0.8647517883816084, 0.23447385493851747, 0.6782740093266804, 0.6625516259050129, 0.6146402409154685, 0.6515571314145376, 0.13003213414547632, 0.6650272636600074, 0.7326126263542524, 0.627084658358364, 0.6292858406251862, 0.6299211811818206, 0.6489429210067329, 0.6703589021805726, 0.6550526150863949, 0.6979974492273826, 0.6959278371946015, 0.7291325350456631, 0.1308186424995441, 0.7017166851817849, 0.5591260224294661, 0.6241881191651978, 0.5909813751218247, 0.1960917701939291, 0.6140564772295114, 0.5787185427951995, 0.4381431140157205, 0.6430595809573105, 0.5208943842738837, 0.6872734453734233, 0.6847289567491248, 0.6803123037921132, 0.6372914825228069, 0.7096421042593746, 0.6356808509698386, 0.7132548348406937, 0.6754188036090557, 0.6646278685448932, 0.14275467749185722, 0.21866941615356927, 0.1484432222783848, 0.3173355091979707, 0.5649464600003493, 9.999999999998899e-05, 0.3506084172743681, 0.06984025432219876, 0.12978613580821619, 0.5064017915407941, 0.4781285434496738, 0.5086853807826703, 0.5045687227624582, 0.5368593274743587, 0.5235755734754104, 0.512800591464236, 0.5161800084820484, 0.5290372656622528, 0.8114572328855412, 0.8110619427644494, 0.7995111594189948, 0.8060786255753551, 0.8102504250856877, 0.808047018166082, 0.8137809431486265, 0.7917720626991764, 0.801375196850996, 0.11760038197241118, 0.10636432339590096, 0.10811134043959103, 0.13007779697893307, 0.08036889513137835, 0.1067418069100835, 0.08920797757052057, 0.1733269322487485, 0.102725363504654, 0.19098061739056715, 0.16907710733502812, 0.2995921537396423, 0.6414686112554551, 0.2251320338784495, 0.26192781575664503, 0.23479638499942646, 0.6909786475386712, 0.193540562159758, 0.22162972396088987, 0.4423564613526215, 0.5794404398405795, 0.5894623998384656, 0.5378268656454619, 0.6174103645309779, 0.6203227095756687, 0.5148589751322908, 0.5075834816143737, 0.27641221322785603, 0.49630583119805927, 0.25557447089199725, 0.5051156078476617, 0.2806556362077435, 0.5529044086078774, 0.5389273882984293, 0.447337185832842, 0.16710381441481403, 0.19352744593038174, 0.2074957106812323, 0.1998420884736175, 0.1977021324080933, 0.20935747799047133, 0.2508589013794882, 0.209435105358181, 0.23749706740455168, 0.25455222072808503, 0.24246457921046305, 0.7644250563934708, 0.24511806709199657, 0.2428035763692743, 0.20414273442261488, 0.7211312375780635, 0.20676904350488468, 0.19200451495913262, 0.2065041135784771, 0.8786667303529323, 0.18406078109411805, 0.8882654727613293, 0.12240610150462439, 0.13179882706249668, 0.10265741537363537, 0.13111105045391125, 0.1829738758459326, 0.1652458569585753, 0.11342854993908635, 0.12786885610416843, 0.12695946934504931, 0.8599817209244343, 0.20620645537259763, 0.8759041545554752, 0.15532454338700175, 0.16639816197612567, 0.8830339005620422, 0.17140826316464775, 0.18739714541863128, 0.18889543565013212, 0.1852467938488932, 0.17551263539894224, 0.19063814848320038, 0.19458333552986729, 0.18275812343938713, 0.17690616285470007, 0.10057940433166135, 0.08574028387783861, 0.0763761414484323, 0.10794955577037002, 0.09073105769970247, 0.08567339947514652, 0.08724789839474267, 0.08018786716469517, 0.07661781583829574]}, "mutation_prompt": null}
{"id": "e129e3e5-0ac7-4b1d-a3e7-f036a8ded9bd", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "ac5bf59f-91eb-4b62-8f0b-97fd32f38155", "solution": "import numpy as np\n\nclass SGIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.gradient_memory = []\n        self.best_solution = None\n        self.elite_percentage = 0.1  # Preserve top 10% elites\n\n    def initialize_population(self):\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.pop_size, self.dim)\n\n    def approximate_gradient(self, func, sol):\n        grad = np.zeros(self.dim)\n        epsilon = 1e-8\n        for j in range(self.dim):\n            sol_forward = np.copy(sol)\n            sol_backward = np.copy(sol)\n            sol_forward[j] += epsilon\n            sol_backward[j] -= epsilon\n            grad[j] = (func(sol_forward) - func(sol_backward)) / (2 * epsilon)\n        return grad\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                \n                gradient = self.approximate_gradient(func, population[i])\n                self.F = 0.5 + 0.5 * np.tanh(np.linalg.norm(gradient))\n                mutant = np.clip(x_best + self.F * (x1 - x2) + 0.1 * gradient, self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "SGIDE", "description": "The Stochastic Gradient-Inspired Differential Evolution (SGIDE) integrates stochastic gradient approximation for parameter refinement and an adaptive mutation scheme to enhance exploration and convergence.", "configspace": "", "generation": 80, "fitness": 0.09044749746303837, "feedback": "The algorithm SGIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.16.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.1594181517374922, 0.17826678740294521, 0.14901188279726407, 0.20068842380522878, 0.2072677920901682, 0.20279138600879953, 0.1758388242230673, 0.19061463272487356, 0.1810143226740909, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017468269711246043, 0.022964496193297435, 0.005375109906600173, 0.010643411704069683, 0.019969072284263922, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.9189803988404801, 0.8628756701420286, 0.19208830999969773, 0.8873309163758324, 0.38453196860981054, 0.21885919269547172, 0.8631720578259394, 0.8429301902665233, 0.9657945049925845, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 0.007378377370581113, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.2121768906449253, 0.1918274340832904, 0.41561454220460514, 0.2476428266746773, 0.320431281305559, 0.1952462990285877, 0.20028262416440867, 0.25261180005358863, 0.25789360177935305, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15400927906899664, 0.17056392933998943, 0.17033481958962915, 0.18073253206047468, 0.16248329716948462, 0.16930501111206864, 0.1698854987187809, 0.16158223177875608, 0.17272894334288325, 0.005391106575296178, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 0.009748988877320897, 0.01759993274736349, 9.999999999998899e-05, 0.0008480334377826138, 0.0267656688986897, 0.12128611704586456, 0.0942358351346595, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.11018343753742066, 0.11608527452768669, 0.10908793949278461, 0.12285597930063974, 0.12391124876847082, 0.17280646444371528, 0.14614998045117933, 0.13894871039353562, 0.13823545697383288, 0.1354906426383281, 0.17377774300845283, 0.1582938366154354, 0.05985564337097804, 0.037663591679862884, 0.08398582550377798, 0.056957211629895754, 0.06406947898089654, 0.06342850570876157, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.09388200728521401, 0.13345086981233123, 0.1103568689991713, 0.08780202581330288, 0.10896891037713907, 0.12245976138762271, 0.07872931414554718, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17376540187482004, 0.14340275004080705, 0.10690833907396302, 0.09369801475310757, 0.1487402910798521, 0.10591525960088533, 0.12758811527355796, 0.10511484148144368, 0.13325347790680298, 0.11147694430974464, 0.11812120917772595, 0.08276526846290344, 0.10241262682944985, 0.07511114396195939, 0.14816479330242094, 0.09804224804083528, 0.1373300740560497, 0.09138213438167386, 0.13720730436585615, 0.15571165331138093, 0.1771182303559905, 0.14848877092951185, 0.14999923528127657, 0.1581630763934152, 0.15082751645619752, 0.17014378979792122, 0.150940316228246, 0.013617939348936514, 0.015916393435176368, 0.031393493129599714, 0.027015293023570086, 0.03425093938292756, 0.020045516730027746, 0.016228383701229143, 0.03803354422653826, 0.017643830485487344]}, "mutation_prompt": null}
{"id": "a5086173-4579-43df-92e2-1adb4667d616", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "e01398c6-8ccd-44eb-8d99-a092d76e844b", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "acfd6d89-2d47-4801-a070-f33c7844824c", "solution": "import numpy as np\n\nclass DA_QDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.10  # Preserve top 10% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                # Introduce randomness in parameter adaptation\n                self.F = np.median(self.memory_F) + 0.1 * np.random.randn()\n                self.Cr = np.median(self.memory_Cr) + 0.1 * np.random.randn()\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x3) + 0.5 * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "DA_QDE", "description": "The Dynamic Adaptive Quantum Differential Evolution (DA-QDE) enhances exploration and exploitation by dynamically adapting parameters and exploiting quantum-inspired initialization.", "configspace": "", "generation": 83, "fitness": 0.38369818927482346, "feedback": "The algorithm DA_QDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8128508171786574, 0.7375015099136143, 0.6682298886404141, 0.7833615044921729, 0.7943784105265047, 0.6537195360919983, 0.7762388358819925, 0.6964572137081504, 0.7275330787817029, 0.5938556983110859, 0.4682507724074939, 0.41160520786416654, 0.6139960879225521, 0.43144689677315196, 0.39070035057333563, 0.6047530415514853, 0.44989568720471684, 0.482355422445656, 0.18074978855290724, 0.11094347283844441, 0.12034430320080758, 0.11415497309962253, 0.12771318149684763, 0.11023736219757307, 0.10155804333414631, 0.11346645133359634, 0.11565537691747196, 0.12675705883063604, 0.1060698448897276, 0.11096714475456337, 0.12634201490092622, 0.11273169662156779, 0.11087562999393064, 0.08995904955551981, 0.11818276188077437, 0.10941464818655533, 0.9561353630412547, 0.9528759227057109, 0.9810212444913082, 0.9704299950880406, 0.9757886901743761, 0.9685698433369864, 0.9824784713048963, 0.9599075967557701, 0.98753150969002, 0.5694986937953204, 0.44516331017183797, 0.34613158303285074, 0.5109955611956877, 0.4169832570367602, 0.3201179200090182, 0.6081903313769691, 0.35256664727376597, 0.37382333353562036, 0.7947256187827103, 0.7596222900285126, 0.8110367320324483, 0.8200305582723109, 0.7398578357845405, 0.7151792622075104, 0.7950310926219808, 0.6703823035790899, 0.7536483701599824, 0.6349883738698889, 0.20898847823299105, 0.3242357673762113, 0.6110440401573523, 0.11915553824905856, 0.514759197459868, 0.6284474476315962, 0.11258146682093106, 0.4795136308065737, 0.5931753704509031, 0.40928876268098535, 0.42977470252688277, 0.6976912463460949, 0.5113763740367366, 0.38213775272619066, 0.11782342607919705, 0.4552271065011936, 0.3462011218605948, 0.5464787347694762, 0.4630118280158083, 0.4385626660678801, 0.5795018751145725, 0.5289453678479485, 0.4093921323117179, 0.6076470324307252, 0.4459646648300841, 0.30554915028956353, 0.7297894956440214, 0.6033996099255109, 0.5510870568165562, 0.721492731173575, 0.4831280600475172, 0.5434635464293415, 0.695410879997658, 0.5264296219777531, 0.5143328687358011, 0.292416098540752, 0.12979786958518957, 0.17708121072579142, 0.3189742806818746, 0.3897157675391911, 0.15638950135654106, 0.2807798060577422, 0.2628104548398148, 0.10505314978959834, 0.5927052799042116, 0.3430819248799343, 0.28868244990653524, 0.566919599590501, 0.37697124210374167, 0.2847180073024531, 0.545496169948499, 0.3688100736174169, 0.29576602008752184, 0.7515076737419978, 0.6496459573934326, 0.5812716948538736, 0.751954326938435, 0.5377845497085192, 0.646676174196633, 0.7627003447642615, 0.5732595216615775, 0.5650341825446996, 0.10906167885514062, 0.10121389162298455, 0.09166885358228138, 0.1006566185349691, 0.09383048730595178, 0.08557227788008803, 0.09847063877042384, 0.09994944063676392, 0.0883116313549881, 0.12528901682294236, 0.13459379611857492, 0.1584783137547835, 0.13034141544976463, 0.2281228780257124, 0.23251948231891273, 0.17008549308650345, 0.16882605361337555, 0.39317810467052894, 0.5059128753314006, 0.4423725917315563, 0.392609592510356, 0.4373525988401622, 0.31528802556001534, 0.34927752139180646, 0.5274541189079159, 0.36759562203156093, 0.33857562190250146, 0.3731485703956253, 0.3099674147430359, 0.27849941857940963, 0.3813983848373469, 0.2038276941250119, 0.26666795213239103, 0.3652231128076904, 0.2530742551066196, 0.2982502585843796, 0.1800940113878292, 0.18779690485556133, 0.18811370622189238, 0.19244397507805666, 0.21736638381489704, 0.1984941876255053, 0.24053754064457322, 0.19087311965475706, 0.202306055985652, 0.21817807868789607, 0.20418915425438422, 0.17821802811851029, 0.19476794798074715, 0.31648607587161326, 0.24996321557269652, 0.19867752672780814, 0.3008906350450953, 0.2683443773312708, 0.202931930884809, 0.16732803214643477, 0.15245132764885205, 0.7979628094200355, 0.18353849248050147, 0.7334962344097358, 0.1070176662487543, 0.16642853971093696, 0.1885067630410462, 0.7614017306598135, 0.20674369307571705, 0.16669217831643268, 0.20596931574471633, 0.2038478550854972, 0.6969452434443255, 0.15380632026389263, 0.15244036037707143, 0.7275911382107172, 0.18925252603800913, 0.17955945772897997, 0.18467786793181729, 0.18119867229775555, 0.18325842775384937, 0.17935810259031149, 0.1798002536669563, 0.1711335683584766, 0.17471874973789692, 0.08155780030123205, 0.08250213988615973, 0.07623717715578116, 0.08208203762057986, 0.08005989269894687, 0.07294018146582637, 0.08628324451048686, 0.08703193971652978, 0.08067402711151916]}, "mutation_prompt": null}
{"id": "8ae3d072-e47e-4435-b12a-481640dcfd87", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "45735753-22ca-4aa8-adb8-665a435a943e", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "5d27b565-ed9f-4da1-90e2-2e8d9da435de", "solution": "import numpy as np\n\nclass EQIDE_CM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Differential weight\n        self.Cr = 0.85  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.2  # Preserve top 20% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.mean(self.memory_F)\n                self.Cr = np.mean(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x3 - x1), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 50:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 50:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "EQIDE_CM", "description": "The Enhanced Quantum-Inspired Differential Evolution with Contextual Memory (EQIDE-CM) uses contextual memory for dynamic parameter adjustment and selective elite reinforcement for improved convergence.", "configspace": "", "generation": 86, "fitness": 0.4434413277542349, "feedback": "The algorithm EQIDE_CM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8507827696017692, 0.8437254800798248, 0.8443147761625467, 0.8569788491261282, 0.8345399639385762, 0.8617088852701036, 0.8517850069904376, 0.8474987768076178, 0.8537773881080677, 0.7135884890090298, 0.6716812674225492, 0.7349048489162371, 0.7148589085412926, 9.999999999998899e-05, 0.7292635645285204, 0.7211570778770922, 0.7209366412500668, 0.711815874491982, 0.1143595989605175, 0.14611662300583628, 0.15591365615842112, 0.13703304447041809, 0.17445793370805818, 0.0760492860245604, 0.14712131420242036, 0.17869334167127693, 0.13298187673902173, 0.13562703285887656, 0.14162444393692897, 0.1177226588785204, 0.13783301833038153, 0.14717248737343758, 0.10305904912877084, 0.13398658064158353, 0.15094183824813046, 0.15132346344295855, 0.9778335898865058, 0.9732672347395079, 0.9816797369561663, 0.9852460164274071, 0.9673686772151352, 0.9714439549332269, 0.9848433007613527, 0.9789872231149546, 0.980241034727606, 0.7021253587062476, 0.6693243381804317, 0.6816894430491316, 0.7045375710385084, 0.6958494426774026, 0.697647687800524, 0.6772259116573767, 0.682629998768802, 0.681684069664605, 0.8747195197977788, 0.2264646303652802, 0.8307569587898005, 0.21158043385242065, 0.8921157101758258, 0.21681153312794554, 0.35376056846671944, 0.36943889284465037, 0.843010233744157, 0.12772981654936555, 0.7191291315336328, 0.6914875623521802, 0.6236098610218287, 0.6714578064890698, 0.6561321330619052, 0.6800879698363256, 0.1283755486530943, 0.6387655346059704, 0.13076493173370163, 0.6988840805280568, 0.6069429481319466, 0.6199672233553692, 0.6516769831207447, 0.6255384031752773, 0.12912462139654768, 0.5879856740911267, 0.6503335184562808, 0.6568486253745256, 0.5564945233243526, 0.5489611956280014, 0.5820557813870715, 0.33322580052999484, 0.6061475992312787, 0.6245167399830069, 0.5734357777746637, 0.6117698000229368, 0.727570326163353, 0.653538666271903, 0.5741968047569498, 0.6857619219356718, 0.6741135248726344, 0.6965781720310105, 0.07782576499363858, 0.7102252347934515, 0.6703353284192304, 0.16446911550250098, 0.39477047498265916, 0.1131228275734194, 0.51721494860799, 0.5026405172379611, 0.09143857477074013, 0.15680965775863986, 0.13645532215369294, 0.12138561244546386, 0.5112026182942824, 0.5033385788928311, 0.4827009864291054, 0.4956412285294449, 0.5687087217451245, 0.519879547896777, 0.4841857984263853, 0.4993501872516558, 0.49903964279865265, 0.8079829970897436, 0.7756644407098794, 0.7860276521304582, 0.7932520201595507, 0.8080836554861957, 0.791677499141614, 0.7956935504861047, 0.808585410965643, 0.7754982840333937, 0.10732442456731983, 0.09819288322399666, 0.134757530077384, 0.12615968593400995, 0.11320351950556529, 0.12829982117301297, 0.1728283728847093, 0.15419446946400495, 0.0836153528186192, 0.7843976600081203, 0.25443281527875694, 0.20303922052008205, 0.21700148230288596, 0.22130857597238907, 0.2843051784292172, 0.1454276564962551, 0.18275812532929536, 0.19292119142545383, 0.5149273553261893, 0.44067276545185197, 0.6214014946394428, 0.617136124587659, 0.2478023544720226, 0.5627818616389295, 0.5143960098587328, 0.5723132071379331, 0.6233460667368189, 0.39212648161939456, 0.35533822983396424, 0.2658717946643647, 0.46784674827843464, 0.21050369418074577, 0.3486997249116883, 0.44702068423672814, 0.4479845744318638, 0.4680635947989519, 0.30135163703392875, 0.19258456246277422, 0.21098589825269554, 0.1919457818200614, 0.1926242049217749, 0.19686519873070074, 0.21253375646485206, 0.204695229583026, 0.19630481580714143, 0.24493101517070703, 0.7562532181536104, 0.20519415397453078, 0.22132261041638823, 0.7207978152794947, 0.20640176165753288, 0.7302053198932953, 0.24236824158375136, 0.19886126799997705, 0.19808283860340192, 0.1693261445647759, 0.11261392689495264, 0.14688613339573875, 0.14789314952055332, 0.17047009850342687, 0.1755894700588626, 0.8939646591452775, 0.10679350612197536, 0.1281299935000756, 0.16861937822262318, 0.8562742283723564, 0.8636102449500601, 0.2108759694870188, 0.16608901864279635, 0.8895296408420665, 0.8552837759242592, 0.15382010955830006, 0.18950293462697831, 0.17354986017562402, 0.18122563761222665, 0.1939333340207109, 0.17767967072392699, 0.2196522563405907, 0.18001268856011032, 0.17637468981118176, 0.1858639988201799, 0.0718222158436096, 0.08315694001071317, 0.08868947473028599, 0.06821851358367603, 0.11618416284253508, 0.09298241359965176, 0.0915312473674672, 0.07880866088958505, 0.0875244931666943]}, "mutation_prompt": null}
{"id": "4ec48469-dfee-4557-9eb4-17d53eb09ef5", "solution": "import numpy as np\n\nclass AMQDE_MA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim  # Reduced population size\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.2  # Increased elite percentage\n        self.num_swarms = 3  # Number of swarms\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        populations = [self.quantum_initialize() for _ in range(self.num_swarms)]\n        fitnesses = [np.array([func(ind) for ind in pop]) for pop in populations]\n        eval_count = self.pop_size * self.num_swarms\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.mean(self.memory_F)\n                self.Cr = np.mean(self.memory_Cr)\n\n            for swarm_index in range(self.num_swarms):\n                population = populations[swarm_index]\n                fitness = fitnesses[swarm_index]\n                new_population = np.copy(population)\n                elite_count = int(self.pop_size * self.elite_percentage)\n                elite_indices = np.argsort(fitness)[:elite_count]\n                new_population[elite_indices] = population[elite_indices]\n\n                for i in range(self.pop_size):\n                    if i in elite_indices:\n                        continue\n\n                    x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                    indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                    x1, x2, x3 = population[indices]\n                    mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                    crossover_mask = np.random.rand(self.dim) < self.Cr\n                    trial = np.where(crossover_mask, mutant, population[i])\n\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < fitness[i]:\n                        new_population[i] = trial\n                        fitness[i] = trial_fitness\n                        self.memory_F.append(self.F)\n                        self.memory_Cr.append(self.Cr)\n                        if len(self.memory_F) > 100:\n                            self.memory_F.pop(0)\n                        if len(self.memory_Cr) > 100:\n                            self.memory_Cr.pop(0)\n\n                        if self.best_solution is None or trial_fitness < func(self.best_solution):\n                            self.best_solution = trial\n\n                    if eval_count >= self.budget:\n                        break\n\n                populations[swarm_index] = new_population\n                fitnesses[swarm_index] = fitness\n\n        best_swarm = np.argmin([np.min(fitness) for fitness in fitnesses])\n        best_idx = np.argmin(fitnesses[best_swarm])\n        return populations[best_swarm][best_idx], fitnesses[best_swarm][best_idx]", "name": "AMQDE_MA", "description": "Adaptive Multi-Swarm Quantum-Inspired Differential Evolution with Memory Averaging (AMQDE-MA) utilizes multi-swarm dynamic allocation and memory-based parameter averaging to enhance global exploration and local exploitation.", "configspace": "", "generation": 87, "fitness": 0.4036584284326923, "feedback": "The algorithm AMQDE_MA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.25.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.7675162974697329, 0.7398121499432149, 0.7664360683837972, 0.7756469898475109, 0.761261263045093, 0.7675388157494302, 0.7445613958715527, 0.7606500613984409, 0.7529348129732709, 0.42397834294788594, 0.5231793312435886, 0.5411292788701334, 0.5170222819816142, 0.5192014100027447, 0.5427454403130867, 0.49804359857118363, 0.5470781944037211, 0.5431873386222087, 0.12725982810873226, 0.1692925131498776, 0.10084917642413804, 0.12891424283875363, 0.13075148544967963, 0.15055343154884337, 0.1436158894892653, 0.14472268472017458, 0.1471602294362021, 0.09111774568768416, 0.11972848118542767, 0.1433212811925918, 0.10568302145193209, 0.15054965162408152, 0.10975252781768163, 0.12402380556578718, 0.11575253528573926, 0.10176127607118157, 0.9610315403440813, 0.9689743907998702, 0.9765360217535959, 0.9722227345090216, 0.9739171948003621, 0.9590573697122683, 0.9743946458368316, 0.9815486708348314, 0.9771551373563433, 0.543632725068653, 0.5315052942353243, 0.5172252046307342, 0.5411810750243871, 0.540906476133369, 0.526405632326426, 0.5307621580106833, 0.48866250608041806, 0.5503998128871359, 0.797957314292173, 0.7860915139883529, 0.7862924221449199, 0.2078187730260186, 0.8082366743174922, 0.26397261502431313, 0.7956858753106835, 0.7950070449964305, 0.8198615692115361, 0.5476756976796704, 0.5242900159888384, 0.6031206377247847, 0.12151844455143124, 0.48800865692536144, 0.5427886976781653, 0.5030955274630042, 0.5316261203854857, 0.4914836747438509, 0.5712503727355078, 0.12333250367215043, 0.5276298701723652, 0.46137836098248175, 0.4875009882305513, 0.519954166569223, 0.5707557545160993, 0.48971396647984944, 0.5167070092716826, 0.4409652740483837, 0.5077583501823127, 0.48723137235470826, 0.4953877051573905, 0.4089776914295593, 0.46178135733362413, 0.4132307728190273, 0.4526093681398128, 0.4175982663862202, 0.489646380493412, 0.5786474146994801, 0.5844496052805845, 0.5329290354900186, 0.6000394229123369, 0.6019695972818493, 0.5627121878564052, 0.565818873917743, 0.6230431235160311, 0.09126466166667746, 0.29365253763399035, 0.15804730587634153, 0.2829566476020601, 0.22707658214788784, 0.31273539619152657, 0.14577300441375407, 0.13369618354175394, 0.1137591943398607, 0.3300911196984303, 0.32271113507164906, 0.3216104703263333, 0.32360769367965825, 0.33720921413348504, 0.3453014912323765, 0.33345815611925333, 0.3239779084940815, 0.35100971671641057, 0.6921291691467867, 0.6988958401010312, 0.6943562717333498, 0.7046890789946627, 0.6867891130102346, 0.6939408508276645, 0.6930075138981407, 0.7021214565559881, 0.7024545594767971, 0.10262944129508211, 0.11338617339676826, 0.11026984926126226, 0.14338475438241782, 0.12264095780822659, 0.1178698964783309, 0.1299464214217929, 0.14299622610025997, 0.145512034697854, 0.21354024377005176, 0.2651194957279964, 0.38855604904269625, 0.1991861275401704, 0.2404099361550136, 0.2974315203720733, 0.32167214960334245, 0.13637586873306518, 0.5280356492848457, 0.4546879573790147, 0.45059023351250627, 0.4445521733410527, 0.3738834271977802, 0.40422116666824215, 0.4413806542950506, 0.45848534687048637, 0.435826257383678, 0.4457188489379248, 0.3371012265741785, 0.3527668431226427, 0.23016085662915797, 0.39012349187203177, 0.3687608813326154, 0.39683521181758763, 0.4000048754490161, 0.40677072658251945, 0.4109520686769732, 0.18900012033159352, 0.2261763215583792, 0.2248050470046581, 0.20039445475490303, 0.21493531484180517, 0.22170904698454963, 0.20533849499302348, 0.19331872963097696, 0.20472508098107678, 0.23587884716414997, 0.18811308317851894, 0.21578288287730196, 0.23902765909742452, 0.2191219412480998, 0.2159958773627645, 0.21311999014945526, 0.2141312920943621, 0.23884686071277617, 0.8472761721986862, 0.171426780083327, 0.14664654232214047, 0.1752581364611142, 0.1770609590593707, 0.19593996268400682, 0.8402045186450054, 0.14116697443274084, 0.8300913080625881, 0.1132897639811119, 0.20920260233756893, 0.8370275401851853, 0.8252030878448402, 0.8227254106682238, 0.1526706463705485, 0.11174712140881149, 0.8039086415463718, 0.11211992783491131, 0.1992845392173609, 0.1985331656333753, 0.20235799622577366, 0.20000276548785578, 0.20676653366215403, 0.21119040389803478, 0.19082423803039417, 0.19167944993078545, 0.20492300856659074, 0.10225895352866576, 0.08849180084482045, 0.13891482500411878, 0.08461438632849827, 0.09146615311144446, 0.083313257504389, 0.09180337752549916, 0.09117046813191332, 0.08132922598194259]}, "mutation_prompt": null}
{"id": "50d3ed26-ffbc-47db-9a38-d30299f9348b", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "8d3f6cfe-588e-4cd2-8cc2-4d32226c7eef", "solution": "import numpy as np\n\nclass AQIDE_EM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n    \n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def mutate(self, target_idx, population, fitness):\n        indices = np.random.choice([j for j in range(self.pop_size) if j != target_idx], 3, replace=False)\n        x1, x2, x3 = population[indices]\n        if np.random.rand() < 0.5:\n            mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(self.best_solution + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                mutant = self.mutate(i, population, fitness)\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_EM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Enriched Mutation (AQIDE-EM) enhances exploration by diversifying mutation strategies and incorporating adaptive parameter tuning.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for +: 'NoneType' and 'float'\")", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {}, "mutation_prompt": null}
{"id": "51090dd6-b784-410f-ba88-62086f790617", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "a4afba76-1d07-4a20-a8aa-20addefd4e17", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "0643c282-c837-4295-b831-c2dc73b896b2", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "d064628f-f0ce-4d35-ad1e-848cda091f0e", "solution": "import numpy as np\n\nclass QEPSDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.6  # Differential weight\n        self.Cr = 0.85  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0:\n                self.F = np.mean(self.memory_F)\n            if len(self.memory_Cr) > 0:\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QEPSDE", "description": "The Quantum-Enhanced Particle Swarm Differential Evolution (QEPSDE) incorporates quantum superposition in its initialization and adaptive crossover strategies for diverse exploration and effective convergence.", "configspace": "", "generation": 93, "fitness": 0.28598825982241727, "feedback": "The algorithm QEPSDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.6889484716922414, 0.6817607590093606, 0.6624207923300505, 0.6789546884705715, 0.6649386056690589, 0.6826985735294746, 0.6876914123761197, 0.6892717714774147, 0.6874440856462469, 0.4245137471184396, 0.445139642428125, 0.4657982529598753, 0.4282798564776451, 0.41510512839850966, 0.44885703633481144, 0.422016183775366, 0.43085404882980727, 0.4654902970077538, 0.11198250507030005, 0.11268061458138323, 0.11154969626117384, 0.09881263424067133, 0.11179757026652204, 0.09968464051038606, 0.09630405235072215, 0.10829618731931345, 0.1115813812638693, 0.10393961104974658, 0.09479889478364678, 0.1020236267063015, 0.09310607011301475, 0.1003275940615207, 0.10589451572777486, 0.09462183839723637, 0.1014795331688465, 0.1043299283686332, 0.8647971096350269, 0.9194389556157166, 0.8829423795950263, 0.8522250641666156, 0.8684955614831443, 0.9169628704634242, 0.8429159337790594, 0.8709553965619636, 0.8884303193537068, 0.3228124686428848, 0.3060881424873494, 0.32464495228969403, 0.3152976550778518, 0.3074961394563195, 0.31476406646530386, 0.3192333761244275, 0.32680603337551173, 0.3478768782796474, 0.6410220575037081, 0.5662648144398157, 0.5886218446584195, 0.6377403034886191, 0.6879971114737171, 0.6797622461169144, 0.6207253398216308, 0.6269405507835868, 0.6700754719450448, 0.20551560619370157, 0.17163720429240437, 0.17956200594328098, 0.1498063054344173, 0.2002586363828206, 0.2114217954433688, 0.1617539964696647, 0.16616264496033983, 0.18472243924711096, 0.1665197978726859, 0.1306596058587114, 0.17910319492842086, 0.1768200517026849, 0.24365865530089736, 0.22717145795477078, 0.14746245287080106, 0.18261907502878472, 0.20208882215433033, 0.15068241187259335, 0.17409343331450688, 0.1812431741858559, 0.18252560329780276, 0.1525692979758818, 0.14722282885571802, 0.14109047781737716, 0.17211074135404436, 0.15178602803303454, 0.32450221191862894, 0.3412030944507931, 0.29984180699135143, 0.2946021238286607, 0.28478195199966017, 0.31796069063040033, 0.3442099026812536, 0.3421182727956664, 0.3447620840438822, 0.03582104141866149, 0.0734482292727251, 0.06716064156451562, 0.08780289668793362, 0.06308920561843623, 0.09733618781465536, 0.06453446150704567, 0.07128526806133118, 0.08429506130913922, 0.1704739857048837, 0.16477001141886816, 0.19733881339116266, 0.1878911839600329, 0.18449540444049617, 0.1950309604811511, 0.187664693524501, 0.17911743957158266, 0.20155366082836257, 0.5170095415994427, 0.539418479571868, 0.5162201994564404, 0.5252549715918946, 0.536423258511203, 0.5328706063678896, 0.5400049798285713, 0.519654050174565, 0.5299303407557079, 0.09326823445555599, 0.09319574332419656, 0.0889549063740438, 0.08995623221402571, 0.08274190699994433, 0.1094916552485301, 0.09780681546553716, 0.09332510296275454, 0.08838776677225779, 0.14146583092186793, 0.14323722058691024, 0.14706371668549223, 0.16315429851765129, 0.14132918543254314, 0.13873505375518158, 0.14931420755569547, 0.14165899355753975, 0.13450029050443701, 0.34586190333563627, 0.3116514914183527, 0.326664961346519, 0.3039220851418356, 0.3029636437449059, 0.3455596437965436, 0.3391073111208901, 0.3533861291528898, 0.35045189575382896, 0.23833927878503014, 0.23076207603828003, 0.2585336118057653, 0.2366196877911999, 0.2246068061515598, 0.22796982820662326, 0.25176264923092107, 0.27294292964104383, 0.24109778252043812, 0.184485256217378, 0.1879859566696649, 0.19657614913377652, 0.18058168582825607, 0.1959436884626431, 0.17289369716376046, 0.1884021340013271, 0.1899760896048267, 0.19201156002261288, 0.1868259696026504, 0.18243140550083803, 0.19931642043053333, 0.18286749169594718, 0.17822102808348628, 0.20635792632033623, 0.18444022786570335, 0.17628494332854483, 0.18157026976278523, 0.18430826334657968, 0.19645770255047446, 0.16466332022731334, 0.3665947141533902, 0.18159006083002882, 0.5506142182038241, 0.5073188050441779, 0.5386911814503981, 0.49798063759123046, 0.163354349289472, 0.34568691359011217, 0.1929828907783272, 0.2009894112761279, 0.15110833572743287, 0.18500327439092001, 0.4391382889905874, 0.5394535638000298, 0.20306286636945248, 0.19301007621142752, 0.19001822745675212, 0.18483065641943153, 0.1795634767958918, 0.1808045617718005, 0.1876755298488072, 0.18277088388166807, 0.17741973067483252, 0.17506391128917964, 0.07134634785354488, 0.07241820507172048, 0.08060242217911417, 0.08620123446578032, 0.07831763357770394, 0.085590761560697, 0.07524558499322231, 0.07321333207457503, 0.07453722251916661]}, "mutation_prompt": null}
{"id": "d47cd10a-70fb-4876-8d09-8ecfaa6c0ad4", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "525d05c0-522a-4574-8526-7ca1445b5bb2", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "d7b8a228-e380-4526-9c45-4c05b47ba162", "solution": "import numpy as np\n\nclass QIDE_AS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n        self.scaling_adaptation = 0.2  # Scaling adaptation factor\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Introduce scaling adaptation\n                adaptive_F = self.F * (1 + self.scaling_adaptation * np.random.randn())\n\n                mutant = np.clip(x1 + adaptive_F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(adaptive_F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QIDE_AS", "description": "The Quantum-Inspired Differential Evolution with Adaptive Scaling (QIDE-AS) employs adaptive scaling factors and memory for crossover rates with an emphasis on mutation diversity.", "configspace": "", "generation": 96, "fitness": 0.3317954496104422, "feedback": "The algorithm QIDE_AS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.7344038254062015, 0.7417799879603612, 0.7586007050125068, 0.7658367665462349, 0.7335248420142844, 0.7362996444161197, 0.7326802482643866, 0.7595402783550026, 0.7510543758990413, 0.5255783530725497, 0.5126413490931832, 0.5054799585461229, 0.5176709442040512, 0.5154458457414766, 0.4595171751629725, 0.5320890039454291, 0.5306126665967403, 0.5676324539402609, 0.11295062393735844, 0.11319236256647747, 0.12009087266921381, 0.1198535117587648, 0.10833911683972275, 0.11608523730383513, 0.09867012154791732, 0.1363391322367148, 0.22255066193546957, 0.11177831980582009, 0.09803779882154573, 0.18085852862551854, 0.121441566737848, 0.1204345723551401, 0.11210149564925087, 0.11882981270926063, 0.11026408737436899, 0.11306389507562997, 0.7040678039710695, 0.894845752637972, 0.8630442827187411, 0.7480342643420123, 0.8226783426910762, 0.6568914684079686, 0.7552228708356682, 0.699849869016018, 0.7734658322762593, 0.30787770282669824, 0.15661114908945806, 0.24386224444141358, 0.20908915856487342, 0.25948344198512363, 0.17510860426976071, 0.21154741513926778, 0.2656921588983657, 0.20825714668331585, 0.7769781536011727, 0.7352749369583629, 0.782407900790636, 0.767373145010767, 0.7229198827054195, 0.7762537260016465, 0.7485760877112915, 0.7735258876235678, 0.750259609433193, 0.1451192182297122, 0.17709853992183666, 0.18370996602583456, 0.17185860433999078, 0.18765316283050393, 0.1606136311293478, 0.1544785979339176, 0.14822563010270673, 0.17134692648083416, 0.1583538706831772, 0.1563908006091902, 0.160715245204187, 0.1596841314791101, 0.1412351463783833, 0.13272031316665012, 0.21197415384912166, 0.16673491355594672, 0.1746793262051427, 0.3099732391093192, 0.3758999551943927, 0.10298205720715448, 0.34709721942910576, 0.20808060968768882, 0.1292764766789558, 0.12633668716163515, 0.33227557352262527, 0.27689357448753615, 0.5277509882841551, 0.4304265006871483, 0.44221607175141353, 0.22955328222487625, 0.3409286287352712, 0.5089125198482423, 0.4939522112874475, 0.2605445177114978, 0.4372817435737323, 0.118163456154459, 0.09770652944826619, 0.1897665770061553, 0.12340775741273868, 0.18327099504520483, 0.1175303206274908, 0.13713429592107385, 0.15865307205366985, 0.06790222699078385, 0.2820736114505822, 0.26025724181903054, 0.25504584089883375, 0.23581272059586533, 0.2886855743723491, 0.29522308957233623, 0.29308740615496776, 0.26971635578468567, 0.21741045981784468, 0.6585572393198882, 0.6686496220437144, 0.6081628458411323, 0.6256327243002568, 0.674382025444717, 0.5765467921046052, 0.6015130223989462, 0.6304480367094165, 0.4807581884973655, 0.10210379006476211, 0.10899813860923113, 0.0957039830700227, 0.09909792094073433, 0.0995090845854395, 0.12488139927175868, 0.09895912103739024, 0.10357382008856697, 0.10143683274437065, 0.16143427998777682, 0.16536127139358592, 0.13938825164986612, 0.15292094995537375, 0.1645771770310177, 0.14418424387194573, 0.14534476968904642, 0.13396072501817435, 0.1365688997342046, 0.4132317693320957, 0.40831708937326205, 0.46672379921515095, 0.4413648852623745, 0.4710359728333944, 0.3951110258872096, 0.4297830395083916, 0.45224371401251506, 0.43783958332551876, 0.36224782973523284, 0.3206206817195896, 0.35781941871098144, 0.33753014826700045, 0.2952877692293151, 0.3921738141861384, 0.3841517853282421, 0.3752419840799702, 0.36686877237934945, 0.1921243001848265, 0.18940541262990818, 0.22721057288354518, 0.20986632978433584, 0.20320749740606658, 0.19034945917447477, 0.2304005921415554, 0.19836022068777914, 0.2007296768784147, 0.19488682806637703, 0.2763763554890083, 0.5160300216911584, 0.2134628098917899, 0.27787120089685746, 0.27907521173558025, 0.20036822829717316, 0.4367072957060816, 0.21476460600712777, 0.6995541085024535, 0.6520681300878348, 0.6802288639807654, 0.766249083667734, 0.18489973205930543, 0.7510232996541558, 0.6482705777264243, 0.18283494605727924, 0.7466713296932616, 0.6234574791420724, 0.2005083639481008, 0.19942039601685202, 0.5308652264759652, 0.19855168199834783, 0.2350783867284122, 0.33517219072874505, 0.19891053402384873, 0.2375865916668004, 0.1800109409145474, 0.18464061303992807, 0.18246170641965664, 0.18994317779373238, 0.18056479850756746, 0.18396453361973386, 0.179255033615066, 0.1756256356234679, 0.190681376844963, 0.08163805889404108, 0.08263856564854011, 0.0841228101249053, 0.07737951848057456, 0.08550011030949589, 0.0839451325882723, 0.08980805901753464, 0.08416131623506773, 0.08038940208692147]}, "mutation_prompt": null}
{"id": "18561760-9e00-47a9-a709-cea20c352e67", "solution": "import numpy as np\n\nclass MAQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.2  # Preserve top 20% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.mean(self.memory_F)\n                self.Cr = np.mean(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "MAQIDE", "description": "The Memory-Augmented Quantum-Inspired Differential Evolution (MAQIDE) introduces memory-based adaptation of control parameters and elite learning to enhance convergence rates effectively.", "configspace": "", "generation": 97, "fitness": 0.33595821690825967, "feedback": "The algorithm MAQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.23.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.7189642021151423, 0.7112541685925292, 0.722053314649037, 0.7310700861150556, 0.7207110948255118, 0.7051654117762713, 0.7136197443358834, 0.7267239860795666, 0.7355742287216771, 0.5087752534728825, 0.5093237953133761, 0.545388262082145, 0.5007867070315926, 0.48617092473935974, 0.5271007970609136, 0.4983064807297203, 0.46171108769890645, 0.5253827052071567, 0.11438632248827507, 0.12257746198687669, 0.12161418487598696, 0.10387194996488636, 0.11125060348465599, 0.12663922640431646, 0.1286184968778351, 0.11948840815135153, 0.12172838669917252, 0.09990615702483718, 0.10803644839126414, 0.10224071016155356, 0.10047551462155502, 0.10148569778182615, 0.09527798214391547, 0.10735721626801409, 0.11843872881424289, 0.09683347406141651, 0.6294355391844244, 0.7426832031921244, 0.8434133513357213, 0.8263193532022953, 0.8383750894535577, 0.8849548919185855, 0.7449223195681628, 0.804583310088383, 0.7594547354546299, 0.36709793037728533, 0.3096442702623915, 0.33159336249008065, 0.2985931645176524, 0.3154618774449114, 0.3204987336360082, 0.2899483247255612, 0.2661334138142478, 0.40102061362695773, 0.7434097728120519, 0.7027558201497357, 0.7349853864194633, 0.7205504247202894, 0.7983562553324139, 0.7656918067861649, 0.7769259018441037, 0.7234300139194729, 0.7200306178344399, 0.1401248217892591, 0.20146441258495085, 0.15226614296776675, 0.14735998307345266, 0.18638534810371943, 0.1953099707870971, 0.1635630291821344, 0.17139052133039168, 0.16352120915213797, 0.16516107089099574, 0.1294490749637922, 0.18175538883870945, 0.17349940648799222, 0.1883576867325346, 0.26345445640900667, 0.1673434899917109, 0.3281892581516036, 0.20733735005673493, 0.3639376168056645, 0.33369422056629583, 0.31137718871629994, 0.33411525637199835, 0.3094287645690418, 0.33679104123343595, 0.3492471920914989, 0.3344744755343091, 0.3335423609025272, 0.4688387618352292, 0.3313473760967317, 0.49199691383138355, 0.45383498127142274, 0.43566669125326074, 0.47318596936827284, 0.48687459952781653, 0.5326543968229918, 0.49604461881569084, 0.09931500032366147, 0.09206063744801996, 0.10740577632737347, 0.17517011900055346, 0.15252577525050437, 0.17295367678944407, 0.12771479493013427, 0.123544322238759, 0.14380904878116452, 0.2683593433715722, 0.24888606046335426, 0.25161378056296013, 0.26538722012766325, 0.2714486864053042, 0.2827563046715067, 0.23558233938899342, 0.25889917955759456, 0.26345521610177436, 0.6466420076889507, 0.6153385318055474, 0.6316039650927789, 0.6248959336892284, 0.6262504885408264, 0.6313111855679692, 0.6715697428425287, 0.6310217039810557, 0.6424488274635678, 0.09514590458836614, 0.08742584232608386, 0.09588182528481315, 0.09458049804966617, 0.10562356442496001, 0.09541770246734427, 0.10170714022102634, 0.09580566509974509, 0.10967397911240151, 0.14830615101047528, 0.17195725367530523, 0.13633051095299686, 0.12744736339453921, 0.13918768036568197, 0.13033788570751437, 0.13894447337899163, 0.14966854262934937, 0.18020094577284074, 0.3867771526773526, 0.36734246242364077, 0.38006360041934073, 0.37152838913190356, 0.37533831086364344, 0.40845173615417163, 0.41538291348403156, 0.40503009765012965, 0.3889957920451338, 0.3037376493242274, 0.31960468161488675, 0.32803147269488186, 0.2876396964452226, 0.27594940269161083, 0.2925465110427964, 0.3243341898726957, 0.32669256680136094, 0.3128086921578158, 0.1925374876131617, 0.18552582238266635, 0.18758270627124707, 0.1864851273629442, 0.1913724698034197, 0.19683125211234376, 0.20068547798578285, 0.20345550315860117, 0.20733661961796135, 0.17580867788963783, 0.25486390936719694, 0.1932315024449891, 0.21370679388974934, 0.18686025714410492, 0.1837056872955184, 0.19092478034541005, 0.19225379468740167, 0.2298883998133575, 0.16999789126315468, 0.6808679377776994, 0.6902869470529676, 0.7152809475718125, 0.6873638182150271, 0.5952978051264117, 0.554214310311514, 0.4968004242509786, 0.5937171634134725, 0.19708762107528233, 0.2010116440904699, 0.6917554398338719, 0.2932207372044662, 0.19678663412168174, 0.683100404051131, 0.7090149964700811, 0.20640853242420476, 0.2010845262021469, 0.18630750712364386, 0.19524518328030716, 0.18492725255455522, 0.18406286284237416, 0.19709528603370452, 0.18056026204647047, 0.19891374761973257, 0.18969562729442957, 0.20041895694306788, 0.0904819214844299, 0.0857954105327271, 0.08802936988126953, 0.0755557358225637, 0.09033712726857679, 0.08413964242614069, 0.08155672615447451, 0.07690535606611737, 0.0931611608302213]}, "mutation_prompt": null}
{"id": "823ee50a-6f9e-40ce-b811-69d885f54b57", "solution": "import numpy as np\n\nclass AQIDE_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.Cr = 0.9  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.15  # Preserve top 15% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.F = np.median(self.memory_F)\n                self.Cr = np.median(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x2 - x3), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AQIDE_DM", "description": "The Adaptive Quantum-Inspired Differential Evolution with Dual Memory (AQIDE-DM) leverages dual memory for parameter adaptation and dynamic elite reinforcement for enhanced convergence.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.8945989008671797, 0.8811045025054921, 0.8814109125958335, 0.8920476672400421, 0.8885594722580704, 0.8863754981124067, 0.8967279277722819, 0.8932665236501781, 0.890955891118357, 0.7734451302187038, 0.7709458460699656, 0.7548947814509281, 0.7864041118598114, 0.7577255342999165, 0.7748037767539588, 0.7871648382605739, 0.7734794244799412, 0.7616182919306393, 0.15907630900920955, 0.12291500912474129, 0.15889835919980155, 0.18212378983056077, 0.09085811540187949, 0.15296059958532837, 0.1845303139393656, 0.14259686528668247, 0.14138160832731572, 0.06814516341337762, 0.14310305822350367, 0.07272217977216333, 0.12260141912285138, 0.06966915937609086, 0.08914865763258328, 0.11570831673428716, 0.10468715884165791, 0.10243432879929626, 0.9870378246118922, 0.9755400654524581, 0.9803661818202754, 0.9767801195093921, 0.9776920690437672, 0.9654678386453531, 0.9850456422568636, 0.9833391664329517, 0.9887426824392881, 0.784475113103912, 0.7700590138813094, 0.7683426880534355, 0.7934376439619469, 0.7728464382043048, 0.7876605070155415, 0.7793758044096896, 0.78143225349123, 0.7715255096162442, 0.3962841507716883, 0.9191185327929519, 0.8775020770192549, 0.27865431311739597, 0.9166664954023032, 0.37651269884353034, 0.899749350238364, 0.9048276557173784, 0.8900094279336801, 0.7323139101795751, 0.7850045098505971, 0.7273607202033464, 0.7337614872836327, 0.7557501760486373, 0.13447001646079892, 0.70633342858508, 0.13279554117168957, 0.13028309330432242, 0.7712965256462863, 0.7453364502690938, 0.702458008912445, 0.7791270914493817, 0.7299059391165298, 0.7217575256952053, 0.741843179887468, 0.7050597824147955, 0.1328996319977146, 0.6815732886238146, 0.5441516655408338, 0.21346084884660743, 0.7469660459599573, 0.7373169423855132, 0.03970787869339143, 0.7358985115165022, 0.6239283501705633, 0.33833198200802383, 0.8016724644502913, 0.8059541147100134, 0.8090478193928958, 0.7673039753954839, 0.680363486957082, 0.7836609685688057, 0.8031761885682605, 0.7818277447681583, 0.815876701043799, 0.3175172973433936, 0.6230796578740281, 0.09925285905569148, 0.5830088401564428, 0.1852171617053806, 0.6142079200728505, 0.14348401820206946, 0.14653578511825927, 0.13101124341660875, 0.6360251673777559, 0.6352711284313357, 0.65081995139068, 0.6658294216896492, 0.6482821506486292, 0.6371281132520987, 0.6223740511202762, 0.5285533385948705, 0.6327575551915137, 0.851017943404855, 0.8527860478905482, 0.8335287058881997, 0.854789281035526, 0.8573070267491475, 0.8326196135564432, 0.8707300317779374, 0.8525526860417372, 0.846553503427393, 0.11659325125328845, 0.10980106082825225, 0.15639104857137975, 0.15474847562537675, 0.09447552487218014, 0.09796877391917402, 0.1516519374528401, 0.10319434600117894, 0.11596435806408223, 0.2305813405892796, 0.1694348594046312, 0.2502434202581004, 0.23924202953093954, 0.1933093830344801, 0.19944600125381107, 0.5016411853400586, 0.49813255784336885, 0.7795987906213915, 0.3689888513730267, 0.4565437951662601, 0.4204141293529835, 0.353339885471065, 0.4445274502626866, 0.5740619568973537, 0.604851861328475, 0.30416416724425865, 0.39452638192529454, 0.22961849193461426, 0.2623566387946604, 0.35258364924352525, 0.49793595138296076, 0.23894132938397028, 0.3888049450300498, 0.22203409572214505, 0.266853390380681, 0.43109291344238176, 0.22280995919292623, 0.22790597959482783, 0.2057107874697165, 0.20246450776213165, 0.21304679787770198, 0.17116899442910816, 0.19058684788710334, 0.19186195431654418, 0.21227212884625346, 0.20003176731962702, 0.19439564225628436, 0.1919924698070744, 0.18932354537607265, 0.19360963974504286, 0.21096623320273877, 0.2064296892344577, 0.17720181753483588, 0.2246518730997903, 0.9033665850957019, 0.15832065420368113, 0.15388840406550552, 0.9324280422782482, 0.19960620176507382, 0.14827927828761744, 0.12281406785956062, 0.9048026962821349, 0.14230362947722275, 0.1565862971947769, 0.9007740416574564, 0.9124422689478195, 0.9173387322055917, 0.8969433430449775, 0.1676390725014002, 0.10486125016491588, 0.10455342936062917, 0.15410519871189188, 0.21600890932381345, 0.19990640409359617, 0.20596224510956496, 0.47721341256096506, 0.20297073952488043, 0.21427632364663474, 0.20431892272022034, 0.22085157974904168, 0.20534675503388689, 0.10760281734420174, 0.09674152232813871, 0.0962482551468995, 0.08008947221578033, 0.09159047964980782, 0.10376956855373831, 0.075275377478221, 0.10830349443350262, 0.09193992197146561]}, "mutation_prompt": null}
{"id": "6b327588-0b8f-44fc-893a-96e2a91d3f29", "solution": "import numpy as np\n\nclass QIDADDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.F_min = 0.4  # Minimum differential weight\n        self.F_max = 0.9  # Maximum differential weight\n        self.Cr = 0.8  # Crossover probability\n        self.memory_F = []\n        self.memory_Cr = []\n        self.best_solution = None\n        self.elite_percentage = 0.2  # Preserve top 20% elites\n\n    def quantum_initialize(self):\n        q_population = np.random.rand(self.pop_size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * q_population\n\n    def adaptive_F(self, generation):\n        return self.F_min + (self.F_max - self.F_min) * (np.cos(np.pi * generation / self.budget) ** 2)\n\n    def __call__(self, func):\n        population = self.quantum_initialize()\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.pop_size\n\n        generation = 0\n        while eval_count < self.budget:\n            self.F = self.adaptive_F(generation)\n            if len(self.memory_F) > 0 and len(self.memory_Cr) > 0:\n                self.Cr = np.mean(self.memory_Cr)\n\n            new_population = np.copy(population)\n            elite_count = int(self.pop_size * self.elite_percentage)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population[elite_indices] = population[elite_indices]\n\n            for i in range(self.pop_size):\n                if i in elite_indices:\n                    continue\n\n                x_best = population[np.argmin(fitness)] if self.best_solution is None else self.best_solution\n                indices = np.random.choice([j for j in range(self.pop_size) if j != i], 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x_best + self.F * (x1 - x2 + x3 - x1), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_F.append(self.F)\n                    self.memory_Cr.append(self.Cr)\n                    if len(self.memory_F) > 100:\n                        self.memory_F.pop(0)\n                    if len(self.memory_Cr) > 100:\n                        self.memory_Cr.pop(0)\n\n                    if self.best_solution is None or trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            population = new_population\n            generation += 1\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "QIDADDE", "description": "The Quantum-Inspired Dynamic Adaptive Differential Evolution (QIDADDE) employs dynamic scaling factors and adaptive quantum exploration for improved convergence in high-dimensional spaces.", "configspace": "", "generation": 99, "fitness": 0.29758456060485483, "feedback": "The algorithm QIDADDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "03d3f53c-5091-4462-8d4b-75bc4c4e5945", "metadata": {"aucs": [0.6805054941698088, 0.6713474898113571, 0.6867516880622939, 0.7012036330511899, 0.723733504280837, 0.7045099656963274, 0.6612625477080537, 0.6757791853835737, 0.6883844084038155, 9.999999999998899e-05, 0.44273640441770723, 0.417372726472954, 0.04137521268282729, 0.43296409884434994, 0.44573597704794476, 0.45599133773536216, 0.4376052977645847, 0.44104241072780437, 0.21438806840621039, 0.2793654025293927, 0.10882898885478187, 0.22752059843519357, 0.2539728596683938, 0.14180274958155004, 0.38686383400181634, 0.1533097974983204, 0.34795621267181864, 0.13711608651011353, 0.23190728236056424, 0.11570931436188492, 0.2685091566951672, 0.13489764619759592, 0.13521727716470577, 0.10002438851417195, 0.14489698087135294, 0.12518746883671028, 0.9697679660774203, 0.9860874841809784, 0.9857079730391715, 0.979190823305112, 0.9740448169149734, 0.9728024621386876, 0.9795249231672213, 0.9758767853102784, 0.9726507968699377, 0.3591340428216774, 0.3213680353430861, 0.3575587146135406, 0.3160370029330678, 0.34608116562520475, 0.3689267075453674, 0.32026235963669625, 0.33732085668162204, 0.344906125824899, 0.5014414096674393, 0.1643842494613409, 0.5626547522808885, 0.6183683366645873, 0.5773744187340879, 0.6569151876983881, 0.5686392402687579, 0.6316833934093429, 0.4362665267690897, 0.2780026247474733, 0.2804490563057547, 0.2706640034097423, 0.26114341752542947, 0.09711700510176269, 0.11536396600761512, 0.2774554765761075, 0.2839532169376354, 0.2904900729234361, 0.010027971954220671, 0.24962825253585386, 0.2746102892388216, 0.23925575183140535, 0.2508943468689142, 0.11927088829260224, 0.2755242457567909, 0.2610181788194732, 0.20783860373998087, 0.05906240427646081, 0.137968083852543, 0.16122819283586864, 0.11818727631126458, 0.0005860869109545197, 0.131635721916602, 0.11150735569820425, 0.15652307056742643, 0.12604750240757234, 0.28455013820013386, 0.27494740000799933, 0.2511202705698671, 0.2187067204013201, 0.28609658013951433, 0.2793070407323299, 0.284810976461207, 0.31903638499446585, 0.2967430087986711, 0.029025575492452438, 0.02685571377913132, 0.037494440866982726, 0.0782522816300858, 0.07801747174332685, 0.08293232841916287, 0.07988276341893874, 0.12806584100036167, 0.07850411211186437, 0.15543240982053907, 0.1498749630008862, 0.17054936496421014, 0.16738777374676628, 0.16520381306026444, 0.17607007750119663, 0.19666563348423338, 0.18483401132280142, 0.17678178933869182, 0.47247979082941316, 0.5081953474100989, 0.5143933571411801, 0.5074883565865083, 0.5244259818593189, 0.5033280142066426, 0.5127566925611748, 0.5171111050494764, 0.5171197301843702, 0.1062337538703998, 0.10722407327119021, 0.12757304435649985, 0.1530719952750207, 0.10316289573757642, 0.12878852696913323, 0.1106064279507113, 0.11060998717561565, 0.11081645745540114, 0.21372751255344624, 0.1885506914628382, 0.14195974134650424, 0.14121934683792858, 0.12452530051406552, 0.15664883977877375, 0.1564994568181104, 0.180293074688756, 0.2590168559991667, 0.3303697686765692, 0.32684197260246917, 0.34128627374728626, 0.33316004542469135, 0.2904112070051956, 0.30890159357295266, 0.36390884465138196, 0.3483356985424788, 0.3563531305049503, 0.2235748613214148, 0.23234673984023368, 0.23296826174561458, 0.23514797794217224, 0.17832525216990613, 0.18133930085991556, 0.24295320288190336, 0.2448341608809801, 0.27247435004996745, 0.17703622235083438, 0.17307619538685481, 0.1934632204389115, 0.1836685252071788, 0.21397959265039812, 0.18304056823106307, 0.18574605402812372, 0.1933665218800158, 0.19343553247201395, 0.22452605503577272, 0.18749871675502217, 0.19203609258010534, 0.20656652835478062, 0.4499035496703302, 0.21142117090021706, 0.48095036821448245, 0.2177526896222166, 0.21013410717227488, 0.16199291688646011, 0.14536852299371417, 0.14720994846897506, 0.18186217905162383, 0.619081076058768, 0.1633181996742813, 0.16644648248629368, 0.6230128865848411, 0.7776808924707095, 0.2048635881245412, 0.6504430549131579, 0.11954690269246382, 0.6560274391380261, 0.6836345958245063, 0.6968873480791415, 0.1524238128586599, 0.18450678743207227, 0.19201408642891382, 0.1868898790464668, 0.19270470856722643, 0.18415548436825668, 0.16091406845172718, 0.18356721507857499, 0.18247453759787524, 0.17023548721540704, 0.2052980151683892, 0.17890700740262655, 0.07752714850595743, 0.06995496204171936, 0.07049004849985485, 0.07511600522839179, 0.0769540228385156, 0.09198751850578957, 0.07789056532164618, 0.07544306674086876, 0.06901991788148987]}, "mutation_prompt": null}
