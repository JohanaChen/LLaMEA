{"id": "202c370d-f7c4-40ca-b377-55b92352260e", "solution": "import numpy as np\n\nclass ADES3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)  # Keeps track of strategy success\n\n    def select_strategy(self):\n        total = np.sum(self.history)\n        if total == 0:\n            return np.random.choice(3)  # Randomly choose if no history\n        probabilities = self.history / total\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best = np.argmin([self.evaluate(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n        return self.best_solution, self.best_fitness", "name": "ADES3", "description": "Adaptive Differential Evolution with Self-adaptive Strategy Selection (ADES3) combining mutation strategies based on historical performance.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 73, in __call__\n  File \"<string>\", line 57, in evaluate\nRuntimeError: Budget exceeded\n.", "error": "RuntimeError('Budget exceeded')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 73, in __call__\n  File \"<string>\", line 57, in evaluate\nRuntimeError: Budget exceeded\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "a8baeb79-80df-4cd5-8c9b-e53480bb2164", "solution": "import numpy as np\n\nclass DES3D:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n\n    def select_strategy(self):\n        total = np.sum(self.history)\n        if total == 0:\n            return np.random.choice(3)\n        probabilities = self.history / total\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n        return self.best_solution, self.best_fitness", "name": "DES3D", "description": "Enhanced Self-Adaptive Differential Evolution with Dynamic Parameter Adjustment (DES3D) using performance feedback and adaptive mutation strategies.", "configspace": "", "generation": 1, "fitness": 0.16626783336783976, "feedback": "The algorithm DES3D got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "202c370d-f7c4-40ca-b377-55b92352260e", "metadata": {"aucs": [0.4468478004769595, 0.6460397506058728, 0.163183365573491, 0.48236638318451874, 0.14829472389442833, 0.1817517412556806, 0.636190940138655, 0.4756651293952553, 0.1619795874947616, 0.36633892852887173, 0.36539064070367366, 9.999999999998899e-05, 9.999999999998899e-05, 0.3781175833315348, 9.999999999998899e-05, 0.39084282647959045, 0.21121888613304818, 9.999999999998899e-05, 0.028345918980544726, 0.0867930121803192, 0.03309730590186788, 0.06201255082228163, 0.027581659570773964, 0.019734820545534992, 0.03488718218334397, 0.024570180947362852, 0.025724570882590836, 0.078872136017754, 0.011125874159338633, 0.015285841031265623, 0.10741215992195319, 0.01275096479862059, 0.022564685187269062, 0.0773151977326828, 0.007573890731671251, 0.0213588980440238, 0.8275866755533678, 0.913462496923744, 0.06070022837980271, 0.8426769176821769, 0.07352681189342292, 0.10779063809038492, 0.8793689800632966, 0.07513765561079377, 0.11819593701498665, 0.19130369264262403, 0.26540834389937196, 0.024775120762622227, 0.25800335760569537, 0.04706064914150265, 0.059543163350613604, 0.2596180856422168, 0.2658384037495264, 0.3147643984099463, 0.11641691157732226, 0.5843298388963112, 0.09107549237888468, 0.10845707189197418, 0.6068780357881898, 0.09845893700207164, 0.6013677141231003, 0.5691190940579667, 0.07827181781918202, 0.10605876535769276, 9.999999999998899e-05, 0.1745520413709557, 0.13830619606065542, 0.11948863830910417, 0.036153641633645206, 0.13355025603548276, 0.13342843819782135, 0.012282063262384901, 0.1197328267053499, 0.015617083279964028, 0.011668119054340287, 0.0437273864142097, 0.16672017584140086, 0.12130248154191481, 0.08754296831629649, 0.15522581558754667, 0.0018980478805530332, 0.19102634430117527, 0.04139410852268033, 9.999999999998899e-05, 0.09056867012067071, 0.06034829443957446, 9.999999999998899e-05, 0.08151902862535898, 9.999999999998899e-05, 0.07518667093467979, 0.36359241376658125, 0.34106602493159077, 0.049062114199637685, 0.16608552706360902, 0.14739908982913585, 0.29556266245491003, 9.999999999998899e-05, 0.1970585685710241, 9.999999999998899e-05, 0.08049979086492054, 9.999999999998899e-05, 9.999999999998899e-05, 0.08063068889931313, 9.999999999998899e-05, 9.999999999998899e-05, 0.08450949199129865, 0.08723697859826984, 9.999999999998899e-05, 0.18880048415463102, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.166507414242396, 0.17435709075680084, 0.18656606255808694, 0.5060496794207248, 0.49229264627916103, 0.5316210593265994, 0.3969195317591163, 0.5278098179205092, 0.18216121199998603, 0.5212879389263589, 0.15715093992462448, 0.19531198923098958, 0.08853769989951232, 0.0979507519380235, 0.03318179241391195, 0.08975644445374786, 0.0202525052239666, 0.03379754618196018, 0.02754390120745298, 0.024305199898001728, 0.033246858793527845, 0.12197092543333221, 0.14823311901755354, 0.1258187697242762, 0.1400642666445885, 0.13190154649578978, 0.12133448323240514, 0.12672262179212979, 0.15312844110275636, 0.09735460801476492, 0.2281868985074892, 0.2908478654272273, 0.16160633512560962, 0.14976669655108887, 0.30883458680093256, 0.1490225556385152, 0.15913237074543085, 0.32158060142742817, 0.1540085677056965, 0.08647245591955, 0.225079362822727, 0.09565669104469321, 0.2408463028251605, 0.23530798301515699, 0.15250176735637488, 0.08997349509985053, 0.2603524025290572, 0.08865855346721396, 0.16151433671906812, 0.1834890577294216, 0.1424895800881565, 0.16296719083567712, 0.20687857979446544, 0.13263773192261086, 0.17220347960031557, 0.18812120212076855, 0.13356911751467704, 0.14018497942350694, 0.1694852190008318, 0.08402449139442492, 0.17170599305212875, 0.05680082001565245, 0.12826651262164668, 0.10315763471082595, 0.17947757015021093, 0.16843238556435158, 0.23455934413753898, 0.07489531322043586, 0.09786067783643992, 0.15970028978319284, 0.5077047873584648, 0.5173230557862412, 0.14927011842090399, 0.15853357952627334, 0.10215992702757903, 0.42215499383791455, 0.10770504837550265, 0.11645812945870149, 0.18387505505921542, 0.07151277563205582, 0.3636480245828603, 0.19977268821012117, 0.19974537980595564, 0.08427364560134298, 0.19571996099966904, 0.15570339818470325, 0.17499204133841673, 0.1431542711735928, 0.18810063740997784, 0.17267137168530877, 0.19620809023272312, 0.1799156919397028, 0.1710030252421182, 0.037471993819781724, 0.07918406941160372, 0.07319352487463748, 0.038007620218557525, 0.04034219411738793, 0.040306438322876614, 0.06613586252828207, 0.044792300851018485, 0.03824493945627616]}, "mutation_prompt": null}
{"id": "92e5e27a-11e4-4606-9a43-2904e448d7c1", "solution": "import numpy as np\n\nclass EnhancedDES3D:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n\n    def select_strategy(self):\n        total = np.sum(self.history)\n        if total == 0:\n            return np.random.choice(3)\n        probabilities = (self.history + 1) / (total + 3)\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D", "description": "Enhanced Self-Adaptive Differential Evolution using adaptive crossover and mutation strategies influenced by fitness improvement history.", "configspace": "", "generation": 2, "fitness": 0.0850700330186756, "feedback": "The algorithm EnhancedDES3D got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "a8baeb79-80df-4cd5-8c9b-e53480bb2164", "metadata": {"aucs": [0.1832526521107567, 0.1297103010080456, 0.16883959049976982, 0.20015847113234464, 0.1427213178186043, 0.19995782361470615, 0.17513733393442088, 0.15519502441733202, 0.14767920281596325, 0.013282365969948806, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02736874138973011, 0.024957973356455887, 0.03288342543324596, 0.0679696378687038, 0.0233307136822275, 0.02737259740590292, 0.04547339855398114, 0.03236545542325042, 0.02682251052617335, 0.030084957675019952, 0.00956241380281242, 0.013646469337614708, 0.027395737799956854, 0.013729933592539267, 0.015461537923951107, 0.02549756731804831, 0.012129384566552881, 0.016113913548771452, 0.10161292564598301, 0.0864513792654068, 0.07023542581700326, 0.08629778013426292, 0.06334175444561263, 0.09894890509020837, 0.11034350404965376, 0.07501679803174266, 0.6965272267817489, 0.15187884618997538, 0.04781588566056294, 0.050301583683444506, 0.10166487024646653, 0.05172000721622716, 0.06193580227050299, 0.07661122784591667, 0.118567780357837, 0.06517578438373517, 0.10685266653378789, 0.13627125509749627, 0.12951286357121938, 0.11231231799434771, 0.1018915495671947, 0.1005530130004294, 0.22427485112735335, 0.12232478888437492, 0.09419490749309445, 0.024743161473703146, 0.006419874100918266, 0.018380431655242502, 0.0036711500442115907, 0.0018551472916693568, 9.999999999998899e-05, 0.03519601523583693, 0.08389495986412498, 0.0037420883181698006, 0.030810655377854657, 0.017498149139358765, 0.000811192061164201, 0.03777273285241012, 0.0067484990346325935, 0.011262751063396581, 0.0374140934069539, 0.000580741900006787, 0.005954883973236069, 9.999999999998899e-05, 0.016862217613274555, 9.999999999998899e-05, 0.002292769483265289, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006180921801468342, 0.22840115439797104, 0.016615745047009134, 0.006641549664107349, 0.020518826830624892, 0.0058438269762315365, 0.0013858272533141536, 9.999999999998899e-05, 0.00702273515652263, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006501267392493126, 0.0021344815440100806, 0.0031479465405048757, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036617661501068266, 0.0897738360682655, 0.006437207884338214, 0.18732914748721974, 0.31981198852530957, 0.20454208700724852, 0.20994434684094465, 0.16527266941795238, 0.18106760022281276, 0.20950647609753037, 0.16928681257808953, 0.189646378231068, 0.03647937360158415, 0.07585535418406397, 0.029415688935444106, 0.05602394594306792, 0.023429628858205098, 0.042334559619517265, 0.035284919777054724, 0.02362811198135184, 0.03870529643302212, 0.13708073425876233, 0.1250778096707782, 0.11842175776965747, 0.12604767036567133, 0.15412246748276337, 0.1263046552326268, 0.13876468277655274, 0.08097856604406883, 0.09130867901136663, 0.15587176321423213, 0.14222018481333487, 0.18254553559298348, 0.18292057915988535, 0.14537637488818145, 0.14772856499534215, 0.15571431513102474, 0.17368505619928365, 0.16280425419562472, 0.11671514109481573, 0.08693490317815522, 0.08838595801237392, 0.10571841840050311, 0.10049465874665109, 0.09504891310133168, 0.10803389917461337, 0.10210773953307128, 0.09100378064124381, 0.14896470236721382, 0.14866355907650775, 0.14063141039311244, 0.15581944672479042, 0.13156911255230208, 0.13433846611272615, 0.14127970345401886, 0.15585301762720138, 0.14544003288875595, 0.13696846715218236, 0.10312255190936137, 0.09151271428286456, 0.14533793528271322, 0.06386925754452966, 0.1268506006164971, 0.12065884650699721, 0.11149575912595433, 0.12235662692298155, 0.34566966662410614, 0.10962008776994447, 0.1072016829888447, 0.2345508164580098, 0.13980697171319478, 0.11654562942297741, 0.12458496478702508, 0.10864610442902245, 0.11725697214423347, 0.22931986131818083, 0.1270842839383831, 0.06932034027342138, 0.10576508160311093, 0.08967744696323243, 0.18741047908808806, 0.11108507784688393, 0.13518630779172036, 0.06099266987660357, 0.1510607275291329, 0.15011443985252515, 0.15269198103892867, 0.1513255011105703, 0.17862440412381786, 0.1774430820658186, 0.16215233686623665, 0.19130858439537157, 0.19268798214858562, 0.03410535357833744, 0.07094764419830657, 0.05037017552415457, 0.04127507552257936, 0.042488554637756026, 0.03709844545104479, 0.04003794153824802, 0.04456253061973514, 0.03957950831988588]}, "mutation_prompt": null}
{"id": "5c75d7fe-afa9-40ce-a5f2-12eaa29d2a22", "solution": "import numpy as np\n\nclass DES3D:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.9\n        return self.best_solution, self.best_fitness", "name": "DES3D", "description": "Self-Adaptive Differential Evolution with Adaptive Crossover and Mutation Strategy Selection based on Success Rates.", "configspace": "", "generation": 3, "fitness": 0.1975552301055291, "feedback": "The algorithm DES3D got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "a8baeb79-80df-4cd5-8c9b-e53480bb2164", "metadata": {"aucs": [0.15519223800673976, 0.6460397506058728, 0.15371890756037954, 0.15909269682106475, 0.6403036749704374, 0.6347812253840355, 0.4572379276647516, 0.4634173349805423, 0.641434356432772, 0.25147517719166557, 0.36539064070367366, 9.999999999998899e-05, 9.999999999998899e-05, 0.3781175833315348, 9.999999999998899e-05, 0.229097893222861, 0.20851139769663163, 0.3825259949680623, 0.03874824845447766, 0.0867930121803192, 0.034023395466986184, 0.04362894919134741, 0.09293314865287505, 0.1273718700529236, 0.0826565550216739, 0.07602326047833485, 0.10043594765134445, 0.07024620350779642, 0.07758005698360415, 0.01449665817733281, 0.0762274030935518, 0.08750785394632021, 0.017731104268597142, 0.06548796780419286, 0.09344155451961256, 0.020072512451590585, 0.7484447736692472, 0.913462496923744, 0.9516278352479595, 0.5990053814028631, 0.7775816912596007, 0.6899434592153921, 0.9248825454559385, 0.9412537467776749, 0.7154416428193306, 0.1800723899685328, 0.26540834389937196, 0.28183662201739024, 0.19199348652440473, 0.27665096773959896, 0.060060543418511636, 0.20604864688545865, 0.2658384037495264, 0.030139960607900917, 0.12366805659989899, 0.5843298388963112, 0.079474830176133, 0.26296057604026324, 0.6068780357881898, 0.10642608658707053, 0.6520210123338883, 0.5691190940579667, 0.06875979057591963, 0.10953901787054399, 0.10704890464929218, 9.999999999998899e-05, 0.11433712733347712, 0.14202277426715715, 0.13734175743710675, 0.1113701093276368, 0.15519340066065812, 0.11649145449613751, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013543773984752039, 0.16672017584140086, 0.00011151600704384368, 0.014406897400754626, 0.15522581558754667, 9.999999999998899e-05, 0.07879829687497875, 0.17032132055163351, 0.19340232994461692, 9.999999999998899e-05, 0.07469339981256706, 0.21688985242766534, 9.999999999998899e-05, 0.06589902728692709, 0.05989006206197334, 0.010976247997964483, 0.34106602493159077, 0.34234383410209, 0.0003843299111467857, 0.15449664641341154, 0.1700111693782579, 9.999999999998899e-05, 0.18817655980215653, 0.33469315428550317, 0.012856070034284461, 0.003204293613534026, 9.999999999998899e-05, 0.005548583928842388, 0.008148619878600383, 9.999999999998899e-05, 0.020797862666032785, 0.08723697859826984, 0.05692934189528065, 0.11915907906222145, 0.11976106048659296, 9.999999999998899e-05, 9.999999999998899e-05, 0.11473450899575177, 9.999999999998899e-05, 0.10487241713981854, 0.17435709075680084, 0.10114456959671803, 0.40690115830424967, 0.49229264627916103, 0.39946189830592516, 0.38337875635527385, 0.5278098179205092, 0.527448287932491, 0.38915302578666033, 0.36319233907139614, 0.5170307181285833, 0.0730020308261764, 0.0979507519380235, 0.09178228631316343, 0.07710707958461482, 0.08176554993301288, 0.07943428014532639, 0.027913426021190624, 0.09211650153874451, 0.08847812619786288, 0.14139967821403476, 0.14823311901755354, 0.1184042466173374, 0.133315377709198, 0.13190154649578978, 0.1142860169705382, 0.1404140577035825, 0.13334430555675048, 0.1258886431669607, 0.1360461138898179, 0.2908478654272273, 0.16596912314600176, 0.22156557633784368, 0.30883458680093256, 0.3077594494783954, 0.14350779119406742, 0.32158060142742817, 0.3389798615220987, 0.08407420227799178, 0.225079362822727, 0.1040301121237237, 0.08782238915922402, 0.23530798301515699, 0.25406634843702114, 0.19594340769202045, 0.2603524025290572, 0.24546892777091134, 0.14243346170813698, 0.1834890577294216, 0.14812457340038931, 0.13672484364111404, 0.20687857979446544, 0.1538517074789566, 0.13927049795368607, 0.18812120212076855, 0.1321119417136939, 0.11185482928092538, 0.1694852190008318, 0.1184309547561847, 0.16433605614606128, 0.16359544817975147, 0.1771219539745501, 0.10190056594844776, 0.17947757015021093, 0.14560649812075221, 0.18854736962867324, 0.15463691132627078, 0.6205368942645091, 0.49322673131578854, 0.5077047873584648, 0.14680950657544123, 0.10698832660948976, 0.2909707140864948, 0.1732250738157891, 0.37282672883933443, 0.15743718390204797, 0.06930792004956676, 0.15258332243604145, 0.155052780158769, 0.18390695996965445, 0.19913877018838888, 0.19974537980595564, 0.09786441650047473, 0.16777070433054286, 0.1836829441925666, 0.17434600244939724, 0.14486914755095737, 0.18810063740997784, 0.13778212854429717, 0.1850491410035381, 0.1799156919397028, 0.1505679698561696, 0.06405486350729495, 0.07918406941160372, 0.03425753447948576, 0.03758530385789749, 0.07758671235460879, 0.07790725776462237, 0.06295827232398588, 0.06780772955242786, 0.07371885986921822]}, "mutation_prompt": null}
{"id": "69b5ba1a-a64d-427f-b3d4-e65c0485e9fe", "solution": "import numpy as np\n\nclass DEESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F_base = 0.5\n        self.CR_base = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.F_history = []\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F_base * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F_base * (self.population[r2] - self.population[r3]) + self.F_base * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F_base * (self.population[best_index] - self.population[idx]) + self.F_base * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        dynamic_CR = self.CR_base * (0.5 + 0.5 * np.random.rand())\n        for j in range(self.dim):\n            if np.random.rand() < dynamic_CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        dynamic_F = self.F_base * (0.7 + 0.3 * np.random.rand())\n        self.F_history.append(dynamic_F)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.85\n        return self.best_solution, self.best_fitness", "name": "DEESA", "description": "Enhanced Differential Evolution with Stochastic Strategy Adaptation and Dynamic Parameter Scaling.", "configspace": "", "generation": 4, "fitness": 0.1758679874470318, "feedback": "The algorithm DEESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "5c75d7fe-afa9-40ce-a5f2-12eaa29d2a22", "metadata": {"aucs": [0.722821611306566, 0.15394307081892444, 0.6841747574370538, 0.7214958238722976, 0.13471344722562717, 0.6877413663643785, 0.7078648511206787, 0.15163687417927663, 0.5700146312448735, 0.4523811614856097, 9.999999999998899e-05, 0.4647343139179273, 0.45201786875366545, 9.999999999998899e-05, 0.4599576269436755, 0.47774072070299556, 9.999999999998899e-05, 0.27668569294412415, 0.1292727300726636, 0.051864457655733, 0.10723083745397921, 0.1088098914932627, 0.025747061136220495, 0.141283551662312, 0.10938437273805635, 0.03204076259308508, 0.10240980040621128, 0.11711752751466409, 0.024041388807975128, 0.10623669087027576, 0.024470248918728288, 0.019050856406688577, 0.09695012397246139, 0.10181379945880875, 0.027534574194237216, 0.09687781482782576, 0.8648973123458376, 0.08395627339589573, 0.8544800746532475, 0.917132655436914, 0.07906730672371964, 0.9387921481878895, 0.8809709457569944, 0.09821829261977111, 0.9454837078036222, 0.30632771747160104, 0.07666554827744276, 0.2831190780222914, 0.3046344231727959, 0.05392603853258626, 0.21061151024680047, 0.27428865859410523, 0.04836332079566563, 0.22565983288632663, 0.10980170236260167, 0.2300406619351505, 0.4266039904385972, 0.5598206892794295, 0.08699115980888561, 0.25059161301114496, 0.5536023261619119, 0.08822915232541417, 0.4708060524732457, 0.1492036724859772, 0.00016893668856210464, 0.15509794447541425, 0.17100096957193578, 0.12040446423869233, 0.00012705128901946416, 0.1694726179681476, 9.999999999998899e-05, 0.14620126744578887, 0.18026339434335337, 0.02012726842674306, 0.15149090690766132, 0.19521329542949284, 0.007633161437844538, 0.11881943543894213, 0.15265918329188222, 0.004668364005993353, 0.13853447226588156, 0.04236372481976414, 0.0007045569037401611, 0.012713776237533558, 0.04263209317418748, 9.999999999998899e-05, 0.042409627105466696, 0.06246082335165448, 9.999999999998899e-05, 9.999999999998899e-05, 0.1507194204550475, 0.006334153020173816, 0.11426988322963771, 0.18129773452256748, 0.00022085401729599052, 0.0011180090382133523, 0.16041573181656676, 9.999999999998899e-05, 0.16587352460161342, 0.037448723969322195, 9.999999999998899e-05, 9.999999999998899e-05, 0.056924094882309095, 9.999999999998899e-05, 9.999999999998899e-05, 0.027612823983910184, 9.999999999998899e-05, 9.999999999998899e-05, 0.12423443238858622, 9.999999999998899e-05, 0.07906564822625461, 0.1417540525115052, 0.002661472839971757, 0.12823660417362137, 0.1297138392494933, 9.999999999998899e-05, 0.08737709286063344, 0.46013317380731356, 0.1806868663818193, 0.39606024514129035, 0.1681758927552962, 0.1714150259606917, 0.479779959295914, 0.20943939138922107, 0.16506951911944778, 0.4013795392504279, 0.08161153572279034, 0.03128020122626407, 0.08762996878406304, 0.09781867350245144, 0.055936979911408, 0.03443038377325991, 0.07128552185014925, 0.027413081988451493, 0.0325725892275166, 0.13183280551190668, 0.08831044179375169, 0.13025650284351997, 0.14528188526271824, 0.11795002702699398, 0.12571282747680557, 0.13525177913572128, 0.08798406671162484, 0.131620132750341, 0.12449510291750887, 0.1593963636090795, 0.24997588329566967, 0.28997434920778453, 0.1449368582455951, 0.27909882537274056, 0.3080783872592747, 0.18490943600959142, 0.32116158045098886, 0.07489051314818951, 0.07537436656306495, 0.21016328394705064, 0.08785458195237772, 0.09157564286443654, 0.22634310960375925, 0.23949871406613832, 0.11347774652012921, 0.21167263451784857, 0.17961725475623058, 0.1412992370922186, 0.19323468703961666, 0.18766314848585464, 0.15038075058331646, 0.16686044728740357, 0.1829371041769352, 0.12590382324420168, 0.1883692611594231, 0.18233494588198695, 0.14006818841409618, 0.1680954886845859, 0.207271196512682, 0.07812712084178386, 0.18270915574234337, 0.1832548023459858, 0.1187079445880892, 0.1864048791680294, 0.14881505868986133, 0.0849785712200033, 0.09506917813720905, 0.4289881272691318, 0.15341947727656957, 0.1525360435368036, 0.13375661782202874, 0.11489660393230039, 0.16933275286708016, 0.16165457593958277, 0.17095780695682317, 0.1666885836403328, 0.17353340189835276, 0.09597380750513074, 0.15372408330530707, 0.19646267501389536, 0.11720270601011984, 0.20361301489837869, 0.16904287993433786, 0.14174712007352086, 0.1976094723614218, 0.172639073487733, 0.16970900701811165, 0.18308307870632645, 0.17553422649012718, 0.13546089326888144, 0.17016860032164294, 0.07039662945929992, 0.033431460225398, 0.04960548512134444, 0.06598959866539555, 0.07142974147203951, 0.06866294370986603, 0.0711249466638435, 0.037830934235617675, 0.035588673956725825]}, "mutation_prompt": null}
{"id": "580edc52-6d4b-4170-af22-71636114f26c", "solution": "import numpy as np\n\nclass EnhancedDES3D:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(5 * dim, 50)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.dynamic_f = np.linspace(0.5, 0.9, self.pop_size)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n    \n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        F_dynamic = self.dynamic_f[idx]\n        return self.population[r1] + F_dynamic * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        F_dynamic = self.dynamic_f[idx]\n        return self.population[r1] + F_dynamic * (self.population[r2] - self.population[r3]) + F_dynamic * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        F_dynamic = self.dynamic_f[idx]\n        return self.population[idx] + F_dynamic * (self.population[best_index] - self.population[idx]) + F_dynamic * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.9\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D", "description": "Enhanced Self-Adaptive Differential Evolution with Dynamic Population and Learning-Based Strategy Adaptation.", "configspace": "", "generation": 5, "fitness": 0.15465153090054548, "feedback": "The algorithm EnhancedDES3D got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.18.", "error": "", "parent_id": "5c75d7fe-afa9-40ce-a5f2-12eaa29d2a22", "metadata": {"aucs": [0.1455041568651364, 0.433804497017088, 0.15131748825953073, 0.16509300160614115, 0.44445531898103674, 0.49807270742775045, 0.3159880559062873, 0.3152381682191503, 0.4435921590100571, 0.07483396702525391, 0.20334607417954353, 9.999999999998899e-05, 9.999999999998899e-05, 0.21183092209905607, 9.999999999998899e-05, 0.08499967344906367, 0.07117369274475316, 0.23257656708355867, 0.026217099518024423, 0.0923005367002736, 0.03920029535463476, 0.030953861336674326, 0.07220943202405794, 0.07841005766550646, 0.09187866748985962, 0.09234837301952159, 0.08053826854016677, 0.05175737313399442, 0.06716769960886104, 0.020043794882955823, 0.055496218949441234, 0.0737547866403232, 0.017528083091227553, 0.0661506762744728, 0.0703259460684541, 0.041392264570109916, 0.9749546689887121, 0.9051046983532587, 0.8725039365617723, 0.8529730585574637, 0.8593542795836548, 0.911590018364688, 0.6532904980093277, 0.8758153307643324, 0.8036732678036553, 0.13411908514572912, 0.2072066230695936, 0.18312921372378566, 0.10865667142971602, 0.1824123679130043, 0.04912918154879553, 0.1351519898260809, 0.18833216048818924, 0.07398909266018894, 0.12697189012895482, 0.24797931087529745, 0.08681046309308094, 0.19000111182651047, 0.47869487411772993, 0.12036086113601163, 0.45093506767322233, 0.43693472813853174, 0.07671065236965391, 0.07222202709359826, 0.04885778480796921, 9.999999999998899e-05, 0.048869381726040606, 0.12070664689447475, 0.13129458742593392, 0.05183417443711691, 0.11957566124167973, 0.06104599875009298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00211099100207357, 0.10245393659039015, 9.999999999998899e-05, 9.999999999998899e-05, 0.10770945907810114, 9.999999999998899e-05, 0.0006983352566268808, 0.07688063488923857, 0.0583880746870451, 9.999999999998899e-05, 0.007102586886590823, 0.07246326966006433, 9.999999999998899e-05, 0.00026265357179511284, 0.01021822513044468, 9.999999999998899e-05, 0.17296039455090562, 0.18522617447030643, 9.999999999998899e-05, 0.08464086570133855, 0.0035924525318002942, 9.999999999998899e-05, 0.10060854623812487, 0.18174155155266603, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004354782432682058, 0.012397906311067297, 0.0538404855885094, 0.0402856729691482, 9.999999999998899e-05, 9.999999999998899e-05, 0.050598652445456915, 9.999999999998899e-05, 0.05169853592028717, 0.1202039973704736, 0.055115377326719006, 0.2699260451323944, 0.3892856367773133, 0.26843484477125723, 0.2965290862371406, 0.4171992265836648, 0.4043823182082551, 0.28536087723288184, 0.2653719167979469, 0.38152534154130224, 0.07067147498490844, 0.07797977855031646, 0.08510348123293843, 0.05785317116366062, 0.061936791559160875, 0.07914761025308037, 0.025391230264751763, 0.08012056413571678, 0.07228411093428533, 0.14434031511945755, 0.12458878003419416, 0.11981754019111779, 0.14183163783858277, 0.12858401562841715, 0.11707727279807822, 0.14220427891497367, 0.13266763058248576, 0.13187427107853744, 0.12124766175467572, 0.2309311516002175, 0.16985531463372083, 0.18072737797649296, 0.21946732998902407, 0.22735673033800918, 0.1485601659808723, 0.271975043874663, 0.23669031945348107, 0.0856338334321537, 0.1885381997196235, 0.09672437885563778, 0.0861446757556571, 0.16353383611470584, 0.17814193132915568, 0.1447439959877902, 0.1867522499413884, 0.19132364526519208, 0.16979429508711952, 0.15945626907792754, 0.1334371491311529, 0.1363255066331014, 0.17692027549783473, 0.12403148403166087, 0.12573859752267036, 0.1772064826806532, 0.12618362590478538, 0.10374156519455591, 0.17217849428632948, 0.0915120344839806, 0.16082481310625896, 0.1526808021996352, 0.1750535494188793, 0.041397823790125576, 0.1551986929183342, 0.1408407016447818, 0.15336384547946746, 0.1439623957378504, 0.2234810237724889, 0.1621179702066482, 0.14371271671303165, 0.09064152399175496, 0.1072095189942931, 0.2898033276211981, 0.13987503397965084, 0.1673429714977528, 0.1614722619009724, 0.08953284148479301, 0.12962977385282415, 0.14987227309350803, 0.15943109806365885, 0.16265233643729282, 0.1995209332781308, 0.06827252725718191, 0.1717250857660665, 0.18358527355188958, 0.14761631310978485, 0.1859687250194536, 0.17600265084253985, 0.14121255424842982, 0.17190719551285671, 0.1680259612488646, 0.14687311592924712, 0.06172044301269686, 0.07021061138294227, 0.035929010801511896, 0.03270913454924318, 0.05012229192464279, 0.07013046092510689, 0.052230590118482745, 0.052585516906719754, 0.06317730171410241]}, "mutation_prompt": null}
{"id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "solution": "import numpy as np\n\nclass DES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95  # Adjust decay factor\n        return self.best_solution, self.best_fitness", "name": "DES3D_Adaptive", "description": "Adaptive Differential Evolution with Dynamic Population Size and Strategy Adaptation.", "configspace": "", "generation": 6, "fitness": 0.24817571229817584, "feedback": "The algorithm DES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "5c75d7fe-afa9-40ce-a5f2-12eaa29d2a22", "metadata": {"aucs": [0.7191171814890431, 0.6853737228883547, 0.8310903990671489, 0.7358915068430041, 0.6894134061139792, 0.6870897314767539, 0.29803138765545856, 0.2921858092141588, 0.2707575770799596, 9.999999999998899e-05, 0.5212169331829446, 0.6706607056182736, 9.999999999998899e-05, 0.538989137439963, 0.15094621782684248, 0.5202166923625464, 0.5350631063776288, 0.6354279931041238, 0.0565521313962396, 0.0874779701311269, 0.11394139240903389, 0.09063660640218985, 0.10444510292232645, 0.11648651802696264, 0.0931761928524375, 0.09077546129201763, 0.05131398314242874, 0.05593606206764923, 0.08262960703265687, 0.11346410044122879, 0.057461531690531364, 0.10508598805377001, 0.11594679796374185, 0.0880698787620593, 0.0747548786974932, 0.12618252951090925, 0.8756699015401185, 0.8893862884989027, 0.6273329958484906, 0.864577203375756, 0.8796170936826908, 0.8465925999064775, 0.780845543850287, 0.7890953287268208, 0.0925596036591182, 0.3733784351599494, 0.3935586090685993, 0.08524911664865198, 0.3718069591620561, 0.11388273360860024, 0.23333753682033398, 0.37243493338332145, 0.3569427532546271, 0.2821690422963661, 0.1612555233141606, 0.6732119185101904, 0.7046938777189118, 0.17633895017533774, 0.6601544180023322, 0.8382430102854954, 0.09289008682419919, 0.5739790419974562, 0.231033385222013, 0.05034908187285547, 0.025830979489989803, 0.03835252915446996, 0.08313751385701218, 0.052424928725893216, 0.18461203705238172, 0.05333088664157881, 0.3500733844815186, 0.17824797498333478, 0.06971880310210532, 0.046442780376550585, 0.2139214668262195, 0.06965798036253312, 0.045246734482950024, 0.16947189091814563, 0.05817924227155613, 0.04163739215956286, 0.33907425743485253, 0.2988555259674699, 0.2850620882637781, 0.1957806862280056, 0.30172887590480035, 0.2762880662334546, 0.06079715076251124, 0.004230996961204991, 0.2695422214330202, 0.0006089109909888091, 0.04524094173087234, 0.43414707731159163, 0.3016758901991854, 0.03459384085337536, 0.3720326697193098, 0.3922753461225432, 0.08113613244216267, 0.42869982773794657, 0.5315415803312192, 9.999999999998899e-05, 0.07835264233581152, 0.20708573242709905, 9.999999999998899e-05, 0.10885165281896658, 0.13309151738600744, 0.07870526899409414, 0.08842293797636758, 0.08292974271110665, 0.03869432082653834, 0.23984226937647257, 0.18718148155401937, 0.026400416546441208, 0.2676127439885534, 0.2379414849661613, 0.24536432290764265, 0.22424970840998948, 0.19879724565484502, 0.24855134925733768, 0.5991907952581617, 0.7455890990645102, 0.6276962720986039, 0.5774970738931969, 0.5769345362066165, 0.31775642892346245, 0.2662824700237677, 0.6415078473076792, 0.045338947842059274, 0.0844540508664472, 0.10876248978170311, 0.061706294350183044, 0.03867918347278099, 0.10609406855086068, 0.05399742200473212, 0.07186953705726318, 0.08041132824428765, 0.1434852119925183, 0.14104738457321508, 0.13435146644519214, 0.14488830732921687, 0.13784018412695076, 0.12485542690863405, 0.1271810395036055, 0.13909449539705454, 0.14351791939669833, 0.16243464094617743, 0.31830464671968595, 0.44160309102151474, 0.29269895463478257, 0.317167082793983, 0.4482019264531448, 0.1867508297663928, 0.3198417527701819, 0.4647584078803024, 0.12828008653041034, 0.24690370244963478, 0.34703336853982825, 0.24611231320372084, 0.22172733113112608, 0.38562134190285635, 0.14902134874297612, 0.26199248649715445, 0.30432588346088496, 0.17076429633163337, 0.1679682291697513, 0.18977813015059797, 0.16999837346041025, 0.1600634029675393, 0.18840738559224746, 0.16001339876081366, 0.13800282988145207, 0.195563032543146, 0.14725664265670002, 0.17100668052633283, 0.1989603253472465, 0.1420432321092261, 0.1377859807762084, 0.17794825227141386, 0.14947274771365082, 0.16522802896743616, 0.335323506249266, 0.13618960859517992, 0.12256417628249561, 0.17864226011495288, 0.14250496344604746, 0.15524953646613682, 0.18770609018922157, 0.08879803886730331, 0.44420041854838777, 0.14890074117153496, 0.07027747980950627, 0.1899876960744754, 0.20283941840002528, 0.4063203294270932, 0.15332621784734368, 0.16431336776361183, 0.21067871488437018, 0.19352264373901573, 0.7652344205712905, 0.14717175565330032, 0.18999850080507152, 0.1832319297539643, 0.1554680993202725, 0.1567249844987838, 0.1944994396889902, 0.17964348346925474, 0.17561535362795389, 0.1800180983686238, 0.04670310743926587, 0.07283097151233231, 0.07287668459476349, 0.07589712405195281, 0.04832267890171338, 0.07025040972003793, 0.06859207277516399, 0.06550881887663162, 0.09048360701003133]}, "mutation_prompt": null}
{"id": "818af9b7-61d9-46fb-b9ba-734807c80bd5", "solution": "import numpy as np\n\nclass Enhanced_DES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive and history-aware population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.memory = []  # Memory to store improvement history\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def adapt_parameters(self):\n        mean_history = np.mean(self.memory) if self.memory else self.F\n        self.F = 0.4 + 0.2 * np.random.rand() * mean_history\n        self.CR = 0.8 + 0.1 * np.random.rand()\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                    self.memory.append(trial_fitness)\n                else:\n                    self.success_rates[strat_index] *= 0.95  # Adjust decay factor\n                    if len(self.memory) > 0:\n                        self.memory.pop(0)  # Maintain manageable memory size\n        return self.best_solution, self.best_fitness", "name": "Enhanced_DES3D_Adaptive", "description": "Enhanced Adaptive Differential Evolution with Consideration of Search History and Memory for Improved Convergence.", "configspace": "", "generation": 7, "fitness": 0.1742454521448088, "feedback": "The algorithm Enhanced_DES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.21.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.17644825386054108, 0.1791018336404422, 0.6366342229811639, 0.14311714408965504, 0.17845377195293843, 0.514634613968755, 0.16617753739696195, 0.17099408693769313, 0.5658506280735485, 9.999999999998899e-05, 9.999999999998899e-05, 0.1916332441278421, 9.999999999998899e-05, 9.999999999998899e-05, 0.21117079376134862, 0.22788141640047999, 0.2806202604084791, 0.28014840042084277, 0.03026150522659532, 0.02812143533681699, 0.10477115604815967, 0.1168876673504663, 0.022996183057020225, 0.12518664468604568, 0.11317753682813414, 0.03386627634496231, 0.09822808795388371, 0.030907232248554295, 0.022866427668124745, 0.09235031434431151, 0.027869421916033366, 0.05548133066588856, 0.08033100239127378, 0.0208569095047052, 0.01016941409112937, 0.10112026416239095, 0.9723639497006673, 0.9199917686373483, 0.9880798422245727, 0.9712558144742416, 0.885124096634311, 0.9742427255494278, 0.9862847787691346, 0.8377651752697342, 0.9716341798372198, 0.28068601716024055, 0.0006456765362199413, 0.3035022704014585, 0.06812645969138498, 0.2589422045014762, 0.3095113403185482, 0.0351404030130007, 0.026919712548044483, 0.07854483042883653, 0.10243739793262197, 0.5150549356648151, 0.5387294301505456, 0.1262100400847045, 0.07817457294742214, 0.6681258476024368, 0.08565023294837026, 0.1178524763639307, 0.6844804821175573, 9.999999999998899e-05, 9.999999999998899e-05, 0.1591078939555438, 9.999999999998899e-05, 9.999999999998899e-05, 0.11358598293409472, 0.012948740017875715, 9.999999999998899e-05, 0.1796367539936362, 0.0020088645238544034, 9.999999999998899e-05, 0.13832885172217846, 9.999999999998899e-05, 9.999999999998899e-05, 0.12456916996311229, 0.004718554309009915, 9.999999999998899e-05, 0.128822146083726, 9.999999999998899e-05, 0.024516180316277336, 0.035477995910023874, 9.999999999998899e-05, 9.999999999998899e-05, 0.26512842207084264, 9.999999999998899e-05, 0.12414081720977643, 0.07253135932386445, 0.0182881107800007, 0.1979383040460727, 0.252157478433335, 9.999999999998899e-05, 9.999999999998899e-05, 0.0660195529680715, 0.001939295286299103, 0.3292135526043919, 0.46813967729946326, 9.999999999998899e-05, 0.0059999159360218934, 0.02233663040043299, 0.030319244144351387, 9.999999999998899e-05, 0.009442229624557097, 0.01686772064004982, 9.999999999998899e-05, 0.014193044292433288, 9.999999999998899e-05, 9.999999999998899e-05, 0.153766932961087, 9.999999999998899e-05, 9.999999999998899e-05, 0.1978189768382873, 0.004651350549953914, 0.18745692875778985, 0.16332713371996121, 0.1391877603298055, 0.24272308597657133, 0.414860036777448, 0.1607320482827076, 0.17417964928942498, 0.5591337663134649, 0.1980994102463065, 0.5731416654123664, 0.5100189848120698, 0.025221713109816135, 0.03260408761635247, 0.05890380861817701, 0.04870018669460152, 0.02682068323021669, 0.09925257859799863, 0.025165749195911302, 0.0442237263655858, 0.08265762361453799, 0.11667890805771097, 0.14231020006935435, 0.11363720022157853, 0.27889925897227297, 0.1173478262013079, 0.23788486940939113, 0.10836263480880337, 0.13585038963569374, 0.10983691149169195, 0.4711567663885132, 0.15579301079846808, 0.25298126932481024, 0.16337201924188194, 0.1550502745172927, 0.3631504243523158, 0.13536956699037128, 0.1808881045606623, 0.2917400788698902, 0.08573410526384395, 0.08012724968478269, 0.2864118150472945, 0.29270015249478754, 0.09634467282853987, 0.2804630928566777, 0.11865618892326912, 0.2293685181626004, 0.18853936629318713, 0.1411734819468684, 0.13429130561876101, 0.1689636633980094, 0.19367100040287066, 0.13121841241036858, 0.17400429232912962, 0.1317526362646324, 0.15730469696110938, 0.20620826735084696, 0.09651078715986372, 0.11531653440820933, 0.1945524399032963, 0.006008043400320684, 0.10435990609077195, 0.20265243193324656, 0.13531695738492822, 0.08825110051959817, 0.16290961181885855, 0.11064240857044028, 0.10855598075881356, 0.14735082142948885, 0.14138805808346333, 0.13096622731705154, 0.16382733838900898, 0.11865728037442591, 0.36672410427241575, 0.42332520916712146, 0.0624127331395784, 0.17317418874310775, 0.18618526704141247, 0.18427222086487327, 0.0853980027711233, 0.1963555061309351, 0.20391268615807745, 0.20893029061627255, 0.08829399515953595, 0.185150394721733, 0.16667418613217322, 0.17443923527749106, 0.17392799112968738, 0.1714875107383783, 0.1797094882077025, 0.17724202051958238, 0.1466721842132469, 0.1763105252084095, 0.042845458498656286, 0.04344660121116739, 0.06249691208115893, 0.05474605254260656, 0.04451047529361096, 0.06943689622973448, 0.03848580922743927, 0.05083323699050324, 0.07769386584639015]}, "mutation_prompt": null}
{"id": "63df9fd0-7c13-414d-8027-cfe72920b3ac", "solution": "import numpy as np\n\nclass DES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95  # Adjust decay factor\n        return self.best_solution, self.best_fitness", "name": "DES3D_Adaptive", "description": "Adaptive Differential Evolution with Dynamic Population Size and Strategy Adaptation.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.7191171814890431, 0.6853737228883547, 0.8310903990671489, 0.7358915068430041, 0.6894134061139792, 0.6870897314767539, 0.29803138765545856, 0.2921858092141588, 0.2707575770799596, 9.999999999998899e-05, 0.5212169331829446, 0.6706607056182736, 9.999999999998899e-05, 0.538989137439963, 0.15094621782684248, 0.5202166923625464, 0.5350631063776288, 0.6354279931041238, 0.0565521313962396, 0.0874779701311269, 0.11394139240903389, 0.09063660640218985, 0.10444510292232645, 0.11648651802696264, 0.0931761928524375, 0.09077546129201763, 0.05131398314242874, 0.05593606206764923, 0.08262960703265687, 0.11346410044122879, 0.057461531690531364, 0.10508598805377001, 0.11594679796374185, 0.0880698787620593, 0.0747548786974932, 0.12618252951090925, 0.8756699015401185, 0.8893862884989027, 0.6273329958484906, 0.864577203375756, 0.8796170936826908, 0.8465925999064775, 0.780845543850287, 0.7890953287268208, 0.0925596036591182, 0.3733784351599494, 0.3935586090685993, 0.08524911664865198, 0.3718069591620561, 0.11388273360860024, 0.23333753682033398, 0.37243493338332145, 0.3569427532546271, 0.2821690422963661, 0.1612555233141606, 0.6732119185101904, 0.7046938777189118, 0.17633895017533774, 0.6601544180023322, 0.8382430102854954, 0.09289008682419919, 0.5739790419974562, 0.231033385222013, 0.05034908187285547, 0.025830979489989803, 0.03835252915446996, 0.08313751385701218, 0.052424928725893216, 0.18461203705238172, 0.05333088664157881, 0.3500733844815186, 0.17824797498333478, 0.06971880310210532, 0.046442780376550585, 0.2139214668262195, 0.06965798036253312, 0.045246734482950024, 0.16947189091814563, 0.05817924227155613, 0.04163739215956286, 0.33907425743485253, 0.2988555259674699, 0.2850620882637781, 0.1957806862280056, 0.30172887590480035, 0.2762880662334546, 0.06079715076251124, 0.004230996961204991, 0.2695422214330202, 0.0006089109909888091, 0.04524094173087234, 0.43414707731159163, 0.3016758901991854, 0.03459384085337536, 0.3720326697193098, 0.3922753461225432, 0.08113613244216267, 0.42869982773794657, 0.5315415803312192, 9.999999999998899e-05, 0.07835264233581152, 0.20708573242709905, 9.999999999998899e-05, 0.10885165281896658, 0.13309151738600744, 0.07870526899409414, 0.08842293797636758, 0.08292974271110665, 0.03869432082653834, 0.23984226937647257, 0.18718148155401937, 0.026400416546441208, 0.2676127439885534, 0.2379414849661613, 0.24536432290764265, 0.22424970840998948, 0.19879724565484502, 0.24855134925733768, 0.5991907952581617, 0.7455890990645102, 0.6276962720986039, 0.5774970738931969, 0.5769345362066165, 0.31775642892346245, 0.2662824700237677, 0.6415078473076792, 0.045338947842059274, 0.0844540508664472, 0.10876248978170311, 0.061706294350183044, 0.03867918347278099, 0.10609406855086068, 0.05399742200473212, 0.07186953705726318, 0.08041132824428765, 0.1434852119925183, 0.14104738457321508, 0.13435146644519214, 0.14488830732921687, 0.13784018412695076, 0.12485542690863405, 0.1271810395036055, 0.13909449539705454, 0.14351791939669833, 0.16243464094617743, 0.31830464671968595, 0.44160309102151474, 0.29269895463478257, 0.317167082793983, 0.4482019264531448, 0.1867508297663928, 0.3198417527701819, 0.4647584078803024, 0.12828008653041034, 0.24690370244963478, 0.34703336853982825, 0.24611231320372084, 0.22172733113112608, 0.38562134190285635, 0.14902134874297612, 0.26199248649715445, 0.30432588346088496, 0.17076429633163337, 0.1679682291697513, 0.18977813015059797, 0.16999837346041025, 0.1600634029675393, 0.18840738559224746, 0.16001339876081366, 0.13800282988145207, 0.195563032543146, 0.14725664265670002, 0.17100668052633283, 0.1989603253472465, 0.1420432321092261, 0.1377859807762084, 0.17794825227141386, 0.14947274771365082, 0.16522802896743616, 0.335323506249266, 0.13618960859517992, 0.12256417628249561, 0.17864226011495288, 0.14250496344604746, 0.15524953646613682, 0.18770609018922157, 0.08879803886730331, 0.44420041854838777, 0.14890074117153496, 0.07027747980950627, 0.1899876960744754, 0.20283941840002528, 0.4063203294270932, 0.15332621784734368, 0.16431336776361183, 0.21067871488437018, 0.19352264373901573, 0.7652344205712905, 0.14717175565330032, 0.18999850080507152, 0.1832319297539643, 0.1554680993202725, 0.1567249844987838, 0.1944994396889902, 0.17964348346925474, 0.17561535362795389, 0.1800180983686238, 0.04670310743926587, 0.07283097151233231, 0.07287668459476349, 0.07589712405195281, 0.04832267890171338, 0.07025040972003793, 0.06859207277516399, 0.06550881887663162, 0.09048360701003133]}, "mutation_prompt": null}
{"id": "939c41a2-af8f-459d-ad01-8e169f233b0c", "solution": "import numpy as np\n\nclass Enhanced_DES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.adaptive_F_CR = [0.5, 0.9]  # Initial F and CR\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.adaptive_F_CR[0] * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return (self.population[r1] + self.adaptive_F_CR[0] * (self.population[r2] - self.population[r3]) +\n                self.adaptive_F_CR[0] * (self.population[r4] - self.population[r5]))\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return (self.population[idx] + self.adaptive_F_CR[0] * (self.population[best_index] - self.population[idx]) +\n                self.adaptive_F_CR[0] * (self.population[r1] - self.population[r2]))\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.adaptive_F_CR[1] or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def adapt_parameters(self):\n        self.adaptive_F_CR[0] = np.clip(self.adaptive_F_CR[0] + 0.1 * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.adaptive_F_CR[1] = np.clip(self.adaptive_F_CR[1] + 0.1 * (np.random.rand() - 0.5), 0.7, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                self.adapt_parameters()\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95  # Adjust decay factor\n        return self.best_solution, self.best_fitness", "name": "Enhanced_DES3D_Adaptive", "description": "Enhanced Adaptive Differential Evolution that incorporates a success-history-based parameter adaptation mechanism.", "configspace": "", "generation": 9, "fitness": 0.16078010784260965, "feedback": "The algorithm Enhanced_DES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.17.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.2794661041510621, 0.2382588330395663, 0.20792239522437583, 0.21956195930197275, 0.2579466830595538, 0.6128196855373036, 0.22671079031005004, 0.7687459271906147, 0.2022737424943739, 9.999999999998899e-05, 0.0001688698475600381, 0.334804240666136, 9.999999999998899e-05, 0.00020226714619142605, 9.999999999998899e-05, 0.6214556875456932, 0.6249064547567094, 0.34435143950898417, 0.08940759659870112, 0.06727889729525416, 0.044743408625033454, 0.11701997193312164, 0.06404136499446433, 0.04813870344976312, 0.09378587610837785, 0.06273418447510049, 0.04112290251653994, 0.04220808344844007, 0.030079914937361174, 0.048255499476341335, 0.04509376061495496, 0.031975009179968206, 0.07051180770421017, 0.03783675447483659, 0.031918818062617205, 0.0864069356944005, 0.9387527793544588, 0.24105219936415478, 0.26801940979689254, 0.9062256828653595, 0.17272711204369173, 0.8545326513800214, 0.9102087255192802, 0.654423585290871, 0.9498451841117916, 0.39904380067130185, 0.07430732622264147, 0.09415093921133899, 0.273660437533249, 0.08576388331522544, 0.07100772098023134, 0.13524263981221596, 0.08121802445960746, 0.07075458372772281, 0.1743283489072226, 0.6444892435550624, 0.11930763292493995, 0.17870669450331755, 0.1356430070146425, 0.14465815535520055, 0.09334018300773328, 0.1419908367055679, 0.11989826756921196, 0.04723905805354556, 0.08243801526859174, 0.03367423435744421, 0.18695063985063232, 0.055663481173739315, 0.0168822818792842, 0.12832005116673828, 0.05857376165232964, 0.07418833043166995, 0.10503776698205858, 0.060799482689914086, 0.03935705344338125, 0.08035462033630159, 0.0060079802860656395, 0.06145199655024303, 0.06989078801487225, 0.02132140282771966, 0.030628778969771342, 0.11718859762049794, 0.1091846213726152, 0.06733264562740693, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.22786345330952085, 0.20671091039000422, 0.2520247216347229, 0.2337316031103419, 0.04607111721256496, 0.009437103571596328, 0.03451548284905437, 0.3059087384237742, 0.24820026283462093, 9.999999999998899e-05, 0.06453266377077194, 9.999999999998899e-05, 0.2131854226634371, 9.999999999998899e-05, 9.999999999998899e-05, 0.10576913517941955, 0.02198439767445326, 9.999999999998899e-05, 0.15401838220901576, 0.007565263400793665, 0.027593994157455892, 0.16054498785715277, 0.022338359127872187, 0.0072175369458332694, 0.019807014763299602, 0.03453794959863332, 0.017493838347421797, 0.45730628035825616, 0.4549945941461624, 0.23466957152852996, 0.423261943851576, 0.23416211588754432, 0.46344590643559225, 0.4743468185425207, 0.23849287932990126, 0.21657302008294044, 0.04683912300049664, 0.034079669230583254, 0.043947524082820544, 0.07366577771028548, 0.050831509699946764, 0.057767717750190406, 0.04337347388184443, 0.04676934288802781, 0.05058873013653353, 0.11141454696696418, 0.20096928721977048, 0.13631610004371741, 0.1408387782938908, 0.11233923912569221, 0.13098491752734975, 0.12560665603747145, 0.08911306176831857, 0.15968886731686394, 0.24897267665482237, 0.16673663332110777, 0.1781158114065734, 0.2625353859758618, 0.18249399064116645, 0.16056793033034378, 0.1938656413178954, 0.25748990849203957, 0.16245816376139688, 0.27124237257416794, 0.12296717651715372, 0.10539560720694041, 0.18597582829903514, 0.1124619521270468, 0.1744491766771049, 0.13088104264633915, 0.1210741005292526, 0.11021833645707979, 0.1598255091941706, 0.15580789503860903, 0.13368238047454795, 0.16203287057442994, 0.14881862047689665, 0.1588133890426603, 0.16513335191795742, 0.18214223418387177, 0.15613940351783928, 0.17212606212125992, 0.13448790111229247, 0.14604438295556332, 0.1427374003628562, 0.14340147917211, 0.1643317906723165, 0.17043881663677474, 0.14126776179068057, 0.1338408604741257, 0.20176962700196932, 0.1127294219583993, 0.14111383762123608, 0.27022649991194025, 0.14376832353873636, 0.15074996969422427, 0.18744239372528348, 0.1781812973458642, 0.1287701995646643, 0.23890115205930273, 0.1993969014575636, 0.1053285439492665, 0.4167673307741252, 0.11580906048529527, 0.10657020546143503, 0.2075688763017196, 0.19858668015297132, 0.1344233772211907, 0.14857989684219197, 0.17890932480425636, 0.15108060998540118, 0.16398807281913286, 0.19684434206486157, 0.1526030927816222, 0.18434898411756862, 0.1526096266276229, 0.1505625578715606, 0.06416155367246734, 0.046834329273194863, 0.05162306621155255, 0.048469502569677525, 0.04189877657359409, 0.054742028563121825, 0.046258540484805266, 0.04281066519922949, 0.04232177565938855]}, "mutation_prompt": null}
{"id": "f9cccc8a-0423-417f-ae3c-9047ede439b3", "solution": "import numpy as np\n\nclass DES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95  # Adjust decay factor\n        return self.best_solution, self.best_fitness", "name": "DES3D_Adaptive", "description": "Adaptive Differential Evolution with Dynamic Population Size and Strategy Adaptation.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.7191171814890431, 0.6853737228883547, 0.8310903990671489, 0.7358915068430041, 0.6894134061139792, 0.6870897314767539, 0.29803138765545856, 0.2921858092141588, 0.2707575770799596, 9.999999999998899e-05, 0.5212169331829446, 0.6706607056182736, 9.999999999998899e-05, 0.538989137439963, 0.15094621782684248, 0.5202166923625464, 0.5350631063776288, 0.6354279931041238, 0.0565521313962396, 0.0874779701311269, 0.11394139240903389, 0.09063660640218985, 0.10444510292232645, 0.11648651802696264, 0.0931761928524375, 0.09077546129201763, 0.05131398314242874, 0.05593606206764923, 0.08262960703265687, 0.11346410044122879, 0.057461531690531364, 0.10508598805377001, 0.11594679796374185, 0.0880698787620593, 0.0747548786974932, 0.12618252951090925, 0.8756699015401185, 0.8893862884989027, 0.6273329958484906, 0.864577203375756, 0.8796170936826908, 0.8465925999064775, 0.780845543850287, 0.7890953287268208, 0.0925596036591182, 0.3733784351599494, 0.3935586090685993, 0.08524911664865198, 0.3718069591620561, 0.11388273360860024, 0.23333753682033398, 0.37243493338332145, 0.3569427532546271, 0.2821690422963661, 0.1612555233141606, 0.6732119185101904, 0.7046938777189118, 0.17633895017533774, 0.6601544180023322, 0.8382430102854954, 0.09289008682419919, 0.5739790419974562, 0.231033385222013, 0.05034908187285547, 0.025830979489989803, 0.03835252915446996, 0.08313751385701218, 0.052424928725893216, 0.18461203705238172, 0.05333088664157881, 0.3500733844815186, 0.17824797498333478, 0.06971880310210532, 0.046442780376550585, 0.2139214668262195, 0.06965798036253312, 0.045246734482950024, 0.16947189091814563, 0.05817924227155613, 0.04163739215956286, 0.33907425743485253, 0.2988555259674699, 0.2850620882637781, 0.1957806862280056, 0.30172887590480035, 0.2762880662334546, 0.06079715076251124, 0.004230996961204991, 0.2695422214330202, 0.0006089109909888091, 0.04524094173087234, 0.43414707731159163, 0.3016758901991854, 0.03459384085337536, 0.3720326697193098, 0.3922753461225432, 0.08113613244216267, 0.42869982773794657, 0.5315415803312192, 9.999999999998899e-05, 0.07835264233581152, 0.20708573242709905, 9.999999999998899e-05, 0.10885165281896658, 0.13309151738600744, 0.07870526899409414, 0.08842293797636758, 0.08292974271110665, 0.03869432082653834, 0.23984226937647257, 0.18718148155401937, 0.026400416546441208, 0.2676127439885534, 0.2379414849661613, 0.24536432290764265, 0.22424970840998948, 0.19879724565484502, 0.24855134925733768, 0.5991907952581617, 0.7455890990645102, 0.6276962720986039, 0.5774970738931969, 0.5769345362066165, 0.31775642892346245, 0.2662824700237677, 0.6415078473076792, 0.045338947842059274, 0.0844540508664472, 0.10876248978170311, 0.061706294350183044, 0.03867918347278099, 0.10609406855086068, 0.05399742200473212, 0.07186953705726318, 0.08041132824428765, 0.1434852119925183, 0.14104738457321508, 0.13435146644519214, 0.14488830732921687, 0.13784018412695076, 0.12485542690863405, 0.1271810395036055, 0.13909449539705454, 0.14351791939669833, 0.16243464094617743, 0.31830464671968595, 0.44160309102151474, 0.29269895463478257, 0.317167082793983, 0.4482019264531448, 0.1867508297663928, 0.3198417527701819, 0.4647584078803024, 0.12828008653041034, 0.24690370244963478, 0.34703336853982825, 0.24611231320372084, 0.22172733113112608, 0.38562134190285635, 0.14902134874297612, 0.26199248649715445, 0.30432588346088496, 0.17076429633163337, 0.1679682291697513, 0.18977813015059797, 0.16999837346041025, 0.1600634029675393, 0.18840738559224746, 0.16001339876081366, 0.13800282988145207, 0.195563032543146, 0.14725664265670002, 0.17100668052633283, 0.1989603253472465, 0.1420432321092261, 0.1377859807762084, 0.17794825227141386, 0.14947274771365082, 0.16522802896743616, 0.335323506249266, 0.13618960859517992, 0.12256417628249561, 0.17864226011495288, 0.14250496344604746, 0.15524953646613682, 0.18770609018922157, 0.08879803886730331, 0.44420041854838777, 0.14890074117153496, 0.07027747980950627, 0.1899876960744754, 0.20283941840002528, 0.4063203294270932, 0.15332621784734368, 0.16431336776361183, 0.21067871488437018, 0.19352264373901573, 0.7652344205712905, 0.14717175565330032, 0.18999850080507152, 0.1832319297539643, 0.1554680993202725, 0.1567249844987838, 0.1944994396889902, 0.17964348346925474, 0.17561535362795389, 0.1800180983686238, 0.04670310743926587, 0.07283097151233231, 0.07287668459476349, 0.07589712405195281, 0.04832267890171338, 0.07025040972003793, 0.06859207277516399, 0.06550881887663162, 0.09048360701003133]}, "mutation_prompt": null}
{"id": "4fbe62bc-2d9f-40e1-b81b-d1b1d25297bd", "solution": "import numpy as np\n\nclass Enhanced_DES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(15, 7 * dim)  # Mildly increased population size for better exploration\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F_base = 0.6\n        self.CR = 0.8  # Adjusted crossover rate\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.dynamic_F = np.full(3, self.F_base)  # Adaptive F for each strategy\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx, self.dynamic_F[strat_index])\n        return mutant, strat_index\n\n    def rand_1(self, idx, F):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx, F):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + F * (self.population[r2] - self.population[r3]) + F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx, F):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + F * (self.population[best_index] - self.population[idx]) + F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        perturbation = np.random.normal(0, 0.01, self.dim)  # Small random perturbation\n        trial = np.clip(trial + perturbation, self.lb, self.ub)\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                    self.dynamic_F[strat_index] = min(1.0, self.dynamic_F[strat_index] + 0.05)  # Increase F adaptively\n                else:\n                    self.success_rates[strat_index] *= 0.9  # Slightly higher decay factor\n                    self.dynamic_F[strat_index] = max(0.4, self.dynamic_F[strat_index] * 0.95)  # Decrease F adaptively\n        return self.best_solution, self.best_fitness", "name": "Enhanced_DES3D_Adaptive", "description": "Enhanced Adaptive Differential Evolution with F-Adaptive Mutation and Novel Crossover Strategy.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {}, "mutation_prompt": null}
{"id": "b967fea4-aa6d-42d0-aad4-6adddc699165", "solution": "import numpy as np\n\nclass HybridDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        curr_cr = np.random.uniform(0.1, 1.0)  # Adaptive crossover rate\n        for j in range(self.dim):\n            if np.random.rand() < curr_cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n        return self.best_solution, self.best_fitness", "name": "HybridDES3D_Adaptive", "description": "Hybrid Evolutionary Strategy combining Adaptive Differential Evolution with Crossover Rate Tuning.", "configspace": "", "generation": 12, "fitness": 0.22452764458532962, "feedback": "The algorithm HybridDES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.7084555954378262, 0.7947487335189428, 0.24111651375824272, 0.722092906245533, 0.7043868449633823, 0.781834532050488, 0.23904313267850885, 0.7518788062448885, 0.21750693120007591, 0.5110302507369746, 0.6572999480319079, 0.6459276367768443, 9.999999999998899e-05, 0.6430253747349353, 0.5257961708372976, 9.999999999998899e-05, 0.6310541961228895, 0.4598348086094315, 0.05893538836485801, 0.19021888993481484, 0.2505582275038116, 0.13964083621770063, 0.3103360307572921, 0.0470319849819365, 0.11686545779032964, 0.1373392185552733, 0.045744606181167935, 0.03455488159194431, 0.14224181916721967, 0.1314387168292115, 0.11070280747225503, 0.13006800078009195, 0.15643239330255443, 0.10344748561259587, 0.21714736953215297, 0.1321373101470532, 0.9558821902044425, 0.902307536699314, 0.1092272196755284, 0.9471536189524092, 0.9332532242781866, 0.1402442631688875, 0.9577802420908246, 0.9777926433127464, 0.3417023919857949, 0.27443603126244576, 0.30147872783260987, 0.05267275388685344, 0.3176943884280462, 0.3826093693245721, 0.2622663323356582, 0.3075561975263752, 0.27319631302577807, 0.3505052685176284, 0.5358337465912211, 0.4839963603930325, 0.5565764585192844, 0.41086246295237894, 0.5998150460956702, 0.19602039614940892, 0.22373876004139703, 0.6299093246275422, 0.12698700532472418, 0.16553621589594236, 0.1492816774412118, 0.026467084689643317, 0.03856335809157441, 0.1408459567700041, 0.0493510437914767, 0.044214121553145525, 0.19509788633424674, 0.16869398493780263, 0.09860716461274677, 0.15160918500068687, 0.1283849640433653, 0.02617412580688483, 0.1764180253431903, 0.17955206024118342, 0.13185418583978514, 0.2029756448205129, 0.18681182127804452, 9.999999999998899e-05, 0.01406167538182923, 0.11913745725221903, 9.999999999998899e-05, 0.10351413065258508, 9.999999999998899e-05, 9.999999999998899e-05, 0.12190757016235743, 0.042661068595720275, 0.10994703348449586, 0.10039676872948544, 0.2024234141284168, 0.012040694706591082, 0.18036022602327506, 0.0009018010572839907, 0.04845467846147222, 0.2672784891832599, 0.03529783967638378, 0.06520632423592576, 0.04754119813635771, 9.999999999998899e-05, 0.0042391463792664785, 0.08244010473460062, 9.999999999998899e-05, 0.009590418291193226, 0.020977469650139913, 0.054043234577983434, 0.013283484168777449, 0.16541096042098347, 0.004964124789607394, 0.20280926658813547, 0.20498588012163044, 0.21827304535910141, 0.009096836778381134, 0.11558918363815052, 0.11923341079013394, 0.23352597422697796, 0.4722999095221766, 0.5081149013741715, 0.46679152145019076, 0.5729929682100522, 0.5471054669240728, 0.22151153152162595, 0.5504876080499465, 0.5070577301650931, 0.08539119143671614, 0.08393276830231333, 0.09350556749179761, 0.07163714481786843, 0.08543840580479978, 0.10450224010610143, 0.04705651325910498, 0.1063307045616062, 0.07133842645909139, 0.15363949125580767, 0.143596016899608, 0.13623797357443923, 0.1365713428918709, 0.1377558713814656, 0.11195077106566642, 0.12356331743602056, 0.13975697069501802, 0.1557181437666606, 0.1718435569680541, 0.329825023443192, 0.3211689857211816, 0.24687000402210502, 0.3584951607904482, 0.3050896781059955, 0.15796797882931768, 0.2823171829429538, 0.42302081192512186, 0.16983881489906183, 0.28548788810897663, 0.2533002581855347, 0.2511593674993877, 0.21015595875168458, 0.25202270945902805, 0.2215665162317929, 0.1974605292138828, 0.11699041035258362, 0.14406419505253232, 0.19276769832389473, 0.1449591264547997, 0.2086690517633304, 0.17478147194371452, 0.23386342433935547, 0.20791038064943956, 0.18532252015750827, 0.18286390068139602, 0.13408721907854415, 0.18394382991015268, 0.20239378151723764, 0.13941311344057872, 0.20059425752305715, 0.15777929545258573, 0.17606292220071262, 0.2616757945193461, 0.2178421225486109, 0.20535576189026605, 0.18224695246489298, 0.1611932938146683, 0.17333065757361676, 0.16331893863320024, 0.13168921929623445, 0.18077680385304318, 0.1386096825741222, 0.16011026110289062, 0.1577593805773797, 0.16231801835782844, 0.16418112163463516, 0.1637512437427766, 0.4261049181279818, 0.16705928874685505, 0.18120678017933722, 0.16302546607804635, 0.07777700001088539, 0.17579142404458437, 0.1836891771452578, 0.17739115832634256, 0.1486377281025938, 0.1950038416646599, 0.14938448621350453, 0.1851021910452868, 0.18823145261037633, 0.18264057910680354, 0.06735615106275328, 0.07706143600303494, 0.06297471539250332, 0.04822445008875842, 0.07894759019930098, 0.0708769288682719, 0.051929300115655996, 0.08378344802066329, 0.041067447584437256]}, "mutation_prompt": null}
{"id": "5401b80f-ad0e-4a4f-85a4-3e34c689e389", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.9  # Adjust decay factor for faster adaptation\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive", "description": "A Modified Adaptive Differential Evolution with Enhanced Exploration and Exploitation Balancing.", "configspace": "", "generation": 13, "fitness": 0.24817571229817584, "feedback": "The algorithm EnhancedDES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.7191171814890431, 0.6853737228883547, 0.8310903990671489, 0.7358915068430041, 0.6894134061139792, 0.6870897314767539, 0.29803138765545856, 0.2921858092141588, 0.2707575770799596, 9.999999999998899e-05, 0.5212169331829446, 0.6706607056182736, 9.999999999998899e-05, 0.538989137439963, 0.15094621782684248, 0.5202166923625464, 0.5350631063776288, 0.6354279931041238, 0.0565521313962396, 0.0874779701311269, 0.11394139240903389, 0.09063660640218985, 0.10444510292232645, 0.11648651802696264, 0.0931761928524375, 0.09077546129201763, 0.05131398314242874, 0.05593606206764923, 0.08262960703265687, 0.11346410044122879, 0.057461531690531364, 0.10508598805377001, 0.11594679796374185, 0.0880698787620593, 0.0747548786974932, 0.12618252951090925, 0.8756699015401185, 0.8893862884989027, 0.6273329958484906, 0.864577203375756, 0.8796170936826908, 0.8465925999064775, 0.780845543850287, 0.7890953287268208, 0.0925596036591182, 0.3733784351599494, 0.3935586090685993, 0.08524911664865198, 0.3718069591620561, 0.11388273360860024, 0.23333753682033398, 0.37243493338332145, 0.3569427532546271, 0.2821690422963661, 0.1612555233141606, 0.6732119185101904, 0.7046938777189118, 0.17633895017533774, 0.6601544180023322, 0.8382430102854954, 0.09289008682419919, 0.5739790419974562, 0.231033385222013, 0.05034908187285547, 0.025830979489989803, 0.03835252915446996, 0.08313751385701218, 0.052424928725893216, 0.18461203705238172, 0.05333088664157881, 0.3500733844815186, 0.17824797498333478, 0.06971880310210532, 0.046442780376550585, 0.2139214668262195, 0.06965798036253312, 0.045246734482950024, 0.16947189091814563, 0.05817924227155613, 0.04163739215956286, 0.33907425743485253, 0.2988555259674699, 0.2850620882637781, 0.1957806862280056, 0.30172887590480035, 0.2762880662334546, 0.06079715076251124, 0.004230996961204991, 0.2695422214330202, 0.0006089109909888091, 0.04524094173087234, 0.43414707731159163, 0.3016758901991854, 0.03459384085337536, 0.3720326697193098, 0.3922753461225432, 0.08113613244216267, 0.42869982773794657, 0.5315415803312192, 9.999999999998899e-05, 0.07835264233581152, 0.20708573242709905, 9.999999999998899e-05, 0.10885165281896658, 0.13309151738600744, 0.07870526899409414, 0.08842293797636758, 0.08292974271110665, 0.03869432082653834, 0.23984226937647257, 0.18718148155401937, 0.026400416546441208, 0.2676127439885534, 0.2379414849661613, 0.24536432290764265, 0.22424970840998948, 0.19879724565484502, 0.24855134925733768, 0.5991907952581617, 0.7455890990645102, 0.6276962720986039, 0.5774970738931969, 0.5769345362066165, 0.31775642892346245, 0.2662824700237677, 0.6415078473076792, 0.045338947842059274, 0.0844540508664472, 0.10876248978170311, 0.061706294350183044, 0.03867918347278099, 0.10609406855086068, 0.05399742200473212, 0.07186953705726318, 0.08041132824428765, 0.1434852119925183, 0.14104738457321508, 0.13435146644519214, 0.14488830732921687, 0.13784018412695076, 0.12485542690863405, 0.1271810395036055, 0.13909449539705454, 0.14351791939669833, 0.16243464094617743, 0.31830464671968595, 0.44160309102151474, 0.29269895463478257, 0.317167082793983, 0.4482019264531448, 0.1867508297663928, 0.3198417527701819, 0.4647584078803024, 0.12828008653041034, 0.24690370244963478, 0.34703336853982825, 0.24611231320372084, 0.22172733113112608, 0.38562134190285635, 0.14902134874297612, 0.26199248649715445, 0.30432588346088496, 0.17076429633163337, 0.1679682291697513, 0.18977813015059797, 0.16999837346041025, 0.1600634029675393, 0.18840738559224746, 0.16001339876081366, 0.13800282988145207, 0.195563032543146, 0.14725664265670002, 0.17100668052633283, 0.1989603253472465, 0.1420432321092261, 0.1377859807762084, 0.17794825227141386, 0.14947274771365082, 0.16522802896743616, 0.335323506249266, 0.13618960859517992, 0.12256417628249561, 0.17864226011495288, 0.14250496344604746, 0.15524953646613682, 0.18770609018922157, 0.08879803886730331, 0.44420041854838777, 0.14890074117153496, 0.07027747980950627, 0.1899876960744754, 0.20283941840002528, 0.4063203294270932, 0.15332621784734368, 0.16431336776361183, 0.21067871488437018, 0.19352264373901573, 0.7652344205712905, 0.14717175565330032, 0.18999850080507152, 0.1832319297539643, 0.1554680993202725, 0.1567249844987838, 0.1944994396889902, 0.17964348346925474, 0.17561535362795389, 0.1800180983686238, 0.04670310743926587, 0.07283097151233231, 0.07287668459476349, 0.07589712405195281, 0.04832267890171338, 0.07025040972003793, 0.06859207277516399, 0.06550881887663162, 0.09048360701003133]}, "mutation_prompt": null}
{"id": "2980ae33-acce-4602-85b7-fb6191974037", "solution": "import numpy as np\n\nclass HybridDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(4)\n        self.func = None\n        self.success_rates = np.zeros(4)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(4) / 4\n        return np.random.choice(4, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best, self.best_2]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def best_2(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[best_index] + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1.1\n                else:\n                    self.success_rates[strat_index] *= 0.9  # Adjust decay factor\n        return self.best_solution, self.best_fitness", "name": "HybridDES3D_Adaptive", "description": "Hybrid Adaptive Differential Evolution with Enhanced Mutation and Learning-based Strategy Selection.", "configspace": "", "generation": 14, "fitness": 0.1722543691743106, "feedback": "The algorithm HybridDES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.35407254283275025, 0.2611723321966475, 0.7334912365092215, 0.39283652127076374, 0.2507160333936419, 0.7131415918310686, 0.2874243783703925, 0.21620805010167987, 0.3460682082469533, 0.021872639806540195, 0.0048758275881851665, 0.5439089200580169, 0.007841576325158583, 0.014036460017933683, 0.15094621782684248, 9.999999999998899e-05, 0.0010849153679144408, 0.5262799660797742, 0.0740542341920305, 0.05087791638593531, 0.1003567040966884, 0.05611558597720234, 0.04969488399114286, 0.11648651802696264, 0.0651472090252615, 0.062279304746672315, 0.06948233155059169, 0.05382756585824644, 0.049190647627199935, 0.07188355258224799, 0.056472162914697366, 0.03892406105668578, 0.08982550999696248, 0.023087939848598582, 0.03553177807976404, 0.07825219360406577, 0.10566415878797375, 0.10835078709203338, 0.9414956459077113, 0.07695813725188783, 0.09109739161836428, 0.8399078429546941, 0.1010753273225028, 0.12602911990338395, 0.9136386516262415, 0.15054598229926253, 0.09281372666816257, 0.14877883527345825, 0.1250244747354865, 0.12329147088098635, 0.15584531608119156, 0.17132976564780544, 0.09906762891996679, 0.38453828980479077, 0.21288199361286464, 0.14539674930102864, 0.7046938777189118, 0.16478198746953654, 0.1734229681632825, 0.8382430102854954, 0.12716861930192558, 0.183539105212705, 0.8175583039482672, 0.09546852349832369, 0.03160517793409201, 0.10861727460054371, 0.06867230510136213, 0.046544561401726914, 0.2042103254007771, 0.06378946549775932, 0.054336816909849595, 0.18443004197672785, 0.14598154937000307, 0.06014123778833513, 0.0899058769795823, 0.033294029634641675, 0.061824708267688266, 0.16947189091814563, 0.14385847529806506, 0.04271649926507903, 0.10220941340175682, 9.999999999998899e-05, 9.999999999998899e-05, 0.2573599247192372, 9.999999999998899e-05, 9.999999999998899e-05, 0.17139546925466898, 0.017141102866120694, 9.999999999998899e-05, 9.999999999998899e-05, 0.04838649267218875, 0.08285609937198168, 0.47114801715036525, 0.04797452746562558, 0.03180709352778954, 0.3922753461225432, 0.08070998778687077, 0.0333243573360722, 0.4542695916671161, 0.007736864120479359, 9.999999999998899e-05, 0.20708573242709905, 9.999999999998899e-05, 9.999999999998899e-05, 0.13309151738600744, 9.999999999998899e-05, 9.999999999998899e-05, 0.049783115709611914, 0.08585046499196392, 0.03201198640499259, 0.18718148155401937, 0.002883236973684533, 0.04097017105305312, 0.2379414849661613, 0.023799105852889024, 0.02861215405652695, 0.2520772390719068, 0.2690210336542316, 0.20544721416935974, 0.579167309535474, 0.32433258055295966, 0.2190508132365725, 0.6025157071624049, 0.3530761326235373, 0.26314403999372804, 0.6415078473076792, 0.0656881677553387, 0.042066017731075434, 0.07707846134655572, 0.049969027957638024, 0.05598205428999248, 0.12765234766712952, 0.05765778558896617, 0.05359170524413237, 0.04483067693055731, 0.11017824602827953, 0.13927297900577396, 0.13434825271085593, 0.154298342654986, 0.10852972522114013, 0.14621339442998982, 0.09508517944591954, 0.10492179963953507, 0.13175347254927217, 0.16965428164601293, 0.18080023809594026, 0.4416011416834549, 0.20518390332063619, 0.17495107601110926, 0.3177311730360981, 0.18356969518691535, 0.196801501782906, 0.3302843587402221, 0.08083677325067296, 0.11382775367629505, 0.34703336853982825, 0.15306551597384677, 0.11869635769591802, 0.3856234974981111, 0.13951477528654854, 0.13910627155987165, 0.30432588346088496, 0.15981394453516773, 0.15671684775420092, 0.21240563270343016, 0.14909175548190323, 0.1431682185335862, 0.17496806699496703, 0.14739093857706953, 0.15273366414771394, 0.20650260006282983, 0.14728887556794856, 0.15032020938620716, 0.1750201601098028, 0.16467064098684137, 0.12614591867634317, 0.1781171998998854, 0.1539192343844097, 0.1471798687177598, 0.16872419195798416, 0.5515046778958889, 0.12187013333359487, 0.17299320448112354, 0.14215100510345524, 0.14881567679769814, 0.5378536810019788, 0.0952345786420512, 0.16454355076506633, 0.1488998778534989, 0.07875461610380063, 0.11618413371024505, 0.1484176753616313, 0.16355775258913485, 0.09304298614056805, 0.34388315180393925, 0.09770675455388333, 0.10933934034462067, 0.765234074719822, 0.14501468776734205, 0.1496472843838519, 0.1778635731121363, 0.15546280244980093, 0.13524107058350632, 0.19449836490199401, 0.15419201691323248, 0.1586391008392366, 0.1866289319456671, 0.05901657290345452, 0.047470504677475045, 0.0699354362900162, 0.04534244224359951, 0.04989669005264186, 0.07025040972003793, 0.05118977831079896, 0.0469574389721662, 0.07998649209793274]}, "mutation_prompt": null}
{"id": "74f130d8-bbcb-4692-aace-737934283d58", "solution": "import numpy as np\n\nclass Enhanced_DES3D:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(15, 7 * dim)  # Slightly increased adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(4)\n        self.func = None\n        self.success_rates = np.zeros(4)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(4) / 4\n        return np.random.choice(4, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best, self.best_1_bin]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def best_1_bin(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != best_index]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[best_index] + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.96  # Slightly adjusting decay factor\n        return self.best_solution, self.best_fitness", "name": "Enhanced_DES3D", "description": "Enhanced Adaptive Differential Evolution with Novel Mutation Strategies and Dynamic Parameter Adjustment.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {}, "mutation_prompt": null}
{"id": "d98cd787-0ea0-49f0-aae9-3225a4af6f32", "solution": "import numpy as np\n\nclass HybridADES_Memory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.memory_size = 10\n        self.fitness_memory = []\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        if len(self.fitness_memory) >= self.memory_size:\n            self.fitness_memory.pop(0)\n        self.fitness_memory.append(fitness)\n        return fitness\n\n    def adapt_params(self):\n        if len(self.fitness_memory) >= self.memory_size and np.std(self.fitness_memory) < 1e-5:\n            self.F = np.clip(self.F * (1.0 + np.random.uniform(-0.1, 0.1)), 0.1, 1.0)\n            self.CR = np.clip(self.CR * (1.0 + np.random.uniform(-0.1, 0.1)), 0.1, 0.9)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "HybridADES_Memory", "description": "Hybrid Adaptive Differential Evolution with Memory-based Strategy Selection for Robust Optimization.", "configspace": "", "generation": 16, "fitness": 0.2481583948878405, "feedback": "The algorithm HybridADES_Memory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.71799408251532, 0.6855281108464668, 0.8284392421068872, 0.7440570439243339, 0.6880857527019203, 0.6921099069786308, 0.29803138765545856, 0.2921858092141588, 0.2707575770799596, 9.999999999998899e-05, 0.5250393020144292, 0.6729787513710626, 9.999999999998899e-05, 0.5422763119781789, 0.15094621782684248, 0.5225239333348963, 0.5377372072525137, 0.6336078682331334, 0.0565521313962396, 0.0874779701311269, 0.11394139240903389, 0.09063660640218985, 0.10444510292232645, 0.11648651802696264, 0.0931761928524375, 0.09077546129201763, 0.05131398314242874, 0.05593606206764923, 0.08262960703265687, 0.11346410044122879, 0.057461531690531364, 0.10508598805377001, 0.11594679796374185, 0.0880698787620593, 0.0747548786974932, 0.12618252951090925, 0.8756699015401185, 0.8893862884989027, 0.626503034869129, 0.864577203375756, 0.8796170936826908, 0.8465925999064775, 0.780845543850287, 0.7890953287268208, 0.0925596036591182, 0.3733784351599494, 0.3935586090685993, 0.08524911664865198, 0.3718069591620561, 0.11388273360860024, 0.23333753682033398, 0.37243493338332145, 0.3569427532546271, 0.2821690422963661, 0.1612555233141606, 0.6732119185101904, 0.7046938777189118, 0.17633895017533774, 0.6601544180023322, 0.8382430102854954, 0.09289008682419919, 0.5739790419974562, 0.231033385222013, 0.05034908187285547, 0.025830979489989803, 0.03835252915446996, 0.08313751385701218, 0.052424928725893216, 0.18461203705238172, 0.05333088664157881, 0.3506641848442621, 0.17824797498333478, 0.06971880310210532, 0.046442780376550585, 0.2139214668262195, 0.06965798036253312, 0.045246734482950024, 0.16947189091814563, 0.05817924227155613, 0.04163739215956286, 0.33912307197887137, 0.2988555259674699, 0.2850620882637781, 0.1957806862280056, 0.30172887590480035, 0.2762880662334546, 0.06079715076251124, 0.004230996961204991, 0.2695422214330202, 0.0006089109909888091, 0.04524094173087234, 0.43414574867893696, 0.30168757124436074, 0.03459384085337536, 0.372044519841935, 0.3922074966126786, 0.08113613244216267, 0.4267268583851975, 0.5315013345746851, 9.999999999998899e-05, 0.07835264233581152, 0.20708573242709905, 9.999999999998899e-05, 0.10885165281896658, 0.13309151738600744, 0.07870526899409414, 0.08842293797636758, 0.08292974271110665, 0.03869432082653834, 0.23984226937647257, 0.18718148155401937, 0.026400416546441208, 0.2676127439885534, 0.2379414849661613, 0.24536432290764265, 0.22424970840998948, 0.19879724565484502, 0.24855134925733768, 0.6027181614140604, 0.7449831457456785, 0.6192650124767125, 0.5753741303930704, 0.5778843378550169, 0.31775642892346245, 0.2662824700237677, 0.631876653526807, 0.045338947842059274, 0.0844540508664472, 0.10876248978170311, 0.061706294350183044, 0.03867918347278099, 0.10609406855086068, 0.05399742200473212, 0.07186953705726318, 0.08041132824428765, 0.1434852119925183, 0.14104738457321508, 0.13435146644519214, 0.14488830732921687, 0.13784018412695076, 0.12485542690863405, 0.1271810395036055, 0.13909449539705454, 0.14351791939669833, 0.16243464094617743, 0.31830464671968595, 0.4424241623447268, 0.29269895463478257, 0.317167082793983, 0.445703770477063, 0.1867508297663928, 0.3198417527701819, 0.460629477138946, 0.12828008653041034, 0.24690370244963478, 0.34703336853982825, 0.24611231320372084, 0.22172733113112608, 0.38562134190285635, 0.14902134874297612, 0.26199248649715445, 0.30432588346088496, 0.17076429633163337, 0.1679682291697513, 0.18977813015059797, 0.16999837346041025, 0.1600634029675393, 0.18840738559224746, 0.16001339876081366, 0.13800282988145207, 0.195563032543146, 0.14725664265670002, 0.17100668052633283, 0.19896032505320593, 0.1420432321092261, 0.1377859807762084, 0.17794825227141386, 0.14947274771365082, 0.16522802896743616, 0.3373794038099992, 0.13618960859517992, 0.12256417628249561, 0.17864226003600725, 0.14250496344604746, 0.15524953646613682, 0.18770609058872767, 0.08879803886730331, 0.44120359791511576, 0.14890074117153496, 0.07027747980950627, 0.18998769663945336, 0.20283942380700515, 0.4102784163470111, 0.15332621772561228, 0.16431336777887973, 0.2106787136599937, 0.19352264257800889, 0.7620124227059573, 0.14717175565330032, 0.18999850080507152, 0.1832319297539643, 0.1554680993202725, 0.15673166305190867, 0.1944994396889902, 0.17964348346925474, 0.17561535362795389, 0.1800180983686238, 0.04670310743926587, 0.07283097151233231, 0.07287668459476349, 0.07589712405195281, 0.04832267890171338, 0.07025040972003793, 0.06859207277516399, 0.06550881887663162, 0.09048360701003133]}, "mutation_prompt": null}
{"id": "73ed089b-cd19-4413-8d8d-7dbeba9043ec", "solution": "import numpy as np\n\nclass HybridDE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 7 * dim)  # Slightly increased adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = np.random.uniform(0.4, 0.9)  # Dynamic scaling factor\n        self.CR = 0.8  # Reduced crossover rate\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.ones(3) / 3  # Initialized success rates to uniform distribution\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2_best, self.current_to_rand]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4 = np.random.choice(candidates, 4, replace=False)\n        return self.population[best_index] + self.F * (self.population[r1] - self.population[r2]) + self.F * (self.population[r3] - self.population[r4])\n\n    def current_to_rand(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        rand_idx = np.random.choice(self.pop_size)\n        return self.population[idx] + self.F * (self.population[rand_idx] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.9  # Adjust decay factor\n        return self.best_solution, self.best_fitness", "name": "HybridDE_Adaptive", "description": "Hybrid Differential Evolution with Adaptive Strategy Selection and Population Diversity Maintenance.", "configspace": "", "generation": 17, "fitness": 0.11505293666034973, "feedback": "The algorithm HybridDE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.15.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.16255445462166085, 0.2089584500257914, 0.256076375351466, 0.17375869704114089, 0.27543999111950257, 0.274057488093682, 0.1874074957098525, 0.1876661313995983, 0.19443512787611938, 0.0014085479738665807, 9.999999999998899e-05, 0.03805805571338716, 0.00010570315079894144, 0.012930107658784773, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07261631010328895, 0.05356985956742899, 0.04605142528753292, 0.03523703310958537, 0.05133753401466634, 0.04168523534762847, 0.05234993245402786, 0.05190227134732173, 0.051872035912800984, 0.028037819383796347, 0.03033165416826289, 0.03463237167185507, 0.04906372351305366, 0.032644325737611, 0.03203573109716196, 0.01688112674163944, 0.031217270915124162, 0.03523197382125731, 0.7445752221518016, 0.9523630275048353, 0.6399330727910248, 0.4343714703990048, 0.7430829640717902, 0.743167739751059, 0.9276210468800186, 0.8196905835213059, 0.7053583001316818, 0.07835815495118004, 0.08097199204748673, 0.08099167153058828, 0.02734385580567944, 0.07994899326241722, 0.06585587182813157, 0.06121501668122442, 0.11684308631574458, 0.07242313413625356, 0.10257474773393938, 0.08133114670504527, 0.12553534348584527, 0.12662283265724383, 0.1740140197266521, 0.13124228911885516, 0.10274830317590966, 0.11033577290783236, 0.12017893785333256, 0.006325723066277877, 0.024402767212461374, 0.009191667059812558, 0.018473780916819615, 0.04548927189491192, 0.0392427757133299, 0.007820980337540862, 0.050111706702806846, 0.03608875869931094, 0.03356371102139932, 0.032395339102900156, 0.03351894671208888, 0.009792836859316645, 0.09198858561831025, 0.04408661521240742, 0.0017695629571913285, 0.026726375009366365, 0.04519326358944531, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011536390854647416, 0.04724399759249376, 0.040759257797631676, 0.03509716291754028, 0.06851371605738554, 0.014070511125085394, 0.022317279555909786, 0.005273443877026107, 0.03988584875551715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015272433249170492, 0.0012403801392889546, 0.01799722427370909, 9.999999999998899e-05, 0.02239052789178586, 0.007977641983965111, 0.00356107813262041, 9.999999999998899e-05, 0.01114874478301442, 0.23061213982561335, 0.19630389435117368, 0.22165508207309126, 0.1670239207316827, 0.22443537146330805, 0.2328453186000654, 0.1977786941023092, 0.2181271462646056, 0.21201967806405708, 0.03278661992999099, 0.04530660450202484, 0.049329525230873306, 0.04222061116886311, 0.03399130946399542, 0.043765379853704545, 0.032973983129643614, 0.04618051413125901, 0.03697571833328184, 0.09035022443203, 0.10294069053883648, 0.1518752537546677, 0.0974106285467764, 0.10990511999388441, 0.10987115628089572, 0.10975062915966372, 0.09828302234056663, 0.10170570954043212, 0.14637181310198288, 0.17543938532980496, 0.16880603048833542, 0.15801202092943056, 0.16663265397983573, 0.16529012790958952, 0.15661230822094674, 0.15901831893983276, 0.1700883126996554, 0.09641682755565795, 0.11675255019128694, 0.09606619723949084, 0.09590786469713419, 0.13544810907146143, 0.11839958638476333, 0.10805429994845217, 0.10370411760544973, 0.11554553288098812, 0.15997840972022714, 0.13124351581405969, 0.16732665606777553, 0.13103215454838446, 0.14894167236726952, 0.17255855664389474, 0.13344554827987154, 0.14491991045816033, 0.17937531738333767, 0.15662393105022288, 0.148785349134253, 0.15252719435878792, 0.1228845550963319, 0.10126822104446165, 0.13125165858075794, 0.1567817409363894, 0.14607598625436458, 0.1299888078216037, 0.14213613939861602, 0.37449481810283913, 0.13663018233843927, 0.1275638603065974, 0.10872631876679084, 0.11365791218956145, 0.10023982512260698, 0.10017279620260611, 0.10224885593533817, 0.1532269877639052, 0.16715392678886598, 0.09182952068839445, 0.08660585527306597, 0.11155466105158962, 0.12406664094757947, 0.16923195822519865, 0.12886706130630377, 0.16044752849339983, 0.17862534366255733, 0.17332869602604728, 0.1558574397918555, 0.1648304309633999, 0.188547584241872, 0.17175886924079964, 0.17443312494891083, 0.15511574518586602, 0.16073522999671763, 0.04398294302862482, 0.05113433913620158, 0.0468783519271434, 0.0438564683370285, 0.056670281031481085, 0.050759515251127985, 0.060839988075674256, 0.04740939342509243, 0.04634056311807977]}, "mutation_prompt": null}
{"id": "0c485956-5127-448a-a98a-3a54b04a178f", "solution": "import numpy as np\n\nclass DES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95  # Adjust decay factor\n        return self.best_solution, self.best_fitness", "name": "DES3D_Adaptive", "description": "Adaptive Differential Evolution with Dynamic Population Size and Strategy Adaptation.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.7191171814890431, 0.6853737228883547, 0.8310903990671489, 0.7358915068430041, 0.6894134061139792, 0.6870897314767539, 0.29803138765545856, 0.2921858092141588, 0.2707575770799596, 9.999999999998899e-05, 0.5212169331829446, 0.6706607056182736, 9.999999999998899e-05, 0.538989137439963, 0.15094621782684248, 0.5202166923625464, 0.5350631063776288, 0.6354279931041238, 0.0565521313962396, 0.0874779701311269, 0.11394139240903389, 0.09063660640218985, 0.10444510292232645, 0.11648651802696264, 0.0931761928524375, 0.09077546129201763, 0.05131398314242874, 0.05593606206764923, 0.08262960703265687, 0.11346410044122879, 0.057461531690531364, 0.10508598805377001, 0.11594679796374185, 0.0880698787620593, 0.0747548786974932, 0.12618252951090925, 0.8756699015401185, 0.8893862884989027, 0.6273329958484906, 0.864577203375756, 0.8796170936826908, 0.8465925999064775, 0.780845543850287, 0.7890953287268208, 0.0925596036591182, 0.3733784351599494, 0.3935586090685993, 0.08524911664865198, 0.3718069591620561, 0.11388273360860024, 0.23333753682033398, 0.37243493338332145, 0.3569427532546271, 0.2821690422963661, 0.1612555233141606, 0.6732119185101904, 0.7046938777189118, 0.17633895017533774, 0.6601544180023322, 0.8382430102854954, 0.09289008682419919, 0.5739790419974562, 0.231033385222013, 0.05034908187285547, 0.025830979489989803, 0.03835252915446996, 0.08313751385701218, 0.052424928725893216, 0.18461203705238172, 0.05333088664157881, 0.3500733844815186, 0.17824797498333478, 0.06971880310210532, 0.046442780376550585, 0.2139214668262195, 0.06965798036253312, 0.045246734482950024, 0.16947189091814563, 0.05817924227155613, 0.04163739215956286, 0.33907425743485253, 0.2988555259674699, 0.2850620882637781, 0.1957806862280056, 0.30172887590480035, 0.2762880662334546, 0.06079715076251124, 0.004230996961204991, 0.2695422214330202, 0.0006089109909888091, 0.04524094173087234, 0.43414707731159163, 0.3016758901991854, 0.03459384085337536, 0.3720326697193098, 0.3922753461225432, 0.08113613244216267, 0.42869982773794657, 0.5315415803312192, 9.999999999998899e-05, 0.07835264233581152, 0.20708573242709905, 9.999999999998899e-05, 0.10885165281896658, 0.13309151738600744, 0.07870526899409414, 0.08842293797636758, 0.08292974271110665, 0.03869432082653834, 0.23984226937647257, 0.18718148155401937, 0.026400416546441208, 0.2676127439885534, 0.2379414849661613, 0.24536432290764265, 0.22424970840998948, 0.19879724565484502, 0.24855134925733768, 0.5991907952581617, 0.7455890990645102, 0.6276962720986039, 0.5774970738931969, 0.5769345362066165, 0.31775642892346245, 0.2662824700237677, 0.6415078473076792, 0.045338947842059274, 0.0844540508664472, 0.10876248978170311, 0.061706294350183044, 0.03867918347278099, 0.10609406855086068, 0.05399742200473212, 0.07186953705726318, 0.08041132824428765, 0.1434852119925183, 0.14104738457321508, 0.13435146644519214, 0.14488830732921687, 0.13784018412695076, 0.12485542690863405, 0.1271810395036055, 0.13909449539705454, 0.14351791939669833, 0.16243464094617743, 0.31830464671968595, 0.44160309102151474, 0.29269895463478257, 0.317167082793983, 0.4482019264531448, 0.1867508297663928, 0.3198417527701819, 0.4647584078803024, 0.12828008653041034, 0.24690370244963478, 0.34703336853982825, 0.24611231320372084, 0.22172733113112608, 0.38562134190285635, 0.14902134874297612, 0.26199248649715445, 0.30432588346088496, 0.17076429633163337, 0.1679682291697513, 0.18977813015059797, 0.16999837346041025, 0.1600634029675393, 0.18840738559224746, 0.16001339876081366, 0.13800282988145207, 0.195563032543146, 0.14725664265670002, 0.17100668052633283, 0.1989603253472465, 0.1420432321092261, 0.1377859807762084, 0.17794825227141386, 0.14947274771365082, 0.16522802896743616, 0.335323506249266, 0.13618960859517992, 0.12256417628249561, 0.17864226011495288, 0.14250496344604746, 0.15524953646613682, 0.18770609018922157, 0.08879803886730331, 0.44420041854838777, 0.14890074117153496, 0.07027747980950627, 0.1899876960744754, 0.20283941840002528, 0.4063203294270932, 0.15332621784734368, 0.16431336776361183, 0.21067871488437018, 0.19352264373901573, 0.7652344205712905, 0.14717175565330032, 0.18999850080507152, 0.1832319297539643, 0.1554680993202725, 0.1567249844987838, 0.1944994396889902, 0.17964348346925474, 0.17561535362795389, 0.1800180983686238, 0.04670310743926587, 0.07283097151233231, 0.07287668459476349, 0.07589712405195281, 0.04832267890171338, 0.07025040972003793, 0.06859207277516399, 0.06550881887663162, 0.09048360701003133]}, "mutation_prompt": null}
{"id": "e99ec5ec-2b21-45d2-8024-2d7d4b287317", "solution": "import numpy as np\n\nclass Improved_DES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.8  # Fine-tuned crossover rate\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.success_rates = np.ones(3) * 0.1  # Initialize with non-zero success rates to avoid division by zero\n        self.func = None\n\n    def select_strategy(self):\n        probabilities = self.success_rates / np.sum(self.success_rates)\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 0.1  # Increment success rate more aggressively\n                else:\n                    self.success_rates[strat_index] *= 0.9  # Decay factor adjustment\n        return self.best_solution, self.best_fitness", "name": "Improved_DES3D_Adaptive", "description": "Improved Adaptive Differential Evolution with Dynamic Strategy Allocation based on Historical Performance.", "configspace": "", "generation": 19, "fitness": 0.12242747576042577, "feedback": "The algorithm Improved_DES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.30562173708450346, 0.3089139557038658, 0.2585669436058634, 0.3151588279712638, 0.3130422484765094, 0.26021424103281343, 0.2849113739592498, 0.28103331540003906, 0.2775161082392077, 0.026560368017210956, 0.07756023360490782, 9.999999999998899e-05, 0.02057909028977556, 0.04553279553212852, 0.013504185253867762, 0.015176789343066543, 0.03711842487891026, 0.015675767018444642, 0.0707130837022183, 0.07276231388670873, 0.05699931476589626, 0.061450585073042574, 0.07083009930693118, 0.06881230733509436, 0.059509291994984004, 0.08494432970851251, 0.04491050577914357, 0.06158222151281478, 0.04361738429321904, 0.053303680400510034, 0.05327276910604706, 0.05496216303924939, 0.04655092951258999, 0.04004655036064142, 0.051052644793825874, 0.04708367547973591, 0.20917216993100374, 0.24544261221759234, 0.37266660346059455, 0.16939155858166544, 0.33817418141405897, 0.15428541182774602, 0.16709528310219435, 0.9570895915141288, 0.10822302684421425, 0.12440203869634203, 0.12310989794085891, 0.09596352800013042, 0.11895848313798851, 0.12346413864212735, 0.14766779148213793, 0.1579101181001732, 0.10576150629191439, 0.1453170182819813, 0.18512326498421128, 0.20031441727886345, 0.2319166482499454, 0.17748715972976903, 0.1798089764435361, 0.1964341889939044, 0.17280362371042224, 0.2086928787452389, 0.1514928684668626, 0.0402840255262501, 0.04081238659341324, 0.060855891890155944, 0.05324624160738334, 0.10604722564563218, 0.010765059660364895, 0.059209566406580594, 0.07788389969983522, 0.10312573729292418, 0.07194317974335918, 0.07861042026074205, 0.05330243730136297, 0.06874193184041744, 0.04918183967371148, 0.07987638830320953, 0.04835678910913066, 0.06608413863990303, 0.08360593005962913, 0.0031058845958811254, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011746425006758932, 9.999999999998899e-05, 0.004131844081168623, 9.999999999998899e-05, 0.006751404925574023, 0.0044341102870475435, 0.11249792424466543, 0.09344521095871605, 0.10448426772657149, 0.07208026245136989, 0.01577189531354417, 0.09312457348392511, 0.09693425895573005, 0.038949923502999306, 0.03821485283727255, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04645916548289819, 0.03790573302414957, 0.042525336905855915, 0.026803610910087317, 0.016027512649400832, 0.03785396779475847, 0.03461110903231768, 0.05829869544641064, 0.009580397731898671, 0.27601571751944687, 0.2691286736238566, 0.2757385013631206, 0.2796118423961057, 0.31116088574054057, 0.2862863021658595, 0.31238534932107576, 0.2651663785494067, 0.3040176630201116, 0.04941793646910386, 0.057153178044578645, 0.03930743017831295, 0.056235823646199834, 0.05770181927761531, 0.052009611424673086, 0.05205205013043801, 0.05960880182505257, 0.059896819469603124, 0.1148389013552078, 0.12156925250435857, 0.11072777161485103, 0.12707834581805777, 0.12596562191162752, 0.10448668343394585, 0.10243917224352284, 0.13185401614250714, 0.1328327555463784, 0.17635941364083918, 0.18935434264079976, 0.20376322179418416, 0.19760186188634943, 0.18443222987561214, 0.20366559829670527, 0.19689303062836738, 0.21226926133982715, 0.21724347646540276, 0.14545431691490518, 0.12634889395881022, 0.1215287893328506, 0.15385488420604065, 0.13600369765495068, 0.14004871125844087, 0.1271731137733847, 0.14010607446365375, 0.12480559138247826, 0.1502100050633659, 0.16221788419118854, 0.16712505680470913, 0.16151633179573888, 0.16353173091739281, 0.17580620519003876, 0.14594464668407914, 0.17301345679747615, 0.1499292066098138, 0.14246318824397863, 0.14797676723760955, 0.13068777425101274, 0.16132523078077887, 0.13206378203677382, 0.13690342513528775, 0.1498168823151269, 0.13528963779112002, 0.160083575739271, 0.13865078006562725, 0.12214432162589905, 0.2623239742574027, 0.14220772160184547, 0.14493339337480715, 0.15076392724916954, 0.1599675955130211, 0.13391110228294678, 0.1947459805648889, 0.23471890290724384, 0.14667283281175825, 0.2324640076403104, 0.17212420904795922, 0.13822449398390058, 0.12514596225710195, 0.17128637570358063, 0.1732192220132741, 0.1666993663167019, 0.16510061673523446, 0.16046453563038776, 0.1635747484803287, 0.15251170487733579, 0.16330490136411846, 0.16484652877177208, 0.1747860455971042, 0.14738705141001007, 0.16176380986933547, 0.04500104927591042, 0.060250298849719, 0.05124210871077717, 0.06388445702159629, 0.07013763281630658, 0.04863088284794648, 0.05190244521643961, 0.04903909391579386, 0.04704516618116561]}, "mutation_prompt": null}
{"id": "a7c10c15-6582-487f-8614-d56f54dff4b5", "solution": "import numpy as np\n\nclass EADES3D_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 7 * dim)  # Slightly larger adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.feedback_control = np.zeros(self.pop_size)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.best_2]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def best_2(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[best_index] + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution, idx):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        self.feedback_control[idx] = fitness\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial, i)\n                target_fitness = self.evaluate(target, i)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n                if self.feedback_control[i] < 0.1 * self.best_fitness:\n                    self.F = min(1, self.F + 0.1)\n                else:\n                    self.F = max(0.4, self.F - 0.05)\n        return self.best_solution, self.best_fitness", "name": "EADES3D_Refined", "description": "Enhanced Adaptive Differential Evolution with Feedback Control and Strategy Refinement.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {}, "mutation_prompt": null}
{"id": "2eebcc18-8574-4e42-9ccd-c74b407a29b9", "solution": "import numpy as np\n\nclass DES3D_Adaptive_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6  # Slightly increased for exploration\n        self.CR = 0.85  # Adjusted for more exploration\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.strategy_weights = np.ones(3) / 3\n\n    def select_strategy(self):\n        if np.sum(self.success_rates) > 0:\n            self.strategy_weights = self.success_rates / np.sum(self.success_rates)\n        return np.random.choice(3, p=self.strategy_weights)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.90  # Adjust decay factor\n        return self.best_solution, self.best_fitness", "name": "DES3D_Adaptive_Enhanced", "description": "Adaptive Differential Evolution with Enhanced Mutation Strategies and Success-Based Adaptation.", "configspace": "", "generation": 21, "fitness": 0.2241348378353377, "feedback": "The algorithm DES3D_Adaptive_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.24341431973383054, 0.6129419987551663, 0.7703991091961863, 0.6309971134740822, 0.6341809935294749, 0.5924574436653411, 0.2980143578975625, 0.262945955504141, 0.23194097259843094, 0.0015517189176421642, 0.3353378529067569, 0.6461202464271001, 0.00030904239818629886, 0.37140857304873465, 0.6025491839830405, 9.999999999998899e-05, 0.3186859220838606, 0.6258601707417197, 0.05030644247352578, 0.09887035756573181, 0.10236605899985496, 0.094408992183585, 0.09735429867452206, 0.1066229282673663, 0.09042918711882408, 0.09069277616053628, 0.053992041344596564, 0.051447108272407394, 0.08840412400284581, 0.1167205363995032, 0.045631832269498185, 0.08154081364186405, 0.09472775782679033, 0.0851201703392952, 0.07383453964109699, 0.09901883393810973, 0.945790237567472, 0.9448445982529642, 0.8832518619782863, 0.9692950921855564, 0.8969522686501548, 0.8116741317917531, 0.8505462386547813, 0.8321137625625769, 0.37023806537988246, 0.09025804168125773, 0.22731820278401094, 0.10078504497591345, 0.2699409056224704, 0.10205919321572543, 0.3976033976416392, 0.26919477475796294, 0.28777086610137736, 0.4288805858796705, 0.1772503636777112, 0.3230269623182733, 0.487518394342054, 0.17881400396517388, 0.4831748038300856, 0.7337725653090112, 0.15319752102542228, 0.5238834411762592, 0.7787186883503787, 0.07545904145358995, 0.05179220845803445, 0.02214904026144282, 0.028821769147826082, 0.046810707029826704, 0.21590793741035053, 0.07542121524530043, 0.12901109315430204, 0.2652953870239526, 0.06616895486410845, 0.04529005196195535, 0.2696443624561633, 0.06046216706727514, 0.04371166576332508, 0.16789213958920468, 0.045747556066874084, 0.015771921564006863, 0.2519393880345907, 0.1902875608689325, 0.10617363106315147, 0.25942457898308524, 0.10382980707905753, 0.11168429487797182, 0.3132487271256654, 9.999999999998899e-05, 0.07587208810841062, 9.999999999998899e-05, 0.09038085874437363, 0.2382396915043612, 0.4423865300083598, 0.04701899269813725, 0.19890923863997245, 0.18645350111446435, 0.019593346456692085, 0.2347678567052891, 0.4716395291839637, 9.999999999998899e-05, 0.019212437169227492, 0.13165655449971514, 9.999999999998899e-05, 0.017415629054157722, 0.13278784428133317, 0.00012419444274258673, 0.03245021084662281, 0.087946178878052, 0.01502138986356627, 0.13156191832286146, 0.23267446342696618, 0.02448377341261332, 0.12751016883190336, 0.26181126511336883, 0.11182059534947386, 0.13669913075008366, 0.2424787830202223, 0.2884468261930363, 0.4281349967765483, 0.6697506345322723, 0.4424636364238639, 0.484602424862148, 0.6432224368315189, 0.26157605968112485, 0.2383526314793537, 0.657960669332886, 0.07634998373387658, 0.0752318190509581, 0.10076372336913664, 0.06479552814698342, 0.03540158916664693, 0.08839530558934439, 0.045396499945602575, 0.0463150968032785, 0.05771497107723522, 0.11216539791460312, 0.08314104473508466, 0.160791716270404, 0.12444496898782564, 0.1753459048602617, 0.13951269852127957, 0.11308077015761808, 0.11943240376034647, 0.11590445714314379, 0.1913813474048297, 0.23410078885425512, 0.3185722516587891, 0.2791253589319659, 0.2358265178055512, 0.4105403929759309, 0.16335563868693392, 0.2982709460640619, 0.3899658591216705, 0.12017415404142906, 0.1607618193722954, 0.26027194892681615, 0.17812794276499921, 0.16634280133048274, 0.27299697351502183, 0.12379755316329266, 0.18444582644561802, 0.26025732107530775, 0.1470357607214935, 0.19894563703210588, 0.19226831812733358, 0.170988628136317, 0.15625407123315926, 0.1896584154654306, 0.1617951643177843, 0.15578568483132404, 0.18258110111925197, 0.14416432299055648, 0.17717824462603604, 0.28873607326161577, 0.14100588616489274, 0.1520654492907202, 0.1709788596443501, 0.17109169192324825, 0.16818062818433832, 0.1946387508631735, 0.14356782234091137, 0.11535410527060252, 0.16406164832280268, 0.14070604868467596, 0.170722702661406, 0.17050177963839597, 0.10233433284199578, 0.37573921457608084, 0.20644074148875613, 0.11949497564424505, 0.15562471985524007, 0.41350019584109443, 0.14947595832385252, 0.17009995959802438, 0.655068784557642, 0.20184902682536632, 0.48828874334158423, 0.19015719484359084, 0.174146631641087, 0.1636163890498996, 0.18781392478622305, 0.1407480032316576, 0.17582107996958385, 0.17689769120831045, 0.17788215679431163, 0.19180529552248382, 0.18718954881171435, 0.04584694812201928, 0.06133460611431785, 0.09785957903576603, 0.06447781938880504, 0.046266977243862084, 0.059308721744197324, 0.05645390951760021, 0.041431274172109456, 0.07903497136799031]}, "mutation_prompt": null}
{"id": "858ad547-b8d7-41e7-8fb7-3f74c27d2e27", "solution": "import numpy as np\n\nclass DES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95  # Adjust decay factor\n        return self.best_solution, self.best_fitness", "name": "DES3D_Adaptive", "description": "Adaptive Differential Evolution with Dynamic Population Size and Strategy Adaptation.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.7191171814890431, 0.6853737228883547, 0.8310903990671489, 0.7358915068430041, 0.6894134061139792, 0.6870897314767539, 0.29803138765545856, 0.2921858092141588, 0.2707575770799596, 9.999999999998899e-05, 0.5212169331829446, 0.6706607056182736, 9.999999999998899e-05, 0.538989137439963, 0.15094621782684248, 0.5202166923625464, 0.5350631063776288, 0.6354279931041238, 0.0565521313962396, 0.0874779701311269, 0.11394139240903389, 0.09063660640218985, 0.10444510292232645, 0.11648651802696264, 0.0931761928524375, 0.09077546129201763, 0.05131398314242874, 0.05593606206764923, 0.08262960703265687, 0.11346410044122879, 0.057461531690531364, 0.10508598805377001, 0.11594679796374185, 0.0880698787620593, 0.0747548786974932, 0.12618252951090925, 0.8756699015401185, 0.8893862884989027, 0.6273329958484906, 0.864577203375756, 0.8796170936826908, 0.8465925999064775, 0.780845543850287, 0.7890953287268208, 0.0925596036591182, 0.3733784351599494, 0.3935586090685993, 0.08524911664865198, 0.3718069591620561, 0.11388273360860024, 0.23333753682033398, 0.37243493338332145, 0.3569427532546271, 0.2821690422963661, 0.1612555233141606, 0.6732119185101904, 0.7046938777189118, 0.17633895017533774, 0.6601544180023322, 0.8382430102854954, 0.09289008682419919, 0.5739790419974562, 0.231033385222013, 0.05034908187285547, 0.025830979489989803, 0.03835252915446996, 0.08313751385701218, 0.052424928725893216, 0.18461203705238172, 0.05333088664157881, 0.3500733844815186, 0.17824797498333478, 0.06971880310210532, 0.046442780376550585, 0.2139214668262195, 0.06965798036253312, 0.045246734482950024, 0.16947189091814563, 0.05817924227155613, 0.04163739215956286, 0.33907425743485253, 0.2988555259674699, 0.2850620882637781, 0.1957806862280056, 0.30172887590480035, 0.2762880662334546, 0.06079715076251124, 0.004230996961204991, 0.2695422214330202, 0.0006089109909888091, 0.04524094173087234, 0.43414707731159163, 0.3016758901991854, 0.03459384085337536, 0.3720326697193098, 0.3922753461225432, 0.08113613244216267, 0.42869982773794657, 0.5315415803312192, 9.999999999998899e-05, 0.07835264233581152, 0.20708573242709905, 9.999999999998899e-05, 0.10885165281896658, 0.13309151738600744, 0.07870526899409414, 0.08842293797636758, 0.08292974271110665, 0.03869432082653834, 0.23984226937647257, 0.18718148155401937, 0.026400416546441208, 0.2676127439885534, 0.2379414849661613, 0.24536432290764265, 0.22424970840998948, 0.19879724565484502, 0.24855134925733768, 0.5991907952581617, 0.7455890990645102, 0.6276962720986039, 0.5774970738931969, 0.5769345362066165, 0.31775642892346245, 0.2662824700237677, 0.6415078473076792, 0.045338947842059274, 0.0844540508664472, 0.10876248978170311, 0.061706294350183044, 0.03867918347278099, 0.10609406855086068, 0.05399742200473212, 0.07186953705726318, 0.08041132824428765, 0.1434852119925183, 0.14104738457321508, 0.13435146644519214, 0.14488830732921687, 0.13784018412695076, 0.12485542690863405, 0.1271810395036055, 0.13909449539705454, 0.14351791939669833, 0.16243464094617743, 0.31830464671968595, 0.44160309102151474, 0.29269895463478257, 0.317167082793983, 0.4482019264531448, 0.1867508297663928, 0.3198417527701819, 0.4647584078803024, 0.12828008653041034, 0.24690370244963478, 0.34703336853982825, 0.24611231320372084, 0.22172733113112608, 0.38562134190285635, 0.14902134874297612, 0.26199248649715445, 0.30432588346088496, 0.17076429633163337, 0.1679682291697513, 0.18977813015059797, 0.16999837346041025, 0.1600634029675393, 0.18840738559224746, 0.16001339876081366, 0.13800282988145207, 0.195563032543146, 0.14725664265670002, 0.17100668052633283, 0.1989603253472465, 0.1420432321092261, 0.1377859807762084, 0.17794825227141386, 0.14947274771365082, 0.16522802896743616, 0.335323506249266, 0.13618960859517992, 0.12256417628249561, 0.17864226011495288, 0.14250496344604746, 0.15524953646613682, 0.18770609018922157, 0.08879803886730331, 0.44420041854838777, 0.14890074117153496, 0.07027747980950627, 0.1899876960744754, 0.20283941840002528, 0.4063203294270932, 0.15332621784734368, 0.16431336776361183, 0.21067871488437018, 0.19352264373901573, 0.7652344205712905, 0.14717175565330032, 0.18999850080507152, 0.1832319297539643, 0.1554680993202725, 0.1567249844987838, 0.1944994396889902, 0.17964348346925474, 0.17561535362795389, 0.1800180983686238, 0.04670310743926587, 0.07283097151233231, 0.07287668459476349, 0.07589712405195281, 0.04832267890171338, 0.07025040972003793, 0.06859207277516399, 0.06550881887663162, 0.09048360701003133]}, "mutation_prompt": null}
{"id": "3762fe10-35eb-4e5d-90fc-857b1e48e7bf", "solution": "import numpy as np\n\nclass EnhancedDES3D:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(20, 7 * dim)  # Increased population size for more diversity\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6  # Slightly higher mutation factor for exploration\n        self.CR = 0.8  # Slightly lower crossover rate for more exploitation\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.ones(3)  # Start with a non-zero success rate\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 0.1  # Slightly increase the success rate gain\n                else:\n                    self.success_rates[strat_index] *= 0.9  # Increase decay factor for faster adaptation\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D", "description": "Enhanced Differential Evolution with Improved Strategy Selection and Feedback Mechanisms.", "configspace": "", "generation": 23, "fitness": 0.09698565332090718, "feedback": "The algorithm EnhancedDES3D got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.10.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.21136354090401288, 0.20408511405711172, 0.21344068246446102, 0.1961631675676364, 0.1910999368656735, 0.22121298384173582, 0.2024487486491675, 0.18639877853311382, 0.18829501048357267, 9.999999999998899e-05, 0.0005798904073140987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050568010192523216, 0.05192172345373425, 0.05668295122322686, 0.04629487986939862, 0.05048799770743717, 0.04737760478518738, 0.055690316274706886, 0.03540364417676789, 0.05033738619806849, 0.03526237077530092, 0.025203268477546947, 0.026475025457606716, 0.044191412021721055, 0.03754896083084658, 0.024281875543268105, 0.024920006751427137, 0.02921991362344556, 0.028797954337587917, 0.45630637712309996, 0.11881071374827079, 0.5017969333653651, 0.38182812511054587, 0.16787436128442945, 0.1773264739028957, 0.2845468683413871, 0.6538967404478673, 0.7209068574359976, 0.07736887774961143, 0.07150680758824146, 0.05852177889512822, 0.08645278042495064, 0.0825041346258546, 0.07458806908223248, 0.09343188664455648, 0.05998993619419579, 0.07476187450882421, 0.13852979926121245, 0.17984663443718163, 0.10783903816287765, 0.16590647280540505, 0.12064588637777995, 0.1183461012033038, 0.12236059071112249, 0.14998687564054014, 0.15639275490967397, 0.03775583324324672, 0.0014002886757638056, 0.01433154411687576, 0.006782415815010268, 0.03710331073832185, 0.024548122594717836, 0.026141655541869424, 0.020091182958080545, 0.027400812500917526, 0.017755065503101464, 0.014054250119778011, 0.01880012784930951, 0.021636861832227128, 0.032154123506515475, 0.017662814279822858, 0.035212361815433746, 9.999999999998899e-05, 0.030291521685788747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005394101103615156, 0.030026846341252744, 0.023263235325285847, 0.006882565234485605, 0.003642712416635163, 0.015046793168445594, 0.012716443076220996, 0.024471590658321607, 0.02421761581310855, 0.030162629496933935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00819623518287349, 0.006985336980457779, 0.006347193872763945, 0.003778763842097743, 9.999999999998899e-05, 0.011970260053164039, 0.01427971384850879, 0.007823653588278412, 0.00892166779030723, 0.19519872970184848, 0.20244021411087598, 0.2237641520255642, 0.19523608707653684, 0.21450710819495578, 0.19303130446880323, 0.21259344040912653, 0.21003174105294664, 0.20926379290728048, 0.04350473825759782, 0.0494036659612086, 0.041247690369142775, 0.04532959351917676, 0.027396900155502224, 0.05395629163008997, 0.039961153560860496, 0.04636157518785, 0.04446260267995694, 0.08959309098717216, 0.11927284433511376, 0.10204815349634844, 0.10466566146859457, 0.1239066470236887, 0.12949236607013848, 0.09311413747053143, 0.13710079363974326, 0.11120339055501338, 0.13775995452269285, 0.14748662358852893, 0.15284878310393601, 0.16368164406308172, 0.1592119809228305, 0.18374424553116164, 0.16581196351694216, 0.18469891714342135, 0.14651006892644403, 0.13758492054637084, 0.1251626786495843, 0.09957648174549794, 0.11149210750792082, 0.110918636597508, 0.09871035704965125, 0.09529204156035864, 0.12424036497259583, 0.10806612732938725, 0.14951730428932264, 0.1464750570079294, 0.1410522655406361, 0.16718987900620308, 0.12458149875500679, 0.1282003177302582, 0.17363956376995793, 0.156155245623934, 0.14981088950095578, 0.12125851783915331, 0.12269642583559415, 0.14787440788651984, 0.13436397735444805, 0.141807365675377, 0.13147683647639075, 0.12048711005806889, 0.14291895786057118, 0.08916747319370355, 0.28107374022808074, 0.10012700765934535, 0.11988197163036762, 0.14897990649996407, 0.12567350784811515, 0.12955450832034765, 0.1133582817563471, 0.118943649430713, 0.12859449333953832, 0.14334091177020525, 0.11592359060705548, 0.08179195770746306, 0.09907491211974684, 0.09672046598212058, 0.1091047314222987, 0.14557125290846562, 0.15050513754824502, 0.1727643221350611, 0.15026628838731326, 0.1434999566876617, 0.1608472854389552, 0.1560542102915955, 0.1537279772638942, 0.14964464199945782, 0.1536947123672573, 0.15975532455145824, 0.17028905970775576, 0.05802298001203654, 0.04410710738729917, 0.04667780356312723, 0.0476596370795529, 0.040913991726054366, 0.04119284330158479, 0.03943410362357258, 0.03434588803103378, 0.05510223495281241]}, "mutation_prompt": null}
{"id": "4bd742bf-21b5-42d0-88e3-8035d67324dd", "solution": "import numpy as np\n\nclass DES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95  # Adjust decay factor\n        return self.best_solution, self.best_fitness", "name": "DES3D_Adaptive", "description": "Adaptive Differential Evolution with Dynamic Population Size and Strategy Adaptation.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.7191171814890431, 0.6853737228883547, 0.8310903990671489, 0.7358915068430041, 0.6894134061139792, 0.6870897314767539, 0.29803138765545856, 0.2921858092141588, 0.2707575770799596, 9.999999999998899e-05, 0.5212169331829446, 0.6706607056182736, 9.999999999998899e-05, 0.538989137439963, 0.15094621782684248, 0.5202166923625464, 0.5350631063776288, 0.6354279931041238, 0.0565521313962396, 0.0874779701311269, 0.11394139240903389, 0.09063660640218985, 0.10444510292232645, 0.11648651802696264, 0.0931761928524375, 0.09077546129201763, 0.05131398314242874, 0.05593606206764923, 0.08262960703265687, 0.11346410044122879, 0.057461531690531364, 0.10508598805377001, 0.11594679796374185, 0.0880698787620593, 0.0747548786974932, 0.12618252951090925, 0.8756699015401185, 0.8893862884989027, 0.6273329958484906, 0.864577203375756, 0.8796170936826908, 0.8465925999064775, 0.780845543850287, 0.7890953287268208, 0.0925596036591182, 0.3733784351599494, 0.3935586090685993, 0.08524911664865198, 0.3718069591620561, 0.11388273360860024, 0.23333753682033398, 0.37243493338332145, 0.3569427532546271, 0.2821690422963661, 0.1612555233141606, 0.6732119185101904, 0.7046938777189118, 0.17633895017533774, 0.6601544180023322, 0.8382430102854954, 0.09289008682419919, 0.5739790419974562, 0.231033385222013, 0.05034908187285547, 0.025830979489989803, 0.03835252915446996, 0.08313751385701218, 0.052424928725893216, 0.18461203705238172, 0.05333088664157881, 0.3500733844815186, 0.17824797498333478, 0.06971880310210532, 0.046442780376550585, 0.2139214668262195, 0.06965798036253312, 0.045246734482950024, 0.16947189091814563, 0.05817924227155613, 0.04163739215956286, 0.33907425743485253, 0.2988555259674699, 0.2850620882637781, 0.1957806862280056, 0.30172887590480035, 0.2762880662334546, 0.06079715076251124, 0.004230996961204991, 0.2695422214330202, 0.0006089109909888091, 0.04524094173087234, 0.43414707731159163, 0.3016758901991854, 0.03459384085337536, 0.3720326697193098, 0.3922753461225432, 0.08113613244216267, 0.42869982773794657, 0.5315415803312192, 9.999999999998899e-05, 0.07835264233581152, 0.20708573242709905, 9.999999999998899e-05, 0.10885165281896658, 0.13309151738600744, 0.07870526899409414, 0.08842293797636758, 0.08292974271110665, 0.03869432082653834, 0.23984226937647257, 0.18718148155401937, 0.026400416546441208, 0.2676127439885534, 0.2379414849661613, 0.24536432290764265, 0.22424970840998948, 0.19879724565484502, 0.24855134925733768, 0.5991907952581617, 0.7455890990645102, 0.6276962720986039, 0.5774970738931969, 0.5769345362066165, 0.31775642892346245, 0.2662824700237677, 0.6415078473076792, 0.045338947842059274, 0.0844540508664472, 0.10876248978170311, 0.061706294350183044, 0.03867918347278099, 0.10609406855086068, 0.05399742200473212, 0.07186953705726318, 0.08041132824428765, 0.1434852119925183, 0.14104738457321508, 0.13435146644519214, 0.14488830732921687, 0.13784018412695076, 0.12485542690863405, 0.1271810395036055, 0.13909449539705454, 0.14351791939669833, 0.16243464094617743, 0.31830464671968595, 0.44160309102151474, 0.29269895463478257, 0.317167082793983, 0.4482019264531448, 0.1867508297663928, 0.3198417527701819, 0.4647584078803024, 0.12828008653041034, 0.24690370244963478, 0.34703336853982825, 0.24611231320372084, 0.22172733113112608, 0.38562134190285635, 0.14902134874297612, 0.26199248649715445, 0.30432588346088496, 0.17076429633163337, 0.1679682291697513, 0.18977813015059797, 0.16999837346041025, 0.1600634029675393, 0.18840738559224746, 0.16001339876081366, 0.13800282988145207, 0.195563032543146, 0.14725664265670002, 0.17100668052633283, 0.1989603253472465, 0.1420432321092261, 0.1377859807762084, 0.17794825227141386, 0.14947274771365082, 0.16522802896743616, 0.335323506249266, 0.13618960859517992, 0.12256417628249561, 0.17864226011495288, 0.14250496344604746, 0.15524953646613682, 0.18770609018922157, 0.08879803886730331, 0.44420041854838777, 0.14890074117153496, 0.07027747980950627, 0.1899876960744754, 0.20283941840002528, 0.4063203294270932, 0.15332621784734368, 0.16431336776361183, 0.21067871488437018, 0.19352264373901573, 0.7652344205712905, 0.14717175565330032, 0.18999850080507152, 0.1832319297539643, 0.1554680993202725, 0.1567249844987838, 0.1944994396889902, 0.17964348346925474, 0.17561535362795389, 0.1800180983686238, 0.04670310743926587, 0.07283097151233231, 0.07287668459476349, 0.07589712405195281, 0.04832267890171338, 0.07025040972003793, 0.06859207277516399, 0.06550881887663162, 0.09048360701003133]}, "mutation_prompt": null}
{"id": "0d344663-0399-4fdf-bcad-27ca02745656", "solution": "import numpy as np\n\nclass DES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95  # Adjust decay factor\n        return self.best_solution, self.best_fitness", "name": "DES3D_Adaptive", "description": "Adaptive Differential Evolution with Dynamic Population Size and Strategy Adaptation.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.7191171814890431, 0.6853737228883547, 0.8310903990671489, 0.7358915068430041, 0.6894134061139792, 0.6870897314767539, 0.29803138765545856, 0.2921858092141588, 0.2707575770799596, 9.999999999998899e-05, 0.5212169331829446, 0.6706607056182736, 9.999999999998899e-05, 0.538989137439963, 0.15094621782684248, 0.5202166923625464, 0.5350631063776288, 0.6354279931041238, 0.0565521313962396, 0.0874779701311269, 0.11394139240903389, 0.09063660640218985, 0.10444510292232645, 0.11648651802696264, 0.0931761928524375, 0.09077546129201763, 0.05131398314242874, 0.05593606206764923, 0.08262960703265687, 0.11346410044122879, 0.057461531690531364, 0.10508598805377001, 0.11594679796374185, 0.0880698787620593, 0.0747548786974932, 0.12618252951090925, 0.8756699015401185, 0.8893862884989027, 0.6273329958484906, 0.864577203375756, 0.8796170936826908, 0.8465925999064775, 0.780845543850287, 0.7890953287268208, 0.0925596036591182, 0.3733784351599494, 0.3935586090685993, 0.08524911664865198, 0.3718069591620561, 0.11388273360860024, 0.23333753682033398, 0.37243493338332145, 0.3569427532546271, 0.2821690422963661, 0.1612555233141606, 0.6732119185101904, 0.7046938777189118, 0.17633895017533774, 0.6601544180023322, 0.8382430102854954, 0.09289008682419919, 0.5739790419974562, 0.231033385222013, 0.05034908187285547, 0.025830979489989803, 0.03835252915446996, 0.08313751385701218, 0.052424928725893216, 0.18461203705238172, 0.05333088664157881, 0.3500733844815186, 0.17824797498333478, 0.06971880310210532, 0.046442780376550585, 0.2139214668262195, 0.06965798036253312, 0.045246734482950024, 0.16947189091814563, 0.05817924227155613, 0.04163739215956286, 0.33907425743485253, 0.2988555259674699, 0.2850620882637781, 0.1957806862280056, 0.30172887590480035, 0.2762880662334546, 0.06079715076251124, 0.004230996961204991, 0.2695422214330202, 0.0006089109909888091, 0.04524094173087234, 0.43414707731159163, 0.3016758901991854, 0.03459384085337536, 0.3720326697193098, 0.3922753461225432, 0.08113613244216267, 0.42869982773794657, 0.5315415803312192, 9.999999999998899e-05, 0.07835264233581152, 0.20708573242709905, 9.999999999998899e-05, 0.10885165281896658, 0.13309151738600744, 0.07870526899409414, 0.08842293797636758, 0.08292974271110665, 0.03869432082653834, 0.23984226937647257, 0.18718148155401937, 0.026400416546441208, 0.2676127439885534, 0.2379414849661613, 0.24536432290764265, 0.22424970840998948, 0.19879724565484502, 0.24855134925733768, 0.5991907952581617, 0.7455890990645102, 0.6276962720986039, 0.5774970738931969, 0.5769345362066165, 0.31775642892346245, 0.2662824700237677, 0.6415078473076792, 0.045338947842059274, 0.0844540508664472, 0.10876248978170311, 0.061706294350183044, 0.03867918347278099, 0.10609406855086068, 0.05399742200473212, 0.07186953705726318, 0.08041132824428765, 0.1434852119925183, 0.14104738457321508, 0.13435146644519214, 0.14488830732921687, 0.13784018412695076, 0.12485542690863405, 0.1271810395036055, 0.13909449539705454, 0.14351791939669833, 0.16243464094617743, 0.31830464671968595, 0.44160309102151474, 0.29269895463478257, 0.317167082793983, 0.4482019264531448, 0.1867508297663928, 0.3198417527701819, 0.4647584078803024, 0.12828008653041034, 0.24690370244963478, 0.34703336853982825, 0.24611231320372084, 0.22172733113112608, 0.38562134190285635, 0.14902134874297612, 0.26199248649715445, 0.30432588346088496, 0.17076429633163337, 0.1679682291697513, 0.18977813015059797, 0.16999837346041025, 0.1600634029675393, 0.18840738559224746, 0.16001339876081366, 0.13800282988145207, 0.195563032543146, 0.14725664265670002, 0.17100668052633283, 0.1989603253472465, 0.1420432321092261, 0.1377859807762084, 0.17794825227141386, 0.14947274771365082, 0.16522802896743616, 0.335323506249266, 0.13618960859517992, 0.12256417628249561, 0.17864226011495288, 0.14250496344604746, 0.15524953646613682, 0.18770609018922157, 0.08879803886730331, 0.44420041854838777, 0.14890074117153496, 0.07027747980950627, 0.1899876960744754, 0.20283941840002528, 0.4063203294270932, 0.15332621784734368, 0.16431336776361183, 0.21067871488437018, 0.19352264373901573, 0.7652344205712905, 0.14717175565330032, 0.18999850080507152, 0.1832319297539643, 0.1554680993202725, 0.1567249844987838, 0.1944994396889902, 0.17964348346925474, 0.17561535362795389, 0.1800180983686238, 0.04670310743926587, 0.07283097151233231, 0.07287668459476349, 0.07589712405195281, 0.04832267890171338, 0.07025040972003793, 0.06859207277516399, 0.06550881887663162, 0.09048360701003133]}, "mutation_prompt": null}
{"id": "f0b6ce69-de40-41c7-9148-13cb51d1f73a", "solution": "import numpy as np\n\nclass AdvancedDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.7  # Enhanced scaling factor\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.ones(3)  # Initialize to ones for unbiased start\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] = max(1e-6, self.success_rates[strat_index] * 0.9)  # Avoid zero success rate\n        return self.best_solution, self.best_fitness", "name": "AdvancedDES3D_Adaptive", "description": "Improved Adaptive Differential Evolution with Enhanced Strategy Adaptation and Success Memory.", "configspace": "", "generation": 26, "fitness": 0.1190734854435565, "feedback": "The algorithm AdvancedDES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.12.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.2573001592420665, 0.26300512181397406, 0.2432258777790416, 0.2653040299804107, 0.29549757668334775, 0.28870551093588015, 0.26288463152919084, 0.24558388556303967, 0.2606442370752088, 0.013707484735824615, 0.00602053138691605, 0.02015195431509309, 0.0143415569522658, 0.0207266862840797, 0.020688567664023494, 0.011160538401714604, 0.018443853077815264, 0.002234933864232125, 0.04320356220281596, 0.05995014790568909, 0.058546510824270426, 0.06329398276046194, 0.058848388129675744, 0.047709266354197255, 0.05187383808145807, 0.06619689447577515, 0.058979597925091554, 0.04081150561017288, 0.049060795418090164, 0.05825002607791052, 0.044978143321172115, 0.04573670642897776, 0.04408370051767452, 0.04247016691562966, 0.03666886938734837, 0.044689198729845, 0.8132007035494426, 0.6631653865933791, 0.7047920707983036, 0.22574455254256076, 0.19677459373595152, 0.1493725581187766, 0.23714363505201086, 0.7892829724759276, 0.6405695627488743, 0.07244924569225752, 0.09418681320372013, 0.1187960459998636, 0.10610636550327779, 0.11441857030191893, 0.10417751944052311, 0.09351542008245217, 0.13407938355500615, 0.09857107554624123, 0.17828500919160584, 0.19351554076944244, 0.16352582510444447, 0.17760528869314507, 0.14037787382015998, 0.14515211571074105, 0.16800441808119082, 0.15921945019824923, 0.12071450603112521, 0.03481007355267607, 0.04932832359090045, 0.023598716471315173, 0.04762059664657814, 0.041275228301874134, 0.04729129534093268, 0.03119164747996417, 0.03711395990103139, 0.05693760820483984, 0.0646117475446164, 0.06094255693834949, 0.053062951247339285, 0.06126268055348594, 0.05201093483925601, 0.08790370908778, 0.05585260010322379, 0.04649223312336204, 0.018843993713931972, 9.999999999998899e-05, 0.0005231634163356258, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06351556591474983, 0.0688571077000617, 0.04921104270941323, 0.1174470906696009, 0.060567881171203264, 0.027541221989473508, 0.07489288428189156, 0.05840176201438718, 0.09019209972029307, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023774996486327638, 0.03308749583875337, 0.03407108235997891, 0.028108919662810927, 0.02093714002114644, 0.024470548200198228, 0.03639714770511504, 0.03378363338431323, 0.040051613740244685, 0.26796093093570894, 0.25584328018264046, 0.24543324096436003, 0.2637804501815676, 0.2562045934509313, 0.2563729126955737, 0.2608959272740494, 0.22481728430404735, 0.2607223196505847, 0.049608215267673006, 0.08766410788817902, 0.03897897833100161, 0.08154768318849781, 0.07258469021360503, 0.053010340838203995, 0.06000385190059132, 0.050089860334865954, 0.03681464544141366, 0.1306467056078049, 0.10874341917794716, 0.11608811494186122, 0.10161823715552676, 0.13967155179458368, 0.08464115057299282, 0.10095214720206991, 0.1114482701710986, 0.12700299663868786, 0.17183597590910193, 0.1699471986956278, 0.1877745833789667, 0.18213941174757142, 0.1719193690568116, 0.17814652561442523, 0.19174346198376568, 0.21999164272949312, 0.18434800358722037, 0.11229106939733069, 0.12056145754395986, 0.10879762733939446, 0.1259762178058409, 0.11657923813301552, 0.134444273919467, 0.11820023336983887, 0.13297784445340144, 0.1253948326923976, 0.1468869702424438, 0.16412224554870825, 0.15900281091676371, 0.1398422433025387, 0.14149682871713798, 0.1659211504951812, 0.15533336612468207, 0.1507149248701185, 0.14908127739513344, 0.146038284860045, 0.14434943002760303, 0.13073694872194097, 0.13254602197564402, 0.13568200321725288, 0.15921879490119262, 0.1420152022351504, 0.1480695588301567, 0.15505523018151668, 0.1453441783736853, 0.1457774852960918, 0.19361632950521024, 0.21795305953417687, 0.15612110526899292, 0.15580878099098594, 0.1105597768336265, 0.13359498016228577, 0.14559108084174677, 0.09525315323106365, 0.11000850594825717, 0.1247569191273189, 0.11633528022829542, 0.12718697916552335, 0.13684425285834456, 0.17657406489414007, 0.11987623230155708, 0.14551836441241395, 0.14936580232918018, 0.17830599800907498, 0.19433857504703, 0.1478381915251099, 0.16061825935214058, 0.14802138077481541, 0.16977413932654994, 0.15165413973265218, 0.16919487630323005, 0.04836761632440589, 0.04116508580968725, 0.048105755170947506, 0.05362113301181215, 0.052867644355391485, 0.04854333614090012, 0.04358241393497553, 0.04736535438759293, 0.06268626455335924]}, "mutation_prompt": null}
{"id": "4ac7f944-c28a-4b43-9896-89a19e020e96", "solution": "import numpy as np\n\nclass HybridDE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(20, 7 * dim)  # Adaptive population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = (self.success_rates + 1) / (total_success + 3)\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_best_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_best_2(self, idx):\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.best_solution + self.F * (self.population[r1] - self.population[r2]) + self.F * (self.population[r3] - self.population[r4])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = list(range(self.pop_size))\n        candidates.remove(idx)\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.90  # Adjust decay factor further\n        return self.best_solution, self.best_fitness", "name": "HybridDE_Adaptive", "description": "Hybrid Differential Evolution with Enhanced Dynamic Strategy Adaptation and Adaptive Population.", "configspace": "", "generation": 27, "fitness": 0.11734719323723602, "feedback": "The algorithm HybridDE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.15.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.2270522161086168, 0.18947354778321535, 0.20941819403457307, 0.2450542502088391, 0.2417370735807014, 0.23738806124588896, 0.24399475689237227, 0.22982637786422688, 0.21264147960697033, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015385437677043479, 0.0026085514114034813, 9.999999999998899e-05, 0.005196606494124678, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06059599804099325, 0.05085930726581078, 0.042327457897327614, 0.057927450104086176, 0.05118955676263215, 0.049302616356030504, 0.0577703162353389, 0.03519919996856535, 0.06112372730061377, 0.04265176177113339, 0.03049104430084848, 0.03636736461344969, 0.058767828673175204, 0.030525943386448096, 0.03555826323174971, 0.03959470009881094, 0.03316686465837515, 0.028334432327786763, 0.9546853565033543, 0.7225009301951548, 0.26941716804851323, 0.9796141306747889, 0.9249467505840621, 0.2636052574186254, 0.911559528300606, 0.9940274390027728, 0.4588441464751052, 0.10539447863384444, 0.07683730755026574, 0.06114896191731989, 0.09242854123620525, 0.09259257023583611, 0.0957498892620926, 0.08899147346449099, 0.0876437149318362, 0.05451933395135511, 0.17157774239225088, 0.14098413321254177, 0.10129408613597424, 0.16275530140797456, 0.10835577683362685, 0.1115824849452558, 0.19504476743347898, 0.11308358674280605, 0.0999024113538991, 0.018519560454582806, 0.02130537381512765, 0.014042614055008507, 0.047028306295177624, 0.07000525393783663, 0.028760660840040697, 0.02869196096521487, 0.040335303007216994, 0.051076832184399845, 0.043381079635998465, 0.005935399668376862, 0.024687206279961127, 0.03703910830201096, 0.038975086213591026, 0.03837456744563894, 0.05639312787439743, 0.013802330644198446, 0.0011027459696033581, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0667984864377118, 0.020994256513419907, 0.0572412346976231, 0.04539762125477975, 0.050454363190370666, 0.020138772187728526, 0.029563125600785112, 0.052077839688314476, 0.07195999688601584, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018014101092711954, 0.009123605728425743, 0.006973369253091, 0.015536848958748517, 0.008166792888897323, 0.025575669433692716, 0.027476266405396244, 0.021759933170673706, 0.012563751078154217, 0.22397080462090713, 0.2315266250082254, 0.22679235418770927, 0.23439869915739286, 0.2083245421209864, 0.2033156812741569, 0.2518965649992527, 0.2225518330217151, 0.2195592241546458, 0.06329678543313588, 0.038682582094557216, 0.03996806635301586, 0.04842214288762514, 0.03610595258756599, 0.04685992154624341, 0.05087760321114021, 0.05497299505803732, 0.044056706021655234, 0.11005267130864682, 0.09785242520295012, 0.09874458713747714, 0.10861500738505003, 0.10852972522114013, 0.09232044409332263, 0.10414011102221499, 0.09976532688076445, 0.08916252456079543, 0.17041160170761926, 0.18363695664187807, 0.1882209335347923, 0.18319542962003876, 0.14837127341043466, 0.16067505604682897, 0.19760754990800922, 0.18291792586423183, 0.16359306638512772, 0.12856458740284293, 0.11992887141536845, 0.10405877151298903, 0.12468653249319084, 0.10081470072577137, 0.11572144010593277, 0.12151814651881321, 0.12740499777119385, 0.09958371040085712, 0.1569569209605155, 0.141247203326739, 0.1567383552423316, 0.14915577134080682, 0.15378043568064348, 0.16535361402772775, 0.15154837363546725, 0.16183464116139024, 0.14595007557242423, 0.16404623507101712, 0.12204254473026066, 0.14269551522067847, 0.13179039268653336, 0.11814021518713291, 0.13080449047223397, 0.13609955239767935, 0.11990364458009195, 0.1211957252062581, 0.17059331281176104, 0.14270207615012698, 0.12034851737500196, 0.12848414097532201, 0.1242636521172279, 0.1082203113128487, 0.13507135819995908, 0.15222405129659544, 0.1374812095921787, 0.14842071307630034, 0.14676353259389419, 0.13891690118535027, 0.07314120845311278, 0.1323799393911388, 0.14457469303307935, 0.11840852620547926, 0.16486473795140444, 0.14772234229974912, 0.17393194533164824, 0.16691674387692457, 0.16716939505816408, 0.17701696011915558, 0.16092195058164038, 0.17076603122738543, 0.19163403704362558, 0.14521696712924492, 0.15466556115998298, 0.05026611573966788, 0.038046908662691226, 0.04977596537851936, 0.05281399000656806, 0.04297462126623264, 0.0431834363702579, 0.04855229037775444, 0.05274181965684588, 0.05241729882919044]}, "mutation_prompt": null}
{"id": "f7ef94d8-04f8-4b4b-9d01-470b2ad05c77", "solution": "import numpy as np\n\nclass Enhanced_Adaptive_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)  \n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            probabilities = self.success_rates / total_success\n        else:\n            probabilities = np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.best_1, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def best_1(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[best_index] + self.F * (self.population[r1] - self.population[r2])\n\n    def current_to_best(self, idx):\n        best_index = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_index] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def local_search(self, solution):\n        for _ in range(5):\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            candidate = np.clip(solution + perturbation, self.lb, self.ub)\n            candidate_fitness = self.evaluate(candidate)\n            if candidate_fitness < self.best_fitness:\n                self.best_fitness = candidate_fitness\n                self.best_solution = candidate\n        return self.best_solution\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                    self.local_search(self.population[i])\n                else:\n                    self.success_rates[strat_index] *= 0.95\n        return self.best_solution, self.best_fitness", "name": "Enhanced_Adaptive_DE", "description": "Enhanced Adaptive Differential Evolution with Dynamic Strategy Selection and Local Search Intensification.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {}, "mutation_prompt": null}
{"id": "fbd6a682-2e22-4f13-9823-bcbd55516b04", "solution": "import numpy as np\n\nclass EnhancedDES3D:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2  # Preserve top 20% elite solutions\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D", "description": "Enhanced Differential Evolution with Adaptive Strategies and Elite Preservation.", "configspace": "", "generation": 29, "fitness": 0.27604585100261786, "feedback": "The algorithm EnhancedDES3D got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "d2086757-b4c0-4002-9389-e3cdac41a7b5", "metadata": {"aucs": [0.7191171814890431, 0.6853737228883547, 0.8310903990671489, 0.7358915068430041, 0.6894134061139792, 0.6870897314767539, 0.15739885748740456, 0.25759781337913423, 0.8108424672274062, 0.5466478978862546, 0.5212169331829446, 0.6706607056182736, 0.49851974153736955, 0.538989137439963, 0.15094621782684248, 0.5202166923625464, 0.5350631063776288, 0.6354279931041238, 0.07827662657143541, 0.0874779701311269, 0.11394139240903389, 0.09063660640218985, 0.10444510292232645, 0.11648651802696264, 0.0931761928524375, 0.09077546129201763, 0.05424533807929133, 0.11298091438637292, 0.03560498061799866, 0.11346410044122879, 0.09108482040310462, 0.06346844530810525, 0.11594679796374185, 0.0880698787620593, 0.0747548786974932, 0.12618252951090925, 0.8756699015401185, 0.8893862884989027, 0.6273329958484906, 0.864577203375756, 0.8796170936826908, 0.8465925999064775, 0.780845543850287, 0.7890953287268208, 0.087144962840211, 0.3733784351599494, 0.3935586090685993, 0.08959288994195236, 0.3718069591620561, 0.08789531559052866, 0.23333753682033398, 0.37243493338332145, 0.3569427532546271, 0.2821690422963661, 0.664508220023943, 0.6732119185101904, 0.7046938777189118, 0.8553248406556757, 0.6601544180023322, 0.8382430102854954, 0.8355042730330049, 0.5739790419974562, 0.231033385222013, 0.05737562033329979, 0.06811226301182127, 0.02683121225133822, 9.999999999998899e-05, 0.05456593925676789, 0.18461203705238172, 0.07782337437856546, 0.3500733844815186, 0.17824797498333478, 0.062263500590926335, 0.04327579940044435, 0.2139214668262195, 0.25390622250311345, 0.061474034662849064, 0.16947189091814563, 0.2948248883559509, 0.05719382183549315, 0.33907425743485253, 0.2988555259674699, 0.2850620882637781, 0.1957806862280056, 0.30172887590480035, 0.2762880662334546, 0.06079715076251124, 0.2971879519666605, 0.2695422214330202, 9.999999999998899e-05, 0.030542185527755783, 0.43414707731159163, 0.3016758901991854, 0.2627327955154831, 0.3720326697193098, 0.3922753461225432, 0.0578665999343726, 0.42869982773794657, 0.5315415803312192, 0.06615856110057972, 0.07835264233581152, 0.20708573242709905, 9.999999999998899e-05, 0.10885165281896658, 0.13309151738600744, 0.07870526899409414, 0.08842293797636758, 0.08292974271110665, 0.0010731196883447813, 0.23984226937647257, 0.18718148155401937, 0.013741389017265071, 0.2676127439885534, 0.2379414849661613, 0.24536432290764265, 0.22424970840998948, 0.19879724565484502, 0.2578150160779, 0.5991907952581617, 0.7455890990645102, 0.6276962720986039, 0.5774970738931969, 0.5769345362066165, 0.6099918329730216, 0.6719489317621115, 0.6415078473076792, 0.040237375912987816, 0.0844540508664472, 0.10876248978170311, 0.04404971239225741, 0.04486715106801098, 0.10609406855086068, 0.06669846847465177, 0.07186953705726318, 0.04522411479566146, 0.1434852119925183, 0.1000820188346544, 0.13435146644519214, 0.14488830732921687, 0.13784018412695076, 0.12485542690863405, 0.1271810395036055, 0.13909449539705454, 0.14351791939669833, 0.17259062647274737, 0.31830464671968595, 0.44160309102151474, 0.29269895463478257, 0.317167082793983, 0.4482019264531448, 0.3121711298226262, 0.3198417527701819, 0.4647584078803024, 0.1034680256428051, 0.24690370244963478, 0.34703336853982825, 0.24611231320372084, 0.22172733113112608, 0.38562134190285635, 0.2467912897075204, 0.26199248649715445, 0.30432588346088496, 0.1551244401953048, 0.1679682291697513, 0.18977813015059797, 0.1844901304877672, 0.16369317187832455, 0.18840738559224746, 0.19027781624551798, 0.16547706156415587, 0.195563032543146, 0.15066910117575283, 0.17100668052633283, 0.1989603253472465, 0.15323274607089865, 0.14154196529178376, 0.17794825227141386, 0.1694648053722021, 0.16522802896743616, 0.335323506249266, 0.14341128872345088, 0.11200598298265141, 0.17864226011495288, 0.8154612959871474, 0.15524953646613682, 0.18770609018922157, 0.10812823851784326, 0.44420041854838777, 0.14890074117153496, 0.19280398964725176, 0.1106429182711125, 0.20283941840002528, 0.4063203294270932, 0.2403451796413446, 0.16431336776361183, 0.21067871488437018, 0.19352264373901573, 0.7652344205712905, 0.14615318211928174, 0.18999850080507152, 0.1832319297539643, 0.18195674025023367, 0.1567249844987838, 0.1944994396889902, 0.17964348346925474, 0.17561535362795389, 0.1800180983686238, 0.03862145660239946, 0.07283097151233231, 0.07287668459476349, 0.07589712405195281, 0.05383231116690079, 0.07025040972003793, 0.06859207277516399, 0.053018524591483596, 0.09048360701003133]}, "mutation_prompt": null}
{"id": "916262ed-1005-41f4-910c-0e7a23660b84", "solution": "import numpy as np\n\nclass EnhancedDES3D:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2  # Preserve top 20% elite solutions\n        self.dynamic_F = (0.4, 0.9)  # Range for dynamic F\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def dynamic_parameter_adjustment(self):\n        # Adjust F dynamically based on progress\n        progress = self.evaluation_count / self.budget\n        self.F = self.dynamic_F[0] + (self.dynamic_F[1] - self.dynamic_F[0]) * (1 - progress)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            self.dynamic_parameter_adjustment()\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D", "description": "Enhanced Differential Evolution with Adaptive Strategies, Elite Preservation, and Dynamic Parameter Adjustment.", "configspace": "", "generation": 30, "fitness": 0.20310465563076396, "feedback": "The algorithm EnhancedDES3D got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "fbd6a682-2e22-4f13-9823-bcbd55516b04", "metadata": {"aucs": [0.6204134576860336, 0.47695785495465004, 0.14942226421141236, 0.5019224984651184, 0.5108549859243392, 0.4937631265510948, 0.1579831223778545, 0.15605993415916275, 0.14989234483851377, 0.27086302102477045, 0.240661623084636, 0.5145299715634502, 0.4354344319880251, 0.24345119272359872, 0.5244184093528644, 9.999999999998899e-05, 0.2441658580163586, 9.999999999998899e-05, 0.07081550647507151, 0.07024555906308871, 0.09315532071412691, 0.09198670562871936, 0.07712692810277044, 0.08571653926353862, 0.04301171434320661, 0.0805490328109405, 0.03839379691045286, 0.08495318988640443, 0.05633904010169921, 0.07634033762462622, 0.06326235155834914, 0.0563403278969421, 0.07795179853254974, 0.06829534361514566, 0.05706288505567081, 0.10883914106564718, 0.1822908997925814, 0.8661535113367473, 0.8263762819617476, 0.8865346902318045, 0.9288612387715331, 0.8985675274500958, 0.9579996710972924, 0.9361821842617432, 0.9415631346750915, 0.07752336359025847, 0.19450888897081509, 0.11074315781889743, 0.2144376176058318, 0.04193550845152061, 0.3475318271591773, 0.1911738747248739, 0.23360129966407828, 0.3256637762381396, 0.10364929164491155, 0.3056019881545827, 0.336684100950843, 0.10138115004398274, 0.37227111750646924, 0.5960028521757719, 0.5880972527657093, 0.3796179915820075, 0.6029531704941035, 0.005123587169001298, 0.020162176562630196, 0.0008085754023324787, 9.999999999998899e-05, 0.00010420456393622768, 0.19598210459013543, 0.006861971322198901, 0.10177275250509665, 0.005857127426788011, 0.008382375567382083, 0.008080345912938713, 0.009907089842218886, 9.999999999998899e-05, 0.0160856816691346, 0.004929380300999542, 0.20186678653300716, 0.0011527787781148158, 0.00465175614218627, 0.07624736605874183, 9.999999999998899e-05, 0.22220855285048935, 9.999999999998899e-05, 0.08044617485959549, 0.25636170094283817, 9.999999999998899e-05, 0.05561673221130492, 0.22937377017453375, 0.1779803714903213, 0.13358884771721347, 0.32851007003852084, 0.31863807754164786, 0.15181195198919795, 0.38829785517943105, 0.4049187436696716, 0.19184531433947016, 0.3893295211198845, 0.019301999185233787, 0.005712472050473094, 0.041834769034221786, 0.08820990051970135, 0.013371268014004234, 0.11744598847409304, 0.03990173001389341, 0.004677281708266867, 9.999999999998899e-05, 0.00027086403546128235, 0.10214382447419357, 0.20061062751223213, 0.0012322548634278174, 0.12047216998496368, 0.2448599490265626, 0.008440893175454378, 0.1052084775231017, 0.2157438166483957, 0.18240710692300222, 0.37289155749236713, 0.5113329516403562, 0.3768538520325464, 0.39763159470107035, 0.560812497502686, 0.5695839225766726, 0.5634583897568304, 0.5989284271885217, 0.07382950321394488, 0.08172267884778484, 0.0771257728828636, 0.04136412926263533, 0.0580656525929506, 0.08349558089731413, 0.0365240223375507, 0.0775979927988446, 0.03380876013252021, 0.14177953844891455, 0.14729702638726372, 0.2101987162065596, 0.11879393455399534, 0.1532527611656722, 0.1563333121543815, 0.16382691492243173, 0.1412017553102971, 0.14015640591068934, 0.3310605186663659, 0.2350179218320929, 0.3150569625751184, 0.3105898468995689, 0.20928382880132868, 0.2782794528337974, 0.33645567721555825, 0.2396441824938802, 0.3323895563089594, 0.08394984264949545, 0.15596143158093823, 0.2604976334358665, 0.15494791557609044, 0.08786151220956495, 0.22673056029178928, 0.25372468664877323, 0.17426620352098066, 0.2573012796345666, 0.12540933464807735, 0.20479167695480394, 0.18754472070980432, 0.1818957409032782, 0.17190952571859575, 0.1454482843327607, 0.14707002761235566, 0.13156967348055404, 0.18394682480121283, 0.06749469509312889, 0.14865457425126638, 0.166482828597166, 0.06469610498847378, 0.0781485195436451, 0.15376720741978822, 0.15759098831460905, 0.16940859790279994, 0.1793969788109716, 0.26441812490188754, 0.19267482056270946, 0.14285057877050766, 0.17648652542843934, 0.49312291567230404, 0.17717098938809905, 0.08516397134380094, 0.16645392679422022, 0.16610507417523057, 0.29237187533607134, 0.1435870642971302, 0.1885613750525159, 0.24214131394022564, 0.14868224834395183, 0.5321088811749468, 0.20519785398153878, 0.1889911720654689, 0.1552565200834677, 0.1761151575075155, 0.1790426816533225, 0.18164344135320065, 0.19073975920315678, 0.18504168878642757, 0.1598190258145391, 0.19087987675122886, 0.192802540517221, 0.18609349993343816, 0.03435754789657364, 0.0664607473324178, 0.036050918234747265, 0.061704969788377806, 0.03947036371458412, 0.04903303122836, 0.05452502233332157, 0.04475206597750425, 0.035978956401786166]}, "mutation_prompt": null}
{"id": "b7d645df-9caa-4a55-8a78-31c43fbde15e", "solution": "import numpy as np\n\nclass EnhancedDES3D:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def dynamic_parameter_control(self):\n        self.F = 0.5 + 0.5 * np.random.rand()  # Dynamic scaling factor\n        self.CR = 0.8 + 0.2 * np.random.rand()  # Dynamic crossover rate\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            self.dynamic_parameter_control()  # Adjust parameters at each generation\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D", "description": "Enhanced Differential Evolution with Adaptive Strategies and Dynamic Parameter Control.", "configspace": "", "generation": 31, "fitness": 0.19560060753408953, "feedback": "The algorithm EnhancedDES3D got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "fbd6a682-2e22-4f13-9823-bcbd55516b04", "metadata": {"aucs": [0.6699931604571794, 0.19270718479931437, 0.6793382980346725, 0.21822190617038695, 0.2091350017436452, 0.470933438212765, 0.18745218753584425, 0.20440973220415137, 0.7101097245489959, 0.21907636665329255, 9.999999999998899e-05, 0.2134768880994392, 0.5265438681741965, 9.999999999998899e-05, 0.5006526199679513, 0.48563296066625017, 0.5030041979392954, 0.47192394617941824, 0.07123633252794226, 0.05487108576129396, 0.10636395883450278, 0.11332256595136292, 0.0363166738382662, 0.10126540860095579, 0.09043703818048399, 0.03755115731249825, 0.08994863520358354, 0.09095373414327901, 0.01934835564615256, 0.030398385341593337, 0.0882842755814649, 0.02516488026613317, 0.09255672476419008, 0.08839265667041052, 0.024671986368292376, 0.060211790917103825, 0.9443332179724291, 0.46616759927489204, 0.8978667932016859, 0.9370673150277573, 0.6282593832710861, 0.8641084584379223, 0.9416362687394204, 0.18560591647355573, 0.9244521163030197, 0.30838055158569044, 0.04085735278115177, 0.3216929005204181, 0.05672555897220266, 0.03546772589602021, 0.36023931666693343, 0.1943837446346529, 0.05401396777469347, 0.172429697087903, 0.13652928128378483, 0.2562368648013029, 0.2290699250393986, 0.6550208794006434, 0.12706195669049625, 0.15690013912082557, 0.7033137479830394, 0.1359259658817238, 0.715145712183525, 0.012268233142798235, 0.040677558236866584, 0.2674990753675587, 0.015036323236392257, 0.030289018988084337, 0.29500606884348524, 0.023382504217716482, 0.02114750590478487, 0.290233995911618, 0.07214542782817113, 0.008674871795820938, 0.021016402733890938, 0.04629851172913191, 0.010814465039834631, 0.045303909248851415, 0.16174242132938066, 0.020004722878126047, 0.23786903624025968, 9.999999999998899e-05, 9.999999999998899e-05, 0.09500081058556464, 9.999999999998899e-05, 9.999999999998899e-05, 0.2982673867925405, 9.999999999998899e-05, 0.25201316465683177, 9.999999999998899e-05, 0.14974697057453146, 0.15279067939787727, 0.16479617936588986, 0.36026775916911036, 0.020898777667275326, 0.3971786925961216, 0.4572660925480265, 0.047493533390614684, 0.49285065288321717, 0.001109959674250982, 0.004993194228171682, 0.12868583238466957, 0.1569811668130736, 0.11243530301636961, 0.08841990622206997, 0.11601222337232153, 0.001994974662031801, 0.11493463028746465, 0.012255440727654388, 0.010956947854395493, 0.08662340808782754, 0.004392891621540551, 0.004638552905903093, 0.1045544920958078, 0.013070958548054623, 0.131087897730771, 0.2195025037616961, 0.20885857882091952, 0.19247539703135552, 0.5919674288729996, 0.6163078110892168, 0.20582464668686673, 0.37697137514606116, 0.6419124747708287, 0.5414351147458432, 0.5689781018065424, 0.0555528738759391, 0.044023975206821886, 0.09860312296357299, 0.041746807280100384, 0.037652983891145464, 0.09492201769711683, 0.04125500633484447, 0.04839190089483414, 0.07608530587305673, 0.1369355631512622, 0.10752485176020454, 0.19458053141940446, 0.20060202473075672, 0.10884080493385462, 0.12346091023578387, 0.08859992012320161, 0.13667469304598812, 0.12654138986403618, 0.31359406995329175, 0.33477867660007454, 0.28356551496907445, 0.3172624863502139, 0.13776319798402492, 0.30812692777717166, 0.2324062606981333, 0.20112359318156525, 0.23162179263690108, 0.2644430656125648, 0.10078505635870261, 0.23593304744950871, 0.11762536114152733, 0.09964865670348677, 0.2250912321028007, 0.16672885695174522, 0.16534745561881825, 0.163292553771323, 0.16157011142100042, 0.1499492264041441, 0.1466432535134432, 0.1662665290117018, 0.1824388529595825, 0.19581990665002758, 0.19772606651637992, 0.13747293370626157, 0.16939474606767868, 0.10522465981131135, 0.1209445903142976, 0.16414233101227238, 0.13405700614388716, 0.1268780100332364, 0.2024708761040197, 0.1557825203626646, 0.11806826695063133, 0.1655275448864295, 0.13272752728380988, 0.123804477447084, 0.1646494447861433, 0.17526850630013813, 0.14176332187985985, 0.18241314014638232, 0.10073366605234513, 0.17616068523685735, 0.13636741623930504, 0.17999449340439844, 0.10233051407397764, 0.17375980366835497, 0.1802780472641038, 0.12366774163570604, 0.1524640915059039, 0.2074411861144242, 0.1551782599035716, 0.18462013296242852, 0.17700520651220408, 0.16169608684828074, 0.17902812316120031, 0.17910698128613967, 0.19304288031404726, 0.2098240709450836, 0.1695497259119566, 0.15390488967340277, 0.16742323178387197, 0.06084127165006625, 0.05456671592535933, 0.07725551454099899, 0.03718029385918875, 0.0469451308062071, 0.05426561448013656, 0.048551356881864405, 0.05043747133536203, 0.07501283496378708]}, "mutation_prompt": null}
{"id": "c0412112-af95-4a90-8ee1-c0145397a320", "solution": "import numpy as np\n\nclass EnhancedDES3D:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2  # Preserve top 20% elite solutions\n\n    def select_strategy(self):\n        if np.random.rand() < 0.1:\n            return np.random.choice(3)  # Introduce randomness in strategy selection\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = solution\n        return fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D", "description": "Enhanced Differential Evolution with Adaptive and Randomized Strategy Selection and Elite Preservation.", "configspace": "", "generation": 32, "fitness": 0.12534241912037689, "feedback": "The algorithm EnhancedDES3D got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.10.", "error": "", "parent_id": "fbd6a682-2e22-4f13-9823-bcbd55516b04", "metadata": {"aucs": [0.3265602025896538, 0.2743047473162574, 0.2484665039739965, 0.310759840294356, 0.29979714401229707, 0.4041294753931609, 0.3223786822352791, 0.2703265972810849, 0.2626263311165443, 0.051413210725384295, 0.10024668597026853, 0.021842949384214938, 0.00578328221143698, 0.03434504989704723, 0.012914262552975564, 0.0060334709155301924, 0.020584314766653566, 0.005791450191095504, 0.05824801042323147, 0.05655093918458787, 0.05642534525324394, 0.053803274674380175, 0.0741215960345255, 0.05928483561669706, 0.0632624156161331, 0.08375608331644524, 0.05261574549972681, 0.05600628372058003, 0.04565649162539798, 0.03780295739198458, 0.0505782730254104, 0.060433422707827034, 0.05239916394461319, 0.02996094991914766, 0.049604457074934216, 0.07018778224812672, 0.1521148201759197, 0.8175334376067832, 0.09656505752471567, 0.16976176537403498, 0.3123510434699647, 0.2648662241523473, 0.6151935123423997, 0.1984461215173633, 0.2063615640493014, 0.1616805743630213, 0.062295638020949284, 0.10156689830113375, 0.12786901096211423, 0.10888363613113416, 0.06927022833436114, 0.1054800459086026, 0.1348192069758285, 0.11533237988220424, 0.2051524913247167, 0.17491637090947465, 0.2069892623563242, 0.16371262515308538, 0.2624460019198065, 0.18433236186886792, 0.27854318094866726, 0.21780336803418687, 0.18443383656099577, 0.07319324913842062, 0.07598774904452787, 0.044682355719695255, 0.1176203106484559, 0.05695410439640314, 0.05949054131709186, 0.09144128775640037, 0.050057536010998605, 0.07511223705793602, 0.07354994823281868, 0.08898666137705458, 0.06403236271839219, 0.07319505961908745, 0.061214337602727986, 0.06770475067379444, 0.08232471761659477, 0.07327435533843274, 0.06807141327533406, 0.0007577752478695743, 9.999999999998899e-05, 9.999999999998899e-05, 0.016643835058460565, 0.0001969680964524212, 0.0031826624719220042, 0.0014522123911480112, 0.0008850305248133683, 0.017374601954118774, 0.16577185638284098, 0.09152429161638864, 0.14173766695321954, 0.07688542090388495, 0.11751751119398213, 0.07053631219605794, 0.0940801463601767, 0.14829502048676568, 0.07257381810667485, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006957380203550523, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004507876723178761, 9.999999999998899e-05, 9.999999999998899e-05, 0.07288628022031884, 0.05141703798153974, 0.10608894084372755, 0.009354633468551032, 0.04086860280962301, 0.02001072141045601, 0.027825615448557994, 0.025898835601804393, 0.04037510790911969, 0.3030311006866748, 0.2704715126214755, 0.28112381706192346, 0.3096557159606367, 0.237602106887574, 0.287768395520834, 0.2598745328555975, 0.28506760507469275, 0.2887216031397436, 0.03405870780872933, 0.06849457711357865, 0.047675029962220505, 0.05637701759319824, 0.05294428316166344, 0.04457944069244435, 0.06554708675566068, 0.060785196318522305, 0.05990105824977332, 0.10768416684791282, 0.09363113839302784, 0.11443266709181044, 0.12235178653496315, 0.10849619519410536, 0.1167382798734119, 0.11098709174886512, 0.10740304625916175, 0.14690579176650898, 0.17254352227954606, 0.23296728679232226, 0.1953335243464921, 0.22646322988489964, 0.19852868071952579, 0.17381209810947473, 0.19198962788246088, 0.2206410895483365, 0.23017584453155604, 0.1448064804499063, 0.14286659773636734, 0.127318203780594, 0.1508681266517108, 0.12960189260189547, 0.17046935226106785, 0.13329388617868787, 0.17237347780214318, 0.18321107284149496, 0.15867735013618023, 0.17001738413992484, 0.1497790306381348, 0.1545231643809546, 0.1847488275749406, 0.1523546327705777, 0.1541287074665041, 0.15229607947190782, 0.1767654846356318, 0.15312453550719274, 0.15554324307213863, 0.14948191115921783, 0.15700009643662782, 0.16153110477268906, 0.16365639909802354, 0.15563829388466455, 0.15486337177023235, 0.13991604420204495, 0.15186977872764673, 0.13604532541735825, 0.12075971091419646, 0.20770844283130585, 0.14190132672072064, 0.1325879736502087, 0.10947556033442818, 0.1381775193491327, 0.11453784045283011, 0.1911937383437171, 0.14671618712936685, 0.19015992469459742, 0.14834722452940274, 0.13903350231090295, 0.12521721949272413, 0.10084288489850335, 0.16785506686565643, 0.13627318319098447, 0.16535902664432056, 0.15911044206573366, 0.16614359206862006, 0.17079344288947684, 0.194894269936988, 0.16126797489920608, 0.17714415130790062, 0.16345636065889124, 0.15028109103198573, 0.056193433982341, 0.06378531666638532, 0.04537724334943127, 0.044364184453202005, 0.05450766600556922, 0.050969974126317874, 0.050676183786063866, 0.057900812761762066, 0.05861304567490244]}, "mutation_prompt": null}
{"id": "5f2cf004-4107-4dee-97d5-10aa32168901", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive", "description": "Differential Evolution with Dynamic Strategy and Self-Adaptation for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 33, "fitness": 0.29048918231491166, "feedback": "The algorithm EnhancedDES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "fbd6a682-2e22-4f13-9823-bcbd55516b04", "metadata": {"aucs": [0.7070275660496457, 0.6976758642813665, 0.8249560365645467, 0.7135564498548673, 0.6980792881358582, 0.6082111095398048, 0.17252370807520168, 0.2953417847587101, 0.7914425862423057, 0.5519855427369996, 0.5017263498823592, 0.641346102693787, 0.5561446709480455, 0.47746930155637046, 0.6177307151659999, 0.5514128724019964, 0.45391906162221607, 0.6154192719556191, 0.09689926426397066, 0.08506514004879373, 0.10845654832705454, 0.10766364905696046, 0.09993432772453359, 0.11096370922348575, 0.08903757090058284, 0.08898696396394878, 0.04665361648306776, 0.12372470390716594, 0.024699290751816316, 0.10250934344231877, 0.11552625766892743, 0.042839324064342876, 0.1127385289189029, 0.09798800550701636, 0.09173769839002632, 0.0995273895268245, 0.905857665446329, 0.7502569496394824, 0.8336260253884609, 0.8971488513175854, 0.8375879368382343, 0.7807573079792814, 0.8714519911128409, 0.9617477546778348, 0.07254608519463912, 0.3323103913003088, 0.37050368888354446, 0.07948774639603107, 0.31268832728151563, 0.07604048247960493, 0.4368897734266216, 0.3676004547642129, 0.3367876116008809, 0.4269857995883749, 0.6884246076983395, 0.6721566312998736, 0.7539498532533195, 0.8153442801550554, 0.596281284316918, 0.7521340956067398, 0.8230308410938033, 0.6406653276983381, 0.7756299921336953, 0.040456623377359446, 0.04767541728735181, 0.07591747600033472, 0.08398829010822262, 0.04832764016288493, 0.19876928942822747, 0.07742711856326334, 0.23984279624636928, 0.575929582924157, 0.05853726965076311, 0.07831594250679352, 0.1838684212307795, 0.26189432660507705, 0.04355558273956017, 0.4049089351806998, 0.1596301187775252, 0.06487677669617664, 0.1927929308438341, 0.33163597308535897, 0.21000746327494957, 0.3400847006320954, 0.4162523195274622, 0.27472518997757545, 0.5162914557735374, 0.4134241739263649, 0.20475564355990594, 0.0010171816395663225, 0.0360544663277389, 0.40943193710370007, 0.608678355307882, 0.2503605076271056, 0.4186925374079178, 0.30537398770026103, 0.05830352165237451, 0.4342912174674408, 0.6506785862677416, 0.07852891398139816, 0.06092343118340526, 0.13977104139014662, 9.999999999998899e-05, 0.06198931160356658, 0.296690545204513, 0.13301695227076193, 0.0705602320429678, 0.168225066831848, 0.00125975226662689, 0.20928623508619626, 0.2943180102437887, 0.023363416132999193, 0.2551975055918718, 0.3631358867984339, 0.29256736940332717, 0.2040483880557763, 0.384491403716995, 0.2556627610107328, 0.5744026167996734, 0.7479809550052747, 0.4590240937554755, 0.5535462972888043, 0.6903466569543111, 0.6162921969003701, 0.5123442042739619, 0.6895869565642003, 0.05503127484949799, 0.09386070781461242, 0.08748750315534759, 0.04450186216483942, 0.04851231296065994, 0.08964743960578758, 0.07176110917115386, 0.07871080659042506, 0.0528695519233795, 0.17797120927288912, 0.09402778899897146, 0.12631630523878035, 0.16683915483138467, 0.12955345460189926, 0.15308370329498033, 0.13831758757960377, 0.1524859820920097, 0.16436192737652233, 0.17688022339284237, 0.31874021133097663, 0.4181091965558946, 0.3397177907875464, 0.2704691425539575, 0.39611935558431144, 0.33997811845515313, 0.3058180709236248, 0.4570961161988947, 0.10585358172266623, 0.2581165538062884, 0.33323082901662937, 0.2719947591763514, 0.1895012735120103, 0.307083469363148, 0.3124434304315008, 0.22287075010918678, 0.32601479149945445, 0.15835465666301352, 0.20260022500293284, 0.1782804587003789, 0.18925187606682303, 0.14206006999136622, 0.17498420329402942, 0.20843978513811368, 0.15995312288897945, 0.17645928224434904, 0.15123767520296283, 0.18747011795340607, 0.46105849892130457, 0.14644836231595915, 0.1451442552846105, 0.1977027255651208, 0.17083785104913918, 0.18654274594623654, 0.18704659446850413, 0.11990543763019212, 0.08381044697047746, 0.1809154760060957, 0.69696092017169, 0.23530697671154222, 0.18621866073905824, 0.10087029557805238, 0.18044294369376346, 0.18141824544629004, 0.16377058245277443, 0.11239594568960043, 0.5881458209162733, 0.49199137581507735, 0.12350433255767201, 0.7742179403374103, 0.21027093643428185, 0.20683339684534952, 0.14978228956295903, 0.1596528653269157, 0.17568663907038795, 0.18322561530887782, 0.17250629579637822, 0.14997967461404405, 0.17484125032194864, 0.1740214930436026, 0.1868146805117148, 0.17351320192085296, 0.04900077916426149, 0.0679042800291636, 0.07601282696741563, 0.07912305483143778, 0.04450639556912339, 0.06740667370757925, 0.0641119141169274, 0.04078441433350888, 0.07831412103471447]}, "mutation_prompt": null}
{"id": "1d3ad53d-8992-4a7f-b5b8-48074c184193", "solution": "import numpy as np\n\nclass EnhancedDES3D_MultiScale:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.scale_factors = [0.5, 1.0, 2.0]  # Multi-scale exploration\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        scale = np.random.choice(self.scale_factors)  # Multi-scale factor selection\n        return self.population[r1] + scale * self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        scale = np.random.choice(self.scale_factors)  # Multi-scale factor selection\n        return self.population[r1] + scale * self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        scale = np.random.choice(self.scale_factors)  # Multi-scale factor selection\n        return self.population[idx] + scale * self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 1.0)  # Slight adjustment\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_MultiScale", "description": "Adaptive Differential Evolution with Dynamic Strategy Selection and Multi-Scale Exploration for Robust Optimization.", "configspace": "", "generation": 34, "fitness": 0.21567135682558267, "feedback": "The algorithm EnhancedDES3D_MultiScale got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.22.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.23828472790970145, 0.7824077622958701, 0.7669884376721209, 0.44435380904959887, 0.2666224582398675, 0.7807673514791779, 0.24962011949521667, 0.25127243061610793, 0.7148029586880522, 0.19558297627925558, 0.15196881195591683, 0.30735183258791565, 0.02928365675168898, 0.006445406220917382, 0.5385854456043792, 0.0017664011189688633, 0.46837801637250587, 0.5167455178386521, 0.04689709090956806, 0.07271623290187523, 0.12780117721903228, 0.057399509377041635, 0.11051459892394266, 0.11073369025079027, 0.05979893708994366, 0.09060564074768895, 0.09009761948940576, 0.03229927015644285, 0.05161704529388933, 0.08398137233301417, 0.03406255051490348, 0.03324157195755273, 0.1009399215565876, 0.06813927768356043, 0.05215739166539568, 0.0955388377483054, 0.6880036206501914, 0.9623110361521559, 0.9300928758533604, 0.8970225542387309, 0.9464086991897768, 0.7808174310337472, 0.953116893455631, 0.8853778773170986, 0.9597826046401681, 0.07421408688032971, 0.33339585061472565, 0.35245642589645, 0.19035526967066763, 0.07460224554943196, 0.21027050811624126, 0.06709927881553124, 0.16740310622573196, 0.27448170784563664, 0.22148128462311023, 0.22761931720268158, 0.7872597430806135, 0.18675771247635153, 0.676338481250988, 0.726827754685524, 0.13856850223394956, 0.7329266067837769, 0.23265446985639548, 0.022675924526370017, 0.003105808596092552, 0.13336743847025723, 0.02823482738133154, 0.06254640552322854, 0.1978046799953268, 0.04043624406788604, 0.04525066032618119, 0.1722169843474607, 0.0719853623728457, 0.012023061133287438, 0.33440442073131393, 0.045751032172414274, 0.06576782161177874, 0.22814341661775472, 0.03240737272699279, 0.059122018647629226, 0.22076829707360057, 0.00042333361037671935, 9.999999999998899e-05, 0.09147153677967379, 9.999999999998899e-05, 0.1818282183235148, 0.0010370924577554064, 9.999999999998899e-05, 0.1482996380604663, 0.2920203290575132, 0.02118838161616554, 0.09523730228251348, 0.2294996828114868, 0.03506912555672259, 0.3156234943433528, 0.330890994835661, 0.06761137616108792, 0.3481449175740493, 0.2825318606504381, 9.999999999998899e-05, 9.999999999998899e-05, 0.0627699370098892, 9.999999999998899e-05, 0.12425520717445981, 0.12178227210505754, 9.999999999998899e-05, 9.999999999998899e-05, 0.17338350181762274, 0.0005526069935156697, 0.06898102570765718, 0.33576386944938863, 0.005104266753006792, 0.2342835196462828, 0.1468565394674768, 0.025429312635435908, 0.02927969154281329, 0.2338465811497229, 0.24421003037396571, 0.25276539328101943, 0.6208258577699297, 0.36453935736104925, 0.5760664224267193, 0.4591302677205571, 0.20930738876009525, 0.5420674965473814, 0.47884475932538373, 0.03258238496766663, 0.0955967737863157, 0.09615577723480695, 0.05239963979265849, 0.049629793495196695, 0.1260484992958042, 0.06306188672868718, 0.04345688673519543, 0.09179644643861118, 0.08504114347014802, 0.13888137068919404, 0.311822035094389, 0.11977539459333786, 0.10849775786930071, 0.22555598828308399, 0.13490398612621157, 0.08623636762264764, 0.17184368128188054, 0.15211932944261075, 0.33741563026888033, 0.4411110060746659, 0.1777240755100825, 0.29775815408267337, 0.5398695666681618, 0.16426626636699204, 0.20879312795244898, 0.43250127642538605, 0.0924910501559496, 0.24104471173108843, 0.26634219211101995, 0.12030510958771679, 0.22681996747431132, 0.2799186105605245, 0.10178351114117412, 0.14122080518442692, 0.240787185282759, 0.16841013963824425, 0.13984054445032523, 0.17123097710626467, 0.13778550175471793, 0.2063069632318275, 0.22534189123642379, 0.1571908236380879, 0.14497408399188405, 0.20624968079934958, 0.13927871609757025, 0.16735015994297187, 0.213996603647034, 0.11782790945064792, 0.1451858785043938, 0.18314731194798273, 0.15634551453533696, 0.1782220830576885, 0.18757796510036373, 0.1467994704521154, 0.15252318601648351, 0.14959186918037448, 0.19625765755667612, 0.18369270698411833, 0.1671102541284416, 0.1032008291683193, 0.11350776145883501, 0.1376084887993122, 0.14509875856467802, 0.17823397698103782, 0.7646240984787009, 0.11100935941119172, 0.1988607698425794, 0.20222158206661256, 0.1912582805158599, 0.4707173834210503, 0.14721804418913276, 0.1754746964537417, 0.17680990795506912, 0.17050507947697713, 0.13748495100198832, 0.14261368554474352, 0.1667332740864651, 0.17806832112903392, 0.1706768721592552, 0.18612587629243682, 0.04571951785951789, 0.05504528837599043, 0.08006679917751625, 0.05682208385464005, 0.05816066366350203, 0.07094172088644957, 0.04604192996580059, 0.05043682764769786, 0.08078079812758698]}, "mutation_prompt": null}
{"id": "bdd1e402-43bc-4e44-a102-78f36681fe79", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(12, 6 * dim)  # Slightly increased population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6  # Adjusted initial F value\n        self.CR = 0.8  # Adjusted initial CR value\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.25  # Adjusted elite fraction\n        self.adaptive_factor = 0.05  # Adjusted adaptive factor\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.5, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive", "description": "Dynamic Differential Evolution with Adaptive Strategy Selection and Self-Adapting Parameters for Enhanced Optimization.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {}, "mutation_prompt": null}
{"id": "aeaf9ca8-e505-4490-840a-904716614198", "solution": "import numpy as np\n\nclass AdaptiveMSDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMSDE", "description": "Adaptive Multi-Strategy Differential Evolution with Success-Based Strategy Selection and Parameter Tuning.", "configspace": "", "generation": 36, "fitness": 0.29048918231491166, "feedback": "The algorithm AdaptiveMSDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.7070275660496457, 0.6976758642813665, 0.8249560365645467, 0.7135564498548673, 0.6980792881358582, 0.6082111095398048, 0.17252370807520168, 0.2953417847587101, 0.7914425862423057, 0.5519855427369996, 0.5017263498823592, 0.641346102693787, 0.5561446709480455, 0.47746930155637046, 0.6177307151659999, 0.5514128724019964, 0.45391906162221607, 0.6154192719556191, 0.09689926426397066, 0.08506514004879373, 0.10845654832705454, 0.10766364905696046, 0.09993432772453359, 0.11096370922348575, 0.08903757090058284, 0.08898696396394878, 0.04665361648306776, 0.12372470390716594, 0.024699290751816316, 0.10250934344231877, 0.11552625766892743, 0.042839324064342876, 0.1127385289189029, 0.09798800550701636, 0.09173769839002632, 0.0995273895268245, 0.905857665446329, 0.7502569496394824, 0.8336260253884609, 0.8971488513175854, 0.8375879368382343, 0.7807573079792814, 0.8714519911128409, 0.9617477546778348, 0.07254608519463912, 0.3323103913003088, 0.37050368888354446, 0.07948774639603107, 0.31268832728151563, 0.07604048247960493, 0.4368897734266216, 0.3676004547642129, 0.3367876116008809, 0.4269857995883749, 0.6884246076983395, 0.6721566312998736, 0.7539498532533195, 0.8153442801550554, 0.596281284316918, 0.7521340956067398, 0.8230308410938033, 0.6406653276983381, 0.7756299921336953, 0.040456623377359446, 0.04767541728735181, 0.07591747600033472, 0.08398829010822262, 0.04832764016288493, 0.19876928942822747, 0.07742711856326334, 0.23984279624636928, 0.575929582924157, 0.05853726965076311, 0.07831594250679352, 0.1838684212307795, 0.26189432660507705, 0.04355558273956017, 0.4049089351806998, 0.1596301187775252, 0.06487677669617664, 0.1927929308438341, 0.33163597308535897, 0.21000746327494957, 0.3400847006320954, 0.4162523195274622, 0.27472518997757545, 0.5162914557735374, 0.4134241739263649, 0.20475564355990594, 0.0010171816395663225, 0.0360544663277389, 0.40943193710370007, 0.608678355307882, 0.2503605076271056, 0.4186925374079178, 0.30537398770026103, 0.05830352165237451, 0.4342912174674408, 0.6506785862677416, 0.07852891398139816, 0.06092343118340526, 0.13977104139014662, 9.999999999998899e-05, 0.06198931160356658, 0.296690545204513, 0.13301695227076193, 0.0705602320429678, 0.168225066831848, 0.00125975226662689, 0.20928623508619626, 0.2943180102437887, 0.023363416132999193, 0.2551975055918718, 0.3631358867984339, 0.29256736940332717, 0.2040483880557763, 0.384491403716995, 0.2556627610107328, 0.5744026167996734, 0.7479809550052747, 0.4590240937554755, 0.5535462972888043, 0.6903466569543111, 0.6162921969003701, 0.5123442042739619, 0.6895869565642003, 0.05503127484949799, 0.09386070781461242, 0.08748750315534759, 0.04450186216483942, 0.04851231296065994, 0.08964743960578758, 0.07176110917115386, 0.07871080659042506, 0.0528695519233795, 0.17797120927288912, 0.09402778899897146, 0.12631630523878035, 0.16683915483138467, 0.12955345460189926, 0.15308370329498033, 0.13831758757960377, 0.1524859820920097, 0.16436192737652233, 0.17688022339284237, 0.31874021133097663, 0.4181091965558946, 0.3397177907875464, 0.2704691425539575, 0.39611935558431144, 0.33997811845515313, 0.3058180709236248, 0.4570961161988947, 0.10585358172266623, 0.2581165538062884, 0.33323082901662937, 0.2719947591763514, 0.1895012735120103, 0.307083469363148, 0.3124434304315008, 0.22287075010918678, 0.32601479149945445, 0.15835465666301352, 0.20260022500293284, 0.1782804587003789, 0.18925187606682303, 0.14206006999136622, 0.17498420329402942, 0.20843978513811368, 0.15995312288897945, 0.17645928224434904, 0.15123767520296283, 0.18747011795340607, 0.46105849892130457, 0.14644836231595915, 0.1451442552846105, 0.1977027255651208, 0.17083785104913918, 0.18654274594623654, 0.18704659446850413, 0.11990543763019212, 0.08381044697047746, 0.1809154760060957, 0.69696092017169, 0.23530697671154222, 0.18621866073905824, 0.10087029557805238, 0.18044294369376346, 0.18141824544629004, 0.16377058245277443, 0.11239594568960043, 0.5881458209162733, 0.49199137581507735, 0.12350433255767201, 0.7742179403374103, 0.21027093643428185, 0.20683339684534952, 0.14978228956295903, 0.1596528653269157, 0.17568663907038795, 0.18322561530887782, 0.17250629579637822, 0.14997967461404405, 0.17484125032194864, 0.1740214930436026, 0.1868146805117148, 0.17351320192085296, 0.04900077916426149, 0.0679042800291636, 0.07601282696741563, 0.07912305483143778, 0.04450639556912339, 0.06740667370757925, 0.0641119141169274, 0.04078441433350888, 0.07831412103471447]}, "mutation_prompt": null}
{"id": "fa74677e-a4db-4f2e-8788-8e8240e0a956", "solution": "import numpy as np\n\nclass EnhancedDES3D_MultiPop:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.num_subpops = 3\n        self.subpopulations = [self.population[i::self.num_subpops] for i in range(self.num_subpops)]\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx, subpop):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx, subpop)\n        return mutant, strat_index\n\n    def rand_1(self, idx, subpop):\n        candidates = [i for i in range(len(subpop)) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return subpop[r1] + self.F * (subpop[r2] - subpop[r3])\n\n    def rand_2(self, idx, subpop):\n        candidates = [i for i in range(len(subpop)) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return subpop[r1] + self.F * (subpop[r2] - subpop[r3]) + self.F * (subpop[r4] - subpop[r5])\n\n    def current_to_best_with_elite(self, idx, subpop):\n        elite_size = int(self.elite_fraction * len(subpop))\n        elite_indices = np.argsort([self.func(ind) for ind in subpop])[:elite_size]\n        best_elite = subpop[np.random.choice(elite_indices)]\n        candidates = [i for i in range(len(subpop)) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return subpop[idx] + self.F * (best_elite - subpop[idx]) + self.F * (subpop[r1] - subpop[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for subpop in self.subpopulations:\n                for i in range(len(subpop)):\n                    target = subpop[i]\n                    mutant, strat_index = self.mutate(i, subpop)\n                    mutant = np.clip(mutant, self.lb, self.ub)\n                    trial = self.crossover(target, mutant)\n                    trial_fitness = self.evaluate(trial)\n                    target_fitness = self.evaluate(target)\n                    if trial_fitness < target_fitness:\n                        subpop[i] = trial\n                        self.history[strat_index] += 1\n                        self.success_rates[strat_index] += 1\n                    else:\n                        self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_MultiPop", "description": "Adaptive Differential Evolution with Multi-population Strategy Enhancements for Diversified Search.", "configspace": "", "generation": 37, "fitness": 0.14642191400459087, "feedback": "The algorithm EnhancedDES3D_MultiPop got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.12.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.25342648398876666, 0.17289039445665644, 0.2913590196428091, 0.1324723427237664, 0.22593737487358412, 0.18994976649410122, 0.39188564031065376, 0.15458184870621716, 0.23850974569881034, 0.004963317976205861, 0.3418494516218261, 0.000995472137927611, 0.11299840487423685, 0.3019606437829586, 9.999999999998899e-05, 0.002630647101022787, 9.999999999998899e-05, 9.999999999998899e-05, 0.12026300481155572, 0.09600637442606508, 0.10215429401637177, 0.07025529678377529, 0.061918546097001315, 0.08248097314718383, 0.09587318927021027, 0.10456441294372631, 0.08435058052190547, 0.10806700385683199, 0.08756184753960605, 0.06285947786120905, 0.0964890324890606, 0.06266907928151899, 0.056535755595304216, 0.11728151068802928, 0.08114622780628433, 0.06292195848090687, 0.35774786077168497, 0.8756011530828376, 0.05911488427948042, 0.5871625277157848, 0.07536652576613068, 0.10590859918386974, 0.3141640573056116, 0.08826715492851966, 0.10128851803075645, 0.07601158594333046, 0.2262691861859596, 0.13441324437665025, 0.058167610331567254, 0.13564928907847695, 0.05011345825245184, 0.06909722488989667, 0.21250883141340393, 0.021097084268151933, 0.19283154141597614, 0.19453688715447137, 0.1588804517965393, 0.27272070049795494, 0.2516878418628764, 0.1457562322761038, 0.12459691382817906, 0.5630677940520337, 0.20892578770180603, 0.05900058497701355, 0.10554069890963658, 0.19092929941717152, 0.03687488863797572, 0.06352758545612669, 9.999999999998899e-05, 0.09110035544645867, 0.12034285765890385, 0.15464091476199027, 0.11220695865131569, 0.18354920713520873, 0.01344801707567389, 0.15518824002066234, 0.14530921951372877, 0.06701546422548732, 0.08343556030123922, 0.17882986520440058, 0.12626752091767535, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06849909286175027, 9.999999999998899e-05, 0.05112297323388304, 0.018807861610747767, 9.999999999998899e-05, 0.1423293456500616, 0.07022664129896561, 0.14457733508823079, 0.12622410166649756, 0.06886019074959038, 0.040329435783642786, 0.11137582638432941, 0.07640299737069833, 0.05399805809667835, 0.0075662832145330094, 9.999999999998899e-05, 9.999999999998899e-05, 0.049405835119690544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07051760701628595, 9.999999999998899e-05, 0.11482189693954259, 0.07163067537594447, 0.05398447412795704, 0.02767167284431893, 9.999999999998899e-05, 0.037946397240879226, 0.03088394849688736, 0.13030369436715794, 9.999999999998899e-05, 0.3440306072246173, 0.4842629420136988, 0.23474460458152624, 0.4044235633975909, 0.4372310918402411, 0.2745682570281639, 0.39726187823535963, 0.20245021017731812, 0.23264607881180832, 0.0795286460685587, 0.09378607273955009, 0.07539978603114705, 0.10084228425870767, 0.09689137377516932, 0.055348682066135746, 0.07187078044006068, 0.0556658289647286, 0.06549740619721, 0.19854476886444217, 0.1107675700991444, 0.1046064031789572, 0.13522868354692397, 0.1422338402680553, 0.14448491903370397, 0.19181367753242506, 0.1377601821550246, 0.09815017163860795, 0.2894160014642152, 0.15992543235380186, 0.23419157580351613, 0.30214555054136816, 0.3081855356333333, 0.21257701522386052, 0.22199504278159443, 0.23893840129545296, 0.22268739209778954, 0.2361466368277072, 0.10192887611367718, 0.2738175033755137, 0.26721675456978033, 0.18294201697135792, 0.24092931693772612, 0.19548139524813446, 0.1667579221100668, 0.12170948402266091, 0.1899347459017774, 0.1956276792100342, 0.1997879516697061, 0.17593777912192055, 0.15668403877830317, 0.1991257001312584, 0.20622140853332205, 0.17167461709153253, 0.18940452173620925, 0.17886759300918098, 0.19743234675911503, 0.18355795911757034, 0.2081287483769162, 0.1604922858288801, 0.16805455598687025, 0.1774088410192458, 0.20775835110064622, 0.01956661034739826, 0.1535607796841183, 0.5602292273339096, 0.17736052985238948, 0.1778265311997973, 0.19401347675113378, 0.28416550207327107, 0.17445130619372962, 0.17523578862967037, 0.15809599469731406, 0.25717118120399685, 0.16813695231019465, 0.28875948486730174, 0.15250647239584236, 0.14728781354698584, 0.2232823244755553, 0.18989491790591528, 0.10505894113729686, 0.21967132124662425, 0.19224924137335853, 0.16060220068512066, 0.1803059429396512, 0.18985105852569983, 0.16923447256706337, 0.14360640643582323, 0.19208255686409426, 0.18761355870195007, 0.16499726408860238, 0.05922147249998522, 0.07041876491572108, 0.09391508665754078, 0.07207035980179899, 0.06745810819048859, 0.08802578970918273, 0.060653815818793366, 0.05294124294999625, 0.05522399025585678]}, "mutation_prompt": null}
{"id": "2df8c799-aae4-4651-9339-e171c32a287b", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6\n        self.CR = 0.85\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.25\n        self.adaptive_factor = 0.15\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive_V2", "description": "Adaptive Differential Evolution with Elite and Stochastic Parameter Tuning for Improved Convergence.", "configspace": "", "generation": 38, "fitness": 0.24813069651269384, "feedback": "The algorithm EnhancedDES3D_Adaptive_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.6330840706066938, 0.615864236681277, 0.7352222341716226, 0.675547988789836, 0.5978302461917855, 0.5387264325854788, 0.23424419897957938, 0.27534450948543143, 0.15870031444165766, 0.4831160621744034, 0.3867461094967982, 0.5375386710714101, 0.4529993664863867, 0.3464168833646093, 0.5384145435092, 9.999999999998899e-05, 0.3915716499790608, 0.4800685231620817, 0.0813845235378321, 0.0815932668717112, 0.10672188375525404, 0.08146665489610971, 0.08605949949463287, 0.08296429970215669, 0.08393453467387102, 0.08494241806579994, 0.054040925300218645, 0.10750021614976268, 0.0816856409622837, 0.10603188644406525, 0.09468888066978998, 0.036733467334731595, 0.09039969756880306, 0.08323752374972881, 0.07914653492710699, 0.1005906244920971, 0.9132273977927242, 0.8814500576759292, 0.7888103304637997, 0.899483736584749, 0.9772674327509808, 0.9145090862091053, 0.8911785339238639, 0.9072418714718511, 0.08163260576239373, 0.0857285178956827, 0.24438626465265767, 0.06260385398930723, 0.3154199730226701, 0.08321147738829227, 0.3833263871933602, 0.34201346056715254, 0.31935656778048593, 0.38731857009989745, 0.618563783153061, 0.5276085936690261, 0.37847684197608156, 0.3463077854097393, 0.559325534332719, 0.6581901579801448, 0.35660434381604755, 0.4587603393674734, 0.6906109629439164, 0.04814669558420648, 0.037561900475660326, 0.05956239286578513, 0.05156122574561617, 0.09334619621861562, 0.21871321391291543, 0.03983739742292669, 0.23847101475873345, 0.290275760477854, 0.053064898367866764, 0.032546135599981096, 0.15049135947978143, 0.20778289047007548, 0.06535979952363924, 0.17255202095601507, 0.17320488679918922, 0.01872242809684299, 0.17505677628151117, 0.2861114564302185, 9.999999999998899e-05, 0.32579947622067806, 0.30932594789401824, 0.18254950715659857, 0.355241653077481, 0.2916780460793248, 0.0005145291375471261, 9.999999999998899e-05, 0.019348816235380983, 0.2530558817522598, 0.36828579892385094, 0.17817580425771662, 0.2790746858893747, 0.20065304860494526, 0.27312083676632337, 0.32487765713422645, 0.5000663666043084, 0.08878895441183665, 0.0013370999379279658, 0.09885750424498452, 9.999999999998899e-05, 0.06900197201633107, 0.15927816267596806, 0.15396802600654558, 0.04300199107900993, 0.1470156703370984, 0.020765839505065053, 0.19064194921834365, 0.24944426490516536, 9.999999999998899e-05, 0.1666868536451973, 0.2693716317940916, 0.24123454569472502, 0.16956492076504603, 0.2634833823877515, 0.2066577043845773, 0.5298988284584591, 0.5856446241048769, 0.5781746946194819, 0.5029045923925861, 0.6055893041374331, 0.6297576592907064, 0.7087481388521242, 0.6447366340062064, 0.08613191409560672, 0.08150596189531589, 0.09514983788470655, 0.04792818388843456, 0.04868560899750085, 0.08004203617528438, 0.046208025381302864, 0.06263923557041384, 0.08786697153739842, 0.1566890828230667, 0.07325961246474655, 0.12348783561235488, 0.12686525503275548, 0.16030105102189596, 0.12364256048627087, 0.15528464383603457, 0.1501389880730981, 0.18353541585090993, 0.16220469807073712, 0.27772704979092033, 0.3209550924768665, 0.27086797416871733, 0.29167197354250807, 0.3183750542225775, 0.30932958316785797, 0.28313214786524143, 0.35129428459210166, 0.10054950506668014, 0.19704857671486875, 0.25236652764909595, 0.22794150445706274, 0.19724743691465585, 0.24386571298905002, 0.22030665784065373, 0.22171163279007366, 0.2959540687012221, 0.18500277188889713, 0.17813222169525567, 0.1731610875745453, 0.13909799625661567, 0.17225062891753007, 0.20906049570696705, 0.1823292442870541, 0.14497960317145353, 0.17736055925467153, 0.12654927830810758, 0.16406765873800522, 0.2508801523430765, 0.14257559409984255, 0.11310019497848245, 0.1916596140744442, 0.16886272012007686, 0.1707117854581358, 0.18807929527674994, 0.12005087387637325, 0.13345874310404904, 0.19668556798080405, 0.1859742715071151, 0.2954418586320572, 0.1776242749482284, 0.10551196070382407, 0.16811485884184185, 0.14108704619268841, 0.33920887248392995, 0.13661378805947666, 0.7528108436196373, 0.5639209808357911, 0.15121964476706395, 0.18712550797527783, 0.2079033489291846, 0.6711522532690357, 0.2079742326541112, 0.19063642144065285, 0.1541176827520856, 0.164509847350095, 0.1467652367570429, 0.16811766851720877, 0.1508922735822955, 0.19195348430497994, 0.18473435479875844, 0.18848987553310736, 0.0682360212812031, 0.07918561507868382, 0.06364191090554505, 0.062377878136012255, 0.04151981610932198, 0.05727620804686506, 0.051457885378231705, 0.0382499649633703, 0.06605232790863524]}, "mutation_prompt": null}
{"id": "e52a65a7-9064-44b5-a107-414f19dc0a02", "solution": "import numpy as np\n\nclass HybridDESM_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.memory = []\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_memory]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_memory(self, idx):\n        if self.memory:\n            best_memory = min(self.memory, key=self.func)\n        else:\n            elite_size = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_memory = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_memory - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n            self.memory.append(np.copy(solution))\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "HybridDESM_Adaptive", "description": "Hybrid Differential Evolution with Adaptive Parameter Control and Memory-Based Strategy Selection for Improved Performance.", "configspace": "", "generation": 39, "fitness": 0.27841956069292934, "feedback": "The algorithm HybridDESM_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.7070275660496457, 0.6976758642813665, 0.8249560365645467, 0.7135564498548673, 0.6980792881358582, 0.6082111095398048, 0.3734579502953005, 0.27696693731013944, 0.36427157870153426, 0.032164524019263285, 0.5017263498823592, 0.641346102693787, 0.08215023296134805, 0.47746930155637046, 0.6177307151659999, 0.5514128724019964, 0.45391906162221607, 0.6154192719556191, 0.07982279655212365, 0.08506514004879373, 0.10845654832705454, 0.10766364905696046, 0.09993432772453359, 0.11096370922348575, 0.08903757090058284, 0.08898696396394878, 0.0659441089952092, 0.08025568780170966, 0.07809124623156571, 0.10250934344231877, 0.07043879811216303, 0.08068571259936219, 0.1127385289189029, 0.09798800550701636, 0.09173769839002632, 0.0995273895268245, 0.905857665446329, 0.7502569496394824, 0.8336260253884609, 0.8971488513175854, 0.8375879368382343, 0.7807573079792814, 0.8714519911128409, 0.9617477546778348, 0.10470406306146562, 0.3323103913003088, 0.37050368888354446, 0.1284710503547185, 0.31268832728151563, 0.1520869641467969, 0.4368897734266216, 0.3676004547642129, 0.3367876116008809, 0.4269857995883749, 0.30634449786967444, 0.6721566312998736, 0.7539498532533195, 0.24665329074979858, 0.596281284316918, 0.7521340956067398, 0.21235676336489973, 0.6406653276983381, 0.7756299921336953, 0.11223083398376221, 9.999999999998899e-05, 0.04800806457066009, 0.19566819577275352, 0.06530647334569117, 0.19876928942822747, 0.13406876512180954, 0.23984279624636928, 0.575929582924157, 0.1137146683317114, 0.0991429957386546, 0.1838684212307795, 0.1460296603562229, 0.1117423929323057, 0.4049089351806998, 0.11225156705700956, 0.07640084986570839, 0.1927929308438341, 0.33163597308535897, 0.21000746327494957, 0.3400847006320954, 0.4162523195274622, 0.27472518997757545, 0.5162914557735374, 0.02332285710986093, 0.20475564355990594, 0.11782119008318481, 0.09155873291857353, 0.40943193710370007, 0.608678355307882, 0.153546721570342, 0.4186925374079178, 0.062008901251142, 0.16526494322497365, 0.4342912174674408, 0.6506785862677416, 0.0002776300864792969, 0.06092343118340526, 0.13977104139014662, 9.999999999998899e-05, 0.06198931160356658, 0.296690545204513, 0.13301695227076193, 0.0705602320429678, 0.168225066831848, 0.03485841562016123, 0.20928623508619626, 0.2943180102437887, 0.09341175243991784, 0.2551975055918718, 0.3631358867984339, 0.29256736940332717, 0.2040483880557763, 0.384491403716995, 0.3616911553598915, 0.5744026167996734, 0.7479809550052747, 0.4590240937554755, 0.5535462972888043, 0.6903466569543111, 0.4100281511762459, 0.35039302505092607, 0.6895869565642003, 0.060415792039843486, 0.09386070781461242, 0.08748750315534759, 0.06414481859070598, 0.09320711335805443, 0.08964743960578758, 0.07779462606505405, 0.07871080659042506, 0.0851759859023794, 0.17797120927288912, 0.14055518296009506, 0.12631630523878035, 0.16683915483138467, 0.12955345460189926, 0.15337496701804743, 0.13831758757960377, 0.1524859820920097, 0.16436192737652233, 0.28931206381769903, 0.31874021133097663, 0.4181091965558946, 0.3397177907875464, 0.2704691425539575, 0.39611935558431144, 0.17190753290071847, 0.3058180709236248, 0.4570961161988947, 0.21939308375641087, 0.2581165538062884, 0.33323082901662937, 0.2719947591763514, 0.1895012735120103, 0.307083469363148, 0.20451075191205492, 0.22287075010918678, 0.32601479149945445, 0.21084919249343415, 0.20260022500293284, 0.1782804587003789, 0.1944735356517454, 0.16552574170966305, 0.17498420329402942, 0.16110377932524933, 0.17091740022959634, 0.17645928224434904, 0.18114518217745412, 0.18747011795340607, 0.46105849892130457, 0.1842459172112545, 0.1854744885712023, 0.1977027255651208, 0.17171976966099478, 0.18654274594623654, 0.18704659446850413, 0.34510276116955596, 0.17454716512881185, 0.1809154760060957, 0.4320409989292443, 0.23530697671154222, 0.18621866073905824, 0.11248366427822387, 0.18044294369376346, 0.18141824544629004, 0.13230123530158522, 0.3015193149299956, 0.5881458209162733, 0.49199137581507735, 0.15058949798047438, 0.7742179403374103, 0.21027093643428185, 0.20683339684534952, 0.14978228956295903, 0.14622230653688129, 0.17568663907038795, 0.18322561530887782, 0.16068180452842917, 0.14997967461404405, 0.17484125032194864, 0.1740214930436026, 0.1868146805117148, 0.17351320192085296, 0.058636106847839486, 0.0679042800291636, 0.07601282696741563, 0.07912305483143778, 0.0731428614604216, 0.06740667370757925, 0.0641119141169274, 0.06631472315374198, 0.07831412103471447]}, "mutation_prompt": null}
{"id": "d65bf113-d795-412f-ab9b-40e368a08b2e", "solution": "import numpy as np\n\nclass HybridDE_MultiExploitation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6\n        self.CR = 0.85\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(4)\n        self.func = None\n        self.success_rates = np.zeros(4)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.15\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(4) / 4\n        return np.random.choice(4, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite, self.best_2]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def best_2(self, idx):\n        best_idx = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx and i != best_idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[best_idx] + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.96\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "HybridDE_MultiExploitation", "description": "A hybrid Differential Evolution using dynamic strategy selection and adaptive control with multi-exploitation path approach.", "configspace": "", "generation": 40, "fitness": 0.13997113863226346, "feedback": "The algorithm HybridDE_MultiExploitation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.15.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.22548096191421985, 0.21078550122107065, 0.4656337145548489, 0.18059793942559788, 0.17425999691424954, 0.5300936470098261, 0.24684671387521828, 0.2408394294675008, 0.2378876087182934, 9.999999999998899e-05, 9.999999999998899e-05, 0.2964999901435236, 0.0005233451572583814, 0.0023027139898166293, 0.5265325115100417, 9.999999999998899e-05, 0.0011144817814363606, 0.25911586547614585, 0.06050840403313362, 0.04397505766329668, 0.08968039415241147, 0.04881896683208453, 0.053170099414848626, 0.08881887136646016, 0.04972436621990983, 0.041605387384292536, 0.049659573697460435, 0.04535379753864632, 0.030244194757387044, 0.11628121706621808, 0.08133179642632382, 0.03618456688956306, 0.07176534211187158, 0.028436920461806015, 0.02679971282597582, 0.06927683548182262, 0.15308427103742883, 0.15060218829613947, 0.8922336486975011, 0.6055702116421766, 0.17434426036525397, 0.9671060262831842, 0.10655079886378516, 0.14814569358447605, 0.7617388052671971, 0.11828097443370789, 0.07191817865381878, 0.11166246420859227, 0.10519896592274258, 0.08363406704303034, 0.14868488012248438, 0.09944862453687187, 0.09159169013111934, 0.22217236133423957, 0.16538843537051562, 0.1512904027325005, 0.3464967987975597, 0.17818493323393902, 0.1848669270758403, 0.6709427407399449, 0.10192041838844101, 0.1413132967777394, 0.6273132450685721, 0.01140141854511545, 0.028326346661480928, 0.04103643979479499, 0.042929341961265854, 0.058093119499993184, 0.05333139610118942, 0.058303454290080325, 0.036034995108605083, 0.09868673114505311, 0.017447115720672812, 0.04204693965592565, 0.15295483185657466, 0.05253633658533241, 0.018386557134946302, 0.15424932393705437, 0.057441734195032734, 0.013152041688302085, 0.0461569205580441, 9.999999999998899e-05, 9.999999999998899e-05, 0.04810420411591365, 9.999999999998899e-05, 9.999999999998899e-05, 0.3043138637156245, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04265116271729508, 0.017066588924820825, 0.20351592084708758, 0.019953166715115045, 0.016078973722471024, 0.18786771839822303, 0.024215835444551304, 0.01979173051386829, 0.23847285009843855, 9.999999999998899e-05, 9.999999999998899e-05, 0.09444346472646226, 9.999999999998899e-05, 9.999999999998899e-05, 0.16095248932836947, 9.999999999998899e-05, 9.999999999998899e-05, 0.009310090672638771, 0.007560918406936401, 0.0205321685290617, 0.23562488639620716, 0.0001147035037327715, 0.010647707416287955, 0.24009608960435824, 0.010847579067559288, 0.01395813258147427, 0.11793585396171369, 0.24304021400307185, 0.21437712582023727, 0.3834939935203684, 0.23394037270614298, 0.2249447893751877, 0.40926740533944894, 0.24230890180401599, 0.20537086136015148, 0.5964618067556713, 0.04827114653990372, 0.04642997975655161, 0.08432130593445131, 0.03544899034158644, 0.045241056878835284, 0.08829611653776648, 0.049481781503743716, 0.052884999332104554, 0.08320069623901238, 0.10530088191901321, 0.08997736237263454, 0.1253036149075506, 0.09855305120349966, 0.10852972522114013, 0.11072942708061095, 0.09925240232394572, 0.10357485147590051, 0.13525219192552307, 0.3000575941940279, 0.15975100471164572, 0.32084956406660037, 0.15387281580558698, 0.15446104278652661, 0.2885314504135905, 0.16364622244528804, 0.1910447025014851, 0.3406379354315058, 0.1274190644660652, 0.10644785398374401, 0.25024577228965805, 0.10839189516472558, 0.1013369139949104, 0.2512269160042033, 0.12388394389224455, 0.11990013927365761, 0.27338979826726006, 0.1741380945753599, 0.15077689174384412, 0.1639653739474115, 0.13468821213364768, 0.14407792559850208, 0.13085688535967477, 0.143965275594085, 0.12784345533253672, 0.13603765723819938, 0.12667537805275353, 0.12087287242237343, 0.20140704804678056, 0.14087557056363276, 0.12489856557709389, 0.1624247485930408, 0.16732801942173114, 0.1401542999167068, 0.17183893856275967, 0.12283257813462511, 0.09498067088176865, 0.14773428707318892, 0.13051220403652586, 0.1207914665021157, 0.5037136100369224, 0.08768934176557519, 0.11329697364078584, 0.13519557474158483, 0.11481955650625408, 0.11385169028550479, 0.15695531893079928, 0.07668005581384463, 0.08066375934434278, 0.13672005842027102, 0.184330773508654, 0.10602927813303398, 0.20797373064557656, 0.15634325496645052, 0.1690676991162523, 0.16465197311338398, 0.14382546810317087, 0.15584146216622885, 0.16551609377499876, 0.15520377815150643, 0.17161358567753615, 0.17739769075049538, 0.03478862755467438, 0.04599882709005376, 0.04303819252995855, 0.051298199119397814, 0.0493831660394739, 0.05721351485307313, 0.047755014320445155, 0.05186923292448553, 0.05900796342598602]}, "mutation_prompt": null}
{"id": "7a5f7e7d-4088-4df6-9709-32a7693a4e21", "solution": "import numpy as np\n\nclass AdaptiveDES4D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 6 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.25\n        self.adaptive_factor = 0.15\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDES4D_Adaptive", "description": "Adaptive Differential Evolution with Enhanced Exploration Strategies and Dynamic Parameter Tuning for Efficient Global Optimization.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {}, "mutation_prompt": null}
{"id": "dd495df1-86de-49ec-a333-df82d66e3105", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.ones(3) / 3  # Start with equal success rates\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.mutation_scaling_factor = 0.05\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        scaled_diff = self.F * (self.population[r2] - self.population[r3])\n        return self.population[r1] + scaled_diff + self.mutation_scaling_factor * np.random.randn(self.dim)\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return (self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + \n                self.F * (self.population[r4] - self.population[r5]))\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.mutation_scaling_factor = np.clip(self.mutation_scaling_factor + 0.02 * (np.random.rand() - 0.5), 0.01, 0.1)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive_v2", "description": "EnhancedDES3D_Adaptive_v2: Augmented Differential Evolution with Adaptive Strategy Switching and Fitness-Based Mutation Scaling for Robust Optimization Performance.", "configspace": "", "generation": 42, "fitness": 0.1228277679728117, "feedback": "The algorithm EnhancedDES3D_Adaptive_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.2856111736149721, 0.3504129977003927, 0.3226575498419314, 0.30572944866984253, 0.3967198524529181, 0.278862048406441, 0.3163968480379037, 0.22421816956923246, 0.16431235958484103, 0.02811060576915403, 0.060810156291168815, 0.05995785469353776, 0.011439577522711075, 0.008079386353844753, 9.999999999998899e-05, 0.005417932723032259, 0.04903594485225948, 0.05054018459307896, 0.055691703677488436, 0.05423672011697567, 0.056726238749525315, 0.08074080140514983, 0.06884093026881732, 0.07460662569790599, 0.08364557311114096, 0.06638721884850707, 0.08482861184790036, 0.04875286195961892, 0.033637229256831436, 0.03585532779148182, 0.06834073552351616, 0.031099068426263643, 0.049481084226794314, 0.04833505491947743, 0.05116160369220746, 0.03474908012738065, 0.5333942079987186, 0.44855442077482555, 0.08091923752170549, 0.16660290807745914, 0.13030042539736264, 0.24111996584437745, 0.12582072814523904, 0.5621881607264501, 0.16129103697920932, 0.06888767096225978, 0.10272465842064504, 0.14233391921565874, 0.11286692342432647, 0.06858627884332202, 0.06923705995190466, 0.07789239935267522, 0.08151727272831122, 0.16677924944228872, 0.20604749833857827, 0.20967677495246684, 0.1988730722454113, 0.22080155441549154, 0.35603961142016993, 0.21134274224648908, 0.13168998546170385, 0.2505536135589195, 0.20809078078393184, 0.07243897273210331, 0.05700057597839514, 0.08314571378001534, 0.03362740429612565, 0.0529353042438242, 0.0748037654416368, 0.051800621523796164, 0.05845133492718302, 0.06463027741966432, 0.08891402194172837, 0.07671742610957244, 0.0619140347592233, 0.04461746247707721, 0.0497910794250116, 0.08034762199317169, 0.07696826016540703, 0.07006166400449021, 0.09014638674040254, 0.008084362598053119, 9.999999999998899e-05, 9.999999999998899e-05, 0.01377313196810015, 0.015595640783546694, 0.03692650249224971, 0.0002143236190534914, 9.999999999998899e-05, 9.999999999998899e-05, 0.12724717669898422, 0.15285159926780068, 0.15543170274030527, 0.060476864405488384, 0.10554300484116397, 0.049041155034485584, 0.06423061853894363, 0.062246836176904075, 0.11482958360355788, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005193538251945351, 0.0717604249562126, 0.02288926146687187, 9.999999999998899e-05, 0.03538251796368075, 0.03513110962943977, 0.043934390569568826, 0.04643222138119818, 0.031402164750837125, 0.20989784027640768, 0.30328033676302024, 0.2728029355200846, 0.30095816553960486, 0.27883523301395885, 0.36219953417431083, 0.2874892655795377, 0.28438225181971466, 0.3064944752853619, 0.05037761701560761, 0.06892750582351148, 0.06458312072947081, 0.06851548556850706, 0.03748120428045132, 0.0620122217739596, 0.061722768474433365, 0.05926624150412585, 0.06583697953917855, 0.1134480160270196, 0.09775447785384528, 0.09337824978770659, 0.12376974511229033, 0.11849434832911432, 0.11225505032043293, 0.12191676127621232, 0.1192955553475189, 0.1145220922804725, 0.2103053499019616, 0.22512853192977844, 0.20051380169387856, 0.19018317543236507, 0.19359178740463057, 0.20830762390131485, 0.19440624727973088, 0.24865859039652327, 0.18179157927257783, 0.13225486602158254, 0.15267855086935667, 0.14604368298790793, 0.14703078365090183, 0.13374848622394564, 0.1185814833956409, 0.1580067585498064, 0.20316100769895606, 0.11969237230450802, 0.17596022990439375, 0.14729089355577396, 0.1688534223890389, 0.1837843918595481, 0.14167838450734815, 0.14982519282973494, 0.18122579423011853, 0.1551105194418515, 0.15192341751340177, 0.1570196873182942, 0.13334373963939128, 0.1404942707050415, 0.14565142569727085, 0.15556157078022115, 0.1422169668753357, 0.15223947465176646, 0.164101039399571, 0.16333961487642357, 0.14376112045012324, 0.13884010853133555, 0.12075842246902124, 0.3703329017714494, 0.1564189971201858, 0.18818448006192856, 0.11521682046857551, 0.16249736416353355, 0.14725688725535457, 0.12239192346212713, 0.10979089181236146, 0.11051631887803126, 0.1428429853095915, 0.1224389660226507, 0.17983816118474039, 0.09420175332759084, 0.19476123609893725, 0.10041646149999583, 0.15566746375080853, 0.15981897057250483, 0.18609708886305543, 0.16578915894802015, 0.15331642897800024, 0.16311815624918014, 0.15943633724793926, 0.1676511542654362, 0.15268947533414012, 0.05714422890981952, 0.045453205567930866, 0.06257248242988012, 0.051444486215441954, 0.052897674342887835, 0.06380651004708959, 0.04574062455579131, 0.0470687768765794, 0.05902688772816944]}, "mutation_prompt": null}
{"id": "fd111b9f-6abe-4d9e-829d-a30d262fa32c", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive_V2", "description": "Adaptive Differential Evolution with Dynamic Strategy Selection and Self-Tuning Parameters for Improved Performance.", "configspace": "", "generation": 43, "fitness": 0.29048918231491166, "feedback": "The algorithm EnhancedDES3D_Adaptive_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.7070275660496457, 0.6976758642813665, 0.8249560365645467, 0.7135564498548673, 0.6980792881358582, 0.6082111095398048, 0.17252370807520168, 0.2953417847587101, 0.7914425862423057, 0.5519855427369996, 0.5017263498823592, 0.641346102693787, 0.5561446709480455, 0.47746930155637046, 0.6177307151659999, 0.5514128724019964, 0.45391906162221607, 0.6154192719556191, 0.09689926426397066, 0.08506514004879373, 0.10845654832705454, 0.10766364905696046, 0.09993432772453359, 0.11096370922348575, 0.08903757090058284, 0.08898696396394878, 0.04665361648306776, 0.12372470390716594, 0.024699290751816316, 0.10250934344231877, 0.11552625766892743, 0.042839324064342876, 0.1127385289189029, 0.09798800550701636, 0.09173769839002632, 0.0995273895268245, 0.905857665446329, 0.7502569496394824, 0.8336260253884609, 0.8971488513175854, 0.8375879368382343, 0.7807573079792814, 0.8714519911128409, 0.9617477546778348, 0.07254608519463912, 0.3323103913003088, 0.37050368888354446, 0.07948774639603107, 0.31268832728151563, 0.07604048247960493, 0.4368897734266216, 0.3676004547642129, 0.3367876116008809, 0.4269857995883749, 0.6884246076983395, 0.6721566312998736, 0.7539498532533195, 0.8153442801550554, 0.596281284316918, 0.7521340956067398, 0.8230308410938033, 0.6406653276983381, 0.7756299921336953, 0.040456623377359446, 0.04767541728735181, 0.07591747600033472, 0.08398829010822262, 0.04832764016288493, 0.19876928942822747, 0.07742711856326334, 0.23984279624636928, 0.575929582924157, 0.05853726965076311, 0.07831594250679352, 0.1838684212307795, 0.26189432660507705, 0.04355558273956017, 0.4049089351806998, 0.1596301187775252, 0.06487677669617664, 0.1927929308438341, 0.33163597308535897, 0.21000746327494957, 0.3400847006320954, 0.4162523195274622, 0.27472518997757545, 0.5162914557735374, 0.4134241739263649, 0.20475564355990594, 0.0010171816395663225, 0.0360544663277389, 0.40943193710370007, 0.608678355307882, 0.2503605076271056, 0.4186925374079178, 0.30537398770026103, 0.05830352165237451, 0.4342912174674408, 0.6506785862677416, 0.07852891398139816, 0.06092343118340526, 0.13977104139014662, 9.999999999998899e-05, 0.06198931160356658, 0.296690545204513, 0.13301695227076193, 0.0705602320429678, 0.168225066831848, 0.00125975226662689, 0.20928623508619626, 0.2943180102437887, 0.023363416132999193, 0.2551975055918718, 0.3631358867984339, 0.29256736940332717, 0.2040483880557763, 0.384491403716995, 0.2556627610107328, 0.5744026167996734, 0.7479809550052747, 0.4590240937554755, 0.5535462972888043, 0.6903466569543111, 0.6162921969003701, 0.5123442042739619, 0.6895869565642003, 0.05503127484949799, 0.09386070781461242, 0.08748750315534759, 0.04450186216483942, 0.04851231296065994, 0.08964743960578758, 0.07176110917115386, 0.07871080659042506, 0.0528695519233795, 0.17797120927288912, 0.09402778899897146, 0.12631630523878035, 0.16683915483138467, 0.12955345460189926, 0.15308370329498033, 0.13831758757960377, 0.1524859820920097, 0.16436192737652233, 0.17688022339284237, 0.31874021133097663, 0.4181091965558946, 0.3397177907875464, 0.2704691425539575, 0.39611935558431144, 0.33997811845515313, 0.3058180709236248, 0.4570961161988947, 0.10585358172266623, 0.2581165538062884, 0.33323082901662937, 0.2719947591763514, 0.1895012735120103, 0.307083469363148, 0.3124434304315008, 0.22287075010918678, 0.32601479149945445, 0.15835465666301352, 0.20260022500293284, 0.1782804587003789, 0.18925187606682303, 0.14206006999136622, 0.17498420329402942, 0.20843978513811368, 0.15995312288897945, 0.17645928224434904, 0.15123767520296283, 0.18747011795340607, 0.46105849892130457, 0.14644836231595915, 0.1451442552846105, 0.1977027255651208, 0.17083785104913918, 0.18654274594623654, 0.18704659446850413, 0.11990543763019212, 0.08381044697047746, 0.1809154760060957, 0.69696092017169, 0.23530697671154222, 0.18621866073905824, 0.10087029557805238, 0.18044294369376346, 0.18141824544629004, 0.16377058245277443, 0.11239594568960043, 0.5881458209162733, 0.49199137581507735, 0.12350433255767201, 0.7742179403374103, 0.21027093643428185, 0.20683339684534952, 0.14978228956295903, 0.1596528653269157, 0.17568663907038795, 0.18322561530887782, 0.17250629579637822, 0.14997967461404405, 0.17484125032194864, 0.1740214930436026, 0.1868146805117148, 0.17351320192085296, 0.04900077916426149, 0.0679042800291636, 0.07601282696741563, 0.07912305483143778, 0.04450639556912339, 0.06740667370757925, 0.0641119141169274, 0.04078441433350888, 0.07831412103471447]}, "mutation_prompt": null}
{"id": "15439a3b-c7ee-44a1-9821-e1b8a0096a75", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(20, 7 * dim)  # Increased population size for diversity\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.7  # Adjusted mutation factor for balance\n        self.CR = 0.8  # Lowered crossover rate for exploration\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(4)  # Added another strategy\n        self.func = None\n        self.success_rates = np.zeros(4)  # Track success for new strategy\n        self.elite_fraction = 0.25  # Increased elite fraction\n        self.adaptive_factor = 0.15  # Slightly higher for more parameter adaptation\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(4) / 4\n        return np.random.choice(4, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite, self.rand_to_best_2]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def rand_to_best_2(self, idx):\n        global_best = self.population[np.argmin([self.func(ind) for ind in self.population])]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (global_best - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.5, 1.0)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.6, 0.9)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.9\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive", "description": "Adaptive Differential Evolution with Hybrid Mutation Strategies and Success-Based Strategy Adaptation.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {}, "mutation_prompt": null}
{"id": "b489eac2-e2db-40c8-8629-30e8992033c1", "solution": "import numpy as np\n\nclass AdaptiveDE_Memory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6\n        self.CR = 0.85\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.ones(3) / 3\n        self.elite_fraction = 0.15\n        self.adaptive_factor = 0.05\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n    \n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_history[strat_index] += 1\n                    self.success_rates[strat_index] += 0.1\n                else:\n                    self.success_rates[strat_index] *= 0.9\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDE_Memory", "description": "Adaptive Differential Evolution with Memory-based Strategy Selection and Dynamic Parameter Adjustment.", "configspace": "", "generation": 45, "fitness": 0.11833821632187226, "feedback": "The algorithm AdaptiveDE_Memory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.27791814253594926, 0.308717371410279, 0.27085080483654334, 0.27740799891433654, 0.29345259915463284, 0.2823324852343905, 0.2822827486870775, 0.2570976342815434, 0.2769070759506491, 0.0400473515045322, 0.06762200944625874, 0.006475410428693484, 0.012315954652085015, 0.03126148718804289, 0.008878786897667856, 0.01809117709446706, 0.033754151954155875, 0.01167725036457834, 0.066860363228881, 0.06672213963899043, 0.06024825932095157, 0.05066750802445963, 0.08195650515820851, 0.04986850967630385, 0.07291495916862845, 0.07442316053177178, 0.06260405410914249, 0.05154690285731589, 0.050420738183366676, 0.05344509482733961, 0.04778022657264447, 0.06329782355125757, 0.04069225301978585, 0.04339164461990952, 0.04650341392007107, 0.04290660131690094, 0.16298611581265865, 0.19462573037080133, 0.11668593993964538, 0.38896614364066195, 0.18548154209663525, 0.9091723199763011, 0.18999447444750528, 0.23349217645051312, 0.4363334775873017, 0.0839842864005883, 0.12004606999985667, 0.07584617074994315, 0.09853111801647041, 0.0839990742756751, 0.09523412840077305, 0.15305582475762036, 0.11353700334190198, 0.11601757147005343, 0.18924569286660797, 0.20000401527002531, 0.12312901814442079, 0.24591523362579137, 0.18875185531975736, 0.1835996615260308, 0.18967619529054158, 0.17664488221096142, 0.192371172655326, 0.06298914408432554, 0.053511678823013775, 0.029954773778214205, 0.04871845008986364, 0.046400418878768, 0.050632339404327986, 0.09845348536079235, 0.05697038206134897, 0.07156265574453735, 0.06279532911784713, 0.0879889848444676, 0.08004450993153056, 0.05397871476049587, 0.07936677372351897, 0.06443294743624428, 0.04718006538687147, 0.04852797973702638, 0.055121651956527185, 0.017640271265360163, 0.001547817569932497, 9.999999999998899e-05, 0.008868359480512122, 0.029619470246778246, 0.001081191300205675, 9.999999999998899e-05, 9.999999999998899e-05, 0.009283469924762366, 0.07571983062381771, 0.06561708305590164, 0.11206590679043382, 0.046845285795085845, 0.06168870182801145, 0.04831173361062524, 0.1046243872955438, 0.06821373902682404, 0.06003711848390225, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026804916328480255, 0.03096002808905962, 0.04267408510934112, 0.01876473028290815, 0.03623759596041254, 0.03392452259679035, 0.05842891085872193, 0.03700869318313105, 0.0279687070715936, 0.27773637249670147, 0.23272636554974313, 0.2568006875236337, 0.2663859396987427, 0.3119129989475907, 0.25498478304081285, 0.2758865978362921, 0.2710569082919545, 0.2618392445150891, 0.06133592616513672, 0.06660110999512325, 0.057885712574054615, 0.060379953797815356, 0.05362327361013608, 0.054642489238855174, 0.060831533653061154, 0.05699132421384567, 0.054463225293315376, 0.10833142240036975, 0.10866607562818553, 0.10951308595647347, 0.11442543533096139, 0.10846925810047181, 0.10687026507196884, 0.15640404345904046, 0.12643112900526232, 0.11737798892983542, 0.18211500805735503, 0.20625394297221422, 0.19062061226051996, 0.19033141599903025, 0.1918934896257175, 0.20430451996487975, 0.19852211891674265, 0.21901608852798404, 0.17414415171023923, 0.1492391297266582, 0.13574825745789953, 0.140386349544802, 0.15080360898805611, 0.12425199810562049, 0.1335686278801148, 0.12278276748424011, 0.14041872607845685, 0.12513054213446828, 0.14564724673661744, 0.18383132321410045, 0.1427653300525884, 0.1436592124723316, 0.16684495606619754, 0.17414721401260957, 0.15588644585973666, 0.1533419888366645, 0.14951745323418286, 0.1448355537812347, 0.14613081007077267, 0.14714865529759957, 0.15117417020696788, 0.13447790643577606, 0.14415086783345576, 0.16056166242111636, 0.15560524041350599, 0.14178395261130916, 0.13870162771021444, 0.12600480239321898, 0.1169789238191421, 0.18180379880529263, 0.13548195589417833, 0.2194481323229902, 0.15119204169857514, 0.12733514233561216, 0.13085095890099874, 0.12331125444363311, 0.11210316100323925, 0.1394743720395194, 0.10903977181266655, 0.1217673121644135, 0.143779730882582, 0.17719170505536042, 0.12404402644741241, 0.18045261748501085, 0.14719609909352616, 0.15014563601383457, 0.1638842869456827, 0.17173650309078237, 0.150228697157476, 0.16863653387326816, 0.17510875556484973, 0.16198312705187656, 0.17197933451018055, 0.052202425495507354, 0.038877802317279886, 0.046479223821806914, 0.07576363072947856, 0.042444198993161764, 0.059713627257229174, 0.046895444901197125, 0.056895347059406465, 0.0538738873135306]}, "mutation_prompt": null}
{"id": "12f02cba-c6e5-4e76-bc26-2372b6f9dfef", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.success_rates = np.zeros(3)\n        self.history = np.zeros(3)\n        self.adaptive_factor = 0.1\n        self.func = None\n        self.elite_fraction = 0.2\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_rand_with_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_rand_with_best(self, idx):\n        best_idx = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (self.population[best_idx] - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 1.0)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive_V2", "description": "EnhancedDES3D_Adaptive_V2: Improved Differential Evolution with Dynamic Strategy and Adaptive Scaling for Enhanced Optimization.", "configspace": "", "generation": 46, "fitness": 0.26553450121701355, "feedback": "The algorithm EnhancedDES3D_Adaptive_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.7070275660496457, 0.6976758642813665, 0.8249560365645467, 0.7135564498548673, 0.6980792881358582, 0.6082111095398048, 0.3039120342682027, 0.285274734116856, 0.2727482254139413, 0.021507710396114765, 0.5017263498823592, 0.641346102693787, 0.016337691149890587, 0.47746930155637046, 0.6177307151659999, 0.5514128724019964, 0.45391906162221607, 0.6154192719556191, 0.05711292706195148, 0.08506514004879373, 0.10845654832705454, 0.10766364905696046, 0.09993432772453359, 0.11096370922348575, 0.08903757090058284, 0.08898696396394878, 0.06685687034336074, 0.048820293380825386, 0.0778905092848432, 0.10250934344231877, 0.06061859484575105, 0.08048127052339182, 0.1127385289189029, 0.09798800550701636, 0.09173769839002632, 0.0995273895268245, 0.905857665446329, 0.7502569496394824, 0.8336260253884609, 0.8971488513175854, 0.8375879368382343, 0.7807573079792814, 0.8714519911128409, 0.9617477546778348, 0.08982612611411167, 0.3323103913003088, 0.37050368888354446, 0.12892284156801304, 0.31268832728151563, 0.10311360325471874, 0.4368897734266216, 0.3676004547642129, 0.3367876116008809, 0.4269857995883749, 0.18442864044223062, 0.6721566312998736, 0.7539498532533195, 0.20934362706927812, 0.596281284316918, 0.7521340956067398, 0.1158151892913315, 0.6406653276983381, 0.7756299921336953, 0.04034446629459909, 9.999999999998899e-05, 0.038629267571498316, 0.07449042639086056, 0.09106542502297632, 0.19876928942822747, 0.06727147093916919, 0.23984279624636928, 0.575929582924157, 0.07281749650026248, 0.044487158170471774, 0.1838684212307795, 0.08059096408797428, 0.05623541648864516, 0.4049089351806998, 0.07070648033688798, 0.03771917831081095, 0.1927929308438341, 0.33163597308535897, 0.21000746327494957, 0.3400847006320954, 0.4162523195274622, 0.27472518997757545, 0.5162914557735374, 0.00011110300606542722, 0.20475564355990594, 9.999999999998899e-05, 0.04649237360078873, 0.40943193710370007, 0.608678355307882, 0.045808230786377524, 0.4186925374079178, 0.30537398770026103, 0.07986655795500397, 0.4342912174674408, 0.6506785862677416, 9.999999999998899e-05, 0.06092343118340526, 0.13977104139014662, 9.999999999998899e-05, 0.06198931160356658, 0.296690545204513, 0.13301695227076193, 0.0705602320429678, 0.168225066831848, 0.05657632506806709, 0.20928623508619626, 0.2943180102437887, 0.03902562786963426, 0.2551975055918718, 0.3631358867984339, 0.29256736940332717, 0.2040483880557763, 0.384491403716995, 0.26326787222774006, 0.5744026167996734, 0.7479809550052747, 0.4590240937554755, 0.5535462972888043, 0.6903466569543111, 0.2741434203436537, 0.22542980223286524, 0.6895869565642003, 0.051452753898843184, 0.09386070781461242, 0.08748750315534759, 0.05192787988809411, 0.08005948640682492, 0.08964743960578758, 0.05347313135207099, 0.07871080659042506, 0.060525709040397446, 0.17797120927288912, 0.14028954261528126, 0.12631630523878035, 0.16683915483138467, 0.12955345460189926, 0.15308370329498033, 0.13831758757960377, 0.1524859820920097, 0.16436192737652233, 0.17788740517699875, 0.31874021133097663, 0.4181091965558946, 0.3397177907875464, 0.2704691425539575, 0.39611935558431144, 0.15986514859216372, 0.3058180709236248, 0.4570961161988947, 0.13950860704490164, 0.2581165538062884, 0.33323082901662937, 0.2719947591763514, 0.1895012735120103, 0.307083469363148, 0.1316924019269129, 0.22287075010918678, 0.32601479149945445, 0.18690372565134972, 0.20260022500293284, 0.1782804587003789, 0.16915011676356428, 0.15121567915213385, 0.17498420329402942, 0.12995531587262865, 0.16632806636151432, 0.17645928224434904, 0.1515069806106476, 0.18747011795340607, 0.46105849892130457, 0.15361433180138828, 0.13507355032853907, 0.1977027255651208, 0.14812900093646697, 0.18654274594623654, 0.18704659446850413, 0.14819705555385898, 0.1399113527571928, 0.1809154760060957, 0.20862139511232947, 0.23530697671154222, 0.18621866073905824, 0.08448849460797869, 0.18044294369376346, 0.18141824544629004, 0.24568819483658577, 0.1992978624267212, 0.5881458209162733, 0.49199137581507735, 0.15032479269344856, 0.7742179403374103, 0.21027093643428185, 0.20683339684534952, 0.14978228956295903, 0.1510384042554933, 0.17568663907038795, 0.18322561530887782, 0.15624316419377826, 0.14997967461404405, 0.17484125032194864, 0.1740214930436026, 0.1868146805117148, 0.17351320192085296, 0.05331927481809784, 0.0679042800291636, 0.07601282696741563, 0.07912305483143778, 0.050468196873553084, 0.06740667370757925, 0.0641119141169274, 0.05636600061993935, 0.07831412103471447]}, "mutation_prompt": null}
{"id": "1cf6c556-2d03-43a2-b134-20b7c8249438", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive_V2", "description": "EnhancedDES3D_Adaptive_V2: Advanced Differential Evolution with Adaptive Strategy Balancing and Dynamic Parameter Adjustment.", "configspace": "", "generation": 47, "fitness": 0.29048918231491166, "feedback": "The algorithm EnhancedDES3D_Adaptive_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.7070275660496457, 0.6976758642813665, 0.8249560365645467, 0.7135564498548673, 0.6980792881358582, 0.6082111095398048, 0.17252370807520168, 0.2953417847587101, 0.7914425862423057, 0.5519855427369996, 0.5017263498823592, 0.641346102693787, 0.5561446709480455, 0.47746930155637046, 0.6177307151659999, 0.5514128724019964, 0.45391906162221607, 0.6154192719556191, 0.09689926426397066, 0.08506514004879373, 0.10845654832705454, 0.10766364905696046, 0.09993432772453359, 0.11096370922348575, 0.08903757090058284, 0.08898696396394878, 0.04665361648306776, 0.12372470390716594, 0.024699290751816316, 0.10250934344231877, 0.11552625766892743, 0.042839324064342876, 0.1127385289189029, 0.09798800550701636, 0.09173769839002632, 0.0995273895268245, 0.905857665446329, 0.7502569496394824, 0.8336260253884609, 0.8971488513175854, 0.8375879368382343, 0.7807573079792814, 0.8714519911128409, 0.9617477546778348, 0.07254608519463912, 0.3323103913003088, 0.37050368888354446, 0.07948774639603107, 0.31268832728151563, 0.07604048247960493, 0.4368897734266216, 0.3676004547642129, 0.3367876116008809, 0.4269857995883749, 0.6884246076983395, 0.6721566312998736, 0.7539498532533195, 0.8153442801550554, 0.596281284316918, 0.7521340956067398, 0.8230308410938033, 0.6406653276983381, 0.7756299921336953, 0.040456623377359446, 0.04767541728735181, 0.07591747600033472, 0.08398829010822262, 0.04832764016288493, 0.19876928942822747, 0.07742711856326334, 0.23984279624636928, 0.575929582924157, 0.05853726965076311, 0.07831594250679352, 0.1838684212307795, 0.26189432660507705, 0.04355558273956017, 0.4049089351806998, 0.1596301187775252, 0.06487677669617664, 0.1927929308438341, 0.33163597308535897, 0.21000746327494957, 0.3400847006320954, 0.4162523195274622, 0.27472518997757545, 0.5162914557735374, 0.4134241739263649, 0.20475564355990594, 0.0010171816395663225, 0.0360544663277389, 0.40943193710370007, 0.608678355307882, 0.2503605076271056, 0.4186925374079178, 0.30537398770026103, 0.05830352165237451, 0.4342912174674408, 0.6506785862677416, 0.07852891398139816, 0.06092343118340526, 0.13977104139014662, 9.999999999998899e-05, 0.06198931160356658, 0.296690545204513, 0.13301695227076193, 0.0705602320429678, 0.168225066831848, 0.00125975226662689, 0.20928623508619626, 0.2943180102437887, 0.023363416132999193, 0.2551975055918718, 0.3631358867984339, 0.29256736940332717, 0.2040483880557763, 0.384491403716995, 0.2556627610107328, 0.5744026167996734, 0.7479809550052747, 0.4590240937554755, 0.5535462972888043, 0.6903466569543111, 0.6162921969003701, 0.5123442042739619, 0.6895869565642003, 0.05503127484949799, 0.09386070781461242, 0.08748750315534759, 0.04450186216483942, 0.04851231296065994, 0.08964743960578758, 0.07176110917115386, 0.07871080659042506, 0.0528695519233795, 0.17797120927288912, 0.09402778899897146, 0.12631630523878035, 0.16683915483138467, 0.12955345460189926, 0.15308370329498033, 0.13831758757960377, 0.1524859820920097, 0.16436192737652233, 0.17688022339284237, 0.31874021133097663, 0.4181091965558946, 0.3397177907875464, 0.2704691425539575, 0.39611935558431144, 0.33997811845515313, 0.3058180709236248, 0.4570961161988947, 0.10585358172266623, 0.2581165538062884, 0.33323082901662937, 0.2719947591763514, 0.1895012735120103, 0.307083469363148, 0.3124434304315008, 0.22287075010918678, 0.32601479149945445, 0.15835465666301352, 0.20260022500293284, 0.1782804587003789, 0.18925187606682303, 0.14206006999136622, 0.17498420329402942, 0.20843978513811368, 0.15995312288897945, 0.17645928224434904, 0.15123767520296283, 0.18747011795340607, 0.46105849892130457, 0.14644836231595915, 0.1451442552846105, 0.1977027255651208, 0.17083785104913918, 0.18654274594623654, 0.18704659446850413, 0.11990543763019212, 0.08381044697047746, 0.1809154760060957, 0.69696092017169, 0.23530697671154222, 0.18621866073905824, 0.10087029557805238, 0.18044294369376346, 0.18141824544629004, 0.16377058245277443, 0.11239594568960043, 0.5881458209162733, 0.49199137581507735, 0.12350433255767201, 0.7742179403374103, 0.21027093643428185, 0.20683339684534952, 0.14978228956295903, 0.1596528653269157, 0.17568663907038795, 0.18322561530887782, 0.17250629579637822, 0.14997967461404405, 0.17484125032194864, 0.1740214930436026, 0.1868146805117148, 0.17351320192085296, 0.04900077916426149, 0.0679042800291636, 0.07601282696741563, 0.07912305483143778, 0.04450639556912339, 0.06740667370757925, 0.0641119141169274, 0.04078441433350888, 0.07831412103471447]}, "mutation_prompt": null}
{"id": "7e216089-643d-4e97-a766-08672310c4a5", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.memory_size = 5\n        self.memory = np.zeros((self.memory_size, dim))\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def update_memory(self, solution):\n        if self.evaluation_count < self.memory_size:\n            self.memory[self.evaluation_count] = solution\n        else:\n            idx = self.evaluation_count % self.memory_size\n            self.memory[idx] = solution\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                    self.update_memory(trial)\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive_v2", "description": "EnhancedDES3D_Adaptive_v2: Dynamic Differential Evolution using Adaptive Memory and Competition Among Strategies for Improved Solution Quality.", "configspace": "", "generation": 48, "fitness": 0.29048918231491166, "feedback": "The algorithm EnhancedDES3D_Adaptive_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.7070275660496457, 0.6976758642813665, 0.8249560365645467, 0.7135564498548673, 0.6980792881358582, 0.6082111095398048, 0.17252370807520168, 0.2953417847587101, 0.7914425862423057, 0.5519855427369996, 0.5017263498823592, 0.641346102693787, 0.5561446709480455, 0.47746930155637046, 0.6177307151659999, 0.5514128724019964, 0.45391906162221607, 0.6154192719556191, 0.09689926426397066, 0.08506514004879373, 0.10845654832705454, 0.10766364905696046, 0.09993432772453359, 0.11096370922348575, 0.08903757090058284, 0.08898696396394878, 0.04665361648306776, 0.12372470390716594, 0.024699290751816316, 0.10250934344231877, 0.11552625766892743, 0.042839324064342876, 0.1127385289189029, 0.09798800550701636, 0.09173769839002632, 0.0995273895268245, 0.905857665446329, 0.7502569496394824, 0.8336260253884609, 0.8971488513175854, 0.8375879368382343, 0.7807573079792814, 0.8714519911128409, 0.9617477546778348, 0.07254608519463912, 0.3323103913003088, 0.37050368888354446, 0.07948774639603107, 0.31268832728151563, 0.07604048247960493, 0.4368897734266216, 0.3676004547642129, 0.3367876116008809, 0.4269857995883749, 0.6884246076983395, 0.6721566312998736, 0.7539498532533195, 0.8153442801550554, 0.596281284316918, 0.7521340956067398, 0.8230308410938033, 0.6406653276983381, 0.7756299921336953, 0.040456623377359446, 0.04767541728735181, 0.07591747600033472, 0.08398829010822262, 0.04832764016288493, 0.19876928942822747, 0.07742711856326334, 0.23984279624636928, 0.575929582924157, 0.05853726965076311, 0.07831594250679352, 0.1838684212307795, 0.26189432660507705, 0.04355558273956017, 0.4049089351806998, 0.1596301187775252, 0.06487677669617664, 0.1927929308438341, 0.33163597308535897, 0.21000746327494957, 0.3400847006320954, 0.4162523195274622, 0.27472518997757545, 0.5162914557735374, 0.4134241739263649, 0.20475564355990594, 0.0010171816395663225, 0.0360544663277389, 0.40943193710370007, 0.608678355307882, 0.2503605076271056, 0.4186925374079178, 0.30537398770026103, 0.05830352165237451, 0.4342912174674408, 0.6506785862677416, 0.07852891398139816, 0.06092343118340526, 0.13977104139014662, 9.999999999998899e-05, 0.06198931160356658, 0.296690545204513, 0.13301695227076193, 0.0705602320429678, 0.168225066831848, 0.00125975226662689, 0.20928623508619626, 0.2943180102437887, 0.023363416132999193, 0.2551975055918718, 0.3631358867984339, 0.29256736940332717, 0.2040483880557763, 0.384491403716995, 0.2556627610107328, 0.5744026167996734, 0.7479809550052747, 0.4590240937554755, 0.5535462972888043, 0.6903466569543111, 0.6162921969003701, 0.5123442042739619, 0.6895869565642003, 0.05503127484949799, 0.09386070781461242, 0.08748750315534759, 0.04450186216483942, 0.04851231296065994, 0.08964743960578758, 0.07176110917115386, 0.07871080659042506, 0.0528695519233795, 0.17797120927288912, 0.09402778899897146, 0.12631630523878035, 0.16683915483138467, 0.12955345460189926, 0.15308370329498033, 0.13831758757960377, 0.1524859820920097, 0.16436192737652233, 0.17688022339284237, 0.31874021133097663, 0.4181091965558946, 0.3397177907875464, 0.2704691425539575, 0.39611935558431144, 0.33997811845515313, 0.3058180709236248, 0.4570961161988947, 0.10585358172266623, 0.2581165538062884, 0.33323082901662937, 0.2719947591763514, 0.1895012735120103, 0.307083469363148, 0.3124434304315008, 0.22287075010918678, 0.32601479149945445, 0.15835465666301352, 0.20260022500293284, 0.1782804587003789, 0.18925187606682303, 0.14206006999136622, 0.17498420329402942, 0.20843978513811368, 0.15995312288897945, 0.17645928224434904, 0.15123767520296283, 0.18747011795340607, 0.46105849892130457, 0.14644836231595915, 0.1451442552846105, 0.1977027255651208, 0.17083785104913918, 0.18654274594623654, 0.18704659446850413, 0.11990543763019212, 0.08381044697047746, 0.1809154760060957, 0.69696092017169, 0.23530697671154222, 0.18621866073905824, 0.10087029557805238, 0.18044294369376346, 0.18141824544629004, 0.16377058245277443, 0.11239594568960043, 0.5881458209162733, 0.49199137581507735, 0.12350433255767201, 0.7742179403374103, 0.21027093643428185, 0.20683339684534952, 0.14978228956295903, 0.1596528653269157, 0.17568663907038795, 0.18322561530887782, 0.17250629579637822, 0.14997967461404405, 0.17484125032194864, 0.1740214930436026, 0.1868146805117148, 0.17351320192085296, 0.04900077916426149, 0.0679042800291636, 0.07601282696741563, 0.07912305483143778, 0.04450639556912339, 0.06740667370757925, 0.0641119141169274, 0.04078441433350888, 0.07831412103471447]}, "mutation_prompt": null}
{"id": "a727c190-dd6e-4619-97cd-16851165c5f3", "solution": "import numpy as np\n\nclass EnhancedDE_AdaptiveElitism:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 7 * dim)  # Adjusted population size for diversity\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.3  # Increased elite fraction to influence search\n        self.adaptive_factor = 0.05  # Reduced adaptation for stability\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 1.0)  # Adjusted CR bounds for robustness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.9  # More aggressive reduction\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDE_AdaptiveElitism", "description": "Enhanced differential evolution using adaptive elitism, probabilistic strategy selection, and dynamic parameter tuning for improved global search capabilities.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {}, "mutation_prompt": null}
{"id": "ef991e32-488f-422e-bb84-cce72e08b228", "solution": "import numpy as np\n\nclass QIDE_ESR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.q_probability = 0.05  # Quantum-inspired probability\n\n    def quantum_momentum(self, idx):\n        if np.random.rand() < self.q_probability:\n            momentum = np.mean(self.population, axis=0) - self.population[idx]\n            return self.population[idx] + self.F * momentum\n        return self.population[idx]\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx) + self.quantum_momentum(idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "QIDE_ESR", "description": "Quantum-Inspired Differential Evolution with Enhanced Adaptivity and Strategy Refinement (QIDE-ESR).", "configspace": "", "generation": 50, "fitness": 0.09419238727287801, "feedback": "The algorithm QIDE_ESR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.16.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.13785008388303233, 0.07275298629224303, 0.10632679006605883, 0.14880228573588716, 0.14454994822989664, 0.13716705545705588, 0.12875084935694636, 0.11643440420881013, 0.12199897660355441, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029499411875062664, 0.02921669470527466, 0.02072370199205109, 0.023323263063818378, 0.008246172881662628, 0.03631813360218006, 0.028836739164100123, 0.0198996175003322, 0.031775033812721065, 0.04071783656521566, 0.004663939691368468, 0.02175739252004205, 0.024792830367820318, 0.0036822145244270743, 0.02801301739375217, 0.008082069689908766, 0.0024548337057809233, 0.012968615383280313, 0.985992325509349, 0.98874607311038, 0.9774079401191488, 0.0994185868549059, 0.09923076844320733, 0.9843245664111794, 0.9844993965252857, 0.9216439413483738, 0.11540231589851646, 0.011156656785670793, 0.010634338680248545, 0.025512438926267866, 0.028779413860988257, 0.05274566374023382, 0.020752872825413604, 0.06784174962585365, 0.07964465765835538, 0.051779391390304075, 0.10026002073480578, 0.0971072010485361, 0.12055540115168473, 0.08134190097958593, 0.1175353293281356, 0.08545723514731163, 0.07774070548481526, 0.07650435427364188, 0.08586498181848368, 9.999999999998899e-05, 0.03173067837261556, 9.999999999998899e-05, 9.999999999998899e-05, 0.009863947916531335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008534604347955943, 0.0040639076230316595, 0.010028226170227805, 9.999999999998899e-05, 9.999999999998899e-05, 0.0304055189675817, 0.00047212202154789384, 0.013537996678220643, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018756145060302876, 0.021926342318780323, 0.040951071277920525, 9.999999999998899e-05, 9.999999999998899e-05, 0.015094181415883035, 0.013136435902945776, 0.015635568532584743, 0.026390968738563614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.113190058403277, 0.13049506361262464, 0.17276629637981333, 0.15952123248921612, 0.12978553620955668, 0.16703861490553662, 0.12758816593182531, 0.1414642545953504, 0.15242458038141304, 0.02198380921173726, 0.020046434402491875, 0.04672293343383682, 0.02206291671906202, 0.038357829231754126, 0.030956278390153913, 0.038270570366372714, 0.026394009618170955, 0.031604132115047645, 0.13814493926617089, 0.10139782407313491, 0.14999968870474656, 0.09853373003882204, 0.12452687252629024, 0.11917402691046752, 0.14092592152282635, 0.15559007243536105, 0.12510412275711147, 0.15013224139840642, 0.11970565740930939, 0.16075501012390436, 0.1685971823264275, 0.14485687855312102, 0.14786399532490724, 0.13219741953088127, 0.17368221163593678, 0.14036279553811815, 0.11291648604713622, 0.08468092067530708, 0.08772163575958547, 0.07021103962131037, 0.09453122737218489, 0.10379980007610701, 0.08372068418420309, 0.0986450242928475, 0.08872214682391621, 0.1586688126813256, 0.1543497273605382, 0.15029752727753987, 0.14704167233498389, 0.14234014164259534, 0.14417594719145854, 0.16305147819315569, 0.15045453303415257, 0.1530391036234754, 9.999999999998899e-05, 0.12513222505042554, 9.999999999998899e-05, 0.1308768549126471, 0.10529836921777513, 0.1299943489827965, 0.06817982639315956, 0.09607542041365946, 0.1322346405345881, 0.14772895326945634, 0.1533711206430589, 0.12636911744688728, 0.09349422555893994, 0.12075286049943501, 0.139041334769767, 0.08499864239241672, 0.15270201086073065, 0.1317862099744187, 0.08313126882893829, 0.1004534898229138, 0.15773878727232027, 0.06598992183968189, 0.119481789812249, 0.16321726303326378, 0.09652360405975358, 0.19024625954247076, 0.17725349232728882, 0.18956043095218789, 0.17457256351747874, 0.17930516087924375, 0.17379728816768947, 0.16926857794571237, 0.1914692309966577, 0.18180555810110866, 0.1828191306248107, 0.1750431796182702, 0.018351604785656894, 0.016822359355136762, 0.04391631997981693, 0.02838312195374071, 0.03755883775011204, 0.045885696952951416, 0.015974534205861146, 0.04258815770294255, 0.03275780403056505]}, "mutation_prompt": null}
{"id": "f8689f33-2a3b-4fcb-a4a2-d2c1006f73c4", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(15, 6 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6\n        self.CR = 0.85\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.15\n        self.adaptive_factor = 0.2\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.3, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.75, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.9\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive", "description": "Enhanced Differential Evolution with Adaptive Parameter Control and Strategy Success Probability for Improved Optimization.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {}, "mutation_prompt": null}
{"id": "8cebfc04-8a88-455b-8785-3236f3cf23eb", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 6 * dim)  # Slight increase in population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6  # Adjusted mutation factor for better exploration\n        self.CR = 0.85  # Adjusted crossover probability\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.ones(3)  # Initialize success rates to ones\n        self.elite_fraction = 0.15  # Adjusted elite fraction for more exploration\n        self.adaptive_factor = 0.05  # Reduced adaptation step size\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates) + 1e-6\n        probabilities = self.success_rates / total_success\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = max(1, int(self.elite_fraction * self.pop_size))\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (2 * np.random.rand() - 1), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (2 * np.random.rand() - 1), 0.6, 1.0)  # Broadened CR range\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.9  # Slightly reduced decay\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive", "description": "A novel self-adaptive Differential Evolution enhanced with dynamic strategy selection and elite-based mutation to optimize black box functions efficiently.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {}, "mutation_prompt": null}
{"id": "dccd0fa5-2bfd-49db-a0e0-b1f279841273", "solution": "import numpy as np\n\nclass EnhancedDES3D_ProbabilisticLineMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            if np.random.rand() < 0.1:\n                self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_ProbabilisticLineMutation", "description": "Robust Adaptive Differential Evolution with Probabilistic Line Mutation for Enhanced Exploration and Stability.", "configspace": "", "generation": 53, "fitness": 0.2523537172655553, "feedback": "The algorithm EnhancedDES3D_ProbabilisticLineMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.6710103804767964, 0.6661650314993504, 0.8398309260899661, 0.6845759433990934, 0.6823303185497245, 0.768966005368105, 0.16169954248946683, 0.2662346046286004, 0.8431585628761179, 0.49498834720535, 0.4718145481404801, 0.6782841933213677, 0.38966457222936624, 0.41750626444651817, 0.013884380877372537, 0.47851791592812143, 0.4105728490273256, 0.2533578009993175, 0.09588079945074246, 0.08072499826760471, 0.09958125894388392, 0.08612943514241433, 0.08691374661349704, 0.11071675881766463, 0.09520964821601463, 0.09369672134031937, 0.0512429210288885, 0.09532520987988669, 0.04256778335195266, 0.10562173033049826, 0.11656679241058043, 0.04533133714689297, 0.1094200539007365, 0.07552891599939282, 0.08159685702696184, 0.12582164485406266, 0.8008635936861597, 0.8881867912695894, 0.8297323005693819, 0.8199878491807985, 0.8143621261183687, 0.6563569548798444, 0.9534506243365563, 0.9510365355465421, 0.08478563679959938, 0.27604377910607814, 0.28125984908481183, 0.10749607892650004, 0.29555922465271034, 0.10155479102969422, 0.2063451959088548, 0.3138658946027332, 0.3637340440937511, 0.23486452602530172, 0.6743630031912831, 0.6128508101098136, 0.8216989473622848, 0.8770683182851782, 0.5479326255434991, 0.26782038566580946, 0.7742025653861222, 0.68161132337425, 0.7969392047035047, 0.06546761744404228, 0.05996804940431122, 0.05126211448449647, 0.0035940872475798136, 0.05579853406104174, 0.12571679546001846, 0.07908281093016345, 0.30188536746551786, 0.44160188021518165, 0.06799569547193185, 0.040329510775123145, 0.12237869263460921, 0.18663742795118488, 0.05761340270966453, 0.14037610679295465, 0.17205544572966847, 0.05523811757910191, 0.17881347161173544, 0.16482938003474323, 0.19414769395353038, 9.999999999998899e-05, 0.15703988960196436, 0.2307194744073272, 9.999999999998899e-05, 0.14445148837845723, 0.21348964678038884, 0.001248641959984531, 0.04081388680768383, 0.28843445910674026, 0.6117032311451844, 0.11300700194059354, 0.3609526866840448, 0.3777764839199351, 0.07551926534281339, 0.30806502179412887, 0.1913865809812607, 0.020539686981789096, 0.061523315198781514, 0.15936359147690837, 9.999999999998899e-05, 0.05820159989863627, 0.34384702157005975, 0.005897263910913497, 0.06448734586610749, 0.07543392539604987, 9.999999999998899e-05, 0.1963767190136123, 0.2065082980883668, 0.0023607186666878555, 0.19529008942210202, 0.0929947957528322, 0.1616832710100241, 0.23318607295770266, 0.1500911957324299, 0.25305537651973586, 0.5656464028542048, 0.5477890017173066, 0.48767070155912073, 0.5350374023770286, 0.5059677610962732, 0.5214933939328503, 0.6185982114850197, 0.5302458476014785, 0.04546727025419117, 0.08047702757034225, 0.12495869821654582, 0.0440600316188402, 0.045874873114078896, 0.0994260725467877, 0.052986493505334464, 0.08510639195820946, 0.04229615024971356, 0.15752986167336436, 0.1000820188346544, 0.1649941447113622, 0.14164722847470512, 0.16453184285441602, 0.14221136939231493, 0.1475346744769993, 0.12033552689016414, 0.19391599762061085, 0.17088780151380867, 0.2959282774822537, 0.379881754959019, 0.27390674110646485, 0.2745953240041984, 0.3914115158523772, 0.29133705981716507, 0.3260897104493027, 0.42482311656947114, 0.12521155837184994, 0.2240202137021321, 0.3926076367762885, 0.24535791646631744, 0.18903810024297896, 0.5014209462320892, 0.22382147325405444, 0.20512806390092186, 0.4590881448695616, 0.1474896450776938, 0.1731168716614857, 0.20909994839864954, 0.1803230897271174, 0.14974374721314598, 0.22316916863803737, 0.17822012040193802, 0.1451170316383681, 0.17468543109547152, 0.14395709171649973, 0.17305215852674372, 0.2298525657688768, 0.14859720531708698, 0.1457164133664619, 0.20911320357533525, 0.16915799795897657, 0.16463118620531025, 0.19178163402864323, 0.12415699884039078, 0.11364344350802347, 0.20241776321058502, 0.17325223171187976, 0.37020219557834366, 0.18848919956480503, 0.08300487126673384, 0.16059839126753228, 0.4212615875346175, 0.15853407167659894, 0.1120885146463374, 0.20849336079120606, 0.4959891501415258, 0.11329630582112626, 0.16585565182585538, 0.21151940125994617, 0.2081905550003006, 0.16399381265008028, 0.16025950486763085, 0.18281153860918886, 0.18105622169166558, 0.17326415305318021, 0.18875068637617243, 0.17492393602569134, 0.18287457715766087, 0.19935185071379247, 0.19526288585171891, 0.048730330186600224, 0.0631426496999371, 0.083011014145978, 0.07064088883729769, 0.05209350587580053, 0.0732699448283991, 0.07191179335170239, 0.054407083930966826, 0.07533656740536043]}, "mutation_prompt": null}
{"id": "f2683364-ade7-44bc-abc5-ffae5747f1da", "solution": "import numpy as np\n\nclass HarmonyInspiredDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.HMCR = 0.9  \n        self.PAR = 0.3  \n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n    \n    def mutate(self, idx):\n        strategies = [self.rand_1, self.harmony_search, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def harmony_search(self, idx):\n        harmony = np.copy(self.population[idx])\n        for j in range(self.dim):\n            if np.random.rand() < self.HMCR:\n                harmony[j] = self.population[np.random.randint(self.pop_size), j]\n            if np.random.rand() < self.PAR:\n                harmony[j] = harmony[j] + np.random.normal(0, 0.1)\n        return harmony\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "HarmonyInspiredDES3D_Adaptive", "description": "Harmony Search-inspired Differential Evolution with Dynamic Strategy Adaptation for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 54, "fitness": 0.24674926863987856, "feedback": "The algorithm HarmonyInspiredDES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.8385235321787124, 0.6142760615515013, 0.28363708126810183, 0.5291053811132818, 0.5513663899000959, 0.5887203178011442, 0.6763746056287823, 0.5757512564675488, 0.18053652164094658, 0.2864753576326773, 0.11827745272767565, 0.641346102693787, 9.999999999998899e-05, 0.09934504030661717, 0.6177307151659999, 9.999999999998899e-05, 0.1762980166526209, 9.999999999998899e-05, 0.13637385563496296, 0.09272379468149317, 0.10845654832705454, 0.12235520259811783, 0.05812461950953707, 0.11096370922348575, 0.11306977956070463, 0.1251598366973964, 0.05321655466949671, 0.03360445137288737, 0.09847762747535416, 0.10250934344231877, 0.10425737181039874, 0.041609955100020524, 0.1127385289189029, 0.09779897487090494, 0.0824747788968705, 0.0995273895268245, 0.9099291102668959, 0.8061647305942892, 0.8336260253884609, 0.8721360165795726, 0.8046885289563394, 0.7807573079792814, 0.877193023314724, 0.7705702029451967, 0.0731281540857508, 0.10690743443177231, 0.14484655287955683, 0.24202632425890436, 0.3036801087998451, 0.168504878956103, 0.32097582700251936, 0.21919768809591778, 0.10228407727172384, 0.4269857995883749, 0.18091601768923293, 0.16983479011490166, 0.7539498532533195, 0.19399603990164782, 0.1692519503764257, 0.7521340956067398, 0.8024210727786021, 0.21345227091997254, 0.7756299921336953, 0.15551279493844072, 0.12572632159844632, 0.046263428418441666, 0.20051319551305102, 0.1473241474997642, 0.19876928942822747, 0.18252362976613679, 0.11992295904131589, 0.06092233226858568, 0.11755624808591492, 0.11862517134408501, 0.07403580902050622, 0.13429461380457164, 0.1473107899657189, 0.4049089351806998, 0.13239714833060423, 0.12587652621382983, 0.1927929308438341, 9.999999999998899e-05, 0.5023345202819338, 0.3400847006320954, 0.01456934826944467, 9.999999999998899e-05, 0.5162914557735374, 0.23393512678347927, 0.00014965099692620942, 0.013299530687642669, 0.061615910470342206, 0.03138017542206384, 0.608678355307882, 0.03363227809416236, 0.042898223904785815, 0.014044831801995672, 0.3653761282062036, 0.043746610989988555, 0.6506785862677416, 0.1757724178762763, 0.058250986550250294, 0.13977104139014662, 9.999999999998899e-05, 0.06732942332872993, 0.296690545204513, 0.15666048548192557, 0.09455493344251531, 0.03809831678427622, 0.14066145759343385, 0.07320437036434868, 0.2943180102437887, 0.32470434350217825, 0.17983548428570717, 0.3631358867984339, 0.1645759460727355, 0.16571464149110793, 0.08275619251835764, 0.3945734797583972, 0.4144601941368231, 0.45042630638419245, 0.5105795749763351, 0.42772605305328104, 0.6903466569543111, 0.5313589408453652, 0.39685239532661976, 0.6895869565642003, 0.04130987347036641, 0.09598469924622677, 0.08748750315534759, 0.09992677095804359, 0.07484474966436361, 0.04915689070745233, 0.1131082558446942, 0.042531628384022246, 0.055135113237021915, 0.24250241145156293, 0.20313952787225598, 0.10837417217867629, 0.17449348714998736, 0.1418642751322292, 0.13713905978833574, 0.1461868834496527, 0.209736389856913, 0.16436192737652233, 0.16143158056411544, 0.20531863583609877, 0.4181091965558946, 0.34764807750632043, 0.17115133411771422, 0.39611935558431144, 0.18281849391776317, 0.3075755319905832, 0.4570961161988947, 0.392068872028866, 0.16059472654171547, 0.33323082901662937, 0.3685440711169017, 0.1466032023200542, 0.307083469363148, 0.3048808000567591, 0.2808962808589963, 0.32601479149945445, 0.1897405386356108, 0.21024741318080842, 0.1782804587003789, 0.23387548992866292, 0.19111845988646847, 0.17498420329402942, 0.1895675796311821, 0.22101824084520705, 0.15811681307242542, 0.1845199984025302, 0.24468409856331264, 0.46105849892130457, 0.20918941211690678, 0.22722417481596102, 0.14405501491721462, 0.18887208864474592, 0.2081917292872162, 0.18704659446850413, 0.22355360005299874, 0.1847195421575918, 0.1809154760060957, 0.8230547195075436, 0.1664121732022109, 0.18621866073905824, 0.24990894012101683, 0.20505656350820967, 0.1398119215031416, 0.1973655499105771, 0.20660077693178625, 0.5881458209162733, 0.2060651847637962, 0.18097748970195726, 0.7742179403374103, 0.2306739198512634, 0.15350198336820375, 0.14978228956295903, 0.18121866605123005, 0.1735410529372946, 0.18322561530887782, 0.17171536446605018, 0.17886751655580135, 0.17484125032194864, 0.15304001746323537, 0.18882033480557547, 0.17351320192085296, 0.04868021610625617, 0.07541860929465272, 0.07601282696741563, 0.07974992856683616, 0.09035263166065921, 0.07703111891015646, 0.09151591954302385, 0.06559659069935075, 0.08452804588545204]}, "mutation_prompt": null}
{"id": "4f3589e1-18ca-480a-b595-e40411d10cd0", "solution": "import numpy as np\n\nclass QuantumEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6\n        self.CR = 0.85\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.25\n        self.adaptive_factor = 0.07\n        self.quantum_factor = 0.05\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.5, 0.95)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.75, 0.95)\n\n    def quantum_inspired_variant(self, position):\n        quantum_position = position + self.quantum_factor * (np.random.rand(self.dim) - 0.5)\n        return np.clip(quantum_position, self.lb, self.ub)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial = self.quantum_inspired_variant(trial)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.9\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "QuantumEnhancedDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Strategy Selection for Enhanced Global Optimization.", "configspace": "", "generation": 55, "fitness": 0.18821096979261623, "feedback": "The algorithm QuantumEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.2474716452151573, 0.4485847581522999, 0.47211065725124013, 0.4263158699314602, 0.4567178853809408, 0.49930237488075935, 0.2419892034133636, 0.5185973207160003, 0.2152750904926244, 9.999999999998899e-05, 0.0922066292485142, 0.13529547641606499, 0.1224956030925769, 0.12066046098166994, 0.11086287279741847, 0.06330778101690526, 0.11571022588552915, 9.999999999998899e-05, 0.041607484172880294, 0.08107808531285499, 0.10101134375429532, 0.08960922266344096, 0.07992231615834244, 0.047025584160209855, 0.0771729439844121, 0.10008344313477013, 0.07629355946999716, 0.044559383486221904, 0.07042991187831171, 0.07740045409004415, 0.04531318841145471, 0.07206325843777883, 0.08425259327451617, 0.0698006211719796, 0.09187611294421294, 0.08148958573926557, 0.8208614248826527, 0.8816652860866045, 0.1027665910422415, 0.9324293641822666, 0.8507259866247083, 0.8239030012971842, 0.8555294046167004, 0.849371079991311, 0.8748330477421822, 0.16283336330874354, 0.22044947031150852, 0.07028620477868386, 0.1755133176821968, 0.3325099921415211, 0.3318886687858791, 0.19038539112775155, 0.21867270978931796, 0.36304511883559887, 0.1590991833743416, 0.34031002307274905, 0.21671961721282396, 0.6952123486990788, 0.3871969674920197, 0.670571918373735, 0.24689120027748246, 0.4088521267259675, 0.6560495087060269, 0.004946843626215003, 0.12508703579254865, 0.15530235577621643, 0.029809411067171054, 0.17147283979791506, 0.1453357854987618, 0.06418350620370838, 0.10086052372565812, 0.060013328822419165, 0.06380547993479535, 0.1825625200674842, 0.09646295389892345, 0.1935417647525347, 0.19019772662793488, 0.056931415798219365, 0.08605099353421697, 0.13065215758910964, 0.16333450794020266, 0.0013342973220198395, 0.08418816471735424, 0.07053896257057346, 0.02733627170162911, 0.05553705536133979, 0.07575449210569163, 0.028163331210842024, 0.042198437378579756, 0.030084613289399376, 0.05547158252669937, 0.1170292915716118, 0.14760860632867112, 0.12715092603434475, 0.0921267243139815, 0.09176573781061748, 0.06023865947585649, 0.11398959079655357, 0.15931846084264412, 9.999999999998899e-05, 0.014627299468938482, 0.014223596504136737, 9.999999999998899e-05, 0.029881096221068715, 0.0012492011701051853, 9.999999999998899e-05, 0.026276487687149297, 9.999999999998899e-05, 0.008403269684887027, 0.10646575799896241, 0.1466845085653542, 0.009285534214671265, 0.10587180396889484, 0.10492904694337013, 0.08250360681380497, 0.09608496136340239, 0.02287413126972282, 0.22749368816724613, 0.3810991558286554, 0.2654434437874582, 0.3667999090555214, 0.3897542218070492, 0.46178217479830286, 0.2306379606904123, 0.3536867770227241, 0.4723669052624696, 0.06315212761954259, 0.08462723138548389, 0.0880734021753038, 0.047640082170176345, 0.08697382029312739, 0.09248187743357106, 0.04120771633348197, 0.09006555345001177, 0.07209025748934672, 0.15522373347083362, 0.10897265435765147, 0.15357078268437385, 0.13441791643715006, 0.14828185370999747, 0.19897020437963897, 0.13703113012378632, 0.14078078315227738, 0.1258565344289253, 0.26964311007353037, 0.24120165977781194, 0.25047628786856424, 0.19715366880315377, 0.22360129413320506, 0.30075198554878957, 0.29377392793465484, 0.3289449671658371, 0.3035293282576921, 0.11517148552304735, 0.20317621018431797, 0.1731983194153066, 0.13312414599953826, 0.18085040860787704, 0.15177710759325835, 0.23692248238356206, 0.21148787810742586, 0.18822356644953708, 0.13395385087280898, 0.1748192207560949, 0.19124248574152203, 0.1704928163591719, 0.1614651552607238, 0.1803382051482898, 0.15257773921971507, 0.16470486847866161, 0.1404552599687131, 0.1361047449099939, 0.16434735404371037, 0.19809468680317854, 0.13451944476865196, 0.18451200967228165, 0.20548106425867052, 0.1626177057826872, 0.1710778021202417, 0.17523842557065394, 0.14818688077593634, 0.37362153442748014, 0.14583396995700082, 0.13611207769327416, 0.17425843890280435, 0.5225195843373075, 0.09999051535553805, 0.1744232375639977, 0.14353670111235406, 0.1648310894884114, 0.3074479543687215, 0.20051714548095823, 0.1300865085519436, 0.14449545671692554, 0.1970843284524676, 0.34445294027604034, 0.14838939297760445, 0.20505189843942595, 0.13965724312546246, 0.1739024513788925, 0.1922007504027049, 0.17605576635805786, 0.17932184678690444, 0.19045145635267102, 0.17127436137529983, 0.1790037683177076, 0.1851890471390466, 0.0623849634555087, 0.05454250777356828, 0.07732789950745023, 0.0559946139124311, 0.07254604833209155, 0.042115826610334084, 0.06386836356752301, 0.06808521666414658, 0.05846319622400642]}, "mutation_prompt": null}
{"id": "d2ba1ff8-73c2-4191-8978-1f96bccce960", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(12, 6 * dim)  # Adjusted population size for diversity\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6  # Adjusted scaling factor\n        self.CR = 0.85  # Adjusted crossover rate\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.ones(3) * 0.33\n        self.elite_fraction = 0.25  # Increased elite fraction\n        self.adaptive_factor = 0.15  # Enhanced adaptive factor\n\n    def select_strategy(self):\n        probabilities = self.success_rates / np.sum(self.success_rates)\n        return np.random.choice(3, p=probabilities)\n    \n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        j_rand = np.random.randint(0, self.dim)\n        trial = np.where((np.random.rand(self.dim) < self.CR) | (np.arange(self.dim) == j_rand), mutant, target)\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 0.95)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive", "description": "Adaptive Differential Evolution with Elite Strategy Selection and Parameter Tuning for Improved Convergence.", "configspace": "", "generation": 56, "fitness": 0.09711943633134228, "feedback": "The algorithm EnhancedDES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.09.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.24688102429495506, 0.18908622284677679, 0.2681963969638025, 0.22197553576386053, 0.2155960370398442, 0.20720095308557418, 0.20957322707661497, 0.2169514527925488, 0.1905647562508821, 0.011068879952615296, 0.004479254888666961, 0.0005977173308426842, 9.999999999998899e-05, 0.00019289952592238535, 9.999999999998899e-05, 0.0001238722560467087, 9.999999999998899e-05, 9.999999999998899e-05, 0.03672367389747033, 0.05644014201905412, 0.05957920905238734, 0.04800048654132116, 0.04144156381811259, 0.06482950242273222, 0.050260995429890265, 0.06771756302798781, 0.06922694755320302, 0.026420382057235625, 0.05934144269306996, 0.028540727901953167, 0.05204770879951226, 0.03548245601760791, 0.043020580704002165, 0.03073852909066843, 0.03405413970884075, 0.036743738653803315, 0.17850443415624961, 0.15054620265965846, 0.8257502629011717, 0.09267927532145481, 0.14417343249331172, 0.19314943034320153, 0.14365030069560758, 0.1481281551437712, 0.2135768340879024, 0.09128508310747185, 0.061773196670630526, 0.06032667104976641, 0.07258935762363539, 0.06355706626088375, 0.08394618758079031, 0.07973771029647503, 0.07809548642364805, 0.04591004944932031, 0.18154578413390177, 0.20037486979309238, 0.11436058415015105, 0.16701953227621047, 0.19017554683453297, 0.14090961139328206, 0.1643905023576615, 0.16663628258296415, 0.14428878221124886, 0.03269159159883783, 0.005684519527419107, 0.0013173243767976572, 0.03925777412471221, 0.004753346139167336, 0.006674851474616439, 0.002913651615470192, 0.003576082747176912, 0.033617035500239534, 0.05265114431470974, 0.0390522653575881, 0.07372305176213179, 0.052754086964757696, 0.016912183961239724, 0.01762938977237538, 0.034107305822830725, 0.020282309684272914, 0.0027863843019445556, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05474077042082304, 0.034684177470071464, 0.08242818568223609, 0.004288740122676771, 0.05645382492742379, 0.055105927003985755, 0.025371479398106356, 0.06938736432852455, 0.09443134548863197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00642783075933151, 0.0064836040955921215, 0.024038361469667313, 0.009530477850286267, 0.010836044730794803, 0.01904853821016983, 0.03490281835459774, 0.01046827122942684, 0.00203353303291931, 0.23818493846065425, 0.18796359463304357, 0.20659153274252862, 0.20063055069608016, 0.19697876435762296, 0.264391405996825, 0.20562840554616324, 0.19757843599804314, 0.26678381090768477, 0.04174627207014414, 0.049031051912030166, 0.058607598233054836, 0.052229436852190836, 0.052261823615597836, 0.058763889656810564, 0.057165692598949325, 0.03553084935319151, 0.03995308587647306, 0.13299026696957483, 0.11980101295964873, 0.09691280615041054, 0.1073353233297194, 0.1351638891117184, 0.09221271844545753, 0.1133671467802333, 0.09017949337203224, 0.12496082374285455, 0.18666822942485628, 0.16506092059457877, 0.18924097537398799, 0.16087481585116437, 0.15504531167016067, 0.1864018148858032, 0.16877521933255246, 0.1771295931346072, 0.20022988714039625, 0.10187414201340184, 0.11492050261406972, 0.11595972511273211, 0.11428010473134076, 0.09586239554105214, 0.13209825080646698, 0.12416710845697765, 0.13637194208247216, 0.11751581225696861, 0.16191606284789872, 0.14874751385266538, 0.16412168885368317, 0.142531808625454, 0.1411092355771858, 0.14001249177716113, 0.14883561107242427, 0.15132054712667764, 0.16933958540665006, 0.1373966286523841, 0.14346731421078351, 0.11584384784269719, 0.12266802898973928, 0.1062652383627325, 0.1459631913891397, 0.1399988619951591, 0.1426746870101515, 0.15267062210048776, 0.11251155301506499, 0.11205938072892185, 0.13107504265695769, 0.13649093764822995, 0.12378600765298886, 0.1678128336444068, 0.1430882436826949, 0.14441358532219017, 0.12809371742522402, 0.2731454037150802, 0.141670988776895, 0.0952195202615993, 0.10709416922421244, 0.10864965904243451, 0.1081600760087591, 0.1408521602196262, 0.10008099593160791, 0.18536272158981093, 0.1489094747782661, 0.15610173572521602, 0.18535304745918535, 0.15769543267077146, 0.17462418047927608, 0.1583117885209906, 0.1548847221025066, 0.15179703283418688, 0.15053785107647255, 0.04586922421074391, 0.046856208848744196, 0.04377813002047093, 0.039163150223742726, 0.049153887000166874, 0.03414040212073144, 0.047672398571713126, 0.03332259811979599, 0.036331404097490805]}, "mutation_prompt": null}
{"id": "65d2512d-28e4-442c-ac6c-f1532dcfd92a", "solution": "import numpy as np\n\nclass OptimizedDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(20, 5 * dim)  # Increased minimum population size for exploration\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6  # Slightly increased for more aggressive mutations\n        self.CR = 0.85  # Slightly reduced to maintain diversity\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.15  # Adjusted elite fraction for efficiency\n        self.adaptive_factor = 0.1\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.5, 1.0)  # Refined range for F\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 0.95)  # Refined range for CR\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "OptimizedDES3D_Adaptive", "description": "Optimized Differential Evolution with Adaptive Strategy Selection and Dynamic Parameter Tuning.", "configspace": "", "generation": 57, "fitness": 0.22796587278456878, "feedback": "The algorithm OptimizedDES3D_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.7640347219625638, 0.557945168176659, 0.7511484529769565, 0.6601915723186734, 0.5990524842925574, 0.5210720008669236, 0.24464627434043928, 0.22003455615742462, 0.21593623578281906, 0.4178537868299994, 0.29959222775763417, 0.5537008814156253, 0.3930653052787987, 0.30795624155692103, 0.5257458180094658, 9.999999999998899e-05, 0.3133410797439431, 0.5271124721478715, 0.08681018278917219, 0.11124558592714617, 0.1156554601528138, 0.08877634755535724, 0.07845492641570107, 0.08919464541564015, 0.08116522330680886, 0.08364734004337038, 0.055994592363221685, 0.10735180045559678, 0.07320952628683242, 0.11974275951387425, 0.09535282401933787, 0.04341977291041954, 0.08759420610271318, 0.07560787720876616, 0.08751316664859965, 0.08966374891329831, 0.8685316704587566, 0.888601407519046, 0.9143370186653752, 0.9037250824167167, 0.9753201612556154, 0.8818235623919627, 0.9457403751786647, 0.9627865961298516, 0.14431334308501553, 0.09073061945349215, 0.23540219243980898, 0.11829198839114141, 0.2835892871871417, 0.07397669714740296, 0.37101901094188205, 0.27232769521913613, 0.23860081613456785, 0.36187603606213514, 0.5057862830524971, 0.2558703891791747, 0.25381714033530356, 0.7171600370825209, 0.4057266757501663, 0.7163899881579834, 0.7282148158402837, 0.3774539372247756, 0.6894761624123984, 0.037046793595389094, 0.06844698239001823, 0.02763314333992961, 0.01589850143183391, 0.04648231625596888, 0.23299103849226932, 0.04558141022326523, 0.11751553007600946, 0.14731073017790386, 0.024121388282975942, 0.10276686839046179, 0.00984162242364961, 0.16815031935065095, 0.03408424803956167, 0.16166380026743887, 0.19987380051560644, 0.03105889258095973, 0.2014899028522119, 0.12087447049463262, 9.999999999998899e-05, 0.22933286260770924, 0.18499177795648625, 0.049988831322389515, 0.20048530285807697, 0.15056662819369626, 9.999999999998899e-05, 9.999999999998899e-05, 0.01197962004560904, 0.18481755594888682, 0.2993083745495301, 0.14146299117721206, 0.128978037887993, 0.19384516923999884, 0.35244672330615456, 0.2380923422751947, 0.35420816046465087, 0.043172675210380485, 0.007104758144607648, 0.07378620778026401, 9.999999999998899e-05, 0.011925816093371067, 0.10437966184263081, 0.0833326590268072, 9.999999999998899e-05, 0.121048913576289, 0.004171029500189438, 0.12254555520481991, 0.20518061893582018, 0.0070321961823023305, 0.1265723667156119, 0.2328003314456042, 0.16438058741863693, 0.10669203848607434, 0.2237386057961116, 0.20607743067716133, 0.3936867169599927, 0.6190929514960958, 0.4895819207958687, 0.4603919428450435, 0.5608466910790442, 0.7376087575330461, 0.5836516386079053, 0.5808209744573198, 0.07212804002860207, 0.06309005152109126, 0.09265471300881922, 0.049510485189409925, 0.04646465530669264, 0.1116878364583117, 0.05374055269459277, 0.03975496678997592, 0.07709876980171682, 0.11836103214918092, 0.10377503344842465, 0.13314643860703013, 0.14255277033023672, 0.1325643203421869, 0.1754092739286971, 0.12078238393894059, 0.12587734104795, 0.15045093715229307, 0.1666510089290274, 0.23390656470253524, 0.28676843282234177, 0.25607252656995605, 0.2068729698639048, 0.3130097210990973, 0.2732166709211571, 0.27516424217090085, 0.35067275642402274, 0.0755751161184216, 0.19018460873626875, 0.20657685009370252, 0.19441832610184417, 0.16074698442074986, 0.23786393553099272, 0.22507863123264382, 0.1798136071867068, 0.25846413669854373, 0.20874568235240665, 0.20569424824863558, 0.18117203790236913, 0.14746176037207426, 0.15287901412132654, 0.18956180846030168, 0.17312024661558933, 0.13552617557155666, 0.17298155998372333, 0.13575187474983053, 0.18102640677893034, 0.18238601078135885, 0.13173197260906966, 0.13622375655208074, 0.17393814997411106, 0.16149377594742786, 0.169910491624357, 0.18460638309370803, 0.10320238711188756, 0.15690902713161992, 0.1210808458754784, 0.16362427395979262, 0.14876141087975703, 0.7712305747304838, 0.10870876912326288, 0.15464496660054228, 0.16773706591706672, 0.2177270030471109, 0.12611136083824181, 0.19503884027354035, 0.14606614396686768, 0.2717449886822396, 0.4097750729192492, 0.20676172666193526, 0.11962590736599144, 0.20766234737782763, 0.16672744891005054, 0.1792870879310311, 0.16450248914518584, 0.15283332219065338, 0.20245602827163267, 0.16763429186944245, 0.176282570687756, 0.17124360228408897, 0.1967774620241729, 0.06617714754080495, 0.047329144294762426, 0.07129662587621821, 0.07407295209020481, 0.04636933802537746, 0.0601010609321847, 0.04128738687367417, 0.05717098473805471, 0.07107138063076213]}, "mutation_prompt": null}
{"id": "5b5d780e-95d2-4fa1-b8ac-b525f71df807", "solution": "import numpy as np\n\nclass EnhancedGammaDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.cooling_rate = 0.01  # New parameter for freezing mechanism\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_freezing]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_freezing(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        direction = self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n        if np.random.rand() > self.cooling_rate:  # Freezing mechanism based on cooling rate\n            direction *= 0.5\n        return self.population[idx] + direction\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedGammaDE", "description": "Enhanced Gamma Differential Evolution with Adaptive Learning Rate and Freezing Mechanism.", "configspace": "", "generation": 58, "fitness": 0.27922343243149866, "feedback": "The algorithm EnhancedGammaDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.7070275660496457, 0.6976758642813665, 0.8249560365645467, 0.7135564498548673, 0.6980792881358582, 0.6082111095398048, 0.1776246230456765, 0.14400914942374599, 0.7914425862423057, 9.999999999998899e-05, 0.5017263498823592, 0.641346102693787, 9.999999999998899e-05, 0.47746930155637046, 0.6177307151659999, 0.5514128724019964, 0.45391906162221607, 0.6154192719556191, 0.08743361020970641, 0.08506514004879373, 0.10845654832705454, 0.10766364905696046, 0.09993432772453359, 0.11096370922348575, 0.08903757090058284, 0.08898696396394878, 0.039833940965092185, 0.09884745840353548, 0.032726604886606725, 0.10250934344231877, 0.0885777585261791, 0.028050940251998835, 0.1127385289189029, 0.09798800550701636, 0.09173769839002632, 0.0995273895268245, 0.905857665446329, 0.7502569496394824, 0.8336260253884609, 0.8971488513175854, 0.8375879368382343, 0.7807573079792814, 0.8714519911128409, 0.9617477546778348, 0.056478637265161336, 0.3323103913003088, 0.37050368888354446, 0.040759087184354614, 0.31268832728151563, 0.04673183366709688, 0.4368897734266216, 0.3676004547642129, 0.3367876116008809, 0.4269857995883749, 0.14823879463117096, 0.6721566312998736, 0.7539498532533195, 0.7330577711656584, 0.596281284316918, 0.7521340956067398, 0.115758028350886, 0.6406653276983381, 0.7756299921336953, 0.041447793012374445, 0.0240707471323216, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19876928942822747, 0.03985750773491947, 0.23984279624636928, 0.575929582924157, 0.06597447524480726, 0.03699204657408206, 0.1838684212307795, 0.038854611143446904, 0.0546928347338973, 0.4049089351806998, 0.25171444478667926, 0.041600818445658105, 0.1927929308438341, 0.33163597308535897, 0.21000746327494957, 0.3400847006320954, 0.4162523195274622, 0.27472518997757545, 0.5162914557735374, 0.39285081392375154, 0.20475564355990594, 9.999999999998899e-05, 0.06051604142690281, 0.40943193710370007, 0.608678355307882, 0.5065932173331924, 0.4186925374079178, 0.003137495647667521, 0.504226191202291, 0.4342912174674408, 0.6506785862677416, 0.1860828661307512, 0.06092343118340526, 0.13977104139014662, 0.27216461484272636, 0.06198931160356658, 0.296690545204513, 0.13301695227076193, 0.0705602320429678, 0.168225066831848, 0.002389724567448903, 0.20928623508619626, 0.2943180102437887, 9.999999999998899e-05, 0.2551975055918718, 0.3631358867984339, 0.29256736940332717, 0.2040483880557763, 0.384491403716995, 0.25911087146116785, 0.5744026167996734, 0.7479809550052747, 0.4590240937554755, 0.5535462972888043, 0.6903466569543111, 0.6545731052852237, 0.21348739295617203, 0.6895869565642003, 0.07981479934051772, 0.09386070781461242, 0.08748750315534759, 0.036115237040123094, 0.027813479588106205, 0.08964743960578758, 0.06119073725024937, 0.07871080659042506, 0.043050630088511954, 0.17797120927288912, 0.09576304021229787, 0.12631630523878035, 0.16683915483138467, 0.12955345460189926, 0.15308370329498033, 0.13831758757960377, 0.1524859820920097, 0.16436192737652233, 0.1351162947108262, 0.31874021133097663, 0.4181091965558946, 0.3397177907875464, 0.2704691425539575, 0.39611935558431144, 0.31857733369336483, 0.3058180709236248, 0.4570961161988947, 0.09492472792703788, 0.2581165538062884, 0.33323082901662937, 0.2719947591763514, 0.1895012735120103, 0.307083469363148, 0.11030182186274629, 0.22287075010918678, 0.32601479149945445, 0.18604437264807305, 0.20260022500293284, 0.1782804587003789, 0.16256614010568626, 0.1453765844120296, 0.17498420329402942, 0.16241534138745284, 0.17180021501816078, 0.17645928224434904, 0.13838306580216808, 0.18747011795340607, 0.46105849892130457, 0.12505973561672112, 0.12908851205201644, 0.1977027255651208, 0.16906392153422511, 0.18654274594623654, 0.18704659446850413, 0.15287194225528433, 0.13402024102845012, 0.1809154760060957, 0.6661262418799356, 0.23530697671154222, 0.18621866073905824, 0.11678726285390528, 0.18044294369376346, 0.18141824544629004, 0.6990536738530083, 0.15950489702795534, 0.5881458209162733, 0.49199137581507735, 0.09715140054965576, 0.7742179403374103, 0.21027093643428185, 0.20683339684534952, 0.14978228956295903, 0.1622520417316511, 0.17568663907038795, 0.18322561530887782, 0.17687341644243848, 0.14997967461404405, 0.17484125032194864, 0.1740214930436026, 0.1868146805117148, 0.17351320192085296, 0.04990876109758813, 0.0679042800291636, 0.07601282696741563, 0.07912305483143778, 0.04574478199528165, 0.06740667370757925, 0.0641119141169274, 0.0398270151177883, 0.07831412103471447]}, "mutation_prompt": null}
{"id": "bb634efb-59a6-484d-8140-690c56aba9e4", "solution": "import numpy as np\n\nclass MultiStrategyDE_HistoryAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.05  # Adjusted adaptive factor for smoother adaptation\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = (self.success_rates + 0.1) / (total_success + 0.3)  # Smoothed probabilities for exploration\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.98  # Slightly less aggressive decay\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "MultiStrategyDE_HistoryAdaptive", "description": "Multi-Strategy Differential Evolution with History-Driven Adaptation for Robust Optimization.", "configspace": "", "generation": 59, "fitness": 0.1543163189927638, "feedback": "The algorithm MultiStrategyDE_HistoryAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.12.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.37003313165873575, 0.4014248662061404, 0.402267905425025, 0.5059906852887555, 0.4110833047256378, 0.3498139001511721, 0.22463804918181418, 0.20475909110054646, 0.4522769409907559, 0.14900761221640424, 0.1395346206774104, 0.07735949749886006, 0.023197788324258894, 0.060466913989201565, 0.12031440064319832, 0.19716313460824375, 0.08509495704741499, 0.01699553327703829, 0.05938282551793417, 0.08512052878393916, 0.07418355759478112, 0.08985715386662907, 0.09569659912630357, 0.0800083207896869, 0.07449555064700941, 0.0775632140834267, 0.05704581443935386, 0.06835235191088629, 0.03203564736014175, 0.08051806420324625, 0.06821974706673684, 0.04522799453558579, 0.04433638919213878, 0.07825993875130077, 0.06735409923053393, 0.07475715211306433, 0.2329550414837871, 0.41913453828014546, 0.15431252596282907, 0.27490082372671754, 0.38359147939611615, 0.2171970905235836, 0.7711556758779908, 0.39738302219065136, 0.07233218187259649, 0.12054604841637429, 0.14791604659224555, 0.05208947758594662, 0.1202107438016714, 0.07220689647226808, 0.1106847270282828, 0.13549079459812907, 0.16186835146958878, 0.17505669142818092, 0.2754440050657142, 0.2973810217908017, 0.2964753059645373, 0.4265613435118406, 0.27967530725588974, 0.7826286077327805, 0.2996428632888778, 0.32694025300756757, 0.49273438458056684, 0.053398224359381685, 0.08024109692752368, 0.08265540990274622, 0.063565165477247, 0.04884413952139499, 0.07476177816177465, 0.04636457348190837, 0.1116000614777164, 0.09338691217931483, 0.12412215321205855, 0.05804712104250975, 0.11585330472528454, 0.0672146179020281, 0.06868917012856868, 0.12115619901178032, 0.11649851949976242, 0.05791750841241028, 0.095011733842019, 0.03660504171221657, 0.08295271625198586, 0.036982837388906176, 0.06457254532428758, 0.09776674676027375, 9.999999999998899e-05, 0.06605699978712487, 0.03209318012616191, 9.999999999998899e-05, 0.025408037935185313, 0.19029588442611023, 0.20978399478015064, 0.16826767247652574, 0.13081472917918413, 0.06917404506741842, 0.1096032016434203, 0.21108022255286796, 0.24879221716944133, 9.999999999998899e-05, 0.005976788859527571, 0.0017466103716479164, 9.999999999998899e-05, 0.006132764664610657, 0.028517202876810144, 9.999999999998899e-05, 0.000537056748371123, 0.0007815571626822448, 0.02463627249035416, 0.15693721064214938, 0.09873558261316062, 0.010107888970560586, 0.08007858190096251, 0.06261946979913624, 0.07441045925324974, 0.08397465113806979, 0.09951871983044858, 0.2577447609833796, 0.3912254805760623, 0.37974010875238073, 0.39746052040315993, 0.362183882288296, 0.3294072191276385, 0.31399089686146064, 0.46943686414590124, 0.3759165761128118, 0.05045467897242528, 0.10082946622637645, 0.07150729467076111, 0.0635681028267494, 0.06798274368875701, 0.08661927047064966, 0.07181930059824315, 0.0712781003831513, 0.04609148370698435, 0.1149199003056447, 0.08219258421122322, 0.12776766522169258, 0.11914351280059077, 0.12669007842307145, 0.11409444629990939, 0.09547623453636733, 0.10343186769779655, 0.11570605784999821, 0.1646826470117636, 0.2943518882655318, 0.22782491129928206, 0.2075600373708648, 0.17696151742533928, 0.24385966473583087, 0.2062510772455698, 0.23308164201531845, 0.2225411320322408, 0.1279841009267244, 0.2663506117947235, 0.1708555890947211, 0.2074618399910304, 0.14171108452974168, 0.17873971993612325, 0.1649189425561155, 0.19865629152619801, 0.19142917175456464, 0.1551254327847864, 0.20180180379539525, 0.19078748914540955, 0.15441807282853426, 0.16133517479788517, 0.1638698225055799, 0.17036170328085076, 0.15545812836987538, 0.14573318257454015, 0.1306386635327531, 0.1629124483800768, 0.17622072248394105, 0.14284826411417473, 0.14702254534436798, 0.17006764877912972, 0.1770953026325982, 0.16778843593354398, 0.16137331404445376, 0.14177766756960464, 0.11065302206123706, 0.24293872405492323, 0.13550087505818487, 0.1482702642679936, 0.1037688615956548, 0.10963479940499965, 0.24483460881387686, 0.16620069709896546, 0.14481676301306945, 0.15703303602362106, 0.163394316249155, 0.10460685500219447, 0.20269899777870748, 0.16208740967680513, 0.20976434114634124, 0.2085015814845308, 0.10575427362069767, 0.1687154414563241, 0.15885854647444708, 0.17114849228587703, 0.1855950584609073, 0.17973735951776726, 0.17666906611997546, 0.16565080161599655, 0.1564753885816168, 0.17601840412318848, 0.05294300255330875, 0.06759562719023338, 0.07233054130978656, 0.057423702179318026, 0.04825516723249279, 0.054456659352538406, 0.044419200178165696, 0.05107668239403462, 0.08081843421194967]}, "mutation_prompt": null}
{"id": "e49956bb-ab59-420d-ac8a-fc0fbb029fde", "solution": "import numpy as np\n\nclass EnhancedDES3D_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(12, 6 * dim)  # Slightly increased population size for better diversity\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6  # Increased mutation factor\n        self.CR = 0.85  # Slightly adjusted crossover rate\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.25  # Increased elite fraction\n        self.adaptive_factor = 0.05  # Reduced adaptive factor for more stable adaptation\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.5, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.9  # Slightly increased decay for less successful strategies\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Adaptive", "description": "Adaptive Differential Evolution with Elite Strategy and Dynamic Parameter Tuning for Enhanced Performance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {}, "mutation_prompt": null}
{"id": "cb9583e3-aa3b-4b8d-b03c-42f2f65011ae", "solution": "import numpy as np\n\nclass EnhancedDES3D_Stochastic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F_base = 0.5\n        self.CR_base = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F_base * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F_base * (self.population[r2] - self.population[r3]) + self.F_base * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F_base * (best_elite - self.population[idx]) + self.F_base * (self.population[r1] - self.population[r2])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR_base or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def stochastic_params(self):\n        self.F_base = np.clip(self.F_base + self.adaptive_factor * np.random.normal(), 0.4, 0.9)\n        self.CR_base = np.clip(self.CR_base + self.adaptive_factor * np.random.normal(), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.stochastic_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDES3D_Stochastic", "description": "Enhanced Differential Evolution using Adaptive Strategies with Stochastic Parameter Control for Improved Convergence.", "configspace": "", "generation": 61, "fitness": 0.24720904880875863, "feedback": "The algorithm EnhancedDES3D_Stochastic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.6235524994608084, 0.49735374960741596, 0.712954500697143, 0.6928251379333843, 0.5844933261657257, 0.5819973710030264, 0.1750917350377318, 0.21925827276331145, 0.6825821315488829, 0.46690468566549703, 0.3126564745513071, 0.5142277443100468, 0.4045887608547013, 0.3158762066283738, 0.5502697532429831, 0.42811995495846344, 0.351941330820959, 0.5407418628290701, 0.09708372992343428, 0.07017911080785, 0.09889561200151109, 0.08190825122386902, 0.08739695579830731, 0.09470720550711154, 0.07750126484375486, 0.0851630562556065, 0.03942314280444714, 0.08794902424740558, 0.033033492223182526, 0.0924415954900345, 0.12853440784314296, 0.046943610030034666, 0.09241030013618234, 0.07451927330367814, 0.0794678079494493, 0.08148855993024029, 0.8681246529765765, 0.9101030352260996, 0.9454732287785867, 0.851739625954182, 0.9641934216256288, 0.8551438362927803, 0.9446629900284158, 0.9396175135046796, 0.1291795177215488, 0.3024966406936559, 0.2207635695054524, 0.09065878488758916, 0.26970934021024306, 0.08773406141519713, 0.3409803355667336, 0.2909223843649249, 0.257353840181059, 0.3826443381979152, 0.6861088956811277, 0.37733533596404867, 0.6137348681114075, 0.8305814064007115, 0.42550143887480885, 0.6715107831574361, 0.7447613990824951, 0.37310046119639806, 0.6321963986017816, 0.0409551230932933, 0.050439529537769534, 0.04513409533074553, 0.05067662139226525, 0.06021807467818929, 0.16116739021627324, 0.08091653588264469, 0.1365368640958583, 0.16888732780199245, 0.05730905046730861, 0.048878464288835355, 0.21848519672901445, 0.29385296716983056, 0.02905810205809778, 0.16655668969259074, 0.1683597615665039, 0.052755840755380645, 0.22544364158928598, 0.2097127409483821, 0.07206981590323247, 0.24490239719711615, 0.2876371598355526, 0.11453659219141432, 0.2275236366753841, 0.19208485050963642, 0.11403986385660314, 9.999999999998899e-05, 0.0722035147167015, 0.26514769585641973, 0.4555016757668049, 0.23095700720649615, 0.18274227395149467, 0.23934814075121424, 0.06018577872490971, 0.2809158578785961, 0.32301040335552067, 0.024338705117308512, 0.015770097418185802, 0.05834266157563939, 9.999999999998899e-05, 0.02141916374538866, 0.1678464807579152, 0.07560276811023081, 0.00420004784286665, 0.08484691062826155, 0.0003209514964506166, 0.15247684854117538, 0.23187543296943403, 0.006488382163251649, 0.13187275115592823, 0.18656650038820466, 0.21232144487837157, 0.13524549271783903, 0.2596940460441335, 0.25686006505068393, 0.4460392061248588, 0.5746207997605234, 0.5406033111638731, 0.4399425318663708, 0.5919471259355544, 0.5624729978152414, 0.5736171998658779, 0.5629030271582256, 0.04301688228636125, 0.09394643519211099, 0.10833406286249758, 0.04305554832392333, 0.05688713186332661, 0.09496710453214996, 0.05427612627940559, 0.09438906463794972, 0.045999182443891895, 0.1340432724643521, 0.08240611098241535, 0.14993200505191528, 0.15244770207284053, 0.17954600791463005, 0.14693870857728397, 0.12029808652917162, 0.10969617055238234, 0.15709382034442043, 0.18779918067381307, 0.236904429143167, 0.3345203924648893, 0.29613970923012534, 0.22434937848809267, 0.3490067245540672, 0.28198734623681543, 0.2682475026623773, 0.35285111388342827, 0.10729512914479278, 0.1554998381867253, 0.25351543586050673, 0.21693596016952899, 0.15803302051354606, 0.24173722002899445, 0.23884982767948904, 0.1715186927911403, 0.27560826077275824, 0.13842099270505237, 0.15488719545166674, 0.18582619026432534, 0.1643956055872563, 0.16075081558131243, 0.1729000044373724, 0.16472628436382764, 0.1384087232422273, 0.18283767507753423, 0.14631047180421264, 0.16944399213724026, 0.17818490907098494, 0.14527528586366456, 0.11969676957911668, 0.2382703925195011, 0.1715195907084962, 0.18507214713252274, 0.19873407682722166, 0.1334142385312349, 0.11267626065679193, 0.700171350537562, 0.6360567080410285, 0.16175799023041548, 0.5706051705692208, 0.09814139759816731, 0.22937156530326797, 0.29730263640608634, 0.16057681554455872, 0.14891273897701862, 0.1953530222422566, 0.17705738444459784, 0.09766294766784944, 0.15706776102194997, 0.205443815544337, 0.20269568375492686, 0.6861223587050296, 0.15718130348984682, 0.1771454972387121, 0.19558385005900913, 0.1698503974412381, 0.1755517136134913, 0.184062304622848, 0.18399288549725323, 0.17464097871247464, 0.18692986306627735, 0.041596723520718304, 0.060966600273543725, 0.06598801117601671, 0.06631904964291446, 0.05578571014585454, 0.05172978761301561, 0.06717481868308461, 0.04592566938021625, 0.07520619042751808]}, "mutation_prompt": null}
{"id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "solution": "import numpy as np\n\nclass HybridDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "HybridDEAdaptive", "description": "Hybrid Differential Evolution with Adaptive Parameter Control and Dynamic Strategy Selection for Improved Convergence.", "configspace": "", "generation": 62, "fitness": 0.2911331966473789, "feedback": "The algorithm HybridDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "5f2cf004-4107-4dee-97d5-10aa32168901", "metadata": {"aucs": [0.7943640129502623, 0.8144884329922805, 0.8390864768477175, 0.8390516123800406, 0.7974585996243068, 0.8204561599859612, 0.8046386645907726, 0.7778564923040878, 0.7981747362322499, 0.5719869519605622, 0.6634228028416476, 0.6579626796747002, 0.00112619595279706, 0.6739098097798891, 9.999999999998899e-05, 0.6894364943049038, 0.6783202940223785, 0.6118272145712483, 0.11525756435334156, 0.04770616126730243, 0.11699450698683644, 0.052068340165012716, 0.110747897019156, 0.05166577450389398, 0.11930319300050563, 0.12102485534263163, 0.12755647709625628, 0.04704111088958529, 0.08358647729482249, 0.0975419507666031, 0.052539275853965006, 0.09608333944023217, 0.1222814205802153, 0.043170639662755805, 0.1271306468329505, 0.10238204099225645, 0.9222580889499564, 0.8105831729242081, 0.8461887392321326, 0.8322579945680152, 0.8169298510023171, 0.9261067837612912, 0.941706950975461, 0.7590957947329594, 0.8879721057455978, 0.16251321136408037, 0.16118069165540205, 0.2453482983957711, 0.12240350883494355, 0.18292862986814074, 0.2513640626646707, 0.09683333868425303, 0.4539682993381965, 0.322276513813633, 0.19187908861823588, 0.22087277120727644, 0.13340605397441962, 0.2279957048108302, 0.6742239814201689, 0.7741192954090236, 0.7516362898708586, 0.7515259217286001, 0.7449961652492936, 0.08108695409275657, 0.5991338944963005, 0.17327370384571228, 0.14355632476480895, 0.04688073264867143, 0.1923483031058898, 0.13921293500770648, 0.20946877964478994, 0.16516068190370992, 0.12156077037957636, 0.13565066500023315, 0.15146376394336425, 0.07326385639841915, 0.23698256669048778, 0.19904041588290877, 0.06674390881917425, 0.12181897675645892, 0.16550749119929875, 0.3471907039850075, 0.2566900919946704, 0.2843599514258336, 0.01664561345863491, 0.055418219606267805, 0.10679412000520716, 0.001399063474079587, 0.14415103489786796, 0.11103305048665102, 0.34299627457341153, 0.07131409896132279, 0.26621731030285, 0.20463057948949803, 0.1252871881389669, 0.1045888788093865, 0.061959597105472275, 0.2778809250292952, 0.2586662830968053, 0.06497122675740519, 0.16285057152187765, 0.14006856101362553, 0.1815390724312992, 0.08751500213789054, 9.999999999998899e-05, 0.11895985306912882, 0.11035648858053504, 0.0946836390703415, 0.24580622808718466, 0.26664819080156743, 0.24045075181339282, 0.2598740276108362, 0.3249227176678422, 0.24806762093113077, 0.41901687339850835, 0.1894283603811241, 0.28871305804044145, 0.7489883975808512, 0.6073223453070193, 0.642193052764974, 0.566701763030812, 0.5706994395482019, 0.7102452013273156, 0.28839863901274077, 0.5045895402764466, 0.5344889167440412, 0.04002527081625884, 0.0798875682013277, 0.14031668361901828, 0.09979750360511386, 0.10485237503215616, 0.10216266570926513, 0.06546566644289764, 0.08277208127848512, 0.0877079444483233, 0.1298145393005289, 0.14610212313623028, 0.14091020892354478, 0.14313456858507156, 0.13058546602889332, 0.22172923151204793, 0.15684572074646896, 0.13340068746999445, 0.13377467165519397, 0.1894581520085269, 0.4182304233715617, 0.3404459268042974, 0.42579108390076525, 0.4382465278214559, 0.34631763411331895, 0.18759783626361082, 0.504327098696105, 0.47027056338004336, 0.3086162625889689, 0.32108850225727203, 0.12985004775664888, 0.35529664574128883, 0.2516130233383542, 0.317894119967152, 0.14944281830570705, 0.4066478185881506, 0.33719989283400786, 0.17198864786344636, 0.18301043445530174, 0.1888924428621923, 0.17045733085059678, 0.18435631264331198, 0.15426907661834444, 0.18126200086653588, 0.1953755355050566, 0.19515682807173385, 0.1949500500638044, 0.14489577335402648, 0.42249439117441767, 0.24801994296934204, 0.20772214257142996, 0.18163472079721255, 0.22740283225987612, 0.20191337145594168, 0.2012092681232438, 0.7408618897797994, 0.1614026206905128, 0.22080570452345705, 0.1492601647625892, 0.19477807466479158, 0.819598476127045, 0.17860900714604322, 0.7661275264160907, 0.4996910273527775, 0.14546721728141365, 0.16625434008533613, 0.46926193971366226, 0.6428984371123851, 0.20912294688683597, 0.6594244142914809, 0.20285682476996736, 0.20711932407945832, 0.15063338521011027, 0.18001292353614207, 0.18190482301068844, 0.17009882361267903, 0.1623662197973894, 0.17855137491994721, 0.1674651942802351, 0.17668400209496704, 0.1719343614495119, 0.17573142093837502, 0.07882955281551696, 0.07807869990318428, 0.07047521049281769, 0.07807334038916092, 0.08713878154104371, 0.0881175211784343, 0.05544978283053348, 0.07644325563016408, 0.07331354957353597]}, "mutation_prompt": null}
{"id": "d899b98a-ca75-453b-b6ad-44d37688f2b4", "solution": "import numpy as np\n\nclass EnhancedDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_pbest]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_pbest(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def environmental_selection(self):\n        fitness_values = np.array([self.func(ind) for ind in self.population])\n        indices = np.argsort(fitness_values)[:self.pop_size]\n        self.population = self.population[indices]\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.environmental_selection()\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDEAdaptive", "description": "Enhanced Adaptive Differential Evolution with Environmental Selection for Diversity Maintenance and Improved Convergence.", "configspace": "", "generation": 63, "fitness": 0.24592904487755976, "feedback": "The algorithm EnhancedDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "metadata": {"aucs": [0.6609669169719641, 0.726121779753254, 0.7212708435611604, 0.71835226364069, 0.6992786849252405, 0.7328163995045606, 0.716243643497648, 0.5933279474598636, 0.62190709272885, 0.5236864163873867, 0.10835989009204516, 0.45105419635010546, 9.999999999998899e-05, 0.49644538193326226, 0.0005420462042126095, 0.4997899765752575, 0.430621709465672, 0.4013772681659833, 0.0946054730723388, 0.04565701801228084, 0.12408817085405299, 0.05413616374399721, 0.09539342770971104, 0.05811496547131245, 0.10981586394734222, 0.09312661560378088, 0.08903589935465694, 0.041342931317839615, 0.0761282019200129, 0.09473777214722578, 0.04061101735245243, 0.10948292546158644, 0.07695284083318144, 0.052063146489721435, 0.07321670528668967, 0.10416334250002579, 0.8325532090463615, 0.8081820457747216, 0.9890484503080929, 0.8862815676247123, 0.9297234704571965, 0.9430617615145879, 0.7773111643392009, 0.7676486959624975, 0.9461643417191419, 0.2819200136348212, 0.266413414397068, 0.2764250305977298, 0.24590797260787178, 0.21838193637926762, 0.29853956642132484, 0.09007164528909217, 0.29667695403097927, 0.23648972558283055, 0.1715316431159647, 0.729903384598443, 0.3438242610656944, 0.16176729391667, 0.5872826504239754, 0.6387989603517481, 0.16728451376247921, 0.6678274369420834, 0.5051218073718637, 0.04638123592674803, 0.13600117576335546, 0.21973688300369432, 0.1774356147944629, 0.054029547046990034, 0.13124791041511674, 0.11858572796260702, 0.1582601739469186, 0.12661895775358734, 0.14548933880599924, 0.16489546267781074, 0.16581786530785847, 0.04663195514048568, 0.14325678305136258, 0.2738674942473551, 0.05972748586957766, 0.15592220275368385, 0.18237769894458222, 0.12058518613759972, 0.07336340274280706, 0.19245334871317588, 0.00032610655538301003, 0.1516475395003426, 0.028764011331742445, 0.005454724723413573, 0.07403551469335834, 0.22124746718893062, 0.3618530138004211, 0.345468856888799, 0.20363372864741702, 0.4001249358599752, 0.2173251703079443, 0.1333168801076614, 0.05035444944760459, 0.24127931214798914, 0.36434178388810323, 0.030582223324047697, 0.04302580101646514, 0.10060811104615208, 0.09326822273959567, 0.0803209772590513, 9.999999999998899e-05, 0.11324453732948203, 0.10870979392108071, 0.1312560703806397, 0.20621075121823107, 0.19467408405117848, 0.18190456256078125, 0.08015932475217546, 0.21175586882579278, 0.18667023235895197, 0.18990509891661456, 0.19898118269543608, 0.165625700373084, 0.5665376518687804, 0.4777427098237357, 0.5067071354012003, 0.5436196376193168, 0.5098780467201626, 0.5471283239324574, 0.21823121823365776, 0.5009620510903241, 0.5758284480639109, 0.023200084059992743, 0.08588315617552911, 0.09366541490738656, 0.09109212163610059, 0.09102792014962413, 0.09306460511530479, 0.06788057668394054, 0.10351983351343874, 0.08773320710279564, 0.13545877353403446, 0.1266537225075861, 0.13261345236783306, 0.18590568175162148, 0.12666078512932577, 0.1625717743608559, 0.1529871906344391, 0.13062566882730697, 0.11574664968431458, 0.17620476172541544, 0.3439735851837732, 0.2874959904094896, 0.3461065339114724, 0.2878180217550804, 0.28933241065099735, 0.182290636346375, 0.34298579249916006, 0.36758088460845095, 0.2742304968618072, 0.23693875736929193, 0.13120349095848305, 0.21118955114225058, 0.18218251653346385, 0.2590119016666055, 0.11689304175326942, 0.2943322290990408, 0.29638177013001643, 0.1575131136142327, 0.1925738459641786, 0.186803643088567, 0.15458875394452354, 0.17667380882055927, 0.14515447098422174, 0.1714476619861487, 0.19285952689255514, 0.21784762805154656, 0.18250596554403187, 0.13861333960227062, 0.21726717092769066, 0.21644869268957723, 0.19532891763515192, 0.18004091365440378, 0.18405612775014257, 0.16852626822786165, 0.18170942557608039, 0.35717007332183615, 0.2124514438037849, 0.11816455154894734, 0.15021144636165595, 0.18809236366054216, 0.5109162656720918, 0.15808571403403326, 0.16957044566588775, 0.24330250338648274, 0.15940026421864462, 0.19202996763718105, 0.15788507937360774, 0.20646300925585337, 0.12923445113024679, 0.18838413167116463, 0.5346305807904053, 0.20143812461441069, 0.12674882831295142, 0.1834323485316408, 0.1615249022336691, 0.18338880237802513, 0.16492434500267195, 0.1659407619209785, 0.18585717396068524, 0.17458107600976003, 0.16177367933130005, 0.16245307253636676, 0.06921435641533569, 0.06835688068261647, 0.07565647599269454, 0.083453689771957, 0.07306745637410694, 0.07720040150683727, 0.04385368953593116, 0.06724091094415074, 0.06759759311588154]}, "mutation_prompt": null}
{"id": "5bc1080f-cfa3-4107-aafe-d0faef791aaa", "solution": "import numpy as np\n\nclass EnhancedHybridDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.fitness_diversity_factor = 0.1\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_diversity]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_diversity(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        diversity_vector = self.fitness_diversity_factor * (self.population[r1] - self.population[r2])\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + diversity_vector\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDEAdaptive", "description": "Enhanced Hybrid Differential Evolution with Adaptive Parameter Control and Dynamic Strategy Selection using Fitness Diversity and Randomized Tournament Selection for Improved Exploration.", "configspace": "", "generation": 64, "fitness": 0.2865408691986452, "feedback": "The algorithm EnhancedHybridDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "metadata": {"aucs": [0.7943640129502623, 0.8144884329922805, 0.8390864768477175, 0.8390516123800406, 0.7974585996243068, 0.8204561599859612, 0.8046386645907726, 0.7778564923040878, 0.7981747362322499, 0.5719869519605622, 0.6634228028416476, 0.6579626796747002, 9.999999999998899e-05, 0.6739098097798891, 9.999999999998899e-05, 0.6894364943049038, 0.6783202940223785, 0.6118272145712483, 0.11525756435334156, 0.06987935068360152, 0.11699450698683644, 0.07254425591872782, 0.110747897019156, 0.06248142629177578, 0.11930319300050563, 0.12102485534263163, 0.12755647709625628, 0.0596965600168885, 0.08358647729482249, 0.0975419507666031, 0.05985871251969288, 0.09608333944023217, 0.1222814205802153, 0.040307315664323884, 0.1271306468329505, 0.10238204099225645, 0.9222580889499564, 0.8105831729242081, 0.8461887392321326, 0.8322579945680152, 0.8169298510023171, 0.9261067837612912, 0.941706950975461, 0.7590957947329594, 0.8879721057455978, 0.16251321136408037, 0.16118069165540205, 0.2453482983957711, 0.12240350883494355, 0.18292862986814074, 0.2513640626646707, 9.999999999998899e-05, 0.4539682993381965, 0.322276513813633, 0.1984491228761769, 0.22087277120727644, 0.13340605397441962, 0.14334834148596132, 0.6742239814201689, 0.7741192954090236, 0.7516362898708586, 0.7515259217286001, 0.7449961652492936, 0.04851362953726712, 0.5991338944963005, 0.17327370384571228, 0.14355632476480895, 0.016215273820314957, 0.1923483031058898, 0.13921293500770648, 0.20946877964478994, 0.16516068190370992, 0.12156077037957636, 0.13565066500023315, 0.15146376394336425, 0.026411707091675618, 0.23698256669048778, 0.19904041588290877, 0.11854343549198143, 0.12181897675645892, 0.16550749119929875, 0.3471907039850075, 0.2566900919946704, 0.2843599514258336, 9.999999999998899e-05, 0.055418219606267805, 0.10679412000520716, 9.999999999998899e-05, 0.14415103489786796, 0.11103305048665102, 0.34299627457341153, 0.07131409896132279, 0.26621731030285, 0.20463057948949803, 0.1252871881389669, 0.1045888788093865, 0.05753726447163299, 0.2778809250292952, 0.2586662830968053, 0.06497122675740519, 0.16285057152187765, 9.999999999998899e-05, 9.999999999998899e-05, 0.08751500213789054, 9.999999999998899e-05, 0.11895985306912882, 0.11035648858053504, 0.0946836390703415, 0.24580622808718466, 0.26664819080156743, 0.24045075181339282, 0.2598740276108362, 0.3249227176678422, 0.24806762093113077, 0.41901687339850835, 0.1894283603811241, 0.28871305804044145, 0.7489883975808512, 0.6073223453070193, 0.642193052764974, 0.566701763030812, 0.5706994395482019, 0.7102452013273156, 0.17244797480907637, 0.5045895402764466, 0.5344889167440412, 0.02546261516162962, 0.0798875682013277, 0.14031668361901828, 0.09979750360511386, 0.10485237503215616, 0.10216266570926513, 0.07402952641332627, 0.08277208127848512, 0.0877079444483233, 0.1298145393005289, 0.14610212313623028, 0.14091020892354478, 0.14313456858507156, 0.13058546602889332, 0.22172923151204793, 0.15684572074646896, 0.13340068746999445, 0.13377467165519397, 0.1447007158094511, 0.4182304233715617, 0.16931521912092917, 0.42579108390076525, 0.4382465278214559, 0.34631763411331895, 0.1820903569872624, 0.504327098696105, 0.47027056338004336, 0.3086162625889689, 0.32108850225727203, 0.10844471441374659, 0.35529664574128883, 0.2516130233383542, 0.317894119967152, 0.12215489495180043, 0.4066478185881506, 0.33719989283400786, 0.1677230244800132, 0.18301043445530174, 0.1888924428621923, 0.1928343058412384, 0.18435631264331198, 0.16174230464827566, 0.18126200086653588, 0.1953755355050566, 0.19515682807173385, 0.1949500500638044, 0.14743668670989352, 0.42249439117441767, 0.24801994296934204, 0.20772214257142996, 0.18163472079721255, 0.22740283225987612, 0.20191337145594168, 0.2012092681232438, 0.7408618897797994, 0.1614026206905128, 0.1675340982878808, 0.15572789457121983, 0.19477807466479158, 0.819598476127045, 0.17860900714604322, 0.7661275264160907, 0.4996910273527775, 0.15833398369952467, 0.16625434008533613, 0.46926193971366226, 0.6428984371123851, 0.08581165592898599, 0.6594244142914809, 0.20285682476996736, 0.20711932407945832, 0.16256497250554636, 0.18001292353614207, 0.18190482301068844, 0.17009882361267903, 0.18234658079861887, 0.17855137491994721, 0.1674651942802351, 0.17668400209496704, 0.1719343614495119, 0.17573142093837502, 0.07882955281551696, 0.07807869990318428, 0.07047521049281769, 0.07807334038916092, 0.08713878154104371, 0.0881175211784343, 0.05998294730526099, 0.07644325563016408, 0.07331354957353597]}, "mutation_prompt": null}
{"id": "eccd1f7a-c8fd-466a-96ee-0b7754d86f9b", "solution": "import numpy as np\n\nclass EnhancedDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory_size = 5\n        self.success_memory = np.zeros((self.memory_size, 3))\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        success_rate_avg = self.success_memory.mean(axis=0)\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5) * success_rate_avg[0], 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5) * success_rate_avg[1], 0.8, 1.0)\n\n    def record_success(self, strat_index, success):\n        self.success_memory[self.evaluation_count % self.memory_size] = 0\n        self.success_memory[self.evaluation_count % self.memory_size, strat_index] = success\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                    self.record_success(strat_index, 1)\n                else:\n                    self.success_rates[strat_index] *= 0.95\n                    self.record_success(strat_index, 0)\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDEAdaptive", "description": "Enhanced Differential Evolution with Adaptive Success Memory and Variable Scaling for Efficient Convergence.", "configspace": "", "generation": 65, "fitness": 0.2853216792019552, "feedback": "The algorithm EnhancedDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "metadata": {"aucs": [0.5325911919987011, 0.7805640676424562, 0.8052427922749659, 0.8248520137632416, 0.7896608938832582, 0.8389957880956405, 0.8199262825115758, 0.7660274491077128, 0.7845904636938981, 0.7215474840414994, 0.6872967260672502, 0.5964755157598344, 0.007462594267714895, 0.08067848202121819, 9.999999999998899e-05, 0.6879415785554392, 0.6217344550232075, 0.6234290947677665, 0.10765855326061624, 0.05636819690057382, 0.12665060139326212, 0.05674405711677777, 0.10410466289051346, 0.04756045066165138, 0.10817957345236251, 0.10045635919155482, 0.15070609280769764, 0.050903928600039894, 0.08196932969582826, 0.09909942091795532, 0.05067761926226633, 0.12407448564973567, 0.1079435156790447, 0.04319179831270181, 0.10509127439860111, 0.12546735267445397, 0.803734339551445, 0.810494917558989, 0.8278855428814331, 0.6454671196281636, 0.8356662270340703, 0.9133425618093417, 0.9252807907665446, 0.8291592899836071, 0.9536849829876023, 0.0990705914611022, 0.35929380084304574, 0.3113683022174263, 0.23650493442296328, 0.4195025947719144, 0.2117372828743218, 0.11147215176899172, 0.39486894831471686, 0.1734018322881843, 0.1809981808269968, 0.24384238476059317, 0.21833916383915197, 0.1323757410746853, 0.8000505479673081, 0.7861110462586894, 0.7761852185508464, 0.7516430035540266, 0.5520404047112974, 0.052654299451644127, 0.12790163012065892, 0.1725472504132073, 0.13664365287209823, 0.05276377843204061, 0.1503936356722645, 0.20967897077683784, 0.14834148574845496, 0.20963138956143834, 0.20646072674057991, 0.23277635694948406, 0.20119592205717673, 0.07772351056477456, 0.3051923929569821, 0.12521354954889907, 0.0648940618778211, 0.26148464476880806, 0.13043115193680566, 0.17456699346432392, 0.18161984316316293, 0.20418941364017873, 9.999999999998899e-05, 0.24882308128995778, 0.10589802461977527, 9.999999999998899e-05, 0.0652762890207278, 0.09834785462976847, 0.21865662846602074, 0.12999032137033395, 0.1878833887033452, 0.46565530279887224, 0.04461557381411074, 0.15907778353858226, 0.05993272994973464, 0.13714031601865484, 0.1915601206085933, 0.16609522018702005, 0.18870562331557805, 0.04009283992876367, 0.09053756278267044, 0.0874931566656012, 9.999999999998899e-05, 0.13292349455462504, 0.10332481209774469, 0.1672117578165011, 0.2440284321014361, 0.3374364973103626, 0.2840813689508298, 0.3467361463348517, 0.28065732950459366, 0.26920848244550444, 0.25933828740547715, 0.2111099978994635, 0.24989363361546812, 0.4772896336176984, 0.5882529693040635, 0.6851597924421837, 0.4583200330592958, 0.5538324789516232, 0.6741403448660668, 0.26617014901580105, 0.6706027482782843, 0.554140226416063, 0.028439247618895602, 0.09428171281763265, 0.12310824657205599, 0.1248275587535429, 0.09419815913082019, 0.12233909464068804, 0.058285881220554225, 0.10365774421765472, 0.08861772091610198, 0.13976608326689544, 0.12257902363096296, 0.13821062123782335, 0.1859127886875518, 0.14729213464166857, 0.1257752345482066, 0.20786130685174753, 0.19481415166959082, 0.1560427402915191, 0.20717236674955197, 0.45009746315222576, 0.38155340850627484, 0.4436344586869947, 0.3149859763907109, 0.3726394031815634, 0.2088551365785305, 0.4829827230414506, 0.42960459903654724, 0.2531670131201168, 0.33922959218624205, 0.12279350976036807, 0.3402414748119177, 0.290266746359234, 0.3511736426142438, 0.12314368603711223, 0.3843892429109794, 0.3153642304839813, 0.13127206338113517, 0.18006826932907793, 0.18086707723296647, 0.17393113749361888, 0.18589336152837443, 0.14214705033162067, 0.19599480981991002, 0.1997806852823072, 0.18306714952653114, 0.19789790598168933, 0.14080652087796064, 0.24046186043759976, 0.22420565481174004, 0.21870086820315593, 0.20550589525058427, 0.20533957835543948, 0.18222556659251044, 0.20767371233042942, 0.6602711920136353, 0.6987803272348656, 0.10533573641868754, 0.15546066798280223, 0.7418423162027676, 0.7777923504280297, 0.24674457091477553, 0.16392164588543712, 0.7988321538303191, 0.0976232585927157, 0.2126954907038897, 0.6700784160549811, 0.6815545219986237, 0.10607230395117528, 0.31296365087043243, 0.19788003903388585, 0.2432880329581636, 0.13690916393718577, 0.17777435328372282, 0.1698830372737008, 0.1844095718853388, 0.1520933505860983, 0.1786066292114996, 0.1920508376347867, 0.18976549534118514, 0.18037002035283167, 0.1849856398752011, 0.09478884858550995, 0.07197639164772285, 0.08294203513090925, 0.09068900909886324, 0.0762453791283293, 0.07185461213802724, 0.06030143315403147, 0.0678758072172192, 0.08594998251419494]}, "mutation_prompt": null}
{"id": "cd4a1114-bef6-4cc6-963a-c27c76363764", "solution": "import numpy as np\n\nclass HybridDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.15  # Adjusted elite fraction\n        self.adaptive_factor = 0.05  # Decreased adaptive factor for finer adjustments\n        self.mutation_probability = 0.05\n        self.momentum = 0.1  # Adding momentum for adaptive factor\n        self.prev_best_fitness = np.inf\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        # Introducing feedback loop\n        improvement = self.prev_best_fitness - self.best_fitness\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5) + self.momentum * improvement, 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5) + self.momentum * improvement, 0.8, 1.0)\n        self.prev_best_fitness = self.best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "HybridDEAdaptive", "description": "Enhanced Hybrid Differential Evolution with Feedback Loop and Momentum for Dynamic Adaptation and Robust Convergence.", "configspace": "", "generation": 66, "fitness": 0.23843409742718336, "feedback": "The algorithm HybridDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "metadata": {"aucs": [0.5825171393041841, 0.5465963959283786, 0.5226666524564434, 0.641952337423871, 0.6266168678053308, 0.6763367434954464, 0.6425506674919027, 0.5821903551925184, 0.41528339709660966, 0.26290529685399056, 0.2839336422789944, 0.2759845096888772, 9.999999999998899e-05, 0.2602638026223594, 9.999999999998899e-05, 0.2624551421053992, 0.2891874547334081, 0.29489241259824117, 0.09751226029800186, 0.03599782378933758, 0.09050605960118485, 0.04477874969642304, 0.08166740007507345, 0.04959566219088796, 0.0877507905889432, 0.07737948185926613, 0.08801526040831353, 0.024874063266965285, 0.054141811127302764, 0.0778526208007514, 0.04321714657260167, 0.07280114370093671, 0.0767659655333508, 0.015234451637220037, 0.07969450149854307, 0.08959164415604626, 0.9144170152027516, 0.9755259090792326, 0.9913423726920133, 0.8684389606122078, 0.9714230680988444, 0.9678994598601678, 0.8506966154973653, 0.9627191884178354, 0.9771414320482605, 0.2514624765502349, 0.2384272990373978, 0.26394122627807015, 0.23492342522157172, 0.26526053939392946, 0.2708034953930528, 0.051192379867544546, 0.26112197021365535, 0.2942821096396806, 0.1393359072293603, 0.39119124196215094, 0.586300469759785, 0.1429055355643648, 0.6105335806668504, 0.3386702230905778, 0.6241256645124539, 0.4262025390829466, 0.21138173900856483, 0.024722356572274617, 0.16499505982939955, 0.21770137361309294, 0.21818661151911878, 0.008679974383596578, 0.1463111765146592, 0.16110584233727454, 0.12973516882871827, 0.1264409105915676, 0.1877948817869941, 0.24548658861455785, 0.1971104187738132, 0.009475554727761293, 0.12382302922793753, 0.18927170913381142, 0.021770672813233416, 0.21062256438663862, 0.14915308878753508, 0.14241852569877977, 0.17355603286448618, 0.18227462737196398, 9.999999999998899e-05, 0.20128271968059164, 0.18187767240661767, 9.999999999998899e-05, 0.19920150827705363, 0.19500566367664207, 0.35868444752004447, 0.3745566280264039, 0.31005846867867126, 0.3186984872424061, 0.36516707465468545, 0.2651517192798156, 0.026834310647811832, 0.3496675003895904, 0.29755830570178965, 0.039618335292280205, 0.02622649974452218, 0.012449714116096078, 0.0722757632971015, 0.082227296469226, 9.999999999998899e-05, 0.06965174651715711, 0.042570020819752585, 0.081200557290393, 0.16058490241121803, 0.14811409932558706, 0.12249404516317941, 0.17419629755769128, 0.14260474475668528, 0.14705057440235136, 0.21627027528831244, 0.2003170089726639, 0.16073558077633876, 0.48516077808083724, 0.4850476267802277, 0.36968658874986127, 0.5292834445995362, 0.4350855443770095, 0.46004670833809, 0.21692983085799, 0.4810526353838799, 0.4249606829171352, 0.04124401465275784, 0.06958253925996327, 0.09002023549091431, 0.10511419990108772, 0.09070068017398969, 0.07452541629475362, 0.04302198365496368, 0.07178743285110067, 0.06710895508148407, 0.24522448406474007, 0.13839589392691254, 0.15594080249853648, 0.14280347532944504, 0.1914534508532152, 0.14368424944181113, 0.1852354154855297, 0.20914760673434707, 0.14523556309135888, 0.14923806995504096, 0.27269643161902835, 0.24062812124079325, 0.2534083163868728, 0.22530930506394364, 0.2322193182711415, 0.16676300865127747, 0.2822273829815395, 0.2858608548650816, 0.19467403243395265, 0.18236908090096549, 0.10598296397570339, 0.2052076719849827, 0.1674262529749565, 0.17221462756814732, 0.12541737693524102, 0.2258421261750866, 0.19905442091493564, 0.15205390937540875, 0.17541295064001838, 0.19391812439282274, 0.16620241812672287, 0.16978122473285007, 0.1392463661129968, 0.1554751847531941, 0.18326146947047572, 0.1771539050566847, 0.1812305553965725, 0.07234157213296188, 0.18236025643661014, 0.17707906869962442, 0.1526665814163949, 0.1910079141605715, 0.190292799883525, 0.16603077718487969, 0.17559269232646169, 0.5144730989158868, 0.18440877792818566, 0.12019360146806446, 0.1483370193078416, 0.6732387223326193, 0.587271124287316, 0.5639181930593714, 0.18506645034775893, 0.4455122949719921, 0.11197269798671716, 0.19960398096692755, 0.1847831064361921, 0.47515212041355903, 0.10366721797323442, 0.3692520915798402, 0.2045318353006802, 0.5643192810806106, 0.12006988138621655, 0.17503563780783604, 0.1764631223496297, 0.18279120201990295, 0.15154686458820066, 0.1633352709126008, 0.1839444436127773, 0.19017927946161395, 0.1747070341758632, 0.16972412952473837, 0.07782828412765064, 0.050140042726597334, 0.06268931166834757, 0.06360710797548164, 0.07891587189626026, 0.06151559400993922, 0.051078823090261016, 0.0704900066648868, 0.0680305152291969]}, "mutation_prompt": null}
{"id": "b054860e-fd4d-438e-b659-d0a7eceac647", "solution": "import numpy as np\n\nclass EnhancedHybridDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.informed_mutation_chance = 0.1\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.informed_mutation_chance:\n            return self.informed_mutation(idx), 2\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def informed_mutation(self, idx):\n        mean_vector = np.mean(self.population, axis=0)\n        return mean_vector + self.F * (self.population[idx] - mean_vector)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDEAdaptive", "description": "Enhanced Hybrid Differential Evolution with Adaptive Strategies and Informed Mutation to Improve Robustness and Convergence.", "configspace": "", "generation": 67, "fitness": 0.11218706534632215, "feedback": "The algorithm EnhancedHybridDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.08.", "error": "", "parent_id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "metadata": {"aucs": [0.2574536107604123, 0.2653978860534191, 0.3138478196345701, 0.2270214686501505, 0.22211962192972146, 0.3316751805024636, 0.26742176432025067, 0.21998541603309218, 0.2590762960523454, 0.04134814562093847, 0.003049183036683112, 0.033468452712710706, 0.004400995951585385, 0.004298274914582567, 9.999999999998899e-05, 9.999999999998899e-05, 0.0020422730129050493, 9.999999999998899e-05, 0.05084189605233602, 0.0540898391091329, 0.057111510140685606, 0.05601893936930302, 0.05545654160342961, 0.08169881095913623, 0.07565207035965082, 0.0637260720059818, 0.056199082141716095, 0.045162449857356846, 0.050990340991896144, 0.04778822020999518, 0.051488285862781646, 0.05808615845435794, 0.04921970075970494, 0.040901835944620824, 0.05615757462733306, 0.047836878593858656, 0.07360603728712689, 0.14439448950555, 0.14849628272565174, 0.0889246191147266, 0.09580947966741382, 0.10924676366246622, 0.14668083739773752, 0.09307875623065898, 0.5750724686010427, 0.11242475200831326, 0.07541464737145942, 0.058622260073070365, 0.05874650707443163, 0.05219248028957879, 0.13448969443673564, 0.13952002446189293, 0.06399086528352549, 0.08022130766391988, 0.21550302911888053, 0.13233406373906742, 0.15590811221878143, 0.21144540129073852, 0.16940483080980429, 0.24640731385437087, 0.1479506907327417, 0.13753552444300043, 0.14979641576334501, 0.09920974802970339, 0.028208935530175228, 0.08065157211708263, 0.006454565503642873, 0.061352535070452685, 0.00033630216974178673, 0.07304857364034034, 0.04249780030677608, 0.07459108610061449, 0.10473482703457282, 0.08558373491331184, 0.22615152673717986, 0.08467034374887261, 0.07728018365803369, 0.0636409114128994, 0.08426341496456757, 0.08518410093262596, 0.07935155383505277, 0.00245728536165446, 9.999999999998899e-05, 9.999999999998899e-05, 0.007032468819686111, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01578574730367177, 0.020303433627581358, 0.06705702690471449, 0.0963753618245311, 0.08624556936930494, 0.052563522126069295, 0.018497492067871324, 0.0625171863856755, 0.0760109455947039, 0.10607191984785769, 0.08847611838431135, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008781819365105692, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03283022897688648, 0.03895700140801239, 9.999999999998899e-05, 0.02603230333015505, 0.04311856131467451, 0.06196727609179653, 0.0057745004417593115, 9.999999999998899e-05, 0.02346530016623105, 0.3392676731265587, 0.2542863630484673, 0.26260325390167216, 0.29319608154337407, 0.2599047799244105, 0.2409648565674284, 0.21338070559541888, 0.2630149984919061, 0.3202033363176334, 0.055890440646131134, 0.05694283058469629, 0.033664348101101305, 0.06076670624856906, 0.04957453997585948, 0.07268457644737902, 0.06026365012524926, 0.05934358680447804, 0.0666360751617876, 0.11553283118344004, 0.09729577849799498, 0.08893473741393665, 0.0985481011125603, 0.11334809980968097, 0.08154023850349601, 0.11719242991756473, 0.09624953530285985, 0.11061109420388004, 0.14562452475721477, 0.18318041480507585, 0.17013488947595634, 0.21775575657244717, 0.1824508968272901, 0.21803071381299755, 0.20389032197410384, 0.21500833218163506, 0.1959772977025398, 0.11151566737157848, 0.14995723012153417, 0.12444428186289846, 0.13611481491679278, 0.12886360144650932, 0.17271053739161812, 0.14044258824928457, 0.15222603509185084, 0.15486158728650046, 0.17960564800471623, 0.18720815461275864, 0.17210967581543268, 0.15876744363599304, 0.15576439988890034, 0.15475848538710546, 0.23012414385600466, 0.18470687859292678, 0.1856453588564263, 0.14734169154806187, 0.15769205441374234, 0.16468427062590563, 0.15360620569798245, 0.14577576767923328, 0.16243904987673818, 0.15823464071524085, 0.1677620405987862, 0.15993186825789396, 0.13166742178787283, 0.15049776287083372, 0.11400732688166226, 0.15820645824583301, 0.15141095096865098, 0.22542508513206683, 0.0949780021034603, 0.17587555908590768, 0.18025010669275998, 0.300186620009823, 0.12922446137014088, 0.16372383398565238, 0.14882424664830196, 0.1587206278574289, 0.15362737988195463, 0.12593540454731078, 0.1334803037936807, 0.13111878022831203, 0.15948117655071614, 0.1542582169015665, 0.18000094311288672, 0.15442556932669127, 0.14220423163977725, 0.15938953499387876, 0.151349655319157, 0.14485184588371847, 0.1611066032867271, 0.06297062752571514, 0.04716636913214389, 0.06857641151660354, 0.06276171509201955, 0.05263154298609518, 0.05155206009069513, 0.056444927352221064, 0.05747218339829996, 0.06773385209136362]}, "mutation_prompt": null}
{"id": "7c04fd3d-ee99-4a04-bd10-e9709826fcf8", "solution": "import numpy as np\n\nclass EnhancedDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.1\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n\n    def local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        for _ in range(5):\n            candidate = individual + np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            if self.evaluate(candidate) < self.evaluate(individual):\n                return candidate\n        return individual\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedDEAdaptive", "description": "Enhanced Differential Evolution with Adaptive Strategy Selection and Local Search Refinements for Optimized Convergence.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "metadata": {}, "mutation_prompt": null}
{"id": "8a0f9dd4-20c9-4008-aae9-80bba3dd1d76", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.ones(3) / 3\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.elite_fraction = np.clip(self.elite_fraction + self.learning_rate * (np.random.rand() - 0.5), 0.1, 0.3)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                if trial_fitness < self.func(target):\n                    self.population[i] = trial\n                    self.strategy_history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution with Adaptive Learning and Self-Organizing Population for Robust Optimization.", "configspace": "", "generation": 69, "fitness": 0.12352493927463878, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.09.", "error": "", "parent_id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "metadata": {"aucs": [0.3378484173047793, 0.2838937228774753, 0.29609855302377974, 0.2477955938232319, 0.24871050456963717, 0.3064638702141982, 0.290844792740661, 0.30928079262854524, 0.31555774813824033, 0.0051781002157589295, 0.04730890701380652, 0.05630358224558618, 0.03376237190522202, 0.02438122282919608, 0.009571176878451326, 9.999999999998899e-05, 0.050395188577581074, 9.999999999998899e-05, 0.06687643235818341, 0.04719719348839424, 0.06876388586289628, 0.05462032562395269, 0.07172303921317158, 0.06707362187182841, 0.09143621464595675, 0.06757200189817669, 0.0665220215313338, 0.04596402717004244, 0.040263508378480806, 0.04195077440275674, 0.04612123094186482, 0.05042241642005918, 0.037504593322255086, 0.05052504155763404, 0.05161348205752547, 0.03758300502363543, 0.10114868265084531, 0.7671412385074943, 0.10142035561958551, 0.3259118536651887, 0.32674991572465095, 0.16220877177188198, 0.22188134414455896, 0.16132721161554842, 0.1663579976688585, 0.09294853066185205, 0.08357682479221074, 0.1290920497719299, 0.07334779690060855, 0.09089255631159598, 0.10146999649811073, 0.12081603574025956, 0.06486028070979932, 0.1127237974741373, 0.18109269191489263, 0.217694377024221, 0.14504469740506576, 0.17097967437566075, 0.204396672125977, 0.188861433005457, 0.16266737817911125, 0.2283104419272004, 0.1663531017266141, 0.0798970805955792, 0.09299059871360715, 0.06837988105793813, 0.09226479308607372, 0.06728565763937999, 0.1333035447781007, 0.07931826498343997, 0.0430838224529454, 0.09369054283462919, 0.12547831718532465, 0.10512068602167635, 0.026616190236395276, 0.05438015209783065, 0.04173103316576199, 0.08990559320682445, 0.055057390000687656, 0.05498670708155717, 0.10978990173588155, 9.999999999998899e-05, 0.047442948239378335, 0.0010798228586023084, 0.00395245075062578, 9.999999999998899e-05, 0.03896026937048769, 0.00035961628128711176, 0.015594210619363724, 0.02419068565910054, 0.13589923240233237, 0.04002121725459984, 0.14299055055920595, 0.06885395679992057, 0.06615548512291047, 0.12582219532520356, 0.07328427651909442, 0.17043614299307897, 0.10319835863276317, 9.999999999998899e-05, 0.0009196462673877193, 0.006639530041689601, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008100005477977512, 9.999999999998899e-05, 0.04041837880510579, 0.061370941879393626, 0.0477035737779834, 0.0370790899021235, 0.0315046239512321, 0.03951019871427419, 0.03797387131605423, 0.046213499702378646, 0.03996854768932112, 0.3012701684359458, 0.27928236815397056, 0.2810442052916188, 0.24535477504571912, 0.2950920660815426, 0.29820857945478474, 0.2810438545615813, 0.28379890255055507, 0.30261278921280677, 0.055032683000842963, 0.0648837765298711, 0.02819442106869663, 0.05572016719484085, 0.04620912458444959, 0.07717852224757149, 0.060155429602937516, 0.05500848031924377, 0.054274352437146955, 0.1109121058367305, 0.10328836447797674, 0.11052763946691901, 0.1457231424600708, 0.1084412626693092, 0.09827699846258386, 0.13838381436782188, 0.10950607182236072, 0.11869264109104316, 0.19625739051046986, 0.20637469986883794, 0.16937836451317978, 0.2010365214111569, 0.1969637296329042, 0.20481847078817317, 0.2003054166159024, 0.22818284907856778, 0.2178290152172837, 0.10311798905592517, 0.1395430093356952, 0.15248332578383983, 0.13342711863957846, 0.1599752875341114, 0.14186807922692135, 0.15505136587075252, 0.15418297249086432, 0.16461848379607746, 0.1734365777465402, 0.1490102051685237, 0.14325836246850154, 0.1520439606705568, 0.14472606577132796, 0.1458520976793568, 0.16932686700287236, 0.13997619768719682, 0.1644171815133375, 0.15289426053421773, 0.14345005504569164, 0.14487892156752313, 0.14670331078556698, 0.16472539280185539, 0.1566809955022943, 0.15544817876002548, 0.16161826599521578, 0.15548958048752026, 0.2549514696308188, 0.126843353729031, 0.15836374316664237, 0.2922728747767084, 0.21246664018902572, 0.19189562894135936, 0.16525207211754767, 0.11914177285867678, 0.12216110249546586, 0.20897031814995848, 0.17773611833488134, 0.17937345974596397, 0.19713070495104978, 0.1707122858571558, 0.11049858668523682, 0.18400868506648382, 0.14156160594760092, 0.11306978943068369, 0.15471602371838744, 0.15481113541203506, 0.16315527460972334, 0.16113112616755243, 0.17494469991331785, 0.15269413460375258, 0.1685233630667754, 0.1653716009326025, 0.1658375888066257, 0.0575014726279085, 0.04944397607319495, 0.05033341316799145, 0.050003918159232885, 0.05857607953998745, 0.052657257492866094, 0.057754841571624804, 0.04897295470462959, 0.06475398523804599]}, "mutation_prompt": null}
{"id": "7d54379c-17a4-4699-9511-4d5230c8179e", "solution": "import numpy as np\n\nclass ImprovedHybridDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(12, 6 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6  # slightly increased for more exploration\n        self.CR = 0.85  # slightly adjusted for better balance\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.3  # increased elite fraction for diverse exploitation\n        self.adaptive_factor = 0.15  # slightly increased for faster adaptation\n        self.mutation_probability = 0.07  # slightly increased for more diversity\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.5, 0.95)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.75, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "ImprovedHybridDEAdaptive", "description": "Improved Hybrid Differential Evolution with Reinforced Adaptive Strategy and Enhanced Exploration for Robust Optimization.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "metadata": {}, "mutation_prompt": null}
{"id": "34e1e5ca-c5d2-4cce-83aa-d01b395b5752", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(15, 6 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6\n        self.CR = 0.85\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.15\n        self.adaptive_factor = 0.15\n        self.mutation_probability = 0.1\n        self.history = np.zeros(3)\n        self.adaptive_learning_rate = 0.05\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.3, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 1.0)\n        self.adaptive_learning_rate = np.clip(self.adaptive_learning_rate + 0.01 * (np.random.rand() - 0.5), 0.01, 0.1)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += self.adaptive_learning_rate\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution with Adaptive Learning and Stochastic Self-Adjustment.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "metadata": {}, "mutation_prompt": null}
{"id": "deebe5c7-f845-4d64-abef-6be027b7a2e4", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(12, 6 * dim)  # Slight increase in population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.15  # Adjusted elite fraction\n        self.adaptive_factor = 0.15  # More aggressive adaptation\n        self.mutation_probability = 0.08  # Slightly increased mutation probability\n\n    def select_strategy(self):\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.best_2_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def best_2_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.3, 0.95)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDE", "description": "Enhanced Hybrid Differential Evolution with Stochastic Adaptive Control, Elite Memetic Crossover, and Dynamic Mutation for Robust Optimization.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "metadata": {}, "mutation_prompt": null}
{"id": "f5dc5c6b-806c-421e-8970-96e68e72f160", "solution": "import numpy as np\n\nclass EnhancedHybridDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.2\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDEAdaptive", "description": "Enhanced Hybrid Differential Evolution with Adaptive Learning Rate and Memory Mechanism for Robust Optimization.", "configspace": "", "generation": 73, "fitness": 0.29769594721748927, "feedback": "The algorithm EnhancedHybridDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.21.", "error": "", "parent_id": "1fc16af3-7d28-4d9b-ab11-82e471e795ca", "metadata": {"aucs": [0.7513545070642655, 0.7266103945396603, 0.7342681003743858, 0.7900840046020879, 0.6257863406002919, 0.7169641673728242, 0.738679491916764, 0.7161357578717856, 0.6733572923486688, 0.4515409441845558, 0.4969725047331641, 0.48909524637553636, 0.5681277337553967, 0.46738560723289735, 0.4403729952331731, 0.21788729590729794, 0.5456660130402775, 0.4413529163751324, 0.09850720769231758, 0.10996517653234072, 0.11607232388208943, 0.11336554946765032, 0.09259002472838451, 0.11075622871842083, 0.11686679952371581, 0.11737872269524063, 0.09571621611624592, 0.09400009249381402, 0.10336878145652195, 0.08442316762790192, 0.08436259915965116, 0.07783756167083289, 0.08210496572172654, 0.09304419256772656, 0.0803993981877944, 0.08202325232539676, 0.8642635356341908, 0.7641438375213543, 0.6182556723703554, 0.8318541152219765, 0.7529480220605399, 0.7064170193868198, 0.6256221457760855, 0.596525800141531, 0.5531868325549312, 0.2618187155864532, 0.3281024712425997, 0.32196671661221066, 0.2721279593734671, 0.35277060681305183, 0.3688011239974962, 0.2830616146843933, 0.3212990906207156, 0.2333065366674959, 0.7849009434761411, 0.6917662695489507, 0.6698851189381178, 0.20154420849429389, 0.6827500405942661, 0.6590859512301654, 0.22064050923661083, 0.7468725327486314, 0.7898794411197714, 0.31657514928530517, 0.28168219340828704, 0.1888203191196448, 0.17694328751138344, 0.12175853573625317, 0.1444058389769125, 0.1411253707900585, 0.16192675332318518, 0.1960622630954385, 0.13695601579970806, 0.20728833021696658, 0.12706180113365484, 0.17450777008918517, 0.17627143059491102, 0.1306579451272475, 0.14231860318730194, 0.1614408850747906, 0.1475071535223207, 0.29644195753590163, 0.2825194832792496, 0.28063074819368794, 0.28408595779228063, 0.35396076739050764, 0.31383498825143186, 0.13173633797878703, 0.0557021526715924, 0.2938937170571865, 0.479842285817371, 0.42583873342146317, 0.22947023604423, 0.5544230929701002, 0.16713269916146323, 0.13914681355912073, 0.42195459683673575, 0.4707558802705325, 0.5735615472337279, 0.06471566968508391, 0.12399457948212289, 0.1249667320210488, 0.13541262655738706, 0.19730234390781776, 0.238473410644077, 0.21240492726944005, 0.061659952196861156, 0.15243586358979933, 0.3183929031598923, 0.26080765231305847, 0.18976370572397505, 0.2807848087891309, 0.24257992191571687, 0.3349729186158741, 0.32122425104753716, 0.3342846997016685, 0.33583936858654884, 0.6785346117538684, 0.46324249591513145, 0.6200433636730283, 0.4429964268240443, 0.5679370218066209, 0.6733919688099743, 0.7285357517764326, 0.6639324043627775, 0.5766888826176126, 0.08136034446703255, 0.09721046401575462, 0.08846069556063463, 0.10318000866852994, 0.08306764294398894, 0.0867240027468913, 0.08433945304921142, 0.08492279903912492, 0.09779376055777955, 0.13354266345014132, 0.13388437646422424, 0.28253106181535115, 0.13204118444336022, 0.14966926129076796, 0.14663033692696903, 0.18208681527907122, 0.11653689357435049, 0.13596688083883401, 0.37331025328089784, 0.3438874879432897, 0.38139031908753984, 0.36640245085755163, 0.319700942157081, 0.3721053609843491, 0.4184825889160284, 0.43141133564602374, 0.4649921617402015, 0.2698981702161204, 0.3226405736682193, 0.2899625432892914, 0.34609588297065597, 0.25821852789470623, 0.28661482550207407, 0.3125664448886347, 0.3272190174463836, 0.27816964717801274, 0.18506865849462206, 0.17491896720247202, 0.19499274301130798, 0.1768766113825817, 0.17977839971942633, 0.17780059759036126, 0.19316257371194256, 0.1898784800444856, 0.19703658392563772, 0.1869493545946339, 0.18892842839380475, 0.18719497190369017, 0.27863714673202944, 0.1868655235067329, 0.18477174276630925, 0.18028794427204686, 0.1783594640742724, 0.1779328593984446, 0.1730091879637815, 0.17368420742203527, 0.16465041661776592, 0.16678470401156886, 0.6386307904641333, 0.40316048216266576, 0.14327236436444857, 0.15974151051020435, 0.7006698758719441, 0.49620449791807497, 0.1980157427212933, 0.20059589472555373, 0.19765364486503834, 0.37496244866768424, 0.2032845138829663, 0.19361747561918385, 0.17559490094045827, 0.42212200875094275, 0.18428595206511678, 0.1753571335394437, 0.18284569819950247, 0.17677096277197635, 0.17705907005072186, 0.16855549934688185, 0.18073601020813712, 0.17038048583312104, 0.1707838537641586, 0.07328464864698048, 0.0630101989658326, 0.07158383104629407, 0.07907402465243207, 0.06851303904977302, 0.06589340327086157, 0.08138733674032506, 0.07428977841195805, 0.06861946545752617]}, "mutation_prompt": null}
{"id": "0c8bd20a-c6f2-4d51-9858-b6a6c5197ba0", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.7\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.history = np.zeros(3)\n        self.func = None\n        self.success_rates = np.zeros(3)\n        self.elite_fraction = 0.15\n        self.adaptive_factor = 0.15\n        self.mutation_probability = 0.08\n        self.memory = {}\n        self.learning_rate = 0.07\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        total_success = np.sum(self.success_rates)\n        probabilities = self.success_rates / total_success if total_success > 0 else np.ones(3) / 3\n        return np.random.choice(3, p=probabilities)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 0.9)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.history[strat_index] += 1\n                    self.success_rates[strat_index] += 1\n                else:\n                    self.success_rates[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemeticDE", "description": "Adaptive Evolutionary Algorithm with Dynamic Memetic Learning for Enhanced Global Optimization.", "configspace": "", "generation": 74, "fitness": 0.2655722464053509, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "f5dc5c6b-806c-421e-8970-96e68e72f160", "metadata": {"aucs": [0.6470190496312845, 0.7312569212155609, 0.6252542314344143, 0.6649743126503005, 0.7071628634261278, 0.674171540279031, 0.6929480697396455, 0.6794824547921554, 0.6382120182256753, 0.43428242655883553, 0.5344776657239987, 0.39531184557192167, 0.3890962931753673, 0.5442714163019593, 0.3832040256178125, 0.42896773076640726, 0.49778740352454687, 0.37449432921238957, 0.09818248330446244, 0.09126845324204136, 0.1006070468817245, 0.08675244384996206, 0.10292793862547511, 0.08228635033964582, 0.09908565037394435, 0.10790811006984136, 0.10284043976443302, 0.0838155261196245, 0.084727499373761, 0.07449587411847491, 0.08558741309657214, 0.09630072990244065, 0.09740323504299708, 0.09618374574474342, 0.08484659662237137, 0.07473450758946998, 0.8397108708466197, 0.8068648789825434, 0.8825590341818556, 0.902845292298824, 0.7984680730219456, 0.9566944256810408, 0.8139848316757519, 0.8150140711693712, 0.8457134398121068, 0.25650237423583055, 0.29708472912678763, 0.26800201284587366, 0.26922467713745113, 0.2552640357360024, 0.2587253475272897, 0.2871697630053809, 0.24678467190489217, 0.269443809640434, 0.5813204192745727, 0.6341883602184168, 0.4866478623436037, 0.6118255461993084, 0.6073116823160509, 0.4721483500758975, 0.539441800131789, 0.6415812035841018, 0.5347051862035808, 0.13844422695447478, 0.1595478684254229, 0.136926046006554, 0.15415778256718327, 0.16535687903515917, 0.159610789687875, 0.15718810249044002, 0.16605842215087252, 0.1209382491175125, 0.2467866228024539, 0.09478681895832342, 0.11678979044805149, 0.17873559134739803, 0.13586221934787723, 0.1259607233336585, 0.1047160593401053, 0.2119252738305244, 0.15807287179100837, 0.07800440961775568, 0.15743926423772336, 0.09568577691186542, 0.17661816126134344, 0.2708670574547202, 0.08982528870062467, 0.19450186788584112, 0.18161328368720975, 0.08033155916551438, 0.17961448383736134, 0.38002255788136297, 0.24203273624916066, 0.23244153549787516, 0.23960831746614353, 0.19069422257571933, 0.2847675308269767, 0.3218906697936391, 0.22338281541162364, 0.02882851027162725, 0.04710039223077145, 0.035592823851192446, 0.06587121712079913, 0.1347628662581517, 0.07693376930022566, 0.051291406722155264, 0.11428493639079729, 0.03489645561032373, 0.17120980125795937, 0.17350996747229253, 0.12997542157664088, 0.15932402593470418, 0.20296534448055714, 0.14332394339265486, 0.19640320462339145, 0.20107510141683238, 0.1467736313144724, 0.49306787319907064, 0.638850603435756, 0.4943391289239779, 0.4958411295070395, 0.5512890141859723, 0.46314479494808547, 0.4851128741346401, 0.6034047195857655, 0.5121774109273174, 0.08213435977167083, 0.07492000774483187, 0.1009795544970461, 0.08498908237252001, 0.06720838885722935, 0.07160849264136182, 0.08785118215045473, 0.08591014489420357, 0.11646653067680823, 0.12669147029966732, 0.14404673411601376, 0.12633831919668825, 0.1202594312687364, 0.1508535127207844, 0.13570378795528026, 0.15043391313443066, 0.11047806444988395, 0.12563342284310475, 0.28509324606298037, 0.3001139378807539, 0.3040970573338799, 0.2500653568536424, 0.3445449371795717, 0.29716409108474406, 0.2826618259450928, 0.37839684023004994, 0.2775125822923721, 0.248256349804305, 0.26212040706670325, 0.21151332372509468, 0.19578361500492336, 0.2761225322116616, 0.20159997663773455, 0.23789958903006925, 0.28427612662047463, 0.18276088024608694, 0.1742207864526687, 0.1768707463161885, 0.17728782129187626, 0.20205743314524116, 0.20656526256303154, 0.17300136765919438, 0.1684033654846957, 0.2069350875930459, 0.19265916245884562, 0.1632606144013451, 0.16903660347436766, 0.17002726249259104, 0.1660812399535998, 0.19770562375408152, 0.1707033519298251, 0.16584059366973036, 0.16813643351510477, 0.16496802474522032, 0.24080429782305723, 0.15441039310368743, 0.47196206505924, 0.17825040953085336, 0.17628458102757016, 0.16222633690993038, 0.1650989472592208, 0.5036786843956904, 0.1580869549781042, 0.34463798950005964, 0.15351986628224912, 0.17972953467304864, 0.2238188391960192, 0.5088834822750927, 0.4116730569741489, 0.34502820432112735, 0.43761238421969695, 0.12377341930566421, 0.1803614107599617, 0.19904350147453875, 0.19503007486850255, 0.19730594080393793, 0.18476130610289765, 0.19306214817461265, 0.1835200667753577, 0.17277444144271337, 0.1948069767922862, 0.07905234340337375, 0.07015560322225955, 0.06202902793311493, 0.07372208217143472, 0.0823369774381374, 0.06773534705063611, 0.08257644748423032, 0.07212050699535266, 0.06337008286919554]}, "mutation_prompt": null}
{"id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "solution": "import numpy as np\n\nclass SynergizedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "SynergizedMemeticDE", "description": "Synergized Memetic Differential Evolution with Self-Adaptive Strategy Selection for Adaptive Optimization.", "configspace": "", "generation": 75, "fitness": 0.32088955148295545, "feedback": "The algorithm SynergizedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "f5dc5c6b-806c-421e-8970-96e68e72f160", "metadata": {"aucs": [0.7788463382149456, 0.7222233227025788, 0.7119897024608502, 0.7872539598804809, 0.6697637107389571, 0.7299586160827567, 0.7280997172209203, 0.7700207881007501, 0.7406958809927395, 0.6218370781976879, 0.5752122875114816, 0.5232453513110437, 0.5620006232021444, 0.54072874598375, 0.5019536302129185, 0.28900440421261986, 0.5603810730042138, 0.5593098247444007, 0.10521036313066034, 0.09320834941053258, 0.11258743499396673, 0.1067897775585438, 0.1036195526006759, 0.08627383971329528, 0.12707716814742942, 0.09516375977408098, 0.08995676347362802, 0.11592019421793809, 0.08250011804273383, 0.08131115101316477, 0.09546741906285228, 0.08963144134998524, 0.07325625281972115, 0.07849354466805414, 0.07545139332300421, 0.0708048359285276, 0.861941010981822, 0.8971908414162126, 0.6612370681904074, 0.7708696894379478, 0.7163555498995502, 0.8250445219414547, 0.8246601216128293, 0.7655937654091072, 0.6653637873887162, 0.1743542157423551, 0.30881355747055417, 0.325665605578738, 0.35217832987227005, 0.35159305745804403, 0.3310880144653249, 0.23768881282148746, 0.35281248714057056, 0.31534423377370335, 0.717156186666721, 0.7152509580951149, 0.7694167693221193, 0.7739087214503402, 0.6983267963951303, 0.5705219263219026, 0.6878657419509291, 0.4243779679415507, 0.48888617565081904, 0.21785467395573987, 0.19538891686141924, 0.21092203540250076, 0.2373482030760815, 0.19690625202219725, 0.2715508675748407, 0.15957217919696265, 0.18304263867915138, 0.2693927208891538, 0.17987020302450585, 0.20224344102444836, 0.1762085294957484, 0.23357766656633416, 0.17760479659726114, 0.37143091241162474, 0.14301556734618914, 0.27968896086435446, 0.12879597665830655, 0.45778505924673885, 0.40520938244170157, 0.45186602566895795, 0.33963890446362943, 0.4082225208890312, 0.4761194845333433, 0.05525861679495081, 0.46179221628434663, 0.330705071249745, 0.1945883063025261, 0.446968619623886, 0.517288249078051, 0.47662933004324926, 0.457947481912213, 0.4385631511156085, 0.5292308367562681, 0.4078991704943833, 0.506346546440023, 0.10827588638823105, 0.112576613062644, 0.15654298198335947, 0.11361337238840097, 0.11416934958047986, 0.3471054887012992, 0.24033305671634542, 0.14773385473504408, 0.07247347257402803, 0.2729341011130033, 0.28323725957262125, 0.298962448085047, 0.3646354595034459, 0.2951319221840737, 0.3781141676917439, 0.23312535157120073, 0.2692240745106065, 0.29342406159216183, 0.47404334368694634, 0.6403134236705154, 0.6664638215743005, 0.6466068507347629, 0.6045447355719609, 0.6692076646039808, 0.7035799909476368, 0.5596990305852284, 0.6326087041208002, 0.09168457508203776, 0.08958559939747468, 0.09047958965771663, 0.10879261485836922, 0.08408005700568955, 0.09283306399873714, 0.10717305354511208, 0.10046583767119954, 0.07451049059448578, 0.15724524156933617, 0.12359200505599743, 0.13306770859049433, 0.1215059008634718, 0.12095843205552592, 0.12882743901703997, 0.1337531586984516, 0.12223213091267049, 0.12580263637107802, 0.39075609884837914, 0.36472260426548, 0.3298749832187664, 0.3498591525115464, 0.3328451446675328, 0.33665338885327634, 0.3824050776819484, 0.3510918950752272, 0.4129295852631687, 0.2814084661077525, 0.26198635350297506, 0.2641382576683833, 0.26958793524366775, 0.2271825027349974, 0.29768874626470776, 0.3538501826387844, 0.28639744580240833, 0.3456874441535813, 0.20402223650003326, 0.19556653877727004, 0.2078026880387156, 0.20098544723749945, 0.22471606106384634, 0.19859485277646727, 0.18047602763759218, 0.1960839157811518, 0.19688314169823629, 0.19357345127892478, 0.17986929722928668, 0.16503015506348961, 0.18149836102994, 0.1736284554292724, 0.16901589746116352, 0.16471802110435352, 0.1753848469130851, 0.17277380456912073, 0.19970360669769283, 0.6608961040029048, 0.18114635879929708, 0.542514759392418, 0.20317264619709585, 0.5231039481787816, 0.7630279585606847, 0.5135031952271126, 0.7610686457944482, 0.25969617067764517, 0.20145860458356446, 0.18244915553874907, 0.15993582957341024, 0.42299883869588295, 0.15632301098026857, 0.15756285468632925, 0.21235786192188455, 0.1952869095292552, 0.16595995080467296, 0.19809167888272738, 0.17738810979752984, 0.1570003792884196, 0.16817963519325407, 0.19041755934225724, 0.18360442985325887, 0.1800634886271547, 0.1707659198681527, 0.07009133261412392, 0.07579438439643105, 0.0735957175464218, 0.08418775240322707, 0.07410162313045254, 0.07554317297248758, 0.07549519201571586, 0.06956569711964167, 0.06590430755300547]}, "mutation_prompt": null}
{"id": "8e085690-ec37-4e48-ac13-1360801515f4", "solution": "import numpy as np\n\nclass SynergizedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "SynergizedMemeticDE", "description": "Synergized Memetic Differential Evolution with Self-Adaptive Strategy Selection for Adaptive Optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.7788463382149456, 0.7222233227025788, 0.7119897024608502, 0.7872539598804809, 0.6697637107389571, 0.7299586160827567, 0.7280997172209203, 0.7700207881007501, 0.7406958809927395, 0.6218370781976879, 0.5752122875114816, 0.5232453513110437, 0.5620006232021444, 0.54072874598375, 0.5019536302129185, 0.28900440421261986, 0.5603810730042138, 0.5593098247444007, 0.10521036313066034, 0.09320834941053258, 0.11258743499396673, 0.1067897775585438, 0.1036195526006759, 0.08627383971329528, 0.12707716814742942, 0.09516375977408098, 0.08995676347362802, 0.11592019421793809, 0.08250011804273383, 0.08131115101316477, 0.09546741906285228, 0.08963144134998524, 0.07325625281972115, 0.07849354466805414, 0.07545139332300421, 0.0708048359285276, 0.861941010981822, 0.8971908414162126, 0.6612370681904074, 0.7708696894379478, 0.7163555498995502, 0.8250445219414547, 0.8246601216128293, 0.7655937654091072, 0.6653637873887162, 0.1743542157423551, 0.30881355747055417, 0.325665605578738, 0.35217832987227005, 0.35159305745804403, 0.3310880144653249, 0.23768881282148746, 0.35281248714057056, 0.31534423377370335, 0.717156186666721, 0.7152509580951149, 0.7694167693221193, 0.7739087214503402, 0.6983267963951303, 0.5705219263219026, 0.6878657419509291, 0.4243779679415507, 0.48888617565081904, 0.21785467395573987, 0.19538891686141924, 0.21092203540250076, 0.2373482030760815, 0.19690625202219725, 0.2715508675748407, 0.15957217919696265, 0.18304263867915138, 0.2693927208891538, 0.17987020302450585, 0.20224344102444836, 0.1762085294957484, 0.23357766656633416, 0.17760479659726114, 0.37143091241162474, 0.14301556734618914, 0.27968896086435446, 0.12879597665830655, 0.45778505924673885, 0.40520938244170157, 0.45186602566895795, 0.33963890446362943, 0.4082225208890312, 0.4761194845333433, 0.05525861679495081, 0.46179221628434663, 0.330705071249745, 0.1945883063025261, 0.446968619623886, 0.517288249078051, 0.47662933004324926, 0.457947481912213, 0.4385631511156085, 0.5292308367562681, 0.4078991704943833, 0.506346546440023, 0.10827588638823105, 0.112576613062644, 0.15654298198335947, 0.11361337238840097, 0.11416934958047986, 0.3471054887012992, 0.24033305671634542, 0.14773385473504408, 0.07247347257402803, 0.2729341011130033, 0.28323725957262125, 0.298962448085047, 0.3646354595034459, 0.2951319221840737, 0.3781141676917439, 0.23312535157120073, 0.2692240745106065, 0.29342406159216183, 0.47404334368694634, 0.6403134236705154, 0.6664638215743005, 0.6466068507347629, 0.6045447355719609, 0.6692076646039808, 0.7035799909476368, 0.5596990305852284, 0.6326087041208002, 0.09168457508203776, 0.08958559939747468, 0.09047958965771663, 0.10879261485836922, 0.08408005700568955, 0.09283306399873714, 0.10717305354511208, 0.10046583767119954, 0.07451049059448578, 0.15724524156933617, 0.12359200505599743, 0.13306770859049433, 0.1215059008634718, 0.12095843205552592, 0.12882743901703997, 0.1337531586984516, 0.12223213091267049, 0.12580263637107802, 0.39075609884837914, 0.36472260426548, 0.3298749832187664, 0.3498591525115464, 0.3328451446675328, 0.33665338885327634, 0.3824050776819484, 0.3510918950752272, 0.4129295852631687, 0.2814084661077525, 0.26198635350297506, 0.2641382576683833, 0.26958793524366775, 0.2271825027349974, 0.29768874626470776, 0.3538501826387844, 0.28639744580240833, 0.3456874441535813, 0.20402223650003326, 0.19556653877727004, 0.2078026880387156, 0.20098544723749945, 0.22471606106384634, 0.19859485277646727, 0.18047602763759218, 0.1960839157811518, 0.19688314169823629, 0.19357345127892478, 0.17986929722928668, 0.16503015506348961, 0.18149836102994, 0.1736284554292724, 0.16901589746116352, 0.16471802110435352, 0.1753848469130851, 0.17277380456912073, 0.19970360669769283, 0.6608961040029048, 0.18114635879929708, 0.542514759392418, 0.20317264619709585, 0.5231039481787816, 0.7630279585606847, 0.5135031952271126, 0.7610686457944482, 0.25969617067764517, 0.20145860458356446, 0.18244915553874907, 0.15993582957341024, 0.42299883869588295, 0.15632301098026857, 0.15756285468632925, 0.21235786192188455, 0.1952869095292552, 0.16595995080467296, 0.19809167888272738, 0.17738810979752984, 0.1570003792884196, 0.16817963519325407, 0.19041755934225724, 0.18360442985325887, 0.1800634886271547, 0.1707659198681527, 0.07009133261412392, 0.07579438439643105, 0.0735957175464218, 0.08418775240322707, 0.07410162313045254, 0.07554317297248758, 0.07549519201571586, 0.06956569711964167, 0.06590430755300547]}, "mutation_prompt": null}
{"id": "75662981-bcc3-4610-971f-9549ce1ef635", "solution": "import numpy as np\n\nclass HybridizedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        strategies = [self.rand_1, self.best_2, self.current_to_rand_1]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def best_2(self, idx):\n        best_idx = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx and i != best_idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[best_idx] + self.F * (self.population[r1] - self.population[r2])\n\n    def current_to_rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[idx] + self.F * (self.population[r1] - self.population[r2] + self.population[r3] - self.population[idx])\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "HybridizedDE", "description": "Hybridized Differential Evolution with Adaptive Crossover and Mutation for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 77, "fitness": 0.17154773680883068, "feedback": "The algorithm HybridizedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.48016010391971564, 0.20988833348864466, 0.37421754206371416, 0.26073548067061336, 0.44975358060428694, 0.35228328994954905, 0.4430139479099091, 0.43083659625486725, 0.35521271899984785, 0.0997344566096584, 0.03481501535655007, 0.04369023567152508, 0.1060437239820945, 0.10995818115166167, 0.012749521968862587, 9.999999999998899e-05, 0.11846590714045413, 0.015617388280704247, 0.07209723118863642, 0.07074312300926089, 0.05489563994577906, 0.075474994716626, 0.06205086095340562, 0.06309114486287648, 0.08995599411314237, 0.07628836438497588, 0.06882501584410583, 0.046164835465013265, 0.05450692553833292, 0.05434279912236306, 0.07133148231635422, 0.05342612765917132, 0.040723557366255436, 0.06883515834685017, 0.0744600090285803, 0.05120433929989554, 0.9337470224871964, 0.8650542814829443, 0.6900586518513865, 0.7199550825102814, 0.8822157750591652, 0.6825143945779044, 0.9267591828110089, 0.8057679076937085, 0.9316772485976768, 0.1947540757805225, 0.1191804211448938, 0.1263359598802818, 0.22481015314080377, 0.21056119548144292, 0.18761250077698222, 0.10982501005012313, 0.19668945495557022, 0.16670070671882498, 0.31298273050675085, 0.13852535787325038, 0.21995716740089322, 0.2237010638037722, 0.22486064947286366, 0.41357430780969195, 0.23558627067523485, 0.15056003768719384, 0.2722002001186331, 0.10840687795198956, 0.11267394480030346, 0.10992323249694091, 0.07712433038691491, 0.08331676119740461, 0.0901173332864561, 0.09465957403458614, 0.07839935928781849, 0.10205787929269028, 0.09584253390482367, 0.16232489332096778, 0.1273001955474503, 0.11194987902359732, 0.1179021193848927, 0.10286323172284006, 0.12086746155698203, 0.11399928811825943, 0.09109265564304991, 9.999999999998899e-05, 0.015655743938904343, 9.999999999998899e-05, 0.013008484365402695, 9.999999999998899e-05, 0.0006116386749841496, 0.009546916143533646, 0.0019606651520205354, 9.999999999998899e-05, 0.09541283654757349, 0.05973335296617388, 0.09978750362830702, 0.041647374709891105, 0.09883954832913167, 0.008754415209597743, 0.15311986408523792, 0.1789481781850607, 0.07631895718097925, 0.028605555681550543, 0.002966141017058388, 0.014515962181291253, 0.03326736270449293, 0.029407229740929908, 0.019164621716829422, 0.014885769973315699, 0.01616681675543663, 9.999999999998899e-05, 0.09244721771717068, 0.0569999132307899, 0.07800065711206494, 0.08560103274478592, 0.03000958585791136, 0.03866907202819003, 0.055394285886689265, 0.0464417955975992, 0.043517519403408755, 0.385697435952435, 0.30756236592673025, 0.32713685659664593, 0.31472177839486226, 0.3088935925477303, 0.349381147191682, 0.39447281104737353, 0.3257375537248307, 0.39531039638959165, 0.06246568191289548, 0.061511711622873944, 0.054574312515726864, 0.06669512342681405, 0.07421064678783551, 0.07389929548876639, 0.08797672869938467, 0.06670424691442423, 0.06027091843194177, 0.09916726613723625, 0.11608483828527172, 0.13694911172777524, 0.12720206026778613, 0.11018731030576367, 0.09427117224038006, 0.11963854280090813, 0.09132849232123408, 0.10524405368602607, 0.2431545066842593, 0.22855624233890726, 0.23592223018897174, 0.25950504465649915, 0.23136022229223008, 0.23859552236227177, 0.20447370232641104, 0.24907610177798156, 0.1941924424719218, 0.17381271915375163, 0.1475241946241569, 0.16213177114671384, 0.17708257906941594, 0.17583098836128008, 0.2390124554767602, 0.15005005055964593, 0.16198807701522477, 0.18600845828511525, 0.15396240750416568, 0.17690447417238742, 0.1975906839387207, 0.18156428716923279, 0.1623186865918277, 0.17644334252142835, 0.1761626641593591, 0.20784880868497468, 0.1636556005422961, 0.1679508583805266, 0.1517105686152821, 0.15849092722135816, 0.16039728418916388, 0.15823256456291146, 0.14918168285510747, 0.16802909007276157, 0.1667287051652152, 0.1517955081528347, 0.5623104965604502, 0.1213227886162882, 0.1413372949672541, 0.16679001837855323, 0.1609277006196559, 0.18753983862774326, 0.36265566586746756, 0.15100302925476938, 0.44924994768433446, 0.07878860955767508, 0.1414918718161292, 0.15317616635319686, 0.32120909361213446, 0.15048791574306597, 0.305140300329347, 0.2090710519844592, 0.20484158987542533, 0.15764616502666118, 0.15009924231388327, 0.1591266345896547, 0.15270036809866594, 0.1640380558002813, 0.1521456579321413, 0.15394738480083292, 0.16086557985420846, 0.15167072369124912, 0.15583193251949867, 0.07983405741042626, 0.06327245178814433, 0.05999644250623337, 0.06544528041632947, 0.05777716277953204, 0.06722504208711944, 0.055418060702506766, 0.06793122471343982, 0.05486739223510717]}, "mutation_prompt": null}
{"id": "09f92fa6-ba0e-422c-bdd7-9081ca08d940", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Probabilistic Strategy Refinement for Enhanced Convergence.", "configspace": "", "generation": 78, "fitness": 0.32088955148295545, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.7788463382149456, 0.7222233227025788, 0.7119897024608502, 0.7872539598804809, 0.6697637107389571, 0.7299586160827567, 0.7280997172209203, 0.7700207881007501, 0.7406958809927395, 0.6218370781976879, 0.5752122875114816, 0.5232453513110437, 0.5620006232021444, 0.54072874598375, 0.5019536302129185, 0.28900440421261986, 0.5603810730042138, 0.5593098247444007, 0.10521036313066034, 0.09320834941053258, 0.11258743499396673, 0.1067897775585438, 0.1036195526006759, 0.08627383971329528, 0.12707716814742942, 0.09516375977408098, 0.08995676347362802, 0.11592019421793809, 0.08250011804273383, 0.08131115101316477, 0.09546741906285228, 0.08963144134998524, 0.07325625281972115, 0.07849354466805414, 0.07545139332300421, 0.0708048359285276, 0.861941010981822, 0.8971908414162126, 0.6612370681904074, 0.7708696894379478, 0.7163555498995502, 0.8250445219414547, 0.8246601216128293, 0.7655937654091072, 0.6653637873887162, 0.1743542157423551, 0.30881355747055417, 0.325665605578738, 0.35217832987227005, 0.35159305745804403, 0.3310880144653249, 0.23768881282148746, 0.35281248714057056, 0.31534423377370335, 0.717156186666721, 0.7152509580951149, 0.7694167693221193, 0.7739087214503402, 0.6983267963951303, 0.5705219263219026, 0.6878657419509291, 0.4243779679415507, 0.48888617565081904, 0.21785467395573987, 0.19538891686141924, 0.21092203540250076, 0.2373482030760815, 0.19690625202219725, 0.2715508675748407, 0.15957217919696265, 0.18304263867915138, 0.2693927208891538, 0.17987020302450585, 0.20224344102444836, 0.1762085294957484, 0.23357766656633416, 0.17760479659726114, 0.37143091241162474, 0.14301556734618914, 0.27968896086435446, 0.12879597665830655, 0.45778505924673885, 0.40520938244170157, 0.45186602566895795, 0.33963890446362943, 0.4082225208890312, 0.4761194845333433, 0.05525861679495081, 0.46179221628434663, 0.330705071249745, 0.1945883063025261, 0.446968619623886, 0.517288249078051, 0.47662933004324926, 0.457947481912213, 0.4385631511156085, 0.5292308367562681, 0.4078991704943833, 0.506346546440023, 0.10827588638823105, 0.112576613062644, 0.15654298198335947, 0.11361337238840097, 0.11416934958047986, 0.3471054887012992, 0.24033305671634542, 0.14773385473504408, 0.07247347257402803, 0.2729341011130033, 0.28323725957262125, 0.298962448085047, 0.3646354595034459, 0.2951319221840737, 0.3781141676917439, 0.23312535157120073, 0.2692240745106065, 0.29342406159216183, 0.47404334368694634, 0.6403134236705154, 0.6664638215743005, 0.6466068507347629, 0.6045447355719609, 0.6692076646039808, 0.7035799909476368, 0.5596990305852284, 0.6326087041208002, 0.09168457508203776, 0.08958559939747468, 0.09047958965771663, 0.10879261485836922, 0.08408005700568955, 0.09283306399873714, 0.10717305354511208, 0.10046583767119954, 0.07451049059448578, 0.15724524156933617, 0.12359200505599743, 0.13306770859049433, 0.1215059008634718, 0.12095843205552592, 0.12882743901703997, 0.1337531586984516, 0.12223213091267049, 0.12580263637107802, 0.39075609884837914, 0.36472260426548, 0.3298749832187664, 0.3498591525115464, 0.3328451446675328, 0.33665338885327634, 0.3824050776819484, 0.3510918950752272, 0.4129295852631687, 0.2814084661077525, 0.26198635350297506, 0.2641382576683833, 0.26958793524366775, 0.2271825027349974, 0.29768874626470776, 0.3538501826387844, 0.28639744580240833, 0.3456874441535813, 0.20402223650003326, 0.19556653877727004, 0.2078026880387156, 0.20098544723749945, 0.22471606106384634, 0.19859485277646727, 0.18047602763759218, 0.1960839157811518, 0.19688314169823629, 0.19357345127892478, 0.17986929722928668, 0.16503015506348961, 0.18149836102994, 0.1736284554292724, 0.16901589746116352, 0.16471802110435352, 0.1753848469130851, 0.17277380456912073, 0.19970360669769283, 0.6608961040029048, 0.18114635879929708, 0.542514759392418, 0.20317264619709585, 0.5231039481787816, 0.7630279585606847, 0.5135031952271126, 0.7610686457944482, 0.25969617067764517, 0.20145860458356446, 0.18244915553874907, 0.15993582957341024, 0.42299883869588295, 0.15632301098026857, 0.15756285468632925, 0.21235786192188455, 0.1952869095292552, 0.16595995080467296, 0.19809167888272738, 0.17738810979752984, 0.1570003792884196, 0.16817963519325407, 0.19041755934225724, 0.18360442985325887, 0.1800634886271547, 0.1707659198681527, 0.07009133261412392, 0.07579438439643105, 0.0735957175464218, 0.08418775240322707, 0.07410162313045254, 0.07554317297248758, 0.07549519201571586, 0.06956569711964167, 0.06590430755300547]}, "mutation_prompt": null}
{"id": "fd95e112-5a34-4077-8879-e90ee9de2e71", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(12, 6 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6\n        self.CR = 0.85\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.12\n        self.mutation_probability = 0.07\n        self.memory = {}\n        self.learning_rate = 0.07\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.25 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.5, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.75, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.02, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMultiStrategyMemeticDE", "description": "Adaptive Multi-Strategy Memetic DE with Dynamic Parameter Adjustments and Elite-guided Search.", "configspace": "", "generation": 79, "fitness": 0.2568277655507789, "feedback": "The algorithm AdaptiveMultiStrategyMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.6596444849570542, 0.6706180855030286, 0.5923029268877033, 0.6637814440746187, 0.6288766268937143, 0.5429122207108532, 0.7111547805146212, 0.6184004885794571, 0.5517064977860546, 0.417581691973958, 0.42319944708412305, 0.29229979271863893, 0.43348105490554856, 0.33847674784840476, 0.25896487565900517, 0.48587484392242486, 0.4480455364949304, 0.28020309802235643, 0.09927819495698731, 0.08346776645493559, 0.08346461336048872, 0.09903762948967543, 0.10643612757560317, 0.0724838907747255, 0.09429449871230555, 0.09243873287431725, 0.09327816282420132, 0.0729440162052657, 0.08464083795028343, 0.08207720481317082, 0.09040461779097064, 0.08308183049970796, 0.0738411551135556, 0.08258170708864676, 0.07239438529519338, 0.07185735949764827, 0.7541501542174882, 0.7926747908915652, 0.7554144279677902, 0.7968162664694491, 0.6299513802683199, 0.7576532635036192, 0.896497917854885, 0.794588308827755, 0.7411200711358005, 0.28903280255417174, 0.2619698482695372, 0.19724491747183182, 0.294924352644812, 0.24186269362059432, 0.20919052115356418, 0.27380928259746284, 0.2659142628758555, 0.22259881747713783, 0.5864684591560865, 0.5370881629343576, 0.4320597594491633, 0.5602036475204344, 0.5653962205324181, 0.6257153749610094, 0.5260153873739953, 0.6027794623027556, 0.4399334898811791, 0.13075821386108089, 0.1511932014993307, 0.1919047749581948, 0.18579734729228936, 0.11199329186588425, 0.12763347778627399, 0.22883617969543024, 0.15975889573269797, 0.16853805082060558, 0.16153818013403765, 0.1401216687515855, 0.13230172639180982, 0.13806207304562068, 0.10308980312288407, 0.1735249860017435, 0.21092065356111966, 0.14336452710189174, 0.11143905307425594, 0.236680159495681, 0.11498931226698883, 0.1598021899466625, 0.14188673582042177, 0.10941988345032572, 0.161906786606284, 0.2839453400175437, 0.10760228223003176, 0.1638650349639782, 0.28880715414840963, 0.20669289227988685, 0.26886195275836877, 0.389378301060056, 0.18197303659566544, 0.228108183076158, 0.2783807965640035, 0.26938196098069467, 0.3370751280098572, 0.048056457591499235, 0.007196867528748818, 0.02769246254049451, 0.10579588803211681, 0.051951254309207995, 0.11405421165384355, 0.13392269479201735, 0.02286378529867239, 0.05386612161348203, 0.20595295314983442, 0.1387325408163348, 0.15133554773461677, 0.2127309602700378, 0.13348491661727224, 0.1517078067390033, 0.19864526684171513, 0.16751674277447237, 0.16044617311966758, 0.5229864472835537, 0.47081871127492836, 0.4571284369227887, 0.5437409658452076, 0.5156959715731766, 0.4717348802049479, 0.5757167602697464, 0.482305515493085, 0.45579232324361874, 0.08748706633376291, 0.07841630187412252, 0.06404503008988727, 0.08100078869885297, 0.08404772670426386, 0.07146180287554893, 0.0821793947846654, 0.08434435835467735, 0.07154524345051338, 0.11698567774629332, 0.10876420926243335, 0.1193876387025884, 0.15143030427896542, 0.13643887823469247, 0.13008816177174776, 0.13442150205386805, 0.11548031222446475, 0.12108368471543474, 0.24296684303464, 0.2568485543963892, 0.26333784051502485, 0.3002666692998056, 0.2955111015760621, 0.26254624307119645, 0.3083919077594154, 0.3223295522414874, 0.2522726081736023, 0.21217320553175, 0.22129470355647562, 0.20634923881041067, 0.24956297043473952, 0.19996324117521613, 0.21052222271428067, 0.2316125035815345, 0.2501207868734314, 0.21577960493850945, 0.1721380070214953, 0.16533570405469566, 0.18459492578053205, 0.18943213001039372, 0.16776835192321793, 0.18022888018337324, 0.20022573374121488, 0.1804982791127384, 0.2036988814212174, 0.15802297420013633, 0.15632241322684126, 0.15318678414774545, 0.161421543731597, 0.1594848257519632, 0.16418315510550585, 0.16149472072791815, 0.16232757617896731, 0.16248363900640816, 0.5341485932547647, 0.15624974608909958, 0.4347888899539598, 0.26503549690803097, 0.4054384995682877, 0.17174643332122796, 0.5391462413951196, 0.20101202506875726, 0.46491111798445295, 0.6597273192790593, 0.3469824634955081, 0.3300107730634274, 0.16284432284613015, 0.5008549201837269, 0.17864310820311324, 0.2760102197705251, 0.18530943009232492, 0.1705002601310911, 0.160963073185583, 0.16265868551501972, 0.17621560187938612, 0.17877459567507414, 0.17115568076736876, 0.18355763474278086, 0.17449636783109235, 0.17349525464165194, 0.17846962230333996, 0.061458017859695624, 0.07643241355236952, 0.06654303661817051, 0.07427142564606914, 0.07718181521107692, 0.06265491449934546, 0.07038359326285515, 0.07167382739108275, 0.05973821438188931]}, "mutation_prompt": null}
{"id": "d97f1bb4-0518-4657-94f8-04f6b9011c1e", "solution": "import numpy as np\n\nclass AdaptiveQuantumMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.quantum_inspired]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def quantum_inspired(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        q_factor = np.random.rand() * 0.1\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2]) + q_factor * np.random.randn(self.dim)\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveQuantumMemeticDE", "description": "Adaptive Quantum-Inspired Memetic Differential Evolution for Enhanced Global Optimization.", "configspace": "", "generation": 80, "fitness": 0.2955435021037566, "feedback": "The algorithm AdaptiveQuantumMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.6976628860900139, 0.5092060405441556, 0.741329999946087, 0.6937005428458656, 0.7424931388084591, 0.6894206537637935, 0.6969602166020408, 0.7479155876219238, 0.6445920234650755, 0.4055874206590987, 0.4219843915316386, 0.3543284097580631, 0.4169067910209382, 0.5726589274408583, 0.5620617672883965, 0.6175162564016548, 0.3516672452431402, 0.520220542896419, 0.10211485177489488, 0.10397567545950204, 0.09486782480873335, 0.08772143694136136, 0.09568333523100914, 0.09342268904850914, 0.10503357479157516, 0.0908063788433554, 0.11313569359639075, 0.0846652287172045, 0.09357391564525441, 0.07680271044654585, 0.07966947957980008, 0.08486283967167396, 0.09360899084579599, 0.09249980568636507, 0.08184357682763088, 0.07750230368736588, 0.8909981805783912, 0.8802186323512446, 0.7602649783961122, 0.7659076829899616, 0.7638231411287133, 0.6832058993711636, 0.7979332147920204, 0.8445982728735335, 0.8539941064268373, 0.2996882936780513, 0.2533508629841943, 0.3836031417845517, 0.36528327883814304, 0.274366349414102, 0.2723810884009632, 0.2924338445669248, 0.3333170398648102, 0.39349939656240407, 0.6589338146818089, 0.6252831744282135, 0.20167866456021144, 0.7633169105468458, 0.7654124700631959, 0.7694470220466404, 0.6710375441932896, 0.5996994691757104, 0.7532696505159447, 0.19215447340320724, 0.22570642874933233, 0.21025148549599715, 0.3682532186938774, 0.1088703764757778, 0.17796791633081754, 0.23593035481592128, 0.1600786366319542, 0.33150788048494906, 0.19971880751305915, 0.16598751193420924, 0.16613827886066468, 0.1767259641711293, 0.17844872921285715, 0.19040037852550018, 0.19615573534789332, 0.2325711876579949, 0.22713664513480059, 0.2609232838265081, 0.23398717150007453, 0.28426468023748896, 0.22901858714588774, 0.24032238253935978, 0.236541807936962, 0.1837295797319466, 0.19492602734492537, 0.13146590846216566, 0.45456174686917505, 0.2560889553300876, 0.42095706175905645, 0.4003809444240498, 0.27719611237523345, 0.2822260094460828, 0.4863789900079113, 0.5532562170728192, 0.47855219136449856, 0.10114765963430106, 0.1658010893935612, 0.08858362192118607, 0.05674172416208134, 0.11723398615187963, 0.06859124810637718, 0.13721261704596277, 0.0638534576738744, 0.17541736671544172, 0.284077562937711, 0.22050237568570208, 0.21412925213218992, 0.22771639240261699, 0.24290594600147275, 0.22761566750950135, 0.1904523942330676, 0.15878316170737783, 0.24057613671575617, 0.4525536688356513, 0.5059630081716102, 0.6109044687530318, 0.5798979695347515, 0.6091519831782186, 0.6177384209191078, 0.6104847745495592, 0.525448126956455, 0.6200238820303308, 0.09516850470108751, 0.08834114592040843, 0.08450877728451756, 0.07816155256704882, 0.0930729401682816, 0.08043748355721403, 0.10585489615789323, 0.08175109982651652, 0.0804803325579494, 0.12131854562780664, 0.12116246191783808, 0.12098496858716168, 0.16730735518060158, 0.1572796312257636, 0.10311403909527339, 0.12174334881743487, 0.13937554726282453, 0.12435261293973288, 0.31647956707504354, 0.3215144125296848, 0.2986856725780923, 0.36864038202254146, 0.3042388195593574, 0.36110470981918597, 0.30659113439553654, 0.31980190903733496, 0.274747499679869, 0.26679156303518625, 0.25053786991445004, 0.2419259528180392, 0.27715052954578423, 0.20728440010468352, 0.24803002303806898, 0.33551059892938306, 0.3397565072832426, 0.26759930828207934, 0.19260256552492516, 0.1888264563436003, 0.20547534698643333, 0.19139283941408602, 0.20287922648571344, 0.20015464754733758, 0.1924346915033195, 0.18018459060177738, 0.17450560030185513, 0.16693400931944014, 0.1760003312843419, 0.1713739504155205, 0.29275852055816143, 0.17320934433324842, 0.16724655886599282, 0.17448909727894735, 0.1739378871932673, 0.17063646275693267, 0.4088608192654215, 0.6386684179763942, 0.15790950395395553, 0.7939166071595343, 0.17827745444776932, 0.1865935188976796, 0.1442886181992029, 0.15650182968085502, 0.14466964707535912, 0.753569308357208, 0.14622430488376326, 0.32612087416262125, 0.58256095941789, 0.22082894128372743, 0.15794946675278698, 0.19053778750426198, 0.19687994056828362, 0.15251018246929837, 0.17167924875085627, 0.18452832676308506, 0.1741363319243886, 0.16313023641901359, 0.17567821582273158, 0.17584680753013004, 0.19000370162833558, 0.17084714474609586, 0.16894900666400592, 0.07207462746005389, 0.06833100190834795, 0.0694185311668798, 0.06889933465683895, 0.07147411375225932, 0.07776970965196506, 0.07314486900505157, 0.07074901846301018, 0.07078090766701661]}, "mutation_prompt": null}
{"id": "0ce3edb4-faa0-4de3-aea2-db9a1310b830", "solution": "import numpy as np\n\nclass QuantumInspiredEASynergizedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n        self.quantum_prob = 0.1\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.quantum_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def quantum_mutation(self, idx):\n        quantum_step = np.random.normal(0, self.quantum_prob, self.dim)\n        return np.clip(self.population[idx] + quantum_step, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredEASynergizedMemeticDE", "description": "Quantum-Inspired Evolutionary Algorithm with Self-Adaptive Strategy Selection for Black Box Optimization.", "configspace": "", "generation": 81, "fitness": 0.3105294332890354, "feedback": "The algorithm QuantumInspiredEASynergizedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.7587941493589269, 0.7823033891744438, 0.7434383784056977, 0.7097713964317858, 0.7484830375008369, 0.7140891606909513, 0.7823160184358715, 0.7287921525600627, 0.6804473874917993, 0.6209408804504808, 0.6066249112574771, 0.5549199803535679, 0.6261588969368459, 0.5958457424321699, 0.44591855264620306, 0.5657180085442121, 0.5835348989985585, 0.4273038356651817, 0.09662123680248791, 0.11641510544871836, 0.097887591371569, 0.10321497621529885, 0.12349031742542138, 0.10130602531388466, 0.12690882195944764, 0.11876302420115004, 0.09241536703707354, 0.0919944049515028, 0.08071868665587212, 0.08449112912543733, 0.10556847396381541, 0.09540945483664964, 0.09599549060346468, 0.07693098583010838, 0.0869913977105774, 0.0875302519578085, 0.7557180737967636, 0.7735064260905766, 0.8248356263475326, 0.6895038307028725, 0.7769964357954283, 0.8698886585319392, 0.8132913868235003, 0.9256748258293493, 0.7734373231363101, 0.381941745992607, 0.26136236369783206, 0.2698965097029715, 0.3199780017182886, 0.34609110890599293, 0.3106012990053466, 0.335887802802018, 0.28357039162763187, 0.3336684043919633, 0.2180254501524691, 0.3376588070623029, 0.6908667573390306, 0.2597341035528875, 0.7289607158420459, 0.7395257730922632, 0.707498737600346, 0.7690326862933619, 0.634696508688696, 0.14935483462093357, 0.19328061025092602, 0.30128158495295443, 0.14290455297457005, 0.13934820032553474, 0.30577551916977297, 0.11870507351476733, 0.12949167209517654, 0.15732087281940732, 0.18181119429417414, 0.21543315329269597, 0.25961787501312583, 0.1323810232701984, 0.24566381362120782, 0.2087837811918254, 0.12715536259984528, 0.1653698127362997, 0.14461459058277903, 0.05678122938767971, 0.3768624841498015, 0.27304360121986837, 0.4478932539895716, 0.2244632237858305, 0.2539691338243737, 0.19641062515857288, 0.31462717406561613, 0.19289570129268396, 0.154254862229818, 0.524396742738839, 0.3787377702143384, 0.5499721946764712, 0.43654440053141275, 0.1973563722386823, 0.46132489989199366, 0.6525019385808027, 0.3458911240062329, 0.087852931227, 0.20522070382973467, 0.08134858427719427, 0.26500974649294007, 0.27777312736281634, 0.15202017464993478, 0.13818537766951977, 0.13224547402178577, 0.09005870485816536, 0.28199710818031776, 0.3082353950414909, 0.21122787869700588, 0.3335031240976124, 0.37276650570411096, 0.21167971508276218, 0.26423152032764874, 0.37296820282288434, 0.19596573837689835, 0.6398492568293683, 0.5681479312333055, 0.5826158925062822, 0.6060189464792992, 0.6899742964304405, 0.5430391178732629, 0.6522631294734822, 0.5671166402123355, 0.5683573973120539, 0.09760504257393199, 0.09887433316047278, 0.10563294928946487, 0.09202705752872387, 0.11039473345243278, 0.09543223947911794, 0.11410423994111696, 0.0906357692634221, 0.0934473897834327, 0.1494795672880067, 0.141656101584144, 0.1353806978716684, 0.17911243840731716, 0.1421971496444936, 0.18403762738540175, 0.1620680594292524, 0.14542423467819865, 0.14954052749539604, 0.3848606341621086, 0.3956029777754638, 0.38046775414356293, 0.40179020730496706, 0.4070824823580036, 0.3219500769003758, 0.39861872649562125, 0.4226321997536232, 0.38371317161838625, 0.26714098553043497, 0.32028132855197333, 0.22220387388797602, 0.3374679044721326, 0.2736102890186618, 0.29467639621226593, 0.2793574401345291, 0.33281791918616177, 0.28268549541039156, 0.19884037130701404, 0.21229326956821037, 0.18549234949113647, 0.19533952991433245, 0.1880089014285753, 0.17036812691243108, 0.21021247468565585, 0.17881291362512852, 0.20665660382041318, 0.1739262781198333, 0.28655677881327923, 0.17980985768055302, 0.21832612307465782, 0.19960404597292558, 0.18445607327787095, 0.17672431192568838, 0.19122151445225777, 0.17871574879702057, 0.17834898370713237, 0.18358707858864565, 0.5924006442797072, 0.7303206924536559, 0.18029500148238964, 0.17421788733453925, 0.14856417600499972, 0.15946354747819202, 0.17926209901900325, 0.45393912888802446, 0.3028091346855577, 0.6650052727993305, 0.16176013523759447, 0.1606530483407812, 0.26746418250244686, 0.15676236181611913, 0.6422527380074046, 0.19964566790276717, 0.16639302120578836, 0.19875562721474793, 0.16872749465834203, 0.16685303116126815, 0.1840217139444753, 0.16848871820997735, 0.17696811474328078, 0.165169450975863, 0.18192306182987528, 0.07337649702896343, 0.067833683932784, 0.07906696171326744, 0.07954694910867599, 0.07340090898954643, 0.07382271532690643, 0.08844092842520401, 0.06959781788492603, 0.08004766586372114]}, "mutation_prompt": null}
{"id": "f50a0125-a52d-4bae-9db7-cda19a2a6705", "solution": "import numpy as np\n\nclass AdaptiveHybridMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6\n        self.CR = 0.85\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.05\n        self.mutation_probability = 0.1\n        self.memory = {}\n        self.learning_rate = 0.08\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n        best_elite = self.population[np.random.choice(elite_indices)]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.5, 0.8)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 0.95)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.05, 0.15)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.9\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveHybridMemeticDE", "description": "Adaptive Hybrid Memetic Differential Evolution with Dynamic Strategy and Parameter Tuning for Robust Optimization.", "configspace": "", "generation": 82, "fitness": 0.11414919262041712, "feedback": "The algorithm AdaptiveHybridMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.11.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.27948497947526674, 0.26009540198157965, 0.2797286730860842, 0.27982692033236856, 0.2503035429173571, 0.2923186991389124, 0.265917795568263, 0.23463307929333344, 0.21951807067773665, 0.018704661333936334, 0.009763365359341747, 0.031521733271204, 0.0019515750749220517, 0.00017403386673686683, 0.007819375090586056, 0.021729898835779915, 0.006178826782548663, 0.008930228557133213, 0.07211885229550175, 0.04145166239399545, 0.04993924655624815, 0.05195317061220617, 0.05692655311510497, 0.04995300361711286, 0.0534677192290286, 0.056139270225969096, 0.05878785652792773, 0.05188319313494871, 0.036981016446032466, 0.045944321453124215, 0.06284431132188728, 0.03277638723893905, 0.03130280746904823, 0.03405487260408824, 0.04474953609535137, 0.04616189702230056, 0.2162708127899471, 0.22112479353254644, 0.2279962199088431, 0.23289499846410144, 0.8767253869355346, 0.3161594199449036, 0.17655107278951876, 0.7564900819398817, 0.705202872490786, 0.05765129030427274, 0.06600489089030726, 0.0948467077835643, 0.09551328899142753, 0.07477161132675447, 0.0916964306485124, 0.11158036483985834, 0.12253034560800447, 0.07212435954192076, 0.17495955779143546, 0.14019239294800012, 0.1502872602854637, 0.22038273276436093, 0.1452988176125395, 0.1280608813183518, 0.17350831438101666, 0.15014175529682816, 0.1942447600329047, 0.033406333140680755, 0.046207059736917855, 0.0646736047903651, 0.03949113566370521, 0.060703572723833865, 0.017321215841979987, 0.08516255371421044, 0.04730436334644328, 0.02875502604325919, 0.06054198149535572, 0.03508756905529975, 0.036502710930980564, 0.03758076057444981, 0.05300901524221058, 0.06238385159970272, 0.06989229682646092, 0.02637357125788964, 0.03671365761631018, 0.0002888431221493848, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006475291844481035, 0.06936114680281169, 0.047263440107080945, 0.10019686576982278, 0.07725630733171218, 0.03618581590136294, 0.045175593229275, 0.04012641274488726, 0.04588448103179166, 0.034814701347436805, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045791041643907016, 0.019383590760881475, 0.022171430523835967, 0.01682652796627604, 0.02443162230957463, 0.034610859303036756, 0.03933359070848996, 0.031517407184102786, 0.049049171878301934, 0.2389051791570841, 0.22208078374354734, 0.2397438613689552, 0.2650487839773725, 0.23916784102787114, 0.2392257030098376, 0.2929388487622012, 0.2314920729982256, 0.2729699225235753, 0.049762808239303014, 0.0607649310260967, 0.06017697100440911, 0.061218428893713095, 0.052187327473857126, 0.0728383159222904, 0.0600955932895888, 0.07098554139046953, 0.06250138783007753, 0.11906532193587405, 0.10993597905875363, 0.10649484856928926, 0.10120110892518608, 0.10927053346172111, 0.09753915288033932, 0.116243470223513, 0.1131061494352964, 0.10354956800991333, 0.17686808956054723, 0.18614311304856046, 0.17631735741807242, 0.19722128398690109, 0.17418827080479093, 0.18879524412554916, 0.19110677148364807, 0.181825883140453, 0.19315176910291387, 0.13202096640667638, 0.13693713108810657, 0.10376724740678911, 0.1305295057438498, 0.11609344762950624, 0.13070749019924988, 0.13694754591117086, 0.11064971001050694, 0.12967257897608908, 0.15635789360302765, 0.14726696677170603, 0.15909041586531292, 0.17426901721634225, 0.13856860228969892, 0.1808221571146056, 0.1665319303206425, 0.15766306490953685, 0.20285671549008044, 0.13366244922118253, 0.13104741044986445, 0.13916369782265392, 0.14054599114453303, 0.1276318902120509, 0.16224513645329208, 0.1381031564165356, 0.12755318889840295, 0.14481170794449494, 0.1347137647978126, 0.12324368537175945, 0.11193013574556865, 0.13553693812040624, 0.13082673454952887, 0.17283718821123606, 0.1224461540945162, 0.15402909092177508, 0.21215827042634716, 0.1166329322733698, 0.1518706828959826, 0.11270419787398456, 0.11497780679506797, 0.12710553344917064, 0.13656204450395093, 0.16654462114841317, 0.0939672630883106, 0.14927980079352332, 0.161376340314052, 0.1580862477414432, 0.17589484543333367, 0.15595076057323842, 0.16145939292174594, 0.16012817220124176, 0.18467963353037953, 0.1717716969837042, 0.15496047544603042, 0.056960418768703835, 0.04098660124514408, 0.05786897605609842, 0.05098377924309039, 0.049160876922460184, 0.0543112516569898, 0.04703553329065813, 0.04563041739041196, 0.04386572863017901]}, "mutation_prompt": null}
{"id": "a506764b-ff87-4c94-8df4-e3cea6fbc315", "solution": "import numpy as np\n\nclass ImprovedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 7 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.7\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(4)\n        self.strategy_prob = np.ones(4) / 4\n        self.adaptive_factor = 0.08\n        self.mutation_probability = 0.07\n        self.memory = {}\n        self.learning_rate = 0.07\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(4)\n        return np.random.choice(4, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite, self.best_2]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n    \n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.3 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n    \n    def best_2(self, idx):\n        sorted_indices = np.argsort([self.func(ind) for ind in self.population])\n        r1, r2 = sorted_indices[:2]\n        if idx in sorted_indices[:2]:\n            r1, r2 = sorted_indices[2:4]\n        candidates = [i for i in range(self.pop_size) if i != idx and i not in [r1, r2]]\n        r3, r4 = np.random.choice(candidates, 2, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[idx])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.6, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 0.95)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.02, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(4) / 4\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "ImprovedAdaptiveMemeticDE", "description": "Improved Adaptive Memetic DE using Dynamic Exploration-Exploitation Balance for Enhanced Optimization.", "configspace": "", "generation": 83, "fitness": 0.11114295015049687, "feedback": "The algorithm ImprovedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.16.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.1810400511733059, 0.18574263116410605, 0.19567263257402934, 0.20923084516081758, 0.19202956329224374, 0.19250477706772062, 0.1963291016728027, 0.17600924780346483, 0.1988225400978333, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04814788726507724, 0.05035298969389701, 0.03933093651479869, 0.049258332522419956, 0.03057595530329804, 0.04565071335909654, 0.04622711192044682, 0.05764131321108634, 0.04437989278679744, 0.02963686656171305, 0.041032188035726946, 0.029056523408045765, 0.04341722276929105, 0.04041843863971095, 0.026080815024654425, 0.046079763611549085, 0.03251486593011377, 0.023812468487702798, 0.7927685422942288, 0.8576695136150854, 0.8837450821171815, 0.8529422656261445, 0.8214537932729329, 0.9034623048222473, 0.6637815949875421, 0.894121741470058, 0.8783240485901314, 0.07595567757350874, 0.06197415644218074, 0.062451517293933057, 0.08965228941421233, 0.0778575919397474, 0.10372129012931453, 0.07450130519824394, 0.047096259117198724, 0.049407313755610804, 0.11901341661060283, 0.09039956487215872, 0.11502828627186767, 0.12105471704478155, 0.10524640261889795, 0.12001255689306889, 0.11454403810974922, 0.09579919403183945, 0.09532121540164118, 0.010343989101721518, 0.008960539327951822, 0.0002938211487513165, 0.03263660571196192, 0.02112522672770445, 0.009602527265504923, 0.024481585366008085, 0.03027217417520589, 0.004431956721913433, 0.006258649808348338, 0.011610015767555715, 0.027419332320925194, 0.008454681096536798, 0.006033344183988598, 0.001728848956675244, 0.014758451918049476, 0.0005299783176978545, 0.009577221928356972, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0082249300043028, 0.015864494078523417, 0.028561654186046836, 0.003917776115864968, 0.011488585694010678, 0.056549246332361136, 0.030137146065358555, 0.05581489372287485, 0.046674531085490134, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008695876862364282, 0.00247288928451872, 0.0183443171874349, 0.002826294115420902, 0.0008990635471329833, 0.011718933515873164, 0.0056159086467924, 0.008952832486038065, 0.009489448146217216, 0.21287750504390424, 0.1875246910829328, 0.20653047925233692, 0.20336179106938468, 0.18092109327908334, 0.19405580932235278, 0.19765587587941158, 0.20299075577989822, 0.1922470775765328, 0.05659932484337338, 0.053949495754828214, 0.04350105778316016, 0.03388389881475817, 0.0443164221844492, 0.04833180701212625, 0.036757700144375294, 0.04072662484156209, 0.045864557363890945, 0.09324284806293304, 0.10209617720396369, 0.11702267869789762, 0.1275355627352297, 0.10850874223927354, 0.10465266401364093, 0.13416153925152374, 0.12290148932765843, 0.11272962448174184, 0.1654319555075353, 0.16577361488090214, 0.15530992586105308, 0.17465324591864884, 0.13549714149351877, 0.14654635846734965, 0.1658173112574992, 0.18784887062156674, 0.14590949850851098, 0.09827638231065461, 0.09207556325696586, 0.09643106165849513, 0.10116956936149546, 0.07970511218429621, 0.08535737825561573, 0.09357048635254195, 0.10745402450237562, 0.1195357447496379, 0.1484543169940089, 0.1372646813107511, 0.14267676839049526, 0.1289698224752216, 0.13248492377869703, 0.14236897894038159, 0.1432645169016754, 0.13096897360765414, 0.14907359665909448, 0.12462256781045467, 0.11853064573315863, 0.10816759656611263, 0.10429976960117093, 0.14547846324249603, 0.10611115426514894, 0.10462178394042565, 0.061805745532795275, 0.06238059295264886, 0.1045364018061693, 0.11551636248921826, 0.13056634315149473, 0.16763641548311192, 0.12090016196913078, 0.11120300317809484, 0.149060714927419, 0.13472261573796007, 0.10800175177660043, 0.13923665958726883, 0.12043521695976211, 0.1378639141266429, 0.0943547634684343, 0.08749354968847145, 0.08715905534148294, 0.1447574727933375, 0.15384842799098986, 0.1748982628531448, 0.1576988922642042, 0.15130243588128656, 0.16416100660774213, 0.16102259256624551, 0.1512504720543416, 0.19650713828677346, 0.15831018505421723, 0.14553528063303678, 0.15780474812592382, 0.037782086891732014, 0.04470766470838605, 0.05002126922626504, 0.04907011109352044, 0.049830489017526625, 0.031973044945182716, 0.04837762632409359, 0.03791063837894748, 0.04279589473854506]}, "mutation_prompt": null}
{"id": "a42db6e3-9eb8-430b-9e1f-e9883ca5586b", "solution": "import numpy as np\n\nclass SynergizedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "SynergizedMemeticDE", "description": "Synergized Memetic Differential Evolution with Self-Adaptive Strategy Selection for Adaptive Optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.7788463382149456, 0.7222233227025788, 0.7119897024608502, 0.7872539598804809, 0.6697637107389571, 0.7299586160827567, 0.7280997172209203, 0.7700207881007501, 0.7406958809927395, 0.6218370781976879, 0.5752122875114816, 0.5232453513110437, 0.5620006232021444, 0.54072874598375, 0.5019536302129185, 0.28900440421261986, 0.5603810730042138, 0.5593098247444007, 0.10521036313066034, 0.09320834941053258, 0.11258743499396673, 0.1067897775585438, 0.1036195526006759, 0.08627383971329528, 0.12707716814742942, 0.09516375977408098, 0.08995676347362802, 0.11592019421793809, 0.08250011804273383, 0.08131115101316477, 0.09546741906285228, 0.08963144134998524, 0.07325625281972115, 0.07849354466805414, 0.07545139332300421, 0.0708048359285276, 0.861941010981822, 0.8971908414162126, 0.6612370681904074, 0.7708696894379478, 0.7163555498995502, 0.8250445219414547, 0.8246601216128293, 0.7655937654091072, 0.6653637873887162, 0.1743542157423551, 0.30881355747055417, 0.325665605578738, 0.35217832987227005, 0.35159305745804403, 0.3310880144653249, 0.23768881282148746, 0.35281248714057056, 0.31534423377370335, 0.717156186666721, 0.7152509580951149, 0.7694167693221193, 0.7739087214503402, 0.6983267963951303, 0.5705219263219026, 0.6878657419509291, 0.4243779679415507, 0.48888617565081904, 0.21785467395573987, 0.19538891686141924, 0.21092203540250076, 0.2373482030760815, 0.19690625202219725, 0.2715508675748407, 0.15957217919696265, 0.18304263867915138, 0.2693927208891538, 0.17987020302450585, 0.20224344102444836, 0.1762085294957484, 0.23357766656633416, 0.17760479659726114, 0.37143091241162474, 0.14301556734618914, 0.27968896086435446, 0.12879597665830655, 0.45778505924673885, 0.40520938244170157, 0.45186602566895795, 0.33963890446362943, 0.4082225208890312, 0.4761194845333433, 0.05525861679495081, 0.46179221628434663, 0.330705071249745, 0.1945883063025261, 0.446968619623886, 0.517288249078051, 0.47662933004324926, 0.457947481912213, 0.4385631511156085, 0.5292308367562681, 0.4078991704943833, 0.506346546440023, 0.10827588638823105, 0.112576613062644, 0.15654298198335947, 0.11361337238840097, 0.11416934958047986, 0.3471054887012992, 0.24033305671634542, 0.14773385473504408, 0.07247347257402803, 0.2729341011130033, 0.28323725957262125, 0.298962448085047, 0.3646354595034459, 0.2951319221840737, 0.3781141676917439, 0.23312535157120073, 0.2692240745106065, 0.29342406159216183, 0.47404334368694634, 0.6403134236705154, 0.6664638215743005, 0.6466068507347629, 0.6045447355719609, 0.6692076646039808, 0.7035799909476368, 0.5596990305852284, 0.6326087041208002, 0.09168457508203776, 0.08958559939747468, 0.09047958965771663, 0.10879261485836922, 0.08408005700568955, 0.09283306399873714, 0.10717305354511208, 0.10046583767119954, 0.07451049059448578, 0.15724524156933617, 0.12359200505599743, 0.13306770859049433, 0.1215059008634718, 0.12095843205552592, 0.12882743901703997, 0.1337531586984516, 0.12223213091267049, 0.12580263637107802, 0.39075609884837914, 0.36472260426548, 0.3298749832187664, 0.3498591525115464, 0.3328451446675328, 0.33665338885327634, 0.3824050776819484, 0.3510918950752272, 0.4129295852631687, 0.2814084661077525, 0.26198635350297506, 0.2641382576683833, 0.26958793524366775, 0.2271825027349974, 0.29768874626470776, 0.3538501826387844, 0.28639744580240833, 0.3456874441535813, 0.20402223650003326, 0.19556653877727004, 0.2078026880387156, 0.20098544723749945, 0.22471606106384634, 0.19859485277646727, 0.18047602763759218, 0.1960839157811518, 0.19688314169823629, 0.19357345127892478, 0.17986929722928668, 0.16503015506348961, 0.18149836102994, 0.1736284554292724, 0.16901589746116352, 0.16471802110435352, 0.1753848469130851, 0.17277380456912073, 0.19970360669769283, 0.6608961040029048, 0.18114635879929708, 0.542514759392418, 0.20317264619709585, 0.5231039481787816, 0.7630279585606847, 0.5135031952271126, 0.7610686457944482, 0.25969617067764517, 0.20145860458356446, 0.18244915553874907, 0.15993582957341024, 0.42299883869588295, 0.15632301098026857, 0.15756285468632925, 0.21235786192188455, 0.1952869095292552, 0.16595995080467296, 0.19809167888272738, 0.17738810979752984, 0.1570003792884196, 0.16817963519325407, 0.19041755934225724, 0.18360442985325887, 0.1800634886271547, 0.1707659198681527, 0.07009133261412392, 0.07579438439643105, 0.0735957175464218, 0.08418775240322707, 0.07410162313045254, 0.07554317297248758, 0.07549519201571586, 0.06956569711964167, 0.06590430755300547]}, "mutation_prompt": null}
{"id": "e6f91a09-1031-4ee0-9540-3cfe4dc495d8", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.evaluate(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMultiStrategyDE", "description": "Adaptive Multi-Strategy Differential Evolution with Memory-Based Elite Selection for Improved Convergence.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: RuntimeError('Budget exceeded').", "error": "RuntimeError('Budget exceeded')", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {}, "mutation_prompt": null}
{"id": "f6b924cb-4091-4f7c-95f7-e0f59a28757d", "solution": "import numpy as np\n\nclass AdaptiveHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 6 * dim)  # Adjusted population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6  # Adjusted scale factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.15  # Increased adaptive factor\n        self.mutation_probability = 0.08  # Adjusted mutation probability\n        self.memory = {}\n        self.learning_rate = 0.07  # Adjusted learning rate\n        self.elite_fraction = 0.2\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveHybridDE", "description": "Adaptive Hybrid Differential Evolution with Dynamic Strategy Reinforcement and Elite Preservation.", "configspace": "", "generation": 86, "fitness": 0.25530398261418263, "feedback": "The algorithm AdaptiveHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.6816336671597227, 0.6264193510017797, 0.5972886372113868, 0.5913371354390037, 0.6890615082950858, 0.6116902497837118, 0.6677165123279525, 0.6546547782711897, 0.5973900886683752, 0.5190790476822438, 0.4980310801829584, 0.324468264139812, 0.39827053250560684, 0.5074728449261925, 0.2747341662579861, 0.5018579048965337, 0.43634180092854946, 0.33864421431160385, 0.08415773027430984, 0.09329106123697295, 0.08944125557096827, 0.09240805806610475, 0.08913828214317165, 0.07790345353283357, 0.10898358224780891, 0.09126259085683397, 0.07507179067619218, 0.09099298210605988, 0.09284145680367839, 0.07115966379745275, 0.08093735699783378, 0.07638509140314131, 0.0711819173792031, 0.07764077222960719, 0.07692311097803106, 0.08085043398052527, 0.8342473628223337, 0.7939032640698371, 0.8217896609866813, 0.5199840867046248, 0.5893707053681825, 0.8752523686380886, 0.8299066671156999, 0.6133210486238301, 0.8048926550948703, 0.2185127810258901, 0.23869777148641358, 0.22828597856220545, 0.21773322570885978, 0.3095830324871073, 0.18965472399155248, 0.24236955804367766, 0.2125049478567833, 0.2075869489329506, 0.6972122352618413, 0.5440605207651685, 0.5692496619934662, 0.6343448292566527, 0.4690695268393451, 0.2970902259858964, 0.6457870593990954, 0.35651320911653106, 0.539932375067449, 0.14167227424226747, 0.1656290749848942, 0.1672997186441758, 0.19979800638225464, 0.15653084860428446, 0.1381739899685055, 0.14593522427264527, 0.16228997878472728, 0.15795078131743234, 0.12090997387971913, 0.14656703200719512, 0.10980546915056388, 0.16111021424603134, 0.12042363169147252, 0.14972659431824886, 0.18638217532487777, 0.10352959000884276, 0.09585979564934222, 0.07296318467841045, 0.20210299337179372, 0.09531667647851993, 0.38767670915330554, 0.10642734930230557, 0.13405871647701895, 0.3480497983304087, 0.15304829199945091, 0.1173216767999753, 0.42693696257214075, 0.32049469017411625, 0.25033441226227837, 0.29174642033694387, 0.270535882559941, 0.22391744991469753, 0.10882110113092058, 0.30337559139241543, 0.23818373430682283, 0.13136428392201815, 0.0072899455562330795, 0.013997443946094812, 0.07488844197990308, 0.053400238197096384, 0.05457178278001007, 0.11417247869740554, 0.03145550581443457, 0.0548889353194314, 0.2684516798380241, 0.11962125821066039, 0.14859677269399085, 0.27602668283738985, 0.14643106304368225, 0.15540814371675293, 0.26433759140730995, 0.13550237675763455, 0.21661662378295776, 0.6389102421417965, 0.48606285725020015, 0.5100804563375345, 0.4621556066862771, 0.4517993152464401, 0.4850976362072712, 0.6143918412238187, 0.5803962019270117, 0.4631133056151593, 0.08376815592232811, 0.07207503313471242, 0.06846964916555409, 0.08312513241245267, 0.07305076741622818, 0.09791652293353748, 0.09760269181143377, 0.09233577619555289, 0.07552211713925627, 0.15205652459286179, 0.13051754789411318, 0.13219668889416758, 0.11997021625266335, 0.1307158783836827, 0.12467030380757549, 0.15198829830746874, 0.13742915354817942, 0.11821362635835908, 0.3236046812474057, 0.33241431930928234, 0.2582080406129138, 0.3390777741749432, 0.3364317645831426, 0.24910859515353512, 0.33703370401892485, 0.29002091637559935, 0.25320708364861555, 0.21534215849877614, 0.23097824801810862, 0.1928271271303934, 0.2408947870103545, 0.18735843274695518, 0.19848686320348374, 0.2987879911579542, 0.23093610549326127, 0.17534958318750327, 0.19184327100439247, 0.16302914351318487, 0.16952891621969124, 0.16890289050684937, 0.16457677277142413, 0.18343792266938785, 0.19063967895303024, 0.1668759800828944, 0.17563596585786034, 0.15187011614783064, 0.1581044206473451, 0.19449178016333135, 0.17581799727293268, 0.15113248654118028, 0.15879511871418506, 0.16688428259711163, 0.1631832963014922, 0.14097230147166118, 0.47313810293661984, 0.16612024744235565, 0.13997928167619444, 0.5309278374329626, 0.17513693997487823, 0.41714518303295955, 0.3207329859569058, 0.161952843004613, 0.2302762277143391, 0.6521953774583862, 0.17252859884668414, 0.2870294932958989, 0.5136617421306817, 0.1677063340869911, 0.17036253300033277, 0.19026374401742463, 0.14239595504600533, 0.18808577191384657, 0.17785309017540862, 0.16955485132996617, 0.1643105010041067, 0.18232339713976042, 0.1781028224930027, 0.16843245859063405, 0.18720786402693312, 0.17549544121521088, 0.1679838503700406, 0.08368704332841337, 0.06945584717988673, 0.06318555843418072, 0.07296870028197333, 0.06415808881277785, 0.06071129927589447, 0.07352398582578157, 0.07845746710012735, 0.06374064660325907]}, "mutation_prompt": null}
{"id": "1169f903-82ec-4449-b6e2-8100a256975f", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6\n        self.CR = 0.85\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.15\n        self.mutation_probability = 0.07\n        self.memory = {}\n        self.learning_rate = 0.07\n        self.elite_size_factor = 0.25\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_size_factor * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.75, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.05, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Enhanced Strategy Adaptation and Memory-Controlled Mutation.", "configspace": "", "generation": 87, "fitness": 0.30360361197994123, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.7372108727141449, 0.6951911755750901, 0.7253009749482741, 0.7261599478305578, 0.7330397995380452, 0.6954463179381446, 0.7488378428821922, 0.7254553436351914, 0.6868340553438528, 0.5778000604766788, 0.5270961738075561, 0.36624321930006476, 0.5670233282490791, 0.5074216783577212, 0.49321295756357153, 0.628860769717274, 0.5261694141508308, 0.5425371366459146, 0.1059270519190686, 0.09468973729016938, 0.08239940302782345, 0.11321890845405724, 0.10046470540627228, 0.10064206905761153, 0.11724507516973481, 0.10242487041002701, 0.11723041275682622, 0.09647211976364034, 0.07266422425663188, 0.06972551153168793, 0.0954631602554662, 0.08402771934547981, 0.08189393764523589, 0.10237114565338357, 0.07875559681526267, 0.08112487455469142, 0.732746912977233, 0.8382857185492646, 0.808195544864367, 0.7666302583630651, 0.8590482566130787, 0.8182059748472783, 0.668182181385445, 0.8656992479262768, 0.8358819419411833, 0.35593199236097806, 0.32277478040731444, 0.3178602032292823, 0.330965871936475, 0.2934766415789277, 0.25190071753834553, 0.20213996252948585, 0.33404756118990575, 0.26787538537796174, 0.6887272211625488, 0.6873680169007135, 0.6533078676300508, 0.7247698990100562, 0.7148478216894247, 0.6423528179016975, 0.6642990682321118, 0.6735748195493667, 0.6456730915693364, 0.13967570711210775, 0.15983802206679798, 0.13534470912960328, 0.26253890704227256, 0.20254972579836705, 0.10104592694215897, 0.167034191508719, 0.25298887932919667, 0.19718687641647892, 0.1526859524256986, 0.14857377118878645, 0.1608796754987738, 0.129052510624302, 0.20123912943131905, 0.1301270288809181, 0.14095158168617195, 0.1878079984352755, 0.1344905008126025, 0.1642632499424893, 0.42229214693985473, 0.34083450999626896, 0.27920600079168356, 0.3331181378536705, 0.16744481642570586, 0.2941190097140226, 0.36591088221497126, 0.36620054128034707, 0.391449861506486, 0.45686908526820247, 0.16326557986156043, 0.272185545789949, 0.43483616609219267, 0.30211565081569947, 0.35178141144429387, 0.474274629098688, 0.4823054496906001, 0.07883893463013103, 0.11429381414545259, 0.0881779421217479, 0.10713976013029025, 0.20480658275560004, 0.11305425153861592, 0.09424628249799483, 0.09658718460769611, 0.09313697070619587, 0.24203811492321825, 0.24764279617174356, 0.269790627176829, 0.25697454753654825, 0.303794515917419, 0.2217898965019347, 0.2977321777648584, 0.2596426842737153, 0.25736740299732896, 0.6922888374272795, 0.6673635459063353, 0.5406429935662103, 0.4414281946719131, 0.606201924004375, 0.6125187396447334, 0.5987853244057315, 0.6420875810988791, 0.6342239658942975, 0.10590255032733309, 0.08182435091163132, 0.07756477290269248, 0.08349923640106205, 0.08972942696807151, 0.09761830888784828, 0.08857974502020605, 0.09844163040639253, 0.07310697931727972, 0.14306906617653625, 0.12784696714791988, 0.11870866709679051, 0.14034022665186707, 0.1393663801592755, 0.13763376876649158, 0.14415209191319167, 0.11837910133063378, 0.12653598911588992, 0.3632268875556164, 0.2971261339333827, 0.35720933910656516, 0.37483369321205795, 0.3510830125101151, 0.31085427486750306, 0.34526923976573176, 0.3601650636824508, 0.4319301279564943, 0.2599661798621441, 0.2681210689415944, 0.29878030956049206, 0.27387770117524723, 0.2540579537931934, 0.27341191082915195, 0.2697935409981971, 0.2644446253881001, 0.31256654253187877, 0.17861247619820864, 0.20154197217100833, 0.186838212913089, 0.1942315585496336, 0.173718129816118, 0.18427794369658201, 0.2205436293245555, 0.18032956957929613, 0.21192187319829703, 0.17276885305246814, 0.17164684983014633, 0.17075718264904116, 0.1756636051623347, 0.1638983774522128, 0.17677316227937623, 0.1736098273047022, 0.16305748439765178, 0.1872023858149905, 0.17218432305423048, 0.173179424380419, 0.5061850392601461, 0.16496147368371328, 0.16506207099634862, 0.6553794222161872, 0.15981637731527065, 0.15033641491207872, 0.5609534053935079, 0.6387079574872302, 0.1609356305224976, 0.3672700600843307, 0.37986791987067337, 0.23103168063099666, 0.5107789284746904, 0.3221120437428986, 0.19555014709275842, 0.11537148601045322, 0.17532183218806863, 0.16353452352500586, 0.1718473952781232, 0.18989633735340017, 0.18376475227565092, 0.17574724042909295, 0.18173924362015448, 0.1667690124511353, 0.18226041945809268, 0.07890002258340867, 0.06957701642730774, 0.06287232745633042, 0.08367893217506184, 0.08059058452884105, 0.07064739178872259, 0.09480752751770616, 0.07044251160199833, 0.07945862199830767]}, "mutation_prompt": null}
{"id": "6876eeb4-1caf-4620-a8e0-c3438b0d03c8", "solution": "import numpy as np\n\nclass EnhancedSynergizedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(20, 6 * dim)  # Increased population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.8  # Reduced crossover rate for diversity\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(4)  # Added new strategy\n        self.strategy_prob = np.ones(4) / 4  # Adjusted probability for four strategies\n        self.adaptive_factor = 0.08  # Slightly reduced adaptation factor\n        self.mutation_probability = 0.03  # Reduced mutation probability\n        self.memory = {}\n        self.learning_rate = 0.08  # Adjusted learning rate\n        self.elite_memory = []  # New memory for elite solutions\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(4)  # Include new strategy\n        return np.random.choice(4, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite, self.elite_guided]  # Added new strategy\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.25 * self.pop_size)  # Increased elite size\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def elite_guided(self, idx):\n        if not self.elite_memory:\n            return self.rand_1(idx)\n        elite_idx = np.random.choice(len(self.elite_memory))\n        elite_solution = self.elite_memory[elite_idx]\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1 = np.random.choice(candidates)\n        return elite_solution + self.F * (self.population[r1] - elite_solution)\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n            self.elite_memory.append(solution)  # Add to elite memory\n            if len(self.elite_memory) > 5:  # Limit size of elite memory\n                self.elite_memory.pop(0)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 0.9)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(4) / 4  # Adjust probability\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedSynergizedMemeticDE", "description": "Enhanced Synergized Memetic Differential Evolution with Adaptive Elite Learning and Dynamic Strategy Balancing for Robust Optimization.", "configspace": "", "generation": 88, "fitness": 0.19520804136148215, "feedback": "The algorithm EnhancedSynergizedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.13.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.3494009174254086, 0.2885420033030067, 0.3424166627163361, 0.15104921042950215, 0.1881565207488416, 0.21351301919516918, 0.32244314710913236, 0.24581149675265745, 0.5656537152077146, 0.18559091227742797, 0.10820085437968008, 9.999999999998899e-05, 0.21004994770398133, 0.08329545341897615, 0.02466252462100016, 0.3640300219150183, 0.16172514618885925, 0.17346831134070184, 0.24975756466550492, 0.10732336502698614, 0.12779714675786813, 0.14843762491474444, 0.1058662099795914, 0.1618590925306851, 0.0854872112346875, 0.11144227875848045, 0.14528241694796584, 0.07585992012477782, 0.06788264133745614, 0.07128209795734564, 0.09652853845671938, 0.07320153060587398, 0.06809795065984015, 0.13049506551499923, 0.07669995983806255, 0.08388445390910526, 0.24377444806752124, 0.1305273037293293, 0.6067016525904765, 0.5434370858366382, 0.8495429644984878, 0.556930122174445, 0.4836635491730178, 0.21511096219660886, 0.5713519431328833, 0.20027453440028253, 0.12456533138787507, 0.13681761869574294, 0.12502088237740827, 0.16522651527652632, 0.0828135243225615, 0.19393893335302148, 0.0785096247480298, 0.09194404435444337, 0.2038403736959682, 0.2016505330306515, 0.20790635651132172, 0.2644361073203684, 0.2541098275368274, 0.5032596942955148, 0.13973350235821946, 0.21966780064188574, 0.7512914726948238, 0.15196741264531266, 0.08757735731130911, 0.12694528923521897, 0.2963218425778781, 0.1652831461198886, 0.11987632571037299, 0.27500493478611765, 0.18056917887524893, 0.10685721522664404, 0.16038565284462858, 0.12380466543898039, 0.17406403531952963, 0.07769232646399338, 0.15844425213797553, 0.12472729503022095, 0.1483005811129935, 0.24362600257544886, 0.12886695789745373, 9.999999999998899e-05, 0.0027830803071677845, 0.08064671119192501, 0.0552156706381004, 0.09773287557737753, 0.03797495016703456, 0.024605495304410918, 9.999999999998899e-05, 0.07097231264356563, 0.13091572359246273, 0.10749755373527681, 0.17840544718354523, 0.05858699765880959, 0.02936176604926166, 0.03749916989807156, 0.18584510786421138, 0.1940947023098829, 0.19000852399689838, 0.22749809395201648, 0.19002597259619103, 0.05249834726364966, 0.11144405877417718, 0.12160346092985597, 0.23873214775844354, 0.20910947476777197, 0.1896942494190147, 0.06583600803150458, 0.09713941939961368, 0.206304837786074, 0.21646666107301638, 0.08155537911077759, 0.3055044677238128, 0.23861010129041382, 0.12286052101176304, 0.08344919796795724, 0.08377042809826984, 0.3663256655204715, 0.40896019487578283, 0.35176195193657156, 0.28301001526819036, 0.3878158303455701, 0.4103175148767868, 0.45729410953472693, 0.42385477226193835, 0.3403082283428992, 0.08695817750078894, 0.10781251440579676, 0.07749981118674787, 0.12034306485607882, 0.08108995794486873, 0.09362036624373793, 0.12704533629368175, 0.11359170707066846, 0.12491474279521009, 0.16166487576117883, 0.13747311212208513, 0.15581152166954093, 0.1886458440257055, 0.12773586167398376, 0.15645017925012994, 0.20560036395581693, 0.15493210558749193, 0.15137005399904824, 0.23948325987072805, 0.3251923637545284, 0.3678666558187821, 0.347627023437451, 0.41696357364548353, 0.2774821735491412, 0.273917797102904, 0.4618683678803205, 0.4923909836191609, 0.13991000628418315, 0.25010518178134244, 0.24210649783107752, 0.31637590101518465, 0.16119471161774201, 0.2778056928771345, 0.18540583949116718, 0.23308074044357663, 0.18053457016832508, 0.20350135042978001, 0.1947880953994091, 0.1984522839383399, 0.2095588958532415, 0.18509669474899848, 0.2253835596644127, 0.16928532602986635, 0.19194647000566, 0.21698409945307418, 0.17233451689142099, 0.16771983227006315, 0.18441520804396427, 0.18653868699864817, 0.1876333515998374, 0.17565495595986447, 0.177061426399447, 0.18007168927541628, 0.1966512443439623, 0.252880516867543, 0.15554145215125004, 0.19084514829248278, 0.16409706383576506, 0.16301813310385516, 0.3058817443662648, 0.11438224257721408, 0.16080669427092198, 0.152750526187039, 0.5637989009644115, 0.18914186167089908, 0.32452502876198264, 0.20107040340701288, 0.2878415264939542, 0.36966770882970634, 0.2573496774438302, 0.23761997566132553, 0.10055095480345333, 0.16673899611936827, 0.18231224533318968, 0.1820657848603846, 0.17459970040309092, 0.18016551861011, 0.17094351228103022, 0.18515112808308076, 0.17046423240492636, 0.17205592600591135, 0.08176929641978403, 0.07617473651243978, 0.07652646977774313, 0.06830665146923531, 0.07352727554842475, 0.08134893510620167, 0.07387398760560426, 0.08007190092150118, 0.0763691413935389]}, "mutation_prompt": null}
{"id": "f3735dbd-a6a8-4c1a-b903-025b822fa3ac", "solution": "import numpy as np\n\nclass EnhancedSynergizedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.1\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedSynergizedMemeticDE", "description": "Enhanced Synergized Memetic Differential Evolution with Adaptive Learning and Mutation Mechanisms for Improved Global Optimization.", "configspace": "", "generation": 89, "fitness": 0.2810081501447097, "feedback": "The algorithm EnhancedSynergizedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.4580051784689976, 0.7189458566961122, 0.6853299583049638, 0.7481522074700988, 0.741421762527007, 0.6932298244942943, 0.7160159081163215, 0.7708344607396947, 0.6698829637138055, 0.5769750100023627, 0.6283877484802862, 0.3783460566248652, 0.6330090747972914, 0.6130549843105562, 0.3578534519193295, 0.5793094695383683, 0.5956033491521333, 0.33210120656667164, 0.11374121664288073, 0.09836583132183807, 0.0984968191890715, 0.08831530392710707, 0.09890279621316289, 0.08584733779752518, 0.09126485218205327, 0.09651552999543234, 0.09528319371066951, 0.09728551334739677, 0.07889123615965421, 0.07912303928011677, 0.09430813473828581, 0.0887614566086461, 0.0802008604391038, 0.07954539655521697, 0.09701673177799808, 0.08541075756212646, 0.8720492702512433, 0.7622798815493186, 0.6952667219582229, 0.4476729534897004, 0.6206566333724164, 0.5905270444172805, 0.5305132606089554, 0.5713679723120101, 0.7391788628204952, 0.1950835175340403, 0.32291483834602897, 0.28359729560087676, 0.18097004645516634, 0.2899322306083816, 0.3043444053257781, 0.21467835608851005, 0.19697368504706225, 0.3183021606724459, 0.6522651210382213, 0.6767643493161921, 0.2095806111131201, 0.711886327930199, 0.7577886785498584, 0.6385925143575959, 0.7419463851676338, 0.22176545295247563, 0.6031133936421238, 0.1304749397767655, 0.1622067535861188, 0.20214429503523557, 0.2783187760041723, 0.12470162050728628, 0.15084609768104018, 0.13240850410832428, 0.12761661604386176, 0.17995007038099153, 0.1502118252564758, 0.15736024671255255, 0.1705560693288093, 0.1420021341874722, 0.16712759788924247, 0.25793660769719884, 0.24387447245374738, 0.13818796361627905, 0.16987978483501465, 0.11058973753189838, 0.3113754297144449, 0.21010803972178405, 0.17050547935375837, 0.21239957036285073, 0.2001691869162987, 0.08775006211627401, 0.10901550252461256, 0.27099766417853366, 0.4757625289154027, 0.14407068036838322, 0.34422759590123886, 0.1922035904641538, 0.24169728602452445, 0.3054232259088919, 0.2327481626733776, 0.566881784609235, 0.37447586277599754, 0.18903910151147496, 0.10636591067308165, 0.06892797098098813, 0.18025083816634235, 0.11890499283557587, 0.13397372626364945, 0.16294565435055497, 0.14418353418932783, 0.08806683892410716, 0.3004121683612663, 0.28366498544319363, 0.16615992389109124, 0.13458968770533974, 0.23907807989416907, 0.19127430526083666, 0.37373928773289433, 0.2830612460413665, 0.19854089063824742, 0.6746098755583553, 0.6941017195071786, 0.5855480810042084, 0.5245528788672957, 0.615170103623286, 0.5264544124420787, 0.5104078073346059, 0.6187111000185144, 0.5781931446121017, 0.11367994499148759, 0.09890548690401424, 0.07744568771208593, 0.09921419404509724, 0.11041865153568287, 0.08583875789242235, 0.0904263266519496, 0.07834294232546091, 0.07337204608550241, 0.1490913299974338, 0.14416672328327695, 0.1309156707964052, 0.1803956502771782, 0.14435709582310918, 0.1437879585747711, 0.12620243161783784, 0.14760832077707087, 0.12807638975874103, 0.43163743265415255, 0.3506955909080566, 0.29382426415121554, 0.37318908574508936, 0.36223307810338934, 0.29007358610605327, 0.37466498219929467, 0.3886750832094912, 0.39817911253428273, 0.3183164615674966, 0.30484948544364976, 0.23124705356144482, 0.2752954954233957, 0.2759431503348009, 0.2211013797056236, 0.3371219589604241, 0.3502127118378279, 0.24932751805299536, 0.19163544232831542, 0.20272820109037537, 0.1631422966545164, 0.20519774788269984, 0.1942113712617627, 0.19268517578034128, 0.18926866087705085, 0.18427425485752214, 0.20369010614712602, 0.17011440507692022, 0.18808782581365824, 0.17771255934751684, 0.2063358508224553, 0.17631499616170554, 0.1766169752090263, 0.19341625161346176, 0.17435431478300456, 0.17225653436695798, 0.3332414067815245, 0.1699615530807016, 0.16394927011681049, 0.6602560670304511, 0.39324891623144187, 0.21378534633127433, 0.35270130547856904, 0.15856357244418173, 0.314816691361393, 0.2976470933852905, 0.16271122622151857, 0.18369018975088602, 0.18931573969358773, 0.28985938594842, 0.17844525970735248, 0.19657642503872763, 0.46348370123534655, 0.20382288042892083, 0.17431967619112454, 0.16719406454753039, 0.16810727528597313, 0.18771591464565218, 0.18547350124329964, 0.16558944588618574, 0.16494490924934457, 0.18028571483646993, 0.1663593321725908, 0.08177895413828407, 0.07503507220247252, 0.06769958338888682, 0.07355740960908674, 0.06645833051310712, 0.0744564793647633, 0.07860521381150887, 0.07291289123524203, 0.07943414215657063]}, "mutation_prompt": null}
{"id": "2a26ab01-dda1-400c-8b5f-1451854c8d08", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 6 * dim)  # Adjusted population size for diversity\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.6  # Adjusted scaling factor for broader search\n        self.CR = 0.85  # Adjusted crossover rate for more exploration\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.1  # Higher mutation probability for more exploration\n        self.memory = {}\n        self.dynamic_learning_rate = 0.02  # Dynamic adjustment for learning\n\n    def select_strategy(self):\n        if np.random.rand() < self.dynamic_learning_rate:  # Use dynamic learning rate\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.15 * self.pop_size)  # Smaller elite pool for diversity\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.5, 1.0)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.dynamic_learning_rate = np.clip(self.dynamic_learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic DE with Dynamic Learning and Mutation for Versatile Optimization.", "configspace": "", "generation": 90, "fitness": 0.27187670355327237, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.7080502753192468, 0.5888322504077002, 0.6967202433277675, 0.6869104898898177, 0.6411596957611752, 0.6501918191369129, 0.7062347558679553, 0.6294023824364345, 0.7102342920410476, 0.47035071291231967, 0.3257273302073851, 0.4020721485899297, 0.4586861292737312, 0.3347493157058219, 0.37923612538938145, 0.41150984477281216, 0.42326008266209736, 0.41452827278449467, 0.08323599188283348, 0.10966584219102571, 0.08811909593388523, 0.10946644660153648, 0.08679474451106794, 0.09400688984545125, 0.08187499124335795, 0.07424540092573184, 0.09136472454670597, 0.07471353663528024, 0.0747258331322106, 0.08368653511496527, 0.09747296271178185, 0.06184779490489434, 0.09629377331407318, 0.08296100975038245, 0.07634247276803419, 0.07522731993830567, 0.6799478707279105, 0.7976994522599428, 0.6195692924237681, 0.8008782928203859, 0.7500579264660975, 0.7976721516574001, 0.8395624720394712, 0.8537310668253141, 0.6668064053853932, 0.2619257372210393, 0.21738003281514717, 0.23703419069296705, 0.2886784896408865, 0.2642200410328188, 0.2401373645039756, 0.2724075313984714, 0.23036111925410907, 0.2572655606532511, 0.6391024360339799, 0.57658254955293, 0.5585360935040949, 0.6242389411988329, 0.5963937330750058, 0.6662975002281226, 0.21678135724831793, 0.5676116794491507, 0.6191083737468934, 0.13543157687634744, 0.1383270933727585, 0.19684678092607466, 0.13680470372771325, 0.20063806528263828, 0.11515707925264884, 0.19987364142857678, 0.15139116896697868, 0.13933089777736618, 0.16843888011998132, 0.10917458362315358, 0.15843638581287756, 0.16360235151701197, 0.14570791074388212, 0.18732632872977706, 0.16986419392372754, 0.22841902892018828, 0.13848668794840613, 0.2092405439721704, 0.1110967975690833, 0.210629007545593, 0.2898585019041263, 0.24802908799828827, 0.23198953575958736, 0.3434325733790362, 0.23277082268422422, 0.20909020382482357, 0.39877104752063985, 0.29228202253853375, 0.30547764532880306, 0.2889144444866313, 0.1862570783733738, 0.22756335994540045, 0.35102238841793854, 0.3191599899614712, 0.3436703926326995, 0.09079632174527519, 0.04835190726163896, 0.10670402663135115, 0.16556450995083027, 0.12789559494093572, 0.06537962861767077, 0.14522112865451964, 0.06696124824411676, 0.11039327613892036, 0.22346120867141028, 0.25061701239922685, 0.19597497814064702, 0.25064371348444725, 0.21732231799494395, 0.19042608395855598, 0.23974559179919397, 0.18297752764977326, 0.1936039938080356, 0.6083422651609555, 0.5517151091962573, 0.5596681015877893, 0.5585662568552447, 0.5937369033917324, 0.5346308370703245, 0.5635343714111385, 0.5501720296331157, 0.5334682869465649, 0.08350764436322622, 0.07283621471772472, 0.09232126989813494, 0.08959351844693775, 0.06984675154585007, 0.07525756192391309, 0.07677283125914669, 0.08502068248240524, 0.08234905478488164, 0.1162713987951538, 0.16296763164081673, 0.1372812455489053, 0.1382684524800194, 0.12494106313143216, 0.12982677524860808, 0.1600434627155608, 0.10660720124834566, 0.1280738778124696, 0.31106705597116724, 0.2998304094073987, 0.32478293668164004, 0.2749965895760964, 0.30043808597745914, 0.3126697716756316, 0.306625075182258, 0.3233806983344828, 0.2839617145301585, 0.2153414485665056, 0.18445595486594502, 0.21988796195473892, 0.20944923819384542, 0.195730851506961, 0.202399453006051, 0.26091951334105756, 0.2535449272593284, 0.2210010256538011, 0.19075274080006943, 0.18622945682862824, 0.18045044674120325, 0.17576112412833622, 0.17035253568216524, 0.19284048259508058, 0.16518296599861404, 0.17207325837341758, 0.17021193215957386, 0.16911631485447487, 0.15409891362276573, 0.1545316867014742, 0.1592349515905016, 0.1699445578960589, 0.17661465382116492, 0.17087370900847454, 0.1676338882183278, 0.1663515203104151, 0.16056468511691835, 0.2948694884312788, 0.17590663235802917, 0.5017587705612134, 0.1742172176925706, 0.5910063248277214, 0.19382127801775695, 0.1524864289842207, 0.5651478796006377, 0.6262778940142111, 0.17474768305081312, 0.5663273517993787, 0.2757366461536459, 0.22947149069529493, 0.5034631179503226, 0.18126295141227278, 0.32460507716923914, 0.1906277118102837, 0.1771706431552067, 0.1710947326760155, 0.18601040319338968, 0.17927169625130412, 0.18295337673192702, 0.17489135588387272, 0.17099334186362536, 0.16932072558179245, 0.16550619135742162, 0.0659832955789541, 0.06239434001734512, 0.07040262721985746, 0.06947980186489988, 0.06904109315179308, 0.06618558875751901, 0.06781049509560799, 0.06948531146800851, 0.0722736005232868]}, "mutation_prompt": null}
{"id": "bb3dcaeb-9c30-40ed-b52f-afc1465d0937", "solution": "import numpy as np\n\nclass EnhancedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.07  # Adjusted learning rate\n        self.dynamic_F_mean = 0.7  # Dynamic parameter tuning\n        self.dynamic_CR_mean = 0.8\n\n    def select_strategy(self):\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.dynamic_F_mean + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.dynamic_CR_mean + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.02, 0.1)\n        total_success = np.sum(self.strategy_success)\n        if total_success > 0:\n            self.strategy_prob = self.strategy_success / total_success\n        else:\n            self.strategy_prob = np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedMemeticDE", "description": "Enhanced Adaptive Memetic Differential Evolution incorporating Dynamic Parameter Tuning and Strategy Diversity.", "configspace": "", "generation": 91, "fitness": 0.26777947874974556, "feedback": "The algorithm EnhancedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.6871550620062487, 0.6824030217596868, 0.6979396519894783, 0.6927744470185966, 0.6718444750724166, 0.6732542809569908, 0.6748360797378894, 0.674222552827471, 0.6863558289427739, 0.491738095692821, 0.4811639635089686, 0.5225083927347001, 0.46231622592086796, 0.4806766898440402, 0.46816213466461165, 0.4994586497692587, 0.4943871629615113, 0.4779920956367397, 0.09362535412023043, 0.09069941941544934, 0.10186120773955809, 0.10028872715622206, 0.08783992393874773, 0.10796913927304974, 0.09746617364212906, 0.09585720480668536, 0.10877237862311362, 0.0783328339657885, 0.09198682098744926, 0.07739535194600977, 0.08401027627713498, 0.08853658483806848, 0.08158374097586873, 0.0741977251114111, 0.0836277937723835, 0.09737222560708214, 0.9090209326806313, 0.9188213467436188, 0.8939861279704845, 0.9142641910646019, 0.8156957131150965, 0.8537761822697684, 0.831938777451245, 0.9080625923029735, 0.8720167242779412, 0.2677722574451299, 0.23988476139105752, 0.2786878170156638, 0.25233285794746063, 0.28146828930131196, 0.2804741093471894, 0.32885158637501444, 0.2769766612241784, 0.29744492286816315, 0.5267035482801472, 0.5241981403641206, 0.5512961786050701, 0.5940740889864693, 0.6059966416344282, 0.5178298848355023, 0.5349841562793185, 0.5725702588004953, 0.6091116495050453, 0.12440141118276771, 0.16534517609374366, 0.16152454804574823, 0.18175710447353532, 0.16936904121649987, 0.18744879632568423, 0.17082834637116484, 0.16527676567109206, 0.1505477094405202, 0.1484620510655481, 0.12596003297931913, 0.20188439710737216, 0.1740693435799665, 0.1709674645957131, 0.16692752951544587, 0.18395037051129837, 0.14936482590574363, 0.1386571650799857, 0.13435797488792522, 0.11811645000127968, 0.09290675081331023, 0.10060256790334365, 0.07622526296708054, 0.14688591020619102, 0.15618983746362625, 0.1218332490751145, 0.1571967902089222, 0.27109749429040153, 0.20694609602794511, 0.25440382887851176, 0.2447604938218323, 0.2076859490294023, 0.23651743984449458, 0.2511631817954043, 0.2687875369562366, 0.24590744341481652, 0.022520466914698778, 0.04998591960333709, 0.0796029219938813, 0.06614711913593563, 0.112255204651034, 0.06411841573939436, 0.039435105543928706, 0.03328338177498846, 0.0553117112556889, 0.16740234829155087, 0.15919199311235555, 0.18461768890516406, 0.22877657766851367, 0.16532071376980717, 0.18054150504497046, 0.15944017870971716, 0.14831133561522147, 0.1768362279166631, 0.5217890339029115, 0.5369426318513787, 0.5260766771453574, 0.5160275391828504, 0.5057534956067444, 0.5028206370715647, 0.4892294240784051, 0.5297223991248745, 0.5435403009990001, 0.07252854616054916, 0.07842687916981173, 0.08590060085194473, 0.07035730710103871, 0.08097684561042096, 0.0775216131469455, 0.08212549558111981, 0.07805144304063649, 0.07506165774375728, 0.11589458234132144, 0.14704567988994277, 0.13041441258438757, 0.13465371059845077, 0.13447376728235994, 0.13580653808633503, 0.1323828759899861, 0.16310718348956144, 0.13657118482822028, 0.2637808799394429, 0.29962920307027174, 0.3002847282398351, 0.3063083624344587, 0.3260327632993142, 0.27925644106305647, 0.30486286013795005, 0.3211197365310452, 0.3368954030329627, 0.20861208253357277, 0.23953901719865311, 0.20814819488095115, 0.18636438698985658, 0.2170666791991155, 0.21824050465378542, 0.22060331890054763, 0.2288276970215518, 0.24966640699493314, 0.18117714866170997, 0.173082236572767, 0.16549327161242944, 0.16943886293574628, 0.1835607377177645, 0.16771290338446687, 0.15796127348698574, 0.1729478086000541, 0.19631725704872327, 0.16595733993645134, 0.1715128780574865, 0.16787355739636367, 0.16828338918674912, 0.1587794482140643, 0.1902866939158564, 0.16128693911094671, 0.16759225198465266, 0.16740799464499723, 0.47629011217424044, 0.26967713848620856, 0.515263436013183, 0.6324955075297939, 0.16078792955987664, 0.29209478758474805, 0.16914590994913548, 0.16287442853716982, 0.16146909840776702, 0.4755296429008433, 0.19151149183810423, 0.19356306688269242, 0.4260214190539424, 0.1557397056272577, 0.18628150332537063, 0.18281966773326486, 0.46286515138362916, 0.17741056179717818, 0.17595739989611126, 0.18025249064117566, 0.1872015465804081, 0.16382636117489324, 0.1712845093238755, 0.16953833037637212, 0.1773859951580833, 0.16796874277531637, 0.18781229543385036, 0.06322451920499716, 0.07231606134540203, 0.06603860095794312, 0.060911123534556966, 0.0728344895634313, 0.08697273932343919, 0.06372968891698294, 0.0629268782714082, 0.07295471391557617]}, "mutation_prompt": null}
{"id": "7d79a0e6-bb11-405b-9e83-54a683bd6845", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n        self.elite_fraction = 0.2\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * 0.9 * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(self.elite_fraction * self.pop_size)\n        if idx in self.memory and np.random.rand() > 0.1:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = np.exp(self.strategy_success) / np.sum(np.exp(self.strategy_success)) if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic DE with Reinforced Elite Selection and Dynamic Strategy Probabilities, enhancing exploitation and exploration capabilities.", "configspace": "", "generation": 92, "fitness": 0.21832859953019546, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.16.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.5120114131998901, 0.5436325798281452, 0.6449076828390943, 0.6116616538391619, 0.5370385854174424, 0.6121576849044721, 0.3238378814624767, 0.5363210440872941, 0.4439914621962703, 0.1192162792145518, 0.32716358261274103, 0.37139168862708594, 0.0836963529749184, 0.503636248362555, 0.1703329324203009, 9.999999999998899e-05, 0.17301079944715803, 0.3055877321988477, 0.08488827360491635, 0.09824224829610317, 0.08937097475850386, 0.091006152252322, 0.0919823200860368, 0.11402007754184429, 0.08465091306323613, 0.10395172754655724, 0.10497333824028776, 0.07058146263746146, 0.07231578216150447, 0.057750000789315026, 0.08751616308312027, 0.07853554262971352, 0.07304592996373527, 0.06780512054587229, 0.07685470722615295, 0.08683557824512167, 0.6375107350868314, 0.7956074397856181, 0.6307943058798842, 0.24765451386275472, 0.6343464514490659, 0.6552295703560727, 0.276466552398254, 0.552133535406484, 0.25344487408506855, 0.2158987352469658, 0.2797975059864839, 0.2760515449216221, 0.16290540942265674, 0.23706520977597334, 0.12041157352091647, 0.2484911294695742, 0.1077480036157834, 0.21287291976908718, 0.5829987325107997, 0.29566457996899065, 0.6290007896060446, 0.2554674006720984, 0.24104055907209776, 0.3178378365156985, 0.21596825261835784, 0.5160022642369877, 0.5583062046058275, 0.11406543878427489, 0.15264604646810442, 0.11633712081925263, 0.1310350511637276, 0.15307501854749317, 0.1167784638035686, 0.16079609481213408, 0.11720131880946971, 0.14742937855491722, 0.11231538010676645, 0.11607269892768945, 0.11362133667383367, 0.12244962636757972, 0.14285050012612377, 0.12679319186321392, 0.10984239076745794, 0.11027710394074552, 0.12430599503332929, 0.061350139011749016, 9.999999999998899e-05, 0.25303606591473293, 0.13514111595889333, 0.1904736164872317, 0.06451520045067971, 0.03093568089975629, 0.18113270470088216, 0.22449625497601677, 0.26272448053490305, 0.3789591494554416, 0.1870871531648901, 0.23041668866426512, 0.11190456893999867, 0.10524656143442912, 0.21346796430923753, 0.33695359760833943, 0.13747188657034437, 0.10392509023592778, 0.04788782863961938, 0.1055504021449506, 0.0761883597953592, 0.0844287500699491, 0.18315351967696147, 0.10853699025639074, 0.01405359002513018, 0.031008888471777962, 0.1391750164903156, 0.1772837822637362, 0.137504751102692, 0.07482892700165322, 0.20129148695785026, 0.15974978109471283, 0.12986208520869824, 0.15415489177672426, 0.10044386736305932, 0.4500220508747088, 0.4667977120697253, 0.4027994925329629, 0.3426798904553612, 0.3873332969305432, 0.6447273776602775, 0.4084604464221857, 0.3567931720325682, 0.5266113657389624, 0.0834872161560366, 0.10517045118068569, 0.09928452292657253, 0.07120915804493322, 0.0762009344104374, 0.11807210416281344, 0.08536125103382197, 0.07557176662338538, 0.09809320525564102, 0.11618818744153925, 0.11445322739271724, 0.12113404594885979, 0.11423803943446276, 0.1491558390020571, 0.10750329386896573, 0.14539313151152655, 0.14114724651636223, 0.12080957652232593, 0.29239734565744613, 0.3037897085646031, 0.294757667763922, 0.3151569534133565, 0.33638152435906765, 0.29784075301697244, 0.36126218408254995, 0.29165705832636746, 0.31033625064414494, 0.20235268494130976, 0.2436517545469129, 0.22589210891087907, 0.24986759499673095, 0.24553665064346586, 0.22546974334051195, 0.2948321395276803, 0.26267163782669445, 0.2744467699596219, 0.22068236319959478, 0.19278312318977353, 0.18006894370285687, 0.19305968793132677, 0.19034824620960733, 0.17810695898640383, 0.18490192092872804, 0.1811592411053854, 0.1678393089559187, 0.17812719379692243, 0.16672279386783195, 0.16797407665315744, 0.1933397602314505, 0.1695481232573588, 0.1961932755017073, 0.16687837433082708, 0.16839523793196154, 0.16832232976248507, 0.6454816175675222, 0.18193008175461978, 0.14457760847188128, 0.6523846238551549, 0.16291583925992037, 0.26874869485287556, 0.4770588255736796, 0.2529548730331539, 0.18363961801052153, 0.5033291509263, 0.15881102395048297, 0.18365819488467316, 0.23017535651997378, 0.1808503190105084, 0.15797242730214567, 0.1832833548557652, 0.14352057809719065, 0.10763558551435615, 0.17647903949388732, 0.17766248823043718, 0.16674811688470637, 0.17797884757453086, 0.17010122509415326, 0.1780925571906682, 0.15409120496882023, 0.16302445631171647, 0.18785293411021364, 0.06648057299197607, 0.07007704778486168, 0.0701980868015597, 0.08630406116833778, 0.07213599241462021, 0.08093835335006938, 0.061232378852711156, 0.0673271553821182, 0.05880417488293965]}, "mutation_prompt": null}
{"id": "6aea592a-ea06-430d-9139-0a1a7664166b", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 6 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.05\n        self.mutation_probability = 0.1\n        self.memory = {}\n        self.learning_rate = 0.02\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_memory_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_memory_elite(self, idx):\n        elite_size = int(0.1 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.05)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemeticDE", "description": "Adaptive Differential Evolution with Memory-Based Elite Strategy and Dynamic Parameter Adjustment.", "configspace": "", "generation": 93, "fitness": 0.27632839154350497, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.19.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.4579024859976428, 0.7284130028831219, 0.7369627336025947, 0.7346771273605108, 0.6757110224305667, 0.7255250497312842, 0.7240302159817029, 0.6837132126050178, 0.6839158605208064, 0.5329352330437274, 0.4599514218058699, 0.4701825194651813, 0.5000486572732266, 0.4819915953716102, 0.41554901602859606, 0.479397796150299, 0.4982408177261053, 0.504222070235675, 0.10196818296968724, 0.10910630336661997, 0.11154616169750986, 0.10240656332240727, 0.09355857072004126, 0.09643803445814725, 0.11344852472729128, 0.10168852559052544, 0.09972913047743148, 0.08370877204387794, 0.07746382480630787, 0.0750190708482864, 0.09494208408583404, 0.08004913397135538, 0.07906818563540874, 0.07047271175597924, 0.08141251625272783, 0.08706550634114796, 0.5429167026846925, 0.794944884967603, 0.4995899373706756, 0.3906489733236338, 0.6510334886174325, 0.7864752711553843, 0.39126345238893945, 0.672153488863833, 0.5596876539862154, 0.29308940933585403, 0.24488875786116493, 0.29795125976444137, 0.21959272056611367, 0.29390498567785517, 0.1981664942088196, 0.2627268164397064, 0.18502837906139613, 0.2529017652905797, 0.7220531282869957, 0.5142444658037238, 0.7016001725094236, 0.6555659457192906, 0.6055538991811968, 0.4420505127218348, 0.3123723584575848, 0.6578262764448752, 0.6578602086047605, 0.16686238029680134, 0.11789172200789466, 0.1596648074481425, 0.11824528652800914, 0.12775081945845235, 0.12277485910857888, 0.1991949375009463, 0.15213047227924947, 0.1493615719640069, 0.17717218439778082, 0.11286355324150499, 0.24197788168935597, 0.15188732256074278, 0.12896847772037745, 0.339615488820596, 0.17971740377317258, 0.14091795481117897, 0.19455837585428448, 0.11529444243365139, 0.2168805944552633, 0.2624220485409434, 0.16705060882084832, 0.17138807192645367, 0.09147871723206957, 0.22019883540641894, 0.1386209256498665, 0.20278295834776616, 0.3462137323986024, 0.34753186050232976, 0.4723323264792971, 0.3320024872699381, 0.32004863393241856, 0.11415395134586215, 0.38459799661715677, 0.299605716054111, 0.4588470266542106, 0.14741525148987644, 0.046538162229627256, 0.15167267186333944, 0.15649888092199848, 0.10893064018149012, 0.22337342452985198, 0.16839271345379714, 0.1375311731788914, 0.09481110888729616, 0.2310333056867101, 0.20923288401241447, 0.28018015063161905, 0.2379119200915084, 0.27857661590481464, 0.23095112112335048, 0.16674998817984432, 0.24015813073372794, 0.21087768127187578, 0.6444250176665773, 0.6028192717261267, 0.5360227215451203, 0.6372058829888756, 0.5700547402261298, 0.5921143007680338, 0.6683516940942951, 0.5238338153764007, 0.6016227639483037, 0.09232694235799643, 0.10123819032744863, 0.08347284236012187, 0.08498409377583427, 0.09110909200364514, 0.09131447246262192, 0.09819152320083491, 0.09143149608890921, 0.08188751891337742, 0.1545797879413816, 0.11422088614248627, 0.15960298101775172, 0.1391644468887886, 0.1369226252129624, 0.10713620656089384, 0.1361110584648244, 0.11947893706192103, 0.11552203741170475, 0.3303319852057113, 0.34785547096894565, 0.32804944311017725, 0.3366084251582704, 0.3017158215273481, 0.3285300076369181, 0.32395654806304164, 0.35586899852291387, 0.31617785228796436, 0.2645227376976581, 0.25785242241752326, 0.2906609770805534, 0.2634862959113111, 0.23081952392497673, 0.2813653006382848, 0.29660000221032357, 0.24926841664186405, 0.300170205427162, 0.17946236077717836, 0.17810677671048702, 0.19023953394060478, 0.18519585903785762, 0.1756183753569005, 0.18292022985574197, 0.19993755331131668, 0.1714363333226946, 0.19097065082027642, 0.1615264170989793, 0.17307186474205394, 0.17075038477702276, 0.17317755683078262, 0.17238747149500855, 0.18339654643118308, 0.15233070351678002, 0.18726615778186328, 0.1699317338939218, 0.1613567323451467, 0.5305382506373582, 0.16243002156553998, 0.5275056698808918, 0.3922395843433889, 0.47509706366889837, 0.1505207263680557, 0.5858090367921767, 0.16901664588298937, 0.5926977959244041, 0.2482085073127751, 0.44427925881727426, 0.19900257370069674, 0.18869271925125897, 0.2490151461680844, 0.17011694086384743, 0.14670416426954946, 0.1867655650595773, 0.1635952173390387, 0.16713940029434526, 0.18336700407455409, 0.17510955056472977, 0.17651092778897548, 0.1734505005253819, 0.19186344895931884, 0.16800850203467088, 0.16340850726418554, 0.07490073578191436, 0.07312569241397304, 0.0733562163816569, 0.07531384027084898, 0.06790732172919145, 0.07195680656955827, 0.07287000070112737, 0.06878043627579011, 0.06716446243246066]}, "mutation_prompt": null}
{"id": "4fffe44b-cf18-403f-83be-067e0451c683", "solution": "import numpy as np\n\nclass EnhancedSynergizedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n        self.dynamic_mutation_prob = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.dynamic_mutation_prob:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n        self.dynamic_mutation_prob = np.clip(self.dynamic_mutation_prob + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedSynergizedMemeticDE", "description": "Enhanced Synergized Memetic Differential Evolution with Adaptive Mutation Probability and Elite Memory for Improved Exploration and Exploitation.", "configspace": "", "generation": 94, "fitness": 0.3084270132028227, "feedback": "The algorithm EnhancedSynergizedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.7708285963410642, 0.7855560701570791, 0.6863578603711472, 0.7665432547534725, 0.5933861128630583, 0.7388154187968674, 0.7743805232052585, 0.798369032603515, 0.6654270000632125, 0.6228230173750336, 0.491774842987584, 0.5538588099294284, 0.5320382869855931, 0.5969553577661697, 0.4867316260451505, 0.33664092969921167, 0.6362288098781725, 0.53884782022323, 0.10980281438647921, 0.10933902044945443, 0.107022251915728, 0.1091202543644777, 0.09988124648385432, 0.10179959877663425, 0.10479335250444033, 0.10301799761716213, 0.09273532296905318, 0.09845764610992569, 0.08866796316218328, 0.08726772196231491, 0.08822200380340905, 0.09207591490523259, 0.08020778275374474, 0.09041678212686999, 0.0993579574693354, 0.08791164140521834, 0.5737628121138292, 0.7205943858412562, 0.9141606581137317, 0.5950856925046654, 0.6294948955175632, 0.7533507435035113, 0.7677821983802743, 0.6627751138499656, 0.6977589745366711, 0.3905460657193923, 0.24582696414265914, 0.2114137594698724, 0.27099636033609886, 0.24110138486278943, 0.3269113273485218, 0.24809475048029406, 0.19149518597769388, 0.3386568344221127, 0.7548507550442684, 0.21655084290467397, 0.6291565171508566, 0.7333922694950563, 0.7770523051137769, 0.6201170805636056, 0.8054484783979032, 0.6704860824823399, 0.6496947491553597, 0.12599839791235867, 0.13352703026739565, 0.40344359525116835, 0.1456147692443519, 0.12816334806143692, 0.2545068357559076, 0.13611599102073813, 0.11860145270535338, 0.1987120652651735, 0.14070200052859583, 0.1598629531944924, 0.15089732237140574, 0.22593373174490183, 0.16259953656363013, 0.2928452579441335, 0.12806688273603473, 0.19880881916706317, 0.18351415448775665, 0.3685994607160231, 0.045213590806709725, 0.26402078762824377, 0.44908320756249154, 0.153331637165527, 0.24285628385035807, 0.2712592149209312, 0.36312845292365226, 0.3043543828620502, 0.44576681899689097, 0.24440344199990882, 0.456294822572724, 0.5429013158899247, 0.1336732086865935, 0.3201184981036894, 0.5381331139270509, 0.49238328281451027, 0.33429151272792046, 0.09459301125408204, 0.13222863512776095, 0.17078194722876816, 0.21147010008169287, 0.2072474155220988, 0.18653419983562447, 0.13008770800726976, 0.22021978860349167, 0.08146016074178897, 0.3208432931901267, 0.31608331791736044, 0.24807975400181648, 0.26822344502806383, 0.30242913571598284, 0.2705980442299406, 0.30104321657846145, 0.3447603960760254, 0.25170027246921456, 0.6711981570052543, 0.7167883736453586, 0.6343728153711846, 0.6801933720481361, 0.4857576012598792, 0.6548390944989779, 0.7390987832648659, 0.43748834038444573, 0.6462199547188356, 0.09659616938970772, 0.08863993280455873, 0.08797441457292321, 0.09784520011746523, 0.08841253406543348, 0.09244105807452596, 0.10098049553399191, 0.11132448383371374, 0.10147231440663385, 0.12427887177589436, 0.12634292684966864, 0.13071153483957154, 0.12501854274765067, 0.15531025489836137, 0.17545854530782856, 0.11961485401509109, 0.16689884443346414, 0.130043378877854, 0.3783001206943283, 0.37282884416496453, 0.3272090596336902, 0.37509835309267703, 0.386417645211534, 0.3211378091409486, 0.3804140559582817, 0.48975564032463315, 0.3782534082164236, 0.2764633613269645, 0.3172309037743747, 0.24490168949302227, 0.26168655922781714, 0.29600028395416533, 0.24243960556949373, 0.2823887118706866, 0.32144138475844175, 0.26359318106801644, 0.18635180655942518, 0.17465453896033578, 0.17035064229756613, 0.19765967189042866, 0.19025496516412577, 0.1797694397888857, 0.19625356651511694, 0.20554200382035137, 0.1814829622808285, 0.17350968182606885, 0.1620516103327806, 0.19736412184585495, 0.17430201777913112, 0.17376429001558458, 0.16647800714575423, 0.16763433229050229, 0.20428223733885353, 0.1830918185798217, 0.17914570433525678, 0.1712843756946537, 0.561555517371795, 0.16554745897977574, 0.668023385500354, 0.5663368810148097, 0.15586557991761651, 0.2541130095521522, 0.1572783225744182, 0.7574786936936324, 0.19559515061409716, 0.15764702206460657, 0.6518647072037116, 0.6147735213994915, 0.5123704002895894, 0.1523076282295358, 0.14532794953924766, 0.20615207155300952, 0.16689291505340753, 0.16968601384918125, 0.19391191136693142, 0.18384072338115953, 0.19220227544723434, 0.17599436163012228, 0.1695831204264796, 0.1824305806303067, 0.1912029510493648, 0.06854528579393859, 0.0744452422487899, 0.07650595874673927, 0.07459653245622999, 0.07505278910255675, 0.07117130986086195, 0.07029151464037553, 0.07068112732636889, 0.07652482799357185]}, "mutation_prompt": null}
{"id": "10c8105b-5bc1-447c-a259-a34879b3f5c7", "solution": "import numpy as np\n\nclass EnhancedSynergizedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n        self.inertia_weight = 0.9  # New inertia weight for balancing exploration and exploitation\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.inertia_weight * (self.population[r1] + self.F * (self.population[r2] - self.population[r3]))\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.inertia_weight * (self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5]))\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.inertia_weight * (self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2]))\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        self.inertia_weight = np.clip(self.inertia_weight + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 0.95)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedSynergizedMemeticDE", "description": "Enhanced Synergized Memetic Differential Evolution with Adaptive Inertia Weight for Improved Exploration and Exploitation.", "configspace": "", "generation": 95, "fitness": 0.1228845172187501, "feedback": "The algorithm EnhancedSynergizedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.09.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.22075035494287776, 0.22129552936239139, 0.20898604559147382, 0.1721442394001198, 0.14320312897564969, 0.15716819406784577, 0.13891893420706602, 0.1817342915584096, 0.1519024132956749, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038055289215118915, 0.0001205954639561524, 0.013132852737168688, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06349841435288495, 0.0684246690341741, 0.09052863144432122, 0.08465230841537996, 0.08313488092366317, 0.07686794567366928, 0.06042129832981502, 0.06393218846471027, 0.08551659940186074, 0.08015608728952939, 0.06224775982586994, 0.06828603964895719, 0.0654648128473142, 0.04388673334573845, 0.05810203790909341, 0.053032307423112934, 0.04429449317313605, 0.04249158424297461, 0.10164255080840445, 0.09452402771280599, 0.1115343964609814, 0.0894927210728641, 0.07693508992467246, 0.08947963534564263, 0.11803741003776325, 0.0771546369389895, 0.11430262438495409, 0.14767043908999966, 0.08491747916064685, 0.09803157695127573, 0.09178799264832582, 0.08875280385828266, 0.10619177450395834, 0.14404577277824793, 0.11869586676548838, 0.11063788500888094, 0.28837550964421055, 0.21111341409946038, 0.7434705967834186, 0.20921498760022073, 0.25117107743492173, 0.1876315278428483, 0.14321021016325886, 0.1331709738855712, 0.1778935055566795, 0.10697777109897122, 0.11712968856407402, 0.13419835008395364, 0.02231260400034185, 0.042516690138561186, 9.999999999998899e-05, 0.07052103715451341, 0.061868276798692556, 0.03875748373362986, 0.1664364455234032, 0.1506746975655957, 0.22384685246969516, 0.19087760674877474, 0.11773338128757149, 0.13717713540323861, 0.23773315636044046, 0.18245266508224844, 0.1667409976362968, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00688656802708687, 0.05641314075390802, 0.057837614901619205, 0.0761717866235202, 0.08071417153800398, 0.04973204782999452, 0.013554266738475818, 0.033319192997781966, 0.03531300015817074, 0.09496084470956723, 0.03365668308300318, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02695010697520861, 0.0034174348437003843, 0.02866362355932328, 9.999999999998899e-05, 0.0014550333739463683, 0.017227187306384395, 0.014339721035991349, 9.999999999998899e-05, 0.003957958907581216, 0.266564426121607, 0.25001658235646285, 0.27313879882719416, 0.16840049315287908, 0.20847770352675343, 0.19206714388582413, 0.32402364546569284, 0.24971986660282186, 0.32668955527343424, 0.0678728340407988, 0.05045898685705563, 0.058040328310488776, 0.06392102157494373, 0.06251191320233862, 0.08407478579997973, 0.07457680910081832, 0.06060578738213118, 0.07238122247678203, 0.12778359793222627, 0.12136601410729253, 0.12367998177840944, 0.14362025349385588, 0.1200545709537999, 0.1304670671712993, 0.12424781331958179, 0.12654833724633519, 0.1294414259494877, 0.21902808277716967, 0.19613684679656707, 0.22029811211198935, 0.23663880193976616, 0.2084474993076556, 0.2441802482819918, 0.20419178385015657, 0.2199802255172848, 0.22913611620880536, 0.14128326574958372, 0.14930134131161465, 0.11681064675817832, 0.19158867763206644, 0.17113095568531667, 0.17901253100661618, 0.15613434433335938, 0.1559119534629575, 0.16262040981738735, 0.20463545715959686, 0.19042267189219642, 0.19700262132120405, 0.21478482538168997, 0.22406053888744715, 0.20697605900580152, 0.20937594676809235, 0.21868810051204945, 0.21331079553019083, 0.16894518191487673, 0.15193658700126011, 0.16807390664535338, 0.17322248217766878, 0.15754042433296367, 0.16916412597383113, 0.1617399942796799, 0.16244482812368644, 0.16474359739746192, 0.17642693556599276, 0.1604691504868555, 0.1682422935418426, 0.2737982476350642, 0.1981170009188964, 0.1875435807057242, 0.2270484829722209, 0.13348454758918182, 0.3483507906717551, 0.21394898462012002, 0.19923990179590012, 0.32687242147693174, 0.16993855804105973, 0.22061363771620424, 0.16290282901247555, 0.15918306777753677, 0.15895997806028084, 0.12023130637303725, 0.17603028334239257, 0.19059033968375438, 0.17553857734926293, 0.17466270757821734, 0.20065486737565275, 0.1852311685108341, 0.18935668404289663, 0.1663298773582459, 0.16947786117604924, 0.07547267310770589, 0.09129838513247701, 0.0754663320596044, 0.08006068837914881, 0.06741605377577575, 0.07605535684507392, 0.07731130263892338, 0.07459014083493243, 0.07602738229418193]}, "mutation_prompt": null}
{"id": "e3f6c5e5-a0b2-498a-aeee-156b23976332", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.1\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveMemeticDE", "description": "Enhanced Adaptive Memetic Differential Evolution with Self-learning Strategy Selection and Dynamic Adaptation.", "configspace": "", "generation": 96, "fitness": 0.2810081501447097, "feedback": "The algorithm EnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.4580051784689976, 0.7189458566961122, 0.6853299583049638, 0.7481522074700988, 0.741421762527007, 0.6932298244942943, 0.7160159081163215, 0.7708344607396947, 0.6698829637138055, 0.5769750100023627, 0.6283877484802862, 0.3783460566248652, 0.6330090747972914, 0.6130549843105562, 0.3578534519193295, 0.5793094695383683, 0.5956033491521333, 0.33210120656667164, 0.11374121664288073, 0.09836583132183807, 0.0984968191890715, 0.08831530392710707, 0.09890279621316289, 0.08584733779752518, 0.09126485218205327, 0.09651552999543234, 0.09528319371066951, 0.09728551334739677, 0.07889123615965421, 0.07912303928011677, 0.09430813473828581, 0.0887614566086461, 0.0802008604391038, 0.07954539655521697, 0.09701673177799808, 0.08541075756212646, 0.8720492702512433, 0.7622798815493186, 0.6952667219582229, 0.4476729534897004, 0.6206566333724164, 0.5905270444172805, 0.5305132606089554, 0.5713679723120101, 0.7391788628204952, 0.1950835175340403, 0.32291483834602897, 0.28359729560087676, 0.18097004645516634, 0.2899322306083816, 0.3043444053257781, 0.21467835608851005, 0.19697368504706225, 0.3183021606724459, 0.6522651210382213, 0.6767643493161921, 0.2095806111131201, 0.711886327930199, 0.7577886785498584, 0.6385925143575959, 0.7419463851676338, 0.22176545295247563, 0.6031133936421238, 0.1304749397767655, 0.1622067535861188, 0.20214429503523557, 0.2783187760041723, 0.12470162050728628, 0.15084609768104018, 0.13240850410832428, 0.12761661604386176, 0.17995007038099153, 0.1502118252564758, 0.15736024671255255, 0.1705560693288093, 0.1420021341874722, 0.16712759788924247, 0.25793660769719884, 0.24387447245374738, 0.13818796361627905, 0.16987978483501465, 0.11058973753189838, 0.3113754297144449, 0.21010803972178405, 0.17050547935375837, 0.21239957036285073, 0.2001691869162987, 0.08775006211627401, 0.10901550252461256, 0.27099766417853366, 0.4757625289154027, 0.14407068036838322, 0.34422759590123886, 0.1922035904641538, 0.24169728602452445, 0.3054232259088919, 0.2327481626733776, 0.566881784609235, 0.37447586277599754, 0.18903910151147496, 0.10636591067308165, 0.06892797098098813, 0.18025083816634235, 0.11890499283557587, 0.13397372626364945, 0.16294565435055497, 0.14418353418932783, 0.08806683892410716, 0.3004121683612663, 0.28366498544319363, 0.16615992389109124, 0.13458968770533974, 0.23907807989416907, 0.19127430526083666, 0.37373928773289433, 0.2830612460413665, 0.19854089063824742, 0.6746098755583553, 0.6941017195071786, 0.5855480810042084, 0.5245528788672957, 0.615170103623286, 0.5264544124420787, 0.5104078073346059, 0.6187111000185144, 0.5781931446121017, 0.11367994499148759, 0.09890548690401424, 0.07744568771208593, 0.09921419404509724, 0.11041865153568287, 0.08583875789242235, 0.0904263266519496, 0.07834294232546091, 0.07337204608550241, 0.1490913299974338, 0.14416672328327695, 0.1309156707964052, 0.1803956502771782, 0.14435709582310918, 0.1437879585747711, 0.12620243161783784, 0.14760832077707087, 0.12807638975874103, 0.43163743265415255, 0.3506955909080566, 0.29382426415121554, 0.37318908574508936, 0.36223307810338934, 0.29007358610605327, 0.37466498219929467, 0.3886750832094912, 0.39817911253428273, 0.3183164615674966, 0.30484948544364976, 0.23124705356144482, 0.2752954954233957, 0.2759431503348009, 0.2211013797056236, 0.3371219589604241, 0.3502127118378279, 0.24932751805299536, 0.19163544232831542, 0.20272820109037537, 0.1631422966545164, 0.20519774788269984, 0.1942113712617627, 0.19268517578034128, 0.18926866087705085, 0.18427425485752214, 0.20369010614712602, 0.17011440507692022, 0.18808782581365824, 0.17771255934751684, 0.2063358508224553, 0.17631499616170554, 0.1766169752090263, 0.19341625161346176, 0.17435431478300456, 0.17225653436695798, 0.3332414067815245, 0.1699615530807016, 0.16394927011681049, 0.6602560670304511, 0.39324891623144187, 0.21378534633127433, 0.35270130547856904, 0.15856357244418173, 0.314816691361393, 0.2976470933852905, 0.16271122622151857, 0.18369018975088602, 0.18931573969358773, 0.28985938594842, 0.17844525970735248, 0.19657642503872763, 0.46348370123534655, 0.20382288042892083, 0.17431967619112454, 0.16719406454753039, 0.16810727528597313, 0.18771591464565218, 0.18547350124329964, 0.16558944588618574, 0.16494490924934457, 0.18028571483646993, 0.1663593321725908, 0.08177895413828407, 0.07503507220247252, 0.06769958338888682, 0.07355740960908674, 0.06645833051310712, 0.0744564793647633, 0.07860521381150887, 0.07291289123524203, 0.07943414215657063]}, "mutation_prompt": null}
{"id": "b4c29ceb-2492-4c7c-9978-4875d59c6d58", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = int(0.2 * self.pop_size)\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Stochastic Local Search and Dynamic Strategy Tuning for Robust Optimization.", "configspace": "", "generation": 97, "fitness": 0.32088955148295545, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.7788463382149456, 0.7222233227025788, 0.7119897024608502, 0.7872539598804809, 0.6697637107389571, 0.7299586160827567, 0.7280997172209203, 0.7700207881007501, 0.7406958809927395, 0.6218370781976879, 0.5752122875114816, 0.5232453513110437, 0.5620006232021444, 0.54072874598375, 0.5019536302129185, 0.28900440421261986, 0.5603810730042138, 0.5593098247444007, 0.10521036313066034, 0.09320834941053258, 0.11258743499396673, 0.1067897775585438, 0.1036195526006759, 0.08627383971329528, 0.12707716814742942, 0.09516375977408098, 0.08995676347362802, 0.11592019421793809, 0.08250011804273383, 0.08131115101316477, 0.09546741906285228, 0.08963144134998524, 0.07325625281972115, 0.07849354466805414, 0.07545139332300421, 0.0708048359285276, 0.861941010981822, 0.8971908414162126, 0.6612370681904074, 0.7708696894379478, 0.7163555498995502, 0.8250445219414547, 0.8246601216128293, 0.7655937654091072, 0.6653637873887162, 0.1743542157423551, 0.30881355747055417, 0.325665605578738, 0.35217832987227005, 0.35159305745804403, 0.3310880144653249, 0.23768881282148746, 0.35281248714057056, 0.31534423377370335, 0.717156186666721, 0.7152509580951149, 0.7694167693221193, 0.7739087214503402, 0.6983267963951303, 0.5705219263219026, 0.6878657419509291, 0.4243779679415507, 0.48888617565081904, 0.21785467395573987, 0.19538891686141924, 0.21092203540250076, 0.2373482030760815, 0.19690625202219725, 0.2715508675748407, 0.15957217919696265, 0.18304263867915138, 0.2693927208891538, 0.17987020302450585, 0.20224344102444836, 0.1762085294957484, 0.23357766656633416, 0.17760479659726114, 0.37143091241162474, 0.14301556734618914, 0.27968896086435446, 0.12879597665830655, 0.45778505924673885, 0.40520938244170157, 0.45186602566895795, 0.33963890446362943, 0.4082225208890312, 0.4761194845333433, 0.05525861679495081, 0.46179221628434663, 0.330705071249745, 0.1945883063025261, 0.446968619623886, 0.517288249078051, 0.47662933004324926, 0.457947481912213, 0.4385631511156085, 0.5292308367562681, 0.4078991704943833, 0.506346546440023, 0.10827588638823105, 0.112576613062644, 0.15654298198335947, 0.11361337238840097, 0.11416934958047986, 0.3471054887012992, 0.24033305671634542, 0.14773385473504408, 0.07247347257402803, 0.2729341011130033, 0.28323725957262125, 0.298962448085047, 0.3646354595034459, 0.2951319221840737, 0.3781141676917439, 0.23312535157120073, 0.2692240745106065, 0.29342406159216183, 0.47404334368694634, 0.6403134236705154, 0.6664638215743005, 0.6466068507347629, 0.6045447355719609, 0.6692076646039808, 0.7035799909476368, 0.5596990305852284, 0.6326087041208002, 0.09168457508203776, 0.08958559939747468, 0.09047958965771663, 0.10879261485836922, 0.08408005700568955, 0.09283306399873714, 0.10717305354511208, 0.10046583767119954, 0.07451049059448578, 0.15724524156933617, 0.12359200505599743, 0.13306770859049433, 0.1215059008634718, 0.12095843205552592, 0.12882743901703997, 0.1337531586984516, 0.12223213091267049, 0.12580263637107802, 0.39075609884837914, 0.36472260426548, 0.3298749832187664, 0.3498591525115464, 0.3328451446675328, 0.33665338885327634, 0.3824050776819484, 0.3510918950752272, 0.4129295852631687, 0.2814084661077525, 0.26198635350297506, 0.2641382576683833, 0.26958793524366775, 0.2271825027349974, 0.29768874626470776, 0.3538501826387844, 0.28639744580240833, 0.3456874441535813, 0.20402223650003326, 0.19556653877727004, 0.2078026880387156, 0.20098544723749945, 0.22471606106384634, 0.19859485277646727, 0.18047602763759218, 0.1960839157811518, 0.19688314169823629, 0.19357345127892478, 0.17986929722928668, 0.16503015506348961, 0.18149836102994, 0.1736284554292724, 0.16901589746116352, 0.16471802110435352, 0.1753848469130851, 0.17277380456912073, 0.19970360669769283, 0.6608961040029048, 0.18114635879929708, 0.542514759392418, 0.20317264619709585, 0.5231039481787816, 0.7630279585606847, 0.5135031952271126, 0.7610686457944482, 0.25969617067764517, 0.20145860458356446, 0.18244915553874907, 0.15993582957341024, 0.42299883869588295, 0.15632301098026857, 0.15756285468632925, 0.21235786192188455, 0.1952869095292552, 0.16595995080467296, 0.19809167888272738, 0.17738810979752984, 0.1570003792884196, 0.16817963519325407, 0.19041755934225724, 0.18360442985325887, 0.1800634886271547, 0.1707659198681527, 0.07009133261412392, 0.07579438439643105, 0.0735957175464218, 0.08418775240322707, 0.07410162313045254, 0.07554317297248758, 0.07549519201571586, 0.06956569711964167, 0.06590430755300547]}, "mutation_prompt": null}
{"id": "c09d4d3d-65bc-49a4-8bfd-a5c493dbae02", "solution": "import numpy as np\n\nclass AdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(10, 5 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(3)\n        self.strategy_prob = np.ones(3) / 3\n        self.adaptive_factor = 0.1\n        self.mutation_probability = 0.05\n        self.memory = {}\n        self.learning_rate = 0.05\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(3)\n        return np.random.choice(3, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = max(1, int(0.1 * self.pop_size))\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.01, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(3) / 3\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemeticDE", "description": "Adaptive Memetic Differential Evolution with Learning-based Strategy Tuning and Diverse Mutation.", "configspace": "", "generation": 98, "fitness": 0.3227485227129257, "feedback": "The algorithm AdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "f4caadb0-b5a4-4465-9178-4d2d66959965", "metadata": {"aucs": [0.7736682066225488, 0.7670340526793287, 0.774446072706901, 0.6558818712597645, 0.7507357361280618, 0.7547772684920645, 0.7602225270081557, 0.7231643241416217, 0.591666147065464, 0.5972132649948882, 0.5831787293425967, 0.5864364274431246, 0.6109281455658895, 0.5217796304163578, 0.5218871192053256, 0.6363635048501483, 0.56077839419441, 0.5692690375926122, 0.11931279283770857, 0.09145006135409983, 0.09272665195137308, 0.10273169577203112, 0.1017202692799839, 0.10434939846182856, 0.10870788388644292, 0.09402800903507214, 0.08792022165865943, 0.08014206061174067, 0.09913698332894294, 0.07039516940932988, 0.1055591950520951, 0.08459866678021022, 0.08741997224397868, 0.08039455040418886, 0.10028145378341746, 0.09111631245210261, 0.780579877589778, 0.8968042546368713, 0.5475746152708666, 0.6040561142847571, 0.6526547440554276, 0.8754931499465882, 0.6935646038445007, 0.7704367691422935, 0.5783762027011636, 0.29568782536219496, 0.3686910571300571, 0.38060539978765817, 0.22055106128229396, 0.3175086038923738, 0.3839675457492342, 0.2678083948442077, 0.2628501098253023, 0.3168437765211085, 0.8392775134087579, 0.2095307720627574, 0.7505916704510719, 0.7546371606488893, 0.7478977604730381, 0.6467013630039775, 0.7235039749013679, 0.6314265220254148, 0.7867682360041437, 0.1373828893155511, 0.20227335590381235, 0.47836883374486283, 0.1535771976486674, 0.17431191011170344, 0.2678276449133755, 0.20573817915662307, 0.14627820225999333, 0.210542460673394, 0.1133866965632837, 0.15370858144920407, 0.22150498316675238, 0.1383765036194231, 0.16207498235320528, 0.18485969436363126, 0.19321183880821513, 0.20878394768218989, 0.20003635434164713, 0.29505447957982867, 0.3481149094139936, 0.4655599833573839, 0.3438533327817136, 0.3677171112918117, 0.3925889933901815, 0.17042093348146115, 0.3283540401609413, 0.2617401580886187, 0.3853653177281433, 0.5121619447991643, 0.44623073073892117, 0.25706674100209237, 0.3576876167726254, 0.3635340900654872, 0.48439218950712004, 0.5586874962536509, 0.4783137576231049, 0.05609879911815385, 0.15531146772000337, 0.16864796652692182, 0.17022780431141415, 0.26749310583118757, 0.21881716647082172, 0.17178492457010963, 0.14459018039021898, 0.0846845741323381, 0.1645677605587531, 0.2690999007496977, 0.32594338787731325, 0.2840715581100326, 0.2942282927882217, 0.3493064798072393, 0.23363132557383604, 0.24659882317948223, 0.2995360286748774, 0.4535424960704981, 0.6577368786165265, 0.7143227098385339, 0.7060331881521853, 0.5826065636832599, 0.5947754082606218, 0.4359802645281503, 0.6077268020967138, 0.7279457351966733, 0.09006305483258947, 0.09691381023020929, 0.0897204461860105, 0.09232697136266121, 0.08909621714669136, 0.08667018708933594, 0.08901815342406805, 0.08662782454497031, 0.07235598508775853, 0.14688408842377554, 0.13378109694825457, 0.13335791474130076, 0.1304058287837595, 0.11972334654538586, 0.14144615689213857, 0.15326808091240585, 0.12709742532163204, 0.12908369011620013, 0.36863577837108186, 0.36706134837649984, 0.3637473306015817, 0.4271306314894777, 0.3481932666879203, 0.39999236746450384, 0.37701292206521253, 0.3989762673441525, 0.43365248540272594, 0.2850169435842834, 0.2850260531118166, 0.30196170330549954, 0.3456961993884251, 0.27282546917097894, 0.2598776522172527, 0.33977364718814806, 0.3699155622191367, 0.3280313660685126, 0.1823918013453626, 0.20021395614350568, 0.17961300821162185, 0.18073871380501516, 0.18005096440769197, 0.196840088385983, 0.24384732238738294, 0.1900820520211609, 0.18786003489545744, 0.17907212944086748, 0.1627064786637693, 0.18803143559497715, 0.19799133536914748, 0.17051576244194544, 0.18855163606591785, 0.19504699288248317, 0.1698865596395317, 0.219744849924968, 0.17536871772811824, 0.16848106524979545, 0.19493963824455818, 0.6579112546802297, 0.15915133485266264, 0.6598090308479126, 0.1496699832668219, 0.1878242319610992, 0.6721766301865666, 0.7220057867521277, 0.6069153178891107, 0.7236319117259142, 0.7096972459586472, 0.49750128485765954, 0.18804027098052734, 0.10174213278133393, 0.5410308204879117, 0.1513168636090877, 0.1741618309332854, 0.1776488160236197, 0.18597723381919518, 0.159275410992481, 0.168486758561888, 0.18564182671903395, 0.1886269357331518, 0.1719963362934963, 0.17816198418067486, 0.06953043108796575, 0.07390339586108241, 0.07576554308836769, 0.07665580709057163, 0.07182087771649315, 0.07826925916982563, 0.07304693212299862, 0.07679662773612361, 0.06694042072432949]}, "mutation_prompt": null}
{"id": "a9250e90-6ea0-438d-8589-4a783527bc00", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(20, 7 * dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.7\n        self.CR = 0.8\n        self.population = np.random.uniform(self.lb, self.ub, (self.pop_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluation_count = 0\n        self.strategy_success = np.zeros(4)\n        self.strategy_prob = np.ones(4) / 4\n        self.adaptive_factor = 0.15\n        self.mutation_probability = 0.1\n        self.memory = {}\n        self.learning_rate = 0.06\n\n    def select_strategy(self):\n        if np.random.rand() < self.learning_rate:\n            return np.random.choice(4)\n        return np.random.choice(4, p=self.strategy_prob)\n\n    def mutate(self, idx):\n        if np.random.rand() < self.mutation_probability:\n            return self.random_mutation(idx), 0\n        strategies = [self.rand_1, self.rand_2, self.current_to_best_with_elite, self.best_1_bin]\n        strat_index = self.select_strategy()\n        mutant = strategies[strat_index](idx)\n        return mutant, strat_index\n\n    def rand_1(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3 = np.random.choice(candidates, 3, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n\n    def rand_2(self, idx):\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2, r3, r4, r5 = np.random.choice(candidates, 5, replace=False)\n        return self.population[r1] + self.F * (self.population[r2] - self.population[r3]) + self.F * (self.population[r4] - self.population[r5])\n\n    def current_to_best_with_elite(self, idx):\n        elite_size = max(1, int(0.1 * self.pop_size))\n        if idx in self.memory:\n            best_elite = self.memory[idx]\n        else:\n            elite_indices = np.argsort([self.func(ind) for ind in self.population])[:elite_size]\n            best_elite = self.population[np.random.choice(elite_indices)]\n            self.memory[idx] = best_elite\n        candidates = [i for i in range(self.pop_size) if i != idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[idx] + self.F * (best_elite - self.population[idx]) + self.F * (self.population[r1] - self.population[r2])\n\n    def best_1_bin(self, idx):\n        best_idx = np.argmin([self.func(ind) for ind in self.population])\n        candidates = [i for i in range(self.pop_size) if i != idx and i != best_idx]\n        r1, r2 = np.random.choice(candidates, 2, replace=False)\n        return self.population[best_idx] + self.F * (self.population[r1] - self.population[r2])\n\n    def random_mutation(self, idx):\n        return np.random.uniform(self.lb, self.ub, self.dim)\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        j_rand = np.random.randint(0, self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.CR or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n    def evaluate(self, solution):\n        if self.evaluation_count >= self.budget:\n            raise RuntimeError(\"Budget exceeded\")\n        fitness = self.func(solution)\n        self.evaluation_count += 1\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = np.copy(solution)\n        return fitness\n\n    def adapt_params(self):\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.5, 1.0)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.7, 0.9)\n        self.learning_rate = np.clip(self.learning_rate + self.adaptive_factor * (np.random.rand() - 0.5), 0.02, 0.1)\n        total_success = np.sum(self.strategy_success)\n        self.strategy_prob = self.strategy_success / total_success if total_success > 0 else np.ones(4) / 4\n\n    def __call__(self, func):\n        self.func = func\n        while self.evaluation_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                mutant, strat_index = self.mutate(i)\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = self.crossover(target, mutant)\n                trial_fitness = self.evaluate(trial)\n                target_fitness = self.evaluate(target)\n                if trial_fitness < target_fitness:\n                    self.population[i] = trial\n                    self.strategy_success[strat_index] += 1\n                else:\n                    self.strategy_success[strat_index] *= 0.95\n            self.adapt_params()\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDE", "description": "Randomized Hybrid Mutation and Adaptive Crossover Strategy in an Enhanced Differential Evolution Framework.", "configspace": "", "generation": 99, "fitness": 0.11242183262277419, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.15.", "error": "", "parent_id": "c09d4d3d-65bc-49a4-8bfd-a5c493dbae02", "metadata": {"aucs": [0.22430247359481847, 0.20951417989071963, 0.18456496181356896, 0.1909091370761119, 0.18015008666004828, 0.20708504273682593, 0.2375008484522605, 0.21129143045310939, 0.20903036838826272, 9.999999999998899e-05, 0.0006081861093575336, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041686741842023145, 0.03840467869073583, 0.06025252777935852, 0.049749350413506366, 0.04387495776590644, 0.0430674962158466, 0.042642913564098994, 0.05596918406484508, 0.04287662621544419, 0.038733389531209084, 0.03910358883421339, 0.02951708279559695, 0.044795681126653664, 0.03609092640106337, 0.027259668507327972, 0.028201839733037914, 0.025771623961453938, 0.03132898580965193, 0.7279738460452839, 0.6448342467239727, 0.8253636782288208, 0.8922863034896622, 0.8501541880066699, 0.7668423820268577, 0.6431056429414602, 0.5308244362672832, 0.847453121661139, 0.06181912051657368, 0.0739365772260433, 0.06232828976485305, 0.08990261315785686, 0.045344559200428236, 0.0848208817920848, 0.08344147553932313, 0.06738755137169772, 0.063359750966, 0.1528194333716214, 0.10126251131209651, 0.12422292320127859, 0.19141215454065263, 0.1154840389007159, 0.11976562822970194, 0.15372654804625308, 0.18739087134611943, 0.11951639389314261, 0.030685343286976585, 0.0005058562678689205, 0.009146525613071055, 0.024772735782945476, 0.009610511995180038, 0.03400633048969681, 0.012558040913121293, 0.04513803708655173, 0.012170246209870506, 0.007115369275025318, 0.004095129674954623, 0.002621860532987408, 0.022607305155656454, 9.999999999998899e-05, 0.03544945962090351, 0.04154256305027937, 0.004384510769091188, 0.0006116761921352021, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09750774070572987, 0.02386969583962839, 0.01858867343522852, 0.02261791607818453, 0.02579900955645298, 0.011385987579495827, 0.04286151651034342, 0.028136294100567838, 0.03371004571471947, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027468519840515238, 0.017303967825698097, 0.0034583575300466407, 0.015568074974116497, 0.009452422889418277, 0.01628673848986184, 0.02347757147313967, 0.017140454597762256, 0.0055183640188081196, 0.2260203612641678, 0.17508939281373792, 0.2270679273361974, 0.22315493574237788, 0.21131303400382895, 0.21457016210020463, 0.2610696972909947, 0.1829103191068696, 0.1974733929828979, 0.03653359827469527, 0.0531136324195306, 0.026535550065764024, 0.033606341765549774, 0.033459895160809716, 0.05245057147500343, 0.04274082730014073, 0.032988443876954654, 0.04330448545072707, 0.10307042637001307, 0.12359085207933806, 0.11078074783943725, 0.1317790580991285, 0.10850874223927354, 0.13064141551265607, 0.10726657961273833, 0.10391618936719893, 0.09290780935623133, 0.15376081460176938, 0.16976393393097533, 0.1578226939844719, 0.184418304620928, 0.1540217873169435, 0.14286151478441822, 0.17102617870637982, 0.18026562145133962, 0.16141225065745235, 0.08401274711587392, 0.10225520627946338, 0.10042056952281475, 0.10556834313196106, 0.0963436614532851, 0.08885939270497856, 0.11758683721222984, 0.12966507093399682, 0.10698327091055959, 0.1478197999748041, 0.1337913754138652, 0.13712268899734592, 0.1402244683864532, 0.13823669157153962, 0.13497169381455787, 0.14738432624336895, 0.14581542428204153, 0.17729384539786297, 0.11245552792891045, 0.14280823637488416, 0.10385181362100815, 0.13388565951340625, 0.14376060065251273, 0.13048431741637945, 0.1330192993173991, 0.0959989940724627, 0.0952815994095676, 0.11848095497326194, 0.12252220709771156, 0.19044621201413992, 0.1309525936653375, 0.12746020675348502, 0.16043643566722166, 0.11794795616478027, 0.1711243584471206, 0.1414295275070594, 0.14154007403417068, 0.11968185410437238, 0.09842731457054343, 0.11019986105017177, 0.12995880865118747, 0.10508068806398663, 0.15363863213351325, 0.15173463622400318, 0.08522252733366442, 0.15920088929359322, 0.15401128466714165, 0.15032944016319127, 0.16471278539989176, 0.16182363750424722, 0.19648899547015464, 0.19513589065674486, 0.14395219503791634, 0.1587526824084684, 0.03083921335200046, 0.05328698340583593, 0.0470463078205281, 0.04649318568193428, 0.05017694320456445, 0.04319790158428316, 0.04285348277913004, 0.03984370713858676, 0.0406305226099255]}, "mutation_prompt": null}
