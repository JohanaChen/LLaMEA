{"id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)  # Ensure a diverse population\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_fraction = 0.1\n        self.eval_count = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def mutate(self, individual, population, best):\n        # Differential Evolution-style mutation\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        x1, x2, x3 = population[indices]\n        mutant = x1 + self.mutation_factor * (x2 - x3)\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        # Binomial Crossover\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, population, fitness, trial, trial_fitness, idx):\n        if trial_fitness < fitness[idx]:\n            population[idx] = trial\n            fitness[idx] = trial_fitness\n\n    def elite_local_search(self, best, func):\n        # Simple local search around best individual\n        epsilon = 0.1\n        neighbors = np.clip(best + epsilon * np.random.uniform(-1, 1, (5, self.dim)), self.lower_bound, self.upper_bound)\n        neighbor_fitness = self.evaluate_population(neighbors, func)\n        best_idx = np.argmin(neighbor_fitness)\n        return neighbors[best_idx], neighbor_fitness[best_idx]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        \n        while self.eval_count < self.budget:\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self.mutate(population[i], population, best)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n                self.select(population, fitness, trial, trial_fitness, i)\n\n            # Local search on elite individuals\n            num_elites = max(1, int(self.elite_fraction * self.population_size))\n            elite_indices = np.argsort(fitness)[:num_elites]\n            for idx in elite_indices:\n                if self.eval_count >= self.budget:\n                    break\n                improved, improved_fitness = self.elite_local_search(population[idx], func)\n                if improved_fitness < fitness[idx]:\n                    population[idx] = improved\n                    fitness[idx] = improved_fitness\n\n        return population[np.argmin(fitness)]", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution-inspired mutation and elite local search to efficiently find optimal solutions in a variable-dimensional search space.", "configspace": "", "generation": 0, "fitness": 0.3736832586882798, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8692060493840063, 0.8753230712129547, 0.8698674066411474, 0.8707515976994974, 0.880477503328092, 0.89465287253704, 0.8790553855507521, 0.88377165145017, 0.8600790633772093, 0.7623483622177147, 0.7541810329597229, 0.7482013374582703, 0.7488058759375524, 0.7509663821491182, 0.7539670999300785, 0.7609350815430083, 0.8114634462483886, 0.7466056217511314, 0.46805418411376776, 0.17224347964858644, 0.1666954043448421, 0.31204445612392284, 0.15952663813173817, 0.17280829373717788, 0.5387702531020028, 0.5822691913010222, 0.15467637501410825, 0.5907154638557285, 0.15832323663437253, 0.16063017056513895, 0.3896513651454019, 0.1582396678739435, 0.15844220345269988, 0.16106691920014382, 0.48211844218531674, 0.4102915818548949, 0.9779176172339342, 0.9667497632537518, 0.9719968350536624, 0.9795003140750971, 0.972419915963086, 0.9880760481933367, 0.981075335970484, 0.9767806814410274, 0.9815172551989324, 0.5933918072584367, 0.5666062873237689, 0.5967689862344604, 0.49725816068317463, 0.5418788986672434, 0.5941763835948577, 0.5748740899981981, 0.5538061149607543, 0.6220029978014117, 0.8753016133072498, 0.7580596612863769, 0.7062554777029746, 0.7014201602218668, 0.7744182312388721, 0.7001958567537541, 0.7183324448662867, 0.6196655388597122, 0.7291839743936602, 0.34622790038245554, 0.2670595021908093, 0.3019234307580272, 0.2771132435610629, 0.39621088396359017, 0.3115441575954957, 0.36763923577058233, 0.2930408970915146, 0.3048814396514129, 0.38525269800966355, 0.13695488401175115, 0.2893911493189225, 0.38197333052188964, 0.3158457266320416, 0.34094842946716253, 0.3449950201308024, 0.3150140464837051, 0.30601967486429404, 0.0853693825450117, 0.09921899811270718, 0.13807479486648155, 0.12245334916386785, 0.12315009479103123, 0.10891705552259867, 0.1395593737827585, 0.14849460200331266, 0.10368516458846044, 0.21653879052648994, 0.3071522481981448, 0.26636489977317324, 0.23142399316838969, 0.18114833421122623, 0.22194721225613867, 0.39223394047062043, 0.285924831288378, 0.31432114008119894, 0.13285394094549718, 0.06893422357273704, 0.0276203221950847, 0.035578161523326934, 0.1390142311518333, 0.0815143979298869, 0.05115905455827763, 0.10552263617305324, 0.10048456782007342, 0.23145605112508572, 0.19400218583067486, 0.1898866452571072, 0.25188584142770365, 0.27291969073834643, 0.24636982667274498, 0.20015216151776072, 0.20957202899866956, 0.19617095024419673, 0.6083424996120554, 0.630463494370376, 0.6386638276027085, 0.5936822476175885, 0.5978466838300331, 0.6139778883491169, 0.6054608059871693, 0.590445838779296, 0.6241900280409345, 0.14306255024300585, 0.14479323630159813, 0.1379969906464672, 0.10478800959981927, 0.12361965197768932, 0.12391627527755045, 0.10827844223390581, 0.10507757842334609, 0.11155714696545982, 0.20367038957393846, 0.19316664931908067, 0.26589389969168875, 0.20361947128024827, 0.232724389021295, 0.23039253866507103, 0.1717033927018463, 0.19710146456574762, 0.19918900212549617, 0.36311052924798237, 0.38778734417098104, 0.36573900483143196, 0.41922445129094354, 0.32593930010600347, 0.3817620155454797, 0.4165296107988583, 0.4419738531695607, 0.4453671616443128, 0.2692943486097289, 0.2648729300371293, 0.24034060653949252, 0.24482336598357146, 0.26464722972333643, 0.23541894044449574, 0.235696162857565, 0.283671956492925, 0.31176964716673305, 0.19870167924286997, 0.20052380129942848, 0.22595015834525833, 0.21909010684395347, 0.18690280590990727, 0.20437187915806354, 0.18855427350468768, 0.18964322846502868, 0.19252505351449312, 0.3681921543476564, 0.2448366902038086, 0.3709243602223107, 0.34569458943346476, 0.24010159524370334, 0.20349342696699646, 0.5154103097479652, 0.4416658578227609, 0.21151223401029617, 0.16754601396824886, 0.2056223765976546, 0.18095202307446134, 0.1665739733998156, 0.7885122251311609, 0.7476442400650446, 0.1789480675557641, 0.701555445745834, 0.19656741203910666, 0.7688606897595233, 0.21190801546764182, 0.7450927086807146, 0.20297164619781183, 0.210386671936159, 0.5033976204271355, 0.2115466117433611, 0.20827487976362968, 0.21340882200334543, 0.18281773179745942, 0.17451668886543625, 0.1908529436635158, 0.18307839354020716, 0.1882844116200033, 0.18897957533201004, 0.19287922488977438, 0.18540945284997845, 0.19620672602122136, 0.07080960414069015, 0.08344663335607261, 0.07092166880818618, 0.0853028461580354, 0.07861076048981941, 0.0922777802302871, 0.08435745326388733, 0.08165582580614972, 0.08575226389930446]}, "mutation_prompt": null}
{"id": "3d3743ba-7863-414e-be88-b3dfb9095136", "solution": "import numpy as np\nfrom scipy.stats import norm\n\nclass ABODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.eval_count = 0\n        self.surrogate_samples = 50\n        self.noise_var = 1e-6\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def mutate(self, individual, population):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        x1, x2, x3 = population[indices]\n        mutant = x1 + self.mutation_factor * (x2 - x3)\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def bayesian_surrogate(self, X, y, X_new):\n        mu = np.mean(y)\n        K = np.exp(-np.sum((X[:, None] - X_new[None, :])**2, axis=2) / (2 * self.noise_var))\n        K_inv = np.linalg.inv(K + self.noise_var * np.eye(len(X)))\n        mu_pred = mu + K_inv @ (y - mu)\n        std_pred = np.sqrt(np.abs(1 - np.diag(K @ K_inv)))\n        return mu_pred, std_pred\n\n    def expected_improvement(self, mu, std, y_best):\n        with np.errstate(divide='warn'):\n            imp = mu - y_best\n            Z = imp / std\n            ei = imp * norm.cdf(Z) + std * norm.pdf(Z)\n            ei[std == 0.0] = 0.0\n        return ei\n\n    def optimize_surrogate(self, X, y, func):\n        X_samples = np.random.uniform(self.lower_bound, self.upper_bound, (self.surrogate_samples, self.dim))\n        mu_pred, std_pred = self.bayesian_surrogate(X, y, X_samples)\n        y_best = np.min(y)\n        ei = self.expected_improvement(mu_pred, std_pred, y_best)\n        best_idx = np.argmax(ei)\n        return X_samples[best_idx]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self.mutate(population[i], population)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if self.eval_count < self.budget:\n                surrogate_opt = self.optimize_surrogate(population, fitness, func)\n                surrogate_fitness = func(surrogate_opt)\n                self.eval_count += 1\n                if surrogate_fitness < fitness[best_idx]:\n                    population[best_idx] = surrogate_opt\n                    fitness[best_idx] = surrogate_fitness\n\n        return population[np.argmin(fitness)]", "name": "ABODE", "description": "Adaptive Bayesian Optimization with Differential Evolution (ABODE) that leverages probabilistic modeling to guide differential evolution in exploring the solution space more effectively.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (15,50) (15,15) ').", "error": "ValueError('operands could not be broadcast together with shapes (15,50) (15,15) ')", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {}, "mutation_prompt": null}
{"id": "42252eac-b659-47f4-bbd6-9c6752c607da", "solution": "import numpy as np\n\nclass AQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)\n        self.eval_count = 0\n        self.alpha = 0.5  # Quantum probability amplitude\n        self.mutation_rate = 0.05\n        self.adaptation_rate = 0.01\n\n    def initialize_population(self):\n        qubits = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return qubits\n\n    def measure_population(self, qubits):\n        # Measurement to collapse quantum states to classical solutions\n        population = np.sign(qubits) * (self.upper_bound - self.lower_bound) / 2 * qubits + (self.upper_bound + self.lower_bound) / 2\n        return np.clip(population, self.lower_bound, self.upper_bound)\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def quantum_crossover(self, qubits):\n        # Quantum-inspired crossover by random rotation\n        indices = np.random.choice(self.population_size, 2, replace=False)\n        parent1, parent2 = qubits[indices]\n        theta = np.random.uniform(-np.pi/4, np.pi/4, self.dim)\n        child1 = np.cos(theta) * parent1 + np.sin(theta) * parent2\n        child2 = -np.sin(theta) * parent1 + np.cos(theta) * parent2\n        return child1, child2\n\n    def quantum_mutation(self, qubits):\n        # Quantum-inspired mutation\n        mutation_mask = np.random.rand(*qubits.shape) < self.mutation_rate\n        qubits += mutation_mask * np.random.uniform(-self.alpha, self.alpha, qubits.shape)\n        return qubits\n\n    def adaptive_parameter_control(self, fitness):\n        # Adapt mutation and crossover rates based on diversity\n        diversity = np.std(fitness)\n        self.mutation_rate = max(0.01, min(0.5, self.mutation_rate + self.adaptation_rate * (0.1 - diversity)))\n        self.alpha = max(0.1, min(1.0, self.alpha + self.adaptation_rate * (0.1 - diversity)))\n\n    def __call__(self, func):\n        qubits = self.initialize_population()\n        population = self.measure_population(qubits)\n        fitness = self.evaluate_population(population, func)\n\n        while self.eval_count < self.budget:\n            new_qubits = []\n            self.adaptive_parameter_control(fitness)\n            for _ in range(self.population_size // 2):\n                if self.eval_count >= self.budget:\n                    break\n                child1, child2 = self.quantum_crossover(qubits)\n                child1 = self.quantum_mutation(child1)\n                child2 = self.quantum_mutation(child2)\n                new_qubits.extend([child1, child2])\n            \n            qubits = np.array(new_qubits[:self.population_size])\n            population = self.measure_population(qubits)\n            fitness = self.evaluate_population(population, func)\n\n        return population[np.argmin(fitness)]", "name": "AQIEA", "description": "Adaptive Quantum-Inspired Evolutionary Algorithm (AQIEA) that utilizes quantum-inspired representation and dynamic parameter adaptation to explore and exploit the solution space efficiently.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 14').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 14')", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {}, "mutation_prompt": null}
{"id": "dd9e3256-2e20-42f4-9ab5-aa1aecc8c640", "solution": "import numpy as np\n\nclass QuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.eval_count = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def quantum_operator(self, population):\n        new_population = []\n        for i in range(self.population_size):\n            quantum_disturbance = np.random.uniform(-1, 1, self.dim) * 0.05\n            new_sol = np.clip(population[i] + quantum_disturbance, self.lower_bound, self.upper_bound)\n            new_population.append(new_sol)\n        return np.array(new_population)\n\n    def mutate(self, population, best):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        x1, x2, x3 = population[indices]\n        mutant = x1 + self.mutation_factor * (x2 - x3)\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, population, fitness, trial, trial_fitness, idx):\n        if trial_fitness < fitness[idx]:\n            population[idx] = trial\n            fitness[idx] = trial_fitness\n\n    def adapt_population_size(self):\n        return max(5, int(self.population_size * (self.budget - self.eval_count) / self.budget))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self.mutate(population, best)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n                self.select(population, fitness, trial, trial_fitness, i)\n\n            if self.eval_count < self.budget:\n                population = self.quantum_operator(population)\n                fitness = self.evaluate_population(population, func)\n\n            self.population_size = self.adapt_population_size()\n\n        return population[np.argmin(fitness)]", "name": "QuantumDifferentialEvolution", "description": "Quantum-inspired differential evolution with adaptive population sizing to dynamically balance exploration and exploitation in black-box optimization.", "configspace": "", "generation": 3, "fitness": 0.22937149172618632, "feedback": "The algorithm QuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.47950575489386116, 0.4818819955713868, 0.5008438202787663, 0.48507763389509906, 0.47691878044267466, 0.4594990824953591, 0.48353650412382476, 0.5281367818385748, 0.46585607413908736, 0.07654317692925783, 0.04592464679039565, 0.05314617817248912, 0.0772363895855076, 0.07262168201991515, 0.049057472802630064, 0.05271956477326423, 0.0491451438830911, 0.06443836902248656, 0.13426559634772162, 0.11618024272145866, 0.15071320653976594, 0.13137963418047838, 0.07297121128698014, 0.13440943511222125, 0.15350503686464312, 0.1202081929954476, 0.10844397057319033, 0.11826755040618786, 0.12253884104121249, 0.11492410777538753, 0.11914959814780157, 0.027655773214705692, 0.12466497385662512, 0.12014278387734267, 0.12890042623402476, 0.12521202332645176, 0.990088570195715, 0.9525580819741187, 0.9454098308586149, 0.9590280947055934, 0.839371912891744, 0.7313325625457154, 0.8912661366059466, 0.7163447494613008, 0.9031830533280407, 0.272460547340987, 0.24728469655801233, 0.2777369899145101, 0.2821261693379825, 0.266902107843747, 0.28139479369117104, 0.25845998372959744, 0.2936440073356189, 0.2983517091983914, 0.27999977804065346, 0.3167390550412058, 0.29400158052875613, 0.739903319081886, 0.7513721883837008, 0.34934836510290246, 0.3378508328639753, 0.21521819812628695, 0.30901154033722233, 0.17066662762251816, 0.2009978876114381, 0.19366568385702032, 0.17224613949449008, 0.15405048853902537, 0.18335787217065447, 0.17437804283985292, 0.1766324538143328, 0.1959055407088811, 0.1528822200754959, 0.16746390491297913, 0.15364656953854827, 0.21198136413461532, 0.1608635179752348, 0.17309159408627806, 0.23006157285934692, 0.16334517756307454, 0.24298945272834083, 0.033501705818261174, 0.009302722142893072, 0.0011510762605350111, 0.0011561778214520535, 0.004468821207446627, 0.018168779624225695, 0.05570863726959596, 0.02516578064427344, 9.999999999998899e-05, 0.05765351936239316, 0.05689280964786181, 0.12854229963034447, 0.10367456722885948, 0.04339902136597973, 0.102524386631207, 0.07146366514709646, 0.12440926968390964, 0.1507614296564459, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023293799150376215, 9.999999999998899e-05, 9.999999999998899e-05, 0.1315986913157785, 0.11400236378313766, 0.10508221597702572, 0.11429129896137513, 0.1339795513235973, 0.12446177836590011, 0.11858627885215922, 0.10293961646810712, 0.10540260445076433, 0.4059797673504477, 0.44086327706575423, 0.4181181213759353, 0.4479479122549833, 0.42930806784058473, 0.4876357382669485, 0.4155077870581757, 0.41625794003000527, 0.4297333423067622, 0.1091198375397604, 0.12726820600922617, 0.12074116328917395, 0.10962934116446754, 0.10555914075630657, 0.10680087107716718, 0.11031629321997538, 0.13136179542135507, 0.10445896719225112, 0.20889061983220403, 0.19340482931891345, 0.20905352306018388, 0.17550709912457474, 0.218241160306617, 0.1768834832242845, 0.20720082411469987, 0.21739761641712796, 0.17840617514987533, 0.2842976193611547, 0.295626461114162, 0.29968098920511577, 0.2824593663997821, 0.3099853057230585, 0.2858694627229095, 0.30129188069482093, 0.2885417080684005, 0.32902035321132517, 0.20500647780389425, 0.26225389414743216, 0.23650531670613306, 0.24128966928485285, 0.2237658105489655, 0.21292886387336774, 0.26396227795819327, 0.24295281986218986, 0.24251702297000366, 0.19718134414574195, 0.18259564961398422, 0.19735665222328636, 0.21616448490629558, 0.17579420097302134, 0.19905607596412922, 0.1937816898578848, 0.187970177313193, 0.19035947937543474, 0.33647622997459137, 0.24091156881482945, 0.23948645300759153, 0.278495470370718, 0.23109988487973931, 0.23863762303129, 0.20153679060360608, 0.21524857484694138, 0.21242077429142192, 0.17116806414865182, 0.6544394303699835, 0.18427490036802419, 0.20540310660951022, 0.19906187576107115, 0.1735973497045985, 0.628251225901211, 0.16111158234231793, 0.15859640041790257, 0.614884691213589, 0.11205182973904138, 0.48380567227062143, 0.1675704442602136, 0.19408275216006687, 0.45745607809969535, 0.11186564678100808, 0.1029633534479415, 0.4966709520146614, 0.1879537081699455, 0.19197029908376673, 0.18438428452184175, 0.19371758810197004, 0.2031484144480562, 0.18257775423942146, 0.18664449437647157, 0.20004162041856688, 0.19514449659009492, 0.08163764245815108, 0.08972722831691315, 0.08677118845088294, 0.07584262941548581, 0.07878753012371598, 0.07757900169818244, 0.07947339350585914, 0.07342831264075755, 0.08731645756298889]}, "mutation_prompt": null}
{"id": "968e3b95-9711-4f74-af84-374cccff96a4", "solution": "import numpy as np\n\nclass NMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.w = 0.7  # Inertia weight\n        self.eval_count = 0\n        self.velocity_clamp = (self.lower_bound - self.upper_bound) * 0.2\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-abs(self.velocity_clamp), abs(self.velocity_clamp), (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        return positions, velocities, personal_best_positions\n\n    def evaluate_population(self, positions, func):\n        fitness = np.array([func(pos) for pos in positions])\n        self.eval_count += len(positions)\n        return fitness\n\n    def update_velocity(self, velocities, positions, personal_best_positions, global_best_position):\n        r1, r2 = np.random.rand(2, self.population_size, self.dim)\n        cognitive_velocity = self.c1 * r1 * (personal_best_positions - positions)\n        social_velocity = self.c2 * r2 * (global_best_position - positions)\n        new_velocities = self.w * velocities + cognitive_velocity + social_velocity\n        return np.clip(new_velocities, -self.velocity_clamp, self.velocity_clamp)\n\n    def update_position(self, positions, velocities):\n        new_positions = positions + velocities\n        return np.clip(new_positions, self.lower_bound, self.upper_bound)\n\n    def local_search(self, position, func):\n        epsilon = 0.05\n        neighbors = np.clip(position + epsilon * np.random.uniform(-1, 1, (5, self.dim)), self.lower_bound, self.upper_bound)\n        neighbor_fitness = self.evaluate_population(neighbors, func)\n        best_neighbor_idx = np.argmin(neighbor_fitness)\n        return neighbors[best_neighbor_idx], neighbor_fitness[best_neighbor_idx]\n\n    def __call__(self, func):\n        positions, velocities, personal_best_positions = self.initialize_population()\n        personal_best_fitness = self.evaluate_population(personal_best_positions, func)\n        global_best_idx = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_idx]\n\n        while self.eval_count < self.budget:\n            velocities = self.update_velocity(velocities, positions, personal_best_positions, global_best_position)\n            positions = self.update_position(positions, velocities)\n            fitness = self.evaluate_population(positions, func)\n\n            # Update personal bests\n            improved = fitness < personal_best_fitness\n            personal_best_positions[improved] = positions[improved]\n            personal_best_fitness[improved] = fitness[improved]\n\n            # Update global best\n            current_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_best_idx] < personal_best_fitness[global_best_idx]:\n                global_best_idx = current_best_idx\n                global_best_position = personal_best_positions[global_best_idx]\n\n            # Perform local search on the global best\n            if self.eval_count < self.budget:\n                improved_position, improved_fitness = self.local_search(global_best_position, func)\n                if improved_fitness < personal_best_fitness[global_best_idx]:\n                    personal_best_positions[global_best_idx] = improved_position\n                    personal_best_fitness[global_best_idx] = improved_fitness\n                    global_best_position = improved_position\n\n        return global_best_position", "name": "NMPSO", "description": "Novel Memetic Particle Swarm Optimization (NMPSO) combines particle swarm optimization with adaptive local search using historical velocity patterns to efficiently explore and exploit the search space.", "configspace": "", "generation": 4, "fitness": 0.11678215296383648, "feedback": "The algorithm NMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.12.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.4857696521399778, 0.4972086073984815, 0.4677462241006175, 0.06312612588946309, 0.43129595091969697, 0.493157067780844, 0.47324752177581053, 0.45730435160552674, 0.472431382192235, 9.999999999998899e-05, 0.012049638867436596, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03231661812495856, 9.999999999998899e-05, 0.019485471149578215, 0.03268244257295971, 0.034348774410067895, 0.0286613469890048, 0.004407223051266396, 0.006818730406106588, 0.0028014456572976743, 9.999999999998899e-05, 9.999999999998899e-05, 0.06274687053583117, 0.015743680889893752, 9.999999999998899e-05, 9.999999999998899e-05, 0.002989775869146838, 9.999999999998899e-05, 0.12210392088575939, 0.07288914148215375, 0.4936055591934728, 0.11817235419519911, 0.09157441387817822, 0.10009925251839125, 0.11084647140289339, 0.18445057686457667, 0.054022763513357885, 0.22373632123052312, 0.08880792206335153, 0.02317157691503302, 0.22062201259449143, 0.21722204612651907, 0.2878180155263105, 0.29148552063691435, 0.22499591496492055, 0.1525278307094744, 0.10081177885774972, 0.03775594762470191, 0.010869143322571828, 0.004562218041036625, 9.999999999998899e-05, 9.999999999998899e-05, 0.03999388526558045, 9.999999999998899e-05, 0.00990846602666351, 0.1936094572083299, 0.1335421602161403, 0.09037611106132504, 0.16758391478038992, 0.11156354369628552, 0.14595068419857193, 0.1813529279344499, 0.10860687804342761, 0.15528406718337795, 0.12406707447187293, 0.11388343058421346, 0.10405404023152709, 0.18139119773094248, 0.1499411824289475, 0.15148696138852125, 0.22447153521894148, 9.999999999998899e-05, 0.10956006453322098, 9.999999999998899e-05, 0.0006428531497904011, 0.0015838130644911796, 0.00026816881736302367, 0.0362021436906651, 0.008658012308906504, 9.999999999998899e-05, 9.999999999998899e-05, 0.00959027975664084, 0.03227466922613387, 0.026440987462786114, 0.06715544918510663, 0.06551642504184152, 9.999999999998899e-05, 0.009374542167639777, 9.999999999998899e-05, 0.022779892022284143, 0.023439954909704297, 0.0008762817452259153, 0.015768972860643937, 0.00701950260297779, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016050104822531885, 0.0022702987075208236, 0.022433448439649117, 0.057403999726545085, 0.06640036604392208, 0.12795147104364257, 0.0588733730815284, 0.08621404923086706, 0.01951672053451725, 0.0713104799835601, 0.11630138736621143, 0.07027508744709698, 0.4057471952771059, 0.3836550014718745, 0.43804007737391604, 0.36875176433955736, 0.38140740565187303, 0.3372558079414737, 0.4000277983333712, 0.3505698153515797, 0.4514818947070921, 0.017138107794157587, 0.0018992142502980425, 9.999999999998899e-05, 0.05099115658884823, 0.039364714028406134, 0.05112235883308691, 0.04659428325510995, 0.03366755658685083, 0.07299561610245242, 0.16193156664488884, 0.16053174777562473, 0.12872945245625755, 0.15600426565783165, 0.1489859013117273, 0.13389916326360685, 0.15518593140602166, 0.12811553972177203, 0.11306604826360855, 0.11250709319665397, 0.12683172685873256, 0.11731743074634582, 0.1376942897382729, 0.1514847968287364, 0.1313417425257356, 0.1388292014746737, 0.12791027094909257, 0.10299101591622606, 0.05992267070713875, 0.0677915689859776, 0.07405707589038191, 0.08293562960167145, 0.1125260211460305, 0.0728239870907037, 0.07023870954903455, 0.09142279253576302, 0.05136670652995834, 0.19189889661689918, 0.15302050621664243, 0.1414288654835869, 0.1149272279100938, 0.12270213456718904, 0.15390907302456924, 0.17358233265929868, 0.1466179076192704, 0.14851681581050524, 0.14684929028624705, 0.15422797717609027, 0.159631628524892, 0.20306237589205456, 0.17288932831290094, 0.17450701903745536, 0.15780278214493615, 0.15551942886972103, 0.12978736582080597, 0.10330907577861015, 0.1349299028157691, 0.15193991152072484, 0.12009072177929825, 0.19980190278793275, 0.1653031597498602, 0.12517934245634676, 0.11163236933602771, 0.10190960460475451, 0.11208234366289327, 0.11336610793483537, 0.050062713035901485, 0.30707945960204486, 0.05231315226730693, 0.19121465878460753, 0.10265097731576844, 0.05660505479354416, 0.2795674635181197, 0.17103956088124483, 0.18720073027570994, 0.1651061514727724, 0.19975817925984807, 0.19622501559816408, 0.18150623947538247, 0.17963859127386717, 0.15792021890786712, 0.21606114145440802, 0.05116933162971182, 0.026432230062110262, 0.06082095062121029, 0.04082736435492629, 0.052250921013584084, 0.04340157914464127, 0.0745645192565928, 0.09243045113805115, 0.031010950475255927]}, "mutation_prompt": null}
{"id": "bb789850-14d8-4883-ba7b-88c52ea6c754", "solution": "import numpy as np\n\nclass QuantumInspiredES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)\n        self.eval_count = 0\n        self.quantum_register = np.pi * np.random.rand(self.population_size, self.dim)\n        self.sigma = 0.1\n        self.learning_rate = 0.9\n\n    def decode(self):\n        # Quantum superposition to real values\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * (np.sin(self.quantum_register) ** 2)\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def update_quantum_register(self, population, best, best_fitness):\n        for i in range(self.population_size):\n            delta = self.learning_rate * (population[i] - best)\n            delta = np.clip(delta, -self.sigma, self.sigma)\n            self.quantum_register[i] += delta * (1 if np.random.rand() > 0.5 else -1)\n            self.quantum_register[i] = np.mod(self.quantum_register[i], np.pi)\n\n    def __call__(self, func):\n        best = None\n        best_fitness = float('inf')\n\n        while self.eval_count < self.budget:\n            population = self.decode()\n            fitness = self.evaluate_population(population, func)\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best = population[current_best_idx]\n\n            self.update_quantum_register(population, best, best_fitness)\n\n            if self.eval_count + self.population_size > self.budget:\n                break\n\n        return best", "name": "QuantumInspiredES", "description": "Quantum-inspired Evolutionary Strategy (QES) that leverages quantum superposition for diverse solution representation and adaptive learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 5, "fitness": 0.10293207167221083, "feedback": "The algorithm QuantumInspiredES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.08.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.24611267580962903, 0.2464454067926981, 0.22515801835392346, 0.2459030998966395, 0.2082249038416939, 0.2126726176973579, 0.229972264797899, 0.20624004074742974, 0.2733935855613563, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05427799636522557, 0.02549092646883966, 0.04276225974550907, 0.06400088301345785, 0.05507861924920654, 0.03504996999025756, 0.041064726104883986, 0.04543252239016815, 0.027379297264711555, 0.05182803517795853, 0.04559139406852186, 0.045920361329068515, 0.0315820672436703, 0.030189107083673283, 0.03779511757836662, 0.051115900937023784, 0.02624619871545053, 0.029769564575200635, 0.24464601409268893, 0.15540624070764208, 0.2472373060854668, 0.20087611669038075, 0.22589112861247695, 0.23796338535587047, 0.24088891536255352, 0.1661705090813742, 0.16954612814444658, 0.10349347655518837, 0.10474004353500455, 0.07395976693056505, 0.1302292881742767, 0.10240801109253261, 0.09210374028337409, 0.07487930586620517, 0.08412009856943992, 0.09825192576210429, 0.11216162527875473, 0.1315528456223516, 0.11810354436641646, 0.14788003575128916, 0.1252342857959604, 0.15834649287932934, 0.12931586002094209, 0.1784285688037749, 0.1360777342398154, 0.03328893636055108, 0.029564540171034603, 0.011434379433959974, 0.05682714248414289, 0.03358713362931143, 0.026447036629117404, 0.052816516260971724, 0.04081153602079446, 0.057900297545444346, 0.03372096085251619, 0.07861364192583209, 0.04108089398348225, 0.03796001107698688, 0.06139001558357815, 0.0490949254645906, 0.0078234274356771, 0.04367534792889105, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07189145653464712, 0.049054656406640085, 0.0029726648951614587, 0.006384412604881096, 0.008510984823036916, 0.0456627685904869, 0.03550832048100072, 0.014099420340585311, 0.039137984230278144, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00620817543636254, 0.0, 0.013321885868633587, 0.02235566748758644, 0.0, 0.0078145978416031, 0.003113646971347417, 0.01110726762979175, 0.25403409199511107, 0.23841495669073542, 0.23779298969350715, 0.2678013249333919, 0.2531008470774253, 0.23318867594753767, 0.23748761578656719, 0.22648696419892644, 0.24195341385322122, 0.07622743372791407, 0.06794358359935082, 0.041157404931718156, 0.05816660034619947, 0.032079949397966434, 0.04474947482428926, 0.04036881747961485, 0.04330750479979817, 0.03708100246012924, 0.1347347749804343, 0.13987209772891807, 0.16436407272870623, 0.1487041446372117, 0.11756278451907454, 0.13071702457504708, 0.13482220151720625, 0.11830974714224463, 0.13921015573877393, 0.2133477933061988, 0.16366628237794634, 0.2053618208203848, 0.1581811538582235, 0.19771960506488484, 0.17500731878019338, 0.1917326632336802, 0.15154204278528227, 0.15796894358952163, 0.14327668426147389, 0.0992003311873566, 0.1260109585676895, 0.1512511087219951, 0.11245176263188494, 0.14265267873264242, 0.10107012372776647, 0.12140395699610784, 0.11261603076834659, 0.13535457201177903, 0.1498542627603352, 0.13485626571158738, 0.17100208304460118, 0.1630670131132016, 0.17844414378062434, 0.18734108329385513, 0.162427035317682, 0.15254264897685166, 0.1552589890524203, 0.14819371474878695, 0.14106283887609583, 0.14857699173749772, 0.14333682513062174, 0.14740123616166256, 0.14813677058648222, 0.1343612608987601, 0.14483197719976726, 0.1583576775263411, 0.1354137729633803, 0.11938526875070599, 0.15652403813202143, 0.14827389677270753, 0.15404296478205837, 0.22094442047632779, 0.12152806140263606, 0.1778194549419817, 0.15203116342092493, 0.13848327865748455, 0.21679424802290637, 0.1476951366515875, 0.15373909214327997, 0.20847437774416988, 0.25636933291521213, 0.11372242623509987, 0.16262409497450847, 0.18286735263744835, 0.18394914533723694, 0.17893682170472225, 0.18533256376969842, 0.17889495603255068, 0.20051135050499513, 0.1684967693651961, 0.18449096728216907, 0.17718735055821688, 0.04464608782379342, 0.05047310858804199, 0.05159823583542844, 0.04824690138603416, 0.04567199818239931, 0.04384627287110221, 0.060125790973393656, 0.06321659179011163, 0.0546712755274843]}, "mutation_prompt": null}
{"id": "f7d1fd31-7701-4bd2-aa40-d7ccfc292507", "solution": "import numpy as np\n\nclass AdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = max(10, 5 * dim)  # Larger swarm for better coverage\n        self.eval_count = 0\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.neighborhood_size = 3  # Dynamic neighborhood size\n        self.local_search_prob = 0.1  # Probability of local restarts\n\n    def initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        return positions, velocities\n\n    def evaluate_swarm(self, positions, func):\n        fitness = np.array([func(pos) for pos in positions])\n        self.eval_count += len(positions)\n        return fitness\n\n    def update_velocity(self, velocities, positions, personal_best_pos, global_best_pos):\n        r1, r2 = np.random.rand(2, self.swarm_size, self.dim)\n        cognitive = self.cognitive_coeff * r1 * (personal_best_pos - positions)\n        social = self.social_coeff * r2 * (global_best_pos - positions)\n        velocities = self.inertia_weight * velocities + cognitive + social\n        return np.clip(velocities, -5, 5)\n\n    def local_random_restart(self, positions, personal_best_pos):\n        random_restart = np.random.rand(self.swarm_size) < self.local_search_prob\n        new_positions = np.where(random_restart[:, np.newaxis], np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim)), positions)\n        return np.where(random_restart[:, np.newaxis], new_positions, personal_best_pos)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_swarm()\n        fitness = self.evaluate_swarm(positions, func)\n        personal_best_pos = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_idx = np.argmin(fitness)\n        global_best_pos = positions[global_best_idx]\n\n        while self.eval_count < self.budget:\n            velocities = self.update_velocity(velocities, positions, personal_best_pos, global_best_pos)\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            fitness = self.evaluate_swarm(positions, func)\n            \n            # Update personal bests\n            improved_mask = fitness < personal_best_fitness\n            personal_best_pos[improved_mask] = positions[improved_mask]\n            personal_best_fitness[improved_mask] = fitness[improved_mask]\n\n            # Update global best\n            current_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[current_best_idx] < personal_best_fitness[global_best_idx]:\n                global_best_idx = current_best_idx\n                global_best_pos = personal_best_pos[global_best_idx]\n\n            # Local random restarts for diversity\n            positions = self.local_random_restart(positions, personal_best_pos)\n\n        return global_best_pos", "name": "AdaptivePSO", "description": "An adaptive particle swarm optimizer with dynamic neighborhood topology and local random restarts to efficiently navigate the search space and avoid premature convergence.", "configspace": "", "generation": 6, "fitness": 0.18028477829438241, "feedback": "The algorithm AdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.4294871587377491, 0.44601831799805636, 0.36599018158772323, 0.2846835424227806, 0.32472653592271394, 0.4167479621267435, 0.3431423539274773, 0.39573161822752356, 0.3793557396872915, 0.09143267980391756, 9.999999999998899e-05, 9.999999999998899e-05, 0.0445792527242338, 0.021981711277416105, 0.10641133705645256, 0.014932060223696642, 0.05071242877616311, 0.0020409897593334225, 0.0707521944743521, 0.0760823891838247, 0.08053853216048923, 0.07144378490167858, 0.05428120277516668, 0.05573629549129033, 0.05689936403253415, 0.0639445132825387, 0.08000985420512174, 0.06451867662755739, 0.05408833833448912, 0.0612190029023304, 0.06482121628853199, 0.08617663879545745, 0.04493591402601227, 0.03519611276816215, 0.06279169981727628, 0.052284367820097266, 0.9915661134337452, 0.9928981063837751, 0.9888423095507851, 0.9863346725281759, 0.989838760390228, 0.985581614765628, 0.9885943990296975, 0.98833335774708, 0.9891642900285513, 0.09637577572720624, 0.08214364200297186, 0.08954268826854783, 0.13392549556245814, 0.12381422920267504, 0.1495766414194586, 0.10563007562574622, 0.09947592507327263, 0.12224222204857127, 0.3257148398385983, 0.24567857706839857, 0.1951886056556389, 0.17464012013723063, 0.1865410542666347, 0.18677811515963316, 0.12201346182798023, 0.24777039846281623, 0.21621800277985948, 0.04128769095125229, 0.13264346937183835, 0.0624292323844573, 0.09083917023014332, 0.11042344548694272, 0.06362065667762506, 0.10072995007037844, 0.1502831234377764, 0.06929806652121329, 0.14981790455618715, 0.11797522575988584, 0.1281544732088421, 0.12093670566770398, 0.1301987260686972, 0.1402488859465124, 0.13739636620430606, 0.08345691080589945, 0.06122319249806896, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011999675611886751, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04175157909600935, 0.04200057223941345, 0.07701043125388385, 0.04876387044426378, 0.07338975017319682, 0.02024695267869825, 0.05843114853357023, 0.08227276091136848, 0.07945877707759952, 0.0015951986096585102, 9.999999999998899e-05, 9.999999999998899e-05, 0.006502618852147868, 0.04227397207234829, 0.002467335947790139, 9.999999999998899e-05, 0.001199544554657761, 0.008293982869337357, 0.09433272345049792, 0.06884925081931559, 0.036086209263206714, 0.004197773445101527, 0.003471109409498019, 0.02958625463122222, 0.0672446227951663, 0.08304464879321583, 0.07798897359602575, 0.3776137082001193, 0.34983933633234565, 0.3138309736569862, 0.33721081507163286, 0.3493821776458017, 0.35014735618661474, 0.3202050708855486, 0.33844009021466004, 0.4189934366250634, 0.06758249334347821, 0.053497805337791915, 0.07076691364378729, 0.05519508129803541, 0.061317168124311094, 0.08114575639634625, 0.05961769148797158, 0.06561695876142071, 0.08956892472095224, 0.19143863241134007, 0.13369849220446117, 0.15007013786486167, 0.21883547044194396, 0.16096039629868697, 0.18928022105143216, 0.1514080915454613, 0.13990887201657132, 0.1553675491709008, 0.17877120090562382, 0.21261417610635114, 0.26349717072789813, 0.24693393369279182, 0.18443268515448152, 0.24109791637666989, 0.21135440259196747, 0.2643057693715605, 0.2017177516174422, 0.14603833324776605, 0.1033076370566901, 0.16632996362918306, 0.17174022773504172, 0.1647655978739393, 0.1837779545013093, 0.16704434286024594, 0.20943582314011644, 0.1322323120339446, 0.19072013374822971, 0.17799637829500592, 0.22542301684480337, 0.18161632247808634, 0.2113538230587172, 0.17182001025198046, 0.16813270913227374, 0.16697748233699372, 0.20753104499591513, 0.16920698332097095, 0.20119327245941354, 0.16664909271903905, 0.18371992630640566, 0.2036775605816984, 0.16395191072616366, 0.17771619086115265, 0.17492257186082827, 0.16944135844677288, 0.40862034132483793, 0.16092757677259883, 0.15448655095920172, 0.5908291126348135, 0.19040789547758563, 0.1917142024532198, 0.12335661297905276, 0.13682564786788076, 0.6309550949496681, 0.12956081373895123, 0.42128722908800675, 0.10512520307566997, 0.4661269139276858, 0.3192392785895146, 0.2099489332121809, 0.1725531323173769, 0.2818708392092283, 0.3469623480210211, 0.1928699135376677, 0.19452735972109148, 0.1886718517912408, 0.195625226639643, 0.19322750938654987, 0.18694470781772266, 0.17849893467499056, 0.18235983169733327, 0.20216668836997398, 0.0764104523331216, 0.06527868227096367, 0.06535735723967717, 0.06584428119906827, 0.053718197033266746, 0.06747873076038635, 0.0579058133633773, 0.051834547574260204, 0.05676729648342094]}, "mutation_prompt": null}
{"id": "df651f6c-bacb-4004-933c-14cfad04fffd", "solution": "import numpy as np\n\nclass AQEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 4 * dim)\n        self.eval_count = 0\n        self.alpha = 0.6  # Probability amplitude\n        \n    def initialize_population(self):\n        # Quantum-inspired initialization (superposition)\n        real_part = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        imaginary_part = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        return real_part, imaginary_part\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def quantum_crossover(self, real_part, imaginary_part):\n        # Quantum-inspired crossover: combining real and imaginary parts\n        new_real = self.alpha * real_part + (1 - self.alpha) * imaginary_part\n        new_imaginary = self.alpha * imaginary_part + (1 - self.alpha) * real_part\n        return new_real, new_imaginary\n\n    def adaptive_mutation(self, real_part, imaginary_part, best_idx):\n        # Adaptive mutation based on the best individual\n        mutation_rate = max(0.1, 1.0 - (self.eval_count / self.budget))\n        best_real = real_part[best_idx]\n        best_imaginary = imaginary_part[best_idx]\n        real_mutation = np.random.uniform(-mutation_rate, mutation_rate, (self.population_size, self.dim))\n        imaginary_mutation = np.random.uniform(-mutation_rate, mutation_rate, (self.population_size, self.dim))\n        new_real = np.clip(best_real + real_mutation, self.lower_bound, self.upper_bound)\n        new_imaginary = np.clip(best_imaginary + imaginary_mutation, self.lower_bound, self.upper_bound)\n        return new_real, new_imaginary\n\n    def __call__(self, func):\n        real_part, imaginary_part = self.initialize_population()\n        composite_population = real_part + 1j * imaginary_part\n        population = np.real(composite_population)\n        fitness = self.evaluate_population(population, func)\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(fitness)\n            real_part, imaginary_part = self.quantum_crossover(real_part, imaginary_part)\n\n            # Perform adaptive mutation\n            real_part, imaginary_part = self.adaptive_mutation(real_part, imaginary_part, best_idx)\n            composite_population = real_part + 1j * imaginary_part\n            population = np.real(composite_population)\n            \n            new_fitness = self.evaluate_population(population, func)\n            if np.min(new_fitness) < np.min(fitness):\n                fitness = new_fitness\n        \n        return population[np.argmin(fitness)]", "name": "AQEA", "description": "Adaptive Quantum-inspired Evolutionary Algorithm (AQEA) utilizing quantum-inspired superposition principles and adaptive mutation to efficiently explore complex search spaces.", "configspace": "", "generation": 7, "fitness": 0.09115529275498996, "feedback": "The algorithm AQEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.2031553969688743, 0.2913788697349472, 0.20148670418314063, 0.08952233024927114, 0.25099272248742754, 0.23986582433085546, 0.276865511600383, 0.24437152786585836, 0.2429104786972529, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06834137223514702, 0.06245344754573612, 0.014493698409800193, 0.032275410353435285, 0.04070960489902975, 0.07768264809979863, 0.02103842897004049, 0.07506346014242027, 0.013060273876075335, 0.0380496824263542, 0.027042062237011888, 0.009704479533580335, 0.034128916021416766, 0.04547853187582185, 0.001847659380023292, 0.04582721137083767, 0.06968995678870937, 0.04818088279594035, 0.045179741609489454, 0.08651883854399789, 0.07951774413879242, 0.053340261193588256, 0.07077894192147272, 0.04927106489742983, 0.0638860334912611, 0.0816648637175007, 0.04556109250434326, 9.999999999998899e-05, 0.10581380258497064, 0.049167985835212535, 9.999999999998899e-05, 0.024404875068057663, 0.15046301421232178, 0.09329249301434717, 0.011293333694524565, 0.13307730731647205, 0.18661196861958884, 0.08160107328488553, 0.09325283358044378, 0.018801691869045456, 0.1032357883420556, 0.17735380294577685, 0.03542593692693885, 0.13210408943751317, 0.16174805772977963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04043859870953326, 0.02482526363955162, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035273868361508365, 0.05970772692099613, 0.017807370792359722, 0.002838789195068192, 0.006434114156098292, 0.017511682991170896, 0.07646373795111772, 0.0777081008641628, 9.999999999998899e-05, 0.010088350828317383, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0765807463024244, 0.02707324422377111, 0.05191201836808035, 0.08506240899095974, 0.02430129811218429, 0.04137561162730874, 0.09449977549201272, 0.04786191563182496, 0.056121194588253265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023310248595764138, 0.0012728458475262938, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20971791478276602, 0.23451400946510037, 0.2304532210999476, 0.21275795336590675, 0.30757290734750387, 0.24584496435205339, 0.2971497383777829, 0.2660421238119469, 0.22861682442811548, 0.06101462245549505, 9.999999999998899e-05, 9.999999999998899e-05, 0.006101769545772684, 0.028755193151747016, 0.056695924331731096, 0.0357243881379079, 0.05689892629636728, 0.05396957579415118, 0.1523085574817582, 0.1275375837729542, 0.13537985762890747, 0.12427795191326463, 0.13331855306325346, 0.15222019110247786, 0.13721340996010167, 0.12963079907815822, 0.18918478840688535, 0.19455154145494258, 0.11308351733136313, 0.19876632397101635, 0.14085788440356262, 0.19224321353493068, 0.1860244552389011, 0.18562095221227815, 0.17377774300845283, 0.1237266570573804, 0.11904664029735612, 0.05464960799938656, 0.08730488202866271, 0.13327921481702654, 0.09937357270862335, 0.0851063076055758, 0.10655465034511358, 0.09386031173166853, 0.12365611128846776, 0.15900950192671703, 0.1633788513079435, 0.174657554988079, 0.20977445234582548, 0.20119613231039946, 0.15510102294127115, 0.14300472487555382, 0.1827656365337118, 0.1876799636055555, 0.14725063644857905, 0.17760278432834398, 0.16508978235460436, 0.16804126542790987, 0.17634698724972642, 0.1720829249443352, 0.15629860211050584, 0.11548476628267468, 9.999999999998899e-05, 0.16689905730650212, 0.14338363523116038, 0.11480421055895007, 0.14049626113759972, 0.16597184879032933, 0.17096413315784853, 0.13470996353617826, 0.13774901128516226, 0.13238846482246536, 0.11583387976275772, 0.17844405898760485, 0.06762593261468097, 0.2650661131029258, 0.14395451527648329, 0.045511073114331335, 0.04690376827171172, 0.3173289454871213, 0.14149840678346248, 0.1892076414765116, 0.19082625937367104, 0.19798133926736816, 0.17735321491604972, 0.2427908296737049, 0.1997915675875529, 0.20536342801360796, 0.18249876388914787, 0.19744769665087414, 0.04217224377256967, 0.044874748228747596, 0.050923593529867084, 0.06472108516645114, 0.06105463503255182, 0.042617051541250284, 0.05166231991183545, 0.03314317409456469, 0.036123277332093306]}, "mutation_prompt": null}
{"id": "6d3d3355-58e5-44f9-81d1-4349975d453b", "solution": "import numpy as np\n\nclass AGPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = max(10, 5 * dim)  # Larger swarm for diversity\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.eval_count = 0\n\n    def initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        return positions, velocities\n\n    def evaluate_swarm(self, positions, func):\n        fitness = np.array([func(pos) for pos in positions])\n        self.eval_count += len(positions)\n        return fitness\n\n    def update_velocity(self, velocities, positions, personal_best_positions, global_best_position):\n        r1 = np.random.rand(self.swarm_size, self.dim)\n        r2 = np.random.rand(self.swarm_size, self.dim)\n        velocities = (self.inertia_weight * velocities +\n                      self.cognitive_coeff * r1 * (personal_best_positions - positions) +\n                      self.social_coeff * r2 * (global_best_position - positions))\n        return velocities\n\n    def update_position(self, positions, velocities):\n        new_positions = positions + velocities\n        return np.clip(new_positions, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_swarm()\n        fitness = self.evaluate_swarm(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n\n        global_best_position = positions[np.argmin(fitness)]\n        global_best_fitness = np.min(fitness)\n\n        while self.eval_count < self.budget:\n            velocities = self.update_velocity(velocities, positions, personal_best_positions, global_best_position)\n            positions = self.update_position(positions, velocities)\n            \n            fitness = self.evaluate_swarm(positions, func)\n\n            # Update personal bests\n            better_mask = fitness < personal_best_fitness\n            personal_best_positions[better_mask] = positions[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n\n            # Update global best\n            min_fitness_idx = np.argmin(fitness)\n            if fitness[min_fitness_idx] < global_best_fitness:\n                global_best_fitness = fitness[min_fitness_idx]\n                global_best_position = positions[min_fitness_idx]\n\n        return global_best_position", "name": "AGPSO", "description": "Adaptive Greedy Particle Swarm Optimization (AGPSO) utilizing a combination of adaptive velocity update and greedy selection with dynamic adjustments for robust performance across diverse problem landscapes.", "configspace": "", "generation": 8, "fitness": 0.3036469126218205, "feedback": "The algorithm AGPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.29.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.8917451391603342, 0.8982210781915289, 0.9035975826789396, 0.9126429155015131, 0.9022600392531457, 0.9074782357466021, 0.903567278747854, 0.9047126180818086, 0.8936061571695614, 0.7413092209731522, 0.714099779289144, 0.7288033355325179, 0.7332260870273845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.7375007581603159, 0.018532300807625468, 0.12246273067456781, 0.18217668508029428, 0.07647770179941293, 0.15185844415106697, 0.17154414083388714, 0.09893010874998986, 0.1625206307838889, 0.1323363583281354, 0.14731084789284143, 0.1885496413074147, 0.15916420606861537, 0.10910613217399134, 0.1021956048518452, 0.14103880564311766, 0.11628600090299313, 0.13842499580104373, 0.11630039891104393, 0.18261912827090054, 0.991774499961799, 0.9931454552934235, 0.9908104012019162, 0.9898552155871102, 0.9881873763901825, 0.9843012317125479, 0.989351714114303, 0.9881874043940369, 0.9922754229239961, 0.7198755705677168, 0.6581660152438135, 0.7328170473415399, 0.7798615650113696, 0.7864997080022195, 0.636447420463911, 0.1265325767888329, 0.08899482972415318, 0.727527965677584, 0.21211686700017252, 0.23862846308224317, 0.17127447855778521, 0.7676102661955573, 0.18369635327943756, 0.2790053206253654, 0.22390005883249908, 0.12502531970227881, 0.24625474724601404, 0.23395075427019585, 0.13285703071609645, 0.22241859540964237, 0.21738904066463105, 0.23168592124126097, 0.22069001022700585, 0.2240565103391543, 0.11319728859868339, 0.1349149083206279, 0.20613172984285022, 9.999999999998899e-05, 0.23347313772954126, 0.2145632989840841, 0.25972396723424374, 0.26944372911890224, 0.2695394743068569, 9.999999999998899e-05, 0.13473422854738715, 0.05856423627103591, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08475951952060912, 0.05826450256064197, 0.020174621958673367, 0.12168233974108045, 0.03358871349384995, 0.045531219958344304, 0.0453752383718673, 0.11277634499426126, 0.16181076080888201, 0.0413544338451195, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0938017611943085, 0.07855145223010129, 0.147502939253084, 0.09893358218016568, 0.20726515249329935, 0.07441242140744908, 0.26152227128270666, 0.10731705897705701, 0.10189384198379414, 0.006770621007400224, 0.006533857459863013, 0.039629157410759785, 0.11085992029656189, 0.08431040954493951, 0.08428494938955122, 0.5342682841034305, 0.56250321827399, 0.525429422466925, 0.5583714516335807, 0.56416717538532, 0.20918151274738617, 0.6468523968170488, 0.5792361453311359, 0.550129953764396, 0.09459828430174255, 0.09230933110250317, 0.07992975367183641, 0.13294218297349414, 0.11969407024632528, 0.1086834497304493, 0.07005019695010706, 0.10571741506345167, 0.13144990143353275, 0.21031301219672283, 0.19684566045124308, 0.18855778449028837, 0.22462762982952156, 0.41548283316716494, 0.33078830061101094, 0.20390120357771468, 0.17648885309451157, 0.21142797013265968, 0.3004330739100225, 0.35291281009729647, 0.3740302181235462, 0.3329750472176356, 0.22228726347310002, 0.3387792785128175, 0.5727685758497736, 0.7226569807449428, 0.3770027140754475, 0.32189946922149615, 0.24637558809972082, 0.35605465884806176, 0.24333684673474676, 0.19330772808518681, 0.22838842855990305, 0.30941048899726253, 0.2685350131045062, 0.2639849879630827, 0.2610618434891542, 0.21165949165544018, 0.19824814099447452, 0.21174740319508667, 0.20255432054648204, 0.21875663748174312, 0.20755253422754238, 0.26249149810672967, 0.23284072466289374, 0.21672379780652928, 0.8099681155071059, 0.19857315532380693, 0.6750465770724179, 0.2219646716896888, 0.20244861599793507, 0.22573148171934487, 0.25171905258414795, 0.20821168588572603, 0.9321488584215243, 0.18255681122982947, 0.15465123843471718, 0.9384283710564231, 0.20140701354472312, 0.20096559821061677, 0.18209595997988248, 0.1708162936231482, 0.9335595675956342, 0.08269782892911304, 0.15741652629317193, 0.11056075747502636, 0.683042797356992, 0.7078151227059906, 0.21354436821396028, 0.10414661456917507, 0.8117300693092421, 0.7688726402752857, 0.20809688662887826, 0.19163588892431793, 0.205291055974964, 0.19459546079317003, 0.19351707986567568, 0.19470437067786894, 0.19495794559129798, 0.22738622612332304, 0.22248348337392265, 0.10590566249660571, 0.0944898863513095, 0.09042337810175416, 0.10666677635884547, 0.08491605394227886, 0.08093879309908825, 0.10082548740441666, 0.08934668543219904, 0.08823991818171784]}, "mutation_prompt": null}
{"id": "7e637d95-e57e-4521-9e37-c1443c2af991", "solution": "import numpy as np\n\nclass AMPSADC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.eval_count = 0\n        self.num_populations = 3\n        self.population_size = max(5, 2 * dim)\n        self.initial_temp = 1.0\n        self.final_temp = 0.01\n        self.cooling_rate = 0.95\n\n    def initialize_populations(self):\n        return [np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for _ in range(self.num_populations)]\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def perturb(self, individual, temperature):\n        noise = np.random.normal(scale=temperature, size=self.dim)\n        candidate = np.clip(individual + noise, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def acceptance_probability(self, candidate_fitness, current_fitness, temperature):\n        if candidate_fitness < current_fitness:\n            return 1.0\n        else:\n            return np.exp((current_fitness - candidate_fitness) / temperature)\n\n    def adaptive_cooling(self, temperature, improvement):\n        if improvement:\n            return max(self.final_temp, temperature * self.cooling_rate)\n        else:\n            return min(1.0, temperature / self.cooling_rate)\n\n    def __call__(self, func):\n        populations = self.initialize_populations()\n        temperature = self.initial_temp\n        best_solutions = [None] * self.num_populations\n        best_fitness = [float('inf')] * self.num_populations\n\n        while self.eval_count < self.budget:\n            for p in range(self.num_populations):\n                population = populations[p]\n                fitness = self.evaluate_population(population, func)\n                for i in range(self.population_size):\n                    if self.eval_count >= self.budget:\n                        break\n                    current_individual = population[i]\n                    candidate = self.perturb(current_individual, temperature)\n                    candidate_fitness = func(candidate)\n                    self.eval_count += 1\n\n                    ap = self.acceptance_probability(candidate_fitness, fitness[i], temperature)\n                    if np.random.rand() < ap:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n\n                best_idx = np.argmin(fitness)\n                if fitness[best_idx] < best_fitness[p]:\n                    best_solutions[p] = population[best_idx]\n                    best_fitness[p] = fitness[best_idx]\n                    temperature = self.adaptive_cooling(temperature, improvement=True)\n                else:\n                    temperature = self.adaptive_cooling(temperature, improvement=False)\n\n            # Migrate best solutions across populations\n            best_solution = min(best_solutions, key=lambda s: func(s))\n            for p in range(self.num_populations):\n                populations[p][np.random.randint(self.population_size)] = best_solution\n\n        best_overall = min(best_solutions, key=lambda s: func(s))\n        return best_overall", "name": "AMPSADC", "description": "Adaptive Multi-Population Simulated Annealing with Dynamic Cooling (AMP-SADC) leverages multiple interacting populations and adaptive cooling schedules to enhance exploration and exploitation in solving black box optimization problems.", "configspace": "", "generation": 9, "fitness": 0.14882203408046202, "feedback": "The algorithm AMPSADC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.15.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.2716520266818362, 0.2978638120048921, 0.313208911869748, 0.28960312952511447, 0.26685699797437734, 0.3033895803422383, 0.33014329278192966, 0.2836785925096307, 0.33402121585336786, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011573986871554198, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08455740184869354, 0.06968205771910907, 0.08062812550732557, 0.06856987964571204, 0.07760702117430485, 0.06316984829624128, 0.08478372724952421, 0.07636455810596776, 0.07310338360003754, 0.06015255875031911, 0.06633950910997866, 0.06302599805369302, 0.062210020122190124, 0.07689220894549631, 0.05699889820889292, 0.054230435956894474, 0.06149699379516915, 0.05404185387713112, 0.43482228130272793, 0.8514045124064226, 0.8517664483953244, 0.7989064514992683, 0.1315768448237402, 0.8135978342936092, 0.775592301515335, 0.7351858737690524, 0.6418935253588904, 0.16905591475900583, 0.27129641218441136, 0.09681863560371495, 0.161626169108401, 0.16246582647833352, 0.16226111386375375, 0.07215849691114617, 0.18953533361932795, 0.2557585874169992, 0.2118330104755488, 0.2652937646294645, 0.20296946065543153, 0.2035507991539255, 0.20028766951158528, 0.21900961100186478, 0.1788943687250728, 0.19142713035430492, 0.19407004218043344, 0.0818581475374609, 0.10734423734459175, 0.13283438494882516, 0.11457543488328814, 0.08646720328778068, 0.08548843969255215, 0.07209025975464789, 0.07044677533152044, 0.11461939465715443, 0.06164346812714816, 0.023726197689929673, 0.0817320332629059, 0.08494529263045547, 0.03446568976504483, 0.06967076633776526, 0.10107637562715521, 9.999999999998899e-05, 0.06865485988509212, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07648261005981949, 0.08704149158984475, 0.05630476785757965, 0.04543329861777745, 0.014994424453369404, 0.02912282054237314, 0.10336858036450847, 0.08098591265018984, 0.0705988907543873, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020542487340872495, 0.02571331243975583, 0.023051538830424767, 0.00020783790757450404, 0.019039620791315937, 0.030628007316952477, 0.049937705491451045, 0.03123447391119827, 0.035907208827974824, 0.25859479796851415, 0.2841830475687712, 0.2786910631406817, 0.3041496155617096, 0.2936373871770561, 0.2973178586419679, 0.2845639286116102, 0.31287146488752193, 0.277235766978026, 0.07575971927416958, 0.07949868493290013, 0.08032614868459187, 0.09198732638133422, 0.0733525198545012, 0.07141356250455932, 0.06888145631084641, 0.0736691200857571, 0.06029720730536792, 0.12832285572329927, 0.12907331374762687, 0.12633715103370924, 0.1687468056592072, 0.12982997027303467, 0.1313044623416808, 0.13938987370274336, 0.14018762209820523, 0.14007775289175806, 0.2174092075704912, 0.28005790802117336, 0.21667802947929515, 0.2016475006498012, 0.20691218709978265, 0.1889379756843549, 0.20366201459867395, 0.1968273068805152, 0.21253476239931202, 0.14664719051223019, 0.1449011587580048, 0.1544605569379759, 0.13826055751620003, 0.14915287636886365, 0.15054956289825694, 0.14663882259598737, 0.15564401787806403, 0.13511930303117736, 0.20164760763543876, 0.15949016195267196, 0.19581486055010155, 0.16790630965607545, 0.19039977592652624, 0.16749285863482344, 0.19624983350489622, 0.19148397831908293, 0.19762590382004896, 0.16455290128062383, 0.16174597270540747, 0.17226880421146817, 0.1648659110752556, 0.1724720346941735, 0.1607476491204115, 0.164378044165032, 0.1649610443429328, 0.16848700649150028, 0.17843502062830996, 0.12175306609633885, 0.1512946299511515, 0.329994143238994, 0.17443060665462562, 0.16819751610285472, 0.16945088483729775, 0.16813168456298755, 0.32120669080266306, 0.29773705546154483, 0.15323661693957724, 0.1084690040808508, 0.1416755644829678, 0.16285656032879237, 0.269828047969883, 0.1541500130602088, 0.14711895982991552, 0.22453039310384482, 0.1706244329761858, 0.17001678550325028, 0.17513754362280265, 0.18970019343355948, 0.18885196971400042, 0.174134895299906, 0.19044131481855997, 0.1613128704197745, 0.1694662751249123, 0.07258709866901258, 0.08741859147604081, 0.07404980807303396, 0.0645506437331087, 0.07376051723301502, 0.056661480420450605, 0.06703654244177959, 0.0731800959212574, 0.061961367169409254]}, "mutation_prompt": null}
{"id": "7acf9b43-c376-4aec-95dc-dad06d8cfbe4", "solution": "import numpy as np\n\nclass MemeticPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)\n        self.eval_count = 0\n        \n        # PSO parameters\n        self.inertia = 0.7\n        self.cognitive_component = 1.47\n        self.social_component = 1.47\n        \n        # Initialize particles\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = self.positions.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        \n        # Global best\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def evaluate_population(self, func):\n        scores = np.array([func(ind) for ind in self.positions])\n        self.eval_count += len(self.positions)\n        for i in range(self.population_size):\n            if scores[i] < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = scores[i]\n                self.personal_best_positions[i] = self.positions[i].copy()\n            if scores[i] < self.global_best_score:\n                self.global_best_score = scores[i]\n                self.global_best_position = self.positions[i].copy()\n    \n    def update_particles(self):\n        r1 = np.random.rand(self.population_size, self.dim)\n        r2 = np.random.rand(self.population_size, self.dim)\n        cognitive_velocity = self.cognitive_component * r1 * (self.personal_best_positions - self.positions)\n        social_velocity = self.social_component * r2 * (self.global_best_position - self.positions)\n        self.velocities = self.inertia * self.velocities + cognitive_velocity + social_velocity\n        self.positions += self.velocities\n        self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n    def local_search_sa(self, position, func):\n        # Simulated Annealing inspired local search\n        temp = 1.0\n        cooling_rate = 0.98\n        best_pos = position.copy()\n        best_score = func(best_pos)\n        self.eval_count += 1\n        \n        while self.eval_count < self.budget and temp > 1e-3:\n            candidate = best_pos + np.random.normal(0, 0.1, self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            candidate_score = func(candidate)\n            self.eval_count += 1\n            \n            # Accept if better or with a probability if worse\n            if candidate_score < best_score or np.exp((best_score - candidate_score) / temp) > np.random.rand():\n                best_pos = candidate\n                best_score = candidate_score\n            temp *= cooling_rate\n        \n        return best_pos, best_score\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        \n        while self.eval_count < self.budget:\n            self.update_particles()\n            self.evaluate_population(func)\n            \n            # Apply local search\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                improved_pos, improved_score = self.local_search_sa(self.positions[i], func)\n                if improved_score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = improved_score\n                    self.personal_best_positions[i] = improved_pos\n                    if improved_score < self.global_best_score:\n                        self.global_best_score = improved_score\n                        self.global_best_position = improved_pos\n        \n        return self.global_best_position", "name": "MemeticPSOSA", "description": "A Memetic Algorithm combining Particle Swarm Optimization and Simulated Annealing to balance global exploration and local exploitation in black box optimization.", "configspace": "", "generation": 10, "fitness": 0.18468061504670044, "feedback": "The algorithm MemeticPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.4778295434341818, 0.4860820257317572, 0.48569705667837637, 0.43548214734269064, 0.4548218763545844, 0.4684071991337727, 0.4506682655542331, 0.466909224692691, 0.443865589845421, 0.017067195839673865, 0.011123547938254208, 0.0015666403069306556, 0.028051337773483787, 9.999999999998899e-05, 0.004685119604920018, 9.999999999998899e-05, 0.02233101948724925, 9.999999999998899e-05, 0.02601508244701145, 0.06269315073781778, 0.027383920202015855, 0.06710131972587463, 0.058584985388361877, 0.08915443531825418, 0.06798401480884786, 0.04576092239208174, 0.03448096796462563, 0.03854584472055389, 0.058709812128245886, 0.024040585772967638, 0.06865544381955224, 0.06845830377898343, 0.03762498529247682, 0.06044807681493658, 0.05119643323388168, 0.043980632626313354, 0.6039106683053072, 0.5473372757784413, 0.8811684898835366, 0.5818761622354157, 0.5395461260328918, 0.5465499599317178, 0.5739311143735577, 0.5273296127585415, 0.5532708989113267, 0.29109364940235005, 0.25914683477343536, 0.257168382141443, 0.3028299150047493, 0.29897515716586953, 0.28503448960406785, 0.31637051660509885, 0.2724631887707014, 0.3080122890465026, 0.22805137415668797, 0.12474305602085223, 0.1480229785013114, 0.22056591226677302, 0.18367643884016116, 0.22216882984878827, 0.18695417031003692, 0.14053850014064484, 0.19584936227568372, 0.18416639158671422, 0.16677936402033755, 0.1350680342635433, 0.15490440064138533, 0.18444638758530107, 0.19771833881437884, 0.18720036214060742, 0.16069407069506692, 0.18572004933156494, 0.20413807934660566, 0.05545245200832105, 0.1746809224578264, 0.17597425004296874, 0.20125037158771875, 0.17461243574150376, 0.22220557526349116, 0.11687355151807355, 0.21996295923369313, 9.999999999998899e-05, 9.999999999998899e-05, 0.005931160787907674, 0.0504140464034013, 0.04139691015843694, 0.0009271665400035767, 0.024081139105516014, 9.999999999998899e-05, 0.005409730226381693, 0.13943194699473893, 0.06205664746350481, 0.11022210538963573, 0.10777710455785472, 0.026970073987351295, 0.05976760173311646, 0.14231119645388213, 0.12978444975321068, 0.09827699843999416, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10068317138660898, 0.10444364540285, 0.11167679458418223, 0.11791147292061344, 0.10083689360848058, 0.10806413841023166, 0.12479797949516469, 0.11775432779601047, 0.09851290239098676, 0.42211031344995864, 0.39266841854539625, 0.416393516552933, 0.4349089094671592, 0.4162641519263467, 0.40910427702899965, 0.4159192748192003, 0.40682494107926115, 0.41665838009869116, 0.048937028197485466, 0.04944410519358866, 0.040164726985046806, 0.07078331064457166, 0.008884138993371371, 0.06404126337680083, 0.04279630492895792, 0.02337368390017347, 0.0674148174042386, 0.18977367983155957, 0.1714147151482328, 0.19839891122059738, 0.2603416273969801, 0.19020917677858107, 0.24719960985641343, 0.22190826416948095, 0.12769869550802238, 0.1688427071853008, 0.16595483731881489, 0.1788480611003933, 0.1283696527242313, 0.16002884259408745, 0.22872346910820796, 0.1824361426053267, 0.15317726491848294, 0.1607868904418519, 0.11735303587407964, 0.09826856728458222, 0.0963058500953341, 0.12277259777727545, 0.1418436068231682, 0.12266401391703163, 0.12605909207077004, 0.08054671942666247, 0.10684899039589513, 0.06162641177452277, 0.18325887654090123, 0.14096043046946327, 0.15899544828224677, 0.20103239684738028, 0.2356242467443339, 0.2121927717660772, 0.17585680860992614, 0.15151258738163254, 0.1926746691521346, 0.18774592617152908, 0.2376502355353981, 0.2107651096893688, 0.2186572457554644, 0.22233874781259289, 0.2018701664231335, 0.18037784744977703, 0.20320344408870084, 0.1929671571775512, 0.6729737124033717, 0.5127661396316818, 0.1708776779165564, 0.5548605245025788, 0.20215584569836242, 0.19869831703011587, 0.6681368486067407, 0.26972778491369975, 0.1637539057211871, 0.40007105703842305, 0.30463904211074166, 0.28096530130426256, 0.5027987508441739, 0.3600242994488484, 0.21273936037901053, 0.1325153758252956, 0.08409599571860416, 0.3167867831206742, 0.1872616182356771, 0.1797912628731808, 0.1857166882805643, 0.18003299711523235, 0.17382627272827955, 0.18879635639025016, 0.20759723126727303, 0.1940861773260587, 0.18470376573557346, 0.05516175576250315, 0.05507260828389138, 0.06341036133544753, 0.04301748863859267, 0.055469256698380875, 0.03655285248756679, 0.055991265347820396, 0.035161356856869275, 0.06322004042804363]}, "mutation_prompt": null}
{"id": "183fbf99-fc82-41db-aa9c-37c26206457c", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = max(10, 5 * dim)  # Large swarm for better exploration\n        self.eval_count = 0\n        self.inertia_weight = 0.729  # Constriction factor for convergence\n        self.cognitive_const = 1.494\n        self.social_const = 1.494\n\n    def initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        return positions, velocities\n\n    def evaluate_swarm(self, positions, func):\n        fitness = np.array([func(pos) for pos in positions])\n        self.eval_count += len(positions)\n        return fitness\n\n    def update_velocity(self, velocities, positions, personal_best, global_best):\n        r1, r2 = np.random.rand(2)\n        cognitive = self.cognitive_const * r1 * (personal_best - positions)\n        social = self.social_const * r2 * (global_best - positions)\n        new_velocities = self.inertia_weight * velocities + cognitive + social\n        return np.clip(new_velocities, -1, 1)\n\n    def update_position(self, positions, velocities):\n        new_positions = positions + velocities\n        return np.clip(new_positions, self.lower_bound, self.upper_bound)\n\n    def local_intensification(self, global_best, func):\n        # Simple local search to exploit around the global best\n        epsilon = 0.1\n        neighbors = np.clip(global_best + epsilon * np.random.uniform(-1, 1, (3, self.dim)), self.lower_bound, self.upper_bound)\n        neighbor_fitness = self.evaluate_swarm(neighbors, func)\n        best_idx = np.argmin(neighbor_fitness)\n        return neighbors[best_idx], neighbor_fitness[best_idx]\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_swarm()\n        fitness = self.evaluate_swarm(positions, func)\n        personal_best = positions.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = positions[global_best_idx].copy()\n\n        while self.eval_count < self.budget:\n            velocities = self.update_velocity(velocities, positions, personal_best, global_best)\n            positions = self.update_position(positions, velocities)\n            fitness = self.evaluate_swarm(positions, func)\n\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = positions[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n\n            global_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[global_best_idx] < func(global_best):\n                global_best = personal_best[global_best_idx].copy()\n\n            # Adaptive inertia weight adjustment\n            self.inertia_weight = 0.4 + 0.5 * (self.budget - self.eval_count) / self.budget\n\n            # Local search around the current global best\n            if self.eval_count < self.budget:\n                improved, improved_fitness = self.local_intensification(global_best, func)\n                if improved_fitness < func(global_best):\n                    global_best = improved.copy()\n\n        return global_best", "name": "AdaptiveSwarmOptimizer", "description": "Swarm-based exploration with adaptive parameter tuning and local intensification for robust global optimization.", "configspace": "", "generation": 11, "fitness": 0.29102214105039076, "feedback": "The algorithm AdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.8299061915133206, 0.8271925223830908, 0.8363376871414098, 0.8329025813605208, 0.8432043612305861, 0.8373811259525676, 0.8336322543128676, 0.8407492091137085, 0.8377878320307277, 0.11732398159863455, 0.006134784786341552, 9.999999999998899e-05, 0.020993583458282394, 0.03707156353863572, 0.15928870633487535, 0.1756160432973204, 0.007990738424955124, 9.999999999998899e-05, 0.13244857319725056, 0.14193086302371116, 0.11849825804393, 0.09987383103355185, 0.11665802764568123, 0.08993251769984267, 0.06456800068677515, 0.09277244286959829, 0.07734491381113495, 0.12309034247331296, 0.09807823725562304, 0.11628850335801344, 0.09749494399683667, 0.06847982854938328, 0.07422102239637984, 0.07161458268692655, 0.06643162808325143, 0.06106350293627161, 0.9702636540183857, 0.9682830528876665, 0.9699999231370996, 0.9634391632556735, 0.9734666066715263, 0.9552406336176175, 0.9764448594967414, 0.9656858457630229, 0.9707500258267405, 0.61019440998639, 0.4019844322452041, 0.5463551479191554, 0.4893861151058959, 0.4743248640294053, 0.44507514625251166, 0.41973705091833113, 0.4333154433005145, 0.3952958777680329, 0.8437022971261265, 0.23018362382047186, 0.8425864239314934, 0.2818457803241625, 0.4023995405044365, 0.21445091043640074, 0.2323273838275942, 0.13147159757637472, 0.23802317141235985, 0.22376690027484036, 0.1291428461685208, 0.1450737540649477, 0.21944125288914174, 0.18781482889476508, 0.12310757244009907, 0.1976334549124409, 0.13674821731783382, 0.13450850520291113, 0.1347300126779608, 0.1893037857122164, 0.23432753365047287, 0.32498721453029544, 0.1311161528587269, 0.16662593537344583, 0.21985665254037468, 0.11670716836816886, 0.19167052871024148, 0.022233957830455453, 9.999999999998899e-05, 0.22096559783921577, 0.005387923975651021, 0.11385704210566727, 0.027206374417542922, 0.19191105029672428, 9.999999999998899e-05, 0.008577518542945084, 0.07781720674543102, 0.05405195632852611, 0.16481107477043455, 0.07779651597180803, 0.06761053528844674, 0.05788552510273348, 0.1826545420476453, 0.09780470975184385, 0.06918916202531544, 0.2514532285204394, 0.19637195975255517, 0.14368851042680364, 0.1686229662668024, 0.21012032533453429, 0.13750257351043926, 0.18784645954808277, 0.09519667339543869, 0.061959101354993384, 0.12568869196215327, 0.056900033471372624, 0.14273997785037207, 0.2297663423824935, 0.2551614595508075, 0.08572105720421586, 0.09449249489496958, 0.09413703194805434, 0.10380895526406053, 0.571365909838035, 0.5162994701882437, 0.6061236834972942, 0.5769517625538505, 0.5526436703274891, 0.5603933742008247, 0.5934367278118322, 0.51992906363335, 0.4910989685162376, 0.04781822334031727, 0.10549877761897974, 0.10057845165986945, 0.05884378727861461, 0.08018824316975315, 0.08260835054575477, 0.11043752345729385, 0.09639814649108214, 0.08095355568419105, 0.2743702375193584, 0.19649072592520056, 0.20715137701271502, 0.1689406055114201, 0.2735438690811537, 0.21708739251642084, 0.3845507425047977, 0.17562958273356888, 0.17039887402522258, 0.15760070032117401, 0.29408855903765985, 0.3731209203173901, 0.24879659220023242, 0.2331033784449823, 0.3048570647307548, 0.29168345664514106, 0.4218190243578429, 0.2855272490024069, 0.29053230348782266, 0.29561691551171076, 0.2820129106165721, 0.27419254310961905, 0.20420245542707038, 0.2476799628111751, 0.2586230068224521, 0.2382682026270636, 0.2162899213429832, 0.25792459100875376, 0.23486292382002927, 0.2784389872373846, 0.24025475814452257, 0.23223197261380735, 0.20850441406912912, 0.26723488713917154, 0.22017841492705503, 0.23429656502071283, 0.18465111011366675, 0.18437817341873564, 0.18236935579759095, 0.17959885479555926, 0.19522548281464147, 0.18325986301957087, 0.19067528364381436, 0.18748982002805414, 0.17222950087289335, 0.12669002164282972, 0.12709415613593078, 0.15376250327031105, 0.9293661940454055, 0.2016740314599591, 0.8939326894881122, 0.12288393969580214, 0.9356258601080882, 0.9107347948016382, 0.8576231665868892, 0.1572786940474198, 0.6525068630009947, 0.9048269483207174, 0.16913076213259592, 0.8233160024999553, 0.6697208803484267, 0.8183945481489979, 0.6585405774537403, 0.2467585677928379, 0.22335849574413702, 0.19200439330253072, 0.21598734156912647, 0.20037081457740658, 0.20550535697127936, 0.25407739435697696, 0.22521785909652026, 0.19516414005997695, 0.08155159586903116, 0.10584435311898777, 0.07309742646790729, 0.10862264845110625, 0.08263537692201317, 0.08770725741929453, 0.0852302569069765, 0.10646272664539225, 0.098095586832039]}, "mutation_prompt": null}
{"id": "2df1da34-4df9-4f89-a4d7-865af6f268f2", "solution": "import numpy as np\n\nclass AdaptiveMemetic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.init_population_size = max(5, 3 * dim)\n        self.population_size = self.init_population_size\n        self.eval_count = 0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.convergence_threshold = 0.01\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def adapt_population_size(self, previous_best, current_best):\n        if np.abs(previous_best - current_best) < self.convergence_threshold:\n            self.population_size = min(self.population_size + 1, self.budget - self.eval_count)\n        else:\n            self.population_size = max(self.init_population_size, self.population_size - 1)\n\n    def mutate(self, population, best):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        x1, x2, x3 = population[indices]\n        mutant = x1 + self.mutation_factor * (x2 - x3)\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def enhanced_local_search(self, individual, func, intensity):\n        epsilon = 0.1 * intensity\n        neighbors = np.clip(individual + epsilon * np.random.uniform(-1, 1, (5, self.dim)), self.lower_bound, self.upper_bound)\n        neighbor_fitness = self.evaluate_population(neighbors, func)\n        best_idx = np.argmin(neighbor_fitness)\n        return neighbors[best_idx], neighbor_fitness[best_idx]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        previous_best = np.inf\n        \n        while self.eval_count < self.budget:\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n            current_best_fitness = fitness[best_idx]\n            \n            self.adapt_population_size(previous_best, current_best_fitness)\n            previous_best = current_best_fitness\n            \n            new_population = population.copy()\n            new_fitness = fitness.copy()\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self.mutate(population, best)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n            \n            # Apply enhanced local search based on convergence\n            intensity = 1 + (1 - current_best_fitness / fitness.max())\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                improved, improved_fitness = self.enhanced_local_search(new_population[i], func, intensity)\n                if improved_fitness < new_fitness[i]:\n                    new_population[i] = improved\n                    new_fitness[i] = improved_fitness\n\n            population, fitness = new_population, new_fitness\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveMemetic", "description": "Adaptive Memetic Algorithm combining dynamic population size control and local search intensity based on convergence speed for robust performance across diverse optimization landscapes.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 15')", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {}, "mutation_prompt": null}
{"id": "c17e1c53-2df0-4e3b-b965-c2481af2eb1d", "solution": "import numpy as np\n\nclass HarmonySearchPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = max(5, 2 * dim)\n        self.harmony_consideration_rate = 0.95\n        self.random_selection_rate = 0.05\n        self.adjustment_rate = 0.3\n        self.eval_count = 0\n        \n    def initialize_harmony_memory(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n\n    def evaluate_harmony_memory(self, memory, func):\n        fitness = np.array([func(ind) for ind in memory])\n        self.eval_count += len(memory)\n        return fitness\n\n    def new_harmony(self, memory):\n        harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.harmony_consideration_rate:\n                harmony[i] = memory[np.random.randint(self.harmony_memory_size), i]\n                if np.random.rand() < self.adjustment_rate:\n                    harmony[i] += np.random.uniform(-0.1, 0.1)\n            else:\n                harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        harmony = np.clip(harmony, self.lower_bound, self.upper_bound)\n        return harmony\n\n    def particle_swarm_optimization(self, memory, func):\n        velocity = np.random.uniform(-1, 1, (self.harmony_memory_size, self.dim))\n        personal_best = memory.copy()\n        personal_best_fitness = self.evaluate_harmony_memory(personal_best, func)\n        global_best_idx = np.argmin(personal_best_fitness)\n        global_best = personal_best[global_best_idx]\n\n        while self.eval_count < self.budget:\n            r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n            velocity = 0.5 * velocity + r1 * (personal_best - memory) + r2 * (global_best - memory)\n            memory = np.clip(memory + velocity, self.lower_bound, self.upper_bound)\n            fitness = self.evaluate_harmony_memory(memory, func)\n\n            for i in range(self.harmony_memory_size):\n                if fitness[i] < personal_best_fitness[i]:\n                    personal_best[i] = memory[i]\n                    personal_best_fitness[i] = fitness[i]\n\n            global_best_idx = np.argmin(personal_best_fitness)\n            global_best = personal_best[global_best_idx]\n\n            if self.eval_count >= self.budget:\n                break\n        \n        return global_best\n\n    def __call__(self, func):\n        harmony_memory = self.initialize_harmony_memory()\n        harmony_fitness = self.evaluate_harmony_memory(harmony_memory, func)\n\n        while self.eval_count < self.budget:\n            if self.eval_count >= self.budget:\n                break\n            new_harmony = self.new_harmony(harmony_memory)\n            new_harmony_fitness = func(new_harmony)\n            self.eval_count += 1\n\n            worst_idx = np.argmax(harmony_fitness)\n            if new_harmony_fitness < harmony_fitness[worst_idx]:\n                harmony_memory[worst_idx] = new_harmony\n                harmony_fitness[worst_idx] = new_harmony_fitness\n\n        best_harmony = self.particle_swarm_optimization(harmony_memory, func)\n        return best_harmony", "name": "HarmonySearchPSO", "description": "HarmonySearchPSO: A novel hybrid algorithm combining harmony search for exploring the solution space and particle swarm optimization for exploiting local optima in high-dimensional black box optimization tasks.", "configspace": "", "generation": 13, "fitness": 0.25580026668469746, "feedback": "The algorithm HarmonySearchPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.7885593881597108, 0.7328250973555751, 0.7174222319892316, 0.7103106090962406, 0.7621201794161634, 0.7322038953525545, 0.7747612867699923, 0.7194134316427476, 0.8157896049082287, 0.37619731626184083, 0.3493742240923261, 0.44659492983845217, 0.363594193391942, 0.35221345545161653, 0.2439483460243529, 0.36098996380337856, 0.42757096554857277, 0.3120348422283715, 0.16278507008064502, 0.1384758544929533, 0.17110713086377805, 0.21902072821594476, 0.1768321835426464, 0.4730380745910374, 0.15033717744805797, 0.38994737660772094, 0.18506764096365969, 0.1261645417630629, 0.13632624937698734, 0.14342638596303603, 0.16041788756436304, 0.2830360399228723, 0.38309318144296334, 0.12298607161904762, 0.13550019354880638, 0.15878134817794887, 0.9430644936059408, 0.9315316768263545, 0.9251585950085446, 0.9546009866053521, 0.9556734594396423, 0.9261813814025678, 0.9560838201561922, 0.9527661621599571, 0.9254083645731147, 0.37554019225233437, 0.4106890435683771, 0.3637035759526791, 0.38613989727674447, 0.4343613163609332, 0.4845906124639008, 0.4171600645735859, 0.3352794847118632, 0.3346087417757634, 0.19046183654038373, 0.08308598932576683, 0.1418325071108375, 0.22576515005881004, 0.2781531593614287, 0.15122872205497806, 0.12463992378580846, 0.20822095074667613, 0.235719045300811, 0.2659584548237487, 0.20082309465074777, 0.20001730581692023, 0.19118788433278777, 0.15196067840911054, 0.13077452382449428, 0.3460410361874072, 0.2301065182708698, 0.1474930922636597, 0.18424922445150627, 0.10767339265761144, 0.27987708984633086, 0.1361915492472725, 0.1317577821458943, 0.15557524692384928, 0.18189851386966394, 0.17017760475790022, 0.17131446001680684, 9.999999999998899e-05, 0.00789906021770348, 9.999999999998899e-05, 0.0017434929653714626, 0.01459881243287986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058321071980409256, 0.05535924581385665, 0.02647150693991862, 0.03601108459448188, 0.0668023789998119, 0.012876201465162773, 0.01566297728856303, 0.1300236081683097, 0.048309852171960155, 0.07986259140072127, 0.10290607227182758, 0.03539654665039904, 0.14000707930778644, 0.11655481312124849, 0.07672630896467836, 0.1343654185011901, 0.07056120415489353, 0.12245102708963373, 0.09619223707053459, 0.23200102215453233, 0.14582642357152675, 0.1393362200084004, 0.05462413159558832, 0.013688960038272358, 0.08585097995831548, 0.24535886551542407, 0.25589343582507773, 0.08236167098356073, 0.4718772266018081, 0.46239569926678836, 0.467888905629829, 0.464872670719368, 0.44573069981032876, 0.44286781810643616, 0.46397383907735246, 0.5012483568912999, 0.5421009819659905, 0.09730378508457727, 0.11307218796246687, 0.03957139509837437, 0.11344560097047929, 0.07149834448795611, 0.1205211297893124, 0.1478927052958786, 0.12012828801352093, 0.07389766096905692, 0.2057829864049815, 0.25354626559838755, 0.19542795156034065, 0.16752045076049382, 0.3290860931810424, 0.1376055778208598, 0.17717991160105795, 0.2177886447391164, 0.26482409308299937, 0.18306112521430928, 0.15917398560856055, 0.2776785743577347, 0.1553351345369265, 0.21208124153275143, 0.22481534619061538, 0.16354548552135095, 0.2334623843042769, 0.1449966168595871, 0.17006536333652889, 0.14279035927920436, 0.1817955511542625, 0.21096858036988808, 0.13202261801808612, 0.21213919967424344, 0.1209189286015353, 0.1492289413084027, 0.16828310828517534, 0.19508427707372744, 0.2312021795834709, 0.2048610845600407, 0.21107862193522686, 0.20398280946291547, 0.1960775888637677, 0.22381587285013782, 0.22286294055817257, 0.2386573626857943, 0.20992318742291682, 0.22306560508941797, 0.22793870889350965, 0.2551831850113735, 0.18780013707205412, 0.19381200828883294, 0.21835273687616297, 0.22686181849480147, 0.20382381402443928, 0.18894112592457502, 0.1893861393829045, 0.1163957488255164, 0.17014765562257417, 0.2019537699123295, 0.9338657554125944, 0.1582759032049318, 0.9266162795599457, 0.17278031734444832, 0.5617467786982804, 0.3597496237261776, 0.11116203332769459, 0.08328177738556442, 0.2133745150688645, 0.20815358574096376, 0.16927343237167258, 0.11237575053219484, 0.09479309848781248, 0.21480772195616882, 0.18148706644717927, 0.2044811870230938, 0.19841718498623873, 0.2063520785095765, 0.18097474154741955, 0.20464294963016372, 0.24163391656221078, 0.20903471463321877, 0.08493228387035234, 0.06591227518844589, 0.07304569913983339, 0.07204798498386478, 0.12068461187450319, 0.09850782796480895, 0.08259645666803594, 0.07958255188464025, 0.09410930287074515]}, "mutation_prompt": null}
{"id": "498c2534-c94c-4063-afc4-e3a8030e4816", "solution": "import numpy as np\n\nclass QiPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)\n        self.eval_count = 0\n        self.inertia_weight = 0.5\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.position = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.position.copy()\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_fitness = np.inf\n\n    def evaluate_population(self, func):\n        fitness = np.array([func(ind) for ind in self.position])\n        self.eval_count += len(self.position)\n        return fitness\n\n    def update_personal_best(self, fitness):\n        better_mask = fitness < self.personal_best_fitness\n        self.personal_best[better_mask] = self.position[better_mask]\n        self.personal_best_fitness[better_mask] = fitness[better_mask]\n\n    def update_global_best(self):\n        min_idx = np.argmin(self.personal_best_fitness)\n        if self.personal_best_fitness[min_idx] < self.global_best_fitness:\n            self.global_best_fitness = self.personal_best_fitness[min_idx]\n            self.global_best = self.personal_best[min_idx].copy()\n\n    def quantum_behavior(self):\n        for i in range(self.population_size):\n            if np.random.rand() < 0.5:\n                self.position[i] = self.global_best + np.random.uniform(-1, 1, self.dim) * np.abs(self.position[i] - self.global_best)\n            else:\n                self.position[i] = self.personal_best[i] + np.random.uniform(-1, 1, self.dim) * np.abs(self.position[i] - self.personal_best[i])\n            self.position[i] = np.clip(self.position[i], self.lower_bound, self.upper_bound)\n\n    def update_velocity_and_position(self):\n        for i in range(self.population_size):\n            inertia = self.inertia_weight * self.velocity[i]\n            cognitive = self.cognitive_coeff * np.random.rand(self.dim) * (self.personal_best[i] - self.position[i])\n            social = self.social_coeff * np.random.rand(self.dim) * (self.global_best - self.position[i])\n            self.velocity[i] = inertia + cognitive + social\n            self.position[i] = self.position[i] + self.velocity[i]\n            self.position[i] = np.clip(self.position[i], self.lower_bound, self.upper_bound)\n\n    def adaptive_local_search(self, func):\n        epsilon = 0.1 * (self.upper_bound - self.lower_bound)\n        for i in range(self.population_size):\n            if self.eval_count >= self.budget:\n                break\n            neighbor = np.clip(self.position[i] + epsilon * np.random.uniform(-1, 1, self.dim), self.lower_bound, self.upper_bound)\n            neighbor_fitness = func(neighbor)\n            self.eval_count += 1\n            if neighbor_fitness < self.personal_best_fitness[i]:\n                self.personal_best[i] = neighbor\n                self.personal_best_fitness[i] = neighbor_fitness\n\n    def __call__(self, func):\n        fitness = self.evaluate_population(func)\n        self.update_personal_best(fitness)\n        self.update_global_best()\n\n        while self.eval_count < self.budget:\n            self.update_velocity_and_position()\n            fitness = self.evaluate_population(func)\n            self.update_personal_best(fitness)\n            self.update_global_best()\n            self.quantum_behavior()\n            self.adaptive_local_search(func)\n\n        return self.global_best", "name": "QiPSO", "description": "Quantum-inspired Particle Swarm Optimization (QiPSO) utilizes quantum principles to enhance global search efficiency through dynamic particle state adjustments and adaptive local search.", "configspace": "", "generation": 14, "fitness": 0.304264440936095, "feedback": "The algorithm QiPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.9075209129606578, 0.8976651562401257, 0.898307677912586, 0.8899408890073413, 0.89438469583411, 0.9104559225179706, 0.8800634803559408, 0.8949485166176446, 0.8993449487850865, 0.8098482405225154, 0.753545412562433, 0.7560149494281339, 0.7726630078148531, 0.047677649401741684, 0.7935053614130704, 0.799723353904433, 0.822348144075611, 0.7960025074695138, 0.184782067387407, 0.1544210055213534, 0.17389234304749845, 0.11594867619336768, 0.15921584655079313, 0.11624562662931459, 0.15516262755986276, 0.6102173208162924, 0.1411816030458647, 0.09687526231172305, 0.15511360895511772, 0.1114651956475955, 0.1160325262125661, 0.12457427895106443, 0.11969502840994684, 0.14121528388344018, 0.11198129476678065, 0.14033326689064307, 0.9826822265584098, 0.9696294859619947, 0.990705536467001, 0.9817191732429481, 0.9690675778285505, 0.9805819855573195, 0.9855061486058159, 0.9743353585942119, 0.9770111317531561, 0.6931285866906374, 0.6681426777195199, 0.631602056202037, 0.6743246732272665, 0.6347241769731724, 0.6365373130020223, 0.7003062964569993, 0.6107354467639903, 0.6312282803390727, 0.33972678169797854, 0.36852299672316247, 0.3171569302499949, 0.28194177613909865, 0.27699840104441, 0.33253236414711673, 0.288167002437274, 0.3871452062287033, 0.3550369202601785, 0.1966480764286863, 0.21120074300609637, 0.19973058295121926, 0.18502785902504426, 0.18666179951200323, 0.2605345046546329, 0.1959246140331159, 0.12616171517793118, 0.2207739232779965, 0.1347823257428139, 0.1911188374322068, 0.12124398028948002, 0.44570183088701665, 0.1320722689598509, 0.15972384597255607, 0.31189908939855926, 0.10432054690301684, 0.21995398859080006, 9.999999999998899e-05, 0.00017486548453304884, 0.005139639577710686, 0.0921102750836219, 0.06607919832269349, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08181304301478498, 0.023580415967947355, 0.1277005205202708, 0.06623201070967533, 0.025413049808373778, 0.033643948781829525, 0.08975821997057543, 0.0930767507173701, 0.10032506774518513, 0.11626687789896917, 0.05173861625035425, 0.11537328415676895, 0.19550635355099955, 0.17562454812803752, 0.08488255509492426, 0.07765874663621564, 0.1503258986177185, 0.08912410944828209, 0.20919647159791233, 0.18254734317000598, 0.059666546211312954, 0.09212192667097008, 0.0210672662956235, 0.08756716431344214, 0.135844155107105, 0.18798986198855328, 0.20892818348101994, 0.54703282080127, 0.602442389604782, 0.5946164687526282, 0.5667761470125736, 0.5614136976278655, 0.5193808795776418, 0.5733788359822393, 0.5188566740598304, 0.6132922455624008, 0.0900333301791274, 0.15699461941323622, 0.10586343367253481, 0.13857973512481125, 0.11810567499731572, 0.1545329252273252, 0.10381035149202822, 0.13752714906621277, 0.10142020585715439, 0.2579627217245578, 0.3119611589462511, 0.19398522028426268, 0.1851298996805656, 0.2839259225762316, 0.1678198823685052, 0.21180793886144322, 0.17470691401818617, 0.27019080442799304, 0.37201291832190286, 0.2602199652681745, 0.2227802928728556, 0.31688138008892675, 0.35573085212622535, 0.27790390229993567, 0.27234986545470785, 0.33408053303886276, 0.33962820166372787, 0.1996451596642299, 0.36216590810291693, 0.19240811140635783, 0.22590887541579996, 0.33224466460477964, 0.172588110233155, 0.23783910650400308, 0.17163291736999342, 0.07964187727123406, 0.21892975630565137, 0.2231556823766392, 0.195694147041109, 0.17944808071673213, 0.23014949225848313, 0.1690447261715915, 0.23326686631005533, 0.20595445549422953, 0.2024383604721557, 0.20099427147797255, 0.19085911828648716, 0.7432796670505446, 0.20293060268876284, 0.2550262985135663, 0.20206588796373381, 0.20982544955983906, 0.22659079106231017, 0.24428772409389854, 0.10539208533555489, 0.18793136767354668, 0.15463101901795162, 0.9005542275572735, 0.201646624226425, 0.2002382598007052, 0.167867345462535, 0.14921057143978755, 0.1673272974262915, 0.08336336630728114, 0.21384409448648822, 0.07296565079113881, 0.21273648054213867, 0.16967198630196667, 0.21360940976081633, 0.10551767999503159, 0.1690513458717363, 0.6540788005589606, 0.19304916477897716, 0.20117026848764907, 0.19221902636025934, 0.20129793824536057, 0.1954643545618837, 0.19162330513351222, 0.19798735425416425, 0.20891567379243747, 0.18828661020105797, 0.09558406275763887, 0.12259723224619645, 0.08520610428687636, 0.09998282048772056, 0.10747550628535896, 0.08291117822004579, 0.08742927841588322, 0.08538961504075815, 0.09177242259235485]}, "mutation_prompt": null}
{"id": "79ea744d-5afc-4bc5-b874-4cc7161753a6", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)  # Ensure a diverse population\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_fraction = 0.1\n        self.eval_count = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def mutate(self, individual, population, best):\n        # Differential Evolution-style mutation\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        x1, x2, x3 = population[indices]\n        mutant = x1 + self.mutation_factor * (x2 - x3)\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        # Binomial Crossover\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, population, fitness, trial, trial_fitness, idx):\n        if trial_fitness < fitness[idx]:\n            population[idx] = trial\n            fitness[idx] = trial_fitness\n\n    def elite_local_search(self, best, func):\n        # Simple local search around best individual\n        epsilon = 0.1\n        neighbors = np.clip(best + epsilon * np.random.uniform(-1, 1, (5, self.dim)), self.lower_bound, self.upper_bound)\n        neighbor_fitness = self.evaluate_population(neighbors, func)\n        best_idx = np.argmin(neighbor_fitness)\n        return neighbors[best_idx], neighbor_fitness[best_idx]\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        \n        while self.eval_count < self.budget:\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                mutant = self.mutate(population[i], population, best)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n                self.select(population, fitness, trial, trial_fitness, i)\n\n            # Local search on elite individuals\n            num_elites = max(1, int(self.elite_fraction * self.population_size))\n            elite_indices = np.argsort(fitness)[:num_elites]\n            for idx in elite_indices:\n                if self.eval_count >= self.budget:\n                    break\n                improved, improved_fitness = self.elite_local_search(population[idx], func)\n                if improved_fitness < fitness[idx]:\n                    population[idx] = improved\n                    fitness[idx] = improved_fitness\n\n        return population[np.argmin(fitness)]", "name": "HybridGADE", "description": "A hybrid genetic algorithm with differential evolution-inspired mutation and elite local search to efficiently find optimal solutions in a variable-dimensional search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.8692060493840063, 0.8753230712129547, 0.8698674066411474, 0.8707515976994974, 0.880477503328092, 0.89465287253704, 0.8790553855507521, 0.88377165145017, 0.8600790633772093, 0.7623483622177147, 0.7541810329597229, 0.7482013374582703, 0.7488058759375524, 0.7509663821491182, 0.7539670999300785, 0.7609350815430083, 0.8114634462483886, 0.7466056217511314, 0.46805418411376776, 0.17224347964858644, 0.1666954043448421, 0.31204445612392284, 0.15952663813173817, 0.17280829373717788, 0.5387702531020028, 0.5822691913010222, 0.15467637501410825, 0.5907154638557285, 0.15832323663437253, 0.16063017056513895, 0.3896513651454019, 0.1582396678739435, 0.15844220345269988, 0.16106691920014382, 0.48211844218531674, 0.4102915818548949, 0.9779176172339342, 0.9667497632537518, 0.9719968350536624, 0.9795003140750971, 0.972419915963086, 0.9880760481933367, 0.981075335970484, 0.9767806814410274, 0.9815172551989324, 0.5933918072584367, 0.5666062873237689, 0.5967689862344604, 0.49725816068317463, 0.5418788986672434, 0.5941763835948577, 0.5748740899981981, 0.5538061149607543, 0.6220029978014117, 0.8753016133072498, 0.7580596612863769, 0.7062554777029746, 0.7014201602218668, 0.7744182312388721, 0.7001958567537541, 0.7183324448662867, 0.6196655388597122, 0.7291839743936602, 0.34622790038245554, 0.2670595021908093, 0.3019234307580272, 0.2771132435610629, 0.39621088396359017, 0.3115441575954957, 0.36763923577058233, 0.2930408970915146, 0.3048814396514129, 0.38525269800966355, 0.13695488401175115, 0.2893911493189225, 0.38197333052188964, 0.3158457266320416, 0.34094842946716253, 0.3449950201308024, 0.3150140464837051, 0.30601967486429404, 0.0853693825450117, 0.09921899811270718, 0.13807479486648155, 0.12245334916386785, 0.12315009479103123, 0.10891705552259867, 0.1395593737827585, 0.14849460200331266, 0.10368516458846044, 0.21653879052648994, 0.3071522481981448, 0.26636489977317324, 0.23142399316838969, 0.18114833421122623, 0.22194721225613867, 0.39223394047062043, 0.285924831288378, 0.31432114008119894, 0.13285394094549718, 0.06893422357273704, 0.0276203221950847, 0.035578161523326934, 0.1390142311518333, 0.0815143979298869, 0.05115905455827763, 0.10552263617305324, 0.10048456782007342, 0.23145605112508572, 0.19400218583067486, 0.1898866452571072, 0.25188584142770365, 0.27291969073834643, 0.24636982667274498, 0.20015216151776072, 0.20957202899866956, 0.19617095024419673, 0.6083424996120554, 0.630463494370376, 0.6386638276027085, 0.5936822476175885, 0.5978466838300331, 0.6139778883491169, 0.6054608059871693, 0.590445838779296, 0.6241900280409345, 0.14306255024300585, 0.14479323630159813, 0.1379969906464672, 0.10478800959981927, 0.12361965197768932, 0.12391627527755045, 0.10827844223390581, 0.10507757842334609, 0.11155714696545982, 0.20367038957393846, 0.19316664931908067, 0.26589389969168875, 0.20361947128024827, 0.232724389021295, 0.23039253866507103, 0.1717033927018463, 0.19710146456574762, 0.19918900212549617, 0.36311052924798237, 0.38778734417098104, 0.36573900483143196, 0.41922445129094354, 0.32593930010600347, 0.3817620155454797, 0.4165296107988583, 0.4419738531695607, 0.4453671616443128, 0.2692943486097289, 0.2648729300371293, 0.24034060653949252, 0.24482336598357146, 0.26464722972333643, 0.23541894044449574, 0.235696162857565, 0.283671956492925, 0.31176964716673305, 0.19870167924286997, 0.20052380129942848, 0.22595015834525833, 0.21909010684395347, 0.18690280590990727, 0.20437187915806354, 0.18855427350468768, 0.18964322846502868, 0.19252505351449312, 0.3681921543476564, 0.2448366902038086, 0.3709243602223107, 0.34569458943346476, 0.24010159524370334, 0.20349342696699646, 0.5154103097479652, 0.4416658578227609, 0.21151223401029617, 0.16754601396824886, 0.2056223765976546, 0.18095202307446134, 0.1665739733998156, 0.7885122251311609, 0.7476442400650446, 0.1789480675557641, 0.701555445745834, 0.19656741203910666, 0.7688606897595233, 0.21190801546764182, 0.7450927086807146, 0.20297164619781183, 0.210386671936159, 0.5033976204271355, 0.2115466117433611, 0.20827487976362968, 0.21340882200334543, 0.18281773179745942, 0.17451668886543625, 0.1908529436635158, 0.18307839354020716, 0.1882844116200033, 0.18897957533201004, 0.19287922488977438, 0.18540945284997845, 0.19620672602122136, 0.07080960414069015, 0.08344663335607261, 0.07092166880818618, 0.0853028461580354, 0.07861076048981941, 0.0922777802302871, 0.08435745326388733, 0.08165582580614972, 0.08575226389930446]}, "mutation_prompt": null}
{"id": "7ba8f78b-6280-4e4f-a082-42fc1a88776b", "solution": "import numpy as np\n\nclass SpiralGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)\n        self.eval_count = 0\n        self.alpha = 0.1  # Spiral expansion factor\n        self.beta = 0.5   # Spiral contraction factor\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def spiral_mutation(self, center, point):\n        direction = point - center\n        angle = np.random.uniform(0, 2 * np.pi)\n        radius = np.linalg.norm(direction)\n        spiral_point = center + radius * np.array([np.cos(angle), np.sin(angle)])\n        spiral_point = np.clip(spiral_point, self.lower_bound, self.upper_bound)\n        return spiral_point\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n            new_population = np.empty_like(population)\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                spiral_point = self.spiral_mutation(best, population[i])\n                trial_fitness = func(spiral_point)\n                self.eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = spiral_point\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n            # Expand and contract spirals\n            self.alpha *= 1.1\n            self.beta *= 0.9\n\n        return population[np.argmin(fitness)]", "name": "SpiralGA", "description": "SpiralGA: A novel optimization algorithm inspired by spiral dynamics in nature, enhancing local and global search through expanding and contracting spirals in the solution space.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (5,) (2,) ').", "error": "ValueError('operands could not be broadcast together with shapes (5,) (2,) ')", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {}, "mutation_prompt": null}
{"id": "3ab60a5d-2060-4840-9acf-785ed3c560a0", "solution": "import numpy as np\n\nclass AdaptiveMemeticOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)\n        self.eval_count = 0\n        self.omega = 0.5\n        self.phi_p = 0.5\n        self.phi_g = 0.5\n        self.elite_fraction = 0.1\n\n    def initialize_population(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        return positions, velocities\n\n    def evaluate_population(self, positions, func):\n        fitness = np.array([func(ind) for ind in positions])\n        self.eval_count += len(positions)\n        return fitness\n\n    def update_velocity_position(self, positions, velocities, personal_best_positions, global_best_position):\n        r_p = np.random.rand(self.population_size, self.dim)\n        r_g = np.random.rand(self.population_size, self.dim)\n\n        velocities = self.omega * velocities + self.phi_p * r_p * (personal_best_positions - positions) + self.phi_g * r_g * (global_best_position - positions)\n        positions = np.clip(positions + velocities, self.lower_bound, self.upper_bound)\n        return positions, velocities\n\n    def local_search(self, best_position, func):\n        epsilon = 0.1\n        neighbors = np.clip(best_position + epsilon * np.random.uniform(-1, 1, (5, self.dim)), self.lower_bound, self.upper_bound)\n        neighbor_fitness = self.evaluate_population(neighbors, func)\n        best_idx = np.argmin(neighbor_fitness)\n        return neighbors[best_idx], neighbor_fitness[best_idx]\n\n    def __call__(self, func):\n        positions, velocities = self.initialize_population()\n        fitness = self.evaluate_population(positions, func)\n        personal_best_positions = np.copy(positions)\n        personal_best_fitness = np.copy(fitness)\n        global_best_idx = np.argmin(fitness)\n        global_best_position = positions[global_best_idx]\n\n        while self.eval_count < self.budget:\n            positions, velocities = self.update_velocity_position(positions, velocities, personal_best_positions, global_best_position)\n            fitness = self.evaluate_population(positions, func)\n\n            # Update personal bests\n            better_mask = fitness < personal_best_fitness\n            personal_best_positions[better_mask] = positions[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n\n            # Update global best\n            current_global_best_idx = np.argmin(fitness)\n            if fitness[current_global_best_idx] < personal_best_fitness[global_best_idx]:\n                global_best_idx = current_global_best_idx\n                global_best_position = positions[global_best_idx]\n\n            # Local search on elite individuals\n            num_elites = max(1, int(self.elite_fraction * self.population_size))\n            elite_indices = np.argsort(fitness)[:num_elites]\n            for idx in elite_indices:\n                if self.eval_count >= self.budget:\n                    break\n                improved, improved_fitness = self.local_search(positions[idx], func)\n                if improved_fitness < fitness[idx]:\n                    positions[idx] = improved\n                    fitness[idx] = improved_fitness\n\n        return positions[global_best_idx]", "name": "AdaptiveMemeticOptimization", "description": "Adaptive Memetic Optimization (AMO) combines adaptive particle swarm optimization with local search to efficiently explore and exploit variable-dimensional search spaces.", "configspace": "", "generation": 17, "fitness": 0.13120825345062428, "feedback": "The algorithm AdaptiveMemeticOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.13.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.49586134858579756, 0.5309750147316243, 0.5274013626049587, 0.1678113790306487, 0.5728130371928024, 0.19289768819434272, 0.5077737495258887, 0.33755625057372907, 0.18510765260959694, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.061384978514521626, 0.09000582014120995, 0.03760218353478939, 0.09353871324354746, 0.08477712592292697, 0.13534277278491735, 0.0846594073845095, 0.05979563334165272, 0.09285424717914881, 0.050357477184503896, 0.09734263342176785, 0.040691364360869064, 0.08883345835217171, 0.0578420715455924, 0.06483342762459887, 0.013027775710056422, 0.053042735093021265, 0.03347113547207137, 0.08309656658000508, 0.07003528371528989, 0.08714214081652483, 0.06307921918953141, 0.07939752356177565, 0.057091028193370974, 0.07768588522137321, 0.07385312758578089, 0.05837965813574897, 0.07502946139570599, 0.012649059810652452, 0.06839361354406281, 0.1031355288927871, 0.10737895920203466, 0.07949031758899305, 0.20003493546096163, 0.04433769195870518, 0.04712325893041891, 0.22454790431407723, 0.07763974928038297, 0.06810400886888401, 0.07800768528899393, 0.03631228699127609, 0.11218052049840388, 0.06490961554089536, 0.07339591561606917, 0.16390634476147203, 0.175463828529839, 9.999999999998899e-05, 0.00020276299723687163, 0.11530551435131842, 9.999999999998899e-05, 9.999999999998899e-05, 0.1315357438783129, 0.13045371590776267, 0.13659682545043617, 0.13156947860883628, 0.12019219302184814, 0.15249004422858758, 0.04167002912565587, 0.13221775979097894, 0.1314132493792758, 0.04356777793643063, 0.017236152416135853, 0.033087342978235235, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02524491231457615, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0622136969042707, 0.0249844514648212, 0.11903668049571947, 0.04181661933880476, 0.007321589591279931, 0.03643616328137045, 0.05713448424027301, 0.07399452254416516, 0.05436330175117887, 0.02655109044103987, 9.999999999998899e-05, 9.999999999998899e-05, 0.040702786946639424, 0.005927909779288143, 9.999999999998899e-05, 0.11929012345778789, 9.999999999998899e-05, 9.999999999998899e-05, 0.036940229458096496, 0.015173033333857666, 0.25432807349578535, 9.999999999998899e-05, 0.03716708239030109, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.46448700923095465, 0.42950588651429056, 0.36368064482912854, 0.25020251625072976, 0.16422270150244245, 0.1876796575693096, 0.37737881855955, 0.20014114395306082, 0.512732714469639, 0.03769577449678674, 0.03834210492976853, 0.02550016254090859, 0.11238195355976421, 0.056700520197751736, 0.16336174793646074, 0.0831763621965893, 0.0856261102504996, 0.10732911526377942, 0.1784820911727808, 0.12704632204819843, 0.1920734609921888, 0.1529529564727733, 0.16219584299466838, 0.18858108602540136, 0.1417919816867338, 0.15106412931013025, 0.16328093733667393, 0.17497310263614285, 0.24850419531472934, 0.1613901379594418, 0.2302040630387966, 0.31381578390199316, 0.22449069799472898, 0.15659516249421246, 0.17457445961915818, 0.1440065909732624, 0.10805885227128986, 0.16054558391100582, 0.11259693342986243, 0.14564733486265036, 0.28343441465454866, 0.1249590198080145, 0.0836984190150144, 0.13983704335193492, 0.059049208301728995, 0.19911851795287672, 0.2510369249055917, 0.18755362554662114, 0.25634475589023353, 0.19380181017602116, 0.2111016268393311, 0.21011674599201158, 0.2071693253669783, 0.17418759817528828, 0.19506744380527108, 0.2014024104296822, 0.18640443969056042, 0.1792709810500377, 0.16887656347410773, 0.1922918618541245, 0.18685718806243656, 0.20717826702922848, 0.17613878783226244, 0.7083714667931228, 0.21054129257354115, 0.15409064932769545, 0.6181098377501654, 0.19987874051804788, 0.2020432840177948, 0.15200865605450253, 0.11987867271176822, 0.13889018138046927, 0.6846242371283742, 0.18742519227205157, 0.0515006126560309, 0.2080810426855878, 0.1415733495250785, 0.35806853653487936, 0.10536686069603707, 0.16875365937737152, 0.09038624267332218, 0.1992153117561909, 0.19511200721293254, 0.20488691371413714, 0.1914264970153311, 0.2002942652241677, 0.22489827985243005, 0.20998731936443282, 0.19824846248080086, 0.20345521607051653, 0.0963772292482381, 0.08019471259110411, 0.07225829358098468, 0.08515355560787663, 0.08526588242974653, 0.05846634358905245, 0.08044031048482159, 0.06301610115392486, 0.06621299474458686]}, "mutation_prompt": null}
{"id": "9febc83c-c8bc-4d4e-9bda-8d39199e9cb3", "solution": "import numpy as np\n\nclass SwarmEnhancedGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)\n        self.inertia_weight = 0.7\n        self.social_coeff = 1.5\n        self.cognitive_coeff = 1.5\n        self.mutation_prob = 0.1\n        self.eval_count = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def particle_movement(self, particle, velocity, personal_best, global_best):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        cognitive_component = self.cognitive_coeff * r1 * (personal_best - particle)\n        social_component = self.social_coeff * r2 * (global_best - particle)\n        new_velocity = self.inertia_weight * velocity + cognitive_component + social_component\n        new_particle = particle + new_velocity\n        new_particle = np.clip(new_particle, self.lower_bound, self.upper_bound)\n        return new_particle, new_velocity\n\n    def mutate(self, individual):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.normal(0, 1, self.dim)\n            return np.clip(individual + mutation_vector, self.lower_bound, self.upper_bound)\n        return individual\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = population[np.argmin(fitness)]\n        global_best_fitness = np.min(fitness)\n        \n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Particle movement inspired by PSO\n                new_particle, new_velocity = self.particle_movement(population[i], velocities[i], personal_best[i], global_best)\n                velocities[i] = new_velocity\n                trial_fitness = func(new_particle)\n                self.eval_count += 1\n\n                # Check if the new particle is better\n                if trial_fitness < fitness[i]:\n                    population[i] = new_particle\n                    fitness[i] = trial_fitness\n\n                # Update personal best\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i] = new_particle\n                    personal_best_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < global_best_fitness:\n                    global_best = new_particle\n                    global_best_fitness = trial_fitness\n\n            # Apply mutation as a genetic algorithm operator\n            for i in range(self.population_size):\n                mutated = self.mutate(population[i])\n                mutated_fitness = func(mutated)\n                self.eval_count += 1\n                if mutated_fitness < fitness[i]:\n                    population[i] = mutated\n                    fitness[i] = mutated_fitness\n\n        return global_best", "name": "SwarmEnhancedGA", "description": "Swarm-Enhanced Genetic Algorithm (SEGA) combines particle swarm optimization principles with genetic algorithm operators to efficiently explore and exploit the search space in black box optimization.", "configspace": "", "generation": 18, "fitness": 0.16721550366714463, "feedback": "The algorithm SwarmEnhancedGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.21.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.40733400927247165, 0.3943920933460858, 0.6693894557578735, 0.3620264257216592, 0.33898183876254806, 0.2341686611207464, 0.6795668579712819, 0.7167346686632226, 0.22923118813600052, 9.999999999998899e-05, 9.999999999998899e-05, 0.06953683532414856, 0.04403564062502374, 0.04479134679566921, 0.042999263466275806, 0.2678395277792829, 0.050158176403048094, 9.999999999998899e-05, 0.054978644945199995, 0.05993942066249858, 0.05202720610319689, 0.054478340458545826, 0.13842589309996944, 0.048576315662912206, 0.05920960582219992, 0.053234066336187214, 0.0877635399357416, 0.0393124788144521, 0.034373977156176405, 0.03986547814452368, 0.06316559602623673, 0.05002621733082435, 0.04301948789171417, 0.04291017043344891, 0.04342330083865453, 0.022900545599115474, 0.9928337543444559, 0.9927348256627635, 0.9929381949911039, 0.9894622706637001, 0.9760759722186585, 0.9901351836109171, 0.9898024142595787, 0.9903971053148463, 0.9917575499756962, 0.11181913857900805, 0.14205510904029273, 0.09529339918162383, 0.13403957587911464, 0.11776301165170044, 0.11530816349468753, 0.10691579017519437, 0.08013269808562251, 0.10515206927496024, 0.1817309476197695, 0.16458819948917847, 0.14791350172261442, 0.1797949594312095, 0.16103365413079662, 0.14900848257932742, 0.2228878241111205, 0.17326923563117758, 0.123898916702189, 9.999999999998899e-05, 0.183403563052158, 0.12102709290409186, 0.05348551524048417, 0.12116237533807939, 0.1250640625780015, 0.025589143134657544, 0.12383420372189302, 0.07830173004075947, 0.10893385390562105, 0.015223792515251633, 0.1611615824038154, 0.14408651810860684, 0.12483740078668437, 0.15921469886686557, 0.11807867104459546, 9.999999999998899e-05, 0.03318957308319492, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0237869447054192, 0.020658142895145337, 0.06893380932225879, 0.07473580485508335, 9.999999999998899e-05, 0.0466742247500761, 0.11560740473133535, 0.1008774483746534, 0.0037971930001664544, 0.021481557695419373, 0.01708971374594026, 9.999999999998899e-05, 0.03323086685204635, 9.999999999998899e-05, 0.0507347216136903, 9.999999999998899e-05, 0.07307459389521298, 0.06614256158170173, 9.999999999998899e-05, 0.005777489009941572, 0.21199337749716185, 0.00601082480446935, 0.002421773104209879, 0.004363946840633792, 0.047929394149173854, 0.008708505789335685, 0.013595048708494817, 0.3719124677881921, 0.30863917630453297, 0.4289138953126381, 0.21248746404938168, 0.44604898487975975, 0.3793818362794722, 0.38827956149293885, 0.3858020882313372, 0.4468387854403013, 0.05919925583829411, 0.04937894224068673, 0.05542141093261688, 0.05797523622803746, 0.03798555950917448, 0.07674027283088292, 0.0773679234539415, 0.05052795487930839, 0.04742901821680423, 0.13974556609761368, 0.14201101301060348, 0.13388021084673873, 0.15946615884622262, 0.1296108017736255, 0.17775333628920875, 0.17045640548282082, 0.15307996949304803, 0.16415294071967523, 0.15356778129143422, 0.21292965257271768, 0.20388336235865578, 0.1730337609287269, 0.20764280108926447, 0.24769767015401323, 0.18875970912304418, 0.16153260433087413, 0.15889016321065375, 0.15247413522330222, 0.13197416807281648, 0.1187040230281795, 0.11557166890334958, 0.125567435031686, 0.12197674269191516, 0.11591868550383788, 0.118483309110478, 0.08505748089086718, 0.15379144120354393, 0.1611884284166858, 0.15850087812698876, 0.15320591155152874, 0.1704288745467749, 0.16053453426390774, 0.16804621136459663, 0.16016283445643398, 0.1582094035720214, 0.1553399361860467, 0.18304681663952904, 0.16932710031151021, 0.1447930175054698, 0.1766069997293609, 0.18431722456963384, 0.18864995512662008, 0.18522324357395714, 0.1693720368190278, 0.5270343403832077, 0.12876398131194278, 0.13644793277931988, 0.23515285895581095, 0.1946984496057551, 0.17380888756788304, 0.1270626173778564, 0.11982212052357333, 0.14242363350576437, 0.12583124835348314, 0.16580375521966417, 0.09354219643932016, 0.20807968585124126, 0.16669360149562673, 0.20008396406876583, 0.1942002318684949, 0.16966169028491462, 0.09401309078926512, 0.21775015431221056, 0.16894926267002464, 0.18351736757515325, 0.1787900949251403, 0.18864962202093938, 0.17346889286283618, 0.16444122013773044, 0.198085245321304, 0.19075162020247793, 0.05211195242592492, 0.06940538656648054, 0.05788324123492783, 0.0712455985206083, 0.060334654301889334, 0.04933070558335362, 0.07177181957443168, 0.05567194776665563, 0.04469213489737378]}, "mutation_prompt": null}
{"id": "f9c66552-3731-4746-9bfb-c631f56cecb6", "solution": "import numpy as np\n\nclass QIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 3 * dim)\n        self.eval_count = 0\n        self.alpha = 0.99  # Learning rate for rotation gates\n        self.q_population = np.random.rand(self.population_size, self.dim, 2)\n        self.q_population /= np.linalg.norm(self.q_population, axis=2, keepdims=True)\n\n    def observe(self, q_individual):\n        probabilities = q_individual[:, 0]**2\n        return np.where(probabilities > np.random.rand(self.dim), self.upper_bound, self.lower_bound)\n\n    def evaluate_population(self, population, func):\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += len(population)\n        return fitness\n\n    def update_quantum_population(self, q_individual, best_solution, individual):\n        for i in range(self.dim):\n            if best_solution[i] != individual[i]:\n                theta = -self.alpha if best_solution[i] == self.upper_bound else self.alpha\n                cos_theta = np.cos(theta)\n                sin_theta = np.sin(theta)\n                q0, q1 = q_individual[i]\n                q_individual[i] = [cos_theta * q0 - sin_theta * q1, sin_theta * q0 + cos_theta * q1]\n        q_individual /= np.linalg.norm(q_individual, axis=1, keepdims=True)\n\n    def __call__(self, func):\n        population = np.array([self.observe(q_ind) for q_ind in self.q_population])\n        fitness = self.evaluate_population(population, func)\n        \n        while self.eval_count < self.budget:\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n            \n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                trial = self.observe(self.q_population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                self.update_quantum_population(self.q_population[i], best_solution, population[i])\n        \n        return population[np.argmin(fitness)]", "name": "QIEA", "description": "Quantum-Inspired Evolutionary Algorithm (QIEA) utilizing quantum bit representation and quantum rotation gates to explore and exploit the search space efficiently.", "configspace": "", "generation": 19, "fitness": 0.06343872682400085, "feedback": "The algorithm QIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.20.", "error": "", "parent_id": "e85d1676-7c64-48c4-9a0c-6fad000dbbc9", "metadata": {"aucs": [0.015284030932687376, 0.015307060093789349, 0.015314013848291674, 0.059360397844246626, 0.05942916965306444, 0.059497120599831255, 0.0316449580691055, 0.03165547598463003, 0.03160017458855002, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.99897, 0.996785, 0.999615, 0.9881368166528351, 0.9965692891814735, 0.9972575, 0.9971572489631858, 0.998449260205674, 0.9989500601671679, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05807360770933223, 0.05838993072199172, 0.058345833627889254, 0.060660790422129685, 0.06065673293195051, 0.060622458838568094, 0.08500132113393433, 0.08499011079907026, 0.08497103874782663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09303423916541209, 0.0933472805355563, 0.09338302773350482, 0.0766340064181279, 0.07669349047779583, 0.07659955543818564, 0.0727550607251769, 0.0729368872927072, 0.0728608706136622, 0.06678843362602516, 0.06677354319177342, 0.06681402934164105, 0.08246170079743065, 0.08234257880078533, 0.08249158513437216, 0.08265345214203113, 0.08256943799190686, 0.08266784484366452, 0.02011591707247684, 0.01961520228091007, 0.02015453860109484, 0.04119906331402212, 0.04118690881547116, 0.04117684408518785, 0.028589975488939712, 0.028673880879046543, 0.028581903156116306, 0.05065964394730749, 0.05068134832667126, 0.05076663885704924, 0.03378738496231504, 0.03376049410122772, 0.033780710614201404, 0.042597318959515906, 0.04256901652467493, 0.03662223739299297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07629000192989055, 0.07637486396863002, 0.07642828562033988, 0.03307732156396925, 0.03305700586268134, 0.03308703901393806, 0.018160931249444512, 0.01817427620529366, 0.01817396701163876, 0.013883177841624295, 0.013873386371037633, 0.013860488485394673, 0.014705045592478205, 0.014807219346546163, 0.014812157941841764, 0.016818259369804633, 0.0168046377519111, 0.016781201517896083, 0.11292509422841412, 0.11291768101946331, 0.11287096513122308, 0.15019555767280268, 0.15022022358137943, 0.15010538723907063, 0.13689443128842194, 0.13693088607045045, 0.13691504774239416, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05]}, "mutation_prompt": null}
