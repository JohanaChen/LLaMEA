{"id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 27, in __call__\nIndexError: index 10 is out of bounds for axis 0 with size 10\n.", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 27, in __call__\nIndexError: index 10 is out of bounds for axis 0 with size 10\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "7dd6a5cb-c361-4382-a542-7fa0d7ec88c7", "solution": "import numpy as np\nimport random\n\nclass HPCSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < self.refine_probability:\n                for k in range(self.dim):\n                    if random.random() < 0.5:\n                        self.best_solution[k] += random.uniform(-1.0, 1.0)\n                    else:\n                        self.best_solution[k] += random.uniform(-1.0, 1.0) * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPCSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Cuckoo Search algorithm and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and a probability-based refinement of the selected solution.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "5c31f1e7-a62b-4cb6-a5d9-81634fce4914", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            for k in range(self.dim):\n                if random.random() < self.probability:\n                    self.best_solution[k] = np.random.uniform(-5.0, 5.0)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "b629cd32-ed26-4491-8c6b-7ae6957af7e1", "solution": "import numpy as np\nimport random\n\nclass AHPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.probability:\n                    self.harmony_memory[j] = np.random.uniform(-5.0, 5.0, self.dim)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "AHPSO", "description": "A novel metaheuristic algorithm, called Adaptive Harmony Particle Swarm Optimization (AHPSO), which combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, incorporates a dynamic adaptation of the harmony memory size, and uses a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "2d8ca84b-04ce-4c27-8255-6d836297ef17", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.5\n        self.crossover_prob = 0.5\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < self.mutation_prob:\n                        x[k] = self.harmony_memory[j, k] + random.uniform(-1, 1)\n                    else:\n                        x[k] = self.best_solution[k] + random.uniform(-1, 1)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    self.best_solution[k] += random.uniform(-1, 1)\n                fitness = func(self.best_solution)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    self.best_solution[k] += random.uniform(-1, 1)\n                fitness = func(self.best_solution)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the mutation and crossover probabilities based on the fitness of the solutions.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "925e9c25-272f-437e-8899-f3bb39911b4a", "solution": "import numpy as np\nimport random\n\nclass HPSO_AR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.refine_prob = 0.05\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            \n            # Refine the selected solution with a probability of 0.05\n            if random.random() < self.refine_prob:\n                self.selected_solution = self.selected_solution + np.random.uniform(-1.0, 1.0, self.dim)\n                self.selected_solution = np.clip(self.selected_solution, -5.0, 5.0)\n                fitness = func(self.selected_solution)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = self.selected_solution\n            \n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_AR", "description": "A novel metaheuristic algorithm, called Harmony PSO with Adaptive Refinement (HPSO-AR), that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, incorporates a dynamic adaptation of the harmony memory size, and includes a probability-based refinement mechanism to adaptively adjust the selected solution's strategy.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "9a9cbf6a-7653-4dda-8c06-f2270e04228c", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.probability:\n                    for k in range(self.dim):\n                        self.best_solution[k] = np.random.uniform(-5.0, 5.0)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability to change individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "7ec053e3-2762-461d-88b3-06c9872e5db6", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            # Probability of 0.05 to change the individual lines of the selected solution\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        self.best_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n                    else:\n                        self.best_solution[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "71cf00f5-7062-48df-9143-91be95dd0a0d", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.probability:\n                    self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "c31a4102-2094-4e2f-85fa-a95f521e4716", "solution": "import numpy as np\nimport random\n\nclass AHPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < self.probability:\n                for k in range(self.dim):\n                    self.best_solution[k] += np.random.uniform(-1, 1)\n                    if self.best_solution[k] < -5.0:\n                        self.best_solution[k] = -5.0\n                    elif self.best_solution[k] > 5.0:\n                        self.best_solution[k] = 5.0\n        return self.best_solution", "name": "AHPSO", "description": "A novel metaheuristic algorithm, Adaptive Harmony Particle Swarm Optimization (AHPSO), that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and introduces a probability-based refinement mechanism to update the best solution.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "1b3f4f80-c62a-4985-8646-519835cde993", "solution": "import numpy as np\nimport random\n\nclass AHPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.selected_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < 0.05:\n                self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n                self.selected_fitness = float('inf')\n            for k in range(self.dim):\n                r1 = random.random()\n                r2 = random.random()\n                if r1 < 0.5:\n                    self.selected_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] + self.w * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                else:\n                    self.selected_solution[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n            self.selected_fitness = func(self.selected_solution)\n            if self.selected_fitness < self.selected_fitness:\n                self.selected_solution = self.selected_solution\n                self.selected_fitness = self.selected_fitness\n            if self.selected_fitness < self.best_fitness:\n                self.best_fitness = self.selected_fitness\n                self.best_solution = self.selected_solution\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "AHPSO", "description": "Adaptive Harmony Particle Swarm Optimization (AHPSO) algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "98dcfaf7-9448-4c36-8101-472eeac29bf6", "solution": "import numpy as np\nimport random\n\nclass DEHPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.copy(self.harmony_memory[j])\n                for k in range(self.dim):\n                    if random.random() < self.probability:\n                        x[k] = np.random.uniform(-5.0, 5.0)\n                F = random.random()\n                r1 = random.randint(0, self.swarm_size - 1)\n                r2 = random.randint(0, self.swarm_size - 1)\n                r3 = random.randint(0, self.swarm_size - 1)\n                v = x + F * (self.harmony_memory[r1] - self.harmony_memory[r2]) + F * (self.harmony_memory[r3] - self.harmony_memory[r2])\n                v = np.clip(v, -5.0, 5.0)\n                fitness = func(v)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = v\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DEHPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and the probability to change the individual lines of the selected solution.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 34 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 34 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "ace2fd11-63b3-4627-a7c1-71b8e7a3c3cf", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < self.probability:\n                self.best_solution += np.random.uniform(-1.0, 1.0, self.dim)\n                self.best_solution = np.clip(self.best_solution, -5.0, 5.0)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            self.budget -= 1\n            if self.budget == 0:\n                break\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and refines its strategy by perturbing the best solution with a probability of 0.05.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "8d6c28e6-6341-4a69-9c89-af02edaa5559", "solution": "import numpy as np\nimport random\n\nclass HSHDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if random.random() < self.probability:\n                    k = random.randint(0, self.dim - 1)\n                    x[k] = self.harmony_memory[j, k] + (self.best_solution[k] - self.harmony_memory[j, k]) * random.random()\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HSHDE", "description": "A novel metaheuristic algorithm that combines the Harmony Search algorithm with the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, as well as a probability of changing individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "c5559058-783e-4a4c-a2c6-fc0ddfa5dd56", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.refine_prob = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.refine_prob:\n                    self.refine_solution(x, func)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\n    def refine_solution(self, x, func):\n        for k in range(self.dim):\n            r1 = random.random()\n            r2 = random.random()\n            if r1 < 0.5:\n                x[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] + self.w * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] - x[k])\n            else:\n                x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n        fitness = func(x)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = x", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Cuckoo Search algorithm, and incorporates a dynamic adaptation of the solution refinement based on the fitness of the solutions.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "dc9df37b-9602-451b-8d9c-c0c8059160d2", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_change = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                # Change individual lines with probability\n                if random.random() < self.prob_change:\n                    for k in range(self.dim):\n                        if random.random() < 0.5:\n                            x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                        else:\n                            x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and a probability to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "6df19db1-69b3-4f87-b051-a0fa0ed1c536", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < 0.5:\n                        self.best_solution[k] = self.best_solution[k] + np.random.uniform(-1.0, 1.0)\n                    else:\n                        self.best_solution[k] = self.best_solution[k] + np.random.uniform(-1.0, 1.0)\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and incorporates a probability-based refinement of the selected solution.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "30746ebe-f843-4206-9ad2-402193a13ee7", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.refine_probability:\n                    self.refine_solution(x, func)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\n    def refine_solution(self, x, func):\n        for k in range(self.dim):\n            r1 = random.random()\n            r2 = random.random()\n            if r1 < 0.5:\n                x[k] = x[k] + self.w * (self.best_solution[k] - x[k]) + self.c1 * random.random() * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n            else:\n                x[k] = x[k] + self.w * (self.best_solution[k] - x[k]) + self.c2 * random.random() * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] - x[k])\n        fitness = func(x)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness\n            self.best_solution = x", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, along with a probability-based refinement strategy to adaptively adjust the algorithm's strategy.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "b4f19ac7-0052-4df0-aba7-c5a3ed687f7c", "solution": "import numpy as np\nimport random\n\nclass ADHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < self.probability:\n                self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "ADHS", "description": "A novel metaheuristic algorithm, called Adaptive Differential Harmony Search (ADHS), that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and a probability to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "ee8a9814-7e2f-4fef-9457-22f1e12ed6f2", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_change = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.prob_change:\n                    for k in range(self.dim):\n                        self.best_solution[k] += random.uniform(-1, 1)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the population size based on the fitness of the solutions, and also a probability of changing the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "75c80b41-a6d9-49e6-a247-89dc102dc19f", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < self.probability:\n                self.probability_refine(func)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\n    def probability_refine(self, func):\n        for k in range(self.dim):\n            r1 = random.random()\n            if r1 < 0.5:\n                self.best_solution[k] += np.random.uniform(-1.0, 1.0)\n            else:\n                self.best_solution[k] -= np.random.uniform(-1.0, 1.0)\n        fitness = func(self.best_solution)\n        if fitness < self.best_fitness:\n            self.best_fitness = fitness", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability-based strategy refinement mechanism to further improve the best solution found.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "f3e77bda-02cb-459f-b498-ad4e3754a79c", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.copy(self.best_solution)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < 0.05:\n                        x[k] = np.random.uniform(-5.0, 5.0)\n                    elif r1 < 0.1:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Genetic Algorithm, and incorporates a dynamic adaptation of the mutation probability based on the fitness of the solutions.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "3306a6cf-36eb-4f7f-8c10-ba51c7741a72", "solution": "import numpy as np\nimport random\n\nclass HSDM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_change = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if random.random() < self.prob_change:\n                    k = random.randint(0, self.dim - 1)\n                    x[k] = np.random.uniform(-5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HSDM", "description": "A novel metaheuristic algorithm that combines the Harmony Search algorithm with the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "a08e7248-a9f5-4907-8ed7-6cae2d5a1228", "solution": "import numpy as np\nimport random\n\nclass ADHM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.selected_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < 0.05:\n                    self.selected_solution = x\n                    self.selected_fitness = fitness\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n                print(f\"Selected solution fitness: {self.selected_fitness}\")\n        if self.selected_fitness < self.best_fitness:\n            return self.selected_solution\n        else:\n            return self.best_solution", "name": "ADHM", "description": "A novel metaheuristic algorithm, called Adaptive Harmony-PSO with Dynamic Harmony Memory (ADHM), that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and a refinement strategy to update the selected solution with a probability of 0.05.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "fb34dbd8-6161-4e4b-82c9-0304659a1d6e", "solution": "import numpy as np\nimport random\n\nclass HPCSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.copy(self.harmony_memory[j])\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < 0.05:\n                        x[k] = np.random.uniform(-5.0, 5.0)\n                    elif r1 < 0.1:\n                        x[k] = self.best_solution[k] + np.random.uniform(-1.0, 1.0)\n                    else:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPCSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Cuckoo Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, as well as a probability of changing individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "558c46f3-358e-43b2-b037-f59165e8d348", "solution": "import numpy as np\nimport random\n\nclass AHDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.mutation_strategy = 'DE'\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.copy(self.best_solution)\n                if random.random() < 0.05:\n                    # Refine the strategy of the selected solution\n                    self.mutation_strategy = 'HS' if random.random() < 0.5 else 'DE'\n                if self.mutation_strategy == 'DE':\n                    # Differential Evolution mutation strategy\n                    r1, r2, r3 = random.sample(range(self.swarm_size), 3)\n                    x = x + self.c1 * (self.harmony_memory[r1] - x) + self.c2 * (self.harmony_memory[r2] - self.harmony_memory[r3])\n                elif self.mutation_strategy == 'HS':\n                    # Harmony Search mutation strategy\n                    for k in range(self.dim):\n                        r1 = random.random()\n                        r2 = random.random()\n                        if r1 < 0.5:\n                            x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                        else:\n                            x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                x = np.clip(x, -5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "AHDE", "description": "A novel metaheuristic algorithm, called Adaptive Hybrid Differential Evolution (AHDE), that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the mutation strategy based on the fitness of the solutions.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 18 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 18 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "e24d61e0-ddce-4dff-9b3e-36e130bfc496", "solution": "import numpy as np\nimport random\n\nclass DE_CMAES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.max_iter = 100\n        self.cr = 0.5\n        self.c1 = 0.5\n        self.c2 = 0.5\n        self.mutation_factor = 1.0\n        self.step_size = 0.1\n        self.population = np.random.uniform(-5.0, 5.0, (self.pop_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.pop_size):\n                x = self.population[j]\n                if random.random() < self.probability:\n                    for k in range(self.dim):\n                        r1, r2, r3 = np.random.randint(0, self.pop_size, 3)\n                        x[k] = self.population[r1, k] + self.mutation_factor * (self.population[r2, k] - self.population[r3, k])\n                else:\n                    r1, r2 = np.random.randint(0, self.pop_size, 2)\n                    x = self.population[r1] + self.c1 * (self.population[r2] - self.population[np.random.randint(0, self.pop_size)])\n                x = x + self.step_size * np.random.uniform(-5.0, 5.0, self.dim)\n                x = np.clip(x, -5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.population[j] = x\n            self.mutation_factor = self.mutation_factor + (random.random() - 0.5) * 0.1\n            self.step_size = self.step_size + (random.random() - 0.5) * 0.01\n            self.probability = self.probability + (random.random() - 0.5) * 0.01\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DE_CMAES", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Covariance Matrix Adaptation Evolution Strategy algorithm, and incorporates a dynamic adaptation of the mutation and step-size based on the fitness of the solutions and the probability of changing individual lines.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "7879287e-f79d-4157-b434-8a8c28abe9ac", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    self.best_solution[k] = np.random.uniform(-5.0, 5.0)\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "5093b7be-7ce5-41b5-8775-91be873bc514", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.DE_strategy = np.random.choice(['rand/1/bin', 'best/1/bin', 'rand/2/bin', 'best/2/bin'], p=[0.05, 0.05, 0.45, 0.45])\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                if np.random.random() < 0.05 and self.DE_strategy == 'rand/1/bin':\n                    x = self.rand_1_bin(x, self.harmony_memory[j], self.best_solution)\n                elif np.random.random() < 0.05 and self.DE_strategy == 'best/1/bin':\n                    x = self.best_1_bin(x, self.harmony_memory[j], self.best_solution)\n                elif np.random.random() < 0.05 and self.DE_strategy == 'rand/2/bin':\n                    x = self.rand_2_bin(x, self.harmony_memory[j], self.best_solution)\n                elif np.random.random() < 0.05 and self.DE_strategy == 'best/2/bin':\n                    x = self.best_2_bin(x, self.harmony_memory[j], self.best_solution)\n                else:\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x = self.harmony_memory[j] + self.w * (self.harmony_memory[j] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), :])\n                    else:\n                        x = self.best_solution + self.w * (self.best_solution - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), :])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            self.DE_strategy = np.random.choice(['rand/1/bin', 'best/1/bin', 'rand/2/bin', 'best/2/bin'], p=[0.05, 0.05, 0.45, 0.45])\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\n    def rand_1_bin(self, x, x1, x2):\n        F = 0.5\n        v = F * (x2 - x1) + x1\n        u = np.random.uniform(-1, 1, self.dim)\n        return x + u * (v - x)\n\n    def best_1_bin(self, x, x1, x2):\n        F = 0.5\n        v = F * (x2 - x) + x\n        u = np.random.uniform(-1, 1, self.dim)\n        return x + u * (v - x)\n\n    def rand_2_bin(self, x, x1, x2):\n        F = 0.5\n        v1 = F * (x2 - x1) + x1\n        v2 = F * (x2 - x1) + x1\n        u = np.random.uniform(-1, 1, self.dim)\n        return x + u[0] * (v1 - x) + u[1] * (v2 - x)\n\n    def best_2_bin(self, x, x1, x2):\n        F = 0.5\n        v1 = F * (x2 - x) + x\n        v2 = F * (x2 - x) + x\n        u = np.random.uniform(-1, 1, self.dim)\n        return x + u[0] * (v1 - x) + u[1] * (v2 - x)", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the Harmony Search algorithm with the Differential Evolution algorithm and incorporates a dynamic adaptation of the harmony memory size and mutation strategy based on the fitness of the solutions.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "93c1b371-e13f-45a1-9db0-3e36021f201c", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        self.best_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n                    else:\n                        self.best_solution[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "eb376759-7e62-4cb6-9698-35573454e15b", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.DE_strategy = 'rand/1/bin'\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.05:\n                        # Refine the strategy of the selected solution\n                        if random.random() < 0.5:\n                            x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                        else:\n                            x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        if self.DE_strategy == 'rand/1/bin':\n                            x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                        elif self.DE_strategy == 'best/1/bin':\n                            x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the mutation strategy based on the fitness of the solutions.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "aa679d26-cc81-4fc5-9c65-62b94aa96554", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.DE_strategy = np.random.choice(['rand/1/bin', 'best/1/bin', 'rand/2/bin'], p=[0.05, 0.45, 0.5])\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                if np.random.rand() < 0.05:\n                    strategy = random.choice(['rand/1/bin', 'best/1/bin', 'rand/2/bin'])\n                    x = self.differential_evolution(x, func, strategy)\n                else:\n                    harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                    for k in range(self.dim):\n                        r1 = random.random()\n                        r2 = random.random()\n                        if r1 < 0.5:\n                            x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                        else:\n                            x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\n    def differential_evolution(self, x, func, strategy):\n        F = 0.5\n        CR = 0.9\n        NP = 50\n        x1 = np.random.uniform(-5.0, 5.0, self.dim)\n        x2 = np.random.uniform(-5.0, 5.0, self.dim)\n        x3 = np.random.uniform(-5.0, 5.0, self.dim)\n        if strategy == 'rand/1/bin':\n            u = np.random.randint(0, NP)\n            v = np.random.randint(0, NP)\n            while u == v:\n                v = np.random.randint(0, NP)\n            x_new = x + F * (x2 - x1)\n        elif strategy == 'best/1/bin':\n            x_new = x + F * (self.best_solution - x)\n        elif strategy == 'rand/2/bin':\n            u = np.random.randint(0, NP)\n            v = np.random.randint(0, NP)\n            while u == v:\n                v = np.random.randint(0, NP)\n            x_new = x + F * (x2 - x1) + F * (x3 - x2)\n        for k in range(self.dim):\n            r = np.random.rand()\n            if r < CR or k == np.random.randint(0, self.dim):\n                x_new[k] = np.random.uniform(-5.0, 5.0)\n        fitness = func(x_new)\n        return x_new", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "1a7f8aec-96c8-4501-8278-fae0f05f32e1", "solution": "import numpy as np\nimport random\n\nclass DEHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_change = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.copy(self.harmony_memory[j])\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] + self.w * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if random.random() < self.prob_change:\n                    idx = random.randint(0, self.dim - 1)\n                    x[idx] = np.random.uniform(-5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DEHS", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and a probability of changing individual lines of the selected solution.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "fe7ad230-24e9-49ef-ae37-ed82e3608290", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            # Refine the strategy with a probability of 0.05\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        self.best_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n                    else:\n                        self.best_solution[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "59ed5254-b62d-41b1-9e30-3e75de100005", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < self.probability:\n                        x[k] = self.harmony_memory[j, k] + np.random.uniform(-1, 1)\n                    elif r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "7db3cc8f-08d3-4866-acb7-b22941780c02", "solution": "import numpy as np\nimport random\n\nclass DEAMP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.memory_size = 10\n        self.max_iter = 100\n        self.population_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.memory = np.random.uniform(-5.0, 5.0, (self.memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.randint(0, self.population_size)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.population_size):\n                if j == self.selected_solution and random.random() < 0.05:\n                    x = self.memory[j] + np.random.uniform(-1, 1, self.dim)\n                else:\n                    x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.memory[np.random.randint(0, self.memory_size), k] + self.w * (self.memory[np.random.randint(0, self.memory_size), k] - self.memory[np.random.randint(0, self.memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.memory[np.random.randint(0, self.memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.memory[j] = x\n            self.memory_size = int(self.memory_size * (1 - (i / self.max_iter)))\n            self.memory = np.random.choice(self.memory, self.memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DEAMP", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Adaptive Memory Programming algorithm, and incorporates a dynamic adaptation of the memory size based on the fitness of the solutions, and refines its strategy with a probability of 0.05.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "7faf1f5d-d405-4874-a0fe-90b6d920d457", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    self.selected_solution[k] += random.uniform(-1, 1)\n                    if self.selected_solution[k] < -5.0:\n                        self.selected_solution[k] = -5.0\n                    elif self.selected_solution[k] > 5.0:\n                        self.selected_solution[k] = 5.0\n            if random.random() < 0.05:\n                self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    self.selected_solution[k] = self.best_solution[k] + random.uniform(-1, 1)\n                    if self.selected_solution[k] < -5.0:\n                        self.selected_solution[k] = -5.0\n                    elif self.selected_solution[k] > 5.0:\n                        self.selected_solution[k] = 5.0\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with an additional strategy refinement mechanism.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "9e827347-b275-414c-9494-106d540160b0", "solution": "import numpy as np\nimport random\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.max_iter = 100\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.particles = np.random.uniform(-5.0, 5.0, (self.pop_size, self.dim))\n        self.best_particles = np.copy(self.particles)\n        self.best_fitness = np.array([float('inf')] * self.pop_size)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.pop_size):\n                x = np.copy(self.particles[j])\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.05:\n                        # Refine the strategy of the selected solution\n                        idx = np.random.choice(self.pop_size, 1, replace=False, p=self.best_fitness / np.sum(self.best_fitness))\n                        x[k] = self.best_particles[idx][0][k] + self.w * (self.best_particles[idx][0][k] - self.particles[np.random.randint(0, self.pop_size), k])\n                    elif r2 < 0.5:\n                        x[k] = self.particles[j, k] + self.w * (self.particles[j, k] - self.particles[np.random.randint(0, self.pop_size), k])\n                    else:\n                        x[k] = self.best_particles[j, k] + self.w * (self.best_particles[j, k] - self.particles[np.random.randint(0, self.pop_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness[j]:\n                    self.best_fitness[j] = fitness\n                    self.best_particles[j] = x\n            if np.mean(self.best_fitness) < np.mean(self.best_fitness):\n                self.particles = np.copy(self.best_particles)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {np.mean(self.best_fitness)}\")\n        return self.best_particles[np.argmin(self.best_fitness)]", "name": "DEPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the population size based on the fitness of the solutions.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities contain NaN').", "error": "ValueError('probabilities contain NaN')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "67f3879b-f4e1-40f8-be19-a9ce9108e14c", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.probability:\n                    self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "fb7cafec-8b3a-451e-b241-52ef5d0fadaa", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < self.probability:\n                for k in range(self.dim):\n                    self.best_solution[k] += np.random.uniform(-1, 1)\n                    if self.best_solution[k] < -5.0:\n                        self.best_solution[k] = -5.0\n                    elif self.best_solution[k] > 5.0:\n                        self.best_solution[k] = 5.0\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "2fbb0034-4c99-4d02-b07c-74f043a113e8", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        self.best_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n                    else:\n                        self.best_solution[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and refines its strategy by randomly changing individual lines with a probability of 0.05.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "428e8200-a4db-4869-924f-0090280cf7c5", "solution": "import numpy as np\nimport random\n\nclass HybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.temperature = 1000.0\n        self.temperature_decrease_rate = 0.95\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.05:\n                        x[k] = self.best_solution[k] + np.random.uniform(-1.0, 1.0)\n                    elif r1 < 0.1:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if np.random.random() < 0.05:\n                    x += np.random.uniform(-1.0, 1.0, self.dim)\n                if np.random.random() < 0.05:\n                    x -= np.random.uniform(-1.0, 1.0, self.dim)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            self.temperature *= self.temperature_decrease_rate\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HybridPSO", "description": "A novel metaheuristic algorithm that combines the Harmony Search and Simulated Annealing algorithms with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size and temperature based on the fitness of the solutions.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "cf74589a-72a3-4f4e-9d8c-06324f977727", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.DE_population = np.random.uniform(-5.0, 5.0, (self.swarm_size, self.dim))\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.copy(self.DE_population[j])\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.05:\n                        x[k] = np.random.uniform(-5.0, 5.0)\n                    else:\n                        if r2 < 0.5:\n                            x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                        else:\n                            x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            self.DE_population = np.random.uniform(-5.0, 5.0, (self.swarm_size, self.dim))\n            for k in range(self.swarm_size):\n                for l in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    r3 = random.random()\n                    if r1 < 0.5:\n                        self.DE_population[k, l] = self.DE_population[k, l] + r2 * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), l] - self.DE_population[np.random.randint(0, self.swarm_size), l])\n                    else:\n                        self.DE_population[k, l] = self.DE_population[k, l] + r2 * (self.best_solution[l] - self.DE_population[np.random.randint(0, self.swarm_size), l])\n                    if r3 < 0.5:\n                        self.DE_population[k, l] = self.DE_population[k, l] + r2 * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), l] - self.DE_population[np.random.randint(0, self.swarm_size), l])\n                    else:\n                        self.DE_population[k, l] = self.DE_population[k, l] + r2 * (self.best_solution[l] - self.DE_population[np.random.randint(0, self.swarm_size), l])\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "d06d37fe-faed-482e-859f-92dbf1eaff51", "solution": "import numpy as np\nimport random\n\nclass DEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.F = 0.5\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution_index = np.random.randint(0, self.population_size)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.population_size):\n                if random.random() < 0.05:\n                    self.population[j] = self.population[self.selected_solution_index]\n                x = self.population[j] + self.F * (self.population[np.random.randint(0, self.population_size), :] - self.population[np.random.randint(0, self.population_size), :])\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.population[j, k] + self.w * (self.population[j, k] - self.population[np.random.randint(0, self.population_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.population[np.random.randint(0, self.population_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.population[j] = x\n            self.selected_solution_index = np.random.randint(0, self.population_size)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if self.population_size > 10 and self.best_fitness < 0.1:\n                self.population_size = int(self.population_size * 0.9)\n                self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        return self.best_solution", "name": "DEPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the population size based on the fitness of the solutions.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 13 is out of bounds for axis 0 with size 13').", "error": "IndexError('index 13 is out of bounds for axis 0 with size 13')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "8ab862fa-ad91-46c1-86b2-724d03293613", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < 0.05:\n                    self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "dba38cf0-e423-45b8-97dd-4d4438d59c7d", "solution": "import numpy as np\nimport random\n\nclass DECS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.max_iter = 100\n        self.f = 0.5\n        self.a = 0.01\n        self.b = 0.01\n        self.x = np.random.uniform(-5.0, 5.0, (self.pop_size, self.dim))\n        self.y = np.copy(self.x)\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.pop_size):\n                r1 = random.random()\n                r2 = random.random()\n                if r1 < 0.05:\n                    x = self.y[j]\n                    for k in range(self.dim):\n                        x[k] = self.x[np.random.randint(0, self.pop_size), k] + self.f * (self.x[np.random.randint(0, self.pop_size), k] - self.x[np.random.randint(0, self.pop_size), k])\n                else:\n                    x = self.x[j]\n                    v1 = self.x[np.random.randint(0, self.pop_size), np.random.randint(0, self.dim)]\n                    v2 = self.x[np.random.randint(0, self.pop_size), np.random.randint(0, self.dim)]\n                    for k in range(self.dim):\n                        x[k] = v1[k] + self.a * (v1[k] - v2[k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.y[j] = x\n            self.x = np.copy(self.y)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DECS", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Cuckoo Search algorithm, and incorporates a dynamic adaptation of the cuckoo eggs based on the fitness of the solutions.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "dae2150e-e842-4bda-b5c1-3f0063437fd4", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.de_size = 5\n        self.f = 0.5\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < 0.05:\n                        x[k] = np.random.uniform(-5.0, 5.0)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    r3 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                v1 = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] + self.f * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                v2 = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] + self.f * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                v3 = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] + self.f * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                x[k] = x[k] + self.c1 * (v1 - self.harmony_memory[j, k]) + self.c2 * (v2 - self.harmony_memory[j, k]) + self.c2 * (v3 - self.harmony_memory[j, k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "8b6076aa-8501-45f7-90b1-1d792c2e830d", "solution": "import numpy as np\nimport random\n\nclass AHSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.selected_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < 0.05 and fitness < self.selected_fitness:\n                    self.selected_fitness = fitness\n                    self.selected_solution = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}, Selected fitness: {self.selected_fitness}\")\n        return self.best_solution", "name": "AHSO", "description": "A novel metaheuristic algorithm, called \"Adaptive Harmony Swarm Optimization\" (AHSO), that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size and a probability-based refinement of the selected solution.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "e5ca45e7-82e3-4c7b-b292-ba273b932bb2", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.DE_size = 20\n        self.DE_dim = dim\n        self.DE_best_solution = np.random.uniform(-5.0, 5.0, self.DE_dim)\n        self.DE_best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            for _ in range(self.DE_size):\n                x = np.random.uniform(-5.0, 5.0, self.DE_dim)\n                y = np.random.uniform(-5.0, 5.0, self.DE_dim)\n                z = np.random.uniform(-5.0, 5.0, self.DE_dim)\n                for k in range(self.DE_dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = y[k] + self.c1 * (z[k] - y[k]) + self.c2 * (self.DE_best_solution[k] - y[k])\n                    else:\n                        x[k] = y[k] + self.c1 * (z[k] - y[k]) + self.c2 * (self.DE_best_solution[k] - z[k])\n                fitness = func(x)\n                if fitness < self.DE_best_fitness:\n                    self.DE_best_fitness = fitness\n                    self.DE_best_solution = x\n                if random.random() < self.probability:\n                    for k in range(self.dim):\n                        self.best_solution[k] = self.DE_best_solution[k]\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size and the probability of changing individual lines of the selected solution based on the fitness of the solutions.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "2fcd0384-eadf-47ab-b3c8-a0a5d586a3fd", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < self.refine_probability:\n                for k in range(self.dim):\n                    if random.random() < 0.5:\n                        self.best_solution[k] += np.random.uniform(-1.0, 1.0)\n                    else:\n                        self.best_solution[k] -= np.random.uniform(-1.0, 1.0)\n                fitness = func(self.best_solution)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability-based refinement of the best solution.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "bc860454-cbd0-48fa-bcf8-e4a3c4ebf646", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_change = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if np.random.rand() < self.prob_change:\n                    idx = np.random.randint(0, self.dim)\n                    x[idx] = np.random.uniform(-5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and also incorporates a probability to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "f7090c87-81b7-4511-b6fd-99495604dc21", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < self.probability:\n                for k in range(self.dim):\n                    self.best_solution[k] += np.random.uniform(-1, 1)\n                    if self.best_solution[k] < -5.0:\n                        self.best_solution[k] = -5.0\n                    elif self.best_solution[k] > 5.0:\n                        self.best_solution[k] = 5.0\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size and a probability to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "673bdbba-b666-4bf0-9507-2126a4f76979", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.probability:\n                    for k in range(self.dim):\n                        r1 = random.random()\n                        r2 = random.random()\n                        if r1 < 0.5:\n                            self.best_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n                        else:\n                            self.best_solution[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with an adaptive probability to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "90d60160-8fd6-403e-97dd-b65dc68e884f", "solution": "import numpy as np\nimport random\n\nclass AH2DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    self.selected_solution[k] += random.uniform(-1, 1)\n                fitness = func(self.selected_solution)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = self.selected_solution\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "AH2DE", "description": "Adaptive Hybrid Harmony Search and Differential Evolution (AH2DE) algorithm, which combines the exploration capabilities of Harmony Search with the exploitation capabilities of Differential Evolution, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and also refines the strategy of the selected solution with a probability of 0.05.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "b3f1a448-0145-4148-a20a-5af17d5766c1", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.probability:\n                    for k in range(self.dim):\n                        if random.random() < 0.5:\n                            self.best_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n                        else:\n                            self.best_solution[k] = x[k]\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Cuckoo Search algorithm and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and a probability to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "87bda05e-12ce-42c6-91f7-3f91d0589d0e", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.probability:\n                    for k in range(self.dim):\n                        self.best_solution[k] = np.random.uniform(-5.0, 5.0)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability of changing the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "51e001ff-7c4d-4bbc-8b63-0eb2fb3183ab", "solution": "import numpy as np\nimport random\n\nclass HPSOPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.probability:\n                    self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\n# Usage example:\n# hpsoplus = HPSOPlus(1000, 10)\n# best_solution = hpsoplus(lambda x: np.sum(x**2))\n# print(best_solution)", "name": "HPSOPlus", "description": "A novel metaheuristic algorithm, called HPSO+, that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and uses a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "080af2ab-95c3-4122-8056-36e4ce42eedd", "solution": "import numpy as np\nimport random\n\nclass HPCSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.selected_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < 0.05:\n                self.selected_solution = self.best_solution.copy()\n                self.selected_fitness = self.best_fitness\n            for k in range(self.dim):\n                r1 = random.random()\n                r2 = random.random()\n                if r1 < 0.5:\n                    self.selected_solution[k] = self.selected_solution[k] + r2 * (self.best_solution[k] - self.selected_solution[k])\n                else:\n                    self.selected_solution[k] = self.selected_solution[k] + r2 * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] - self.selected_solution[k])\n            fitness = func(self.selected_solution)\n            if fitness < self.selected_fitness:\n                self.selected_fitness = fitness\n                self.selected_solution = self.selected_solution\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}, Selected fitness: {self.selected_fitness}\")\n        return self.best_solution", "name": "HPCSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Cuckoo Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability-based refinement of the selected solution.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "067585a8-ecb4-4392-afe5-a7df3f4710f9", "solution": "import numpy as np\nimport random\n\nclass HPCSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if random.random() < self.probability:\n                    for k in range(self.dim):\n                        x[k] = np.random.uniform(-5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPCSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Cuckoo Search algorithm and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "344c929f-e077-46f6-ae8e-0ddb43c0eaaf", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.population = np.random.uniform(-5.0, 5.0, (self.swarm_size, self.dim))\n        self.fitness = np.zeros(self.swarm_size)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.copy(self.population[j])\n                for k in range(self.dim):\n                    if random.random() < 0.05:\n                        x[k] = self.population[np.random.randint(0, self.swarm_size), k] + random.uniform(-1, 1)\n                fitness = func(x)\n                if fitness < self.fitness[j]:\n                    self.fitness[j] = fitness\n                    self.population[j] = x\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            for j in range(self.swarm_size):\n                x = np.copy(self.population[j])\n                for k in range(self.dim):\n                    r1 = random.randint(0, self.swarm_size - 1)\n                    r2 = random.randint(0, self.swarm_size - 1)\n                    r3 = random.randint(0, self.swarm_size - 1)\n                    x[k] = x[k] + self.c1 * (self.population[r1, k] - x[k]) + self.c2 * (self.population[r2, k] - self.population[r3, k])\n                self.population[j] = x\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the population size based on the fitness of the solutions.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "e36f0fc5-3c02-49de-aa96-fdd038ab3a72", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.refine_prob = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < self.refine_prob:\n                self.refine_solution()\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\n    def refine_solution(self):\n        for k in range(self.dim):\n            r1 = random.random()\n            if r1 < 0.5:\n                self.best_solution[k] = self.best_solution[k] + np.random.uniform(-1, 1)\n            else:\n                self.best_solution[k] = self.best_solution[k] + np.random.uniform(-1, 1) * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n        self.best_fitness = func(self.best_solution)", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability-based refinement strategy.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "440d3398-2a71-4b72-b5d5-4be91afa78aa", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            # Refine strategy with a probability of 0.05\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < 0.5:\n                        self.best_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n                    else:\n                        self.best_solution[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "268ddc94-6ad8-457c-980a-0f9d19daff93", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if random.random() < self.probability:\n                    x[k] = np.random.uniform(-5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Cuckoo Search algorithm, and incorporates a dynamic adaptation of the step size based on the fitness of the solutions.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "4c5a584e-5610-4db4-b493-fa463b21b3e9", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            \n            # Update the selected solution with a probability of 0.05\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    self.selected_solution[k] = self.best_solution[k] + np.random.uniform(-1, 1) * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(self.selected_solution)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = self.selected_solution\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Cuckoo Search algorithm, and incorporates a dynamic adaptation of the cuckoo egg laying strategy based on the fitness of the solutions.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "2d5755f0-27b0-4aa2-9012-b40c1811f791", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < self.probability:\n                k = np.random.randint(0, self.dim)\n                self.best_solution[k] = np.random.uniform(-5.0, 5.0)\n        return self.best_solution\n\nclass DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.max_iter = 100\n        self.f = 0.5\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.population_size):\n                x = self.population[j] + self.f * (self.population[np.random.randint(0, self.population_size), :] - self.population[np.random.randint(0, self.population_size), :])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.population[j] = x\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n        self.de = DE(budget, dim)\n        self.de_population = np.random.uniform(-5.0, 5.0, (self.swarm_size, self.dim))\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < self.probability:\n                k = np.random.randint(0, self.dim)\n                self.best_solution[k] = np.random.uniform(-5.0, 5.0)\n            for j in range(self.swarm_size):\n                x = self.de_population[j] + self.de.f * (self.de.population[np.random.randint(0, self.de.population_size), :] - self.de.population[np.random.randint(0, self.de.population_size), :])\n                fitness = func(x)\n                if fitness < self.de.best_fitness:\n                    self.de.best_fitness = fitness\n                    self.de.best_solution = x\n                self.de.population[j] = x\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, DE Best fitness: {self.de.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the Harmony Search algorithm with the Differential Evolution algorithm and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and the probability of changing the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "e49ad035-6986-49b5-a296-2338e972462f", "solution": "import numpy as np\nimport random\n\nclass DEHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_change = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < self.prob_change:\n                        x[k] = self.harmony_memory[j, k] + np.random.uniform(-1, 1)\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            self.budget -= 1\n            if self.budget <= 0:\n                break\n        return self.best_solution", "name": "DEHS", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and a probability of changing the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "eea8a646-6d33-4425-92b9-852d89ab0be6", "solution": "import numpy as np\nimport random\n\nclass DEHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.copy(self.harmony_memory[j])\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < self.probability:\n                        x[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] + np.random.uniform(-1, 1)\n                    elif r1 < 0.3:\n                        x[k] = self.best_solution[k] + np.random.uniform(-1, 1)\n                    else:\n                        r2 = random.randint(0, self.swarm_size - 1)\n                        r3 = random.randint(0, self.swarm_memory_size - 1)\n                        x[k] = self.harmony_memory[r2, k] + self.w * (self.harmony_memory[r3, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if np.sum(np.isinf(self.harmony_memory)) > 0 or np.sum(np.isnan(self.harmony_memory)) > 0:\n                self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        return self.best_solution", "name": "DEHS", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'DEHS' object has no attribute 'swarm_memory_size'\").", "error": "AttributeError(\"'DEHS' object has no attribute 'swarm_memory_size'\")", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "2becf505-5d01-4091-9d2b-580e78595185", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < self.probability:\n                for k in range(self.dim):\n                    self.best_solution[k] = self.best_solution[k] + np.random.uniform(-1, 1)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\nclass HPSO_refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < self.probability:\n                for k in range(self.dim):\n                    if random.random() < 0.5:\n                        self.best_solution[k] = self.best_solution[k] + np.random.uniform(-1, 1)\n                    else:\n                        self.best_solution[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability-based refinement of the selected solution.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "ad952cfb-5ef7-4654-b7ab-5199f27b5e8c", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.probability:\n                    k = random.randint(0, self.dim-1)\n                    self.best_solution[k] = np.random.uniform(-5.0, 5.0)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "d67c181b-2c13-4be8-a6fe-92eea03bcfcd", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.max_iter = 100\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.choice(self.population_size, 1, replace=False)[0]\n        self.selected_solution_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.population_size):\n                x = np.copy(self.population[j])\n                if random.random() < 0.05:\n                    self.population[j] = self.population[self.selected_solution] + np.random.uniform(-1, 1, self.dim)\n                    self.population[j] = np.clip(self.population[j], -5.0, 5.0)\n                else:\n                    r1 = random.randint(0, self.population_size - 1)\n                    r2 = random.randint(0, self.population_size - 1)\n                    r3 = random.randint(0, self.population_size - 1)\n                    x = self.population[r1] + self.w * (self.population[r2] - self.population[r3]) + np.random.uniform(-1, 1, self.dim)\n                    x = np.clip(x, -5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                if fitness < self.selected_solution_fitness:\n                    self.selected_solution_fitness = fitness\n                    self.selected_solution = j\n            self.population_size = int(self.population_size * (1 - (i / self.max_iter)))\n            self.population = np.random.choice(self.population, self.population_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the population size based on the fitness of the solutions.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "9068b638-d7f2-43f2-9aaf-d4306bca33fa", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    self.selected_solution[k] = np.random.uniform(-5.0, 5.0)\n                self.selected_solution = self.selected_solution.tolist()\n                self.selected_solution = [round(i, 4) for i in self.selected_solution]\n                self.selected_solution = np.array(self.selected_solution)\n                self.harmony_memory = np.concatenate((self.harmony_memory, self.selected_solution.reshape(1, -1)))\n                self.harmony_memory_size = len(self.harmony_memory)\n                self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with an additional strategy refinement mechanism.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "c9bca67e-601b-42ae-a0ac-e80dac8ac332", "solution": "import numpy as np\nimport random\n\nclass DEHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < self.probability:\n                for k in range(self.dim):\n                    self.best_solution[k] += np.random.uniform(-1, 1)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DEHS", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and a probability to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "1536c310-911b-4b41-adf5-c660c88010af", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.DE_population_size = 50\n        self.DE_dim = dim\n        self.DE_F = 0.5\n        self.DE_CR = 0.9\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n\n            # Differential Evolution\n            DE_population = np.random.uniform(-5.0, 5.0, (self.DE_population_size, self.DE_dim))\n            for k in range(self.DE_population_size):\n                x1 = DE_population[k]\n                x2 = DE_population[np.random.randint(0, self.DE_population_size)]\n                x3 = DE_population[np.random.randint(0, self.DE_population_size)]\n                x4 = DE_population[np.random.randint(0, self.DE_population_size)]\n                v = x1 + self.DE_F * (x2 - x3) + self.DE_CR * (x4 - x1)\n                v = np.clip(v, -5.0, 5.0)\n                fitness = func(v)\n                if fitness < func(x1):\n                    DE_population[k] = v\n            if np.any(DE_population < -5.0) or np.any(DE_population > 5.0):\n                print(\"Warning: DE population out of bounds.\")\n            if func(DE_population[np.argmin([func(x) for x in DE_population])]) < self.best_fitness:\n                self.best_fitness = func(DE_population[np.argmin([func(x) for x in DE_population])])\n                self.best_solution = DE_population[np.argmin([func(x) for x in DE_population])]\n\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the population size based on the fitness of the solutions.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "45f50fb5-09d7-40a5-a991-2665a7202c32", "solution": "import numpy as np\nimport random\n\nclass DEHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_refine = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.copy(self.harmony_memory[j])\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] + self.w * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < self.prob_refine:\n                for k in range(self.dim):\n                    self.best_solution[k] += random.uniform(-1, 1)\n                    if self.best_solution[k] < -5.0:\n                        self.best_solution[k] = -5.0\n                    elif self.best_solution[k] > 5.0:\n                        self.best_solution[k] = 5.0\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DEHS", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and refines its strategy with a probability of 0.05.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "3b0b6691-03fb-4a0e-b61e-7aecfa2b77c9", "solution": "import numpy as np\nimport random\n\nclass DHSPSO_AM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.probability:\n                    for k in range(self.dim):\n                        self.best_solution[k] = np.random.uniform(-5.0, 5.0)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DHSPSO_AM", "description": "A novel metaheuristic algorithm, called Dynamic Harmony Search Particle Swarm Optimization with Adaptive Memory (DHSPSO-AM), that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and introduces a probability of changing the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "1d36c71b-db09-4cd6-b5c1-4c5d6a6b602d", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_refine = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.prob_refine:\n                    self.refine_solution(x)\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\n    def refine_solution(self, x):\n        for k in range(self.dim):\n            r1 = random.random()\n            r2 = random.random()\n            if r1 < 0.5:\n                x[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory.shape[0]), k] + self.w * (self.harmony_memory[np.random.randint(0, self.harmony_memory.shape[0]), k] - self.best_solution[k])\n            else:\n                x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory.shape[0]), k])\n        return x", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, along with a probability to refine its strategy.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "c32c82eb-784c-4944-8bf8-0c8822652618", "solution": "import numpy as np\nimport random\n\nclass DEHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.selected_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.05:\n                        x[k] = self.selected_solution[k] + np.random.uniform(-1, 1)\n                    elif r1 < 0.1:\n                        x[k] = self.best_solution[k] + np.random.uniform(-1, 1)\n                    else:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n                if func(self.selected_solution) < self.selected_fitness:\n                    self.selected_solution = self.best_solution\n                    self.selected_fitness = self.best_fitness\n        return self.best_solution", "name": "DEHS", "description": "A novel metaheuristic algorithm that combines the Harmony Search algorithm with the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability-based refinement of the selected solution.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "589c5994-6517-4ec2-9509-2202ff2713cc", "solution": "import numpy as np\nimport random\n\nclass AHSPSO_DR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    self.selected_solution[k] += random.uniform(-1, 1)\n                    if self.selected_solution[k] < -5.0:\n                        self.selected_solution[k] = -5.0\n                    elif self.selected_solution[k] > 5.0:\n                        self.selected_solution[k] = 5.0\n        return self.best_solution, self.selected_solution", "name": "AHSPSO_DR", "description": "A novel metaheuristic algorithm, Adaptive Harmony Search-Particle Swarm Optimization with Dynamic Harmony Memory Size and Refinement (AHSPSO-DR), that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and introduces a refinement mechanism to adjust the strategy of the selected solution with a probability of 0.05.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "4c54886d-5747-47a6-b1b1-f7f73685adaf", "solution": "import numpy as np\nimport random\n\nclass HPCSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if random.random() < self.probability:\n                    x[np.random.randint(0, self.dim)] = np.random.uniform(-5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPCSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Cuckoo Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "1ace36f1-059b-4e0c-81d5-16c8881ecf46", "solution": "import numpy as np\nimport random\n\nclass HSDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.copy(self.best_solution)\n        self.selected_fitness = self.best_fitness\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < 0.05:\n                        x[k] = self.selected_solution[k] + np.random.uniform(-1, 1)\n                    else:\n                        r2 = random.randint(0, self.harmony_memory_size - 1)\n                        r3 = random.randint(0, self.harmony_memory_size - 1)\n                        x[k] = self.harmony_memory[r2, k] + self.w * (self.harmony_memory[r3, k] - self.harmony_memory[r2, k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                if fitness < self.selected_fitness:\n                    self.selected_fitness = fitness\n                    self.selected_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HSDE", "description": "A novel metaheuristic algorithm that combines the Harmony Search algorithm with the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size and a probability-based update of the selected solution.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "fbd998e7-7935-47c5-959d-997690ad6557", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            # Refine the selected solution with a probability of 0.05\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    if random.random() < 0.5:\n                        self.selected_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n                    else:\n                        self.selected_solution[k] = self.best_solution[k]\n        return self.best_solution\n\n    def refine_selected_solution(self):\n        for k in range(self.dim):\n            if random.random() < 0.5:\n                self.selected_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n            else:\n                self.selected_solution[k] = self.best_solution[k]", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with an additional strategy refinement mechanism that changes individual lines of the selected solution with a probability of 0.05.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "372f9f04-ab0a-4f79-ae0a-15ce9253bb9e", "solution": "import numpy as np\nimport random\n\nclass HSHDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_change = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    if random.random() < self.prob_change:\n                        x[k] = self.harmony_memory[j, k] + random.uniform(-1, 1)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                x = x + 0.5 * (self.harmony_memory[j] - self.best_solution) + 0.5 * (self.harmony_memory[np.random.randint(0, self.harmony_memory_size), :] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), :])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HSHDE", "description": "A novel metaheuristic algorithm that combines the Harmony Search algorithm with the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "044b5a9b-d4b1-4009-8294-84926a1c07fe", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < self.probability:\n                for k in range(self.dim):\n                    self.best_solution[k] = np.random.uniform(-5.0, 5.0)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\n    def adapt_harmony_memory_size(self, i):\n        self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n        self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "76f5c65d-b319-49dc-8536-b5fe38fdcab1", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        self.best_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        self.best_solution[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "55023993-6757-4c5b-8719-36f462e89e4b", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < self.probability:\n                for k in range(self.dim):\n                    self.best_solution[k] += random.uniform(-1, 1)\n                fitness = func(self.best_solution)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and a probability to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "382a234e-7a5a-4f0d-b0ec-b224886e29ce", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_change = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                # Differential Evolution mutation\n                v = np.copy(x)\n                for k in range(self.dim):\n                    v[k] = x[k] + self.c1 * (self.harmony_memory[np.random.randint(0, self.swarm_size), k] - self.harmony_memory[np.random.randint(0, self.swarm_size), k])\n                fitness = func(v)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = v\n                self.harmony_memory[j] = x\n                # Change individual lines with probability\n                if random.random() < self.prob_change:\n                    for k in range(self.dim):\n                        r1 = random.random()\n                        if r1 < 0.5:\n                            self.best_solution[k] = self.harmony_memory[j, k]\n                        else:\n                            self.best_solution[k] = self.best_solution[k] + self.c2 * (self.harmony_memory[np.random.randint(0, self.swarm_size), k] - self.harmony_memory[np.random.randint(0, self.swarm_size), k])\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 36 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 36 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "f8a01063-02e8-421f-8b0d-6285ddcd3d4a", "solution": "import numpy as np\nimport random\n\nclass DEHPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < 0.05:\n                        x[k] = self.best_solution[k] + np.random.uniform(-1.0, 1.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DEHPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability-based refinement of the best solution.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "cb366f19-a387-48b4-8cb5-2a485fc69c15", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    if random.random() < 0.5:\n                        self.best_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n                    else:\n                        self.best_solution[k] = self.best_solution[k] + random.uniform(-1, 1)\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "aa5ea707-a78a-41ef-bdfc-46da0eabb21f", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.copy(self.best_solution)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        if random.random() < self.probability:\n                            x[k] = np.random.uniform(-5.0, 5.0)\n                        else:\n                            x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        if random.random() < self.probability:\n                            x[k] = np.random.uniform(-5.0, 5.0)\n                        else:\n                            x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and also incorporates a probability to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "4989e8d8-36b8-4d84-b8e7-9c7f9829eeb6", "solution": "import numpy as np\nimport random\n\nclass HPCSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if random.random() < self.probability:\n                    k = random.randint(0, self.dim - 1)\n                    x[k] = np.random.uniform(-5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPCSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Cuckoo Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "712cf069-34a7-4471-a8a4-fb9970618b94", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if random.random() < self.probability:\n                    k = random.randint(0, self.dim - 1)\n                    x[k] = np.random.uniform(-5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\n# Modified the code to introduce the probability of changing the individual lines of the selected solution to refine its strategy.", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Genetic Algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "04173741-85ec-416e-a8fd-ae373edd8a59", "solution": "import numpy as np\nimport random\n\nclass DEHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                x = x + self.c1 * (np.random.uniform(-5.0, 5.0, self.dim) - x) + self.c2 * (np.random.uniform(-5.0, 5.0, self.dim) - self.best_solution)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n                if random.random() < self.probability:\n                    for k in range(self.dim):\n                        r1 = random.random()\n                        if r1 < 0.5:\n                            self.best_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n                        else:\n                            self.best_solution[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DEHS", "description": "A novel metaheuristic algorithm that combines the Harmony Search algorithm with the Differential Evolution algorithm and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "e3d19d3c-ffae-4621-b1c6-5d0449373899", "solution": "import numpy as np\nimport random\n\nclass HPCSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.selected_solution = np.random.uniform(-5.0, 5.0, self.dim)\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if random.random() < 0.05:\n                for k in range(self.dim):\n                    self.selected_solution[k] = np.random.uniform(-5.0, 5.0)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution\n\n    def refine_strategy(self):\n        for k in range(self.dim):\n            if random.random() < 0.05:\n                self.selected_solution[k] = np.random.uniform(-5.0, 5.0)", "name": "HPCSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Cuckoo Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and allows for refinement of the strategy by changing individual lines of the selected solution with a probability of 0.05.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "7269112a-7f54-4d3f-99bc-b1b7643d4547", "solution": "import numpy as np\nimport random\n\nclass HPCSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.least_fitness = float('inf')\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.cuckoo_eggs = np.random.uniform(-5.0, 5.0, (self.swarm_size, self.dim))\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < self.probability:\n                        x[k] = self.cuckoo_eggs[j, k] + np.random.uniform(-1, 1)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                if fitness < self.least_fitness:\n                    self.least_fitness = fitness\n                    self.cuckoo_eggs[j] = x\n                else:\n                    if random.random() < 0.25:\n                        self.cuckoo_eggs[j] = x\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if self.budget > 0:\n                self.budget -= 1\n            else:\n                break\n        return self.best_solution", "name": "HPCSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Cuckoo Search algorithm and incorporates a dynamic adaptation of the cuckoo eggs size based on the fitness of the solutions.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "6677f017-d09f-46b5-b0e2-094234b8f5dd", "solution": "import numpy as np\nimport random\n\nclass DEHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.copy(self.harmony_memory[j])\n                for k in range(self.dim):\n                    r1, r2, r3 = random.sample(range(self.swarm_size), 3)\n                    if random.random() < 0.05:\n                        x[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] + np.random.uniform(-1, 1)\n                    else:\n                        x[k] = self.harmony_memory[r1, k] + self.w * (self.harmony_memory[r2, k] - self.harmony_memory[r3, k])\n                x = np.clip(x, -5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DEHS", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 19 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 19 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "1d0d1243-d50f-4bad-9d78-7d0b82a94ec7", "solution": "import numpy as np\nimport random\n\nclass DEHS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_change = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < 0.05:\n                        x[k] = np.random.uniform(-5.0, 5.0)\n                    elif r1 < 0.1:\n                        x[k] = self.best_solution[k] + np.random.uniform(-1, 1)\n                    else:\n                        r2 = random.randint(0, self.swarm_size-1)\n                        x[k] = self.harmony_memory[r2, k] + np.random.uniform(-1, 1)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "DEHS", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "d5bf39d9-e2d1-411c-ada4-e6d7ce83eb5d", "solution": "import numpy as np\nimport random\n\nclass HPSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n            if random.random() < self.probability:\n                for k in range(self.dim):\n                    if random.random() < 0.5:\n                        self.best_solution[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k]\n                    else:\n                        self.best_solution[k] += np.random.uniform(-1.0, 1.0)\n                        self.best_solution[k] = max(-5.0, min(self.best_solution[k], 5.0))\n            if self.budget - self.max_iter <= 0:\n                break\n        return self.best_solution", "name": "HPSA", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Simulated Annealing algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "30ee5b02-e43d-45f0-90d8-b7dff0ac3ce7", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_change = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if random.random() < self.prob_change:\n                    for k in range(self.dim):\n                        if random.random() < 0.5:\n                            x[k] = np.random.uniform(-5.0, 5.0)\n                        else:\n                            x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Particle Swarm Optimization algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, with a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "a88065c4-2897-43a3-88f8-e8b476f2cea0", "solution": "import numpy as np\nimport random\n\nclass HPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.probability = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    if r1 < 0.05:\n                        x[k] = self.best_solution[k] + random.uniform(-1, 1)\n                    elif r1 < 0.1:\n                        x[k] = self.harmony_memory[j, k] + random.uniform(-1, 1)\n                    else:\n                        x[k] = self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k] + random.uniform(-1, 1)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO_DE", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Harmony Search algorithm with the exploitation capabilities of the Differential Evolution algorithm, and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions and the probability of mutation to refine its strategy.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
{"id": "5ba72533-adf4-4105-aedf-4581b9d96ffb", "solution": "import numpy as np\nimport random\n\nclass HPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 10\n        self.max_iter = 100\n        self.swarm_size = 50\n        self.w = 0.7298\n        self.c1 = 1.49618\n        self.c2 = 1.49618\n        self.harmony_memory = np.random.uniform(-5.0, 5.0, (self.harmony_memory_size, self.dim))\n        self.best_solution = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = float('inf')\n        self.prob_change = 0.05\n\n    def __call__(self, func):\n        for i in range(self.max_iter):\n            for j in range(self.swarm_size):\n                x = np.random.uniform(-5.0, 5.0, self.dim)\n                harmony = np.random.uniform(-5.0, 5.0, self.dim)\n                for k in range(self.dim):\n                    r1 = random.random()\n                    r2 = random.random()\n                    if r1 < 0.5:\n                        x[k] = self.harmony_memory[j, k] + self.w * (self.harmony_memory[j, k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                    else:\n                        x[k] = self.best_solution[k] + self.w * (self.best_solution[k] - self.harmony_memory[np.random.randint(0, self.harmony_memory_size), k])\n                if random.random() < self.prob_change:\n                    k = random.randint(0, self.dim-1)\n                    x[k] = np.random.uniform(-5.0, 5.0)\n                fitness = func(x)\n                if fitness < self.best_fitness:\n                    self.best_fitness = fitness\n                    self.best_solution = x\n                self.harmony_memory[j] = x\n            self.harmony_memory_size = int(self.harmony_memory_size * (1 - (i / self.max_iter)))\n            self.harmony_memory = np.random.choice(self.harmony_memory, self.harmony_memory_size, replace=False)\n            if i % 10 == 0:\n                print(f\"Iteration {i+1}, Best fitness: {self.best_fitness}\")\n        return self.best_solution", "name": "HPSO", "description": "A novel metaheuristic algorithm that combines the exploration capabilities of the Differential Evolution algorithm with the exploitation capabilities of the Harmony Search algorithm and incorporates a dynamic adaptation of the harmony memory size based on the fitness of the solutions, and a probability of 0.05 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "e03beffd-ea66-4ddc-899a-8a9692549f93", "metadata": {}, "mutation_prompt": null}
