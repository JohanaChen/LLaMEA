{"id": "cfac9a65-9054-4f30-8d59-2874c2169068", "solution": "import numpy as np\n\nclass HybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] += 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n            # Modified simulated annealing\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizer(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizer", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer\" (HSO), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm.", "configspace": "", "generation": 0, "fitness": 0.17330235347516407, "feedback": "The algorithm HybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": null, "metadata": {"aucs": [0.2862431840291877, 0.31857076645060034, 0.3161363886826052, 0.31117948102579385, 0.3006050084356936, 0.3027054926928854, 0.3191970598358618, 0.2996052943577173, 0.31470126892903827, 9.999999999998899e-05, 0.0006696223862602269, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0803500966418289, 0.07939539445476163, 0.09434540676908942, 0.0823858613145354, 0.07925655672415488, 0.08056213683851365, 0.10567546099603564, 0.09017193728926887, 0.09547166845217359, 0.06101848510808017, 0.07269642891720829, 0.0751836645496784, 0.07673256741396872, 0.06922143922738944, 0.06860109975264062, 0.07499929962828067, 0.06550181992065085, 0.06947901606178586, 0.9009049927467812, 0.9292352672100812, 0.8911507200511113, 0.8746525675270668, 0.888883210663366, 0.8731138511760403, 0.9293431951027967, 0.926034303623854, 0.9246957932613258, 0.18835040145353765, 0.18896639927994852, 0.22636260574583644, 0.18976791282168792, 0.1941137115862871, 0.1911034322236863, 0.1880135749173415, 0.20204831777056365, 0.195015778555779, 0.21290745726621185, 0.2217515578121123, 0.21568376299391545, 0.2188247287576255, 0.25532414370007495, 0.18884912783720276, 0.22877994399658752, 0.21167018723418507, 0.23326170161247317, 0.09139054204023922, 0.05186407029348261, 0.08952370607846061, 0.06975594865494461, 0.1119661526662118, 0.10728689844106176, 0.10164338755394697, 0.10175846246984133, 0.1066540655800523, 0.1073348475136996, 0.0703266777835383, 0.10726784669443312, 0.12021124079540335, 0.1039002029314895, 0.11351504230284393, 0.10991922623451011, 0.11597712623825396, 0.0674592356713174, 0.0015108101440121091, 9.999999999998899e-05, 9.999999999998899e-05, 0.02181722711102252, 0.0002349413802162914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10755900570676968, 0.05711124968869552, 0.10274170669085125, 0.0792828353687306, 0.055753413986717515, 0.02124661647304671, 0.1454192951635943, 0.0963600905182197, 0.07511980877531332, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05179795156089406, 0.039600354090042256, 0.0426421863389258, 0.06667134933460461, 0.044059943603071194, 0.06036366786377201, 0.05097536176689588, 0.03418563597985891, 0.03755128339809066, 0.30246565015610527, 0.30868442234015137, 0.30878871619717607, 0.2898077433532119, 0.3586985374861974, 0.3061484191022533, 0.29995418738819035, 0.31369924820000483, 0.3009076530846946, 0.06705035454855002, 0.09589361068323288, 0.08515879905647339, 0.08234890001822825, 0.09173438125394118, 0.10705471886090001, 0.09263337502196523, 0.07661365788445584, 0.11343419935188614, 0.1277248752284741, 0.20304178548565255, 0.14179759878442855, 0.17825311332820404, 0.17099560477116593, 0.18348167681223637, 0.12234166275818004, 0.13613618858179577, 0.15194692370135165, 0.22922636875634916, 0.21357252172012353, 0.23343197985740993, 0.2173398607917667, 0.23112525174299037, 0.22341513029694626, 0.22567262551292355, 0.22467800905060364, 0.22241310531528957, 0.16811116796467485, 0.17959586444544562, 0.1842635456507412, 0.1700548345654357, 0.17712842355615432, 0.17065647827075048, 0.16261528324344876, 0.1811374132651289, 0.14171988115099343, 0.20226484175337922, 0.21120731900744294, 0.197105656916436, 0.2094155396814371, 0.20950818510426739, 0.20600091538746035, 0.2102294582952956, 0.19900690251310005, 0.2002847799297004, 0.2076039160186237, 0.1804523129872152, 0.18091279167724128, 0.1809214588766317, 0.1819286915735624, 0.17663842229829885, 0.17178027079834535, 0.17590222377237164, 0.17322587985169868, 0.17557061508254046, 0.17831181144439778, 0.18206133184585516, 0.15366385295899088, 0.19171694306031273, 0.16571302839572288, 0.2463447799002566, 0.4010776954696509, 0.3901902630388715, 0.3769416930842926, 0.20330980697730971, 0.09166462860491142, 0.16702631262775414, 0.16652424669039667, 0.16580611373016674, 0.16428756321971083, 0.10194656182321782, 0.4170730759730873, 0.1777006550472352, 0.18005631991747872, 0.17911882146632374, 0.19406455937957967, 0.17711325428257263, 0.18794665246796116, 0.1926035786227478, 0.1855958984838031, 0.19535228367458535, 0.08096960093921357, 0.08681477308665286, 0.08528338842124616, 0.07968323032646818, 0.09237488592131882, 0.08553169930445115, 0.08190985401651374, 0.07512596464233323, 0.08795932296846698]}, "mutation_prompt": null}
{"id": "bed50f5c-e4fb-47f6-aa14-6382e3f1c649", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.999\n        self.dynamic_swarm_size = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] += 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n            # Modified simulated annealing\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic swarm size adjustment\n            if self.dynamic_swarm_size and evaluations > (self.budget // 2):\n                self.swarm_size = int(np.sqrt(self.budget - evaluations))\n                self.particles = self.particles[:self.swarm_size]\n                self.velocities = self.velocities[:self.swarm_size]\n                self.best_positions = self.best_positions[:self.swarm_size]\n                self.best_fitness = self.best_fitness[:self.swarm_size]\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACD(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACD", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling and Dynamic Swarm Size\" (HSO-ACD), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm and adaptive cooling rate, and dynamically adjusts the swarm size based on the optimization progress.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ZeroDivisionError('integer division or modulo by zero').", "error": "ZeroDivisionError('integer division or modulo by zero')", "parent_id": "cfac9a65-9054-4f30-8d59-2874c2169068", "metadata": {}, "mutation_prompt": null}
{"id": "c9d0720d-0738-4b72-8cd6-9b09ddb38e97", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerAC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] += 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerAC(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerAC", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling\" (HSO-AC), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm and an adaptive cooling schedule.", "configspace": "", "generation": 2, "fitness": 0.1737265569302595, "feedback": "The algorithm HybridSwarmOptimizerAC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "cfac9a65-9054-4f30-8d59-2874c2169068", "metadata": {"aucs": [0.3037444899485411, 0.3085094562943026, 0.2823804386305103, 0.31890950474503343, 0.3333054544431945, 0.3044141095687346, 0.2897797223848251, 0.3244749783308638, 0.31706831769935184, 9.999999999998899e-05, 0.0006696223862602269, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0923944223794253, 0.09124338018667766, 0.07922745422906663, 0.08408566568836118, 0.08223701663269856, 0.07656433237777238, 0.08431660634653215, 0.10367315943540056, 0.09276060312554746, 0.061106170799549164, 0.07803714472131684, 0.0804866992886456, 0.08505035607954126, 0.0862941073596648, 0.0895804946271439, 0.0848353450741457, 0.06408385388665139, 0.07355326053161737, 0.9009051850473684, 0.9315893847244843, 0.8928129167705626, 0.8778988677728632, 0.8882348077927966, 0.88044324486559, 0.9293558039981009, 0.926034303623854, 0.9246957932613258, 0.17515835985927375, 0.19680661405135869, 0.17190474051164872, 0.20135978387557285, 0.17740654522687038, 0.2020547635663119, 0.1746867966729646, 0.1888570759820586, 0.1966427024666465, 0.23814862683398463, 0.2640401083304912, 0.21960680437774072, 0.20485598875295907, 0.2562622208617876, 0.1873548845941404, 0.22324667545834675, 0.24260494281091882, 0.25353667138545777, 0.08188449439475476, 0.07123130693202606, 0.09715940297331127, 0.06257355035911438, 0.1023636485212368, 0.10637593912920307, 0.10699130634054399, 0.11404893092747093, 0.11994501777379118, 0.10591666179699588, 0.06661801018162183, 0.09647204250375563, 0.10609246538121153, 0.10358926003108992, 0.10973025373438339, 0.12048438976313225, 0.11730336939043173, 0.0988621846435912, 0.0015108101440121091, 9.999999999998899e-05, 9.999999999998899e-05, 0.02181722711102252, 0.0002349413802162914, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10755900570676968, 0.05711124968869552, 0.10274170669085125, 0.07787751169541024, 0.055753413986717515, 0.02124661647304671, 0.1454192951635943, 0.09461398291180789, 0.07511980877531332, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051795259501305035, 0.03352706981943121, 0.05158217891042716, 0.045498333053872964, 0.041312272914598935, 0.057021449018089476, 0.03614443621775587, 0.03265966179715707, 0.06415552057785023, 0.31562184790525694, 0.29870204169945214, 0.30368407359003036, 0.29442813862022954, 0.29325217466751274, 0.30170087807621515, 0.32077999653828515, 0.3108965556765294, 0.3088181556573848, 0.07845190430991822, 0.09028606111557258, 0.07921925613371694, 0.07664401761437989, 0.0902168596498748, 0.12086075110571615, 0.10462803965374023, 0.08397706478532085, 0.08589429138489646, 0.14038933902454842, 0.16526836840227244, 0.1252235758243312, 0.15597168916969295, 0.1683563830794561, 0.19161338913253312, 0.16562225854400114, 0.16472651597533094, 0.18979952530075173, 0.22849802455556645, 0.22707939831009027, 0.22840657980873014, 0.2103054179273245, 0.22863967473888147, 0.2253796460424533, 0.22878700168650512, 0.24037822816691556, 0.22455252310918217, 0.16778017785726274, 0.13890619485450784, 0.18351607223672117, 0.1914258683496729, 0.18648996428321407, 0.16013125156673502, 0.15950162888025277, 0.17866935581494947, 0.14979994267037833, 0.21706487655311646, 0.18583463294392155, 0.19629952084593594, 0.2327248732676851, 0.22621946858922126, 0.21450678585955196, 0.2245471540340298, 0.21143532179640578, 0.22961488393180784, 0.2076039160186237, 0.18219319178451365, 0.18134769625231306, 0.18781250442299402, 0.1812174377272041, 0.18760275408790117, 0.17851628582701085, 0.17755249506939597, 0.17312296609455735, 0.17453045131081313, 0.18009892493534296, 0.18065832901443557, 0.1168096824860313, 0.1888072283313128, 0.16486690348732302, 0.13762437567486108, 0.3759400015853117, 0.4440617065272682, 0.36189044028417494, 0.20103196296584802, 0.09166462860491142, 0.16687368341445508, 0.16678355465238526, 0.17079280405734065, 0.16349976643147623, 0.10191788010227087, 0.37255568734070765, 0.2001528148083559, 0.1971573763499589, 0.17686421155669685, 0.17841498823318636, 0.17562741545596905, 0.17280099043570718, 0.18361610177344856, 0.18465285686271748, 0.17834410843807058, 0.08640079701672498, 0.08786016700561827, 0.09112432168627527, 0.08118497152371185, 0.08426533271046921, 0.0912686924772399, 0.08266634015381424, 0.081735840678402, 0.08795932296846698]}, "mutation_prompt": null}
{"id": "2bd9c767-c03e-45af-9636-06addb085209", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] += 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACL(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACL", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling and Levy Flight\" (HSO-ACL), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, and Levy flight for enhanced global search.", "configspace": "", "generation": 3, "fitness": 0.17807278864017764, "feedback": "The algorithm HybridSwarmOptimizerACL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "c9d0720d-0738-4b72-8cd6-9b09ddb38e97", "metadata": {"aucs": [0.32211198214145875, 0.29570310520112286, 0.2961807073029171, 0.31579764915185937, 0.3036014241567565, 0.3065130429770012, 0.3122357387265894, 0.28736742933559223, 0.31091290115799486, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040858323186554246, 9.999999999998899e-05, 0.0808824056431735, 0.09357111437749666, 0.08560017545166543, 0.08013710776359817, 0.07955284963515186, 0.07681640217761654, 0.10174926219842906, 0.0922242539599436, 0.08411863252934948, 0.07942493174672072, 0.08427959762925652, 0.07658867974209771, 0.08244292509001117, 0.07078223667805827, 0.0629785772107061, 0.08293130026449147, 0.0716968260901143, 0.07539913233858009, 0.8963471109875898, 0.9304907615961833, 0.9025216007492755, 0.8631824176395857, 0.8770871810814598, 0.9121885557218445, 0.9281812848425637, 0.9169606448480375, 0.9235806139327318, 0.17539568833932795, 0.20054549421540924, 0.18836986919122367, 0.1947885841294249, 0.21934099671574037, 0.17766928720799224, 0.19221008221665514, 0.15957449121212341, 0.17343873192770842, 0.2419699916154997, 0.21842016417411425, 0.24525419968318163, 0.2017198736719411, 0.2354396836073871, 0.18633186551771264, 0.22559509876044515, 0.22752525288016967, 0.21966490926535642, 0.10229750299932405, 0.10145557884692957, 0.09762048736834117, 0.06732803834920797, 0.12233319139942689, 0.10644222168422002, 0.09547173760890615, 0.1299345489796946, 0.1127670038427967, 0.11304135592089148, 0.11715141603963752, 0.10182433715049322, 0.09834592703966993, 0.12770407473211076, 0.11458693265930686, 0.10439389874474525, 0.08755277675934048, 0.07988123692490645, 9.999999999998899e-05, 0.004257751166280244, 9.999999999998899e-05, 0.0026076223190629744, 9.999999999998899e-05, 0.0011276209035601115, 0.01127897234284303, 9.999999999998899e-05, 9.999999999998899e-05, 0.09297765622153398, 0.03326581746026569, 0.10402216759167382, 0.07938119963947754, 0.06526464791842668, 0.01841465049370694, 0.10274069699297339, 0.07414432255956416, 0.11488142387957445, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039074760356926475, 0.0451026237798029, 0.04075540294057933, 0.05039954575679817, 0.04549878295473264, 0.03766817350286711, 0.04216180168472783, 0.043414407786201425, 0.04016361264175905, 0.325995744169322, 0.3092902625558036, 0.29526265419722497, 0.3097180280773857, 0.29482243648101325, 0.3229747913930139, 0.3045677531772709, 0.3190648113274762, 0.3463409159809525, 0.08444997706234503, 0.09021084379089461, 0.0911092744477503, 0.10818824283741346, 0.08918081803196565, 0.07946728909568723, 0.083455493072498, 0.09246690325688378, 0.09890069615139951, 0.17209867152712688, 0.17220949345110492, 0.18354274651430547, 0.14498644987581122, 0.27357466497537897, 0.17421788258271953, 0.18954036008613484, 0.14890451027434315, 0.14263682699927016, 0.22426127083112057, 0.1922821968253362, 0.23525845953643776, 0.22574125087892882, 0.21832279516857456, 0.23154107173133098, 0.24316856375420692, 0.2332429919672424, 0.2265424463521395, 0.17901545010096265, 0.17059638838750835, 0.18198163597761097, 0.1899603673356156, 0.1719560075121206, 0.1710954434217976, 0.16204586961433143, 0.1901159811132619, 0.14886932108002315, 0.2313013729156066, 0.20346611027805095, 0.1766742586819342, 0.2162628319732125, 0.264959555224777, 0.21445858928363415, 0.20469035897168208, 0.20409150629778627, 0.1857340802182742, 0.17226440152616618, 0.1760104769637605, 0.1718828402947301, 0.1789662196226518, 0.18127597274542095, 0.16916150996808832, 0.1733312325756602, 0.1722549544941212, 0.17165401165617167, 0.3587730503833183, 0.17547487908156056, 0.17910734546000406, 0.2177951637170712, 0.19115220539713174, 0.18733104346600749, 0.16754796729454535, 0.3988823627151631, 0.38610726770514225, 0.3489947606344391, 0.19905569872238227, 0.2500685488096315, 0.3691654942783146, 0.31281071108916114, 0.16552207089348325, 0.2653811511849933, 0.10781208921809082, 0.35544368769731394, 0.19344860796899832, 0.18786504739992516, 0.1843338840047437, 0.19541739205845166, 0.18797904930327514, 0.20218388189179637, 0.2015712107226928, 0.18117433772748615, 0.181676605353016, 0.08412117040173361, 0.08171570659031946, 0.08484550620772302, 0.0754162357183088, 0.08087103693707831, 0.09071544767090145, 0.0829226862228144, 0.08582257766544443, 0.0764110504748523]}, "mutation_prompt": null}
{"id": "1a86ba09-19a8-478f-b3c9-f15d0fd48dab", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACL_RDM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.mutation_probability = 0.2\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] += 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Randomized dimensional mutation for increased diversity\n                if np.random.rand() < self.mutation_probability:\n                    mutated_dim = np.random.randint(0, self.dim)\n                    self.particles[i, mutated_dim] = np.random.uniform(self.lower_bound, self.upper_bound)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACL_RDM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACL_RDM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Randomized Dimensional Mutation\" (HSO-ACL-RDM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, and randomized dimensional mutation for increased diversity.", "configspace": "", "generation": 4, "fitness": 0.172923870664876, "feedback": "The algorithm HybridSwarmOptimizerACL_RDM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "2bd9c767-c03e-45af-9636-06addb085209", "metadata": {"aucs": [0.3018008943369773, 0.32614547077696365, 0.28543155575268797, 0.30074478906850577, 0.2903959054174924, 0.30034929063090277, 0.29285351052054787, 0.2796657999498948, 0.27935244876163345, 9.999999999998899e-05, 0.01034711177702663, 9.999999999998899e-05, 9.999999999998899e-05, 0.023228773192790375, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09384309205124575, 0.07998432004006284, 0.0897947380897689, 0.07182041622342461, 0.09542575247642926, 0.08375656071540816, 0.08955924279396654, 0.0930818593663354, 0.09706281438061448, 0.06158420633229722, 0.06810235062955095, 0.09213820449515242, 0.084594670204588, 0.08162427728553234, 0.07971681361607641, 0.06523822497509424, 0.08970316331355188, 0.06755231353330216, 0.8979050844816899, 0.9387144603934852, 0.8890588723386503, 0.9001402890426967, 0.8882656647207062, 0.9128727537673662, 0.9136715689538436, 0.9167054528093932, 0.918564520726135, 0.21089924023799955, 0.1685902959088651, 0.20015996573695682, 0.1778582715973256, 0.18446086703943143, 0.1707419323024102, 0.1604119002758343, 0.16568267175458318, 0.1909690493968127, 0.23806709397623538, 0.2383323414424171, 0.22487908914242793, 0.2576144175961329, 0.23362298510851398, 0.20071030373104404, 0.20418057100235654, 0.20322921435137276, 0.225642741174107, 0.10724313883261438, 0.10398542436900193, 0.09449983418710328, 0.11713982682174862, 0.11005911022294657, 0.10518145496350828, 0.12341544337037325, 0.06361238363593491, 0.11348453447641582, 0.10962017569302718, 0.09777594685929503, 0.1343143712264293, 0.09631032577070842, 0.1049300157269536, 0.11421127138888965, 0.11150400725619802, 0.10451524109727994, 0.11176897660844465, 0.00033060771101522946, 0.012866077615976468, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07618540196696577, 0.04780051338392566, 0.12073564468007247, 0.07823991897963878, 0.09889112839475989, 0.024499026876429908, 0.10513241241045923, 0.05860266313083429, 0.10022717212406895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04613394784039915, 0.04856184737410951, 0.029226753337167954, 0.016504916339022402, 0.04316511718441829, 0.03762406785954353, 0.0548502953457084, 0.03947370575026321, 0.03694603711275779, 0.3226333022784502, 0.3013205148755246, 0.3224211278589121, 0.277401199861144, 0.2913483819698164, 0.2935770328670092, 0.2911338985883166, 0.2892475932998061, 0.30655994273294485, 0.08571656429602659, 0.10010590101525718, 0.09097735882351665, 0.09268869431464732, 0.09287331907093643, 0.09169103856410488, 0.09128086998039853, 0.10131757043357992, 0.08747236546233306, 0.14944909840331788, 0.15243998433186368, 0.14118548632429995, 0.13948194575098116, 0.17037261331684495, 0.1624994287632242, 0.13341406272597345, 0.14522163948442124, 0.14212281628577206, 0.2288524026415294, 0.22346027970416327, 0.23616061766155694, 0.22479864128818072, 0.22546621041349868, 0.2210960122266793, 0.2253606427945153, 0.23599292422359908, 0.23103072038457506, 0.17441014662976395, 0.15247390923978965, 0.16046802688678397, 0.16884229599688005, 0.17371264571101241, 0.18197167809351045, 0.15073875067343667, 0.17797353089527734, 0.1506416149416533, 0.18321736617137807, 0.20289221182649186, 0.20375327945503263, 0.20032246043845492, 0.2401764665116315, 0.19677337082600277, 0.2396873167387784, 0.21492747829805925, 0.19550651816502373, 0.18370721137783108, 0.18546575575541435, 0.17715279845249787, 0.18540686112569416, 0.1851205639968586, 0.17293993894342385, 0.17708520303370312, 0.22820170124957728, 0.17221664129771452, 0.12570352650180172, 0.17655759683036176, 0.17506526431312464, 0.15268453820934247, 0.19141207426068096, 0.1865776831982241, 0.20118811684729676, 0.1533926383803913, 0.4212266490900254, 0.362219831804253, 0.1969220602712095, 0.34364345842245914, 0.3319108115075119, 0.16830388873012359, 0.1651380736167719, 0.16548643089662962, 0.11083629666568617, 0.38392074437791646, 0.1869513240242492, 0.17163346698943682, 0.1960636403246765, 0.17941828905967538, 0.1817333129639379, 0.1749494684120455, 0.1743296630056157, 0.1954465061117857, 0.17613880628668266, 0.0872128275072811, 0.08009781426977791, 0.0837774855582597, 0.08002361895638099, 0.07075915582907566, 0.08033163472088922, 0.08944851357451677, 0.09178356324563486, 0.07659041545906675]}, "mutation_prompt": null}
{"id": "66e9e58d-ea2a-4f43-9891-a635470281ac", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLCM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.cauchy_mutation_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        return position + np.random.standard_cauchy(size=self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] += 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Cauchy mutation for increased diversity\n                if np.random.rand() < self.cauchy_mutation_rate:\n                    self.particles[i] = self.cauchy_mutation(self.particles[i])\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLCM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLCM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Cauchy Mutation\" (HSO-ACL-CM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, and Cauchy mutation for increased diversity.", "configspace": "", "generation": 5, "fitness": 0.1751570846739588, "feedback": "The algorithm HybridSwarmOptimizerACLCM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2bd9c767-c03e-45af-9636-06addb085209", "metadata": {"aucs": [0.34275305234195286, 0.3303769746732932, 0.2823239607414624, 0.31555115649128185, 0.2918299434983863, 0.31746875936248786, 0.29477393578785527, 0.29646610332443213, 0.28873002368275114, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08469021870475713, 0.11444387403424683, 0.06942483874569538, 0.09007664379583491, 0.07918187497791462, 0.08117381016907532, 0.0879321375439347, 0.09229894073561085, 0.0850181236658869, 0.07471600529361933, 0.0759547756121437, 0.08344717888242359, 0.08572830335267478, 0.08303520849690449, 0.0688430344997667, 0.08899716178173966, 0.0785314443752464, 0.08344965295948736, 0.8981847751513976, 0.9390594949541251, 0.9134861263593861, 0.9277161445936376, 0.9181929048458003, 0.9227830665915349, 0.9395179805635896, 0.9284797136242712, 0.9001469317238511, 0.18279911859666487, 0.1927005603806744, 0.16001653194778664, 0.18752137984165929, 0.17145088542257014, 0.18033157246904885, 0.16876049935144988, 0.20726570130208322, 0.1931197927539341, 0.2826324096866579, 0.2499537654944719, 0.21811907733979774, 0.23817881996511292, 0.24918201518467398, 0.18141724491073308, 0.22603635098156138, 0.22964273512565625, 0.21781688094268525, 0.08501522865461808, 0.06399271161634057, 0.10319569881615531, 0.09063870788363637, 0.10712246202805942, 0.09052465342087002, 0.11003796734258142, 0.1058429817022597, 0.10848052114304518, 0.11986245776590532, 0.08233227175503033, 0.11665938645151652, 0.11057985539225124, 0.11794182630524663, 0.12508780256421237, 0.09040842850278497, 0.09671071767166028, 0.07592099353142456, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023757770683334734, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10022806800344863, 0.06536973307535077, 0.10351410222735791, 0.10324578359160297, 0.06124738675928365, 0.01693386086004245, 0.09579475969109463, 0.11008247379951097, 0.07836944426840764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0375762842330607, 0.03230616485489224, 0.060634449144717606, 0.06928141954501676, 0.05352029472897246, 0.03970625115332582, 0.03466598712647684, 0.03416564578310355, 0.06624403610553387, 0.307280982975375, 0.2837592176065845, 0.29121147391409474, 0.2830025405959775, 0.31027008466846784, 0.2900281205272165, 0.30898461543530875, 0.3020523648899024, 0.3077595996700909, 0.0948598783693052, 0.08537648315612367, 0.06979584850308185, 0.0799227165836226, 0.08787468486511751, 0.07985121827899422, 0.08496295001166998, 0.0781662535294616, 0.0937204846827675, 0.19467716723810713, 0.16114023512496156, 0.16055114758586386, 0.15175856129734033, 0.14796243297560463, 0.16179164978575022, 0.18230647659665078, 0.16268948687789142, 0.17110949204916903, 0.2297826423832875, 0.2401711532544787, 0.22252842298302689, 0.22403477475461941, 0.2315336842569684, 0.24263962581616383, 0.22542931054372917, 0.21557091555629937, 0.2188026999080146, 0.1696075162676587, 0.15778255771152871, 0.17430972148941437, 0.1952140220320343, 0.17589535767519338, 0.16772316324721503, 0.1501276051985626, 0.17217585802872304, 0.1460043945657693, 0.19578909365129626, 0.215847828915385, 0.18518922700167773, 0.19246366561599937, 0.2151055107490264, 0.17909601417150844, 0.2224063870504106, 0.21215643769414583, 0.20463459281260066, 0.16586455728578053, 0.17322849321858336, 0.18511942672791737, 0.1795587249297016, 0.18696580685359954, 0.17517027793903994, 0.1847120494630472, 0.1722515263293819, 0.17670415774878534, 0.1808371011998331, 0.16459121134931343, 0.17854651876348637, 0.13688520807060245, 0.19102255345277053, 0.18646179174134336, 0.3682772168328492, 0.3792165797090682, 0.382499577519276, 0.4293466520251634, 0.16727570253510715, 0.2490223415116659, 0.29414343089352724, 0.1646780469401008, 0.16564712438518858, 0.16455154051321697, 0.1943671592525742, 0.2966445088322832, 0.1759821777870798, 0.20102450745182843, 0.17298511383165172, 0.19171009187124355, 0.19117369292028774, 0.18000094157885071, 0.18586881313596382, 0.18665444342350612, 0.17806110781738083, 0.0843690645599865, 0.0751960010673518, 0.07172400837112258, 0.06954551752860538, 0.07652219995362053, 0.08069080386057303, 0.08747137262458216, 0.07633042063438877, 0.08019616180182243]}, "mutation_prompt": null}
{"id": "bc4d2be0-dee6-4e6b-8bdf-54a67f054477", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACL_CM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.chaotic_map = lambda x: 4 * x * (1 - x)\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def chaotic_mutation(self, x):\n        chaotic_value = self.chaotic_map(np.random.uniform())\n        return x + (self.upper_bound - self.lower_bound) * (chaotic_value - 0.5)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] += 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Chaotic mutation for increased diversity\n                if np.random.rand() < 0.1:\n                    self.particles[i] = self.chaotic_mutation(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACL_CM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACL_CM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Chaotic Mutation\" (HSO-ACL-CM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, and chaotic mutation for increased diversity.", "configspace": "", "generation": 6, "fitness": 0.17450259830346596, "feedback": "The algorithm HybridSwarmOptimizerACL_CM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "2bd9c767-c03e-45af-9636-06addb085209", "metadata": {"aucs": [0.30079965228782557, 0.3327572692526263, 0.304997853070734, 0.31266651787076716, 0.3119839801876165, 0.30476498580699796, 0.28878562606389546, 0.32673483008330184, 0.29479216002822484, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08313299506302718, 0.06693733871898744, 0.09276540266408406, 0.08874086328786612, 0.08836990882685392, 0.07861044065543632, 0.08630516786927489, 0.08915661853833368, 0.10018918176100056, 0.06321193592330365, 0.09073962710482897, 0.06779503984190705, 0.07293247183547791, 0.07599202550457862, 0.07631574965854815, 0.0681425519262524, 0.07173780127831142, 0.06948800843032954, 0.8987175977968456, 0.9379346599998323, 0.9016034252052392, 0.8538261970129155, 0.8791168921655718, 0.9111543859118505, 0.940072636691243, 0.9275925542076131, 0.9228547904760722, 0.18092789556752675, 0.2117175437459905, 0.1980876631119235, 0.19335623694768433, 0.18932366765004705, 0.1948460733899371, 0.1771916928550138, 0.16435425678443738, 0.17255788416608797, 0.2869182706160698, 0.24828915783069394, 0.26807897831457017, 0.20868394849137062, 0.22982628112296666, 0.196879525501218, 0.2434648348077052, 0.1997778720989717, 0.23093874128111758, 0.11723610232483384, 0.10428546682915352, 0.09618645546539173, 0.04916147849212216, 0.12464773719055577, 0.0942722705094029, 0.10264643169422927, 0.11577951012148824, 0.10895030815547524, 0.10433073541163163, 0.09622121466255906, 0.09855769356064681, 0.11151835068061211, 0.11078591216175049, 0.10915291146063699, 0.13824965118417598, 0.11124228776024048, 0.09803374990646385, 9.999999999998899e-05, 0.010917237393776258, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10267616891600573, 0.08238952821242362, 0.08766833595369494, 0.12161846213423377, 0.08493341822372602, 0.06581670175841103, 0.07346233496671117, 0.02131125266257805, 0.06460728907202262, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042929440738726954, 0.05105763947238395, 0.0592417375850115, 0.04098730257888905, 0.041478732767297855, 0.02674784401991348, 0.048983709849605095, 0.040258774880664205, 0.04129470212532538, 0.3420419220457821, 0.3003722722011777, 0.30361275867779935, 0.3078833505294315, 0.2878896943523669, 0.29534826736621145, 0.2948838459155231, 0.33380931246745527, 0.3512189358079668, 0.0718210734114395, 0.08161095005934804, 0.08576517366116587, 0.07645343514729408, 0.09397183697808975, 0.10449956164247454, 0.08101398209099175, 0.08460497852921633, 0.09070239142162029, 0.1466292364445939, 0.15038380318272115, 0.17003334974110584, 0.18060191122089742, 0.17723350419386863, 0.14548886059322963, 0.15540914023659858, 0.14845903345598144, 0.14760857340270817, 0.22344730432565163, 0.22082207529089715, 0.24595259425547134, 0.22432994771542702, 0.23058795357602535, 0.2542070169776254, 0.22704349721812178, 0.25646364407481226, 0.22008100558425225, 0.16982270043661918, 0.13670087939435194, 0.17665851576565983, 0.16705428594176663, 0.1741607411667625, 0.1934013265292046, 0.16763754074067816, 0.17841825861182026, 0.15291179536357735, 0.2062164848763005, 0.20359028319028294, 0.20441533320336824, 0.2371417012997652, 0.2046093384208737, 0.18315235955923126, 0.2179544413675153, 0.20440683075178634, 0.2059922001168052, 0.17461527547079603, 0.16678448479803354, 0.17408115324353035, 0.18924262996294616, 0.1871420823757567, 0.18084614133759946, 0.17992474441278394, 0.18429274207802193, 0.17195953704584843, 0.16991908995841254, 0.1813119450712537, 0.17532582968143817, 0.1311838510734218, 0.19116790857887678, 0.1658240003524013, 0.3560428728381606, 0.16008535364714283, 0.3814468969611835, 0.34652506184670295, 0.16726224692613045, 0.31339735277987024, 0.20092246577610362, 0.16530770693422459, 0.16634175934454254, 0.16393263368770128, 0.1512551641134916, 0.38266203196271664, 0.19396937291324012, 0.20136628478971808, 0.19276658242131584, 0.19690657103573528, 0.18827204559895683, 0.18268254228711478, 0.18703603658226808, 0.1822100511757725, 0.17629858058024206, 0.08003471347032376, 0.08991277220050764, 0.07757400454195051, 0.0762598999548536, 0.08876042546211516, 0.08916466156780012, 0.07694654586490757, 0.07779697479758885, 0.08009044733974846]}, "mutation_prompt": null}
{"id": "4bb8c8d8-20d1-49db-9754-180d55847d11", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] += 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBL(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBL", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning\" (HSO-ACL-OBL), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, and opposition-based learning for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.18328585675998676, "feedback": "The algorithm HybridSwarmOptimizerACLOBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "2bd9c767-c03e-45af-9636-06addb085209", "metadata": {"aucs": [0.32544686106256837, 0.3315461379421989, 0.30375616480062584, 0.32221072687427943, 0.30504618965038344, 0.35291077807097004, 0.2906195842392384, 0.2970139820738076, 0.302200497684353, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09605367607534243, 0.08896409374859782, 0.08145404074976725, 0.09340638400100576, 0.07435253088668647, 0.10277343401664729, 0.09528953883235114, 0.10839742922589812, 0.09723631905205932, 0.06955883929566675, 0.08814088381573093, 0.10545697108766139, 0.07611945786714402, 0.07016435004799937, 0.06703823098346873, 0.08479263088877376, 0.07282175300824656, 0.09375647310524127, 0.9251115194512758, 0.9525442436700687, 0.9389353825733113, 0.8999030389139793, 0.9075091913877606, 0.9257805258642096, 0.9432909862112238, 0.9333299502557872, 0.9267641673032739, 0.1963187622811039, 0.18580706359282584, 0.18816171178768726, 0.18780402918430716, 0.17573776954814124, 0.19120559173880602, 0.23443763760461034, 0.17127687920666246, 0.1802224715419044, 0.23190999584248684, 0.240594875400845, 0.24127550390245456, 0.27772926863487724, 0.2581863361129576, 0.20822255499961284, 0.21552005874549773, 0.22903606227550322, 0.22426286893998026, 0.11136641283119264, 0.08718325021150031, 0.0714371518889313, 0.07890558386887259, 0.09510561911216386, 0.12453744449068194, 0.11710836256183443, 0.05555727511581987, 0.10972650412989882, 0.13095524138447434, 0.11029235581670238, 0.12761144360254673, 0.10874783764576823, 0.10792431792580393, 0.10473542162813043, 0.11771169935985981, 0.11465583152631276, 0.10391495272140305, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11531047782895965, 0.09632810051188812, 0.12422520154154448, 0.06473617159948242, 0.06941609788324787, 0.02780607486388431, 0.16067723225471398, 0.1061186696715054, 0.06525274032805883, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0672148328349167, 0.060753370421861796, 0.034178145530624926, 0.05355684410382333, 0.05231320546006679, 0.05079497525364385, 0.048378306129393644, 0.05088950195606612, 0.02963475588384734, 0.3174502994467001, 0.3030048167303455, 0.307621852161555, 0.28937198869509395, 0.32199492375216743, 0.3096120861853827, 0.3531188864467969, 0.3052198072463017, 0.3493688730977861, 0.08648918834557173, 0.09823231547892697, 0.08371726717158146, 0.08157976698012992, 0.08932655995724659, 0.09070941601941884, 0.08171641432976195, 0.08751133310599579, 0.08235247121778899, 0.14070064041109687, 0.1570830656340968, 0.13968235788783046, 0.1658466940482658, 0.16702010709468773, 0.17848672142972877, 0.17895270605178992, 0.17255891754371822, 0.17347767839990647, 0.2277007905770242, 0.2283202901194893, 0.224005374816181, 0.22908776289801958, 0.2468817951467196, 0.24391915606140524, 0.23812591753307477, 0.2401408641470757, 0.22944399178807495, 0.18499208070973427, 0.16422439015929013, 0.17684237509637968, 0.17408487941796869, 0.16709904565743672, 0.1783954488580557, 0.17965751123376772, 0.16869624258386906, 0.15098586507639644, 0.21219228016246738, 0.19368349129260365, 0.2087332513514677, 0.22464991030196835, 0.20990449944161527, 0.22304195014770523, 0.24025670237377272, 0.20245742389672838, 0.21324793847042134, 0.19101052755137915, 0.17348660064999144, 0.17111551959843985, 0.2003818514706872, 0.17945892342685343, 0.17260640898244894, 0.18292199401676368, 0.18900661477739145, 0.1741262481518947, 0.17971053313913088, 0.1768179147476281, 0.37758463977425705, 0.42530694712535466, 0.1877878892518403, 0.16533231888473454, 0.1487660997429654, 0.3786265359115003, 0.45458419493732705, 0.3898965263061941, 0.2001700636935676, 0.3872149414077348, 0.3506386950136129, 0.19202871646529185, 0.16605703073126277, 0.16617060718455046, 0.38433927405135926, 0.35156126436589574, 0.18387963863901113, 0.1837501323614048, 0.18697677988458283, 0.18478500090355288, 0.19148141143118314, 0.18007099182119968, 0.17455248149538038, 0.18222075024312767, 0.18728395317346735, 0.0762872167387002, 0.0979420134976452, 0.08484958640831353, 0.09908479114413948, 0.08392347867047123, 0.08494969080560144, 0.08464221787661441, 0.08081642196924055, 0.08739342160777286]}, "mutation_prompt": null}
{"id": "8975bb58-a643-4997-aebd-afcc715cd30e", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIW:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIW(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIW", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight\" (HSO-ACL-OBL-DIW), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, and a dynamic inertia weight for better balance between exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.19462174995630702, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIW got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "4bb8c8d8-20d1-49db-9754-180d55847d11", "metadata": {"aucs": [0.3387705556650571, 0.36694467257712027, 0.34352966069304547, 0.3214501886553932, 0.35491266118544107, 0.34941090819577725, 0.3408272330447597, 0.343762417611287, 0.36977836140455655, 0.024808360414493635, 0.005273372183058012, 0.044931174067087354, 9.999999999998899e-05, 0.0077924864926389725, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09765880836983176, 0.08798232256841765, 0.10461454950242022, 0.09904312934617032, 0.07384847267380357, 0.10079804085712751, 0.10789154017352376, 0.10134204102791045, 0.10261394931428947, 0.10169194271802429, 0.09234309114555928, 0.0951138255209234, 0.09052030081113827, 0.08385629622164814, 0.07905320630908585, 0.09206965553090163, 0.09001368883063154, 0.08358235780663814, 0.9186178632738351, 0.9480487769391553, 0.9283828099003468, 0.878470045581347, 0.8942903590654959, 0.9217326887911804, 0.9361623398219554, 0.9318947894845484, 0.9267870469744861, 0.21788000878491365, 0.21003923690714932, 0.22920777977803364, 0.21415428533153713, 0.21960961134981594, 0.21544223636741733, 0.22290040420539758, 0.21160920987376253, 0.20959039883304753, 0.24997573245351834, 0.29464677620049573, 0.2641124946488699, 0.2799699832841175, 0.2678362342166244, 0.2289912457886596, 0.2415626653791315, 0.2565379795936701, 0.27310144863985186, 0.16145559742657134, 0.07808825675617537, 0.09446511699765303, 0.08499581378909093, 0.1267322226799561, 0.1264877742574454, 0.1242965238197028, 0.08321643288113578, 0.1442075340622816, 0.12347999167577217, 0.13384046176919073, 0.1300989302127311, 0.14436485693760082, 0.11877854112774022, 0.14626486069085098, 0.11759555873522876, 0.13388120426759365, 0.1284196857331028, 9.999999999998899e-05, 9.999999999998899e-05, 0.0052906921865752965, 0.025729212322306405, 0.002996280893948655, 9.999999999998899e-05, 9.999999999998899e-05, 0.02143975224955008, 0.05497599892232907, 0.08411999911291879, 0.051640745707347224, 0.16884564757811205, 0.09676318154152852, 0.07258631043623831, 0.046055029172911044, 0.14720446267907916, 0.07338001926183846, 0.06051051265881924, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06276287520170931, 0.07640026239728048, 0.06095433076288004, 0.06573801870996321, 0.0700000687146316, 0.06921351007408516, 0.07045800234019006, 0.06068013361037816, 0.07096662229963002, 0.32643288960963923, 0.34013438970999654, 0.3490575743667903, 0.3202790159579547, 0.32629639076292316, 0.325422736866919, 0.3331186851250333, 0.3538438216791585, 0.3404314665198991, 0.1033702928855702, 0.09767246541335028, 0.10130019772573928, 0.1517499433621038, 0.09402935870131224, 0.09631753637133367, 0.095062511654047, 0.10935460611776593, 0.0971903004499498, 0.1608718925387479, 0.16301605143912679, 0.13332824511696728, 0.16031210793151562, 0.18104169563467487, 0.1810129579519103, 0.17008676286761348, 0.136503482940444, 0.204156488498887, 0.24959942523868106, 0.25439237214502075, 0.24963459445877256, 0.25069211898361976, 0.25926863568010683, 0.24236512099840046, 0.22309224985319287, 0.2451021300530093, 0.23880862039948603, 0.22410306702128857, 0.20744056762310503, 0.18072802746553207, 0.21075669462052338, 0.19026669478313885, 0.174486753484686, 0.18853199743702242, 0.18760844173093172, 0.1773330099417919, 0.21529073846976587, 0.22027588217006955, 0.21262275308287648, 0.21129385588456573, 0.20400913631245987, 0.21883591647711464, 0.22668852192922573, 0.21471085887666008, 0.21755503610825033, 0.17940127465534061, 0.1800544267522315, 0.2015379792633578, 0.19223678532207222, 0.1849637369006133, 0.17585264880250395, 0.19294714593280204, 0.2104717604718953, 0.17666204327102064, 0.1823628303899163, 0.1814190858644975, 0.4629623300981083, 0.48661987602193923, 0.19510470988719197, 0.16620074208341562, 0.1505115436951051, 0.15316681696157208, 0.4420686043903914, 0.41720114959453436, 0.20671172833864337, 0.43840841633118166, 0.4762745447322988, 0.20006156523238627, 0.1655950930031309, 0.16713049372731037, 0.3633611040548681, 0.40101905727572784, 0.1986686354809838, 0.18423094677223906, 0.1901354231318373, 0.2007799797919445, 0.17993008913864084, 0.17840230934329504, 0.17715055122315349, 0.21617928838941836, 0.1776309649623352, 0.08524106220248562, 0.08659841231066656, 0.08136911039442873, 0.08623822652424784, 0.09992570358825015, 0.08199220491791237, 0.11397249390740949, 0.0972123742578247, 0.0964808767023082]}, "mutation_prompt": null}
{"id": "d7ffa841-ac75-48e2-940f-f468c23e2818", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWGM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.gaussian_mutation_rate = 0.1\n        self.gaussian_mutation_stddev = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def gaussian_mutation(self, position):\n        return position + np.random.normal(0, self.gaussian_mutation_stddev, size=self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Gaussian mutation for increased diversity\n                if np.random.rand() < self.gaussian_mutation_rate:\n                    mutated_position = self.gaussian_mutation(self.particles[i])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWGM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWGM", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Gaussian Mutation (HSO-ACL-OBL-DIW-GM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, and Gaussian mutation for increased diversity.", "configspace": "", "generation": 9, "fitness": 0.19269702749731327, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWGM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "8975bb58-a643-4997-aebd-afcc715cd30e", "metadata": {"aucs": [0.3408364024440784, 0.33669527128417154, 0.33290086378853645, 0.3210068091366287, 0.33499150129048094, 0.3404777826953139, 0.32593132413210113, 0.3329825829719879, 0.33383269351113654, 9.999999999998899e-05, 0.00738404064803122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10756105477379774, 0.09564300789960489, 0.10159605432645535, 0.09869975877496451, 0.09081931719338754, 0.08564182833714973, 0.10491001607019423, 0.10868869719302998, 0.07542854433097146, 0.07022418403156894, 0.08255930929574584, 0.08250455976264603, 0.09199637690060847, 0.09068169714905139, 0.08437412520374743, 0.10619629723569146, 0.0785776177857409, 0.0912125567711839, 0.9098678941961285, 0.9311679893959449, 0.892387801871215, 0.8733939263737636, 0.8924143159534812, 0.8987797451757289, 0.9335513671609409, 0.9072648695225088, 0.9184748855959202, 0.2199419256960753, 0.2351829760874009, 0.2246621049423485, 0.2474060036582979, 0.225096303631798, 0.2206508135819889, 0.2564978714116707, 0.21017165373919366, 0.210077042195999, 0.2567150916343732, 0.29114800887917636, 0.30070322630578683, 0.2259048932819867, 0.27757807822660996, 0.20953894196942624, 0.23836271553728783, 0.1980113981102961, 0.2464966955585105, 0.14275024099487177, 0.08199856232280944, 0.13222446510604546, 0.16507393660299707, 0.11528978509758858, 0.12030230564170119, 0.13844972014608792, 0.12543773104755418, 0.15368836772596928, 0.13139400213092978, 0.14725610829104774, 0.13623513857718628, 0.13010183302588452, 0.12419270997756171, 0.13536324197007454, 0.135143546979554, 0.13448739006544297, 0.09773600844287045, 0.0023280223835921987, 9.999999999998899e-05, 9.999999999998899e-05, 0.019956329943668027, 0.00027686312448493844, 9.999999999998899e-05, 0.0011457975290549705, 0.00016648627896753698, 9.999999999998899e-05, 0.08032436636782603, 0.09427277147763524, 0.1369044947038598, 0.07723797667404675, 0.053043207773122214, 0.03145319870784946, 0.10430789827090592, 0.06465607337725254, 0.09832716240086925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0622921667562748, 0.06501406003174925, 0.061243023637086336, 0.060976950015253495, 0.06677865103059955, 0.048913301464988734, 0.06283672729341083, 0.06372083416105034, 0.04682113834676527, 0.32850941803897626, 0.32710770527622846, 0.3336191495606933, 0.33335654125406833, 0.3318495190710461, 0.3214396257320469, 0.33850167420893595, 0.3359913794977246, 0.34640247979398386, 0.10244158430119055, 0.09455637324882737, 0.083681004041672, 0.09488451599217662, 0.09243795810668076, 0.08351698963160381, 0.09582623537773693, 0.09705368319080021, 0.10020402453156352, 0.14990148546344084, 0.16537096141412788, 0.13329849888543432, 0.18421381778096524, 0.1738956701863379, 0.18710366959874247, 0.1837718678156569, 0.17852695608868707, 0.1752286379216137, 0.24845310580674995, 0.23905543003875107, 0.24687408045785697, 0.25281403897874577, 0.2398136381395911, 0.2488397946158014, 0.24133819522184807, 0.2631416078559762, 0.24702257429464658, 0.19761599040754652, 0.18749740119856273, 0.19991036022215247, 0.20168723503871278, 0.19351627117979175, 0.18732968241276393, 0.15703831269322122, 0.20029539519748818, 0.17927309090290733, 0.23399309207223173, 0.21440324561214574, 0.23494153648949667, 0.21267730784349337, 0.2150341492965131, 0.2125677932051896, 0.23004970369284183, 0.2344976371426961, 0.22406839114805588, 0.19822726994430728, 0.18045167949553675, 0.18964383446132793, 0.19204138606103138, 0.19272182003954774, 0.1849469777519801, 0.21723466594752583, 0.18622416180458057, 0.17542140091289826, 0.12776088485668147, 0.18206111039231543, 0.4862042206370226, 0.46125360177324637, 0.192535539702113, 0.19128690737511456, 0.1386715634909257, 0.4365373282016971, 0.44368548837366506, 0.4395041037362918, 0.20823268264124473, 0.41994751616353676, 0.3374965898176765, 0.16571953873374445, 0.16587241957323917, 0.16589753025122245, 0.3978491542999111, 0.4117452052986388, 0.1833909515799531, 0.20804250200254137, 0.19422851097026328, 0.17475264322787898, 0.1918573432123135, 0.1716985775313773, 0.18580898233804477, 0.1793066014111977, 0.17906505041899723, 0.082400578034042, 0.0777171747312061, 0.07724794876878072, 0.09376504070392988, 0.0921512255729573, 0.09371186959715327, 0.09135866734750364, 0.1000513637413113, 0.08236242878809485]}, "mutation_prompt": null}
{"id": "5e4bc070-01a1-4a29-8391-74cbbaf8ab79", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWGM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.gaussian_mutation_rate = 0.1\n        self.gaussian_mutation_stddev = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def gaussian_mutation(self, position):\n        return position + np.random.normal(0, self.gaussian_mutation_stddev, size=self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Gaussian mutation for increased diversity\n                if np.random.rand() < self.gaussian_mutation_rate:\n                    mutated_position = self.gaussian_mutation(self.particles[i])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWGM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWGM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Gaussian Mutation\" (HSO-ACL-OBL-DIW-GM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, and Gaussian mutation for increased diversity.", "configspace": "", "generation": 10, "fitness": 0.19269702749731327, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWGM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "8975bb58-a643-4997-aebd-afcc715cd30e", "metadata": {"aucs": [0.3408364024440784, 0.33669527128417154, 0.33290086378853645, 0.3210068091366287, 0.33499150129048094, 0.3404777826953139, 0.32593132413210113, 0.3329825829719879, 0.33383269351113654, 9.999999999998899e-05, 0.00738404064803122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10756105477379774, 0.09564300789960489, 0.10159605432645535, 0.09869975877496451, 0.09081931719338754, 0.08564182833714973, 0.10491001607019423, 0.10868869719302998, 0.07542854433097146, 0.07022418403156894, 0.08255930929574584, 0.08250455976264603, 0.09199637690060847, 0.09068169714905139, 0.08437412520374743, 0.10619629723569146, 0.0785776177857409, 0.0912125567711839, 0.9098678941961285, 0.9311679893959449, 0.892387801871215, 0.8733939263737636, 0.8924143159534812, 0.8987797451757289, 0.9335513671609409, 0.9072648695225088, 0.9184748855959202, 0.2199419256960753, 0.2351829760874009, 0.2246621049423485, 0.2474060036582979, 0.225096303631798, 0.2206508135819889, 0.2564978714116707, 0.21017165373919366, 0.210077042195999, 0.2567150916343732, 0.29114800887917636, 0.30070322630578683, 0.2259048932819867, 0.27757807822660996, 0.20953894196942624, 0.23836271553728783, 0.1980113981102961, 0.2464966955585105, 0.14275024099487177, 0.08199856232280944, 0.13222446510604546, 0.16507393660299707, 0.11528978509758858, 0.12030230564170119, 0.13844972014608792, 0.12543773104755418, 0.15368836772596928, 0.13139400213092978, 0.14725610829104774, 0.13623513857718628, 0.13010183302588452, 0.12419270997756171, 0.13536324197007454, 0.135143546979554, 0.13448739006544297, 0.09773600844287045, 0.0023280223835921987, 9.999999999998899e-05, 9.999999999998899e-05, 0.019956329943668027, 0.00027686312448493844, 9.999999999998899e-05, 0.0011457975290549705, 0.00016648627896753698, 9.999999999998899e-05, 0.08032436636782603, 0.09427277147763524, 0.1369044947038598, 0.07723797667404675, 0.053043207773122214, 0.03145319870784946, 0.10430789827090592, 0.06465607337725254, 0.09832716240086925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0622921667562748, 0.06501406003174925, 0.061243023637086336, 0.060976950015253495, 0.06677865103059955, 0.048913301464988734, 0.06283672729341083, 0.06372083416105034, 0.04682113834676527, 0.32850941803897626, 0.32710770527622846, 0.3336191495606933, 0.33335654125406833, 0.3318495190710461, 0.3214396257320469, 0.33850167420893595, 0.3359913794977246, 0.34640247979398386, 0.10244158430119055, 0.09455637324882737, 0.083681004041672, 0.09488451599217662, 0.09243795810668076, 0.08351698963160381, 0.09582623537773693, 0.09705368319080021, 0.10020402453156352, 0.14990148546344084, 0.16537096141412788, 0.13329849888543432, 0.18421381778096524, 0.1738956701863379, 0.18710366959874247, 0.1837718678156569, 0.17852695608868707, 0.1752286379216137, 0.24845310580674995, 0.23905543003875107, 0.24687408045785697, 0.25281403897874577, 0.2398136381395911, 0.2488397946158014, 0.24133819522184807, 0.2631416078559762, 0.24702257429464658, 0.19761599040754652, 0.18749740119856273, 0.19991036022215247, 0.20168723503871278, 0.19351627117979175, 0.18732968241276393, 0.15703831269322122, 0.20029539519748818, 0.17927309090290733, 0.23399309207223173, 0.21440324561214574, 0.23494153648949667, 0.21267730784349337, 0.2150341492965131, 0.2125677932051896, 0.23004970369284183, 0.2344976371426961, 0.22406839114805588, 0.19822726994430728, 0.18045167949553675, 0.18964383446132793, 0.19204138606103138, 0.19272182003954774, 0.1849469777519801, 0.21723466594752583, 0.18622416180458057, 0.17542140091289826, 0.12776088485668147, 0.18206111039231543, 0.4862042206370226, 0.46125360177324637, 0.192535539702113, 0.19128690737511456, 0.1386715634909257, 0.4365373282016971, 0.44368548837366506, 0.4395041037362918, 0.20823268264124473, 0.41994751616353676, 0.3374965898176765, 0.16571953873374445, 0.16587241957323917, 0.16589753025122245, 0.3978491542999111, 0.4117452052986388, 0.1833909515799531, 0.20804250200254137, 0.19422851097026328, 0.17475264322787898, 0.1918573432123135, 0.1716985775313773, 0.18580898233804477, 0.1793066014111977, 0.17906505041899723, 0.082400578034042, 0.0777171747312061, 0.07724794876878072, 0.09376504070392988, 0.0921512255729573, 0.09371186959715327, 0.09135866734750364, 0.1000513637413113, 0.08236242878809485]}, "mutation_prompt": null}
{"id": "44d5e0b8-b8d1-4d22-8ed4-89b4ff0e89ac", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWCM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.chaotic_map = np.random.uniform(size=self.swarm_size)\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Chaotic maps for increased randomness and diversity\n                self.chaotic_map[i] = self.logistic_map(self.chaotic_map[i])\n                if np.random.rand() < self.chaotic_map[i]:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWCM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWCM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Chaotic Maps\" (HSO-ACL-OBL-DIW-CM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, and chaotic maps for increased randomness and diversity.", "configspace": "", "generation": 11, "fitness": 0.17411272719671397, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWCM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "8975bb58-a643-4997-aebd-afcc715cd30e", "metadata": {"aucs": [0.3019013894947079, 0.3230327176125325, 0.30973141993627673, 0.2972184343281884, 0.2911784461903929, 0.3103223725821661, 0.3061001037765121, 0.30271033001293335, 0.326460496054895, 0.024465043603139947, 0.006111866583903058, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0958421320910593, 0.08300330390386224, 0.09551712046761673, 0.08056469239748454, 0.08539966903905538, 0.07958290557549441, 0.09468824648499863, 0.08337168033922338, 0.08807902718092431, 0.07364314402168148, 0.07636540577144957, 0.07188070453248308, 0.07496000159037086, 0.0624741208379872, 0.0854849125009447, 0.07104486101627538, 0.06230714790810721, 0.05705686401693855, 0.8931037463326441, 0.9337241377015101, 0.8862503668238896, 0.85952652355235, 0.859765936749377, 0.8995223883424741, 0.925942260741646, 0.9130467084269644, 0.9036629195387483, 0.19697731988549327, 0.18803094055508607, 0.17893365484961488, 0.18400765396995622, 0.17313400748862606, 0.1832052750824188, 0.17122387094323022, 0.16437064935206236, 0.17600872617513086, 0.2075431473703777, 0.23796545050239115, 0.21969602165593605, 0.20905425776578146, 0.18661450989899264, 0.17880716846391387, 0.21522358716047452, 0.2202956309763373, 0.25412374939741744, 0.09183063700898397, 0.1014387099420534, 0.10436589683597086, 0.06165835366713723, 0.11228538009432454, 0.12976291334750167, 0.10267741590579971, 0.05140124496756293, 0.10381247281525452, 0.11973950195934868, 0.12092123585140802, 0.10060383204790069, 0.10659896135393954, 0.10258076484250467, 0.12545764417690208, 0.10352983459726384, 0.10021707509190858, 0.10567707874054444, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020405221346134206, 9.999999999998899e-05, 9.999999999998899e-05, 0.02011850476601973, 9.999999999998899e-05, 9.999999999998899e-05, 0.08162797003466726, 0.058520429323104306, 0.08776614023433016, 0.09453198827969211, 0.1071343551402737, 0.033746237279576596, 0.0852574368691087, 0.05547892063239035, 0.07616269043274804, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03774400366636743, 0.04916649394258221, 0.03976023189147959, 0.03730695975740561, 0.05509620724343711, 0.06168833776973137, 0.03834705648935055, 0.04238309898602588, 0.03709455715039989, 0.29843500360426567, 0.2973846872784649, 0.3209886902550999, 0.29595618608959084, 0.2997711931980874, 0.3064456897172154, 0.29771604119536965, 0.3170253867910007, 0.3100999318303478, 0.08723471263991489, 0.0790427390719769, 0.08421039142475606, 0.07445667771875819, 0.08282103341230251, 0.09860005144961759, 0.07353309365344263, 0.09397472556465492, 0.08736562270024173, 0.1210759554074059, 0.15538514808293835, 0.15757745858879713, 0.17059803380575778, 0.15662834456440056, 0.13715879759568017, 0.13429467266996908, 0.13174064747225744, 0.17564245886036456, 0.2216582939954218, 0.23075499722214776, 0.22454641489929295, 0.23026481782523733, 0.23808249690519945, 0.23231091215065414, 0.2405407570590613, 0.23311083146442324, 0.22653018043766027, 0.1818490790231514, 0.1686760666346574, 0.1684917653604121, 0.17541554060273612, 0.16312778661654614, 0.16346725483553382, 0.14298101567851895, 0.1792920088085591, 0.1773545757744991, 0.19563951042634575, 0.21348368948395713, 0.21939039502390145, 0.22313017051515305, 0.2017670497945716, 0.20353453212074624, 0.25687372387938645, 0.2167701560128309, 0.2010984935224659, 0.17359165057901027, 0.18480090492751022, 0.1749617335760546, 0.185927326761667, 0.17906095138260258, 0.17403533854879139, 0.17591605340713345, 0.17767775346331605, 0.17046065218708117, 0.1787569215549928, 0.3866830886094301, 0.17709921187714806, 0.19302571422429848, 0.19272493343158237, 0.15141261072084256, 0.26436025488549475, 0.16367846036591982, 0.35174288801172493, 0.3478399911504605, 0.19795722864261955, 0.3330352505812756, 0.2903379758145337, 0.28114253617073415, 0.25381082434182256, 0.2898817892846911, 0.19967795500483254, 0.23137446216776636, 0.1854630347049936, 0.1807336557658431, 0.18717814138864852, 0.18124855784541682, 0.1761296564084165, 0.17583669815916003, 0.18503133694747953, 0.1781284145369908, 0.17618118379637582, 0.08366973315342507, 0.07622375401757508, 0.08019666708899853, 0.07096774346440726, 0.0795876412421963, 0.09178611018527849, 0.08008330538474528, 0.07872057710067659, 0.07844754687492861]}, "mutation_prompt": null}
{"id": "72be079f-5c3d-4951-b862-6a048ebfcf66", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        return position + np.random.normal(0, self.mutation_step_size, size=self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Self-Adaptive Mutation\" (HSO-ACL-OBL-DIW-SAM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, and self-adaptive mutation for increased diversity.", "configspace": "", "generation": 12, "fitness": 0.19269702749731327, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "8975bb58-a643-4997-aebd-afcc715cd30e", "metadata": {"aucs": [0.3408364024440784, 0.33669527128417154, 0.33290086378853645, 0.3210068091366287, 0.33499150129048094, 0.3404777826953139, 0.32593132413210113, 0.3329825829719879, 0.33383269351113654, 9.999999999998899e-05, 0.00738404064803122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10756105477379774, 0.09564300789960489, 0.10159605432645535, 0.09869975877496451, 0.09081931719338754, 0.08564182833714973, 0.10491001607019423, 0.10868869719302998, 0.07542854433097146, 0.07022418403156894, 0.08255930929574584, 0.08250455976264603, 0.09199637690060847, 0.09068169714905139, 0.08437412520374743, 0.10619629723569146, 0.0785776177857409, 0.0912125567711839, 0.9098678941961285, 0.9311679893959449, 0.892387801871215, 0.8733939263737636, 0.8924143159534812, 0.8987797451757289, 0.9335513671609409, 0.9072648695225088, 0.9184748855959202, 0.2199419256960753, 0.2351829760874009, 0.2246621049423485, 0.2474060036582979, 0.225096303631798, 0.2206508135819889, 0.2564978714116707, 0.21017165373919366, 0.210077042195999, 0.2567150916343732, 0.29114800887917636, 0.30070322630578683, 0.2259048932819867, 0.27757807822660996, 0.20953894196942624, 0.23836271553728783, 0.1980113981102961, 0.2464966955585105, 0.14275024099487177, 0.08199856232280944, 0.13222446510604546, 0.16507393660299707, 0.11528978509758858, 0.12030230564170119, 0.13844972014608792, 0.12543773104755418, 0.15368836772596928, 0.13139400213092978, 0.14725610829104774, 0.13623513857718628, 0.13010183302588452, 0.12419270997756171, 0.13536324197007454, 0.135143546979554, 0.13448739006544297, 0.09773600844287045, 0.0023280223835921987, 9.999999999998899e-05, 9.999999999998899e-05, 0.019956329943668027, 0.00027686312448493844, 9.999999999998899e-05, 0.0011457975290549705, 0.00016648627896753698, 9.999999999998899e-05, 0.08032436636782603, 0.09427277147763524, 0.1369044947038598, 0.07723797667404675, 0.053043207773122214, 0.03145319870784946, 0.10430789827090592, 0.06465607337725254, 0.09832716240086925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0622921667562748, 0.06501406003174925, 0.061243023637086336, 0.060976950015253495, 0.06677865103059955, 0.048913301464988734, 0.06283672729341083, 0.06372083416105034, 0.04682113834676527, 0.32850941803897626, 0.32710770527622846, 0.3336191495606933, 0.33335654125406833, 0.3318495190710461, 0.3214396257320469, 0.33850167420893595, 0.3359913794977246, 0.34640247979398386, 0.10244158430119055, 0.09455637324882737, 0.083681004041672, 0.09488451599217662, 0.09243795810668076, 0.08351698963160381, 0.09582623537773693, 0.09705368319080021, 0.10020402453156352, 0.14990148546344084, 0.16537096141412788, 0.13329849888543432, 0.18421381778096524, 0.1738956701863379, 0.18710366959874247, 0.1837718678156569, 0.17852695608868707, 0.1752286379216137, 0.24845310580674995, 0.23905543003875107, 0.24687408045785697, 0.25281403897874577, 0.2398136381395911, 0.2488397946158014, 0.24133819522184807, 0.2631416078559762, 0.24702257429464658, 0.19761599040754652, 0.18749740119856273, 0.19991036022215247, 0.20168723503871278, 0.19351627117979175, 0.18732968241276393, 0.15703831269322122, 0.20029539519748818, 0.17927309090290733, 0.23399309207223173, 0.21440324561214574, 0.23494153648949667, 0.21267730784349337, 0.2150341492965131, 0.2125677932051896, 0.23004970369284183, 0.2344976371426961, 0.22406839114805588, 0.19822726994430728, 0.18045167949553675, 0.18964383446132793, 0.19204138606103138, 0.19272182003954774, 0.1849469777519801, 0.21723466594752583, 0.18622416180458057, 0.17542140091289826, 0.12776088485668147, 0.18206111039231543, 0.4862042206370226, 0.46125360177324637, 0.192535539702113, 0.19128690737511456, 0.1386715634909257, 0.4365373282016971, 0.44368548837366506, 0.4395041037362918, 0.20823268264124473, 0.41994751616353676, 0.3374965898176765, 0.16571953873374445, 0.16587241957323917, 0.16589753025122245, 0.3978491542999111, 0.4117452052986388, 0.1833909515799531, 0.20804250200254137, 0.19422851097026328, 0.17475264322787898, 0.1918573432123135, 0.1716985775313773, 0.18580898233804477, 0.1793066014111977, 0.17906505041899723, 0.082400578034042, 0.0777171747312061, 0.07724794876878072, 0.09376504070392988, 0.0921512255729573, 0.09371186959715327, 0.09135866734750364, 0.1000513637413113, 0.08236242878809485]}, "mutation_prompt": null}
{"id": "bbcc22f8-60aa-4aef-a727-ad76e4867fff", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWGM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.gaussian_mutation_rate = 0.1\n        self.gaussian_mutation_stddev = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def gaussian_mutation(self, position):\n        return position + np.random.normal(0, self.gaussian_mutation_stddev, size=self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Gaussian mutation for increased diversity\n                if np.random.rand() < self.gaussian_mutation_rate:\n                    mutated_position = self.gaussian_mutation(self.particles[i])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWGM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWGM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Gaussian Mutation\" (HSO-ACL-OBL-DIW-GM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, and Gaussian mutation for increased diversity.", "configspace": "", "generation": 13, "fitness": 0.19269702749731327, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWGM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "8975bb58-a643-4997-aebd-afcc715cd30e", "metadata": {"aucs": [0.3408364024440784, 0.33669527128417154, 0.33290086378853645, 0.3210068091366287, 0.33499150129048094, 0.3404777826953139, 0.32593132413210113, 0.3329825829719879, 0.33383269351113654, 9.999999999998899e-05, 0.00738404064803122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10756105477379774, 0.09564300789960489, 0.10159605432645535, 0.09869975877496451, 0.09081931719338754, 0.08564182833714973, 0.10491001607019423, 0.10868869719302998, 0.07542854433097146, 0.07022418403156894, 0.08255930929574584, 0.08250455976264603, 0.09199637690060847, 0.09068169714905139, 0.08437412520374743, 0.10619629723569146, 0.0785776177857409, 0.0912125567711839, 0.9098678941961285, 0.9311679893959449, 0.892387801871215, 0.8733939263737636, 0.8924143159534812, 0.8987797451757289, 0.9335513671609409, 0.9072648695225088, 0.9184748855959202, 0.2199419256960753, 0.2351829760874009, 0.2246621049423485, 0.2474060036582979, 0.225096303631798, 0.2206508135819889, 0.2564978714116707, 0.21017165373919366, 0.210077042195999, 0.2567150916343732, 0.29114800887917636, 0.30070322630578683, 0.2259048932819867, 0.27757807822660996, 0.20953894196942624, 0.23836271553728783, 0.1980113981102961, 0.2464966955585105, 0.14275024099487177, 0.08199856232280944, 0.13222446510604546, 0.16507393660299707, 0.11528978509758858, 0.12030230564170119, 0.13844972014608792, 0.12543773104755418, 0.15368836772596928, 0.13139400213092978, 0.14725610829104774, 0.13623513857718628, 0.13010183302588452, 0.12419270997756171, 0.13536324197007454, 0.135143546979554, 0.13448739006544297, 0.09773600844287045, 0.0023280223835921987, 9.999999999998899e-05, 9.999999999998899e-05, 0.019956329943668027, 0.00027686312448493844, 9.999999999998899e-05, 0.0011457975290549705, 0.00016648627896753698, 9.999999999998899e-05, 0.08032436636782603, 0.09427277147763524, 0.1369044947038598, 0.07723797667404675, 0.053043207773122214, 0.03145319870784946, 0.10430789827090592, 0.06465607337725254, 0.09832716240086925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0622921667562748, 0.06501406003174925, 0.061243023637086336, 0.060976950015253495, 0.06677865103059955, 0.048913301464988734, 0.06283672729341083, 0.06372083416105034, 0.04682113834676527, 0.32850941803897626, 0.32710770527622846, 0.3336191495606933, 0.33335654125406833, 0.3318495190710461, 0.3214396257320469, 0.33850167420893595, 0.3359913794977246, 0.34640247979398386, 0.10244158430119055, 0.09455637324882737, 0.083681004041672, 0.09488451599217662, 0.09243795810668076, 0.08351698963160381, 0.09582623537773693, 0.09705368319080021, 0.10020402453156352, 0.14990148546344084, 0.16537096141412788, 0.13329849888543432, 0.18421381778096524, 0.1738956701863379, 0.18710366959874247, 0.1837718678156569, 0.17852695608868707, 0.1752286379216137, 0.24845310580674995, 0.23905543003875107, 0.24687408045785697, 0.25281403897874577, 0.2398136381395911, 0.2488397946158014, 0.24133819522184807, 0.2631416078559762, 0.24702257429464658, 0.19761599040754652, 0.18749740119856273, 0.19991036022215247, 0.20168723503871278, 0.19351627117979175, 0.18732968241276393, 0.15703831269322122, 0.20029539519748818, 0.17927309090290733, 0.23399309207223173, 0.21440324561214574, 0.23494153648949667, 0.21267730784349337, 0.2150341492965131, 0.2125677932051896, 0.23004970369284183, 0.2344976371426961, 0.22406839114805588, 0.19822726994430728, 0.18045167949553675, 0.18964383446132793, 0.19204138606103138, 0.19272182003954774, 0.1849469777519801, 0.21723466594752583, 0.18622416180458057, 0.17542140091289826, 0.12776088485668147, 0.18206111039231543, 0.4862042206370226, 0.46125360177324637, 0.192535539702113, 0.19128690737511456, 0.1386715634909257, 0.4365373282016971, 0.44368548837366506, 0.4395041037362918, 0.20823268264124473, 0.41994751616353676, 0.3374965898176765, 0.16571953873374445, 0.16587241957323917, 0.16589753025122245, 0.3978491542999111, 0.4117452052986388, 0.1833909515799531, 0.20804250200254137, 0.19422851097026328, 0.17475264322787898, 0.1918573432123135, 0.1716985775313773, 0.18580898233804477, 0.1793066014111977, 0.17906505041899723, 0.082400578034042, 0.0777171747312061, 0.07724794876878072, 0.09376504070392988, 0.0921512255729573, 0.09371186959715327, 0.09135866734750364, 0.1000513637413113, 0.08236242878809485]}, "mutation_prompt": null}
{"id": "de313fcf-0ecb-43ee-82da-d0867e96a718", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.de_scale_factor = 0.5\n        self.de_crossover_probability = 0.5\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def differential_evolution(self, position):\n        r1, r2 = np.random.choice(self.swarm_size, 2, replace=False)\n        mutant = self.particles[r1] + self.de_scale_factor * (self.particles[r2] - position)\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        crossover = np.where(np.random.rand(self.dim) < self.de_crossover_probability, mutant, position)\n        return crossover\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive differential evolution for enhanced local search\n                if np.random.rand() < 0.1:\n                    de_position = self.differential_evolution(self.particles[i])\n                    de_fitness = func(de_position)\n                    evaluations += 1\n                    if de_fitness < fitness:\n                        self.particles[i] = de_position\n                        self.best_fitness[i] = de_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSADE(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSADE", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Self-Adaptive Differential Evolution\" (HSO-ACL-OBL-DIW-SADE), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, and self-adaptive differential evolution for enhanced local search.", "configspace": "", "generation": 14, "fitness": 0.1902167450494678, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "8975bb58-a643-4997-aebd-afcc715cd30e", "metadata": {"aucs": [0.34864680232342704, 0.3369793450845746, 0.3323623405110714, 0.3266834306578066, 0.3426714968292377, 0.34136741517204405, 0.334599375524236, 0.32465210265989974, 0.3277724772059828, 9.999999999998899e-05, 0.005446023940666622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10422534072094891, 0.08998175221140137, 0.09065017218419269, 0.11539564324625662, 0.08752176410509471, 0.0995053460663885, 0.09120938397604861, 0.11683816654462531, 0.10514917863490336, 0.08279008079273986, 0.09627353749808298, 0.08792864649404908, 0.08010269942353987, 0.08146909342708675, 0.09118698316878127, 0.09579784570646044, 0.08560768600878854, 0.09237944389727948, 0.9035054679210428, 0.9429512677147632, 0.8745144062571937, 0.8578534146416827, 0.8966775514867026, 0.9218350023728732, 0.9198800387647795, 0.92678870668532, 0.8962179752396249, 0.22206172413965874, 0.2307815540951318, 0.22149953197602767, 0.2291260844004337, 0.22995825109294288, 0.20285339823358328, 0.22479024660592672, 0.2124959922093853, 0.21449833255497275, 0.25821165245103594, 0.282939383085721, 0.2657431711359667, 0.2742716707452426, 0.3117751616557576, 0.24732698377862183, 0.2716881460393086, 0.2387081142452424, 0.28320342868924564, 0.13911916074670516, 0.11430621334147995, 0.11327343295927295, 0.11137287647057525, 0.12972982239560693, 0.16005303099108992, 0.13217335977010913, 0.12221088318059159, 0.14148609321651928, 0.12383109764521227, 0.13476539692410638, 0.0902984333218434, 0.12559364913702087, 0.14674241345573702, 0.13825583846429235, 0.1214316292080635, 0.1397511006287725, 0.1337564684493151, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007144955218229554, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08485543341927493, 0.08903148288131035, 0.11356060155724812, 0.06525661529531768, 0.04676435897716258, 0.037274608505979856, 0.06964331296956605, 0.07235100412460926, 0.07528633979183175, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053987249205740606, 0.06425309788772027, 0.05942483329302628, 0.05995750234478159, 0.06297738831978128, 0.05031148491916482, 0.07464148038340068, 0.06808538826523125, 0.06426301787432565, 0.3343287597010133, 0.3466061135989982, 0.32312619703914114, 0.3352197904897831, 0.3253427974624328, 0.3461437427080982, 0.32380703840237324, 0.34046197266075817, 0.34175567580369715, 0.09419146091765762, 0.08896245173396256, 0.105336025883904, 0.09545821143367339, 0.08507700856927203, 0.10171988263755061, 0.09142180250363852, 0.09702485093651791, 0.09829189579058561, 0.14961901434367098, 0.15671839575536173, 0.16179307174392743, 0.1782247196016815, 0.1804631592522986, 0.16365513943396615, 0.18230272129036573, 0.1682259506153969, 0.16621545907235125, 0.24938945772251142, 0.2505482964648782, 0.25243862667486416, 0.26571314933605117, 0.2428687479452889, 0.25327373015441357, 0.2074457370512921, 0.2656274279034203, 0.25080270170961294, 0.1907604436566076, 0.198843408733122, 0.20695196425870932, 0.19511633802422135, 0.1742709003285976, 0.18156135282122832, 0.18207864043389388, 0.19074331226769892, 0.19750767486372356, 0.21494077290186242, 0.2447951585165733, 0.2318039387938685, 0.22553904046818185, 0.2125858202057611, 0.2368142757009879, 0.2289624373506305, 0.21190184309978843, 0.21033485778228822, 0.18453840525566045, 0.18599497093447237, 0.17842245511819343, 0.1893532307395419, 0.18968417369480595, 0.17499648093958953, 0.17159819764699769, 0.18618253750285607, 0.1671363689406029, 0.4754856310384755, 0.18201989185554257, 0.16663171158432177, 0.16945187419004848, 0.19604073115581655, 0.19288575478446723, 0.45520344429149684, 0.4458049412537053, 0.1641198226770092, 0.4188603729761242, 0.20470732220914523, 0.07303066350780663, 0.37598504126381216, 0.16496110581168577, 0.1660723187610753, 0.16683967566338365, 0.4356993021522303, 0.41166212023250315, 0.17766189750129158, 0.18975405579974813, 0.1936221484247529, 0.18495209939645407, 0.18912971427410108, 0.1847965883645476, 0.1809787702805673, 0.19748923322276657, 0.1826151737245434, 0.08956041585830299, 0.08702246136987435, 0.07190707233390425, 0.077789676752832, 0.08983453363345839, 0.07749861847406936, 0.07690752990477034, 0.08929414875128205, 0.0804495941104384]}, "mutation_prompt": null}
{"id": "dda6ffb7-f820-4f24-8395-41536e66c689", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWRDM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.randomized_dimensional_mutation_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def randomized_dimensional_mutation(self, position):\n        mutated_position = np.copy(position)\n        mutated_dimension = np.random.randint(0, self.dim)\n        mutated_position[mutated_dimension] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return mutated_position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Randomized dimensional mutation for increased exploration\n                if np.random.rand() < self.randomized_dimensional_mutation_rate:\n                    mutated_position = self.randomized_dimensional_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWRDM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWRDM", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Randomized Dimensional Mutation (HSO-ACL-OBL-DIW-RDM)", "configspace": "", "generation": 15, "fitness": 0.19048620272989614, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWRDM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "8975bb58-a643-4997-aebd-afcc715cd30e", "metadata": {"aucs": [0.3465248302307886, 0.34129630694539415, 0.3389437323063881, 0.3352060784484291, 0.3615785374005349, 0.3351673522714492, 0.37847618506380853, 0.33141141072327684, 0.34432410446645867, 0.014308696551027067, 0.002785395022301018, 0.008929510236023286, 9.999999999998899e-05, 0.0008032324508465694, 0.0037376557613988393, 9.999999999998899e-05, 0.0011880331062713578, 9.999999999998899e-05, 0.10777818576755638, 0.10931391360039855, 0.10050186406447115, 0.09593269228854295, 0.09593025400601873, 0.0888690157003712, 0.10067624634842032, 0.10831971455583589, 0.12265064039805496, 0.08866854571032834, 0.07556661029288447, 0.0976037050098637, 0.07835508452923057, 0.08603151883546833, 0.08587292429332771, 0.08561679935443445, 0.08452654166667872, 0.10326516455198687, 0.9158853667863406, 0.9328985403113486, 0.9125201777541863, 0.8633367437378304, 0.8862918504616843, 0.9066225180126929, 0.9384374925007473, 0.9211814704777085, 0.9185422470753145, 0.22319548734554095, 0.21272530215275343, 0.21008372607612347, 0.22574674564193598, 0.21832970208305114, 0.22065405191245668, 0.22299320914863796, 0.21807896238452984, 0.20265995265913894, 0.26496780044607393, 0.2977071236655785, 0.21621484277099312, 0.2759392796496739, 0.29427623040465145, 0.23625362910064518, 0.27600387821439176, 0.23214580051260614, 0.25539829357559907, 0.12531871787314175, 0.13922764725865278, 0.13498993855054575, 0.08216628720572294, 0.1326701445416102, 0.1328909358291105, 0.11317585761048143, 0.08194067308501674, 0.1325180323955676, 0.12139173458758379, 0.11986353963813123, 0.11864288170454607, 0.15912519231421962, 0.12788043148296568, 0.1329952616788218, 0.12319035365481779, 0.1281050342237373, 0.1189232391246966, 0.0005206864818876333, 9.999999999998899e-05, 0.001025575850089111, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013281201410969556, 9.999999999998899e-05, 0.010189454085264282, 0.11539188689809465, 0.1012470921068449, 0.15444580972452837, 0.09687214310770398, 0.07813820591945264, 0.022982120665842043, 0.10906986018482989, 0.09222784654084304, 0.1036071000612121, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.055943483721390685, 0.06752612202388841, 0.062400227701560285, 0.06472322977650269, 0.057516520297888785, 0.05742155373355218, 0.07010517430581853, 0.06508515496737566, 0.0740266922920737, 0.33329113834367574, 0.40680416921052165, 0.32533962557064, 0.344596459581639, 0.3404438565645601, 0.3170238159064297, 0.3220810897366111, 0.3520413024185085, 0.3341196972758542, 0.09055993811769258, 0.10023591831235279, 0.09743874890207371, 0.09683696179310375, 0.10265065781769467, 0.1020541063721323, 0.09627017111707514, 0.08226842922736055, 0.08962910662818291, 0.14625356435232317, 0.17622127674074384, 0.16755943214155944, 0.14286753474503544, 0.1639725039537212, 0.18036566267316834, 0.17161429496700586, 0.17043498653797073, 0.13359679245228706, 0.24338222133221987, 0.24349445623061194, 0.24510710109679557, 0.24815580188397257, 0.24659420705121793, 0.24515775420268104, 0.2603905309686133, 0.2538532796327365, 0.2502168281689311, 0.1901301667943669, 0.19448539556761757, 0.19407564661633936, 0.20194986492884537, 0.1896185412601733, 0.18539431778774118, 0.1869647906058448, 0.20320318168874096, 0.16617939585236852, 0.23128594019639181, 0.22545758896230106, 0.21207081272886386, 0.21080466878292858, 0.2256416128453801, 0.2539992001036748, 0.21567299540287854, 0.2373785711883858, 0.23131188772170097, 0.18055680896129667, 0.18050872825785502, 0.1831836686260443, 0.18572123811128471, 0.19769272210007816, 0.20566954727302278, 0.17487596953558715, 0.17941504583065437, 0.17670916991126884, 0.18340560963869268, 0.18343064504959838, 0.14507541788531675, 0.486983862686449, 0.19381879564725035, 0.1449844696965913, 0.13973882488989642, 0.46663139179034674, 0.16339435095101362, 0.44101827517179426, 0.2055205654957255, 0.44066063509758957, 0.19846768595898479, 0.16022717439680034, 0.16528433542032905, 0.16769520466300147, 0.36893604224496357, 0.34490795938517527, 0.17171175175289477, 0.17705238157195513, 0.19944676219534008, 0.18370197527162369, 0.2151170849729972, 0.1818844807923523, 0.1758048292735368, 0.1940321653107583, 0.194031046921201, 0.07739350502489983, 0.07239178365469667, 0.0748967470968317, 0.08295129049312489, 0.08496542763047055, 0.08989007418579953, 0.09349048656444969, 0.08588692941018239, 0.09954805162798397]}, "mutation_prompt": null}
{"id": "a4085573-6fee-4a50-a0b6-ed883d3814f5", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWCT:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.chaos_map = np.random.uniform(0, 1, size=self.swarm_size)\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def chaos_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Chaos theory for increased diversity\n                if np.random.rand() < 0.1:\n                    self.chaos_map[i] = self.chaos_map(self.chaos_map[i])\n                    self.particles[i] = self.lower_bound + (self.upper_bound - self.lower_bound) * self.chaos_map[i]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWCT(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWCT", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Chaos Theory\" (HSO-ACL-OBL-DIW-CT), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, and chaos theory for increased diversity.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'numpy.ndarray' object is not callable\").", "error": "TypeError(\"'numpy.ndarray' object is not callable\")", "parent_id": "8975bb58-a643-4997-aebd-afcc715cd30e", "metadata": {}, "mutation_prompt": null}
{"id": "59733327-24ab-472e-8474-773e12bd59f3", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWGM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.gaussian_mutation_rate = 0.1\n        self.gaussian_mutation_stddev = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def gaussian_mutation(self, position):\n        return position + np.random.normal(0, self.gaussian_mutation_stddev, size=self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Gaussian mutation for increased diversity\n                if np.random.rand() < self.gaussian_mutation_rate:\n                    mutated_position = self.gaussian_mutation(self.particles[i])\n                    mutated_position = np.clip(mutated_position, self.lower_bound, self.upper_bound)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWGM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWGM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Gaussian Mutation\" (HSO-ACL-OBL-DIW-GM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, and Gaussian mutation for increased diversity.", "configspace": "", "generation": 17, "fitness": 0.19269702749731327, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWGM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "8975bb58-a643-4997-aebd-afcc715cd30e", "metadata": {"aucs": [0.3408364024440784, 0.33669527128417154, 0.33290086378853645, 0.3210068091366287, 0.33499150129048094, 0.3404777826953139, 0.32593132413210113, 0.3329825829719879, 0.33383269351113654, 9.999999999998899e-05, 0.00738404064803122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10756105477379774, 0.09564300789960489, 0.10159605432645535, 0.09869975877496451, 0.09081931719338754, 0.08564182833714973, 0.10491001607019423, 0.10868869719302998, 0.07542854433097146, 0.07022418403156894, 0.08255930929574584, 0.08250455976264603, 0.09199637690060847, 0.09068169714905139, 0.08437412520374743, 0.10619629723569146, 0.0785776177857409, 0.0912125567711839, 0.9098678941961285, 0.9311679893959449, 0.892387801871215, 0.8733939263737636, 0.8924143159534812, 0.8987797451757289, 0.9335513671609409, 0.9072648695225088, 0.9184748855959202, 0.2199419256960753, 0.2351829760874009, 0.2246621049423485, 0.2474060036582979, 0.225096303631798, 0.2206508135819889, 0.2564978714116707, 0.21017165373919366, 0.210077042195999, 0.2567150916343732, 0.29114800887917636, 0.30070322630578683, 0.2259048932819867, 0.27757807822660996, 0.20953894196942624, 0.23836271553728783, 0.1980113981102961, 0.2464966955585105, 0.14275024099487177, 0.08199856232280944, 0.13222446510604546, 0.16507393660299707, 0.11528978509758858, 0.12030230564170119, 0.13844972014608792, 0.12543773104755418, 0.15368836772596928, 0.13139400213092978, 0.14725610829104774, 0.13623513857718628, 0.13010183302588452, 0.12419270997756171, 0.13536324197007454, 0.135143546979554, 0.13448739006544297, 0.09773600844287045, 0.0023280223835921987, 9.999999999998899e-05, 9.999999999998899e-05, 0.019956329943668027, 0.00027686312448493844, 9.999999999998899e-05, 0.0011457975290549705, 0.00016648627896753698, 9.999999999998899e-05, 0.08032436636782603, 0.09427277147763524, 0.1369044947038598, 0.07723797667404675, 0.053043207773122214, 0.03145319870784946, 0.10430789827090592, 0.06465607337725254, 0.09832716240086925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0622921667562748, 0.06501406003174925, 0.061243023637086336, 0.060976950015253495, 0.06677865103059955, 0.048913301464988734, 0.06283672729341083, 0.06372083416105034, 0.04682113834676527, 0.32850941803897626, 0.32710770527622846, 0.3336191495606933, 0.33335654125406833, 0.3318495190710461, 0.3214396257320469, 0.33850167420893595, 0.3359913794977246, 0.34640247979398386, 0.10244158430119055, 0.09455637324882737, 0.083681004041672, 0.09488451599217662, 0.09243795810668076, 0.08351698963160381, 0.09582623537773693, 0.09705368319080021, 0.10020402453156352, 0.14990148546344084, 0.16537096141412788, 0.13329849888543432, 0.18421381778096524, 0.1738956701863379, 0.18710366959874247, 0.1837718678156569, 0.17852695608868707, 0.1752286379216137, 0.24845310580674995, 0.23905543003875107, 0.24687408045785697, 0.25281403897874577, 0.2398136381395911, 0.2488397946158014, 0.24133819522184807, 0.2631416078559762, 0.24702257429464658, 0.19761599040754652, 0.18749740119856273, 0.19991036022215247, 0.20168723503871278, 0.19351627117979175, 0.18732968241276393, 0.15703831269322122, 0.20029539519748818, 0.17927309090290733, 0.23399309207223173, 0.21440324561214574, 0.23494153648949667, 0.21267730784349337, 0.2150341492965131, 0.2125677932051896, 0.23004970369284183, 0.2344976371426961, 0.22406839114805588, 0.19822726994430728, 0.18045167949553675, 0.18964383446132793, 0.19204138606103138, 0.19272182003954774, 0.1849469777519801, 0.21723466594752583, 0.18622416180458057, 0.17542140091289826, 0.12776088485668147, 0.18206111039231543, 0.4862042206370226, 0.46125360177324637, 0.192535539702113, 0.19128690737511456, 0.1386715634909257, 0.4365373282016971, 0.44368548837366506, 0.4395041037362918, 0.20823268264124473, 0.41994751616353676, 0.3374965898176765, 0.16571953873374445, 0.16587241957323917, 0.16589753025122245, 0.3978491542999111, 0.4117452052986388, 0.1833909515799531, 0.20804250200254137, 0.19422851097026328, 0.17475264322787898, 0.1918573432123135, 0.1716985775313773, 0.18580898233804477, 0.1793066014111977, 0.17906505041899723, 0.082400578034042, 0.0777171747312061, 0.07724794876878072, 0.09376504070392988, 0.0921512255729573, 0.09371186959715327, 0.09135866734750364, 0.1000513637413113, 0.08236242878809485]}, "mutation_prompt": null}
{"id": "9e101078-fd0d-4379-8055-484ef07848e1", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Self-Adaptive Mutation\" (HSO-ACL-OBL-DIW-SAM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, and a self-adaptive mutation strategy for increased diversity.", "configspace": "", "generation": 18, "fitness": 0.19519787911598113, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "8975bb58-a643-4997-aebd-afcc715cd30e", "metadata": {"aucs": [0.34586637947182064, 0.3393439331007596, 0.34757014024885646, 0.3482876788738235, 0.3376875989586188, 0.3296295202520847, 0.33563166267520683, 0.34159491703168454, 0.3566178498535205, 0.002480067215975046, 0.014452548641350371, 0.0006738999753702624, 9.999999999998899e-05, 0.011462119229441292, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09416538378994721, 0.12136159168129856, 0.08293289778501745, 0.10237209985856821, 0.09096489155022591, 0.09386891714722456, 0.11228226209930703, 0.10013112133071422, 0.07844404782750602, 0.08030930831792116, 0.08951637703199489, 0.09501113259670124, 0.07629361798256562, 0.06909009725986359, 0.10011805696749143, 0.08012737155606442, 0.08365977486313947, 0.09676234890398538, 0.9076467325844689, 0.9436289072961669, 0.9206918974886313, 0.8624792044806572, 0.8744238280794214, 0.879773460890343, 0.9311933377121485, 0.9278949708948651, 0.9127505029655163, 0.20895970082865756, 0.20299554616608118, 0.2263552825872699, 0.25022696163322566, 0.21831112823837906, 0.21023202252031825, 0.23326963745172846, 0.2067169225212282, 0.2378665901598772, 0.27797479763586097, 0.24257146440304367, 0.2534474435833983, 0.26818716275726706, 0.2624775443924563, 0.19652652886318678, 0.2742556150698877, 0.22211109771936466, 0.28663688876877835, 0.11612679608646015, 0.07373047856719983, 0.11595715429603426, 0.07553042286321943, 0.1258284369046181, 0.12542300023992015, 0.12009283085784794, 0.0971390754878626, 0.14839177354585664, 0.12512536365574056, 0.12447405270240375, 0.11133787562296549, 0.1717313206587785, 0.13692355111804133, 0.1307174005746068, 0.10355913862660804, 0.12973219921935775, 0.12214645626777854, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032116123723131884, 0.001357364386244675, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010070744139724419, 0.08252107890596527, 0.03977963878780466, 0.12868526606355335, 0.08078643168063604, 0.05891816375131298, 0.05690190893087643, 0.08862070000255551, 0.0701031222670272, 0.12790415787686182, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06291757068160131, 0.05811303127540268, 0.06808560832396038, 0.07228610599511665, 0.062129177479978925, 0.07847771389641767, 0.08849644882546237, 0.06128068331621084, 0.0631657077228791, 0.32441990377788466, 0.3335960787853611, 0.33379370345956905, 0.33719559530702903, 0.3481513547507429, 0.32251196335007526, 0.3517013262957872, 0.34357095070415333, 0.33667863599754744, 0.0923641250117031, 0.0891080672423159, 0.10977749957779337, 0.1100620531780403, 0.08905276247446103, 0.10566133251402776, 0.09871087189533811, 0.10518716053940702, 0.10204728679876407, 0.1717172764826873, 0.1378738581972493, 0.17372355947987594, 0.17844098508761108, 0.19741019191108178, 0.21412471766157726, 0.18353689106442972, 0.13513864362120875, 0.22385041741453282, 0.24078983378711005, 0.2495211195730327, 0.2470469209351952, 0.2383192463092687, 0.24610290152222836, 0.24381527916097456, 0.24150593186922364, 0.25354167830729624, 0.25265735468490924, 0.16153448123656577, 0.19228270365714273, 0.19833990739591778, 0.19640355077313065, 0.18695951029419677, 0.1829518658756134, 0.17584538812254924, 0.18612995471918203, 0.16781451794151014, 0.24306088127557646, 0.21663082056544247, 0.23384085627897233, 0.25194824922186565, 0.22718348426325063, 0.23087790167065636, 0.209754161242529, 0.21930718808863647, 0.2249557048756502, 0.17112269175184847, 0.1768341516147811, 0.1778244183186145, 0.19179519764888975, 0.19018385765536439, 0.18615912576036053, 0.20036340690991605, 0.19103830514927533, 0.17255172775803362, 0.4472341181562447, 0.18216048652213424, 0.46701432623741457, 0.497255813183078, 0.1951830757187658, 0.1924166748376407, 0.14013830851883302, 0.43394824694271106, 0.4442522029984578, 0.4243139629289613, 0.20655990888028386, 0.3567678703855136, 0.3051856379565382, 0.3394114948833893, 0.16673122361421955, 0.16615749882320308, 0.5036646725140181, 0.4224597414290078, 0.18066274969476925, 0.17885698538294892, 0.18577856065569587, 0.18153050905162726, 0.17517670665801777, 0.19948955856717754, 0.1767127238845927, 0.17729763678277344, 0.18622824903793578, 0.09566404121376126, 0.07757964529656003, 0.07809852848915977, 0.0866132947294096, 0.08164147811195366, 0.08313716340024746, 0.07633405003234672, 0.08877803268530282, 0.08890635495396015]}, "mutation_prompt": null}
{"id": "04ee5870-23c6-4deb-9aef-f0f9232afcac", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMCM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.chaotic_map = np.random.uniform(0, 1, size=self.dim)\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Chaotic map for enhanced exploration\n                if np.random.rand() < 0.1:\n                    self.chaotic_map = self.chaotic_map(self.chaotic_map)\n                    self.particles[i] += self.chaotic_map * np.random.uniform(-1, 1, size=self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMCM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMCM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Chaotic Maps\" (HSO-ACL-OBL-DIW-SAM-CM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, a self-adaptive mutation strategy for increased diversity, and chaotic maps for enhanced exploration.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'numpy.ndarray' object is not callable\").", "error": "TypeError(\"'numpy.ndarray' object is not callable\")", "parent_id": "9e101078-fd0d-4379-8055-484ef07848e1", "metadata": {}, "mutation_prompt": null}
{"id": "94ac8563-3589-4215-ba6d-bfcc7271f6ef", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMCM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.chaotic_map_lambda = 4.0\n        self.chaotic_map_mu = 0.9\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def chaotic_map(self, x):\n        return self.chaotic_map_lambda * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_map_values = np.random.uniform(size=self.swarm_size)\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Chaotic map for enhanced exploration and exploitation\n                chaotic_map_values[i] = self.chaotic_map(chaotic_map_values[i])\n                self.particles[i] += chaotic_map_values[i] * (self.upper_bound - self.lower_bound) / 4.0\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMCM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMCM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Chaotic Maps\" (HSO-ACL-OBL-DIW-SAM-CM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, a self-adaptive mutation strategy for increased diversity, and chaotic maps for enhanced exploration and exploitation.", "configspace": "", "generation": 20, "fitness": 0.16549190632121824, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMCM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.15.", "error": "", "parent_id": "9e101078-fd0d-4379-8055-484ef07848e1", "metadata": {"aucs": [0.32520448002325064, 0.3136911108064785, 0.29022526961535156, 0.31007825161344693, 0.31141221948022946, 0.33197795532123786, 0.3725267146989678, 0.31810817754704024, 0.32510718919806103, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007872926892185106, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07655195372915136, 0.07025610916938962, 0.08672974255263288, 0.09043436777804414, 0.09414353549235088, 0.09385563915290662, 0.11010162067937912, 0.08647934189132489, 0.09148124100140576, 0.08480095941190835, 0.08045853666542857, 0.08031699790710589, 0.07178989747173414, 0.06814248151618851, 0.0853757450257866, 0.07944547011900016, 0.0677683190179067, 0.06429575418960254, 0.8635695439396758, 0.9570949000151445, 0.7631209278868102, 0.16572569698668704, 0.13349281869860807, 0.13430802686583243, 0.8745771800652524, 0.8769220489596768, 0.8800975983980344, 0.22737247362957158, 0.16664772149777252, 0.20618620516773867, 0.2120906177731653, 0.1782007267991581, 0.1716425032325677, 0.17312139117410785, 0.1690577211231843, 0.1743051948935983, 0.27417266292302855, 0.282064425380982, 0.2675909850492795, 0.2471189375486752, 0.23092866036325554, 0.18784986314259755, 0.17865743468097695, 0.172727235165827, 0.19147397397782528, 0.06518181605337581, 0.09053676545150868, 0.07920707142200756, 0.009504451867454411, 0.1015607580273854, 0.11523226116154694, 0.12755342552562832, 0.07869081240023568, 0.13901679673728262, 0.1127248677069409, 0.11038022241544931, 0.09386198683139213, 0.1250908790028341, 0.12765886420639194, 0.11098538649735723, 0.12565363104209515, 0.1331392796594033, 0.119162171785962, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010124843702585373, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0655565404433448, 0.039838916457483164, 0.0581153614118044, 0.08362272178090258, 0.07764224702621692, 0.05003113585269825, 0.05098969989289159, 0.046072411690862514, 0.09268565910791693, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048193877424537956, 0.04983535202201006, 0.048719963723814375, 0.04162316613372752, 0.062471297454910424, 0.06079988809715231, 0.04557454952033457, 0.0640495214880149, 0.05970894286995043, 0.3471775012432219, 0.3147968808976259, 0.325721404565415, 0.32200937903340165, 0.3287089587917671, 0.3290549631732892, 0.33931725202613894, 0.3070201405841876, 0.32927029038784283, 0.08405809491093119, 0.08287839095189409, 0.07613662816449229, 0.09187823582818877, 0.06818907327691937, 0.08940166932430016, 0.09229364288069486, 0.09262795617604114, 0.09287040608330754, 0.1490822626957895, 0.14086603331237857, 0.15953903771702171, 0.15008718348541283, 0.16380046423068706, 0.13209561258876001, 0.13479231504133027, 0.13457867839485282, 0.17937599581340868, 0.24774106451772837, 0.24700784822512611, 0.24270659260628058, 0.22215858304101033, 0.2352413692741152, 0.2162477058130634, 0.1956644055570954, 0.23836401065988344, 0.2206758667774147, 0.18418617846187768, 0.1808448683005367, 0.15423926115293873, 0.18601432605572255, 0.1871085039232948, 0.17490493665893614, 0.15815387208638565, 0.18633987310812306, 0.13892404043622664, 0.23945770098799424, 0.23712969664650363, 0.2412318997119124, 0.23572773644026157, 0.19565561554794075, 0.2292777227255811, 0.241809606472128, 0.22402612258332066, 0.21936182203601762, 0.18339286629413942, 0.18479479743587124, 0.179613170242376, 0.16895664332112903, 0.17367369884740014, 0.17691681234448753, 0.1740128510732517, 0.1696831661216076, 0.18780105635551037, 0.16833194550395836, 0.16450757007548777, 0.18132302327467542, 0.17024230486465808, 0.1898379503611891, 0.14151431389495395, 0.13806221216988945, 0.14161788518508234, 0.16140798441517235, 0.35463449803910596, 0.16712064183250164, 0.27022223599466755, 0.3932382202140823, 0.3443038892187821, 0.16536693970186866, 0.35410307756603265, 0.4541548893213767, 0.346976182557716, 0.1812573745923004, 0.17747102295919615, 0.18084047010379445, 0.19588464278975937, 0.20797631411827577, 0.17559612540243275, 0.17917969136988499, 0.18135219961147853, 0.18609814328354346, 0.09575351601596338, 0.08193482013299724, 0.08215321978860102, 0.08564077819957161, 0.07562749960265991, 0.10111227260595934, 0.08135816798086615, 0.0866335063202256, 0.08178009989296375]}, "mutation_prompt": null}
{"id": "b9e69bde-1223-400e-b6ab-01b445957e20", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMCM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.cauchy_mutation_rate = 0.05\n        self.cauchy_mutation_scale = 1.0\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.cauchy_mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim) * self.cauchy_mutation_scale\n        return position + mutation_vector * mutation_mask\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Cauchy mutation for further exploration\n                if np.random.rand() < self.cauchy_mutation_rate:\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMCM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMCM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Cauchy Mutation\" (HSO-ACL-OBL-DIW-SAM-CM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, a self-adaptive mutation strategy for increased diversity, and Cauchy mutation for further exploration.", "configspace": "", "generation": 21, "fitness": 0.19273172708734926, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMCM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "9e101078-fd0d-4379-8055-484ef07848e1", "metadata": {"aucs": [0.35242566638903317, 0.3450919729617494, 0.34092078481758437, 0.34091466468684795, 0.3547241935701285, 0.33976108855958087, 0.34009272677160407, 0.3239601308847043, 0.3322242050922044, 9.999999999998899e-05, 0.01743549042221426, 0.011707549990205512, 0.0066212150845677, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11200884802442723, 0.09143143947128318, 0.09788232556518595, 0.10271280591169452, 0.0975169458011631, 0.1130887745702317, 0.0809394836182239, 0.12512012474707956, 0.12695113784537138, 0.08681554926360002, 0.06971953253377228, 0.07406908231725517, 0.08127022438307685, 0.09181188095721937, 0.07890862502441376, 0.08148016736889296, 0.05225371458896222, 0.08825780191798316, 0.9105082617060927, 0.9430143192049926, 0.9092491729942246, 0.868832329368341, 0.8646198565855485, 0.9238523754350283, 0.9396929749664222, 0.9371518816281892, 0.9137972136982968, 0.22301455747083243, 0.20986437812302194, 0.23031962062882672, 0.21159168076356705, 0.21428522075144718, 0.21369378140619677, 0.22253546909497235, 0.2452577202055639, 0.1965606000445398, 0.2615625449754574, 0.25462952350104906, 0.2669647404540647, 0.264737931347645, 0.25464293778044866, 0.23619127582073374, 0.2540547371795613, 0.265595947704389, 0.3042433905701052, 0.12808137106850315, 0.13330869128772815, 0.11640686148852997, 0.12587430666698152, 0.14003697149582328, 0.11596911859812375, 0.1273279481190862, 0.11831905898514428, 0.13556812188711187, 0.12612176693819488, 0.12027500242520106, 0.14845275701142724, 0.12314997618034307, 0.1239460974814508, 0.12865783184438373, 0.1383911883349156, 0.14496939324251545, 0.12589751792098614, 0.008640113706744001, 0.0005622533324882717, 9.999999999998899e-05, 0.005982554890103686, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11877197835773456, 0.0636678007394188, 0.09947919810581751, 0.05522397193595985, 0.03269733266259156, 0.022207757364102743, 0.09659278603443944, 0.05516899555581589, 0.08737889531891363, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07165197904986564, 0.06084244891828494, 0.06822892919922052, 0.05504114720452147, 0.06140324453175139, 0.04903338179162764, 0.054184494355980495, 0.06349192535007564, 0.059979402705387486, 0.34616749713194817, 0.3332169596036554, 0.35503149018497393, 0.3270610539888128, 0.3720688267728448, 0.3362628691489946, 0.32765192995288706, 0.3259055436766438, 0.3484181725034161, 0.0849563385842983, 0.10394897352131593, 0.10685512101639727, 0.09238178620980342, 0.1028472614481365, 0.09485500964443017, 0.10021218976938595, 0.10222456578430594, 0.08896171008066978, 0.14382553044213242, 0.17566513555847563, 0.12506460109711992, 0.16764128496809605, 0.1734230584474662, 0.2044544077258863, 0.16958745750854454, 0.1652597995553411, 0.1509022026815492, 0.26331325685871565, 0.2414287445443607, 0.2429653333654035, 0.24270725855036046, 0.2607206985431796, 0.24863583186284466, 0.2071751426392483, 0.2640624298169266, 0.2612161833052892, 0.20011274256044875, 0.18367541809699173, 0.18680791458752988, 0.20060236093631667, 0.1952038388660572, 0.1911627347613406, 0.17527650631464875, 0.18445806815311216, 0.1655065149051126, 0.228673600445486, 0.22071067509578068, 0.21929854270438742, 0.22951096886169087, 0.2303134120227548, 0.2367789709718381, 0.22059127634466114, 0.21345760968110594, 0.22033045168221765, 0.18451996415823746, 0.1870421941957764, 0.18165397206285794, 0.18917330620505668, 0.18835383495728397, 0.17197742459428467, 0.19280006618556667, 0.17120872429477763, 0.17327217270564066, 0.12679124197198222, 0.18268233912824883, 0.18118440655559176, 0.49635439368254675, 0.19515954575279304, 0.16567497572523537, 0.1393871181205203, 0.5916514307642353, 0.450726635974812, 0.4483905353064903, 0.20599767325455287, 0.4949192741250539, 0.4356760905341991, 0.16536553506158125, 0.16490923365641297, 0.16630548276693202, 0.36206491183526246, 0.4791212787761253, 0.17760171612920206, 0.18415203702560956, 0.1739256435419022, 0.17840436974226237, 0.19375286912685774, 0.18886376933734705, 0.185155938411251, 0.1727390795469146, 0.16997746259286706, 0.0854017712463101, 0.09039242757627985, 0.08141889052622409, 0.07702237507139598, 0.07466067306481194, 0.08384904947633698, 0.08085800011349453, 0.07802595513951416, 0.0902728287243455]}, "mutation_prompt": null}
{"id": "17658329-c8fb-4561-a42d-b75b6d64346a", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.995  # refined inertia weight damping ratio\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.mutation_rate_adaptation = 0.01  # new mutation rate adaptation parameter\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.mutation_rate += self.mutation_rate_adaptation * (1 - self.mutation_rate)  # adapt mutation rate\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2", "description": "HybridSwarmOptimizerACLOBLDIWSAMV2, a novel metaheuristic algorithm that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, and a self-adaptive mutation strategy for increased diversity, with refined strategies for inertia weight damping, mutation rate adaptation, and adaptive cooling.", "configspace": "", "generation": 22, "fitness": 0.1657564327656035, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.16.", "error": "", "parent_id": "9e101078-fd0d-4379-8055-484ef07848e1", "metadata": {"aucs": [0.3166950897736731, 0.29903072646811046, 0.32833235358512125, 0.3077125897161064, 0.3030870553202598, 0.30806665657608967, 0.32507162629023056, 0.3167232350943854, 0.34118533348037583, 9.999999999998899e-05, 0.00589989959619619, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0912982824730818, 0.11738314902582248, 0.07382988999975693, 0.09588065444403093, 0.06932956706738713, 0.08722050030688877, 0.08415101281640458, 0.06792394065634744, 0.07444933531955045, 0.0696271238898718, 0.08333828777526686, 0.07129687614687663, 0.09513410467846095, 0.0459929214621958, 0.06794759671518258, 0.06252879852440107, 0.053513813424925005, 0.06068461549597304, 0.7239095378692186, 0.9149114474021349, 0.8409237102731836, 0.5754515816200281, 0.7685557376819605, 0.6897688824276047, 0.8713680871521635, 0.8963153845357902, 0.880821250259193, 0.1871289942950478, 0.1638645818053548, 0.15580921589005647, 0.18424042525379924, 0.1494925352403227, 0.18020624425134446, 0.17877549645566893, 0.14248012726271586, 0.20789616618127493, 0.23027285078116166, 0.2690583514633972, 0.2434978866146723, 0.24836501367811825, 0.24281825627171605, 0.2147766219010664, 0.2002355321534074, 0.14949520018461093, 0.23625944859786263, 0.13025901440156362, 0.0642831556851986, 9.999999999998899e-05, 9.999999999998899e-05, 0.10733039981412928, 0.11400008721801991, 0.10947681330272696, 0.009651620278645856, 0.09401562432438804, 0.10514974730047033, 0.09099727527042611, 0.06045570477326434, 0.08912942927386047, 0.12380354257944515, 0.116721431860898, 0.10756488233022521, 0.1063716089238349, 0.10573908005475918, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08976610246704986, 0.04395565420692382, 0.05916243180160763, 0.04030845043739151, 0.052436053346089695, 0.048006523487516106, 0.07927576721661667, 0.034193279657142694, 0.05702443557310366, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0543150868497938, 0.04087440987785662, 0.03665738843506294, 0.041447988636745814, 0.03541650110292738, 0.04091459020303134, 0.03897140099803453, 0.05167036998314145, 0.04505171169731548, 0.3265508454748841, 0.30372810824022967, 0.309698452844956, 0.2973315284050386, 0.31335178198108826, 0.3223883864870587, 0.3202141690046033, 0.30891542549012696, 0.3477326484003671, 0.0634289532866229, 0.09664852740201335, 0.07480391871026681, 0.08417307004398211, 0.06709047080603248, 0.10158853667614387, 0.0805247519884208, 0.09054956632561095, 0.0856846784960108, 0.15157227151122987, 0.1662012103381496, 0.14540497319499301, 0.16211956688974238, 0.184750463982721, 0.16092927585264338, 0.15697449802426633, 0.1320946177988166, 0.17560879883395042, 0.22239196906811098, 0.22527383584102534, 0.24131750907751226, 0.23649802044610257, 0.22600883757307788, 0.2184209487680694, 0.24056974147915455, 0.2336432826325442, 0.18528865574233266, 0.18173844076845425, 0.17376306722733226, 0.17478737129828226, 0.1715623269964741, 0.17442158517656248, 0.17806277814988714, 0.15971270010819005, 0.18288908686349326, 0.1595929091398568, 0.19903789872611044, 0.19702728093025768, 0.20411043191180767, 0.21244051971574962, 0.21541491947276004, 0.22134803429016314, 0.21299385152897132, 0.1996173355020514, 0.24010858877453, 0.1740666770994661, 0.17724884328516455, 0.1710879721552654, 0.19151852005920678, 0.1905798298884993, 0.17081770261024298, 0.1802540315722304, 0.20773276292462217, 0.16767794685242965, 0.12646412827466902, 0.17676568662863124, 0.1830447709119709, 0.31929720452743304, 0.19224795087373847, 0.18213609684063536, 0.13730961350331983, 0.1457832885642507, 0.39967377677105453, 0.31299898039564333, 0.19717977380967344, 0.1292216111305674, 0.1982433541554336, 0.26838577727027313, 0.16524365544615338, 0.16479657806126213, 0.10306234953624427, 0.46678309187252576, 0.21025613822500988, 0.17737764832141945, 0.1784559349435445, 0.1907749881210048, 0.1887716072627097, 0.1879925804099991, 0.17662570448118076, 0.16520542110242842, 0.17160395700963527, 0.09141612002645416, 0.059509867056483756, 0.09061987850800546, 0.06602321488236962, 0.08337545150946768, 0.07459243503802082, 0.09527266409227708, 0.08851206315284255, 0.09204923751301264]}, "mutation_prompt": null}
{"id": "6a7f34aa-6c78-4db5-a567-9f4cb35a90a3", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.4  # changed from 0.5 to 0.4\n        self.levy_flight_alpha = 1.2  # changed from 1.5 to 1.2\n        self.levy_flight_beta = 1.6  # changed from 1.8 to 1.6\n        self.opposition_based_learning_rate = 0.25  # changed from 0.2 to 0.25\n        self.inertia_weight = 0.85  # changed from 0.9 to 0.85\n        self.inertia_weight_damping_ratio = 0.995  # changed from 0.99 to 0.995\n        self.mutation_rate = 0.12  # changed from 0.1 to 0.12\n        self.mutation_step_size = 0.12  # changed from 0.1 to 0.12\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.22:  # changed from 0.2 to 0.22\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMRefined(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMRefined", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Self-Adaptive Mutation\" (HSO-ACL-OBL-DIW-SAM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, and a self-adaptive mutation strategy for increased diversity, with refined strategy.", "configspace": "", "generation": 23, "fitness": 0.1858422307378071, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "9e101078-fd0d-4379-8055-484ef07848e1", "metadata": {"aucs": [0.3341472742839652, 0.34967896626393036, 0.3474777573827672, 0.3259000566305358, 0.3177362899557449, 0.3609424739309973, 0.3357633443381688, 0.33854623251003524, 0.3264932379915185, 9.999999999998899e-05, 0.0016261454281398802, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09286539575687836, 0.08846555087531616, 0.09176436397994236, 0.08278130088779945, 0.08637314725858358, 0.08801557068830057, 0.09042783521728581, 0.0974270653385807, 0.11572982111524655, 0.07931185550468522, 0.0973109534478086, 0.08959238150935367, 0.08520054020227197, 0.05840195167916573, 0.08809027897304755, 0.09357240350060547, 0.08102175021513447, 0.07388577981040412, 0.8978728123408397, 0.9378376449293817, 0.8744854206950469, 0.8527416818292227, 0.8371071416316573, 0.8623765567489663, 0.9201774253636519, 0.926983101588538, 0.9030172688654781, 0.225078617302908, 0.22546044421630795, 0.20983442487256143, 0.20719849211695285, 0.20362125353701388, 0.22350057517591693, 0.20837255385941333, 0.21903660756929388, 0.2133943555291824, 0.2594949725586285, 0.28313405459343544, 0.27942451719623407, 0.27262916436040363, 0.25913275583459705, 0.2514332214831553, 0.22949921232391235, 0.23173761872083887, 0.2536985582000002, 0.12886458105374854, 0.10451313374432791, 0.1169020604943184, 0.09101020185748643, 0.1141257980738919, 0.11643252714448227, 0.1208970839224619, 0.1150582830615351, 0.1335336475221669, 0.12278687409058398, 0.12202110684803724, 0.12873607758558625, 0.13023995634622465, 0.1541961317952868, 0.11798211218648635, 0.11346012620894708, 0.13033903104607125, 0.09549214409283047, 0.008871492822009719, 9.999999999998899e-05, 0.0002543772942357192, 0.018478314173416943, 0.006957399485957638, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10583997025819936, 0.05474155485066601, 0.11673305266357803, 0.0652772966333236, 0.0949290107596178, 0.0501345129378451, 0.12938950666647975, 0.05636227790482551, 0.0556274887871403, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06123415647793429, 0.06145671138594788, 0.06948919889374972, 0.062075701654999094, 0.05362894577759958, 0.05567435016222222, 0.05471543203748952, 0.05933677199751142, 0.04611409482055895, 0.3260766694026903, 0.3290681762302684, 0.3309461118586351, 0.3203046593585104, 0.3247514238963498, 0.3570917879435941, 0.31662455363375164, 0.32612963664194317, 0.334509581830862, 0.08295149618711872, 0.09863852238827897, 0.10922217206363816, 0.09118505453139347, 0.10482711535102829, 0.11392271313367164, 0.09918427122117368, 0.09747136004487655, 0.10647375757491484, 0.16134730853196655, 0.1899867975445806, 0.1398515600568202, 0.16694856361343502, 0.1921390782869069, 0.18114753305206055, 0.15665590731299017, 0.16918205739396475, 0.1517566626910073, 0.24620023550941694, 0.2529438706291567, 0.24357500656881959, 0.24695862938414903, 0.23875046302124892, 0.2521988018329948, 0.2567503424245072, 0.24693318347237625, 0.2248076300359102, 0.17541987846296214, 0.18997227892246937, 0.20462711349440843, 0.20979589657855513, 0.20161831954799359, 0.19209113898622965, 0.19845483529303953, 0.1873714682535662, 0.1816715690149615, 0.21810791271026475, 0.20644257763353657, 0.2171846578918607, 0.22552650978062527, 0.22646011894988982, 0.2374532422393374, 0.2271985005587831, 0.2292564665906176, 0.22413475876822264, 0.18736449350151518, 0.16991848040365098, 0.1877736149690611, 0.17719768745176756, 0.20542194505823796, 0.1994608502408286, 0.19554490629390608, 0.19416723729369245, 0.1699619782584756, 0.18012159675583894, 0.18017046536072445, 0.14357115455313452, 0.5017758374778694, 0.19256631421075643, 0.19220733828291903, 0.13908399328425058, 0.1495833800082128, 0.4722171534288535, 0.43361417517663925, 0.20330773631619603, 0.3821180843107489, 0.20046264576380368, 0.16582309089307512, 0.16570640100771328, 0.16555050378058167, 0.11298338496847504, 0.36500395084791937, 0.16885509387382813, 0.17769985979279956, 0.18203363092066716, 0.19655656844678915, 0.194656164020389, 0.17923738703800396, 0.18907864910300742, 0.17536578452871932, 0.18216386753224345, 0.10835698826479567, 0.0896639756787927, 0.07785917386428698, 0.08684721849399069, 0.0926403276356561, 0.08663109208537867, 0.07575894938028271, 0.08018300594929528, 0.09241309088669203]}, "mutation_prompt": null}
{"id": "deb8a20f-c9bd-461b-8364-f7f3e6213be3", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMCM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.cauchy_mutation_rate = 0.1\n        self.cauchy_mutation_scale = 1.0\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.cauchy_mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim) * self.cauchy_mutation_scale\n        return position + mutation_vector * mutation_mask\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Cauchy mutation for enhanced exploration\n                if np.random.rand() < self.cauchy_mutation_rate:\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMCM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMCM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Cauchy Mutation\" (HSO-ACL-OBL-DIW-SAM-CM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, a self-adaptive mutation strategy for increased diversity, and Cauchy mutation for enhanced exploration.", "configspace": "", "generation": 24, "fitness": 0.18943204672439573, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMCM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "9e101078-fd0d-4379-8055-484ef07848e1", "metadata": {"aucs": [0.33240493142805605, 0.32294017408225895, 0.3366317943295032, 0.35793740813377384, 0.3365756642560528, 0.3339992704031539, 0.340905602425997, 0.31729193782444753, 0.3427614791229041, 9.999999999998899e-05, 0.005827623499682688, 0.007070272196344374, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11648378153928207, 0.08794861987675306, 0.09243970992679729, 0.1214347971478612, 0.10059030158262516, 0.08657632302412366, 0.10629107647387714, 0.09938350274727803, 0.1095387668545782, 0.08571304939289548, 0.08385316137894516, 0.09379181745882947, 0.0903499696436908, 0.07961140360005359, 0.08565337216661606, 0.09307492811728024, 0.07535224731848666, 0.08666412120537537, 0.8975512767172635, 0.946527860700735, 0.8982645022746453, 0.8639351926528103, 0.8883961069931712, 0.8850652139553865, 0.9135908243029007, 0.9236507276253892, 0.9125523251750264, 0.20649219161820687, 0.22068106346913674, 0.20175822749838035, 0.21340776260404415, 0.24069767932875052, 0.22339125209907662, 0.2301924619344633, 0.20338368615058455, 0.20888974822906603, 0.29314620647965817, 0.29126244963955017, 0.2636017439704669, 0.2049752559670176, 0.25396665113155514, 0.22530050036466864, 0.2810652398546114, 0.2204711707689636, 0.25699849369461814, 0.12228716192814448, 0.11284265805245863, 0.11436001462788259, 0.08717751624862269, 0.11906560137654765, 0.11943310185793576, 0.12741503014515965, 0.0809797979697956, 0.15605199548191362, 0.1275486757887162, 0.1346972336194303, 0.115520413843889, 0.13382790983724135, 0.12639153808610448, 0.11550009129635852, 0.12246503883123439, 0.11850457999891095, 0.12004393044978934, 0.012152276915976423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002898963927845055, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08193121188901709, 0.05455837801610308, 0.08385564487617447, 0.06357712106517033, 0.056589761856244536, 0.05443673138068028, 0.06023666264962846, 0.11029566848617867, 0.06897474019659822, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06459653075448712, 0.06100967902616761, 0.07117247942009342, 0.060474947823904945, 0.05512768653218869, 0.06556119633626878, 0.056547012862530055, 0.06123543573256607, 0.04432216459437277, 0.3266411256616242, 0.33538886018916614, 0.3301476634029298, 0.3095170464983642, 0.3170588065054587, 0.3332442821898628, 0.32919307725147195, 0.329883797006291, 0.33414803749029975, 0.10329516129499339, 0.0971881837586368, 0.10574199209666424, 0.12583753723385094, 0.11410097285147713, 0.09534052338857468, 0.08473096984882245, 0.11132522248021415, 0.08765789134886659, 0.1332355545612106, 0.1638919186711133, 0.13535171400515866, 0.16671373587429938, 0.18705637004072817, 0.19322375294705996, 0.1789088609733428, 0.17795716326220756, 0.1788101824974616, 0.25727481426805965, 0.2469718228400326, 0.25031683473433797, 0.24850742837840134, 0.25759858136344616, 0.23788471347744344, 0.21524024555088894, 0.2443405694217039, 0.2360323898572031, 0.1935479404965479, 0.20246428399169536, 0.18789212281356427, 0.18200394436531087, 0.19188556784436528, 0.18329458722911485, 0.188519904816438, 0.19226432260831616, 0.16889127682387317, 0.2136028409987457, 0.22387377601951008, 0.24660803522891606, 0.20800983927687255, 0.22958034586124954, 0.22465033463249962, 0.22102418071287966, 0.22405320817931684, 0.21161645937138562, 0.18457592954387847, 0.18337090592787286, 0.19135622349459513, 0.2070462971622825, 0.18672598058565393, 0.18253965663384464, 0.16994350010352988, 0.18447771712346972, 0.1734705317045031, 0.18079809622743392, 0.18134444816130546, 0.5272082786398211, 0.43431771879912584, 0.1960810708619708, 0.19157127774642502, 0.1392785753712158, 0.1604673598449865, 0.43422597669424623, 0.39886168289836244, 0.20382591661222316, 0.4548445852219778, 0.3118734754545296, 0.3298607990373782, 0.16872270118337473, 0.16782558341062137, 0.3187230730643221, 0.3441586913431979, 0.1657349892102542, 0.17507710596069714, 0.1826050021054576, 0.19354821934896183, 0.22131340830168134, 0.17307825962457624, 0.17342588876843035, 0.17710150373291966, 0.177233698978987, 0.08451404318621758, 0.08774944707857102, 0.07930041888204031, 0.08654894979669625, 0.07559837365438093, 0.0727204870806174, 0.08961471536432508, 0.09672883896596429, 0.08011240894428284]}, "mutation_prompt": null}
{"id": "ba03d71a-8884-44df-bde2-5c7784a67351", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMCM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = self.chaotic_mappingInitialization(self.swarm_size, self.dim)\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def chaotic_mappingInitialization(self, swarm_size, dim):\n        particles = np.zeros((swarm_size, dim))\n        for i in range(swarm_size):\n            for j in range(dim):\n                particles[i, j] = self.lower_bound + (self.upper_bound - self.lower_bound) * (np.sin(i) + np.cos(j)) / (np.abs(np.sin(i)) + np.abs(np.cos(j)))\n        return particles\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMCM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMCM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Chaotic Mapping\" (HSO-ACL-OBL-DIW-SAM-CM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, a self-adaptive mutation strategy for increased diversity, and a chaotic mapping for improved initialization.", "configspace": "", "generation": 25, "fitness": 0.17191759983719887, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMCM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "9e101078-fd0d-4379-8055-484ef07848e1", "metadata": {"aucs": [0.32142015531237167, 0.3352843911039005, 0.3386720562828208, 0.30812494575005245, 0.3462626258743038, 0.3182972709455656, 0.33051440518569497, 0.34967777224824104, 0.3022520212285372, 0.032725844476896415, 0.010287871127518833, 0.010701953973740963, 0.002620843757208835, 0.019439292613737003, 9.999999999998899e-05, 0.016241143597427787, 0.014470337780062126, 9.999999999998899e-05, 0.0860886644285851, 0.07232931505572182, 0.0718278931676154, 0.09809896204443902, 0.09538854039979616, 0.1224499956550873, 0.07974184600540124, 0.08970487959723539, 0.07080914331239907, 0.08428985498998265, 0.06912151565259317, 0.07874598418020651, 0.05791550465057538, 0.0772644493277076, 0.0875035527876642, 0.0808544666636708, 0.06859040101617409, 0.0818850689053352, 0.8562910867779141, 0.8323573472610528, 0.8407117107474937, 0.7586221083739048, 0.8282389318534041, 0.782187969893796, 0.8340761635745166, 0.8292108013524229, 0.8438625158468919, 0.16439519630546473, 0.18582791533687304, 0.17520587633065898, 0.1932408026735033, 0.19474172298725967, 0.20865441677838514, 0.21201894203262128, 0.17821591417901872, 0.20810885552438363, 0.282077874601411, 0.2833150345430141, 0.29361110257864675, 0.24189623872913302, 0.2511804844243676, 0.2397672483411447, 0.24463496153550057, 0.24159862075771565, 0.2938116980902342, 0.13053195605672385, 0.1178729821185922, 0.124618649932277, 0.08811198507253792, 0.10998661802381071, 0.09091339300901724, 0.12018347068737856, 0.11728644311703451, 0.11260311910840426, 0.11923772569432645, 0.14000554122477515, 0.11948148402714376, 0.1371790607546518, 0.13903929004029925, 0.14087524796783946, 0.13844029761284204, 0.1483696381695241, 0.13720864993272497, 9.999999999998899e-05, 0.0073294513426884755, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08732843553836522, 0.1376301078185188, 0.03964442261162171, 0.03263168660077154, 0.015725576997941415, 0.007585317403944858, 0.05734075371151559, 0.02850400845578549, 0.018178873309447008, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0517465571826895, 0.04944691496722431, 0.06633374892896393, 0.05043228252506893, 0.0365796140933482, 0.0538536434893222, 0.05281033455229556, 0.04486678029524771, 0.061005093987818504, 0.3236905873648822, 0.31783527229699804, 0.3303312651283522, 0.31091704340999715, 0.302130629719604, 0.3193366586828207, 0.3292698391833828, 0.3298363616175407, 0.34412586808148893, 0.08822318114931349, 0.08529884142097854, 0.09172116484090387, 0.09301905637212604, 0.09825645492669433, 0.09527836618841634, 0.09448716896402021, 0.08255572023437485, 0.09731301279985105, 0.16260177383873597, 0.17080320930352244, 0.16562167502002956, 0.1643519876559878, 0.14084969273983572, 0.14216146190837753, 0.13854243205935723, 0.1355949036998254, 0.1336122557066346, 0.21674223577149154, 0.20923362533269163, 0.24836373918397758, 0.24826604476034597, 0.2506328399928075, 0.23521973636539129, 0.1786690699140756, 0.17814527013659698, 0.18288523677250934, 0.14109689732716546, 0.15594621651101404, 0.14358394519760842, 0.19996258636185793, 0.1951060288797486, 0.18022473448221277, 0.14411909789752209, 0.1443855357434468, 0.1489794817844422, 0.25788582823422734, 0.23767063335112415, 0.23229161689981714, 0.2524912824435659, 0.20806795828262925, 0.23316963662853163, 0.23721526860213182, 0.23458560625361868, 0.22326968910987544, 0.1833421392366461, 0.17302216271475357, 0.1688146747921384, 0.1778836802768441, 0.17841649210170785, 0.17057254420469892, 0.19785632545383647, 0.18934930618016432, 0.18670981581964408, 0.1653709852487687, 0.1760931506821546, 0.16261671116574783, 0.14588940642827852, 0.14448762292384876, 0.1554079857974744, 0.14186619443133675, 0.1427030401923064, 0.142569658481574, 0.10434402606761106, 0.1045593147410877, 0.10201422026179097, 0.10152913032958588, 0.10105893973240543, 0.40701860870023887, 0.11904247996188855, 0.5088192657758543, 0.40322993359717096, 0.18355773225363647, 0.1918294095481511, 0.17042830906422002, 0.1811461492327927, 0.18397367860142044, 0.18976167373780184, 0.17537786244414022, 0.1803439231598455, 0.18426373401788199, 0.08764906380934445, 0.09015386331668274, 0.08838046326725946, 0.08147407708170995, 0.0897288405628438, 0.09537121521626557, 0.07514675297398699, 0.08311789438085793, 0.08164971344058725]}, "mutation_prompt": null}
{"id": "c8456bab-e642-4794-bfc9-5971c882e3e6", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMGP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.gaussian_perturbation_stddev = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        return position + np.random.normal(0, self.gaussian_perturbation_stddev, size=self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Gaussian perturbation for improved local search\n                if np.random.rand() < 0.1:\n                    perturbed_position = self.gaussian_perturbation(self.particles[i])\n                    perturbed_position = np.clip(perturbed_position, self.lower_bound, self.upper_bound)\n                    perturbed_fitness = func(perturbed_position)\n                    evaluations += 1\n                    if perturbed_fitness < fitness:\n                        self.particles[i] = perturbed_position\n                        self.best_fitness[i] = perturbed_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMGP(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMGP", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Simulated Annealing with Gaussian Perturbations\" (HSO-ACL-OBL-DIW-SAM-GP), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, a self-adaptive mutation strategy for increased diversity, and Gaussian perturbations for improved local search.", "configspace": "", "generation": 26, "fitness": 0.19031185314081053, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMGP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "9e101078-fd0d-4379-8055-484ef07848e1", "metadata": {"aucs": [0.3546931635932148, 0.3288719691148818, 0.3215806592912178, 0.3500038154568579, 0.3430799466485349, 0.33775053013944867, 0.3190574470612263, 0.33447803306024404, 0.3418668456638434, 0.0013225916127481696, 0.0031124502995689696, 0.023577285846910545, 0.0003437525939565811, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11832159394720543, 0.09897899599669713, 0.07667096054748601, 0.08958609293628417, 0.09944345129572829, 0.09929097928636943, 0.0871178129122705, 0.09944827351138597, 0.0970123906704139, 0.08427797575703666, 0.08162151591060096, 0.09204163298546186, 0.09431646311333808, 0.07450781931637307, 0.0920286800128457, 0.102619728270123, 0.0849273185386864, 0.07577744368896766, 0.9178758066910426, 0.9426956587318929, 0.8982970400384473, 0.8695885831774304, 0.8770529975655907, 0.8510232276235868, 0.9395513834174722, 0.9389848638630046, 0.9092053479188145, 0.22283375782965864, 0.22573810922391113, 0.20378232913738292, 0.21694117375240307, 0.21314073371622055, 0.23176494711170392, 0.23746667919020548, 0.21335028489927998, 0.20525161521882496, 0.2807134195972546, 0.30258826878975364, 0.2388230725698277, 0.24457107331549433, 0.2780571040116887, 0.2252933887453863, 0.2892197402957344, 0.24792189455130476, 0.25261752921761393, 0.1161795720570743, 0.08596183353209053, 0.11418638236130796, 0.0922530938559526, 0.16002051794519723, 0.12167919725608423, 0.13523892388251335, 0.10799399577292934, 0.1246270504261705, 0.13288739816184592, 0.11412103917505445, 0.10777777295352475, 0.14638820456168466, 0.11990544494982647, 0.1253898055989332, 0.13693603325278436, 0.0811320009873594, 0.12384201060235123, 9.999999999998899e-05, 9.999999999998899e-05, 0.016045774464716667, 0.024219238326000037, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08433423193384193, 0.03775604022103163, 0.12608376816150613, 0.0992567261269598, 0.047770015504846164, 0.01146929282645015, 0.06548244104287437, 0.09937166674621145, 0.07942380922091685, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06373465998242422, 0.06089465957625939, 0.05750643248928822, 0.07109893883937335, 0.07945677505686222, 0.04267352271257363, 0.045059293346883744, 0.06001086903410846, 0.06822834623882923, 0.3280017102906738, 0.32600206545826305, 0.32595555141871, 0.32170304326525756, 0.33512574265996586, 0.3118111104981288, 0.32671652056517586, 0.3511633228561438, 0.34137106780269233, 0.09000155532567644, 0.0898646353589454, 0.09004414007299943, 0.09952116754378726, 0.09951513176177307, 0.09824553725527896, 0.09721162580922171, 0.10351379529801674, 0.08486349983856001, 0.14355598948286585, 0.1633423056460157, 0.15259994816030653, 0.15625482637243526, 0.1928934844735508, 0.2011878352756833, 0.21667506805201742, 0.18850791853111282, 0.16971204397604545, 0.25094942811905774, 0.2554311909532547, 0.24623604748606454, 0.24960736634008618, 0.25901730335649376, 0.2665886017156066, 0.25087927689916056, 0.26336186941055295, 0.24139809774361942, 0.17417041322639504, 0.18916622095882885, 0.2009625925904417, 0.19906362488062113, 0.19119581696148802, 0.18243177375041963, 0.18385653328663898, 0.198033418431376, 0.16985694336796298, 0.2250611626671618, 0.21478500705015546, 0.2413661900064048, 0.22375004832808187, 0.2372178112664557, 0.23145936434590797, 0.2475158665290378, 0.22007252192607074, 0.24265533537078354, 0.17538684663633208, 0.186974069647446, 0.17166712161129527, 0.19722385839203083, 0.1827511378139295, 0.1867724919988628, 0.18763289971971087, 0.1782108713006908, 0.17015633951846432, 0.17757332112599744, 0.12377339622565964, 0.45139780006397046, 0.16985523968848681, 0.1935316243529318, 0.19042927612616445, 0.13827418658251733, 0.2368515222644907, 0.4359437541136507, 0.4131695005190661, 0.20426251461862677, 0.40768915738250266, 0.3361232481625618, 0.43081164482085355, 0.1688363403215617, 0.16746859737970043, 0.32588479668436654, 0.41159941505911224, 0.17876092527798204, 0.1776620950461122, 0.17975926606161452, 0.18819359354128917, 0.20318701050383847, 0.18253693155715378, 0.23004838599005129, 0.18572949273193118, 0.17596963836641266, 0.07913176742297123, 0.08087198606376678, 0.07087592809495147, 0.10135409040944487, 0.08597755208587587, 0.08581761231622387, 0.08780550497950512, 0.08241433868519621, 0.07898828866683527]}, "mutation_prompt": null}
{"id": "f9af3cef-304d-4b20-a3ca-5dc378423c21", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMCM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.cauchy_mutation_rate = 0.05\n        self.cauchy_mutation_scale = 1.0\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.cauchy_mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim) * self.cauchy_mutation_scale\n        return position + mutation_vector * mutation_mask\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Cauchy mutation for enhanced exploration\n                if np.random.rand() < self.cauchy_mutation_rate:\n                    cauchy_mutated_position = self.cauchy_mutation(self.particles[i])\n                    cauchy_mutated_fitness = func(cauchy_mutated_position)\n                    evaluations += 1\n                    if cauchy_mutated_fitness < fitness:\n                        self.particles[i] = cauchy_mutated_position\n                        self.best_fitness[i] = cauchy_mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMCM(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMCM", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Cauchy Mutation\" (HSO-ACL-OBL-DIW-SAM-CM), that combines the exploration capabilities of particle swarm optimization with the exploitation capabilities of a modified simulated annealing algorithm, an adaptive cooling schedule, Levy flight for enhanced global search, opposition-based learning for improved convergence, a dynamic inertia weight for better balance between exploration and exploitation, self-adaptive mutation for increased diversity, and Cauchy mutation for enhanced exploration.", "configspace": "", "generation": 27, "fitness": 0.19273172708734926, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMCM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "9e101078-fd0d-4379-8055-484ef07848e1", "metadata": {"aucs": [0.35242566638903317, 0.3450919729617494, 0.34092078481758437, 0.34091466468684795, 0.3547241935701285, 0.33976108855958087, 0.34009272677160407, 0.3239601308847043, 0.3322242050922044, 9.999999999998899e-05, 0.01743549042221426, 0.011707549990205512, 0.0066212150845677, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11200884802442723, 0.09143143947128318, 0.09788232556518595, 0.10271280591169452, 0.0975169458011631, 0.1130887745702317, 0.0809394836182239, 0.12512012474707956, 0.12695113784537138, 0.08681554926360002, 0.06971953253377228, 0.07406908231725517, 0.08127022438307685, 0.09181188095721937, 0.07890862502441376, 0.08148016736889296, 0.05225371458896222, 0.08825780191798316, 0.9105082617060927, 0.9430143192049926, 0.9092491729942246, 0.868832329368341, 0.8646198565855485, 0.9238523754350283, 0.9396929749664222, 0.9371518816281892, 0.9137972136982968, 0.22301455747083243, 0.20986437812302194, 0.23031962062882672, 0.21159168076356705, 0.21428522075144718, 0.21369378140619677, 0.22253546909497235, 0.2452577202055639, 0.1965606000445398, 0.2615625449754574, 0.25462952350104906, 0.2669647404540647, 0.264737931347645, 0.25464293778044866, 0.23619127582073374, 0.2540547371795613, 0.265595947704389, 0.3042433905701052, 0.12808137106850315, 0.13330869128772815, 0.11640686148852997, 0.12587430666698152, 0.14003697149582328, 0.11596911859812375, 0.1273279481190862, 0.11831905898514428, 0.13556812188711187, 0.12612176693819488, 0.12027500242520106, 0.14845275701142724, 0.12314997618034307, 0.1239460974814508, 0.12865783184438373, 0.1383911883349156, 0.14496939324251545, 0.12589751792098614, 0.008640113706744001, 0.0005622533324882717, 9.999999999998899e-05, 0.005982554890103686, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11877197835773456, 0.0636678007394188, 0.09947919810581751, 0.05522397193595985, 0.03269733266259156, 0.022207757364102743, 0.09659278603443944, 0.05516899555581589, 0.08737889531891363, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07165197904986564, 0.06084244891828494, 0.06822892919922052, 0.05504114720452147, 0.06140324453175139, 0.04903338179162764, 0.054184494355980495, 0.06349192535007564, 0.059979402705387486, 0.34616749713194817, 0.3332169596036554, 0.35503149018497393, 0.3270610539888128, 0.3720688267728448, 0.3362628691489946, 0.32765192995288706, 0.3259055436766438, 0.3484181725034161, 0.0849563385842983, 0.10394897352131593, 0.10685512101639727, 0.09238178620980342, 0.1028472614481365, 0.09485500964443017, 0.10021218976938595, 0.10222456578430594, 0.08896171008066978, 0.14382553044213242, 0.17566513555847563, 0.12506460109711992, 0.16764128496809605, 0.1734230584474662, 0.2044544077258863, 0.16958745750854454, 0.1652597995553411, 0.1509022026815492, 0.26331325685871565, 0.2414287445443607, 0.2429653333654035, 0.24270725855036046, 0.2607206985431796, 0.24863583186284466, 0.2071751426392483, 0.2640624298169266, 0.2612161833052892, 0.20011274256044875, 0.18367541809699173, 0.18680791458752988, 0.20060236093631667, 0.1952038388660572, 0.1911627347613406, 0.17527650631464875, 0.18445806815311216, 0.1655065149051126, 0.228673600445486, 0.22071067509578068, 0.21929854270438742, 0.22951096886169087, 0.2303134120227548, 0.2367789709718381, 0.22059127634466114, 0.21345760968110594, 0.22033045168221765, 0.18451996415823746, 0.1870421941957764, 0.18165397206285794, 0.18917330620505668, 0.18835383495728397, 0.17197742459428467, 0.19280006618556667, 0.17120872429477763, 0.17327217270564066, 0.12679124197198222, 0.18268233912824883, 0.18118440655559176, 0.49635439368254675, 0.19515954575279304, 0.16567497572523537, 0.1393871181205203, 0.5916514307642353, 0.450726635974812, 0.4483905353064903, 0.20599767325455287, 0.4949192741250539, 0.4356760905341991, 0.16536553506158125, 0.16490923365641297, 0.16630548276693202, 0.36206491183526246, 0.4791212787761253, 0.17760171612920206, 0.18415203702560956, 0.1739256435419022, 0.17840436974226237, 0.19375286912685774, 0.18886376933734705, 0.185155938411251, 0.1727390795469146, 0.16997746259286706, 0.0854017712463101, 0.09039242757627985, 0.08141889052622409, 0.07702237507139598, 0.07466067306481194, 0.08384904947633698, 0.08085800011349453, 0.07802595513951416, 0.0902728287243455]}, "mutation_prompt": null}
{"id": "cd45f918-bfe1-4298-8498-cff5835f5e3b", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight and Self-Adaptive Mutation\" (HSO-ACL-OBL-DIW-SAM) that incorporates a new \"Velocity Clustering\" strategy to enhance the convergence speed and diversity of the swarm.", "configspace": "", "generation": 28, "fitness": 0.19552492464578564, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "9e101078-fd0d-4379-8055-484ef07848e1", "metadata": {"aucs": [0.33245762640896503, 0.3331776313798904, 0.3434592525523199, 0.3242984799437706, 0.36791707867748524, 0.38151320793789534, 0.3540898512442415, 0.39108043332523934, 0.32639762519030513, 9.999999999998899e-05, 0.010553265380115806, 9.999999999998899e-05, 9.999999999998899e-05, 0.004632277591584577, 0.0009380493196488038, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08949496910421895, 0.12199630356127855, 0.11423445456563386, 0.10872462931386562, 0.09867286020573829, 0.08996358343313116, 0.10332879468408684, 0.09253338425810054, 0.10060258296854918, 0.0880450670637829, 0.07874565190436733, 0.07739518335843054, 0.09132698340129541, 0.07727756528587892, 0.07092844818430877, 0.0914470999138135, 0.08948700622319139, 0.08121889653980341, 0.9170863316127524, 0.9485973470278739, 0.9077277429232746, 0.8735602490206024, 0.9073768177592764, 0.8776725221608022, 0.9410319765016097, 0.9247162078864329, 0.9197361378878481, 0.22840227255681067, 0.2094787309533367, 0.2271398837517724, 0.20177857820856682, 0.20092196162395248, 0.20963623014047728, 0.2152046704774333, 0.22745513885649504, 0.20330740515868517, 0.26413812786897584, 0.2636473260805491, 0.26377100149980726, 0.28124438882649716, 0.2267924535721857, 0.25606413903173886, 0.26409324269574286, 0.2205451231182718, 0.2771497139750113, 0.1232453445914018, 0.09078482214234551, 0.10960179156982908, 0.08159040756462432, 0.1472761550918149, 0.12568320464135452, 0.15567891200792605, 0.12775339346031211, 0.128571521045862, 0.15299759156447568, 0.12659888454298485, 0.11545275500837959, 0.12394446769292211, 0.12130501123985193, 0.13150829926541008, 0.13103272632666207, 0.07367272213163956, 0.10713827468768, 0.014754522893416278, 9.999999999998899e-05, 9.999999999998899e-05, 0.031868859867205, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0151358936898639, 0.09672292317227471, 0.04254371034736637, 0.055423095724659976, 0.11737004330485912, 0.1093267065527529, 0.03597363776719098, 0.11487539254814838, 0.07487437284664333, 0.06027115068361677, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06054598076025397, 0.06105087246701535, 0.055963293976221795, 0.07913283699884255, 0.05824996979400787, 0.07573981703453214, 0.06409702063547995, 0.061449307613933746, 0.05398364617939111, 0.33300545549143135, 0.34657274581036923, 0.35239091649155363, 0.3147351772683442, 0.33243316338025763, 0.3229889308668066, 0.34479704879706696, 0.3676171687081562, 0.3561559122518302, 0.11513863479402953, 0.09996523837158988, 0.08724988698398883, 0.08743298958788659, 0.07723409901157063, 0.11233918571969881, 0.1005262546612179, 0.1114357324809041, 0.08059693491200703, 0.17574587326268976, 0.1698337498678928, 0.12769739323483864, 0.19859685750004374, 0.20472890002284538, 0.17449427462292766, 0.17054480627280322, 0.15575580442901404, 0.17582070299854202, 0.23989927799357302, 0.2584081055311189, 0.2584033953729711, 0.24970712072010226, 0.24701650633456862, 0.2584158638011982, 0.25103754548676227, 0.24558335047782875, 0.25237757839016917, 0.188741983389073, 0.19222993311285552, 0.19427161958430827, 0.17937439968088342, 0.19676078919427675, 0.18699732527971558, 0.17192472421909477, 0.2049443032152105, 0.1515778123412601, 0.2314101623369319, 0.21445714824177264, 0.2200217967107756, 0.22841150204929805, 0.21075155635352816, 0.24287854381441576, 0.19782636935716602, 0.22113110469806674, 0.23827412117128421, 0.1748409005773437, 0.19444969407365442, 0.17085104729286904, 0.19625619665785554, 0.1853177457509554, 0.17944325660419636, 0.201107386688262, 0.17995370108962216, 0.17826475430483646, 0.4948491441090639, 0.18238373476943903, 0.45620825500815176, 0.511923328556787, 0.19072978608347313, 0.19379243588216644, 0.13956984409018425, 0.4935071576417901, 0.46440015228696563, 0.3733968791139811, 0.20242657283299448, 0.40890727716758235, 0.41785259038343947, 0.37063908849809546, 0.16685822042902054, 0.16794197708016312, 0.27529537520216496, 0.42874868131518573, 0.18209558058953068, 0.17159095538508895, 0.1802828545614117, 0.18255814990965247, 0.18952861213756655, 0.16955680659392725, 0.18097835653969763, 0.18547926933373815, 0.18682939297576617, 0.08720865796955146, 0.080591854694261, 0.07410542146651156, 0.09780025916895296, 0.08557083496652718, 0.08676692007052189, 0.08098517926485982, 0.0794413335957308, 0.09392702058675972]}, "mutation_prompt": null}
{"id": "ebcfdd98-be63-4d18-8304-750bbd4927cc", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.centroid_velocity_clustering_rate = 0.2\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def centroid_velocity_clustering(self, velocities, positions):\n        centroid = np.mean(positions, axis=0)\n        distance_to_centroid = np.linalg.norm(velocities - centroid, axis=1)\n        closest_particles = np.argsort(distance_to_centroid)[:int(self.swarm_size * 0.2)]\n        closest_velocities = velocities[closest_particles]\n        return np.mean(closest_velocities, axis=0)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                centroid_velocity = self.centroid_velocity_clustering(self.velocities, self.particles)\n                if np.random.rand() < self.centroid_velocity_clustering_rate:\n                    self.velocities[i] = centroid_velocity\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2Refined(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2Refined", "description": "A novel metaheuristic algorithm, \"Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering\" (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Centroid-Based Velocity Clustering\" strategy to enhance the convergence speed and diversity of the swarm.", "configspace": "", "generation": 29, "fitness": 0.185370130004503, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "cd45f918-bfe1-4298-8498-cff5835f5e3b", "metadata": {"aucs": [0.3367896898743785, 0.32169685485861277, 0.3262966078106424, 0.32785920572632454, 0.3201831723022247, 0.31146845851608307, 0.31559327059557785, 0.3266872687945058, 0.32714547694294216, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0877536472293512, 0.08080695746798994, 0.08669338033716412, 0.1047619348924016, 0.08988283169541578, 0.08486886545315153, 0.1019243005595376, 0.09996854963910862, 0.1002003449444131, 0.08547528076422528, 0.07568796913073583, 0.08528173024226071, 0.08113944135856999, 0.08357309086688236, 0.08355865340454238, 0.0766546716692974, 0.0786358366025861, 0.0957308158500606, 0.9143957976163324, 0.9531722422520053, 0.9265740575383377, 0.8398410051029898, 0.8511129721695029, 0.8758466058186156, 0.9017649548945785, 0.9406535843881635, 0.929248062996206, 0.2125073970592315, 0.1954058120648997, 0.20740989520325415, 0.2011659805720757, 0.20281523518841726, 0.21038894852680312, 0.25255821703473647, 0.22077033776610155, 0.19715859398774427, 0.23722959960232415, 0.2647082041025458, 0.2635586230472453, 0.24013368263912338, 0.27021452734398355, 0.20750604274992035, 0.27016588532852615, 0.24638981591829368, 0.26622330179883147, 0.1256887720054385, 0.06000533108565065, 0.09099917826973014, 0.04411785138165503, 0.10816483825874224, 0.11995722354788085, 0.1392307694743269, 0.09098982579781445, 0.1361857183639288, 0.1230004162289502, 0.14783340497283515, 0.13018932183797238, 0.1422814229269752, 0.11998944153640045, 0.12528051528218875, 0.12518951807091727, 0.11846332618116762, 0.16110380074785824, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0026971912921198715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005209736362258965, 0.06766888658403025, 0.061136087048145105, 0.09260412388579786, 0.08446794714419414, 0.06027797818115954, 0.019757689433411496, 0.1142471151374439, 0.05580770446272365, 0.06341731220072233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06440629669351672, 0.06771782569264484, 0.09545309611095942, 0.058634514311600494, 0.06881266793734253, 0.06548154421463914, 0.05503116545470421, 0.06817528429168251, 0.05157621805348811, 0.33776706873086937, 0.3232673959591672, 0.3388121086845848, 0.32032659183417045, 0.31097802011697573, 0.3258315442264169, 0.31690458131531607, 0.33378055881604873, 0.3255286764370475, 0.08757837154183401, 0.09217323652535636, 0.06438224637740986, 0.07591201541100823, 0.10859147242904765, 0.09781594605336286, 0.07335149238056715, 0.09971451788167396, 0.09983821460726083, 0.14430616670294438, 0.17972291360857962, 0.13491480607597928, 0.14880154421442804, 0.17266988069252653, 0.18432259521166594, 0.18872681144071635, 0.13471455944561272, 0.15499484880242564, 0.24860455529274417, 0.2594661939271691, 0.24642586334551086, 0.24400824854372294, 0.27965721350006134, 0.23493874072974275, 0.2524317922396435, 0.25232268897802, 0.2421511801998959, 0.18353172893901415, 0.17526287660883022, 0.20405846698014718, 0.18757035086761442, 0.18452980488461335, 0.1874858916640787, 0.1885504161863394, 0.19990557731815461, 0.1771758561543686, 0.21528593779972027, 0.21524218915754068, 0.21674560586450953, 0.2159029319160355, 0.23568670593387964, 0.23719092110993611, 0.222161180926008, 0.22355366210670724, 0.21790915135134759, 0.1991854784702095, 0.2056754591530443, 0.17267457691713572, 0.18359288589944078, 0.17900293780669163, 0.1938856002717131, 0.17774152716432856, 0.1768520859174565, 0.16787397121005831, 0.1806514575714887, 0.1808731981599614, 0.1795419133068652, 0.4166022122370938, 0.19291064524176083, 0.19436820089236018, 0.137812965469861, 0.4969658433229577, 0.16174391770825491, 0.35611002320667706, 0.16765019081090882, 0.4398821915410608, 0.19280765835601021, 0.332359629953196, 0.1649558797581343, 0.16415818802085835, 0.3138697101093638, 0.3712783632195693, 0.1989138545466842, 0.1750301119315214, 0.1905292733485232, 0.1886780972758927, 0.18639634401189997, 0.18241274741899494, 0.19132717223729567, 0.17511793602769798, 0.17911483593738975, 0.09784941440602868, 0.09446906679711442, 0.09194261025958617, 0.10066037557157814, 0.07759621883078704, 0.08330337752861672, 0.08907636329695923, 0.08998853838144116, 0.09404236271703337]}, "mutation_prompt": null}
{"id": "8cee53ee-f4a3-42fa-931a-b74322a7bd39", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PF(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PF", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm.", "configspace": "", "generation": 30, "fitness": 0.20505512053677463, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "cd45f918-bfe1-4298-8498-cff5835f5e3b", "metadata": {"aucs": [0.4568515066791925, 0.49052183301953967, 0.49358636326789485, 0.4285671283986293, 0.4481202839036236, 0.45976705761742565, 0.4625090311250506, 0.43562195479136645, 0.4652804392367146, 9.999999999998899e-05, 0.023804661015440653, 0.0008855658909869835, 9.999999999998899e-05, 0.10743250348160349, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10621831848543262, 0.10817635477090282, 0.12280900575643405, 0.11280020622950726, 0.08233787301074458, 0.08558812471953348, 0.09304024833684632, 0.13781639961506986, 0.10401482994440958, 0.08681319511359176, 0.08845212876593012, 0.1132363508276456, 0.08987805968060292, 0.10150499196517726, 0.08109189428711483, 0.10056997542999202, 0.08971756883172888, 0.051853471293234366, 0.8852112828383112, 0.9451142330630633, 0.913101395848823, 0.8812006603988715, 0.8941972270814091, 0.8797246103442246, 0.9379859863979558, 0.915166056275755, 0.9214545707390434, 0.26452640083482415, 0.25437408950690776, 0.26423464309884925, 0.2259839546095529, 0.22084300679049007, 0.26821007853588597, 0.2331140613509678, 0.2390244546996645, 0.24600891533967773, 0.23625597494300832, 0.3346168773033854, 0.24853567527180964, 0.2558710100500623, 0.3348521519404757, 0.24514112420950684, 0.2198070403823389, 0.22991916594995698, 0.3257712904270067, 0.16880064956747032, 0.12964617651279042, 0.13700722629532847, 0.10386081984413797, 0.12663961694006898, 0.123161401369287, 0.15767814879198594, 0.15624452821050816, 0.14547789642684916, 0.1522247501509033, 0.14645653320170482, 0.12326459822675229, 0.14648330204057036, 0.14414740988120034, 0.12661416154924898, 0.12923753493071066, 0.15408626417618, 0.14816425652117182, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022266110516270032, 0.007211942580810371, 0.00012745083795284717, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10605566185140036, 0.0684365255815137, 0.12463199784885692, 0.06291930609038432, 0.07670014555639515, 0.030455989570876807, 0.11118288686052691, 0.05226807891480534, 0.09620953939654031, 0.004357245863876424, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007962162513172721, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016600955649300753, 0.1424890303488442, 0.12149699483054832, 0.09102959320223103, 0.12432702037980148, 0.07066625713176822, 0.11270297307488386, 0.11924576341474147, 0.09448117684476398, 0.07482413297184498, 0.4213142192814101, 0.46883564920724907, 0.4093687414449191, 0.3978931884192066, 0.4073145536197458, 0.44861957303277866, 0.42138291460762745, 0.43469407485541545, 0.41647925260665575, 0.10289163562087256, 0.08789947122270236, 0.1327496865362605, 0.10516675889302074, 0.0995206883258839, 0.10598483555515159, 0.09385759436319718, 0.12426317858429325, 0.07835056766158466, 0.15302665004773786, 0.2230910010021543, 0.18478411719045518, 0.1669639437508016, 0.1870313194481309, 0.15297041794419963, 0.1811232031140767, 0.183458729907379, 0.19062155532451597, 0.29042658914267006, 0.30777794669582625, 0.29630416199910115, 0.3232984803656923, 0.27897871645384154, 0.2605847467897593, 0.2622312905555375, 0.2739852136895141, 0.2800626697335852, 0.22079887894723926, 0.23111211869328752, 0.2635126444827338, 0.20920272498686898, 0.21012174905800007, 0.22198841821922366, 0.20276228172359223, 0.20767748198819547, 0.19545166549924253, 0.2430082555895442, 0.23341775395029696, 0.2236270438093988, 0.22698754182459413, 0.2383017769740282, 0.22183375628669189, 0.25284806223987033, 0.2365084788032854, 0.2332772762648887, 0.1702424015012326, 0.1765181981714664, 0.1895236706540211, 0.26796446893588877, 0.1796824882917143, 0.18797587034401275, 0.1981639374913321, 0.18058463450722917, 0.17983793056846065, 0.12861221287041358, 0.18614405378570942, 0.18525648179608856, 0.17096742702440892, 0.1974293862544737, 0.16679545153058462, 0.14178701925327464, 0.16776081368196427, 0.1643667685725504, 0.4640037273392088, 0.1682220755262135, 0.4442318789896653, 0.4188973986868719, 0.16603464568934323, 0.16473870008854208, 0.16755749311699275, 0.28202411752459755, 0.16223930624218552, 0.17526030260606873, 0.18065394897515596, 0.1852198954651686, 0.1775805132237378, 0.17616439997622024, 0.19155374422044213, 0.19015389397771654, 0.19570977313095295, 0.1894854006466843, 0.08686021590010662, 0.12295686690450858, 0.09867284823513234, 0.09528684078062033, 0.07954797143862291, 0.08311557051819696, 0.10169696133284867, 0.08336895321773441, 0.08149351051322229]}, "mutation_prompt": null}
{"id": "2c1dd782-95cd-454a-88a3-6e1b48ca645c", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.swarm_restructuring_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def swarm_restructuring(self, particles):\n        restructuring_mask = np.random.rand(self.swarm_size) < self.swarm_restructuring_rate\n        restructuring_particles = particles[restructuring_mask]\n        if len(restructuring_particles) > 0:\n            restructuring_centroid = np.mean(restructuring_particles, axis=0)\n            restructuring_directions = np.random.uniform(-1, 1, size=(len(restructuring_particles), self.dim))\n            restructuring_distances = np.linalg.norm(restructuring_directions, axis=1)\n            restructuring_distances = restructuring_distances[:, np.newaxis]\n            restructuring_particles = restructuring_centroid + restructuring_directions / restructuring_distances * np.random.uniform(0, 1, size=(len(restructuring_particles), 1))\n            particles[restructuring_mask] = restructuring_particles\n        return particles\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Swarm restructuring for improved exploration\n                if np.random.rand() < self.swarm_restructuring_rate:\n                    self.particles = self.swarm_restructuring(self.particles)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, and a novel \"Swarm Restructuring\" mechanism to improve exploration.", "configspace": "", "generation": 31, "fitness": 0.20048402688004863, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "8cee53ee-f4a3-42fa-931a-b74322a7bd39", "metadata": {"aucs": [0.45173584029566016, 0.4388177388077238, 0.45006296481529107, 0.4475944234938346, 0.4437806661704089, 0.44749378804339357, 0.44707851919518415, 0.46101632441470397, 0.43784982271494344, 0.0009478593490366283, 0.0005497453740074265, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012337452189272735, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.094260151675996, 0.12353913349313439, 0.09113010893505069, 0.09962883218795415, 0.11711548505263236, 0.07560931460476805, 0.09728462210470823, 0.14297276352658828, 0.10710791668641373, 0.09586696095234115, 0.07656118618289443, 0.07096109062630074, 0.08726627497551909, 0.045585599573735425, 0.10573706755623058, 0.08854515175617839, 0.08358470251218808, 0.07698999543206175, 0.8910898485349378, 0.744634763417153, 0.8964554381954409, 0.824549495019917, 0.8013256918772264, 0.7739648352492169, 0.9078250809008434, 0.816521234014631, 0.9207664827822226, 0.27111391401693474, 0.2626609506463563, 0.24239055290306522, 0.25749640773469196, 0.2595280428719333, 0.26164318767381367, 0.25421186972925314, 0.24356257836131456, 0.24096406016728855, 0.22910375879890665, 0.22846171600063048, 0.20725465587437597, 0.2280820705158313, 0.23856617286988824, 0.2554033171841429, 0.3182869481144277, 0.2014311028726279, 0.2133372198148762, 0.12459135921008124, 0.11745506525702931, 0.14399168596201684, 0.15286906406853795, 0.18477326598380572, 0.21568379796494186, 0.14833107409040003, 0.18470539035364886, 0.14492501813840386, 0.16726523110228264, 0.17002383897466955, 0.17718362438483415, 0.1797832669418753, 0.15943648444449188, 0.16632095018617055, 0.16289592131926678, 0.1380987901993358, 0.14502022591940822, 9.999999999998899e-05, 9.999999999998899e-05, 0.03524586960661835, 0.007576867678007471, 9.999999999998899e-05, 0.012907503704758683, 0.0019141309909662674, 0.0003407574579723516, 0.014838977146437338, 0.10225181365123115, 0.05164768789312457, 0.11509024044956206, 0.07254255008979893, 0.054149725517257496, 0.025695496823465835, 0.045758189318863884, 0.062051728602003586, 0.038555148403881856, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1211954858431058, 0.0808146451977444, 0.07397786499848358, 0.0790621657132391, 0.11580553529377047, 0.07637615987296631, 0.11947068156690166, 0.11968513736861841, 0.10345038400310913, 0.40454798606380504, 0.4142363291707849, 0.41359344591819247, 0.3958806791793438, 0.3995795214490656, 0.3849265944633651, 0.3995596460508877, 0.42231591098565413, 0.41736515623753134, 0.07808146553072948, 0.08012741565537274, 0.06946665672822583, 0.07780041585000941, 0.08976020979578392, 0.10399565279113598, 0.09124581940891818, 0.13158281107074477, 0.0694046954531603, 0.15651604779787376, 0.2973703252503841, 0.11836790123490815, 0.14155343505427576, 0.15204524711813405, 0.248599296936714, 0.19537219144443274, 0.23019897710784476, 0.20082232833021973, 0.30681630714173225, 0.28024700965929794, 0.28843270873134574, 0.27134912848056925, 0.3271685963075176, 0.2585025940675183, 0.23814363907805025, 0.3140805936333052, 0.2268751208799662, 0.20668780555430832, 0.19024934526566517, 0.2583713489550403, 0.21131642264798578, 0.21961474454686625, 0.19892445168933814, 0.18046989490476084, 0.21136085377984304, 0.17060266528839096, 0.24383721784942003, 0.2522746964243511, 0.25843843100704067, 0.2627517929877877, 0.2594559894848216, 0.2616922611803665, 0.2753318401073134, 0.251958118661336, 0.24738999199305745, 0.19196547429949196, 0.18236695426462524, 0.18381408930599452, 0.20140169913783246, 0.21056801181080098, 0.17880159867807, 0.17482596194126054, 0.1899077930175317, 0.17204616583080856, 0.1868171845248897, 0.18640331512902963, 0.1856237371736259, 0.5914184866796784, 0.1986918847288951, 0.14764724813211882, 0.14060495043352406, 0.14773403864347168, 0.5958182541486615, 0.5417174458177005, 0.20551440073024196, 0.10646349365665886, 0.2032023539711978, 0.16314879806807225, 0.16383837148961067, 0.1634420840069588, 0.16525896196928969, 0.1636731935293727, 0.18631111733771044, 0.1815897777259563, 0.18079282223416138, 0.18717747899881365, 0.18503364826415358, 0.18126146737713877, 0.18302570860199463, 0.18100695042186754, 0.1836743991536468, 0.09232123211793719, 0.08777854124588469, 0.0719872734821283, 0.0923232889917448, 0.09318709084936128, 0.07044693143449399, 0.07426157673527001, 0.08934297331480445, 0.06955385073667819]}, "mutation_prompt": null}
{"id": "2a195867-4f02-4d70-a399-58542b304a3c", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.dynamic_particle_filtering_rate = 0.05\n        self.velocity_reinitialization_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def velocity_reinitialization(self, velocities):\n        reinitialized_velocities = np.zeros((self.swarm_size, self.dim))\n        for i in range(self.swarm_size):\n            if np.random.rand() < self.velocity_reinitialization_rate:\n                reinitialized_velocities[i] = np.random.uniform(-1, 1, size=self.dim)\n        return reinitialized_velocities\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate + self.dynamic_particle_filtering_rate * (evaluations / self.budget):\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Velocity reinitialization for preventing stagnation\n                self.velocities[i] = self.velocity_reinitialization(self.velocities)[i]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy with an enhanced exploration-exploitation balance using a dynamic particle filtering rate and a novel \"Velocity Reinitialization\" mechanism to prevent stagnation.", "configspace": "", "generation": 32, "fitness": 0.19171463552451684, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.15.", "error": "", "parent_id": "8cee53ee-f4a3-42fa-931a-b74322a7bd39", "metadata": {"aucs": [0.5135591594035388, 0.47029453036227065, 0.5005741107866146, 0.494901905072777, 0.46655080244990854, 0.5197689868089659, 0.461481551904536, 0.4027115125111561, 0.4397152087137495, 9.999999999998899e-05, 0.010251835501555617, 0.0009630938456531846, 9.999999999998899e-05, 0.0034402376294939696, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003215073707393268, 9.999999999998899e-05, 0.09927964240044562, 0.08454245395170434, 0.140050340888766, 0.08664538134601574, 0.09472446510368338, 0.10942021056335305, 0.1487217236497339, 0.10352775437426476, 0.0977550444789731, 0.08936901718714685, 0.10400893896494767, 0.08631959043074988, 0.08959713389016233, 0.08485520257728263, 0.09365899111311815, 0.09296337630496676, 0.0807377705104545, 0.08020604647258045, 0.5326958804099158, 0.7850922974380431, 0.4406367459878414, 0.30036432439259775, 0.3709184753099717, 0.21096752290539966, 0.7266228049973882, 0.6127926823315237, 0.5300777082886191, 0.22819706365974068, 0.24192032160549637, 0.22710462120218422, 0.25824335099495477, 0.2452200307366852, 0.24276918340267883, 0.23553123564801304, 0.23853767862460262, 0.23532951080980724, 0.29269618735206326, 0.2966714679544381, 0.223602144244185, 0.268354679806207, 0.31657771021220604, 0.20780984526719037, 0.19732184421694643, 0.2196274019431308, 0.2974887620220684, 0.15735643590041037, 0.10966317100071465, 0.11396788320291451, 9.999999999998899e-05, 0.13762891300457591, 0.22598020203942393, 0.14278708898031833, 0.10235126314143239, 0.14926788258398227, 0.14023212379345873, 0.1813303891863689, 0.16809506165555466, 0.1543027759274166, 0.15059719753202339, 0.16008569509675474, 0.14519618689214586, 0.1656171859540524, 0.18270355146545558, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007234281034959489, 9.999999999998899e-05, 0.0025621395508708122, 9.999999999998899e-05, 0.008269299098620841, 9.999999999998899e-05, 0.12501436793590492, 0.14524904594760335, 0.08070761867693277, 0.06016438420629033, 0.0682801189128659, 0.020792577302884307, 0.10905159121731955, 0.07663309714174105, 0.06546784040173026, 0.011681715195136722, 9.999999999998899e-05, 9.999999999998899e-05, 0.00032811350291972463, 0.0016136566851521206, 9.999999999998899e-05, 9.999999999998899e-05, 0.001162236829283958, 0.04103350465728217, 0.0817993976251804, 0.12072447614777626, 0.06464478357691428, 0.11964487631429199, 0.0993526695829452, 0.09117214919018146, 0.12201214702505692, 0.08358663297134827, 0.09735806442312966, 0.42839127971738455, 0.4413925471124932, 0.4007940456351533, 0.4043354677499458, 0.3979783727064785, 0.3851928769234362, 0.4199141099701722, 0.4461391270859776, 0.43065315526081294, 0.09217975704386061, 0.10880483203132807, 0.0993502845992803, 0.09278287941150498, 0.07179941711994764, 0.11344424676682707, 0.1092425080165742, 0.06888214633105982, 0.08488624188213123, 0.15669833333003358, 0.19051828286163397, 0.1930899113914747, 0.18645943351677619, 0.2644389331822765, 0.20360258876960047, 0.1435065098646996, 0.17113234240477704, 0.18793457544422898, 0.270467815100881, 0.27197105016268186, 0.326089190358132, 0.2911389442313106, 0.30388517896853573, 0.27743487536854283, 0.2379650808867233, 0.29284817870181856, 0.2196870110691017, 0.20597406879246072, 0.19260629981197464, 0.22996261676228424, 0.21344854443740224, 0.24347768796072122, 0.25160876364329354, 0.19544244521490928, 0.2077479404963083, 0.22058561566892376, 0.23613971043323678, 0.23275911692796336, 0.23926973530375362, 0.24002910825875745, 0.23229228823964687, 0.23452583943010719, 0.25001812001500845, 0.23278345983055837, 0.22591105937213873, 0.16982302229727098, 0.1807595639116486, 0.17520461659299835, 0.1783475224717498, 0.1891780091968548, 0.18491546077829846, 0.18419619321577807, 0.17527606889428493, 0.1894472376265569, 0.18543750314147245, 0.18543416100715404, 0.18632577945445972, 0.4820359922197395, 0.19860437741054515, 0.14941217279574026, 0.14010531622600486, 0.15554986475886112, 0.5342543827583097, 0.4529215964594553, 0.20736356502561615, 0.41901008624674396, 0.43353701492941055, 0.3686864950254184, 0.3638740785749207, 0.16697601539742046, 0.16428439876451106, 0.38379814691529623, 0.1967535810493498, 0.19796951135937957, 0.17148447300337122, 0.17151007733744916, 0.1733013844980651, 0.18077338561615075, 0.18646000139394647, 0.18968184092543394, 0.17594307509187257, 0.07742399090641972, 0.09229739279798832, 0.08694248312145425, 0.09102513506640186, 0.09224428135847662, 0.06675632924373154, 0.09840484904157543, 0.08111759469716928, 0.07750649226929562]}, "mutation_prompt": null}
{"id": "25e490a1-f0c7-487f-bdd4-f1ddab81c185", "solution": "import numpy as np\n\nclass NovelSwarmOptimizerACLOBLDIWSAMV2PF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.probabilistic_velocity_update_rate = 0.5\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                if np.random.rand() < self.probabilistic_velocity_update_rate:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                else:\n                    self.velocities[i] = np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = NovelSwarmOptimizerACLOBLDIWSAMV2PF(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "NovelSwarmOptimizerACLOBLDIWSAMV2PF", "description": "Novel Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering that incorporates a new \"Particle Filtering\" strategy and enhanced exploration-exploitation balance through probabilistic velocity updates.", "configspace": "", "generation": 33, "fitness": 0.19607472491630742, "feedback": "The algorithm NovelSwarmOptimizerACLOBLDIWSAMV2PF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "8cee53ee-f4a3-42fa-931a-b74322a7bd39", "metadata": {"aucs": [0.40366651846895063, 0.42940400660984834, 0.38945342553694684, 0.44341090123892124, 0.37486823078122367, 0.4145658703370182, 0.40340131788499545, 0.4105144509420867, 0.40000425868699985, 0.0011069046423083373, 0.00036599626351130343, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040876457267180366, 9.999999999998899e-05, 0.10671265979526745, 0.10796941692447404, 0.07634703272886234, 0.09618486518204772, 0.09642988712553324, 0.10990150496601947, 0.12177827409990039, 0.09244696690837295, 0.08698247908963508, 0.10272833428671657, 0.07340590620387011, 0.09534810654421566, 0.10210112497271295, 0.10240012662836939, 0.08285370696732275, 0.09477549682607511, 0.08145760017065495, 0.10401521188663554, 0.8764888265618558, 0.9166443214923312, 0.7958529211738368, 0.7848978739235903, 0.65953739821127, 0.7802510527782031, 0.9352684283752684, 0.8976599167311008, 0.8818700888653486, 0.220096616581809, 0.2319359353043574, 0.206999883607749, 0.24818522135535526, 0.2275452384941058, 0.20042197390961614, 0.24390504346981456, 0.21471552928193705, 0.2026459098093425, 0.21728685873535947, 0.23136434978792897, 0.22982812899155647, 0.20579594646809862, 0.2619200565464206, 0.19024121512107128, 0.224410753603969, 0.23879919324043963, 0.24262645379656966, 0.11381646842436277, 0.13627190823065227, 0.1186095311574411, 0.10239670270178414, 0.1325099479265206, 0.144140867262614, 0.13409909263351238, 0.1672758188405996, 0.12403799061004794, 0.13203458625614384, 0.12819470635810903, 0.12374111603053517, 0.13046780769730337, 0.12253985835879044, 0.129375117316333, 0.13347269578788057, 0.12252748984018325, 0.14538551646967868, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004473692321186218, 0.007779312544007877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11271589197258258, 0.08014873095110309, 0.06723877258139765, 0.08277171916704662, 0.0690463552239482, 0.06069740649009636, 0.1161113931865726, 0.1176936025912173, 0.08385360737931713, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00020333822806584134, 9.999999999998899e-05, 9.999999999998899e-05, 0.09303647679961746, 0.059045835561401194, 0.07190368487801513, 0.08895284376367674, 0.12569311178881815, 0.08027483808212532, 0.06457777220008831, 0.04971970313453489, 0.07234872257967817, 0.3735024417367977, 0.39414018475563617, 0.3868061803780224, 0.36827893109570586, 0.3943370091454811, 0.3759890979563072, 0.3706404680283637, 0.390521803109665, 0.4068617320427744, 0.10389810496505048, 0.09779674673340955, 0.08732164176143165, 0.12205893567494464, 0.11474103469428887, 0.11642236222820301, 0.10789425414120724, 0.09671588647994467, 0.08489085364043458, 0.16240635063961217, 0.16566853320611807, 0.1361035603199542, 0.14372854930984735, 0.1542333622850378, 0.1541755025303273, 0.147978045293658, 0.1663774470859889, 0.18625810659175124, 0.26366562938587046, 0.30991132659531284, 0.2788428482883073, 0.2651982886146914, 0.2700871758995801, 0.2611801076070144, 0.2861178583787295, 0.2496547583425518, 0.22547911432353818, 0.19537870676885716, 0.21581382687770112, 0.22008512295520555, 0.2185360511211536, 0.20917651641283597, 0.24658735758368988, 0.19379922697108398, 0.1947934540013111, 0.20096139124212953, 0.20890916037242147, 0.23376715556897143, 0.257921626149341, 0.222721514274264, 0.22314253202636813, 0.21616531538394923, 0.2073849433155135, 0.22568264163077567, 0.2064804544512343, 0.19223630648062706, 0.16580537096294068, 0.16973900389688512, 0.180711182071146, 0.17399952652840966, 0.1640484038568586, 0.16616237493310893, 0.18087347027748435, 0.17149665971476624, 0.1841850962186825, 0.1832647750149763, 0.43122809895227643, 0.4015595050577223, 0.1945597917219818, 0.41081897263930234, 0.1394512746028549, 0.5619758792275846, 0.5531701934269753, 0.3258367559030707, 0.15112378193621845, 0.413025942885621, 0.3141619735724479, 0.1647603561212494, 0.1649563966358948, 0.16293392520449057, 0.16079524492923936, 0.37605931170812346, 0.20237062014839557, 0.22611937257159154, 0.18908220728159963, 0.18174686154979913, 0.16515607469954408, 0.21165091006176062, 0.1904805640608218, 0.18426105492836053, 0.17317298340557885, 0.08437931490722517, 0.0916489898843671, 0.07523564429815965, 0.0971276127667623, 0.08364368615160567, 0.08398413397465232, 0.10146778648375332, 0.09174887788140984, 0.07877687250174292]}, "mutation_prompt": null}
{"id": "12b53625-dd7a-4f49-921a-6d3aa29a24a9", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.evaluations_per_inertia_weight_adjustment = self.budget // 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight adjustment based on evaluations\n            if evaluations % self.evaluations_per_inertia_weight_adjustment == 0:\n                self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering that incorporates a new \"Particle Filtering\" strategy and a modified simulated annealing with adaptive cooling and dynamic inertia weight adjustment based on evaluations.", "configspace": "", "generation": 34, "fitness": 0.19950510855651873, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "8cee53ee-f4a3-42fa-931a-b74322a7bd39", "metadata": {"aucs": [0.4023612161356134, 0.42962356581689265, 0.4975397506669734, 0.4123157422592574, 0.45391379506450324, 0.4496461946162421, 0.4397389096223342, 0.41458292663165497, 0.41804265919344985, 9.999999999998899e-05, 0.030198776334981248, 9.999999999998899e-05, 9.999999999998899e-05, 0.08327860900503892, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12033296160643236, 0.10747070813279147, 0.12248650908029302, 0.10037648033012647, 0.1032050491690698, 0.11667245770028345, 0.11526953808640195, 0.11575011364585475, 0.09776372128172439, 0.07684446974935366, 0.09730993027518076, 0.07806675176481148, 0.09511959495820443, 0.10913805781573171, 0.1071924669926777, 0.08883459404006477, 0.08175660201936918, 0.07513965642158948, 0.8856725895448101, 0.9451638137747685, 0.9206515668335284, 0.8878947668544637, 0.8946692029487239, 0.8907439477759321, 0.9380971036734408, 0.9246449583217747, 0.9222644067884107, 0.24145677555623046, 0.24280747303796368, 0.22347752014445732, 0.22265285121780676, 0.22074269737691732, 0.2237322730797051, 0.23445385069020408, 0.21238625142127654, 0.2197857803599801, 0.2786420913302008, 0.32697485850030894, 0.2155185655820453, 0.22570593246128823, 0.35815927564345107, 0.20303054729590342, 0.29285946019367126, 0.2294544840408551, 0.322830353491101, 0.1426158328611924, 0.13274054226403842, 0.13942665574016955, 0.09453229646371164, 0.12777208573994903, 0.12108810551526805, 0.1475836161055527, 0.12349537395624643, 0.12433342009449388, 0.14718158833091388, 0.14121724670324964, 0.11614887433040944, 0.14786227542660468, 0.13095780639900423, 0.134559528594816, 0.12777717259634136, 0.14997523413298675, 0.15032552221817952, 9.999999999998899e-05, 9.999999999998899e-05, 0.013382418412029806, 0.04908447083283174, 0.011183402348466376, 0.0375255550424608, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018042932082998897, 0.11915478809064517, 0.10591982255990573, 0.14682903824114368, 0.08908417535633473, 0.0708015527136362, 0.03767787992853899, 0.15900185713522152, 0.02818030308979924, 0.10608531325242077, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11153770566916588, 0.10964095372466509, 0.08179915232924162, 0.08993860987248115, 0.07292680215372671, 0.08233726672611297, 0.06341486845942523, 0.06664629956119772, 0.07324160341336428, 0.37937371370898465, 0.41149356664492354, 0.3921648221309234, 0.3823608171022358, 0.39143084621176727, 0.37776655959956607, 0.4230837093923018, 0.39088940939673034, 0.40609310427045364, 0.10206482595620714, 0.08427308103714948, 0.06724108258906913, 0.11437529023343973, 0.08656619247812758, 0.0887959184429572, 0.08054950798468585, 0.10199944926391058, 0.08829904064559502, 0.16062241257680288, 0.2249198630503273, 0.16441381795156995, 0.14087436440885082, 0.17348060735820814, 0.164990778790428, 0.17755441294477547, 0.2032588010050751, 0.14744900185711196, 0.25644894890743786, 0.29041814583771286, 0.2861225845263856, 0.28403617519954627, 0.2935059364009448, 0.299052242706472, 0.2383117035908896, 0.26141222393219254, 0.27687974845485774, 0.23680039609302916, 0.23361960988832342, 0.2429164135184646, 0.2045407889195261, 0.21118845527011199, 0.21637622968281622, 0.1832856885272205, 0.23491540957526902, 0.18630355411308663, 0.1966665229625928, 0.24845650387860385, 0.2360445144736767, 0.23957578367388455, 0.21972355696368462, 0.21649465978341986, 0.2316196725534293, 0.23133589461059945, 0.2323953046570627, 0.17873952532081416, 0.19928110853374748, 0.18300414959897193, 0.19375291115471516, 0.1849106026808024, 0.18871619706316567, 0.23380279027702056, 0.17453593345616736, 0.1796829880534031, 0.12836242144973098, 0.1862405325775931, 0.18448399968650286, 0.17093170892815435, 0.19737344898968, 0.16694435153789655, 0.1418644982764572, 0.1680222686218089, 0.16447218869075164, 0.3607612289224742, 0.168215290599398, 0.5007489238041255, 0.34989098434453825, 0.16598114490844307, 0.16465759156504423, 0.16750205115105743, 0.25952995991639294, 0.16201624546491133, 0.17331482575910673, 0.18316377654685345, 0.1758747088642273, 0.20203146657730908, 0.17828992379404462, 0.1737063332301837, 0.18013156914174755, 0.1931883507397929, 0.177469127300654, 0.08802170473889859, 0.07926202613632172, 0.08482743314779384, 0.0903712757972005, 0.09205028513044566, 0.09612301810566792, 0.09537618496834821, 0.08909775816027832, 0.12831045281161946]}, "mutation_prompt": null}
{"id": "af913b57-d5f1-4bd9-9187-43425af0c951", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.probability_7_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def probability_7_strategy(self, position):\n        if np.random.rand() < self.probability_7_rate:\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        else:\n            return position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Apply probability 7 strategy\n                self.particles[i] = self.probability_7_strategy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 7.", "configspace": "", "generation": 35, "fitness": 0.20715479594919065, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "8cee53ee-f4a3-42fa-931a-b74322a7bd39", "metadata": {"aucs": [0.425993039867553, 0.46804418549469784, 0.42456511294887933, 0.42743208549231515, 0.39400183563927516, 0.4166014966534334, 0.431333341971749, 0.3986324099494186, 0.4156197580274428, 0.016650683546122647, 0.0013049524013711844, 0.003382415690385443, 0.004573329856219388, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09497539753547424, 0.11154780064436476, 0.10160914492614026, 0.1065347101458376, 0.1029046586825183, 0.10113757808340684, 0.12075785467494826, 0.1220730299732864, 0.11928076926330833, 0.10752543628442601, 0.10750283905259239, 0.08631544668587376, 0.10183731982091326, 0.08833954086497087, 0.10203927607324825, 0.1122958534496471, 0.07342541620946463, 0.07336970125237607, 0.9052502871680005, 0.94414998703743, 0.8758322832878428, 0.9130434842640027, 0.8737362125378675, 0.888495279380789, 0.9294035172752377, 0.9004190646399993, 0.9101305614043775, 0.23007747023552105, 0.20560146585331884, 0.23125553621885908, 0.25587011444442653, 0.22559934635705714, 0.22236654088568386, 0.23407553109006596, 0.19546625698005227, 0.20617532360588897, 0.3211242905645144, 0.23726381497471472, 0.22312293939941696, 0.2734314879880356, 0.22792168119763279, 0.21483051304262746, 0.2618641052191416, 0.24429482157902283, 0.30094746938003003, 0.16112769227668666, 0.13494022729662192, 0.09649680335137656, 0.14120232290900625, 0.17058456182407933, 0.15964269412836385, 0.14971911790813008, 0.15785023381276808, 0.13719021886036098, 0.1226953297454173, 0.11760411351188871, 0.12319602052475676, 0.1574463518072582, 0.13437221691051215, 0.1275647227253397, 0.13439332516771518, 0.1292341059858525, 0.1438285753632612, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06845232745543184, 0.0021142945297492055, 0.032595383076371, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14152021750577592, 0.03516892204995925, 0.0881107958578885, 0.09898100534670629, 0.07163934711061015, 0.03500263652203828, 0.12020043099478661, 0.09093692275733334, 0.08520672129855411, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09420926963263032, 0.08566919258988348, 0.07904581734256566, 0.09762741451168822, 0.10704717995771407, 0.08484530204126983, 0.08847939243816239, 0.08658333911869465, 0.07965055157888967, 0.4263453078260815, 0.4138981818326418, 0.4073042662791113, 0.38432342096446626, 0.40117109243212523, 0.39743011227263714, 0.3881249956367395, 0.3820931612846833, 0.3929545120848106, 0.11031259415453809, 0.10728308918401419, 0.10034444577059476, 0.12155309402884906, 0.1325290340935682, 0.09651821245999148, 0.11829386076418091, 0.08606493465056009, 0.09403980322330285, 0.16537235713648113, 0.19062668467044386, 0.1401506731452773, 0.1616018776425453, 0.16756435697651817, 0.14899246162427449, 0.1711488828205634, 0.15992145024734838, 0.156961899592985, 0.2670577962763653, 0.24266463886930634, 0.3086197720811418, 0.29280710538749644, 0.2751348497291978, 0.2805218380590443, 0.21665958328949975, 0.2763561139495082, 0.25315572516638696, 0.21538807270261007, 0.172176348201038, 0.21571119273985073, 0.2269442450589686, 0.23600389827410329, 0.20480218254894644, 0.18797287381552608, 0.19767231953119413, 0.17701634951010237, 0.2164312486953177, 0.21675831162579096, 0.23050320807659086, 0.2183992261008465, 0.21182437881053517, 0.22333085605956327, 0.22930361814080302, 0.2468514189039518, 0.20789312072631605, 0.17386190879135388, 0.17450300361617754, 0.17755663330037785, 0.1912848280190539, 0.19567770922016092, 0.19101849918483804, 0.1948369969388727, 0.18622463519070098, 0.1790087050379816, 0.5677095936640548, 0.18472611743302847, 0.18601582039054942, 0.4542787838376682, 0.19542661737870715, 0.1145001233130657, 0.25156637087403755, 0.5667218220695545, 0.5275163770045215, 0.4843777505386433, 0.1684715044696461, 0.43530030366919303, 0.35611828630681464, 0.36055210240609037, 0.3162712661290028, 0.16579513937858226, 0.3489242089403124, 0.33556530430464304, 0.17612232030049668, 0.189360829832398, 0.18753461642068736, 0.17449779646275676, 0.19973433629249415, 0.190671813187826, 0.20388354507991457, 0.19152480247197845, 0.1827375178136802, 0.08507078583391503, 0.09741502486466158, 0.07861088453123666, 0.0778494239658527, 0.10307221245557341, 0.08658292736278794, 0.104441599602206, 0.0839845452024307, 0.0901145718079962]}, "mutation_prompt": null}
{"id": "d0f95aef-85e7-474c-9c49-089963365a19", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.probability_1_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def probability_1_strategy(self, position):\n        if np.random.rand() < self.probability_1_rate:\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        else:\n            return position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Apply probability 1 strategy\n                self.particles[i] = self.probability_1_strategy(self.particles[i])\n                # Apply a new perturbation strategy to further enhance exploration\n                if np.random.rand() < 0.1:\n                    self.particles[i] += np.random.uniform(-0.1, 0.1, size=self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1.", "configspace": "", "generation": 36, "fitness": 0.2058986723933595, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "af913b57-d5f1-4bd9-9187-43425af0c951", "metadata": {"aucs": [0.42397217995100267, 0.40790800337546185, 0.4653927763467973, 0.40417473665015125, 0.3983764129943944, 0.39668448713966475, 0.4369709870916748, 0.4121423523489559, 0.4256196363918747, 0.03302774500568917, 0.011342712631275398, 9.999999999998899e-05, 0.010117577666172828, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.073184450209826, 0.11170000698361748, 0.09310686084183051, 0.0894189125907866, 0.0848122310187005, 0.11646107854743892, 0.116085704205099, 0.11923639495238658, 0.11121611482801141, 0.07041864708527501, 0.10028296657433822, 0.0972454791055758, 0.09989497320021035, 0.0741030113651846, 0.056356247660329095, 0.08950763442409138, 0.08129064277244491, 0.07978569690004456, 0.918983248755148, 0.9471385932906559, 0.8808092558287898, 0.8485178902057983, 0.8705182605644219, 0.8971622200227388, 0.921802992315089, 0.9260441507319682, 0.9105845904572308, 0.22885439985949407, 0.22348284129246743, 0.23126627778438325, 0.21771987355498623, 0.24229686171700904, 0.23381108971092046, 0.2230383654363164, 0.22897690361501144, 0.22364966326536628, 0.24946235986743426, 0.29122718475009146, 0.27400693665914, 0.21044804350180268, 0.23521638477581308, 0.20525999380138882, 0.23589814595542558, 0.22663866110034547, 0.2533562999289337, 0.132530217561037, 0.1324899680170385, 0.12795593387425963, 0.1278220434480969, 0.18231068430287245, 0.1605142699954638, 0.14983894284466115, 0.13904029923566052, 0.12792907319415847, 0.13589165902119038, 0.14964906202604378, 0.1274092987375658, 0.12517657083286882, 0.12875796627009417, 0.135607372971704, 0.12810872682148966, 0.13447854001082282, 0.1244629432480775, 9.999999999998899e-05, 0.012954443421252515, 0.0043428172652202335, 0.02007434002535846, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023782812710556156, 0.13082694078891777, 0.06874898470075896, 0.10183629476887401, 0.1034434342851055, 0.06123506616943564, 0.04085816933324371, 0.1310444148998422, 0.10189962117718165, 0.04863522901253181, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08115335086163755, 0.09681288883768469, 0.095807599280059, 0.08487273096500048, 0.08855805322534138, 0.08982222614022572, 0.10244231084907895, 0.09710903803522253, 0.0914677294362839, 0.3895421157469515, 0.461782079793405, 0.42314416059073834, 0.4032325731576296, 0.3739528442823603, 0.40348569062176654, 0.3995150368278131, 0.3869347921052554, 0.4160312848327692, 0.10000218036960684, 0.10644240137233141, 0.11788429859854821, 0.10157371538954885, 0.12283145318536426, 0.10609506304195204, 0.09706965016521096, 0.08982385308396845, 0.09470832073294655, 0.17122870914402832, 0.15791168723428595, 0.11877956615871843, 0.14594858569117475, 0.19440875833127946, 0.17145357517169924, 0.21415428850068208, 0.20275140359539034, 0.1934820983556046, 0.25352570927226115, 0.2825677752819755, 0.29408579176468697, 0.28350156787810477, 0.2898618556119793, 0.28977117162893506, 0.24050966755414316, 0.29428146221093876, 0.2581858237229817, 0.20647293796990351, 0.19187338166729162, 0.20485202795636692, 0.22041176043842736, 0.20377620131402407, 0.2302579752173206, 0.16104395971056706, 0.22128857233551236, 0.16635724159555554, 0.2235407301408504, 0.23246744652530593, 0.2251101919244879, 0.20030877928802826, 0.21932701022325685, 0.2384719447568181, 0.22250827348817015, 0.22160220115981344, 0.2123497085235012, 0.17961295820271972, 0.17786657691338592, 0.17588657467566027, 0.18836167240875656, 0.19808988355437585, 0.17866504925433224, 0.17172805235354516, 0.18296883786143592, 0.17551209533652712, 0.548303643088967, 0.18558563102705028, 0.18523367984303063, 0.5484120938801591, 0.19682549960939888, 0.5431799126221033, 0.4777194286734333, 0.14967689765003755, 0.472956696232009, 0.37630736253863395, 0.2054213281592967, 0.35660899150869496, 0.2044010450055319, 0.30110531119625217, 0.16598760988193118, 0.19706745901716338, 0.3405607916869112, 0.43547919042281924, 0.1804201666507237, 0.1860955413972658, 0.18676011837860307, 0.1799679315606012, 0.1826890622912518, 0.19721569614577616, 0.18633268588811047, 0.18234133612473613, 0.18860516066528388, 0.09799041400948372, 0.08981273354292729, 0.09147561012785899, 0.08382077799163201, 0.08410701515282903, 0.08544138259862355, 0.10416496584026758, 0.09697811033016823, 0.1021786822147096]}, "mutation_prompt": null}
{"id": "b32e1f98-66a5-4e46-8867-858e8a25d7bb", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.98\n        self.adaptive_cooling_rate = 0.6\n        self.levy_flight_alpha = 1.2\n        self.levy_flight_beta = 1.5\n        self.opposition_based_learning_rate = 0.3\n        self.inertia_weight = 0.85\n        self.inertia_weight_damping_ratio = 0.995\n        self.mutation_rate = 0.15\n        self.mutation_step_size = 0.15\n        self.velocity_clustering_rate = 0.15\n        self.particle_filtering_rate = 0.25\n        self.probability_2_rate = 0.2\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.02 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def probability_2_strategy(self, position):\n        if np.random.rand() < self.probability_2_rate:\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        else:\n            return position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.6 * np.random.uniform(-1, 1, size=self.dim) + 0.6 * (self.best_positions[i] - self.particles[i]) + 0.6 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.25:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Apply probability 2 strategy\n                self.particles[i] = self.probability_2_strategy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2.", "configspace": "", "generation": 37, "fitness": 0.1879017345389272, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "af913b57-d5f1-4bd9-9187-43425af0c951", "metadata": {"aucs": [0.36313580891459074, 0.4217929045772214, 0.38183510591080216, 0.37208438704364477, 0.3916357534034032, 0.41021022093378545, 0.395428913308428, 0.3646207688874632, 0.38304006489350273, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10136558551383967, 0.07110771239685287, 0.08865118587104504, 0.07455408661561491, 0.08769478780046669, 0.07861352647449726, 0.11401832186754834, 0.10709568685872894, 0.1286115224943415, 0.07613216897997865, 0.08191647812853009, 0.085650457263858, 0.07996735609874928, 0.07558354614379037, 0.0808281956178526, 0.06926748245539038, 0.07769374117590144, 0.08410199684366293, 0.9215626681081653, 0.947949117118046, 0.8975458042372134, 0.8704342687445767, 0.8635026982500855, 0.8898178798787683, 0.9220080173021946, 0.9299898832188246, 0.9317926139935788, 0.1946699702839243, 0.18676216962671044, 0.20127646699179735, 0.1873660118217536, 0.19789675818255614, 0.19409790167772067, 0.2056153545024766, 0.19071255728401348, 0.2137846674630598, 0.26366182377017733, 0.21012872210375677, 0.2169653066817555, 0.2605029937267762, 0.25865019269538836, 0.19935473494230882, 0.21935946196526068, 0.20463397734876365, 0.1966117794672213, 0.10699534398548072, 0.10997534553789734, 0.1241326834967893, 0.12036819254351194, 0.15179231020925854, 0.1333167786490672, 0.1366482654007366, 0.12901397452986585, 0.13329547354689986, 0.11452320774708169, 0.11378144777187515, 0.10971930560214571, 0.1341659519912286, 0.10852413975410569, 0.12016691449692318, 0.10923701333571478, 0.13650648577728297, 0.11354202298258076, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017780949318252026, 0.0239788061151901, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09337690593422954, 0.059237870564140205, 0.1325998848140496, 0.07336729320809032, 0.05545570651649867, 0.038997561601401665, 0.061244260653146365, 0.04345388746047285, 0.08317870184991005, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08349817784828106, 0.08993300664477788, 0.07112718712649968, 0.07628913754520306, 0.0741265268788951, 0.06681107377568074, 0.05557179541627244, 0.06597092235195101, 0.07734460507149166, 0.3858347494886152, 0.36661180084016665, 0.3989766055755223, 0.37767511338762316, 0.36074775615627297, 0.36894390869457716, 0.38263720515745814, 0.3834919134332233, 0.3661178696717493, 0.10807953190965724, 0.09153364692778809, 0.07294607851801105, 0.09595781963242933, 0.10579009096137992, 0.1091830267941315, 0.09041864090161544, 0.11270749479952302, 0.08546031978699542, 0.13491087741573393, 0.1446685201849628, 0.12872770087142815, 0.15989363776834764, 0.15753115828960818, 0.14370999464431589, 0.13452426269423212, 0.14219505076183048, 0.1504341345441631, 0.26871785877747034, 0.26314059349589014, 0.2743434695397934, 0.24480947166932787, 0.26467943042345576, 0.2622623676831184, 0.20635203758587095, 0.2644750495633007, 0.2357955364330654, 0.19580533134175648, 0.18234646203704763, 0.18981402160267002, 0.19305233732823035, 0.20514209080751233, 0.23384592151180572, 0.17781813480609376, 0.1978488528280815, 0.14682172117571168, 0.221163809375583, 0.22359101635281797, 0.2363093833310681, 0.22750946038041697, 0.21562286926007546, 0.2060199288397615, 0.24526840926483662, 0.21465858556068795, 0.21401157779408875, 0.16870784640500547, 0.1796529855926441, 0.1770273298832009, 0.2110006921366121, 0.18646535286947952, 0.17911548153011647, 0.19071187144764679, 0.1798637533609896, 0.1851463092547383, 0.4660633897856795, 0.1847005799945508, 0.18578172151837868, 0.4413187328303282, 0.19090189859710294, 0.16481792313126753, 0.16441635671735677, 0.15974098521813362, 0.1607016727780045, 0.3538437672366588, 0.2506004544737914, 0.41049810146504784, 0.18147532819544454, 0.1646060265702507, 0.16659807256161308, 0.16557504812526547, 0.16328284239418878, 0.3717315441516378, 0.1900360800278471, 0.18780861301791563, 0.187118984106446, 0.17763716692196196, 0.17929336921050054, 0.17437816664762507, 0.1884208168094874, 0.19325567306650981, 0.1882056250603822, 0.08201249769090246, 0.08400146162589639, 0.07979762120277178, 0.07501338847976535, 0.11258095969595994, 0.07652961923049117, 0.08285482230440666, 0.08772326750879544, 0.08998513508133132]}, "mutation_prompt": null}
{"id": "24ca0850-002e-481f-a834-c5f0ab993837", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.adaptive_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.adaptive_mutation_step_size = 0.05\n        self.velocity_clustering_rate = 0.1\n        self.dynamic_velocity_clustering_rate = 0.05\n        self.particle_filtering_rate = 0.2\n        self.probability_2_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def probability_2_strategy(self, position):\n        if np.random.rand() < self.probability_2_rate:\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        else:\n            return position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate + self.dynamic_velocity_clustering_rate * (evaluations / self.budget):\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate + self.adaptive_opposition_based_learning_rate * (evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.mutation_step_size += self.adaptive_mutation_step_size * (1 - evaluations / self.budget)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Apply probability 2 strategy\n                self.particles[i] = self.probability_2_strategy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2 using adaptive opposition-based learning rate, self-adaptive mutation step size, and dynamic velocity clustering rate.", "configspace": "", "generation": 38, "fitness": 0.20594681453194055, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "af913b57-d5f1-4bd9-9187-43425af0c951", "metadata": {"aucs": [0.43604150760531857, 0.42809948868607295, 0.4131498635892735, 0.4045880977742693, 0.402764016868417, 0.46164965415930903, 0.4107596067728896, 0.4217784031999784, 0.4238708154989915, 9.999999999998899e-05, 0.0010607099920248997, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018009132804123196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09323159029242345, 0.10589727558364193, 0.10060498765801695, 0.10141007839146621, 0.12609562978692468, 0.0770589963173186, 0.0957709229303284, 0.11331982332982338, 0.11008579732676826, 0.07636409836702862, 0.08837076561217416, 0.07295053192694867, 0.0962232938085239, 0.07454688171165147, 0.09924638350915627, 0.10918942448000579, 0.08150461922849206, 0.07823597670359472, 0.907678567766074, 0.9445062044721003, 0.8892858160338604, 0.9121452724813133, 0.8732429261511712, 0.8896998019987994, 0.9287488259162986, 0.9230269226609149, 0.9111024832513485, 0.2223971980563233, 0.20552038552342078, 0.21787894243540773, 0.2171462366017034, 0.221003401219525, 0.2249480463450031, 0.21427682218531796, 0.19784185723057712, 0.2237140892039846, 0.2844340030392064, 0.29572226406519486, 0.23352678916792724, 0.26885076575460354, 0.2613190672142387, 0.22859068733888832, 0.31180168223053295, 0.21534405498937081, 0.2971987395672804, 0.13851255385085715, 0.13958237326583445, 0.09969598584985329, 0.12512450792003216, 0.17849109378075778, 0.13586461855717558, 0.13204762390462077, 0.14106225556706864, 0.12832503777830317, 0.11873888157561319, 0.10992990977657469, 0.14153631003714506, 0.13712760925785372, 0.12757432761347298, 0.1367585846539663, 0.12145172291806317, 0.11969927190408214, 0.12456166465503815, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03425259114613399, 0.030263097140205697, 0.006327870056050178, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10841865955061458, 0.07520684554163615, 0.08940011147873805, 0.11343957657193882, 0.06293805084031212, 0.012466768177803345, 0.15377022264528806, 0.07619325315748193, 0.09235630607346834, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08863701181314154, 0.07952324731868798, 0.09187001852606647, 0.08463020476861771, 0.0937401558554809, 0.09033728249544526, 0.10032390271099212, 0.092032420960514, 0.0869740211410408, 0.40502494003665823, 0.4229033477441483, 0.42632165807717215, 0.3515004662005906, 0.4075441280894839, 0.42503371195647544, 0.4196896504670874, 0.4061572022504766, 0.39579622417662585, 0.10436757504426863, 0.10943764335254058, 0.10195250768210407, 0.10191597449512502, 0.11730282716451623, 0.10569487400067934, 0.11784876237167574, 0.09281660633470856, 0.09492928469119577, 0.15844805864716816, 0.184188652502824, 0.1445746585512696, 0.16151639045991084, 0.18520891518959204, 0.16423869594088758, 0.17285440439666677, 0.17053603050456223, 0.16656787710551202, 0.2550262945388494, 0.2433337187495056, 0.2884877193751806, 0.27610069346067745, 0.2899661830914657, 0.28197658391556446, 0.22144593111756772, 0.28969074177290266, 0.24422910710091594, 0.20235462726192277, 0.20040874773014816, 0.22769711020665873, 0.2000309990280129, 0.2260404587034981, 0.185002948656377, 0.18001876975714026, 0.20226396328288276, 0.13689769241646843, 0.2286570377039323, 0.22932669997127086, 0.22291670008467168, 0.23888867474085596, 0.23194159607072706, 0.23629796002765857, 0.2487663136401137, 0.22911735981096681, 0.22085100740559627, 0.1718239022378093, 0.18208889898586944, 0.1782390455285029, 0.19497773063611756, 0.18349377818942725, 0.20080412747844234, 0.19582352951327098, 0.18152007842404994, 0.1772870153811682, 0.5222384060248213, 0.1849313723526821, 0.18599264625905554, 0.47927076105223354, 0.19393246710702994, 0.11438908442854678, 0.2771635492713487, 0.5415166734584345, 0.513628953868289, 0.42331441170158945, 0.1684402797907536, 0.42913996142466737, 0.4068637175398826, 0.36754993773971745, 0.3220902129903047, 0.1659524208016948, 0.27826085252414123, 0.3772315494629006, 0.1779002163786112, 0.18603263380243973, 0.17707019763513887, 0.17596495775457188, 0.18536247363700908, 0.1744356434393245, 0.2045531518184308, 0.18856623166102737, 0.1811002968546256, 0.08040713115156217, 0.09256326283263061, 0.07519099415515407, 0.08300302871314724, 0.11836468772471931, 0.08467737768448458, 0.08990546242567321, 0.089146943981263, 0.10218721789354313]}, "mutation_prompt": null}
{"id": "c73ef220-ee82-4939-9073-fddbc192766e", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.98\n        self.adaptive_cooling_rate = 0.4\n        self.levy_flight_alpha = 1.2\n        self.levy_flight_beta = 1.6\n        self.opposition_based_learning_rate = 0.25\n        self.inertia_weight = 0.85\n        self.inertia_weight_damping_ratio = 0.995\n        self.mutation_rate = 0.12\n        self.mutation_step_size = 0.12\n        self.velocity_clustering_rate = 0.12\n        self.particle_filtering_rate = 0.22\n        self.probability_10_rate = 0.12\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def probability_10_strategy(self, position):\n        if np.random.rand() < self.probability_10_rate:\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        else:\n            return position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Apply probability 10 strategy\n                self.particles[i] = self.probability_10_strategy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 10.", "configspace": "", "generation": 39, "fitness": 0.20040571749081035, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "af913b57-d5f1-4bd9-9187-43425af0c951", "metadata": {"aucs": [0.4229413390195984, 0.4225014731378557, 0.42894851002625023, 0.3891317844257429, 0.39388927264530516, 0.4077176002969898, 0.47717076589692575, 0.3897954089231487, 0.4337561125428344, 0.04416981847988333, 0.003558287641833857, 0.0016505293259891918, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0034799474091647964, 9.999999999998899e-05, 0.10575988764405797, 0.08169411443588537, 0.08861479318516796, 0.08277948879567198, 0.10303510869816923, 0.09709303424444715, 0.11138157670948312, 0.11070236116327437, 0.10151300805213526, 0.070195211667608, 0.10151892837260112, 0.07163132529825522, 0.08932934078495125, 0.0679020596908072, 0.10141846654107978, 0.09836585066848424, 0.097684542668104, 0.07659479499495792, 0.90738687867722, 0.9450945196475423, 0.8684035983033574, 0.8194904044885265, 0.8714499854029261, 0.9276644821943282, 0.9117902320530253, 0.9199214644910888, 0.9198048882628727, 0.2104366848421968, 0.21455559809549563, 0.23529991781124981, 0.2150049652412922, 0.20475742086916204, 0.2074397819969388, 0.24370662029410328, 0.1987345454035646, 0.21650947045464186, 0.2755769345024829, 0.33373302922581993, 0.26701404599227063, 0.24603034869479423, 0.20923877350670816, 0.3346274748765544, 0.19849962904099627, 0.26771677400823446, 0.24088151135589142, 0.10909496512043193, 0.11410569066060994, 0.1289472411459085, 0.12443991951987043, 0.1314601153604399, 0.13256246211391431, 0.14098862493277298, 0.10216301924437066, 0.13582023952045275, 0.11910356081335105, 0.12707138825025577, 0.13304838908668248, 0.1254985833767578, 0.14515455765395235, 0.12550720068332843, 0.12436283364118628, 0.1517395730223825, 0.14357440942457145, 0.009129081069376266, 0.002620174225606786, 0.0041373752969288136, 0.04400985060879048, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11028472667723677, 0.088671417058802, 0.09833019866957127, 0.10114862163591443, 0.09075602011272366, 0.031473105864529116, 0.14763698248744372, 0.08156735244927782, 0.13148316442363706, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08078036530393473, 0.07717675651685352, 0.08584793227052556, 0.061674612755660885, 0.08163455402389841, 0.06881283606347466, 0.10648031814491465, 0.06387971511425439, 0.06746899890083458, 0.39103170264409126, 0.3864957231739836, 0.4023311642972097, 0.3878142364738394, 0.3779961613531907, 0.3934296161827794, 0.3963484112500808, 0.389611957367761, 0.37532509872759734, 0.09751561656925223, 0.1033940693685037, 0.079660910393336, 0.09528431663157277, 0.08517177379686058, 0.13911888760247926, 0.10165397147328636, 0.11402846945662493, 0.08620531403416731, 0.13311361785578613, 0.147315099832658, 0.15238803447597693, 0.1579007414812178, 0.17631824293822707, 0.16465900255501253, 0.17282591378705214, 0.14255613516089982, 0.1663259120285009, 0.27363076080768156, 0.24390160702056107, 0.27741884760273794, 0.26984274524724927, 0.27326118264182664, 0.2761465332243247, 0.21667858216430447, 0.27202294385825876, 0.24307426065883442, 0.19429599739281, 0.20210887531944632, 0.23223201644632407, 0.23453497156339598, 0.17642801174581924, 0.22992693249895269, 0.20100352754723028, 0.20448739385918346, 0.17105167395757215, 0.21364524522227046, 0.2362329282144151, 0.2265762811521087, 0.23174910582686814, 0.2243259091112113, 0.24422445022715766, 0.2208630592628964, 0.21491699463110137, 0.23648807400141325, 0.19328678066263294, 0.16948674578380074, 0.20899272515982692, 0.18153053208121106, 0.1758755907778592, 0.18425725924155567, 0.17651690534163278, 0.17167500238383493, 0.1771017948249679, 0.535121615083399, 0.18595273759272068, 0.18574346801292152, 0.2894041242804942, 0.19633764956744792, 0.14299084231904946, 0.14038867661109766, 0.5790811438994083, 0.4807456751173399, 0.38548276832840145, 0.20370955808901647, 0.47037227189221886, 0.35547362764027024, 0.16556128024709638, 0.1670983959672292, 0.16430720865779203, 0.37708318298937826, 0.268811414651823, 0.1776410433182275, 0.1862551571079747, 0.19295134843226502, 0.1680171876070462, 0.1811937652150486, 0.1829689924763669, 0.17870792492881193, 0.18409491557928892, 0.18418284842988542, 0.07198882057137523, 0.11361082743034279, 0.08763947420661733, 0.0921737781575912, 0.09267788786582676, 0.08793498434569169, 0.08388152512184965, 0.09540363317982958, 0.09879121835328719]}, "mutation_prompt": null}
{"id": "7e9c8abe-b50a-4416-b068-9e81b1492cc6", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.probability_1_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def probability_1_strategy(self, position):\n        if np.random.rand() < self.probability_1_rate:\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        else:\n            return position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Cauchy mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Apply probability 1 strategy\n                self.particles[i] = self.probability_1_strategy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget)) ** 2\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, using Cauchy mutation and a novel adaptive cooling schedule.", "configspace": "", "generation": 40, "fitness": 0.20461746832890804, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "af913b57-d5f1-4bd9-9187-43425af0c951", "metadata": {"aucs": [0.425982494011206, 0.44062892321773994, 0.4908113252244686, 0.4182409154641522, 0.3962873513751495, 0.4115226324952187, 0.40297753718445406, 0.43160801980850616, 0.4342756755818341, 0.010269990128131234, 0.019545217080989108, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11537127179424223, 0.10587931106534487, 0.1166050321065002, 0.10357093254823924, 0.09256500467954887, 0.09416464993543672, 0.12203733075701928, 0.12804699516624585, 0.09935112494346099, 0.0751517518660697, 0.07865737248729687, 0.0747257313398253, 0.09026040643502165, 0.101161071660271, 0.08908141205731224, 0.09457570395422676, 0.08700290187470294, 0.08523323928513149, 0.9151144204435582, 0.9370477253537365, 0.8832976851679104, 0.8499586907932071, 0.9005274552013485, 0.92227405168193, 0.9349824710844702, 0.9544039595818052, 0.9123201924604952, 0.20905313648976898, 0.21872896625418947, 0.20769812118200015, 0.2134947391884402, 0.21841544605487362, 0.21724105089485657, 0.2114988338482181, 0.226333322997739, 0.2114689595277398, 0.2316820127213698, 0.3121717739233909, 0.22514463143337704, 0.29573779012981805, 0.27103444817831535, 0.2036008678711213, 0.30803103278959665, 0.3024188126789942, 0.26528662924020074, 0.19161689311284824, 0.11596854808185308, 0.13807506261199853, 0.09813605755528465, 0.1496466017569884, 0.13073575569319895, 0.15398879616726413, 0.14017440283704252, 0.14845888516822436, 0.11834563035573686, 0.13937483412392426, 0.12930920258281298, 0.13913298853526557, 0.12806572254724724, 0.15010393262861377, 0.13130289944971552, 0.12543702596027584, 0.12964910661529416, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0024843159488402433, 0.0008554481576596995, 0.019506379499591775, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1681719142337459, 0.08041538169070772, 0.09967544931355876, 0.07237311283067416, 0.03649839409593081, 0.03468060858483257, 0.08780549205205812, 0.08728764617936235, 0.11124636315957126, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09578685587449565, 0.10061097938890073, 0.07512113464154224, 0.06956618979348428, 0.09761585692503483, 0.06152881282558287, 0.1045391757728974, 0.07648814038430596, 0.10575271875928594, 0.3839778260539559, 0.40348383977102986, 0.40886635234685975, 0.40581022781813403, 0.38177232342702994, 0.4026109418276814, 0.407510487199506, 0.3892202967805918, 0.41580266532812193, 0.11197193120736704, 0.08907851835068537, 0.08210329418987439, 0.09030214381916613, 0.11039046177515177, 0.10348129243109527, 0.12847579811031407, 0.09199101262578202, 0.09888928672118413, 0.17261344503371767, 0.21241520286793925, 0.13226585487730957, 0.15053198075233287, 0.15688429090234934, 0.1577364373841842, 0.15772225615954139, 0.14793449096284583, 0.14790837698276904, 0.30086707939804336, 0.2916662829024904, 0.27185151109591554, 0.2800908423780274, 0.28677015488387747, 0.25113095918437145, 0.24943715789884402, 0.2694129350574228, 0.23550520497464222, 0.19934592381262162, 0.2012229904230357, 0.23764228001590904, 0.221374992905226, 0.1978251425963683, 0.22852831525894668, 0.18926950030940792, 0.22403321102907803, 0.17067722549465125, 0.21897252753333685, 0.22648999242931367, 0.2520198398529996, 0.21952536247065224, 0.22613719996022397, 0.22021302291168365, 0.22413266122727937, 0.22258738557355373, 0.2419759935471889, 0.18791767928239111, 0.17319341335935767, 0.18900642611157514, 0.18282302716632892, 0.1741327121015882, 0.18313927977085187, 0.17559970089198673, 0.18632474743236394, 0.1716185852833907, 0.183974047383628, 0.18455461881897295, 0.18541563419579865, 0.17104289618149982, 0.1973050944374778, 0.19398971016468192, 0.4296732555057623, 0.5572259618846405, 0.5050741845528739, 0.3908818823537813, 0.5366212516119135, 0.46598028151026993, 0.3332695896582961, 0.1647887837605433, 0.1656624667800648, 0.1657521939881531, 0.27313792011473625, 0.5127476974558585, 0.1785028080389489, 0.17542511344834744, 0.18115826715099526, 0.18895151170508384, 0.19055692822056036, 0.17336712375327823, 0.1928940319747885, 0.18436082180656754, 0.1793358019181276, 0.08337016619519633, 0.08164151362218797, 0.07802692168840353, 0.08699842657944323, 0.08036199107348041, 0.09475099350313998, 0.09433628142147099, 0.07724020169749524, 0.09249321406033484]}, "mutation_prompt": null}
{"id": "7076e3f9-149e-4aa2-8bf3-2321dd0ab61d", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.3  # Changed from 0.5 to 0.3\n        self.levy_flight_alpha = 1.2  # Changed from 1.5 to 1.2\n        self.levy_flight_beta = 1.6  # Changed from 1.8 to 1.6\n        self.opposition_based_learning_rate = 0.3  # Changed from 0.2 to 0.3\n        self.inertia_weight = 0.8  # Changed from 0.9 to 0.8\n        self.inertia_weight_damping_ratio = 0.98  # Changed from 0.99 to 0.98\n        self.mutation_rate = 0.2  # Changed from 0.1 to 0.2\n        self.mutation_step_size = 0.2  # Changed from 0.1 to 0.2\n        self.velocity_clustering_rate = 0.2  # Changed from 0.1 to 0.2\n        self.particle_filtering_rate = 0.3  # Changed from 0.2 to 0.3\n        self.probability_7_rate = 0.2  # Changed from 0.1 to 0.2\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def probability_7_strategy(self, position):\n        if np.random.rand() < self.probability_7_rate:\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        else:\n            return position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Apply probability 7 strategy\n                self.particles[i] = self.probability_7_strategy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 3.", "configspace": "", "generation": 41, "fitness": 0.1879870884485435, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "af913b57-d5f1-4bd9-9187-43425af0c951", "metadata": {"aucs": [0.4283437503761396, 0.3573472031367221, 0.36591932307325703, 0.35300194095741666, 0.3679144461338315, 0.38243757603013084, 0.34843343889714107, 0.3755436058014314, 0.4024498661053887, 9.999999999998899e-05, 9.999999999998899e-05, 0.03507236427966198, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10538325865095033, 0.08593742445732755, 0.09206275216264881, 0.0919691740223163, 0.07256547933791568, 0.09856624438811634, 0.08781153603782188, 0.08935451889599522, 0.08194132828813927, 0.08676823486991836, 0.0811288822026941, 0.0813359684660323, 0.09730691109849454, 0.051219265892336496, 0.07433060553844972, 0.08722460349743522, 0.07465457188918967, 0.11710606432519421, 0.8851840225109291, 0.9214698507341441, 0.8385731526909448, 0.7879586507594522, 0.7794166467713992, 0.7574882808030543, 0.9171609537972876, 0.8833121018935883, 0.8851966088809199, 0.20847407059946932, 0.19309879666284913, 0.2072644067410303, 0.22007438850586636, 0.21332514875625097, 0.21653997524581148, 0.21522408837363294, 0.22190731803653752, 0.21140908071888065, 0.22241929086288903, 0.2983882384630838, 0.20715099281458083, 0.23731371562087689, 0.22040626024072185, 0.27722581812719094, 0.22791773210809285, 0.23286070460586206, 0.19733639742361897, 0.11753265738206042, 0.11045974665007374, 0.0845295539492561, 0.0757984590643902, 0.15165155680928177, 0.12517272976896654, 0.13976588345057028, 0.10654007967872381, 0.155629569864983, 0.12807296872305085, 0.1252724214875801, 0.12294986809239639, 0.11757618194373298, 0.13445222151038394, 0.1271890575351614, 0.11801365123851792, 0.11810379994777431, 0.11587977075713751, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018267046954353883, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13508568201367777, 0.06283382421324535, 0.1134601430339901, 0.10797806458051129, 0.05009454994127116, 0.03770611589180184, 0.08205256899351276, 0.07729011916785389, 0.053211237417476354, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06571850990143391, 0.06346933052242532, 0.07381130270077574, 0.06058704117577962, 0.08280406734737789, 0.049344433219403405, 0.07486233543525345, 0.058575952092358774, 0.059315857112352766, 0.34324884003150313, 0.3625788803381109, 0.3455085508860546, 0.34038906331628993, 0.3299647087215992, 0.3386063729704524, 0.3592879548474319, 0.38967324602740117, 0.3985410350235884, 0.08484631902201889, 0.09949019014726035, 0.08101576044041048, 0.10097771255978205, 0.07082772970646656, 0.09764649737264297, 0.09223899861930929, 0.10211520158810983, 0.1112955018870998, 0.17641815568240204, 0.1547340421585366, 0.12330951057988004, 0.14021415040598117, 0.15625447675048476, 0.15617323303722952, 0.16282208261539022, 0.1702290843947012, 0.2080115113019354, 0.24135018818167797, 0.2618172597557966, 0.24377530047320073, 0.27099175710321266, 0.2594949963258225, 0.23800078146634562, 0.2619001617306115, 0.2506676307526243, 0.2759986229470772, 0.1728409128272793, 0.1762035843422436, 0.1978899398733428, 0.1980852447116931, 0.22861645807720032, 0.20104423174560504, 0.19781952818427495, 0.20650505796887453, 0.18007800187060496, 0.21699562495401792, 0.21704459690853062, 0.20500436637261688, 0.2286399018616586, 0.21723262170460855, 0.259539469506051, 0.23922640260893235, 0.21126557560301695, 0.26020723618800956, 0.1789190136787493, 0.18930898065098334, 0.17787288005779356, 0.20354928125123373, 0.2024681260507487, 0.17050307515985974, 0.18946890532705885, 0.17039100946002161, 0.17485027062505032, 0.4513625478122243, 0.18483983678875593, 0.5110333682347559, 0.18849262280686785, 0.19594997546602855, 0.4351796838795834, 0.164911290398832, 0.1793835254363232, 0.16609060004719778, 0.385108677500951, 0.20123958866966873, 0.39243772551303435, 0.19828246319598164, 0.20422857466938793, 0.1973027029505655, 0.16587076659233702, 0.3415815101129738, 0.16539218560287172, 0.17751293600022455, 0.18429259353069527, 0.19041282325538245, 0.17762807074477083, 0.181151633042549, 0.17894521775299577, 0.1797494171991062, 0.17997830144965987, 0.17291269794473174, 0.08777491855290642, 0.09274821275784761, 0.0930923865511799, 0.08992586663207347, 0.10856902058708107, 0.07962510301496406, 0.07889115790547929, 0.10128669649709665, 0.08925520791985564]}, "mutation_prompt": null}
{"id": "d25c034f-be07-483b-8edb-d55b0901c99d", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.probability_2_rate = 0.05\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def probability_2_strategy(self, position):\n        if np.random.rand() < self.probability_2_rate:\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        else:\n            return position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Apply probability 2 strategy\n                self.particles[i] = self.probability_2_strategy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2.", "configspace": "", "generation": 42, "fitness": 0.20684135992736868, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "af913b57-d5f1-4bd9-9187-43425af0c951", "metadata": {"aucs": [0.4756949339110622, 0.4333912591949779, 0.46566355847561636, 0.4355248314377903, 0.461946736740388, 0.42053560963789816, 0.448156418823384, 0.41386583348065364, 0.4402979120449142, 0.02010450603674563, 0.018857090926141296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09703064924053484, 0.12656451739278674, 0.10213052570861203, 0.11338063116006591, 0.11609272267965265, 0.09253663188454064, 0.10701887187439352, 0.10063422442648695, 0.08111689930363042, 0.08261046776638503, 0.08882341656390613, 0.08820405494335737, 0.08091146888203893, 0.07032324884338192, 0.07629101055355225, 0.09709679668184801, 0.11577648086892567, 0.09571483495197941, 0.9114577212565125, 0.9316817660436431, 0.9213643535347626, 0.9039680932333743, 0.8712586630260706, 0.831347275015313, 0.9257510329589483, 0.9243599662105001, 0.918040653369932, 0.22733071013064032, 0.22456086778045714, 0.2241946593693832, 0.23502989185236622, 0.23370234632417586, 0.21564788162857162, 0.2587439082492219, 0.20883235711001757, 0.22971460750586858, 0.3374851160834633, 0.3269803542255644, 0.23562997167776445, 0.26120831469448824, 0.25392416082180336, 0.2496430583420869, 0.26224563075627416, 0.2597530762913224, 0.28734223105064616, 0.14167883874009657, 0.1349369384411352, 0.12561245851918024, 0.11363761305987885, 0.16246251972656578, 0.14814896081928042, 0.14788608588009444, 0.1589404509300517, 0.18284587763960802, 0.13406581948869933, 0.12909216929150913, 0.12490883620121951, 0.13718663559979027, 0.12929106877448227, 0.14040784059274725, 0.15777578536250436, 0.15310098039534548, 0.13759082142604107, 9.999999999998899e-05, 9.999999999998899e-05, 0.000648484574568231, 0.057478329731000866, 0.0014199336192787237, 0.0008881104430985554, 0.0007056011859043476, 0.00010303581323167776, 0.0005093501133929257, 0.11561872306130039, 0.05761353453740958, 0.09025629810533609, 0.10453636517061782, 0.07032892493092313, 0.019613107649635975, 0.16096794525355784, 0.11396748025748471, 0.11592448443225845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007849376966457933, 9.999999999998899e-05, 0.11560745283832163, 0.11517615454109653, 0.08804168037919258, 0.08373926201003612, 0.08078944530193855, 0.07321483119790828, 0.10085237163515992, 0.12095451891661635, 0.08728738914279077, 0.4264954038896317, 0.42485656315459974, 0.410924928463806, 0.39333255538005163, 0.3913629891994099, 0.40774561437136936, 0.4155922079914658, 0.4328509934808077, 0.42681741966005016, 0.10238357319437452, 0.08746965477574453, 0.10987621850242302, 0.09614813133349764, 0.09097816205090026, 0.13101981219253833, 0.113511714708458, 0.11045277333414782, 0.1250477976938581, 0.13500881108898943, 0.15289033302247312, 0.17702917304181487, 0.15101860525602295, 0.16448047104554575, 0.14680122468341483, 0.18601640321476032, 0.1652618839731953, 0.13444074281213347, 0.30162945622559323, 0.302433361161465, 0.3056066509429385, 0.297491610036388, 0.30673878776829544, 0.29789393400535435, 0.23796496737610118, 0.30112683533431617, 0.281603194623116, 0.2157943481868645, 0.18797909487072118, 0.22282883435508516, 0.20303350557801658, 0.19627283971379106, 0.20364223925483937, 0.1972422540767771, 0.19399477240154628, 0.1752877811850636, 0.2274817297301701, 0.22836268445136576, 0.23017289620292825, 0.2647035825472278, 0.22969474933306033, 0.22693751752358338, 0.21670268729007314, 0.2160719569936218, 0.22116164787490744, 0.1894573431715778, 0.18462966421073468, 0.20240557970530393, 0.20655705809624125, 0.19684409149608595, 0.18952313743159188, 0.19211365489593124, 0.17842162826588104, 0.18120375473063255, 0.55243773828959, 0.18568642363434484, 0.18613951928448969, 0.17167674003099143, 0.19892615106129719, 0.11561888420458677, 0.14050732682933853, 0.5461013292514895, 0.15915433657509748, 0.42827336061806665, 0.20932248351519278, 0.49145076943780974, 0.35720420975393063, 0.3642607297982704, 0.17193354169373887, 0.1664220357493823, 0.32761736498459426, 0.33865701553956296, 0.19975770847811336, 0.20533762627078445, 0.18140178543335417, 0.1860784834327711, 0.18052901295476353, 0.18207218942832448, 0.18593760142036486, 0.17754998330315974, 0.17066802140418824, 0.08189152335231575, 0.08822330221211228, 0.09462697067532477, 0.08365318259499288, 0.08785530884140402, 0.07207698637926008, 0.09288062411516618, 0.09330405603749492, 0.09881871948772603]}, "mutation_prompt": null}
{"id": "5ed453ea-feab-400a-9767-2f04a3875880", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.dynamic_velocity_adaptation_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def dynamic_velocity_adaptation(self, velocities):\n        velocity_adaptation_factors = np.random.uniform(0.1, 0.9, size=self.swarm_size)\n        return velocities * velocity_adaptation_factors[:, np.newaxis]\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.velocities[i] = self.dynamic_velocity_adaptation(np.array([self.velocities[i]]))[0]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation for increased diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, utilizing a novel \"Dynamic Velocity Adaptation\" approach to adjust velocity updates.", "configspace": "", "generation": 43, "fitness": 0.19199099464907285, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.15.", "error": "", "parent_id": "af913b57-d5f1-4bd9-9187-43425af0c951", "metadata": {"aucs": [0.4619595615329771, 0.4732177889354824, 0.46807848708258193, 0.46456867759072895, 0.4570905621232809, 0.4748963297628157, 0.44840311172643965, 0.4538554450940936, 0.4547778442758992, 9.999999999998899e-05, 0.050241647479976725, 9.999999999998899e-05, 9.999999999998899e-05, 0.015246800643814118, 9.999999999998899e-05, 9.999999999998899e-05, 0.017339476800349418, 9.999999999998899e-05, 0.08567649293919333, 0.06460478735277575, 0.07976802959826124, 0.09396851745329093, 0.08161622893455645, 0.08941979850586701, 0.10834925217356017, 0.07446020656141938, 0.11807527751584679, 0.07158291587951937, 0.09962959205379796, 0.08332282566442906, 0.08748940218071088, 0.07477318763288054, 0.06909627172416699, 0.10089739887113847, 0.07935234151660353, 0.06042361608706959, 0.6753402888426585, 0.8979578639690031, 0.3154636354285917, 0.12492902602708933, 0.2903353223843578, 0.14742021150414386, 0.6280300879743135, 0.8314049420061744, 0.7792878052598717, 0.2724871301955273, 0.28516207980169106, 0.23353731001501288, 0.29719090285696237, 0.24078018840542248, 0.23947449581133562, 0.2784808095427316, 0.26246582914487127, 0.20969377068312023, 0.22422387898276197, 0.22459442064446034, 0.2181264399008882, 0.2634272022474986, 0.24307446028479296, 0.2066413675298293, 0.22476503096930633, 0.16802977586567525, 0.22489557475540245, 0.29867350478422516, 0.2275952027786423, 0.17650174235687643, 0.044796357386357344, 0.134542080629098, 0.22322784158684383, 0.18276018670347716, 0.17962906740537032, 0.13660320396240133, 0.1625724788413927, 0.15963711721639973, 0.14400031544353165, 0.16926597929584353, 0.14353120971443534, 0.17055019502066138, 0.14595485344284265, 0.16199966263245857, 0.13983671025536637, 9.999999999998899e-05, 9.999999999998899e-05, 0.02763119356007704, 9.999999999998899e-05, 0.009549601008449815, 9.999999999998899e-05, 0.001159026584789169, 0.004783531374389138, 0.000186799598206, 0.11534237816788806, 0.06618760920089284, 0.12887198931890975, 0.06981380048845054, 0.14097673541074618, 0.03023765899186015, 0.08986207087990494, 0.04003624235234149, 0.04120718114659938, 0.005524208317117529, 0.0018111567802152617, 9.999999999998899e-05, 0.011381397104091584, 0.00431772575794187, 0.0013302698853729922, 0.025960190891957113, 9.999999999998899e-05, 0.0032260509197303833, 0.1373856930244206, 0.11128052772789465, 0.06291789518953306, 0.15210589147445075, 0.09679401531631049, 0.11365569820285093, 0.10525949532322831, 0.11331767070015775, 0.08679097299663685, 0.46012803665597735, 0.3838390629004643, 0.43864586522265825, 0.42119829958354627, 0.3999304724263244, 0.36026107634406357, 0.44437144853317545, 0.41597477094873725, 0.4004328061717175, 0.10610223630774673, 0.12168525527843865, 0.07501306123389206, 0.10002127256638993, 0.07048218297953734, 0.12150242223110819, 0.08751700546862229, 0.10511832858559678, 0.08468338375616824, 0.19147814778359573, 0.13325662677104977, 0.15917882213961276, 0.1678287589562144, 0.17131814358172037, 0.15702896413847933, 0.17290515648950222, 0.1609837433609662, 0.20229300366343073, 0.2381329777191621, 0.17543561799001928, 0.2688083852820409, 0.28199826002399364, 0.2831054209112511, 0.3079636428801926, 0.21417792342678565, 0.28010504048363327, 0.22020901123124914, 0.17878185580325734, 0.21760471776037293, 0.21294462066172926, 0.21398735611903053, 0.22023216764723363, 0.2559390656022633, 0.19078521713427055, 0.20832311204364928, 0.19272679603568954, 0.2262436407357834, 0.25973011393967926, 0.23004906564869432, 0.2495962108404105, 0.2352769663270935, 0.25029560677258034, 0.23283388528338267, 0.23432919267126184, 0.21982116617918745, 0.18541183246934712, 0.18554123046932602, 0.17845840687307024, 0.17130700553682054, 0.18027930217370758, 0.1829108353478871, 0.16149769134978575, 0.179390797356355, 0.17905141467380548, 0.18496393298312763, 0.18630923866036053, 0.1856768847510517, 0.5668238542508806, 0.19570150056665225, 0.11389106963862816, 0.13961143539031584, 0.16549904778224622, 0.6132335904180397, 0.45371302409090175, 0.4642612469320998, 0.3334816169449172, 0.46991112180738026, 0.3220929027245304, 0.1657222288989273, 0.16427163469875072, 0.3208352349287801, 0.37867498991579474, 0.19665013354045535, 0.1915855754409267, 0.1802906934946732, 0.19462138188992006, 0.18006867564415951, 0.18086891793320836, 0.17843572454749423, 0.18008868443561876, 0.1748030202899732, 0.09214108470864069, 0.1109101302246347, 0.07386877914317669, 0.08144327711210575, 0.09151799057772236, 0.08658388872368827, 0.08698348081952412, 0.07980307047008028, 0.09706775845895044]}, "mutation_prompt": null}
{"id": "a70c287f-6707-40a0-a842-060a6a2bd810", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.opposition_based_learning_memory = 0.5\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.adaptive_mutation_rate = 0.05\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.probability_2_rate = 0.1\n        self.dynamic_cooling_schedule = 0.5\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def opposition_based_learning_with_memory(self, position, memory):\n        return memory * position + (1 - memory) * self.opposition_based_learning(position)\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def adaptive_self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.adaptive_mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def probability_2_strategy(self, position):\n        if np.random.rand() < self.probability_2_rate:\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        else:\n            return position\n\n    def dynamic_cooling_schedule(self, evaluations):\n        return self.cooling_rate * (1 - self.dynamic_cooling_schedule * (evaluations / self.budget))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with memory for improved convergence\n                if np.random.rand() < self.opposition_based_learning_rate:\n                    opposition_position = self.opposition_based_learning_with_memory(self.particles[i], self.opposition_based_learning_memory)\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Adaptive self-adaptive mutation for increased diversity\n                if np.random.rand() < self.adaptive_mutation_rate:\n                    mutated_position = self.adaptive_self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Apply probability 2 strategy\n                self.particles[i] = self.probability_2_strategy(self.particles[i])\n            # Modified simulated annealing with dynamic cooling schedule\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / (self.temperature * self.dynamic_cooling_schedule(evaluations))):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2, featuring adaptive mutation rates, opposition-based learning with memory, and dynamic cooling schedules.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'float' object is not callable\").", "error": "TypeError(\"'float' object is not callable\")", "parent_id": "af913b57-d5f1-4bd9-9187-43425af0c951", "metadata": {}, "mutation_prompt": null}
{"id": "652aeb58-35be-4d9d-8c52-452864087a5e", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.probability_3_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def probability_3_strategy(self, position, velocity):\n        if np.random.rand() < self.probability_3_rate:\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim), np.random.uniform(-1, 1, size=self.dim)\n        else:\n            return position, velocity\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i], self.velocities[i] = self.probability_3_strategy(self.particles[i], self.velocities[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation with adaptive rate\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 3, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning.", "configspace": "", "generation": 45, "fitness": 0.2089665524718994, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "af913b57-d5f1-4bd9-9187-43425af0c951", "metadata": {"aucs": [0.44301459635738194, 0.40585193604552827, 0.4402735147467527, 0.45425782061304687, 0.407208402918787, 0.42227364013521385, 0.4052427513275413, 0.4440286767362436, 0.4409672322713607, 0.005631538367933953, 0.0022202443914393077, 0.03379995079477416, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01254247984995871, 9.999999999998899e-05, 0.13112043255416006, 0.10986062255390316, 0.0808085336591976, 0.07859077431680761, 0.11137487491138398, 0.10979863924522526, 0.10520082567070499, 0.12839831176577443, 0.12192433483160892, 0.10419063933402628, 0.0985732823377703, 0.08409073093999253, 0.08703918148121226, 0.07136164973751058, 0.09231667276967437, 0.0983583716862273, 0.07276727375252545, 0.09882297151094221, 0.899793538899336, 0.937877004009221, 0.8858559438214422, 0.8202266478867815, 0.8588129697784714, 0.8894754622765353, 0.9383183204336523, 0.9185737372066689, 0.9159823803685321, 0.23059348348657704, 0.24389733292227223, 0.2276034394307248, 0.21726321954331296, 0.22742657947530753, 0.22084753286445913, 0.23830385471636328, 0.21304800368513066, 0.22362557836299546, 0.3481603115135691, 0.26939698012261337, 0.24602812752532965, 0.2590115484355713, 0.2649786963113019, 0.2302327636577427, 0.31444141444782325, 0.20046055711147093, 0.23592341443319842, 0.13597847529253326, 0.13864747097307495, 0.14442926247440735, 0.15392630151178344, 0.19923501666402288, 0.15132394018734374, 0.12292803890203763, 0.1369890375958086, 0.12755912288310323, 0.14460743209139715, 0.14031270506523075, 0.1378997091603158, 0.13553096348972615, 0.12315461005129458, 0.12149292568493164, 0.13222236339153282, 0.12189791828058949, 0.1283995768508276, 9.999999999998899e-05, 0.0038501895680599363, 0.0039062135849499136, 0.01900843413121034, 9.999999999998899e-05, 9.999999999998899e-05, 0.03319010908212916, 9.999999999998899e-05, 0.004303112332490255, 0.1013814157459999, 0.0924809035860158, 0.1549377535554124, 0.10928817082170139, 0.049730396208183425, 0.050703576269837125, 0.10113265814970329, 0.08918154066088757, 0.07979549497275251, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010329913277620784, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10716546635089275, 0.1032711360400137, 0.08069464050130992, 0.09832380984461764, 0.0764454163667706, 0.09084833284715133, 0.0908741573640024, 0.09827087550779345, 0.0890837814446308, 0.38445329864469546, 0.39460170881488055, 0.3970851801724168, 0.3891426847760152, 0.36915634870363156, 0.39057994174383237, 0.39797558774019337, 0.4078636319262686, 0.4073916179076288, 0.10811663954166939, 0.10926342310010773, 0.10531002329410588, 0.10246394608734899, 0.10180135707719529, 0.11303908638905069, 0.09982224750258828, 0.10103177245326678, 0.08673818094350061, 0.1453421743741956, 0.19112367645864448, 0.14186437022334664, 0.15742785193730346, 0.16111242340504883, 0.18167050059328727, 0.15635090109189553, 0.15228107977450067, 0.18355423510170887, 0.2029605817822755, 0.2520626884015277, 0.29179944699812477, 0.251500547623436, 0.28159890003905375, 0.2561984542414242, 0.22462393918635704, 0.25972081483485865, 0.27326757738435403, 0.18546696373566185, 0.2237214392165574, 0.22958388672670416, 0.23144680539673446, 0.20565768381373872, 0.21226741382812908, 0.18146077013970263, 0.21375754946025305, 0.19772464910465826, 0.23592193567216213, 0.27015672177883376, 0.23647522309172175, 0.2345061456627876, 0.22297192722957238, 0.2549273498038689, 0.20344916708016814, 0.21426314515220635, 0.21110186240380746, 0.1860890235300029, 0.1901940790809532, 0.16799708826283732, 0.17728864221240404, 0.18220436376516336, 0.18823061848908718, 0.1824902678931979, 0.17235029602808005, 0.18164555821802308, 0.6613083701297587, 0.18508556508891272, 0.1861571162139567, 0.48994353176005656, 0.19619742734323287, 0.19442498927521767, 0.153585494877591, 0.5756488613149618, 0.5919728349008464, 0.5949581769470548, 0.3649774342228046, 0.3862968506547815, 0.20144537977580135, 0.47213915512142135, 0.16563624113125774, 0.33532792116969135, 0.3570310270284647, 0.37821829647936533, 0.17541721028812185, 0.17675654442419564, 0.18423968835207327, 0.17287236016336516, 0.17906229955995645, 0.191867076992849, 0.17488905268578292, 0.18728525294626597, 0.1801122220040997, 0.07842564100627714, 0.09598407582014168, 0.09562919387451385, 0.08167369263761826, 0.08759643905661141, 0.0853943116738719, 0.08678467366499987, 0.08113096510727669, 0.09315042408520624]}, "mutation_prompt": null}
{"id": "36d1f43c-a7b5-447f-af2b-075e573c99a8", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV1:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.probability_1_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def self_adaptive_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.uniform(-self.mutation_step_size, self.mutation_step_size, size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def probability_1_strategy(self, position, velocity):\n        if np.random.rand() < self.probability_1_rate:\n            return np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim), np.random.uniform(-1, 1, size=self.dim)\n        else:\n            return position, velocity\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i], self.velocities[i] = self.probability_1_strategy(self.particles[i], self.velocities[i])\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Self-adaptive mutation with adaptive rate\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.self_adaptive_mutation(self.particles[i])\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV1(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV1", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning.", "configspace": "", "generation": 46, "fitness": 0.2089665524718994, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV1 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "652aeb58-35be-4d9d-8c52-452864087a5e", "metadata": {"aucs": [0.44301459635738194, 0.40585193604552827, 0.4402735147467527, 0.45425782061304687, 0.407208402918787, 0.42227364013521385, 0.4052427513275413, 0.4440286767362436, 0.4409672322713607, 0.005631538367933953, 0.0022202443914393077, 0.03379995079477416, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01254247984995871, 9.999999999998899e-05, 0.13112043255416006, 0.10986062255390316, 0.0808085336591976, 0.07859077431680761, 0.11137487491138398, 0.10979863924522526, 0.10520082567070499, 0.12839831176577443, 0.12192433483160892, 0.10419063933402628, 0.0985732823377703, 0.08409073093999253, 0.08703918148121226, 0.07136164973751058, 0.09231667276967437, 0.0983583716862273, 0.07276727375252545, 0.09882297151094221, 0.899793538899336, 0.937877004009221, 0.8858559438214422, 0.8202266478867815, 0.8588129697784714, 0.8894754622765353, 0.9383183204336523, 0.9185737372066689, 0.9159823803685321, 0.23059348348657704, 0.24389733292227223, 0.2276034394307248, 0.21726321954331296, 0.22742657947530753, 0.22084753286445913, 0.23830385471636328, 0.21304800368513066, 0.22362557836299546, 0.3481603115135691, 0.26939698012261337, 0.24602812752532965, 0.2590115484355713, 0.2649786963113019, 0.2302327636577427, 0.31444141444782325, 0.20046055711147093, 0.23592341443319842, 0.13597847529253326, 0.13864747097307495, 0.14442926247440735, 0.15392630151178344, 0.19923501666402288, 0.15132394018734374, 0.12292803890203763, 0.1369890375958086, 0.12755912288310323, 0.14460743209139715, 0.14031270506523075, 0.1378997091603158, 0.13553096348972615, 0.12315461005129458, 0.12149292568493164, 0.13222236339153282, 0.12189791828058949, 0.1283995768508276, 9.999999999998899e-05, 0.0038501895680599363, 0.0039062135849499136, 0.01900843413121034, 9.999999999998899e-05, 9.999999999998899e-05, 0.03319010908212916, 9.999999999998899e-05, 0.004303112332490255, 0.1013814157459999, 0.0924809035860158, 0.1549377535554124, 0.10928817082170139, 0.049730396208183425, 0.050703576269837125, 0.10113265814970329, 0.08918154066088757, 0.07979549497275251, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010329913277620784, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10716546635089275, 0.1032711360400137, 0.08069464050130992, 0.09832380984461764, 0.0764454163667706, 0.09084833284715133, 0.0908741573640024, 0.09827087550779345, 0.0890837814446308, 0.38445329864469546, 0.39460170881488055, 0.3970851801724168, 0.3891426847760152, 0.36915634870363156, 0.39057994174383237, 0.39797558774019337, 0.4078636319262686, 0.4073916179076288, 0.10811663954166939, 0.10926342310010773, 0.10531002329410588, 0.10246394608734899, 0.10180135707719529, 0.11303908638905069, 0.09982224750258828, 0.10103177245326678, 0.08673818094350061, 0.1453421743741956, 0.19112367645864448, 0.14186437022334664, 0.15742785193730346, 0.16111242340504883, 0.18167050059328727, 0.15635090109189553, 0.15228107977450067, 0.18355423510170887, 0.2029605817822755, 0.2520626884015277, 0.29179944699812477, 0.251500547623436, 0.28159890003905375, 0.2561984542414242, 0.22462393918635704, 0.25972081483485865, 0.27326757738435403, 0.18546696373566185, 0.2237214392165574, 0.22958388672670416, 0.23144680539673446, 0.20565768381373872, 0.21226741382812908, 0.18146077013970263, 0.21375754946025305, 0.19772464910465826, 0.23592193567216213, 0.27015672177883376, 0.23647522309172175, 0.2345061456627876, 0.22297192722957238, 0.2549273498038689, 0.20344916708016814, 0.21426314515220635, 0.21110186240380746, 0.1860890235300029, 0.1901940790809532, 0.16799708826283732, 0.17728864221240404, 0.18220436376516336, 0.18823061848908718, 0.1824902678931979, 0.17235029602808005, 0.18164555821802308, 0.6613083701297587, 0.18508556508891272, 0.1861571162139567, 0.48994353176005656, 0.19619742734323287, 0.19442498927521767, 0.153585494877591, 0.5756488613149618, 0.5919728349008464, 0.5949581769470548, 0.3649774342228046, 0.3862968506547815, 0.20144537977580135, 0.47213915512142135, 0.16563624113125774, 0.33532792116969135, 0.3570310270284647, 0.37821829647936533, 0.17541721028812185, 0.17675654442419564, 0.18423968835207327, 0.17287236016336516, 0.17906229955995645, 0.191867076992849, 0.17488905268578292, 0.18728525294626597, 0.1801122220040997, 0.07842564100627714, 0.09598407582014168, 0.09562919387451385, 0.08167369263761826, 0.08759643905661141, 0.0853943116738719, 0.08678467366499987, 0.08113096510727669, 0.09315042408520624]}, "mutation_prompt": null}
{"id": "1464fe24-db3f-4c53-8526-1b73c2125906", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation.", "configspace": "", "generation": 47, "fitness": 0.2091965277832529, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "652aeb58-35be-4d9d-8c52-452864087a5e", "metadata": {"aucs": [0.48062003160336686, 0.49097607473030236, 0.4839047319397649, 0.46940686183467417, 0.43230250316874985, 0.4992736466512001, 0.43421533948400104, 0.41337125225460336, 0.44146161989924915, 0.04464822376254873, 0.0005014961690538167, 0.0005929790770428101, 9.999999999998899e-05, 0.017833070872851353, 9.999999999998899e-05, 9.999999999998899e-05, 0.00418882831675127, 9.999999999998899e-05, 0.11809528970718297, 0.10486896753012065, 0.1107148841962966, 0.09903843634779275, 0.11912531568802809, 0.06642916245824493, 0.10319728488241686, 0.1190677372131258, 0.13297738619852573, 0.1104742076222246, 0.10359183101011726, 0.09157957886379664, 0.08093787359003035, 0.08107186595685978, 0.09315727915137317, 0.08891292566062059, 0.09609870113807828, 0.09807431217137341, 0.9156659550140471, 0.949121673878814, 0.9024784153583556, 0.8455302048582279, 0.8661795703729719, 0.8309180122494718, 0.9026421290753599, 0.9198920953271243, 0.9159994373552381, 0.27745561065329727, 0.24543379075612481, 0.2611090985946808, 0.2666442233148455, 0.25359748586035946, 0.2307083427960901, 0.24918229773687428, 0.2620989995196916, 0.23946551746016376, 0.26932501620162996, 0.3057126780328193, 0.3123048869215036, 0.26041804458441575, 0.34523776623922964, 0.2571212820714821, 0.2281886971803262, 0.265915919658981, 0.2304776597540179, 0.13003046805473606, 0.12543195807981666, 0.1316422920981829, 0.09888766316964337, 0.11841080670776027, 0.12079415731843168, 0.13251148941684188, 0.12698994294722232, 0.1580789728679427, 0.17206293863496702, 0.13177461687168923, 0.13545387461780933, 0.14771726723990009, 0.18803862720788678, 0.14618977179636294, 0.12343813804099424, 0.134431970464846, 0.1512173154809614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01590764541404277, 0.011116614104991984, 9.999999999998899e-05, 0.007270083552814666, 0.00040673347794140113, 9.999999999998899e-05, 0.13303404741933522, 0.09277735927861963, 0.11566985920309525, 0.09487226854906072, 0.10511688034582112, 0.04094174953790786, 0.09013795524297441, 0.05844931420535382, 0.07759532172459915, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002910812121414308, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012940189693225301, 0.1041529077878871, 0.10819714465011254, 0.0955393889909848, 0.06231608546467815, 0.0817321612265145, 0.09904171345771773, 0.0998001424184275, 0.0942142814533905, 0.11086419568888795, 0.42499563088846726, 0.4105279621409279, 0.4599401790148475, 0.36222015569748534, 0.3999683509733277, 0.4393606418597287, 0.41670284186873774, 0.41195481870807926, 0.4093900108748836, 0.09147188263813566, 0.12018112382338697, 0.09181929087186491, 0.07727635204664751, 0.10576316326114588, 0.1359149554120449, 0.0949299633420877, 0.1133285438322047, 0.10112755580679655, 0.19022095049952037, 0.25637130935006647, 0.19896803523559203, 0.1603116703430687, 0.1715292211477517, 0.16578132406560087, 0.20282453444361415, 0.18946085961553094, 0.23865315278126276, 0.27895988766932145, 0.30382896522874736, 0.3048343088133709, 0.30939036505260453, 0.27283556286433586, 0.2663300870129687, 0.2435891089149509, 0.2898046868196349, 0.2558768146192655, 0.21917715651777592, 0.2037467599211613, 0.2391348281297886, 0.2205539977942519, 0.2341537542459189, 0.20397745017408675, 0.17317572923808677, 0.23038556403036203, 0.16213178390989746, 0.23006305438048436, 0.22427409716686508, 0.23930855606665713, 0.22109286938987338, 0.2249653030554124, 0.23720922718620296, 0.21993393231392167, 0.32405691375331536, 0.2347316836764849, 0.17165315191886366, 0.1853930769079125, 0.1915942420754263, 0.1886078245938756, 0.2104472622570034, 0.1793535522326669, 0.17939032245032305, 0.1826241694470475, 0.18994543061145752, 0.7127828837989674, 0.18536421658533064, 0.18521775146927066, 0.5650082811116457, 0.19823165832141898, 0.11399853869838339, 0.140658746825995, 0.15382333464154596, 0.16057024441669987, 0.46286489100152606, 0.21055308079733537, 0.4632876282789472, 0.37280156500379413, 0.16914446071114309, 0.3511164033396569, 0.1657007010207635, 0.16572649576662302, 0.26381179448218184, 0.17400695241411923, 0.19067823490668356, 0.17838140900889543, 0.18065274348432592, 0.17187633498231336, 0.17899120356047793, 0.19730315391015196, 0.17600986085278214, 0.18147567906903772, 0.08322002297735054, 0.08673769957267019, 0.08773494970888829, 0.08695406364547875, 0.08958347787824328, 0.0885760582393208, 0.0934484433589221, 0.09856462989328174, 0.08482481046301671]}, "mutation_prompt": null}
{"id": "0a9bbe32-7cb3-4081-963f-6f0198a1292d", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.2:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.1:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 4, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far.", "configspace": "", "generation": 48, "fitness": 0.2113594474081232, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "1464fe24-db3f-4c53-8526-1b73c2125906", "metadata": {"aucs": [0.45247871244991333, 0.4553525104493674, 0.45213388579257796, 0.4447729547457817, 0.44887630644674126, 0.413870437500953, 0.440697930115584, 0.40863619197380185, 0.4459867229758633, 0.018960187234637882, 0.02657979336835381, 9.999999999998899e-05, 9.999999999998899e-05, 0.034962186403044826, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12344782094362983, 0.1042686377987162, 0.106455594563299, 0.09618407718762778, 0.08852538785341824, 0.09949155021276457, 0.12413271073676024, 0.1038162261308695, 0.09513909559751321, 0.09088173670416833, 0.09927996996219823, 0.09508620946525648, 0.09606693562663282, 0.08215658862028064, 0.10668994999940518, 0.12204499526432433, 0.08514243881208627, 0.09425608232704163, 0.909963770829828, 0.9421165394696984, 0.8934798437016095, 0.8935045480495297, 0.852962803912783, 0.9239375336346443, 0.9310509169255442, 0.9318536246254512, 0.9135670713581808, 0.2644747004673714, 0.2649325847131434, 0.25222507323370047, 0.2511518840668878, 0.2514348664176058, 0.23085608101180766, 0.2451098321169054, 0.24089408691062875, 0.24717714822510461, 0.23550515235833536, 0.6290948207096247, 0.30438632578018043, 0.2924346854351264, 0.2022113320152733, 0.2031704193627787, 0.2691352390159133, 0.22539655781388868, 0.2950980743402497, 0.11270419277289401, 0.17281767214909305, 0.11591787999211445, 0.1057259742759119, 0.15462504831339452, 0.1189381248438991, 0.1326903264886823, 0.1238661089449834, 0.13105864755648977, 0.13463784655366418, 0.15400335957025568, 0.17153259186706638, 0.15594157614904014, 0.15056519302420568, 0.13497036410414676, 0.1353750304279553, 0.16052189600794464, 0.12693548364455853, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05223287724035364, 9.999999999998899e-05, 0.0031746558167853323, 9.999999999998899e-05, 9.999999999998899e-05, 0.015164104515081767, 0.1285813610768448, 0.05105501860814654, 0.12147649982097641, 0.09157942882149905, 0.03212904439628361, 0.027353511182302448, 0.16243200780305922, 0.04990443610477524, 0.08448457191417058, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006969866972138528, 9.999999999998899e-05, 0.0015812642541088717, 9.999999999998899e-05, 0.10828784994509932, 0.1063159749379411, 0.0768784817148539, 0.06924612471297875, 0.12404091835604958, 0.06965422841787405, 0.0925983678787945, 0.0878182363960528, 0.0813974145698354, 0.4363200488722877, 0.4088699479561887, 0.40495000875570475, 0.39746396672248296, 0.4084854829266171, 0.43266869471472547, 0.42748499669307705, 0.4251836204086583, 0.404472172915754, 0.0948588903148071, 0.11639238441785149, 0.0899325122628768, 0.0952373560633063, 0.10913928466889866, 0.12616385951224474, 0.09212442316786473, 0.1362495423823319, 0.08521685495523346, 0.19062378470669872, 0.25303606959457514, 0.13561182287646767, 0.17856037559455107, 0.2542153823508966, 0.1480230499511206, 0.19709048473903334, 0.16121464579338773, 0.1617385080962338, 0.255391233785762, 0.28463335389208266, 0.28501510832462473, 0.3121865861789439, 0.29027645767609356, 0.2827491696009198, 0.22156770983873275, 0.3051556007474385, 0.2834617934866811, 0.24326145749572448, 0.23214545513165663, 0.18915070103503018, 0.20499962166517494, 0.22184503410226197, 0.23784816173513623, 0.1876249813410521, 0.21558277059629216, 0.17003293023106003, 0.26371370736868094, 0.21422970710459144, 0.2544655202464955, 0.21784003372085692, 0.2292371684935428, 0.22341558154766472, 0.23281666798676137, 0.23056588854901683, 0.23824212152325086, 0.20509351840700174, 0.18385211615734953, 0.17481972185740924, 0.21490598012986017, 0.17954616311411353, 0.17952776299404583, 0.19020180231908357, 0.20146577726580694, 0.18099775774983173, 0.12798426867928936, 0.18620942800972196, 0.18579012369580838, 0.5827143678970677, 0.1982953806030654, 0.16388684944481124, 0.14111349373304805, 0.5085815909422459, 0.5462707147466151, 0.38926459049569684, 0.16840739173972286, 0.39676533043459905, 0.42727159825212657, 0.2004394156992696, 0.16658872878301467, 0.3258251394769761, 0.2904821907259786, 0.3968933734964941, 0.20286978212721973, 0.18607798644724027, 0.18232984173411226, 0.1982751122131312, 0.18520239386726622, 0.19763075362780824, 0.19846988931043308, 0.1849148179350898, 0.17694274749198013, 0.08861677929428458, 0.08757825314494183, 0.07065355891748948, 0.09769765860717727, 0.11065295654929519, 0.08153399050421539, 0.10777825931362384, 0.09386653528929234, 0.10426202647876448]}, "mutation_prompt": null}
{"id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV1:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV1(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV1", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate.", "configspace": "", "generation": 49, "fitness": 0.21839453189541005, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV1 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "0a9bbe32-7cb3-4081-963f-6f0198a1292d", "metadata": {"aucs": [0.5161665562055474, 0.46863754195075047, 0.45686086387716884, 0.49643964797520734, 0.4315166841061766, 0.4463537736575277, 0.4496693691406971, 0.4554736267806634, 0.4248831292984153, 0.004996650854338092, 9.999999999998899e-05, 9.999999999998899e-05, 0.012896683461991798, 0.00386242523487923, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1314262657220292, 0.10349911568779657, 0.10701401924105791, 0.11325285247684713, 0.10895030370487546, 0.11105080485389007, 0.1199423743379201, 0.11082829971608898, 0.10835161606385102, 0.06812524466401282, 0.10396893689007525, 0.09590489013554326, 0.08384017889595485, 0.07793515059729783, 0.09039411309799872, 0.09448593441836106, 0.08127790697845216, 0.09354696977290111, 0.9149437159038689, 0.9463388479092292, 0.9108893139050334, 0.8969920244089592, 0.8950541175293093, 0.900342531086881, 0.9275784881873064, 0.928751963941111, 0.9156287233669277, 0.23953076011221064, 0.23843008141702426, 0.24238509076837522, 0.2487991344659568, 0.25718683020020605, 0.23384254485983458, 0.2538639946863792, 0.230898883660127, 0.24699672667467454, 0.34718347933433524, 0.5620882322612071, 0.3188607378266364, 0.26703628686669056, 0.5669831037903761, 0.2003174553443342, 0.32265442278633394, 0.22159257778049657, 0.34323837006394775, 0.12633107658741882, 0.11775727184740936, 0.1219455635683957, 0.15370240559454906, 0.19478386007495319, 0.1752652400456225, 0.2095662360297892, 0.1945944178763801, 0.1296016797541797, 0.15040927278604654, 0.15939601729046315, 0.14726989361253295, 0.15106261494300965, 0.13094747891514147, 0.14928307363484616, 0.13942849685452274, 0.14993500134283877, 0.17091464547089874, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012883290007943415, 0.038772674189703316, 9.999999999998899e-05, 9.999999999998899e-05, 0.024860245703190564, 0.0059993218546611216, 9.999999999998899e-05, 0.17294596243341565, 0.04334270476019886, 0.12039701793598212, 0.06842739471425552, 0.0724790421596404, 0.008010654468166511, 0.14082663297287945, 0.08609158104856507, 0.027724534758409747, 9.999999999998899e-05, 0.0019041304058730057, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016300196988678906, 9.999999999998899e-05, 0.10306238773447984, 0.13640264059954021, 0.095116314162486, 0.07776311133195246, 0.11148381500604154, 0.09290302531644479, 0.11112461682253105, 0.10860408182431225, 0.12101996516164926, 0.4702425975644683, 0.4342864478496944, 0.42184368652632465, 0.4087485366177336, 0.4157787217995912, 0.40039747656557667, 0.4428398148394139, 0.43278248890715165, 0.3933062447462814, 0.12376727292636513, 0.1104207526338209, 0.09008600339087736, 0.08940601391046543, 0.10548075063669127, 0.09847752232086937, 0.10382837830311287, 0.13787555053702671, 0.10371149747944819, 0.1464609151097941, 0.2471315581421546, 0.1301924556941274, 0.1752734914938323, 0.18305714766003756, 0.19604618874051138, 0.17180286184771754, 0.14039362638510777, 0.18943444043613988, 0.2805592982962185, 0.3146128285991272, 0.3076468466003597, 0.2806600132288273, 0.2652824930249973, 0.29532169317493306, 0.29428369945558097, 0.29905724623901797, 0.27890401803805265, 0.20191842740513755, 0.2206934528999549, 0.2010551004885549, 0.22828781954723376, 0.2120810622503806, 0.23264969032131488, 0.19357491884086686, 0.2233239195032216, 0.17088789018808204, 0.22656433312006719, 0.24376289347299218, 0.2615811191601396, 0.28598625631646246, 0.2444659000490802, 0.26495452009176956, 0.22551057173720312, 0.2201260443005697, 0.20335547304146062, 0.18818233954969688, 0.18830803559355547, 0.18746919832629183, 0.18494089832133975, 0.1895485426180915, 0.18299821010092743, 0.22462223841510431, 0.2642964937036125, 0.17744376377944993, 0.18445692975113526, 0.1863874209495643, 0.18638656068666615, 0.11747024595346434, 0.19781932440241856, 0.1454011874861657, 0.14121775269510506, 0.5943487682775936, 0.607378074248494, 0.6180626766097557, 0.45505717626775, 0.39937593592580967, 0.43092084864210023, 0.4430592536642147, 0.16682127380804157, 0.16632441313996604, 0.34793110106826475, 0.3766321383693363, 0.1895858302765414, 0.20577758536257085, 0.19384221685336622, 0.18005388736037764, 0.18471065011035648, 0.18808126837065953, 0.18213404534153754, 0.21214562941366866, 0.1728856302377504, 0.07520755994165751, 0.08638043654742145, 0.08673797564716246, 0.0829196702417998, 0.07622665878481216, 0.0923906643647433, 0.07628001798312323, 0.10600531051356665, 0.09267825801847307]}, "mutation_prompt": null}
{"id": "1592d77b-48c1-4072-bda5-268e43543ccd", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.restart_iterations = 50\n        self.iterations_without_improvement = 0\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def restart_swarm(self):\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.iterations_without_improvement = 0\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                        self.iterations_without_improvement = 0\n                    else:\n                        self.iterations_without_improvement += 1\n                if self.iterations_without_improvement >= self.restart_iterations:\n                    self.restart_swarm()\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and an additional \"Restart\" strategy to reinitialize the swarm when the global best fitness does not improve for a certain number of iterations.", "configspace": "", "generation": 50, "fitness": 0.09847850227242226, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.07.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.19420901404154645, 0.2386973649179196, 0.20283716434443688, 0.2189248700023264, 0.16860826714143862, 0.1934018748341335, 0.18715960812384314, 0.1736084807457844, 0.17290238824699733, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07542185270481772, 0.050717833448093, 0.06927770681276468, 0.04543448678934514, 0.03756876635090134, 0.046131431957587066, 0.05218910065761351, 0.04629170706970709, 0.055812884820992115, 0.03837157524746149, 0.05042166934661363, 0.05985843685945669, 0.04189780110497088, 0.036209452458254576, 0.0464009714397966, 0.037289507456389814, 0.030902940128203604, 0.02853054686028933, 0.09754528553078345, 0.08495531389435895, 0.08340495424451089, 0.07809625291806666, 0.08478902371471508, 0.06829041282165405, 0.07431451094639996, 0.07992300854994594, 0.08584860770419489, 0.07929646157595394, 0.09136628819249504, 0.11038665430653072, 0.10865497240007171, 0.09052973203684489, 0.0919014741262254, 0.10290536921988092, 0.08084981082744092, 0.10307032407981265, 0.14275400180504016, 0.12983127216685975, 0.14607175544468387, 0.147756451394211, 0.1169843078066295, 0.11902434315902444, 0.13240248025728885, 0.10781378141937226, 0.15031253912243114, 0.0017913671885914084, 0.06461022919692483, 0.013464841389155713, 0.002207090415962787, 0.006592866345040416, 0.03571773872375994, 0.022788485991489194, 0.0029166364831105795, 0.018007029238797045, 0.021831060866757235, 0.02102940312935353, 0.007283489802524801, 0.04489647932521823, 0.015038119137908534, 0.051337437585124435, 0.03936135535761609, 0.054192345344363124, 0.009081846885956701, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07613946419741369, 0.03810383811040541, 0.05281777215859107, 0.07136872887290424, 0.058841113763054675, 0.049882018183596166, 0.05460705838852187, 0.049897309121210265, 0.03802056167386869, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013419488622358089, 9.999999999998899e-05, 0.0020504594769393814, 0.2479640989780013, 0.24963259700222573, 0.22329159722547565, 0.2000196653224261, 0.2000938703927504, 0.2200979440629478, 0.1957130752443471, 0.21234991993041752, 0.22452735752226338, 0.06343323735102935, 0.04852110935081477, 0.059138586204359855, 0.044967223324007155, 0.05735299748644107, 0.04104210509401984, 0.04986997611427668, 0.04745910429050182, 0.05659750228859961, 0.11874690151911305, 0.1299805032728476, 0.13651101422550405, 0.14403817994196, 0.14825392762956924, 0.1487688304577861, 0.1445293327125461, 0.1382370607330633, 0.14741554865891848, 0.16597372399137234, 0.17025773126102706, 0.17860146958784806, 0.19282689103495498, 0.17760548502039053, 0.16859692689966888, 0.1840422547764191, 0.1872603958284792, 0.17643013015050635, 0.12499616000130631, 0.11183913192931139, 0.11303276979855836, 0.14503977312688754, 0.11465137842683237, 0.15777667729839906, 0.12886649046771637, 0.11476892775152159, 0.13171911605647624, 0.15133919541083474, 0.18440654187732974, 0.1714464771775278, 0.17721467692039683, 0.16996631559905906, 0.17769368699788324, 0.16791017924263318, 0.18265711962798192, 0.17166348492449124, 0.15622605406986823, 0.15176369152857172, 0.1421886057869175, 0.16288072998558345, 0.15394383101002207, 0.15116067115274745, 0.1490494008144817, 0.15439514415578837, 0.1616698594322814, 0.1854971345703681, 0.19339716982969424, 0.18580889755778385, 0.16516840526658838, 0.16569346796039408, 0.16885424824641848, 0.219223714213297, 0.15971190951801018, 0.19210838075572323, 0.1927622020528329, 0.15561285769407873, 0.17381636778216125, 0.20705201751021052, 0.2747164383199443, 0.1503865849587479, 0.14908920229144518, 0.22145415741394137, 0.21923053819636817, 0.17878902745554992, 0.1704654777416179, 0.17387710574349824, 0.18818616387073694, 0.19357672791796454, 0.1866310533760943, 0.17607928542064344, 0.18784744876928694, 0.17509878399837686, 0.06093798151528751, 0.060484758646553005, 0.06445401462554423, 0.06278862155796783, 0.05348490243207993, 0.06590577253077812, 0.07028537297527349, 0.05301396978961803, 0.0605992343264099]}, "mutation_prompt": null}
{"id": "2de102f7-ca89-4ca0-9917-65ce5fd50e66", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.memory = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.memory_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def update_memory(self, position):\n        if len(self.memory) < self.memory_size:\n            self.memory.append(position)\n        else:\n            self.memory[np.random.randint(len(self.memory))] = position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    self.update_memory(self.particles[i])\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                        self.update_memory(self.particles[i])\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                        self.update_memory(self.particles[i])\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Memory-based position update\n                if np.random.rand() < 0.05:\n                    memory_index = np.random.randint(len(self.memory))\n                    self.particles[i] = self.memory[memory_index]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                        self.update_memory(self.particles[i])\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and a new \"Memory-Based\" strategy to store and retrieve the best positions found so far.", "configspace": "", "generation": 51, "fitness": 0.20884653417483956, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.45084135146560467, 0.4467905055514807, 0.43630970399853786, 0.4388224448454443, 0.43699781601229093, 0.4730403333959756, 0.44963751340168867, 0.4609962832722373, 0.48057296809027816, 0.015116171790651944, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003138479271527439, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09593086711043475, 0.1221579882762237, 0.11390049657248669, 0.09912965299335796, 0.10174047670243813, 0.09659071639537342, 0.103568984289654, 0.1401628113317389, 0.1202306849717315, 0.08893763475747996, 0.08716832242885941, 0.07882912808980913, 0.08995964455592997, 0.08061484549737707, 0.0738639431467567, 0.1092090920622355, 0.09208439942505242, 0.08205704516192402, 0.9144293312921354, 0.9432194780049891, 0.9077235764910845, 0.8582844051728765, 0.877087777742078, 0.8734543450802479, 0.9344728816966578, 0.9203343687040271, 0.9108476100173772, 0.25273664801091267, 0.23067677037298495, 0.25584409404286024, 0.24227250151307733, 0.23905858602543117, 0.2195118927894817, 0.23963761439674625, 0.23190881691488308, 0.24387084764278222, 0.33037819945592806, 0.22118289830732163, 0.2227638631536485, 0.2645324999669404, 0.5389029859248102, 0.3506283662404529, 0.2846080168551509, 0.2253519000423897, 0.2618199727423801, 0.15113267266504193, 0.13065632862107668, 0.13753151425635757, 0.0022501652550045437, 0.12615201248895047, 0.12624730302523335, 0.1492942836715545, 0.16556801685750577, 0.12271234937818243, 0.20724883768058522, 0.17881898818267694, 0.12572312148513898, 0.143900668373939, 0.13638246607274318, 0.1261740726111873, 0.1391668699765738, 0.15148632093993075, 0.1656547800487802, 9.999999999998899e-05, 0.006083659550638165, 9.999999999998899e-05, 0.02960932824074103, 0.00011151443704415787, 9.999999999998899e-05, 0.00011792495930529334, 9.999999999998899e-05, 9.999999999998899e-05, 0.10754945291203444, 0.03810353337339434, 0.11430023804467415, 0.06731687807247566, 0.09090221322507785, 0.051077444399191485, 0.09083728912594413, 0.048165179795261026, 0.09538883828835465, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004215955852712061, 0.002524877284352245, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09283755011123362, 0.12281412030226146, 0.08070475973117952, 0.11116549798670516, 0.07897586851677474, 0.11051423251035064, 0.09600958973945617, 0.10340708067162219, 0.09521783673242312, 0.36138205716278904, 0.4041364884423122, 0.3859781892314441, 0.38400753775553975, 0.4017686193253768, 0.44544364970317596, 0.419811870356228, 0.4431944471116471, 0.40864088907481955, 0.10330264554843527, 0.0871241575959475, 0.1083562238484701, 0.08821084352906872, 0.10009432904872373, 0.129771753455032, 0.10683064575819756, 0.09632104690435916, 0.0840404963457746, 0.17091839866102787, 0.16813096234962122, 0.1372645978624739, 0.2531994218752268, 0.17451894413850277, 0.16902520850832736, 0.139616522478763, 0.1591861737838688, 0.14859922461995723, 0.31260894465704725, 0.2849346258839338, 0.3073773033231021, 0.2647851719225317, 0.30241895142104036, 0.28120316515237453, 0.26634908573719696, 0.30202247669892035, 0.25401344639667334, 0.23765122147369955, 0.20003135108914571, 0.19927080806635344, 0.23431856354129255, 0.21982836563795638, 0.2006383597084419, 0.21372894230470485, 0.24412373584443592, 0.1931204153170727, 0.23230315009104208, 0.2271440993741054, 0.23734363063896435, 0.24152529883331686, 0.21296977306887732, 0.22751242268895233, 0.2412369164657815, 0.22509220121178675, 0.21689697913852612, 0.17679721272524962, 0.17982889912351618, 0.18382734095854736, 0.20083765726749092, 0.21190533251482635, 0.17992299656690447, 0.18536631204063037, 0.19883361506127928, 0.17735216258038544, 0.6413214542820376, 0.1857941755033955, 0.18573535348858194, 0.17083325120077242, 0.19877570927122856, 0.19459509552023457, 0.14925885519118187, 0.5565720985156549, 0.5996115264608444, 0.4862761943586734, 0.2087754211694678, 0.3546914837095665, 0.34578993121959256, 0.20478522836112611, 0.16718694808082457, 0.16729921678865578, 0.1592230795309828, 0.2719278149072146, 0.17094223729373192, 0.16701170215669736, 0.1920705017397678, 0.1850470330629892, 0.17682213629058063, 0.17997150283075403, 0.1927406276942487, 0.1815915274863149, 0.1822870902404753, 0.0923302452031588, 0.09410026483523293, 0.1234628123964796, 0.09836208227067944, 0.1040299802491953, 0.09864486155599239, 0.09606788270574884, 0.092525670436441, 0.09050191783770101]}, "mutation_prompt": null}
{"id": "6ce6821c-6983-4a08-a16c-834c6d853a6e", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.probability = 0.25  # probability 4\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update with probability 4\n                if np.random.rand() < self.probability:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                else:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 4, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate.", "configspace": "", "generation": 52, "fitness": 0.1838240251224797, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.34350624681669806, 0.34822519983405353, 0.39067549626181497, 0.3045237644580516, 0.31742371330823893, 0.3273550867245958, 0.31952055880490826, 0.35045797650430466, 0.318670243840395, 9.999999999998899e-05, 0.0006575387420277856, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001466926038816041, 9.999999999998899e-05, 0.08860767534039493, 0.08431144718170547, 0.0814346555415113, 0.079596970499342, 0.0950350620560968, 0.08961684080149646, 0.10601547841513914, 0.09960354100851654, 0.12078807087961563, 0.06957297888838676, 0.0914110232635501, 0.07826920612087196, 0.07837122019810927, 0.07537695613568829, 0.06090763251733611, 0.08283594776382819, 0.0810041294913344, 0.07420248713758304, 0.8552159410165812, 0.8958196789481787, 0.8810593087614011, 0.8487840052545466, 0.8311886281702578, 0.8007908215947295, 0.9047921007691151, 0.8709061125281211, 0.8931057654031693, 0.20392899175765833, 0.18146708224113528, 0.17672668657567991, 0.20225474051602488, 0.1793586190522799, 0.17883982814454902, 0.18272389721703086, 0.17921353120438366, 0.2247027754785419, 0.2738479957490425, 0.27159502138507796, 0.20826419780789407, 0.2879780010213032, 0.23605114120508575, 0.24699140167698097, 0.2078218371776024, 0.2033815199708664, 0.2373836901791031, 0.11900501517135131, 0.10958480583634389, 0.1353532045511865, 0.11904331976930116, 0.08718096632934436, 0.11700575314133221, 0.14924468394410684, 0.08509910474894422, 0.1265717297956378, 0.11550007593174683, 0.09968155075651575, 0.09703947870630014, 0.09760305786568624, 0.1047686032601075, 0.1221956953533263, 0.10809428794662068, 0.1069822275910447, 0.10976868201564538, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00661043819042384, 0.00015063861889796915, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12285752879173384, 0.09366558850837992, 0.1186098506716049, 0.07843949113078363, 0.07332784218884936, 0.06592127478747967, 0.07410910375141888, 0.10942475700659904, 0.07902565598534728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.065513300304191, 0.059533752167038934, 0.06476147238683438, 0.0471886555236275, 0.07420198134933198, 0.07766806551069116, 0.05901673824439713, 0.059953560025709174, 0.04718181214942174, 0.3569338329375118, 0.3484332032622274, 0.34542986814354404, 0.329352391005182, 0.3182460483071966, 0.3839456159503597, 0.35538669573428616, 0.3359232873716619, 0.3397281029347893, 0.09538291164256296, 0.07684576088318884, 0.10680584316107145, 0.08797657963065808, 0.0852725216233865, 0.08701053974139628, 0.09025491825650589, 0.0858739465714281, 0.10436012847441611, 0.1390199212907557, 0.1483899155474242, 0.1399013954284115, 0.15829049288901864, 0.15292750732835103, 0.1240247125766264, 0.13640702590494225, 0.16705869000168783, 0.14978897703651983, 0.22999850337072836, 0.21072017802813214, 0.2777288448300532, 0.2326099838083645, 0.246680913093553, 0.26113133144750256, 0.23605302925248828, 0.257708691233713, 0.23829610162048154, 0.19023005338589516, 0.1719072499374743, 0.19932927939138945, 0.17212574849811224, 0.19724196028981733, 0.17895555201379842, 0.16359993003405304, 0.17471491401456352, 0.14409933426229748, 0.18566455122269565, 0.20221177835547433, 0.21589740717011496, 0.22365258019222023, 0.24018178230783582, 0.21090642682430538, 0.2212526672312427, 0.2215349114392383, 0.2177687691764022, 0.1669713092121412, 0.17444052814335176, 0.17371942875008795, 0.18721955562636872, 0.17727297221897576, 0.17309429127082598, 0.17796711447407088, 0.17055314915551567, 0.17185548005730744, 0.17105896309872715, 0.17770430072120036, 0.2912733333556602, 0.430698531127807, 0.4019280315136765, 0.18483982407300992, 0.16724789232503845, 0.1668327949608014, 0.43908168739872044, 0.38879765114191067, 0.3659996370202978, 0.3689528409783486, 0.3308056152777228, 0.2723262885613167, 0.17154992389733148, 0.3096841291268152, 0.26479775484407586, 0.2742050419547801, 0.1714474124911065, 0.189158429302128, 0.18440606341050303, 0.1758826392265832, 0.1876097851593831, 0.17218284210618362, 0.17861217472222013, 0.18891899968460868, 0.18272922815525083, 0.075680367603842, 0.07541694661716847, 0.08607606269085788, 0.08540791587560148, 0.08783951335313755, 0.08494522504190916, 0.08259502615500425, 0.07699646786277914, 0.08521180525635141]}, "mutation_prompt": null}
{"id": "7e505539-4e33-4829-bb9e-3a02f3093abb", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.crossover_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def crossover(self, position1, position2):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        return position1 * crossover_mask + position2 * (1 - crossover_mask)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                # Crossover for enhanced exploration\n                if np.random.rand() < self.crossover_rate:\n                    crossover_index = np.random.randint(self.swarm_size)\n                    self.particles[i] = self.crossover(self.particles[i], self.particles[crossover_index])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and also incorporating a new \"Crossover\" strategy to enhance the exploration of the swarm.", "configspace": "", "generation": 53, "fitness": 0.21089092432640008, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.469256609760788, 0.44733692588467733, 0.4694632756302338, 0.43548742868165546, 0.44828363954236805, 0.4355775048312098, 0.43155855589744174, 0.44504531472449194, 0.45483607036593143, 0.0002880994073768406, 0.025287967387117027, 0.002644108766472364, 0.024346833707485138, 0.03335411493247997, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11459248100608399, 0.11938542594487922, 0.12406427044737534, 0.1158738409271286, 0.07708073166169183, 0.0766663704817716, 0.1279169743151326, 0.1922455573460231, 0.1141944847614017, 0.08624986009544777, 0.07063749253080964, 0.09342146742842328, 0.08731861150439435, 0.09155126672168934, 0.09217975361555786, 0.1084249137152905, 0.0900016035765624, 0.12114614493250808, 0.9079531053286631, 0.9360532582728225, 0.9129930037877115, 0.8603873569457734, 0.8927714115276933, 0.8898306114522616, 0.9351891210975732, 0.9240908558379307, 0.9155256446301464, 0.2639635912286623, 0.24801588383563777, 0.25112876521698, 0.2606916348751215, 0.24412668396216775, 0.26195564142906036, 0.22826285274335878, 0.24418992853714017, 0.26377210629744763, 0.22734735861304745, 0.643627258822167, 0.3336625867684726, 0.2362566723965821, 0.3554950727982511, 0.2502962413621803, 0.23610006999664068, 0.23309034031272902, 0.22532227004231986, 0.139888710764292, 0.11889389410274365, 0.12078844738770422, 9.999999999998899e-05, 0.13535313788551817, 0.10900479873077307, 0.15751074237021911, 0.1648087218707922, 0.14192715968565794, 0.13155681702105815, 0.1443832439041033, 0.13627570105433517, 0.12068390852718436, 0.1474103280797655, 0.14594748157201398, 0.13480092609912186, 0.17891517238513766, 0.14533687571547182, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006665246633852373, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011239276172539947, 0.08766168949583297, 0.05016687486228488, 0.1698687087168086, 0.0871352098656254, 0.08368903147558471, 0.04739393987732232, 0.09365503503908734, 0.06389510975161516, 0.06817393039498343, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004606594556779253, 9.999999999998899e-05, 9.999999999998899e-05, 0.12092149040967293, 0.098213742358367, 0.08555097013057478, 0.11325510624291169, 0.11599544105060555, 0.09791169567983193, 0.1147094884897899, 0.10632304648036406, 0.07855460777971657, 0.42624006266168, 0.42747954449379444, 0.39944468305959613, 0.3928012844958604, 0.41680144862209245, 0.39795390425501387, 0.3975693523345841, 0.39960702440286533, 0.3897061376841183, 0.09801280983551064, 0.11666877613249849, 0.12286260773147029, 0.10489740496387145, 0.11628385080191694, 0.12839620880704317, 0.11132454375008383, 0.1097543320244233, 0.07806994654416122, 0.151455664563241, 0.1714630149869023, 0.13131736871360844, 0.1822990120538157, 0.1637771424324168, 0.14764378755337837, 0.15546086731552855, 0.1865400869439966, 0.17755871583599914, 0.29904551518645983, 0.2980986314675782, 0.3027201481476486, 0.277348744366103, 0.2607915353799487, 0.2979575765522565, 0.26472528694196285, 0.3083944747101285, 0.2921067265898344, 0.22411354103635484, 0.1870840594758718, 0.26429843335993497, 0.2295567707382059, 0.222899151215611, 0.22225755010663428, 0.2037239425511045, 0.24151669540850818, 0.19354471524933337, 0.24065848541690615, 0.23546768649385985, 0.23538662838694602, 0.24449183233743121, 0.24660516331689364, 0.24093078678605584, 0.2336858397357906, 0.22143016590204, 0.23799518337417036, 0.18059830328204085, 0.18136950928902174, 0.19780178671244342, 0.199949805715242, 0.211579378034066, 0.19612051873140768, 0.20582816257759662, 0.17775454925766443, 0.1774305830542695, 0.18462318379574805, 0.17438227130416495, 0.18441142707629998, 0.11751574829915612, 0.19821251649899252, 0.1669140876351537, 0.14102956363192165, 0.5034569615007987, 0.5665608745586787, 0.5303829630304462, 0.21061496679513658, 0.5469367847874449, 0.20619755812522822, 0.4054941655972649, 0.16809268386330367, 0.16575227229271228, 0.3829758154700582, 0.36409209525058484, 0.19796332285965523, 0.20353607810598262, 0.18036290132367971, 0.1827095492641776, 0.17487838786871468, 0.19404511623972243, 0.18040610110690491, 0.18049911481004277, 0.1825321509068184, 0.09724352279183368, 0.09360610080276632, 0.10059818199213, 0.08830576186444128, 0.08902337841282804, 0.09328752097580872, 0.0810543797463954, 0.09610699812864953, 0.08920243715724463]}, "mutation_prompt": null}
{"id": "9ff2d43a-bf30-4fa1-b44b-253e6ba992bd", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update with probability 0.8\n                if np.random.rand() < 0.8:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                else:\n                    self.velocities[i] = 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 8, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate.", "configspace": "", "generation": 54, "fitness": 0.20993487839212915, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.48750400346732303, 0.46173581276167186, 0.4807082395831461, 0.5096651422599217, 0.43677602623912737, 0.50845536508513, 0.4745448635191004, 0.464089512523735, 0.4998613113148783, 0.018993203750317655, 0.003941782454655929, 0.014169588104560926, 0.0011243171073125335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12923425641237207, 0.11304060349080447, 0.16134030469652172, 0.09294205848546899, 0.11243700654460154, 0.12200415856604141, 0.0852920863153096, 0.10466949815961546, 0.10811739702003087, 0.0736288595109631, 0.08726082571472749, 0.10328328803112674, 0.09820498282140488, 0.0898159788608558, 0.09660973835099007, 0.08578323212438466, 0.09130009482301171, 0.08833356062403475, 0.9139919720784135, 0.9299162270239842, 0.8843607621260159, 0.8509234158633354, 0.8895988649395496, 0.8561048102692037, 0.9102681739921535, 0.9230589887026595, 0.9086034248030312, 0.2599677625714829, 0.2568951966152482, 0.24082599751578626, 0.24395236940046217, 0.25230509989006356, 0.24804043159352007, 0.26540547502407996, 0.22073461708177333, 0.23654317109142786, 0.7021537218410483, 0.3110186529203339, 0.2988227987585953, 0.27212470738160854, 0.25947827949875724, 0.20763855706808865, 0.22052053382388948, 0.2318174201556471, 0.3398081859890474, 0.11939553605875886, 0.11736899491477193, 0.13678681488646616, 0.09359530350864098, 0.13905825330372112, 0.13952520730008, 0.12548603257864976, 0.14322843833569165, 0.1698212490007276, 0.1590286058721595, 0.16550413492325933, 0.16099253303494188, 0.12530252972165457, 0.1746691723877144, 0.14287069581584633, 0.16991973031512675, 0.1247953579367258, 0.15576977761166777, 9.999999999998899e-05, 0.010983107931082148, 9.999999999998899e-05, 9.999999999998899e-05, 0.004750697087650191, 0.002940680656513539, 0.03210787551105532, 9.999999999998899e-05, 9.999999999998899e-05, 0.10968776100681021, 0.03925513829838945, 0.1237374969039855, 0.0821894083683039, 0.07988607021217375, 0.022216659744510925, 0.08913066055895291, 0.07186687049026264, 0.12804205805438995, 9.999999999998899e-05, 0.004579145469911561, 9.999999999998899e-05, 0.022251242764695367, 9.999999999998899e-05, 0.00034879441564061864, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006495185460058117, 0.12332084114524622, 0.09634123624165258, 0.1366871523620593, 0.1139304099129198, 0.10840193035569223, 0.09296772640979767, 0.1140418912990443, 0.10633401445931046, 0.06687025108346811, 0.4246119738492493, 0.4183003651322029, 0.4201297928201331, 0.40880913875808655, 0.4173820977900943, 0.3986375106618478, 0.4276059567616577, 0.4193843552605342, 0.42240532791136465, 0.09909942817369011, 0.09085508464118153, 0.08352616097782373, 0.12220450901672686, 0.1271708496393138, 0.13306292009683962, 0.13656072897375215, 0.13095250656935564, 0.09658205519278873, 0.14907974090990683, 0.17058533167772838, 0.14243160333742222, 0.16767176086956515, 0.1892274221349044, 0.18602737580476236, 0.1635990070328247, 0.17374559003224554, 0.19012609296857452, 0.29352882250782464, 0.27009058033642586, 0.29167749710383983, 0.2821033943453033, 0.29773280194773455, 0.29155576348485124, 0.26280445547483977, 0.27799460445152924, 0.2550493611313662, 0.21330944568916843, 0.17989258936106456, 0.2536677374792573, 0.239663345160672, 0.23196564179166812, 0.20774643660647196, 0.18682140105085987, 0.20349504370605564, 0.1875417786656569, 0.22844411645302576, 0.23716827309471733, 0.21866475271965113, 0.2247810513337548, 0.2442858988669222, 0.2617615287852346, 0.23322499817127884, 0.24806021317156346, 0.22728760790764813, 0.1848375321886382, 0.18588075742724453, 0.17950815728333214, 0.18315816260478834, 0.23791296519677563, 0.2099589141864897, 0.2058792357504542, 0.1787636398967294, 0.1912283013965308, 0.1281212789801368, 0.1855439018292887, 0.18693758313217534, 0.15189394447758875, 0.19773527626326426, 0.19537656045742935, 0.1414132863466795, 0.15395331746110474, 0.7217174082855263, 0.4316714596386517, 0.21045409309060492, 0.5295699032382533, 0.3987198597523969, 0.16531961271331275, 0.16683517180248875, 0.1652085877452264, 0.32705072383347156, 0.16782055167312593, 0.1975618308299919, 0.18181165532508714, 0.18186068634990193, 0.1917997603684699, 0.17411771059806846, 0.18230767856525265, 0.18260939033850676, 0.17801475234362807, 0.18587541139636066, 0.081808758871737, 0.06415259974654941, 0.08824697680543381, 0.08929020961481715, 0.08388933384902575, 0.08231923873050018, 0.08578880797943511, 0.08968666048447027, 0.09434453251951214]}, "mutation_prompt": null}
{"id": "260d1c45-37dc-49b5-85ec-c91cc6b7887c", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.multi_explorer_prob = 0.3\n        self.multi_explorer_num = 3\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def multi_explorer(self, particles):\n        explorers = np.random.uniform(-1, 1, size=(self.multi_explorer_num, self.dim))\n        explorer_prob = np.random.rand(self.swarm_size)\n        for i in range(self.swarm_size):\n            if explorer_prob[i] < self.multi_explorer_prob:\n                particles[i] = explorers[np.random.randint(self.multi_explorer_num)]\n        return particles\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                # Multi-explorer strategy\n                self.particles = self.multi_explorer(self.particles)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and a novel \"Multi-Explorer\" strategy to utilize multiple explorers with different exploration-exploitation trade-offs.", "configspace": "", "generation": 55, "fitness": 0.0931936911699918, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.24993897818514543, 0.2215803240196852, 0.21905191451619355, 0.11082126844547169, 0.12506885433265602, 0.1217994237384511, 0.12061690849105888, 0.1386698407733209, 0.12765465541064713, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0431703123407422, 0.04832315148463184, 0.045614756720620764, 0.05802225744399925, 0.04636884683672182, 0.04210622010251719, 0.03473034660127983, 0.025082588246164605, 0.014207325606492627, 0.04046361411911348, 0.05448096190154961, 0.05582957626161755, 0.034119004945679654, 0.04579653614640988, 0.046091876014651145, 0.030007222871439976, 0.030482054227716104, 0.03467581700363975, 0.0942073851890658, 0.04283549450955926, 0.0320108920017419, 0.09321590085564058, 0.03215933885147282, 0.05887547792350378, 0.06834737947011926, 0.04957217285241966, 0.05087501084799584, 0.08471903707505712, 0.04913160175761222, 0.0534607397406347, 0.02485138242309326, 0.03685905658276456, 0.03332129317581789, 0.05977215830780791, 0.013526531207016523, 9.999999999998899e-05, 0.17514753064689814, 0.1723918874760464, 0.19730491144319318, 0.09093265239031356, 0.18502575767007057, 0.15537459345654459, 0.07885077856204448, 0.07405972018499962, 0.07988054015880552, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00367015794749348, 9.999999999998899e-05, 9.999999999998899e-05, 0.02467917356883431, 9.999999999998899e-05, 0.12337805524361756, 0.11683052149565998, 0.11804591865727998, 0.1158664878855672, 0.1269212114332937, 0.11673248851777551, 0.11755235217544124, 0.13266284089110103, 0.10846586396522961, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05626900518351918, 0.04396445564044693, 0.044358270313283765, 0.04783418693197805, 0.0505586739777254, 0.020752996400178914, 0.011056248646616362, 0.01537977927714107, 0.06580643904456829, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2286057175451579, 0.21028385169704666, 0.1968707556941377, 0.1774699872495128, 0.15308892088239678, 0.15818146887531725, 0.2614881177131022, 0.2563423459943134, 0.2729555443329338, 0.02799718373082105, 0.02175037492163634, 0.02973002665634561, 0.04336502253137475, 0.04065212935862361, 0.0491347141661187, 0.04933552712209255, 0.05627928338662891, 0.04483199529908122, 0.14182741306001678, 0.11758212590341044, 0.12357912378159586, 0.12086113235011986, 0.11536676478415941, 0.13668714477107224, 0.15569272120288535, 0.15495883458801418, 0.13802785036344234, 0.14714830904974552, 0.1487005959270855, 0.13860830163485005, 0.19198501351682307, 0.19458483182713937, 0.20624853413334476, 0.14878210866534503, 0.14825907689886753, 0.14037718381065512, 0.12573154230523065, 0.08729960519876878, 0.09708772027046997, 0.14561250445907148, 0.142191306720868, 0.1669578342978877, 0.07808451329278154, 0.08804753362073348, 0.08711511942648575, 0.23093009332627756, 0.23660968253227566, 0.22448947956909993, 0.21986111157749633, 0.24826954701478166, 0.22493317547975644, 0.25679941266872, 0.2502634025516439, 0.25101015974365715, 0.15982328971193183, 0.16382176191853925, 0.16034084200622734, 0.156974699247591, 0.1613077039403692, 0.15764164072261488, 0.15437276291172786, 0.16011103891359357, 0.15687019503751087, 0.1825966337745124, 0.1778093848426845, 0.1754823532129347, 0.10803679851838133, 0.11384759125552113, 0.11933799397778588, 0.09229667273205722, 0.11977215244069994, 0.09467377677635036, 0.21082688474918676, 0.23594190239510682, 0.20389637902899538, 0.10351352366664213, 0.10139806726917577, 0.11377067659540285, 0.15568053082120148, 0.13890148813823566, 0.1448114806288704, 0.18812344466983644, 0.18746660521340797, 0.18126634118341833, 0.1832623055742738, 0.17515562382821048, 0.17674795139554766, 0.18746178803499347, 0.18120811983253649, 0.17647077684556356, 0.07366789429115328, 0.07477493279935554, 0.07388551562056056, 0.07206629836200795, 0.07537494897816577, 0.07047198570958624, 0.06737657476546155, 0.06729451389511454, 0.06830068025935598]}, "mutation_prompt": null}
{"id": "1ff61b09-f5dd-479b-a2e3-2e7fb315408d", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.multi_explorer_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def multi_explorer(self, particles):\n        explorer_particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        explorer_velocities = np.zeros((self.swarm_size, self.dim))\n        explorer_best_positions = np.copy(explorer_particles)\n        explorer_best_fitness = np.inf * np.ones(self.swarm_size)\n        for i in range(self.swarm_size):\n            explorer_fitness = self.global_best_fitness\n            if np.random.rand() < self.multi_explorer_rate:\n                explorer_fitness = np.inf\n                for j in range(self.swarm_size):\n                    if np.linalg.norm(particles[j] - explorer_particles[i]) > 1e-6:\n                        explorer_fitness = min(explorer_fitness, self.best_fitness[j])\n            if explorer_fitness < explorer_best_fitness[i]:\n                explorer_best_fitness[i] = explorer_fitness\n                explorer_best_positions[i] = np.copy(explorer_particles[i])\n        return explorer_particles, explorer_velocities, explorer_best_positions, explorer_best_fitness\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Multi-explorer for balancing exploration and exploitation\n                if np.random.rand() < self.multi_explorer_rate:\n                    explorer_particles, explorer_velocities, explorer_best_positions, explorer_best_fitness = self.multi_explorer(self.particles)\n                    self.particles[i] = explorer_particles[i]\n                    self.velocities[i] = explorer_velocities[i]\n                    self.best_positions[i] = explorer_best_positions[i]\n                    self.best_fitness[i] = explorer_best_fitness[i]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and a new \"Multi-Explorer\" strategy to balance exploration and exploitation.", "configspace": "", "generation": 56, "fitness": 0.18485717492469889, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.3814842462237017, 0.3395496266753095, 0.31905217776065975, 0.29635495040978, 0.3003583557313535, 0.3246117962757997, 0.31648692241361154, 0.31477990173415826, 0.31676496261883835, 9.999999999998899e-05, 0.009613024589199104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09141280417352993, 0.08410793358004465, 0.0811974003378042, 0.08525461105881382, 0.07439406955291228, 0.09693021921086731, 0.07846239203382832, 0.07709336578240145, 0.10266387556474288, 0.08119173528710366, 0.07229664933396585, 0.07177351509248109, 0.09249906316336942, 0.07308902598738076, 0.08602801582315456, 0.06934206174725877, 0.07199559145148182, 0.07465271073893687, 0.9145473367762778, 0.9415721499871422, 0.8973703374974807, 0.9066943975130746, 0.8777639764132169, 0.8878712959833754, 0.928731831748883, 0.9302145858160789, 0.9145842003305179, 0.19217414668003563, 0.18994631711019427, 0.18497282573607343, 0.1932947051025552, 0.18168630237050698, 0.18586336892035715, 0.18147815458079475, 0.19505430097344356, 0.18064515802763348, 0.2576935711936842, 0.34067533127955596, 0.2302756043242573, 0.25547414087544174, 0.2509854795121891, 0.1960671249983852, 0.2264642986137385, 0.17144439747519014, 0.20955618225670813, 0.11995589845594201, 0.08154727328926203, 0.1049453997076305, 0.10305012546344294, 0.11499333200469153, 0.10602843899395886, 0.12655203304040974, 0.11050810458618254, 0.11548177886948885, 0.13092418901916714, 0.11357105988973981, 0.1221636989814382, 0.13378478446883013, 0.12479293959375193, 0.11165535423764883, 0.11400381026340545, 0.11560878788257922, 0.09191904758532077, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12966078527515823, 0.07625703168407838, 0.11297167972170241, 0.12192108148659486, 0.0592379968224217, 0.05480945911464952, 0.12467855607286604, 0.09698175375396989, 0.07736688197998043, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04963558017086378, 0.05050258854062539, 0.0402927721419184, 0.05917023725416348, 0.04378179856102693, 0.0351858326391159, 0.04430422455418559, 0.03795821604077987, 0.03798447217800238, 0.3154204343571697, 0.3027859008692123, 0.34535095189392173, 0.33016751128302635, 0.3121377552203457, 0.2947392836038254, 0.3448039864844946, 0.33957457453610984, 0.38191433085090376, 0.08442965398880731, 0.07426310339708853, 0.08171008343669306, 0.06778049440597422, 0.07648526916783882, 0.11821519478403897, 0.09520915385446693, 0.09885795620284721, 0.08551934208892542, 0.15885280225572274, 0.1251840220967615, 0.14192195549195985, 0.15424060189459743, 0.20125007466799516, 0.1726898090900344, 0.14977031486789583, 0.19378318304616227, 0.16913921060003556, 0.2358651501026433, 0.2259713598121551, 0.24352556588958474, 0.26704036223898286, 0.2489293047705856, 0.24266633450687403, 0.23515983177629196, 0.2619911251546114, 0.1930713621216461, 0.18192000577169742, 0.17813921937934207, 0.1793786844587204, 0.1872645406908754, 0.18236515299613398, 0.21032726959276593, 0.15288126989386197, 0.18904061869645994, 0.161378987897014, 0.2187603472638764, 0.219400108292355, 0.2339424739253746, 0.22044547811944049, 0.22274806055113294, 0.22718340319577224, 0.21719827413708925, 0.23260302510351494, 0.21166787879807303, 0.1767193809717783, 0.19658937647669839, 0.17034772666829634, 0.19220150011956916, 0.17256737112171072, 0.170812291020782, 0.16937735368860396, 0.18690672257241514, 0.16454255627336534, 0.18322096309479152, 0.18481567457044834, 0.18583010854208137, 0.18262426034160928, 0.35618839893517285, 0.1836155747810635, 0.4371802240600563, 0.3616718853515666, 0.37716254600801524, 0.4040147052728208, 0.37964169432020656, 0.29325281026159056, 0.3052577872207397, 0.16942820192297148, 0.16600185256390154, 0.2828134911669111, 0.44606917912904487, 0.26169265535616737, 0.182322554804489, 0.18529792595675842, 0.18931435950741415, 0.1899779626919189, 0.198644427993531, 0.1879122183474755, 0.1910412041836954, 0.20688693974270211, 0.1799776704009799, 0.08559584653432917, 0.08360838423653805, 0.08248137904694708, 0.07287891246514933, 0.0863810082081583, 0.08919063285459083, 0.08064153524094275, 0.08905738864049595, 0.08700146071845427]}, "mutation_prompt": null}
{"id": "3c9027cc-58a8-41ee-b425-ff5155d2a57f", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.4\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.98\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.archive_update_rate = 0.05\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < self.archive_update_rate:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Archive-based Position Update\" strategy and modified simulated annealing with adaptive cooling rate, using Cauchy mutation and Gaussian perturbation, and a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm.", "configspace": "", "generation": 57, "fitness": 0.21833280243053202, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.4269539956693157, 0.460230599492794, 0.46346841595775023, 0.4821594053991798, 0.4775509697480844, 0.4534412674116972, 0.45218434740677826, 0.4446175904123083, 0.48195415560810806, 0.0026389698331524825, 9.999999999998899e-05, 9.999999999998899e-05, 0.00029249015402932343, 0.00042895727394676175, 9.999999999998899e-05, 9.999999999998899e-05, 0.02764049359219589, 9.999999999998899e-05, 0.11479368964346814, 0.09482915985972173, 0.07841204671608881, 0.10914741559935626, 0.10479491667962171, 0.10988959654279695, 0.12263682322188452, 0.10926361630577008, 0.10639187476589962, 0.09229548373802299, 0.09426161338591887, 0.09389863521355091, 0.08623855852383133, 0.06611845440992214, 0.0947600222300391, 0.08363142550037139, 0.0859606877396153, 0.10349488791395234, 0.9156940071464299, 0.9461656415254367, 0.8992645050619752, 0.8855231071342965, 0.8846448824576153, 0.8922484608214919, 0.9269541519864443, 0.9287165578500403, 0.9149520437065584, 0.27799271561785077, 0.2485191100831563, 0.2616731763184815, 0.25300711372572615, 0.29621482030427315, 0.25695430431682953, 0.2778065398557553, 0.24337582905962118, 0.2275462581966331, 0.6148652911324645, 0.3149385238491226, 0.24638936675329648, 0.26562252577356316, 0.3497843787214864, 0.20106805758283686, 0.26684063644334777, 0.21967220695117984, 0.3081589213316265, 0.12484582466340999, 0.14286939675764387, 0.1167134896244515, 0.1379825538330539, 0.12852296677081554, 0.17705622761735618, 0.12485404920442911, 0.1838990472950769, 0.12261559644002318, 0.136121062072029, 0.12361884443872517, 0.16639248577168086, 0.14262123923863346, 0.12731570986687057, 0.15183286781621552, 0.1556436321888217, 0.1894978265588233, 0.16659037571873447, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027047093520995436, 0.0014338552795208903, 9.999999999998899e-05, 0.0011606025403049225, 0.003034575768317338, 0.010120662309211381, 0.13614173338482127, 0.05939753091205169, 0.14404835144999195, 0.07118320250906762, 0.054092880584074354, 0.028801284989408815, 0.1510597041287396, 0.06636915894286033, 0.07276164363584414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00805095395756783, 0.027682547436515437, 0.011914144900659673, 0.007757293424873524, 9.999999999998899e-05, 9.999999999998899e-05, 0.10302092710720023, 0.1363921618506303, 0.11574021169824211, 0.09341081161126707, 0.1372440312532477, 0.11959206726364169, 0.10655349328515296, 0.10082201000757918, 0.11614313523761777, 0.43480445815684643, 0.40300743999592015, 0.4405289234301528, 0.43145656114623343, 0.4036225597970964, 0.41049164399274674, 0.4205134347364018, 0.40735473329253713, 0.40037166370137367, 0.0915096879816023, 0.10721412870245461, 0.09378198241391833, 0.131991318722675, 0.10667044316091634, 0.11583832100675195, 0.07531676505674145, 0.15430544781884725, 0.0933937111553067, 0.20888621912026717, 0.26456702344889005, 0.13435322414763018, 0.20132251020091585, 0.19756863387536117, 0.24799599534905692, 0.19330565988493698, 0.13535917293156674, 0.17508611970912702, 0.29416297395686963, 0.30702208707389067, 0.2895982280875331, 0.26599773460813325, 0.31175341788234623, 0.3040703379019384, 0.2469965873917388, 0.2966357182084204, 0.2925808632885947, 0.19115311081040354, 0.20950485647804307, 0.20320416828372, 0.22317161094235827, 0.25829333651995734, 0.2316966325079911, 0.21588350394816547, 0.21723932132839407, 0.16916642164857076, 0.2515509473570099, 0.24500758120419164, 0.24648892461057204, 0.24234480552950521, 0.2711175589222936, 0.21619569608759248, 0.24561360465673487, 0.22678142586372774, 0.23104131141692774, 0.19267679063073606, 0.18322578380105436, 0.18035557835289706, 0.1850399443995735, 0.1851993249265198, 0.19167833964744907, 0.2002049013874796, 0.26445975188733684, 0.1808143831591431, 0.18457206187143826, 0.18632794679857434, 0.18639846551539296, 0.1174624502663777, 0.19788115570863551, 0.145396772404624, 0.14105121311081925, 0.5231559125152376, 0.6249725604301192, 0.5898966849101848, 0.4519196801778279, 0.6284387111513323, 0.4811303894644663, 0.3501543768229862, 0.16649364642619857, 0.1664023714672952, 0.4200637607832043, 0.361285845132851, 0.18857400656163903, 0.1902711683354681, 0.1756483885553607, 0.18811830173198418, 0.17234332432128263, 0.18197178261997804, 0.18310098344935444, 0.21214562941366866, 0.17583637735344493, 0.09356048294781194, 0.0949472591906666, 0.10039908584137502, 0.09993032709047178, 0.08956006219024548, 0.08675862897353526, 0.1130608512508341, 0.0991918970916682, 0.08691683512046222]}, "mutation_prompt": null}
{"id": "959ea757-1ca7-4df4-b0a0-0888727ba0b3", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n            # Introduce a new random particle\n            if np.random.rand() < 0.05:\n                new_particle = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n                new_fitness = func(new_particle)\n                evaluations += 1\n                if new_fitness < self.global_best_fitness:\n                    self.global_best_fitness = new_fitness\n                    self.global_best_position = new_particle\n                    self.particles[np.argmax(self.best_fitness)] = new_particle\n                    self.best_fitness[np.argmax(self.best_fitness)] = new_fitness\n                    self.best_positions[np.argmax(self.best_fitness)] = new_particle\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 4, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate.", "configspace": "", "generation": 58, "fitness": 0.21775361947401858, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.4776127103908119, 0.4478246781974622, 0.4631548592113416, 0.44674084589829344, 0.4717112412028701, 0.4491415656734806, 0.43422708845767655, 0.4475151377644355, 0.4534880096435985, 0.005224977180052326, 0.01029804296839354, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013095219507622824, 9.999999999998899e-05, 0.1267837412311723, 0.11082023165397203, 0.0838318694406075, 0.08113342462924489, 0.11091817409182092, 0.09692199829499937, 0.11060467390444373, 0.1347643194981425, 0.10171616248583193, 0.08292824681952515, 0.09409077230202434, 0.09432299914426479, 0.10525725853353851, 0.08380971771272194, 0.09427519174955756, 0.10145750843926848, 0.08780598737705081, 0.09065549672787132, 0.9149185365843612, 0.9528475656721036, 0.9019599952738571, 0.8590307485187099, 0.8922575248175727, 0.887229440003112, 0.9400928966172807, 0.9274045226928455, 0.9152445442680793, 0.24571331683776343, 0.23623816873406034, 0.25129590519834144, 0.26225835007628606, 0.2883024449316183, 0.2560652237202128, 0.2581571269784355, 0.2548019730012726, 0.2616153468494926, 0.35830296228249403, 0.35887942079919577, 0.2944328563099903, 0.3240141141774907, 0.267382031811103, 0.20440000371804823, 0.2805481153879734, 0.28507383609564885, 0.30757531142740613, 0.143114421430229, 0.20302068679211593, 0.13587991004025812, 0.14536555671767293, 0.1327662689844099, 0.14364293607372458, 0.1427352951022849, 0.2078649458819869, 0.1515082963578891, 0.13779550866315438, 0.13472385216692417, 0.14272395888482337, 0.12273481978217038, 0.1462364675597979, 0.14770362213693256, 0.13443699688258293, 0.14061436562930407, 0.13938608467221658, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011604875910523615, 0.022014674609741047, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1273584898019049, 0.058076611469501604, 0.08719113213121543, 0.09650977797693083, 0.0688440289921507, 0.015210840319275443, 0.13051085016280972, 0.08818575407039864, 0.045229610352893856, 9.999999999998899e-05, 0.0031961086480627454, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12278417431736466, 0.10981606708245784, 0.1012726966143962, 0.10823895910890113, 0.10548112672459187, 0.12165543879430263, 0.07733486014181568, 0.11806272552450958, 0.127749090917465, 0.4255475516668472, 0.4116764170736745, 0.4173976799671558, 0.4133202673340466, 0.42071020363199774, 0.42881049591845066, 0.4234779678345454, 0.38007977662525994, 0.4332759224808369, 0.09547303944404173, 0.12390917581998673, 0.07810503542733982, 0.08954326719336114, 0.09418483587413462, 0.11167186556218534, 0.08655288754098056, 0.1290526744184839, 0.10778693663161287, 0.17684450320934342, 0.21515529407864598, 0.1510146448870564, 0.19622472084995146, 0.18845017734323877, 0.16029774052584977, 0.17978180561978008, 0.20482154155541876, 0.2184742144558791, 0.3055113885767845, 0.2733034944425793, 0.31610191262123577, 0.27099648771383933, 0.26454362561885714, 0.29998514989353575, 0.2916169883171711, 0.28438711430310704, 0.23880325862974316, 0.19711165281901266, 0.19186480227873504, 0.23951648211871213, 0.24638595910569006, 0.22777498945473373, 0.21472137648634082, 0.20160593173620978, 0.23573480125422308, 0.17519479733800414, 0.23737762118164818, 0.23041304294528064, 0.2199778400993727, 0.25064762372368043, 0.22609231060576884, 0.2129735196551794, 0.23616210234214252, 0.2620305025663291, 0.20853194962697674, 0.18408206266523974, 0.1834487132601701, 0.18599944336730811, 0.18834350438756298, 0.183113252086458, 0.17746214884734146, 0.18012204112147157, 0.18162134739869296, 0.182196335639073, 0.18500328713933356, 0.18612735309077855, 0.18516145456508415, 0.11839680125887408, 0.1973959390588328, 0.6213944249760698, 0.14911587373868262, 0.6331627361839787, 0.5984323994866273, 0.5922106953907339, 0.5077995148642723, 0.4876987769646298, 0.5538964093328094, 0.16975624616252938, 0.16761988791447602, 0.1653386456355962, 0.4199613908197777, 0.49877304952016743, 0.17839744806026758, 0.19918298190721584, 0.18483564453538315, 0.19592010826885775, 0.19915751784381797, 0.1845958038357478, 0.1837224065619386, 0.21218189657304443, 0.18810895381874393, 0.09405891422110235, 0.08358873676362366, 0.08406875195623631, 0.11123423460283288, 0.11281921355109092, 0.07801911649196824, 0.08536257812919412, 0.0860364349382764, 0.08043802900003016]}, "mutation_prompt": null}
{"id": "0a525702-c879-48e1-932d-c28aaf48b6de", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.multi_local_search_rate = 0.05\n        self.multi_local_search_step_size = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def multi_local_search(self, position):\n        new_position = np.copy(position)\n        new_position += np.random.uniform(-1, 1, size=self.dim) * self.multi_local_search_step_size\n        new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n        return new_position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                # Multi-local search\n                if np.random.rand() < self.multi_local_search_rate:\n                    new_position = self.multi_local_search(self.particles[i])\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < fitness:\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and a new \"Multi-Local Search\" strategy to escape local optima.", "configspace": "", "generation": 59, "fitness": 0.21104419904796692, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.4293351169042672, 0.4901451164297329, 0.44233801625689917, 0.4482645609154965, 0.45318316524385305, 0.44867534955448285, 0.42649666693694843, 0.43960183408223286, 0.4499551879194622, 9.999999999998899e-05, 0.020889555600571486, 9.999999999998899e-05, 9.999999999998899e-05, 0.013842959408721822, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09399397964586953, 0.12824751037503024, 0.10799406668064859, 0.08919116871170096, 0.09087983788105392, 0.09222178572864015, 0.1150257997568257, 0.11455807634012527, 0.10660255637191896, 0.09683967181389286, 0.10049934613459433, 0.07788031764736991, 0.1111627252402646, 0.08259034492547124, 0.07433787850217888, 0.09790725477125328, 0.0852730373160091, 0.09491411543248252, 0.9056913178417456, 0.9316079742494991, 0.8891232294789698, 0.8400279610573919, 0.8751605917227802, 0.8766406982518563, 0.9219630062280222, 0.9158596775822921, 0.9114771422567586, 0.26044890106684015, 0.25258638579476234, 0.23125749656058303, 0.2695010692491381, 0.25219862629263523, 0.22474059518367795, 0.24986009415026444, 0.24888169801374083, 0.22576954592943077, 0.22897868322622295, 0.36726075072927256, 0.27040923526571636, 0.3246437580853462, 0.24581987329018407, 0.22617258791448025, 0.25160357725040017, 0.22960386690526602, 0.31574192378148214, 0.15935211426008788, 0.13198339982473373, 0.12089857641249868, 0.1344422638308015, 0.12906833682373364, 0.14309502325447554, 0.1434007342282575, 0.13597420002901506, 0.14018647295292908, 0.18613021250219175, 0.15902617758086435, 0.13168437323010296, 0.1831170728693743, 0.14404726284617697, 0.12516760885192157, 0.14682564280318333, 0.1322687476684551, 0.15402681967521747, 9.999999999998899e-05, 9.999999999998899e-05, 0.014069758598052817, 0.11126514657425124, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010194105497107753, 9.999999999998899e-05, 0.025358267596734874, 0.10280236320035585, 0.049755503629472675, 0.09823054130779907, 0.09935813394022919, 0.10742192641121984, 0.04537312194980092, 0.14250367767998073, 0.06125114651027075, 0.05429453528933048, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011032129703703042, 9.999999999998899e-05, 9.999999999998899e-05, 0.009136655502032798, 9.999999999998899e-05, 0.0952574752330333, 0.15417274920591117, 0.08383037679725636, 0.10169245769000312, 0.1219848861478986, 0.07655269844273427, 0.09596774622315352, 0.1065931570874985, 0.10640766493378429, 0.41514366242176903, 0.4062287955239444, 0.406435942680788, 0.4129398728930499, 0.39331402190612696, 0.40843164399723697, 0.3931428878817268, 0.4018712100830797, 0.3998606036255383, 0.09888572260265505, 0.1327046850620176, 0.11742352409424073, 0.13122218346085823, 0.10621937558563, 0.12052112655802227, 0.10337713507089608, 0.09074174500127741, 0.0803731210021319, 0.18570625526983386, 0.20781337184055793, 0.13218683980163426, 0.21257776202937206, 0.1853335334285876, 0.18972649056067825, 0.16895723915714822, 0.17402306401522272, 0.1978777177170037, 0.2977939393710243, 0.2856016376550672, 0.27359131446336804, 0.28507613089855, 0.2866908935180682, 0.25707332088848467, 0.2944895962606011, 0.282693945008753, 0.28503569726057165, 0.19979395002590195, 0.19350620194357093, 0.22835726228952802, 0.2364042388240576, 0.22212635170026607, 0.22551516088597023, 0.21129717467616216, 0.21395350505552013, 0.20424753258081507, 0.21519965353362946, 0.22879232523055593, 0.22068782674034415, 0.2222282302436286, 0.24123042423017327, 0.2210293707229284, 0.22169216016261994, 0.24025602727866902, 0.21005395470377874, 0.18247749339301267, 0.1799622118541434, 0.18310016492502323, 0.2046532977536233, 0.2065622239628514, 0.1907421674486276, 0.18547232850115147, 0.18283296691269224, 0.18037461368356633, 0.18567123491794446, 0.17420654566511462, 0.18639595044713897, 0.1714215999039811, 0.19766157100610804, 0.2082636780064091, 0.14101497372034577, 0.7642376806785653, 0.5909762130549083, 0.4797932965923646, 0.21074949037376378, 0.4687680330163836, 0.20448487104958246, 0.20439406674083516, 0.41389592012215237, 0.16712226372203365, 0.4525851130467786, 0.34581382305762887, 0.18065442761212602, 0.18219665193815648, 0.18101818110218115, 0.1908649233722296, 0.1785556139141038, 0.19682022906140106, 0.186666929063515, 0.1804650028942415, 0.19257176593099978, 0.11064099245177583, 0.07095540542110135, 0.08280423510993007, 0.10813553565188927, 0.10121079449440218, 0.08275231282138573, 0.09098461862177498, 0.09428293527290266, 0.10091072481277974]}, "mutation_prompt": null}
{"id": "91cc5200-7266-4824-8f84-55b351ffa08f", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.differential_evolution_rate = 0.1\n        self.differential_evolution_step_size = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def differential_evolution(self, position):\n        r1, r2 = np.random.randint(0, self.swarm_size, size=2)\n        while r1 == r2:\n            r2 = np.random.randint(0, self.swarm_size)\n        mutant_position = self.particles[r1] + self.differential_evolution_step_size * (self.particles[r2] - self.particles[r1])\n        mutant_position = np.clip(mutant_position, self.lower_bound, self.upper_bound)\n        return mutant_position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Differential evolution for local search\n                if np.random.rand() < self.differential_evolution_rate:\n                    mutant_position = self.differential_evolution(self.particles[i])\n                    mutant_fitness = func(mutant_position)\n                    evaluations += 1\n                    if mutant_fitness < fitness:\n                        self.particles[i] = mutant_position\n                        self.best_fitness[i] = mutant_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutant_fitness)\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and incorporating a new \"Differential Evolution\" strategy to enhance the local search capabilities.", "configspace": "", "generation": 60, "fitness": 0.21110997564866504, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.4680816315652243, 0.45429265395434393, 0.454703886056977, 0.4684562828888391, 0.44491903012163514, 0.4440699781834687, 0.4557554301340908, 0.4249319162639781, 0.4618347872520482, 9.999999999998899e-05, 0.017282662922446068, 0.03622690774815218, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1034435984321872, 0.08747896513175879, 0.11045759150154177, 0.09816648780510417, 0.10804359732523006, 0.12002182459719224, 0.1100943111149223, 0.14617745665257809, 0.10024558714956677, 0.10127658852934851, 0.07154715592766292, 0.10146833033149905, 0.08300085430829662, 0.0801230932316086, 0.09330103294460601, 0.08392612407808542, 0.08714138623586054, 0.07794858122205117, 0.900594661668544, 0.9402403222413667, 0.9059325036433402, 0.9014704594439225, 0.8332508669319609, 0.8672925538776464, 0.9107807965429597, 0.9247610490538097, 0.9047112132852503, 0.2609250877765559, 0.2579315681155834, 0.2429887814081283, 0.2302459190743601, 0.22771987252038883, 0.21813603388267888, 0.22242967970297167, 0.22662939233685275, 0.2213122018912167, 0.31113442282325854, 0.5083165833202465, 0.26756404251519617, 0.2577871795089458, 0.20612780712601908, 0.25564096121007307, 0.20050591200155965, 0.2266090578106218, 0.28211502986533266, 0.16749554222249807, 0.13420848639817817, 0.12626996525606793, 0.1369058499707595, 0.1347890640049444, 0.16405199996289088, 0.1362532405857403, 0.17122737648440522, 0.16296619940626733, 0.13839349994080818, 0.13259195847002503, 0.12620818117847976, 0.16092438606086512, 0.14873658483973307, 0.1297925418546172, 0.12295548091086272, 0.13700764558894518, 0.1293878127516509, 0.05770439052446852, 0.03596843696445662, 9.999999999998899e-05, 0.041774673067212054, 0.018664570451897844, 0.023702649591904268, 0.0004629473519763838, 9.999999999998899e-05, 0.00987128159747186, 0.12812021496611103, 0.07267725904345557, 0.11057566858273715, 0.07133121237334983, 0.036726231792152064, 0.012402561009952628, 0.08077434373732462, 0.08386919410051685, 0.056831686708720186, 9.999999999998899e-05, 0.0033533556616653915, 9.999999999998899e-05, 9.999999999998899e-05, 0.02170246366699391, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.113754874371917, 0.09160775373723995, 0.078341816771754, 0.08711201678819469, 0.12439649105996864, 0.13088617778816747, 0.08250104511301526, 0.12129614915225517, 0.12337778068556471, 0.39603799326235944, 0.41848072017882765, 0.4427916007311795, 0.39824603818744286, 0.3871816779784163, 0.3740767237534416, 0.40773092218747076, 0.4014319880535244, 0.4176987103829639, 0.0885348982256543, 0.16175067095274775, 0.07769029052144727, 0.08219875339119642, 0.1346386317625482, 0.09019682516191929, 0.09832984119126409, 0.11676277277263147, 0.12050540451084557, 0.2095203053907333, 0.1929895540720471, 0.14104086501782642, 0.2003020276851758, 0.1912135597012079, 0.21863477144368693, 0.19096237412003336, 0.20115589922711508, 0.17000212468854348, 0.3029168232827798, 0.2627610829427449, 0.30290533635796124, 0.2546909878885324, 0.310667833536027, 0.2795964155269818, 0.28866805358484326, 0.30031186483104355, 0.2655902632151197, 0.18074096686361718, 0.2060873057039, 0.22879068278222747, 0.19755542298303952, 0.19934550752511027, 0.2159278100208205, 0.16736487634663322, 0.21563936560936126, 0.19586601672429682, 0.22009022341840456, 0.2323189070692857, 0.29431814756430963, 0.2345952055862579, 0.24932179990358028, 0.20098050166230663, 0.2457885393467638, 0.2367626176738591, 0.2283333346233558, 0.1994791656066397, 0.186785219110702, 0.1871640800954375, 0.20390698369042015, 0.1842279417223427, 0.1897975315751198, 0.19456019181832884, 0.17111260203120238, 0.17967563512931561, 0.6767079658485171, 0.18474119368734165, 0.18509405370780607, 0.5694008364462921, 0.19693986160083155, 0.19409331806452068, 0.14050497153426966, 0.2054324627424422, 0.6461099445519918, 0.4790544776051405, 0.15235868146352272, 0.332247284685787, 0.16682516237427225, 0.42864374985536546, 0.16722258167282633, 0.16409584798122245, 0.3841041355368521, 0.3209394067611081, 0.17121405448912352, 0.17224982505987407, 0.1884184990495521, 0.18692480211576068, 0.18813473878195075, 0.1827443127172511, 0.17828997485822984, 0.18371529774169615, 0.18543734619083807, 0.09777820393577508, 0.08732604880488748, 0.07920821887161378, 0.08381673039362991, 0.09193998294891204, 0.09576701535312371, 0.09683106301946376, 0.11387565741308558, 0.0876910886045762]}, "mutation_prompt": null}
{"id": "88c0a2a9-fe3b-4d10-a9fb-d007b906edfc", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.archive_update_rate = 0.05\n        self.probability_change = 0.2\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if np.random.rand() < self.probability_change:\n                    fitness = func(self.particles[i])\n                    evaluations += 1\n                    if fitness < self.best_fitness[i]:\n                        self.best_fitness[i] = fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], fitness)\n                        if fitness < self.global_best_fitness:\n                            self.global_best_fitness = fitness\n                            self.global_best_position = np.copy(self.particles[i])\n                    # Modified velocity update\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                    velocity_centroids = self.velocity_clustering(self.velocities)\n                    if np.random.rand() < self.velocity_clustering_rate:\n                        self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                    self.particles[i] += self.velocities[i]\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                    self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                    # Levy flight for enhanced global search\n                    if np.random.rand() < 0.1:\n                        self.particles[i] += self.levy_flight(self.dim)\n                        self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                    # Opposition-based learning with adaptive rate\n                    if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                        opposition_position = self.opposition_based_learning(self.particles[i])\n                        opposition_fitness = func(opposition_position)\n                        evaluations += 1\n                        if opposition_fitness < fitness:\n                            self.particles[i] = opposition_position\n                            self.best_fitness[i] = opposition_fitness\n                            self.best_positions[i] = np.copy(self.particles[i])\n                            self.update_archive(self.particles[i], opposition_fitness)\n                    # Cauchy mutation and Gaussian perturbation\n                    if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                        mutated_position = self.cauchy_mutation(self.particles[i])\n                        mutated_position = self.gaussian_perturbation(mutated_position)\n                        mutated_fitness = func(mutated_position)\n                        evaluations += 1\n                        if mutated_fitness < fitness:\n                            self.particles[i] = mutated_position\n                            self.best_fitness[i] = mutated_fitness\n                            self.best_positions[i] = np.copy(self.particles[i])\n                            self.update_archive(self.particles[i], mutated_fitness)\n                    # Particle filtering for enhanced exploration\n                    if np.random.rand() < self.particle_filtering_rate:\n                        particle_centroids = self.particle_filtering(self.particles)\n                        self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                    # Archive-based position update\n                    if np.random.rand() < self.archive_update_rate:\n                        archive_index = np.random.randint(len(self.archive))\n                        self.particles[i] = self.archive[archive_index][0]\n                else:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy and a novel \"Archive-based Position Update\" with adaptive probability.", "configspace": "", "generation": 61, "fitness": 0.17138209951695257, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.2963688445212369, 0.3172308677904322, 0.29337959274933223, 0.3008893283761217, 0.3038442286725298, 0.28476402049303573, 0.3118949901224345, 0.3096979722274704, 0.3381481665878374, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05490901338122345, 0.08450436280727358, 0.06972534538852537, 0.12908185999203792, 0.06630480222081658, 0.07183292299788668, 0.06940860852631214, 0.08372967264939357, 0.07931684136603456, 0.06504046159273913, 0.058045072365109585, 0.05736207423258621, 0.06349110138739, 0.07372831015968018, 0.049502837500063124, 0.06016083151656404, 0.07191564906105374, 0.06423594304446001, 0.9105922783204788, 0.9131784860403509, 0.938503464472325, 0.870369601762603, 0.9579446738781585, 0.9475343954842669, 0.9380086901405827, 0.813917594301644, 0.9335206672147377, 0.15654487884126977, 0.15476264285556696, 0.1852892381012966, 0.15445133769173136, 0.16229805914663542, 0.16453886912700633, 0.15405756127576675, 0.1634047107646187, 0.16964364037128832, 0.19093226381425488, 0.20134579578372302, 0.1683519333208755, 0.2563558583476353, 0.2109631975864863, 0.2019469823139386, 0.21701542535842355, 0.2229050889493719, 0.18037485637196626, 0.025095079466893377, 0.0877918958221311, 0.05384257793748515, 0.0790275434479456, 0.07619214160247068, 0.10247718111323634, 0.1080994042494342, 0.09749465478422914, 0.08873150002873631, 0.10595105200607502, 0.10224752360921541, 0.10491423383016829, 0.10645108136388848, 0.10963401841869158, 0.0933003079499547, 0.11648369903303923, 0.11603896527727975, 0.11467079239617906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012551439507546447, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13261036288406558, 0.07547890288809866, 0.09022877729179435, 0.07087121402489971, 0.049762977318845714, 0.05547943532554522, 0.08347851936255157, 0.06381387476392175, 0.05833834928825732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037952389951492305, 0.02737782524177057, 0.031089343197548303, 0.029142202469480627, 0.03261844366743649, 0.03907258019310811, 0.026121520675507215, 0.03800445251540774, 0.03727588275453131, 0.30426006705346986, 0.272884733141352, 0.3114505669959976, 0.32856525218655874, 0.28972501350617275, 0.3089145293621556, 0.2897411628850918, 0.2963933074060302, 0.29684871126769885, 0.08360936758684945, 0.09909072759347304, 0.08695882777209696, 0.07920643835340946, 0.06701509666341776, 0.08224186146797241, 0.08042269077276798, 0.09585149561294404, 0.0790892674921504, 0.1594596021243393, 0.15301151201445573, 0.16980592923202853, 0.140166782694792, 0.1290674261256619, 0.13228570517342175, 0.1599279372920942, 0.12771770347131517, 0.1431023496316437, 0.21625468280979276, 0.21810668993372506, 0.22457858411384746, 0.20471718502266767, 0.21864487823047274, 0.24452938221570386, 0.20418981374965284, 0.2219504581223617, 0.2309864174281694, 0.16962415514804763, 0.15906305129988219, 0.16158387718052614, 0.15440295515459745, 0.17129933201819736, 0.14839400980731698, 0.13957193007875934, 0.14004426528557412, 0.15304463468887264, 0.19264338025517724, 0.196888301281411, 0.21412187497359836, 0.21563009531085298, 0.1914664438084257, 0.21619981433968594, 0.20465918099163738, 0.19810398642503857, 0.20764821035991066, 0.16950209866220045, 0.17230397864516667, 0.16453369867884282, 0.17672783504721978, 0.16403522119217084, 0.1683694590028001, 0.17519718031427534, 0.16889140647991285, 0.16468859394425384, 0.1654210022525413, 0.36725302364083645, 0.28743196862856535, 0.29682852172245044, 0.302009717272974, 0.18842773013126002, 0.3204847639646812, 0.3262328914774444, 0.33393349580791876, 0.22901404037902862, 0.4123036094895851, 0.2896941537492983, 0.290825329502195, 0.18128171219573164, 0.1806949986691585, 0.2756388234007, 0.20722079441418295, 0.2008686684344161, 0.18177135366920538, 0.17462948845500903, 0.18783679863947034, 0.17694944161161819, 0.2002056555331283, 0.1726866365566997, 0.19882468958407162, 0.22831247266516097, 0.19445195026960838, 0.06557915952715321, 0.09452643456769783, 0.069842920857761, 0.07669660559666114, 0.07492921150218823, 0.08227659140274557, 0.07305620345060415, 0.07710441393920686, 0.07429903679524663]}, "mutation_prompt": null}
{"id": "8e182d42-d735-480d-bbf4-1d81336727e5", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.differential_evolution_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def differential_evolution(self, position):\n        r1, r2 = np.random.randint(0, self.swarm_size, size=2)\n        return position + 0.5 * (self.particles[r1] - self.particles[r2])\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Differential evolution for enhanced exploration\n                if np.random.rand() < self.differential_evolution_rate:\n                    self.particles[i] = self.differential_evolution(self.particles[i])\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and a novel \"Differential Evolution\" strategy to enhance the exploration of the swarm.", "configspace": "", "generation": 62, "fitness": 0.21187431154509845, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.46524718400625775, 0.43444270721883227, 0.4215838562027484, 0.44912664519723944, 0.43912134800240776, 0.4550875345893921, 0.4354452198253346, 0.4357461361726146, 0.44754473995452604, 0.010830980633822263, 0.0016264891957009642, 0.003664540633451563, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02131945139402347, 9.999999999998899e-05, 0.11304410302120049, 0.08900394163846503, 0.09328328502081296, 0.12597326608601556, 0.09994837747716068, 0.09851257381063983, 0.08653243488574391, 0.13159953694590099, 0.11688956986362864, 0.09630840995005818, 0.10389837958181303, 0.07948304732092981, 0.10424484841127213, 0.09813217416545417, 0.1052867464142817, 0.0942722054947146, 0.1010336140819813, 0.09264659986210155, 0.9031158476017178, 0.9520009013503073, 0.9133947982081011, 0.9105666420180851, 0.8690662482469514, 0.8825094817117538, 0.9220090190593677, 0.9343793742421287, 0.9169799853174723, 0.24248933225870228, 0.25630513973987457, 0.22774191992402115, 0.23323210402508698, 0.2530758225830405, 0.228453462295501, 0.23259983307088583, 0.21845686556892085, 0.2396099255198737, 0.6593820920513734, 0.35913802492882074, 0.33770960324369237, 0.2631804224226645, 0.20572610650891898, 0.24969710402270717, 0.22328790039300472, 0.23037352421768476, 0.21271294222962134, 0.1722458312473898, 0.0969842722340607, 0.1403650890301973, 0.13798245723137514, 0.15190558751112582, 0.16299304120331504, 0.12946450787772223, 0.1446947135254959, 0.15330209885522506, 0.13879995929597622, 0.14162739017513992, 0.1402713548300868, 0.13262461474534426, 0.13547285259258057, 0.16294936757392808, 0.13834254740517538, 0.127438770895276, 0.13744089648177327, 0.0023492197510737167, 9.999999999998899e-05, 0.03198965139251064, 0.021794826557752778, 0.078362637418538, 0.004809784592192723, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14533215561667134, 0.05040200521270366, 0.08288266744696615, 0.09815191923762356, 0.055941602155993086, 0.026320434857035058, 0.13686719187544782, 0.06334232266696105, 0.07106132732548887, 9.999999999998899e-05, 0.0035893210026686218, 9.999999999998899e-05, 9.999999999998899e-05, 0.00047531362082642303, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09116302082572325, 0.10148099626781515, 0.07967758740704178, 0.07203671010411505, 0.12924815683145896, 0.11358053000662527, 0.1054945322801828, 0.08431046128310249, 0.08965733548178345, 0.4159016577925373, 0.3912842934098788, 0.40514344117339096, 0.38939490441014235, 0.4025872940589701, 0.40703414735578836, 0.42228772400718995, 0.42375038628433837, 0.42953992963358445, 0.11354171602062268, 0.09052600833679447, 0.08329593943521141, 0.1175567425715599, 0.10593771672033947, 0.09991116198422101, 0.15854014461605803, 0.0983227247163968, 0.09700145949468264, 0.14396015499164916, 0.16699818283339596, 0.136060164059556, 0.17336174179584263, 0.1812380501988502, 0.20951873599622484, 0.16494815582445643, 0.18994045240797763, 0.17491544953296212, 0.30301668348178035, 0.30857488222497664, 0.309875136724736, 0.30162740483889383, 0.29566491777324055, 0.25986960083614963, 0.2584005668108895, 0.30200743742893876, 0.27714051068666945, 0.19745703125124536, 0.17379945023147625, 0.22224346334699085, 0.2080009593401958, 0.22167718951693616, 0.24905908282011346, 0.1976142621646112, 0.22007599210643825, 0.1913058067141451, 0.24016477535018987, 0.21113369437673202, 0.2250908330582433, 0.2439503907351167, 0.22987462611877352, 0.22194082007462812, 0.24869255896464038, 0.25138627106070777, 0.24524289916246234, 0.20692762056689495, 0.1776928743509627, 0.18138408295723318, 0.21456166815013789, 0.20860778319550066, 0.17515463026159195, 0.17437773205752505, 0.17887064841036648, 0.1772588466255094, 0.5779914214959403, 0.18612687758607716, 0.18562771110486698, 0.48194140699958776, 0.1985837627737772, 0.11432654836922596, 0.14027683884172348, 0.6147063286958802, 0.6284503911967698, 0.5001429726406623, 0.15138997811925947, 0.20360666283263873, 0.16658467296832968, 0.34269314537990725, 0.16752946959641435, 0.16556675601739357, 0.29470598920325364, 0.38359179180088465, 0.20791134530341848, 0.19405028119695333, 0.17482574840231568, 0.19530606633507164, 0.1691441091668907, 0.1985059110635159, 0.19315383394653185, 0.18293832527278164, 0.1832877923060494, 0.11241865338214663, 0.09278083337007792, 0.11577197258832495, 0.08701414690015885, 0.0901537616390038, 0.10010236333816924, 0.08034642465609598, 0.07810965722144902, 0.0880642948431607]}, "mutation_prompt": null}
{"id": "ec17ca91-b11f-44ca-ba31-448f2428debc", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.diversity_threshold = 0.5\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def diversity_based_strategy(self, particles):\n        diversity = np.mean(np.linalg.norm(particles[:, np.newaxis] - particles, axis=2), axis=1)\n        return np.mean(diversity) < self.diversity_threshold\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                # Diversity-based strategy\n                if self.diversity_based_strategy(self.particles):\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and a new \"Diversity-Based\" strategy to balance exploration and exploitation.", "configspace": "", "generation": 63, "fitness": 0.21839453189541005, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.5161665562055474, 0.46863754195075047, 0.45686086387716884, 0.49643964797520734, 0.4315166841061766, 0.4463537736575277, 0.4496693691406971, 0.4554736267806634, 0.4248831292984153, 0.004996650854338092, 9.999999999998899e-05, 9.999999999998899e-05, 0.012896683461991798, 0.00386242523487923, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1314262657220292, 0.10349911568779657, 0.10701401924105791, 0.11325285247684713, 0.10895030370487546, 0.11105080485389007, 0.1199423743379201, 0.11082829971608898, 0.10835161606385102, 0.06812524466401282, 0.10396893689007525, 0.09590489013554326, 0.08384017889595485, 0.07793515059729783, 0.09039411309799872, 0.09448593441836106, 0.08127790697845216, 0.09354696977290111, 0.9149437159038689, 0.9463388479092292, 0.9108893139050334, 0.8969920244089592, 0.8950541175293093, 0.900342531086881, 0.9275784881873064, 0.928751963941111, 0.9156287233669277, 0.23953076011221064, 0.23843008141702426, 0.24238509076837522, 0.2487991344659568, 0.25718683020020605, 0.23384254485983458, 0.2538639946863792, 0.230898883660127, 0.24699672667467454, 0.34718347933433524, 0.5620882322612071, 0.3188607378266364, 0.26703628686669056, 0.5669831037903761, 0.2003174553443342, 0.32265442278633394, 0.22159257778049657, 0.34323837006394775, 0.12633107658741882, 0.11775727184740936, 0.1219455635683957, 0.15370240559454906, 0.19478386007495319, 0.1752652400456225, 0.2095662360297892, 0.1945944178763801, 0.1296016797541797, 0.15040927278604654, 0.15939601729046315, 0.14726989361253295, 0.15106261494300965, 0.13094747891514147, 0.14928307363484616, 0.13942849685452274, 0.14993500134283877, 0.17091464547089874, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012883290007943415, 0.038772674189703316, 9.999999999998899e-05, 9.999999999998899e-05, 0.024860245703190564, 0.0059993218546611216, 9.999999999998899e-05, 0.17294596243341565, 0.04334270476019886, 0.12039701793598212, 0.06842739471425552, 0.0724790421596404, 0.008010654468166511, 0.14082663297287945, 0.08609158104856507, 0.027724534758409747, 9.999999999998899e-05, 0.0019041304058730057, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016300196988678906, 9.999999999998899e-05, 0.10306238773447984, 0.13640264059954021, 0.095116314162486, 0.07776311133195246, 0.11148381500604154, 0.09290302531644479, 0.11112461682253105, 0.10860408182431225, 0.12101996516164926, 0.4702425975644683, 0.4342864478496944, 0.42184368652632465, 0.4087485366177336, 0.4157787217995912, 0.40039747656557667, 0.4428398148394139, 0.43278248890715165, 0.3933062447462814, 0.12376727292636513, 0.1104207526338209, 0.09008600339087736, 0.08940601391046543, 0.10548075063669127, 0.09847752232086937, 0.10382837830311287, 0.13787555053702671, 0.10371149747944819, 0.1464609151097941, 0.2471315581421546, 0.1301924556941274, 0.1752734914938323, 0.18305714766003756, 0.19604618874051138, 0.17180286184771754, 0.14039362638510777, 0.18943444043613988, 0.2805592982962185, 0.3146128285991272, 0.3076468466003597, 0.2806600132288273, 0.2652824930249973, 0.29532169317493306, 0.29428369945558097, 0.29905724623901797, 0.27890401803805265, 0.20191842740513755, 0.2206934528999549, 0.2010551004885549, 0.22828781954723376, 0.2120810622503806, 0.23264969032131488, 0.19357491884086686, 0.2233239195032216, 0.17088789018808204, 0.22656433312006719, 0.24376289347299218, 0.2615811191601396, 0.28598625631646246, 0.2444659000490802, 0.26495452009176956, 0.22551057173720312, 0.2201260443005697, 0.20335547304146062, 0.18818233954969688, 0.18830803559355547, 0.18746919832629183, 0.18494089832133975, 0.1895485426180915, 0.18299821010092743, 0.22462223841510431, 0.2642964937036125, 0.17744376377944993, 0.18445692975113526, 0.1863874209495643, 0.18638656068666615, 0.11747024595346434, 0.19781932440241856, 0.1454011874861657, 0.14121775269510506, 0.5943487682775936, 0.607378074248494, 0.6180626766097557, 0.45505717626775, 0.39937593592580967, 0.43092084864210023, 0.4430592536642147, 0.16682127380804157, 0.16632441313996604, 0.34793110106826475, 0.3766321383693363, 0.1895858302765414, 0.20577758536257085, 0.19384221685336622, 0.18005388736037764, 0.18471065011035648, 0.18808126837065953, 0.18213404534153754, 0.21214562941366866, 0.1728856302377504, 0.07520755994165751, 0.08638043654742145, 0.08673797564716246, 0.0829196702417998, 0.07622665878481216, 0.0923906643647433, 0.07628001798312323, 0.10600531051356665, 0.09267825801847307]}, "mutation_prompt": null}
{"id": "e17405fb-6274-485c-b532-532cf3fa6742", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.98\n        self.adaptive_cooling_rate = 0.6\n        self.levy_flight_alpha = 1.2\n        self.levy_flight_beta = 1.5\n        self.opposition_based_learning_rate = 0.3\n        self.inertia_weight = 0.85\n        self.inertia_weight_damping_ratio = 0.995\n        self.mutation_rate = 0.15\n        self.mutation_step_size = 0.15\n        self.velocity_clustering_rate = 0.15\n        self.particle_filtering_rate = 0.25\n        self.archive_size = 12\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.12, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(4, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(4):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(4, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(4):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.55 * np.random.uniform(-1, 1, size=self.dim) + 0.55 * (self.best_positions[i] - self.particles[i]) + 0.55 * (self.global_best_position - self.particles[i]) + 0.12 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.12:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.06:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate.", "configspace": "", "generation": 64, "fitness": 0.21081423313229836, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.44092814072124853, 0.42503631713096834, 0.4249938272859545, 0.4414351154843099, 0.46174299409531117, 0.47032190568473975, 0.4291648206733454, 0.453551888918288, 0.4339535561479201, 9.999999999998899e-05, 0.021228970298007854, 9.999999999998899e-05, 0.00013917933381035752, 0.005236507476362062, 0.002054821878166191, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11265342353947527, 0.12503908442645095, 0.11577650144739127, 0.10126756434731488, 0.1035704026778701, 0.08692951060592857, 0.12484390745212326, 0.11599392881405435, 0.11730284076982767, 0.08941020143394796, 0.09393844487703895, 0.09729653959210516, 0.06942928278114613, 0.07818646198548174, 0.09968418107004418, 0.11069374760721751, 0.09062534001995504, 0.08356367188084446, 0.8715869856902504, 0.9326732878832775, 0.8365990640969154, 0.8985547157456499, 0.8799976463082567, 0.9046058225330642, 0.912548599460508, 0.9229744611436277, 0.8993997559381378, 0.2588175998482817, 0.26759864850252, 0.24790916617971437, 0.25973166554899985, 0.2456246817319515, 0.2479504399044391, 0.25524297313913724, 0.24240998154544646, 0.2202119657757018, 0.3321531483564548, 0.29022630340889055, 0.31683213984311964, 0.21816386600754833, 0.2654588381229376, 0.20798735174373273, 0.36594270386141603, 0.17820964097799352, 0.4272541484140092, 0.15151111533899753, 0.2013260056699674, 0.11207028015001941, 0.07272032467379863, 0.13780108307516492, 0.13248511057435608, 0.14104313070188879, 0.19015739086360894, 0.1335593962952325, 0.15241529589277603, 0.13633086100700142, 0.1422907552400282, 0.12260329517936408, 0.1250805450285838, 0.1395489349119431, 0.13752135986040215, 0.14498307698899116, 0.12177593516837515, 9.999999999998899e-05, 0.00819648677275131, 9.999999999998899e-05, 0.05730425085264779, 9.999999999998899e-05, 9.999999999998899e-05, 0.027104837794139858, 9.999999999998899e-05, 0.020688542211585115, 0.1148871034161606, 0.031864347782046054, 0.13966578439836141, 0.10766847676069047, 0.04732776511697534, 0.03184676469816783, 0.11752890604665567, 0.05664151063444001, 0.10532348256724089, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005349752599736024, 0.09737477691423269, 0.10047620998831586, 0.07728810703345845, 0.12154824166180456, 0.10146134887120184, 0.09885497815662025, 0.12469380031589206, 0.10249054720267636, 0.09411818520248094, 0.408262242596387, 0.4294781586878541, 0.41362311063083446, 0.418204559525457, 0.40835420878576456, 0.42648434390631984, 0.3837678670813449, 0.42054091811405037, 0.38516711291866046, 0.1108111233406931, 0.10777011706634765, 0.07235685538193082, 0.0750808922273225, 0.09916740097518573, 0.1328929393038366, 0.10790302631109538, 0.11805906488269446, 0.0903959460291881, 0.14937922935819248, 0.151297358605059, 0.18812979636144678, 0.15117685677806603, 0.16039534380466558, 0.1792081832282706, 0.15779173678114589, 0.24175864478576403, 0.1891767502938133, 0.27679722424568376, 0.28035003096238575, 0.30187842123064623, 0.2665032997936435, 0.29738890073617574, 0.26164107294050076, 0.2605432708123169, 0.2783620932854106, 0.2947035204505275, 0.18666986582779554, 0.20239713425002837, 0.2270203718956445, 0.21370148509508202, 0.2363827261609006, 0.20353677866978925, 0.18615218976949566, 0.21189094752100757, 0.18874449420299488, 0.229113646854197, 0.2773493664524238, 0.22477539097009813, 0.22673499768313155, 0.21991921746583165, 0.23272256796528024, 0.2441598149239489, 0.24370005064127787, 0.22627110887185753, 0.1902479924694851, 0.18137593418077724, 0.18106065487436995, 0.20567600424188526, 0.19058566510415043, 0.1926815376987927, 0.1993540681898508, 0.1856503087368374, 0.17886136970875355, 0.4458598668805386, 0.1853013360892507, 0.18583066760537537, 0.6236039818009482, 0.19624721301340142, 0.19605285740661538, 0.14059397974329846, 0.16726433553497333, 0.6317208603649396, 0.42304670507578623, 0.20843589031840004, 0.4338516376684243, 0.3941799869602862, 0.4027402997348808, 0.16591888096439034, 0.16795016685783815, 0.16472918919119306, 0.47282346302858824, 0.1791982044015198, 0.19287423571286966, 0.19606504675111047, 0.1727313855163093, 0.18840389155323767, 0.20774863323473403, 0.1737331555616609, 0.18650518807097538, 0.1890536035992565, 0.10404088775004694, 0.09238933999002596, 0.08371110817532057, 0.09369199601296319, 0.08432790360234721, 0.09618682390975497, 0.09212007076415774, 0.10112462477985174, 0.09489284051939362]}, "mutation_prompt": null}
{"id": "7a1973df-8cc1-4ef7-a6a3-e43ce476b853", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.exploration_phase = True\n        self.phase_switch_threshold = 0.5\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def switch_phase(self, evaluations):\n        if evaluations / self.budget > self.phase_switch_threshold:\n            self.exploration_phase = False\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                if self.exploration_phase:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                else:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.8 * (self.best_positions[i] - self.particles[i]) + 0.2 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n            self.switch_phase(evaluations)\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and a novel \"Multi-Phase\" strategy to adaptively switch between exploration and exploitation phases.", "configspace": "", "generation": 65, "fitness": 0.2166025551981099, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.5161665562055474, 0.45488443827555514, 0.46235185924719746, 0.496421665825832, 0.4463835073613336, 0.44863799879205457, 0.4543335770133451, 0.4353601439710766, 0.42725607697563706, 0.0031221539859005443, 9.999999999998899e-05, 9.999999999998899e-05, 0.01382559920038473, 0.005142729297393234, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13008005986296334, 0.10438188083420885, 0.10400439410252327, 0.11276915375597141, 0.10888091549975876, 0.11116624114167917, 0.11980627166695534, 0.10803935300299239, 0.10799108135468538, 0.06588113596900458, 0.0971240118540736, 0.09463100516832679, 0.08211227573645485, 0.07508368154726652, 0.09040571690191068, 0.09026901453655978, 0.08968864342347693, 0.08727886370612448, 0.9149437159038689, 0.9463388479092292, 0.9108893139050334, 0.8969920244089592, 0.8950541175293093, 0.900342531086881, 0.9275784881873064, 0.928751963941111, 0.9156287233669277, 0.23174904718907763, 0.23731475709255534, 0.23103502992390834, 0.24230114390061486, 0.24164880095074925, 0.22237903843954143, 0.2482537679253014, 0.22612389113745812, 0.2334526747379232, 0.3500823425471866, 0.5625175417715249, 0.2952862704185878, 0.26703628686669056, 0.5383976038151403, 0.20028498856560406, 0.3209449374566412, 0.22159257778049657, 0.3382972029993331, 0.12457364881308242, 0.1177726889481997, 0.12158358636109423, 0.15421240309559048, 0.19472089024493866, 0.17470251104018442, 0.21114949449318354, 0.19280945186988296, 0.12927558753188784, 0.14804389441535404, 0.16020130520527853, 0.1468577349443816, 0.1481686170457044, 0.12357156720658458, 0.14985111523666927, 0.13749519213860406, 0.14993500134283877, 0.16912756097299497, 9.999999999998899e-05, 9.999999999998899e-05, 0.004169019288069453, 0.036288374157348535, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005045480245504663, 9.999999999998899e-05, 0.172115973933068, 0.04542556762977967, 0.12099243892949507, 0.06421956671369922, 0.06827275372787445, 0.005344803068517812, 0.13730369506575002, 0.08842850848341854, 0.026787110068769993, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004449835256949863, 9.999999999998899e-05, 0.0020347211280721256, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10570519922486454, 0.14423087799426593, 0.09628130261753287, 0.0828213440266592, 0.10657756227424087, 0.09044356225397499, 0.10605841101272218, 0.11158579609641783, 0.12101996516164926, 0.47210120093075714, 0.40927525136854537, 0.42804460652410325, 0.4130896565844975, 0.40660222336135243, 0.40169728956284734, 0.43666140808389453, 0.42722541685847204, 0.39272906833434695, 0.12351141909398378, 0.10875478752484213, 0.09603762086401835, 0.08929605996316736, 0.09627902896803175, 0.09846618767141446, 0.10402327027368607, 0.13936199588962084, 0.10383149932497782, 0.14348592111696312, 0.2508068437347051, 0.12488403227624312, 0.16519176119326262, 0.18744352357086513, 0.19200739198979933, 0.18545835895286256, 0.12520650246215337, 0.19835267200098794, 0.2785200626234404, 0.31014138334011054, 0.3016419682118331, 0.27950442387283736, 0.2593883532521004, 0.2912785775832367, 0.2885138593462462, 0.2982480104966413, 0.2836827278061522, 0.19792024048188683, 0.22099175712858055, 0.20030035454871176, 0.22948808223885753, 0.21339830278106575, 0.23142437134720706, 0.19537612616555144, 0.22215969524049317, 0.16972274642033625, 0.22656433312006719, 0.24376289347299218, 0.25932017095645943, 0.28598625631646246, 0.2347288528996614, 0.26458997328433775, 0.21867025021417053, 0.2201260443005697, 0.20370587256590578, 0.1875438724535311, 0.18399001312704721, 0.17700635954975064, 0.18486091183334485, 0.18387562252940903, 0.18328434219078948, 0.2223677766215838, 0.26612504694040406, 0.17732035645911204, 0.18445692176871376, 0.1863846698765511, 0.18637278803441426, 0.1174660566136374, 0.19784467378306714, 0.1454011874861657, 0.14121440398330065, 0.6036135353216999, 0.5944892522155033, 0.5968857416315804, 0.43785496381207945, 0.40796886671261745, 0.43116824828110145, 0.4418518732838922, 0.16682166978248192, 0.16630167018660136, 0.33639619241147833, 0.3642980300856101, 0.19174369839560845, 0.20577758536257085, 0.19384221685336622, 0.17746385272247367, 0.18339684470742046, 0.18808126837065953, 0.18213404534153754, 0.21214562941366866, 0.1726813435396818, 0.07836392328607344, 0.0831740729339785, 0.08487495489676145, 0.08588453340770341, 0.07920167726661398, 0.0923906643647433, 0.08435353549220981, 0.09010725992910884, 0.09267825801847307]}, "mutation_prompt": null}
{"id": "0da6718f-e687-4efb-a10c-033614841094", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.probability = 2\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                if np.random.rand() < 1 / self.probability:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                else:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate.", "configspace": "", "generation": 66, "fitness": 0.2023352045375877, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.4616437288062868, 0.4291399671214048, 0.4508718194764846, 0.43115866928406243, 0.404379960480691, 0.4483162164033997, 0.44856383430017166, 0.44771831815904595, 0.42320365965198925, 0.007651705571435796, 9.999999999998899e-05, 0.005917539346415146, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.097127046596173, 0.0753739828076101, 0.11176042697816813, 0.10757959141708617, 0.11268673856179778, 0.09835308440908452, 0.08289589740254055, 0.10442257406657263, 0.09496292446748611, 0.08686752416456889, 0.07416677496340196, 0.08909516644917947, 0.08410110202796184, 0.08749293515838985, 0.09197927355686175, 0.07804509449658759, 0.08573231832860329, 0.08812519896548276, 0.8744440933693796, 0.9398586697288358, 0.8640589163582232, 0.7862466512109882, 0.8721862407423462, 0.8736809339363021, 0.9213467702858762, 0.9137881182734492, 0.9002560120759843, 0.23460820188507814, 0.21785817093376658, 0.23675702656711384, 0.2153679038394366, 0.21763458649666345, 0.23741854844536792, 0.21831018213811482, 0.2159557857083374, 0.21598611264663803, 0.2633047937612959, 0.2777664434247604, 0.23605651200761946, 0.25505578511323934, 0.259160322474557, 0.23617894320424504, 0.21633411202297237, 0.20209233468870402, 0.26207106294572946, 0.12602024602236017, 0.1306981825745377, 0.12598821141109384, 0.10012696182246839, 0.12781365954763368, 0.14052815293266396, 0.13412079250683895, 0.12090568559077841, 0.13151289203804373, 0.14749955488903, 0.1381470720843021, 0.1328563269387154, 0.12436567110323249, 0.13663052197360215, 0.15561573325572575, 0.13909015399745217, 0.13347024909376737, 0.12362511437125046, 9.999999999998899e-05, 0.012133455520557779, 9.999999999998899e-05, 9.999999999998899e-05, 0.0048055596377287735, 9.999999999998899e-05, 0.0005298299566486309, 9.999999999998899e-05, 0.004236339288087421, 0.15075179299622687, 0.05103872225182571, 0.1281658526756161, 0.07098978479950546, 0.0624458104878064, 0.0722825875783748, 0.0852737569485178, 0.0883499730338011, 0.060972956054973104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12650219277964092, 0.05642199911521095, 0.12369883326608155, 0.10870039181490487, 0.11009949332245705, 0.11969251130496539, 0.08979478694567333, 0.07538241691043945, 0.08891538999514392, 0.3904898549342307, 0.39284571654628986, 0.42841554164185414, 0.38893707632603713, 0.3733279923101369, 0.43233011541756095, 0.36138717135043263, 0.4057442494423732, 0.3769295821729669, 0.10612595691330173, 0.09108954994407026, 0.10272957764143265, 0.08499713516435858, 0.09870060791984547, 0.09253902751130283, 0.12268631789758422, 0.10106588648974635, 0.08632224278650191, 0.16608058571766504, 0.1508798191667693, 0.18899037174421662, 0.14097844553495875, 0.18485340238128478, 0.15546618924707944, 0.17500519486211596, 0.16176081179189183, 0.1847686994144303, 0.28891780913305243, 0.2697413678110121, 0.2991255746182322, 0.2700763403753371, 0.30138658660887985, 0.2683068562459333, 0.2530871859215361, 0.27849071877284537, 0.26751402545518665, 0.24344836712662743, 0.22910132528965832, 0.2341888630972474, 0.22193772336242856, 0.22956345761059038, 0.2186797369191671, 0.1881320726986232, 0.21340135527533877, 0.195640320730338, 0.23128302498995013, 0.23983415103076478, 0.22010326875166542, 0.23679012480838557, 0.22160497676954938, 0.22685025779478596, 0.2314956397601663, 0.22568450141108465, 0.21835642046897596, 0.16499245395498785, 0.17918179963104863, 0.17426831418288424, 0.18438276676350795, 0.17984963665108222, 0.18425093253491043, 0.18644875740823985, 0.20559480109421135, 0.19161072052587302, 0.4629076448324506, 0.18479413621431096, 0.18740731713109893, 0.5276270988964988, 0.1958201622004162, 0.1939664768873739, 0.14012823699269772, 0.1678553382311191, 0.635647195503839, 0.4073687821028731, 0.16926364712176545, 0.5216253017153635, 0.398693082711405, 0.16256544471793044, 0.1655262459870862, 0.16190568962791063, 0.21296099949562575, 0.2943364489301109, 0.19933937537290203, 0.19135645191450112, 0.1869265843933514, 0.18600354807790953, 0.20490012695582993, 0.1934225439114874, 0.20334401993932982, 0.18323765869957498, 0.19323799144509735, 0.09543096060859502, 0.08993283423858467, 0.08668457032107513, 0.09038358908195754, 0.08543616283100308, 0.08611995180861065, 0.10072185576774173, 0.09677307353791331, 0.0865683475173975]}, "mutation_prompt": null}
{"id": "51868049-506c-4615-8e03-6778c146318f", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.gradient_step_size = 0.01\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def gradient_based_local_search(self, position, func):\n        gradient = np.zeros(self.dim)\n        for i in range(self.dim):\n            eps = 1e-6\n            position_eps = np.copy(position)\n            position_eps[i] += eps\n            gradient[i] = (func(position_eps) - func(position)) / eps\n        return position - self.gradient_step_size * gradient\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                # Gradient-based local search\n                if np.random.rand() < 0.1:\n                    self.particles[i] = self.gradient_based_local_search(self.particles[i], func)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and a new \"Gradient-based\" local search strategy to further refine the solutions.", "configspace": "", "generation": 67, "fitness": 0.18557311805445081, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.3921173866516049, 0.4148134314014069, 0.421383400932843, 0.38562767998255276, 0.38744550772336694, 0.4109736346154186, 0.39692133141106056, 0.39542342537661945, 0.39199686854282656, 9.999999999998899e-05, 0.009586992858898302, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11742085561977023, 0.09657197893975722, 0.08756922276274459, 0.1031260317344902, 0.08753777368220039, 0.09291023004922205, 0.09792184486085587, 0.1127594582078908, 0.0978076365409477, 0.07255912425668798, 0.0722974479843006, 0.09197490676347475, 0.08959919248447801, 0.04800111908102045, 0.08524015049878908, 0.07632487179028846, 0.08004015102935846, 0.08649773249034265, 0.8443815161946637, 0.8967081673036463, 0.85826260247774, 0.7902974665312366, 0.7806779828626449, 0.7871744937336242, 0.8947451104825122, 0.8566528631516567, 0.8565243574556511, 0.19222645706262842, 0.1992542136234735, 0.20543882233141264, 0.18667114431634302, 0.19215306733231396, 0.1711089001893079, 0.18148314521716125, 0.17613797201920622, 0.1697446266114353, 0.23390097331074855, 0.26177922557885924, 0.2006402361363101, 0.242322122530107, 0.2464299049876617, 0.1911213667560846, 0.24565313287103185, 0.2171105358394665, 0.2134822219605479, 0.12055242875821992, 0.0806498715377848, 0.10938296063045239, 0.08475045905940626, 0.12043702917140708, 0.10996169134439748, 0.11689546675400708, 0.09680308235301871, 0.12986972879025183, 0.11128037823506043, 0.13627508349533857, 0.12523493796820384, 0.12894002287792505, 0.1228521558723662, 0.12752080057879522, 0.1151215488979469, 0.09326268811824734, 0.11074848635081747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10124242747054413, 0.029786543712328806, 0.07238634344203188, 0.06130155513866031, 0.054698644092079696, 0.06431781782755575, 0.08802434804285675, 0.050094100171958034, 0.04053086126579053, 9.999999999998899e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.11127209094432, 0.09857529486424188, 0.0965689632957023, 0.14859434366183777, 0.10792458856565501, 0.08289604160186714, 0.07883856312178528, 0.10957678399208148, 0.07317695251075584, 0.40694892326464316, 0.38488047230461897, 0.37835097943006235, 0.3516159259168151, 0.3378291748877629, 0.3249718897648487, 0.382841553361952, 0.3699477694760387, 0.3706794024955764, 0.07671717423712032, 0.10224588143799151, 0.0996483249715635, 0.08006623358314735, 0.08229527176462359, 0.07659414626427641, 0.10271283422604849, 0.1036835250071354, 0.10134800582517256, 0.1328201492671056, 0.13635505267859716, 0.13296586958234602, 0.15130315913450942, 0.17812928749872758, 0.12652653755213328, 0.1264588929702255, 0.11375554741939997, 0.14012377366151652, 0.2508559098122266, 0.2799893483495052, 0.294417503999164, 0.23531728426737886, 0.25500378095019127, 0.2632529381241643, 0.24020460568218827, 0.2832525801596335, 0.21424072866848543, 0.18166188890447033, 0.18780664344243647, 0.19460840686104708, 0.19696746815193444, 0.1946503370006436, 0.19502126260136676, 0.16120119394463128, 0.21877793881709928, 0.1673670490500797, 0.2118305921836645, 0.21098124115567063, 0.20024256193591727, 0.20879242173013512, 0.18986444173440187, 0.1986814708710094, 0.23255589811089628, 0.20658421613176314, 0.2096063126842378, 0.18959438293438124, 0.19369087927457163, 0.17455797645535898, 0.20354887196191662, 0.17650603020642885, 0.18761712299689304, 0.17711623357477146, 0.2045474025183457, 0.18343305172266455, 0.1806616057560525, 0.18281651057608528, 0.18272526286622004, 0.5068604650745215, 0.19461543706727558, 0.1566977086505964, 0.1386143309210569, 0.14576264529652105, 0.4892466634452921, 0.41698158727462886, 0.20656709585158428, 0.3531607121570539, 0.3510546974808967, 0.32990991923605684, 0.16529595497536176, 0.16388920576737875, 0.31602589300307504, 0.2986599334693246, 0.17513056353467327, 0.1818991395798789, 0.18101549487588164, 0.181934109669312, 0.17348361592721562, 0.16935633659988947, 0.18787885340932486, 0.1806101596172468, 0.17919046735860733, 0.07086212529474178, 0.07839786005619176, 0.08527278010924944, 0.09058911293662242, 0.08741202509833257, 0.07812513992410097, 0.0830930740396818, 0.07992766273184682, 0.08722851351957672]}, "mutation_prompt": null}
{"id": "9d4ac76d-e657-4e66-b584-42f2143d3237", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.evolutionary_gradient_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def evolutionary_gradient(self, position):\n        gradient_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + gradient_vector\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Evolutionary gradient for enhanced convergence\n                if np.random.rand() < self.evolutionary_gradient_rate:\n                    self.particles[i] = self.evolutionary_gradient(self.particles[i])\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and a new \"Evolutionary Gradient\" strategy to enhance the convergence speed.", "configspace": "", "generation": 68, "fitness": 0.2086229858727055, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.45419990038070723, 0.4848288801306391, 0.4664723274728475, 0.470530284364051, 0.46259345284835096, 0.4276837063953489, 0.439105571571637, 0.45054049041152944, 0.42446705323544587, 0.02264072625202007, 0.008214869123543966, 0.004916614013170562, 9.999999999998899e-05, 0.014860528089764347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11124925376292272, 0.07503755125503941, 0.1219221057599208, 0.11074626976407631, 0.10741379345770508, 0.09730117891262069, 0.09232498035316161, 0.09614480255500313, 0.1172853200943147, 0.08400046690694785, 0.08823044468177921, 0.10418528317069764, 0.08992801578475751, 0.07331259320119865, 0.07617062969902233, 0.11740646510506336, 0.1040580911605139, 0.08177041193767542, 0.8952666753254124, 0.9449403747523909, 0.9087961031953511, 0.8715886547298645, 0.9149045627888583, 0.9004482800704601, 0.913669159685625, 0.9075110657538836, 0.9147534469220098, 0.267751291772207, 0.2808688256117615, 0.25737883208734536, 0.25584442133019547, 0.2586315185371221, 0.2520553122280188, 0.24580206616969358, 0.2256791324958859, 0.2540404401476616, 0.3312149308027207, 0.2758911083798493, 0.28496407573021654, 0.2708719216454343, 0.2692591038651878, 0.24052772533435396, 0.2504184546407777, 0.1768356831403466, 0.29029159960145634, 0.12411694012128827, 0.12733858190841363, 0.14356729750713015, 0.1470027458799641, 0.12499919556851691, 0.14017857191726346, 0.14198704318844124, 0.15917058700035414, 0.18053311742980582, 0.18832883877648632, 0.13240759528749058, 0.153046314351304, 0.19022725717498912, 0.1338816671473525, 0.14993337848561605, 0.17499068581682498, 0.11624917897503706, 0.179356521809665, 0.016385818534705887, 0.02047895124802801, 9.999999999998899e-05, 0.0036633526130335214, 0.0020784667086208852, 9.999999999998899e-05, 0.0010231988857872798, 9.999999999998899e-05, 0.0058069212419373795, 0.07133864952297575, 0.08382336005733981, 0.10090287607187598, 0.08651307393939367, 0.06676803665643416, 0.02004207576016559, 0.12533093380250104, 0.07616170482666751, 0.08367061153938771, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00046652859980544914, 9.999999999998899e-05, 0.00839464599980655, 9.999999999998899e-05, 0.11680461270151532, 0.10538494879881433, 0.10233085154394972, 0.10186625503324942, 0.09974038104914906, 0.06205819367136978, 0.11326209010295807, 0.07776553903630978, 0.09103948162825604, 0.43329074695199066, 0.3942082882292707, 0.40437421614364144, 0.3984140073337503, 0.4320770561484437, 0.38339063684523345, 0.40883470387613907, 0.4111321315810571, 0.42839185910746524, 0.08552350331689462, 0.15884902584109317, 0.09468176158832942, 0.09574377460034811, 0.09739900052576433, 0.11623304204447249, 0.10328642162492685, 0.10678565644954119, 0.1008901707814952, 0.18101611201308165, 0.13442284546430472, 0.14528266793277234, 0.17630007210302867, 0.27368329800039815, 0.18742644099052574, 0.16934293112000454, 0.17116969692549477, 0.22662646897605643, 0.28324569480270734, 0.29562863967160047, 0.2798769036830513, 0.26471459101659256, 0.31084915840016436, 0.2913838268957495, 0.29419046978321783, 0.29133871363253405, 0.23139130319145074, 0.21255573177390408, 0.2281868897497794, 0.23185595578133367, 0.21877810325500824, 0.21557971183507152, 0.21348752510409041, 0.19718260327489734, 0.24568921293586132, 0.18946583945187856, 0.22654970884892478, 0.2326482368714976, 0.2227864502807152, 0.23876026480559953, 0.23128234560942063, 0.24460593873004466, 0.24002263002731028, 0.2581984268140962, 0.22571166904115247, 0.18869611473080894, 0.17712445531434529, 0.18934310145595146, 0.184170351398233, 0.18588901540971825, 0.24599038145940733, 0.1736063704035885, 0.17289408440495557, 0.17673827162157685, 0.1799074372006476, 0.1858080618326936, 0.18535080464341724, 0.17785656945361583, 0.19861185114603264, 0.19683284683600855, 0.14128796700817925, 0.6150236309146109, 0.5273331882450085, 0.4388739435075356, 0.16856950077043098, 0.44245647374023256, 0.40887583450296694, 0.16570677792231636, 0.16732605015616497, 0.16473870523847656, 0.2609015021614045, 0.2858466039089397, 0.1843863655095841, 0.17753346220103772, 0.1740859134205115, 0.1712041829814499, 0.19586963449084194, 0.18034203813463423, 0.17569358941357238, 0.18236879595874367, 0.1860384031149126, 0.0801454740972889, 0.09503238520536217, 0.07327244582309289, 0.09311633599644553, 0.102314615256616, 0.08034396081314465, 0.10027055777220661, 0.07846750992096385, 0.09991239470798396]}, "mutation_prompt": null}
{"id": "ce4a47e2-42c4-4fcc-9180-f7210db12a1e", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n            # Additional exploration with 10% probability\n            if np.random.rand() < 0.1:\n                for i in range(self.swarm_size):\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 4, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate.", "configspace": "", "generation": 69, "fitness": 0.20562924465322988, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.4381071372232044, 0.40236661705661336, 0.43269639425367024, 0.40812499416291004, 0.3711055186300225, 0.37844367290998193, 0.4215342969544976, 0.39945455512953487, 0.38853839028056514, 0.02320230372175136, 9.999999999998899e-05, 0.006125386795458376, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007210874767755726, 9.999999999998899e-05, 0.11070865250521678, 0.0831347537135041, 0.10702836143171679, 0.09550330294804643, 0.10419057885448146, 0.11306497224323864, 0.10616259519672056, 0.10879257418600319, 0.11320127918494327, 0.06839889391836018, 0.0787483332847021, 0.08774941432177963, 0.1039210575343279, 0.06923155259267044, 0.09300452139684601, 0.08727034796652222, 0.08308211075604854, 0.08592032521232162, 0.89729801319859, 0.9429687382123152, 0.9082738955164736, 0.9032486318214457, 0.8489567013155065, 0.925497985838891, 0.9400928966172807, 0.9124777482711072, 0.9276993302872929, 0.23990773596420434, 0.2447182206614691, 0.19897570644440177, 0.22741445866236498, 0.20624463696523665, 0.23130340102116165, 0.2378075210284264, 0.19533615447414354, 0.20267878315858256, 0.3112821362115238, 0.23318878014769984, 0.27514328921587383, 0.2702783904213969, 0.31443947874586775, 0.2685555035782513, 0.28949783152860153, 0.37102875641032274, 0.231552560792611, 0.13571988591694295, 0.1390264406897963, 0.13742820251576848, 0.1353668887465519, 0.11606296007063233, 0.17766337570806956, 0.13950296857946254, 0.11446183481918304, 0.12109479971469206, 0.1403821057437672, 0.1457297818102512, 0.13429624388552985, 0.12239313601821089, 0.1210008246978872, 0.15289635811157642, 0.16260821560210137, 0.12126714094705915, 0.122265323315072, 9.999999999998899e-05, 9.999999999998899e-05, 0.01496252665302833, 0.024757227023508133, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000497688300420629, 0.12453048189104043, 0.0666845558773641, 0.14581774683621918, 0.14141713566140568, 0.0690087679106215, 0.08789833809108027, 0.11837902353227725, 0.08630088082594212, 0.03883715193441528, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10561126237460938, 0.10597170484519736, 0.06537695268170207, 0.09550044113214662, 0.08854101009699711, 0.09396374095264959, 0.07777598505864602, 0.08996914306723591, 0.09190164163457648, 0.4110909554364134, 0.42512015373169876, 0.39500985667441857, 0.37880258605468775, 0.4394765101258038, 0.3700841954518933, 0.41758358186014, 0.409931479461515, 0.39023183866543576, 0.10760995515351146, 0.09693987522116754, 0.08712932914802984, 0.08645243419556059, 0.10437714909346163, 0.11162723455958434, 0.08387268374749035, 0.10163429646102828, 0.12035898665159495, 0.1407598022324419, 0.1665572421967345, 0.18526936220517176, 0.1759618731175886, 0.17461693850466053, 0.21888443296826832, 0.15896230112337417, 0.19424890936841466, 0.16749245971912274, 0.2906309193683273, 0.2631463572908658, 0.30181623550336767, 0.29074243196271665, 0.2893514708937831, 0.26994566907045425, 0.2443284888489029, 0.25203653695147055, 0.22883776299922964, 0.17931742158745, 0.1745102110182868, 0.21723088331762763, 0.25385249547245226, 0.24059471239746355, 0.2085873699159605, 0.1915498086559424, 0.21833256867099948, 0.17839585387055867, 0.22205554476063172, 0.26172279697418943, 0.20060485272245632, 0.22522166046726777, 0.258550770086574, 0.23351829822615366, 0.22770541850922443, 0.25318939753892533, 0.21140562314479527, 0.19038745985497485, 0.18884609240139272, 0.18943575380090116, 0.18905317794805265, 0.19169963234149123, 0.17444847854675916, 0.1797795869961758, 0.23766252784580055, 0.17284601584472925, 0.18498477578236738, 0.1856644505497954, 0.2997738469264023, 0.15865513678036136, 0.19601629174961077, 0.6215253931278365, 0.14911587373868262, 0.38566391721338467, 0.15795356831817353, 0.583037191911606, 0.4074114741899205, 0.3156766043879753, 0.510368784042195, 0.1693537592648845, 0.20208779554285272, 0.16529229455145744, 0.39904167579719885, 0.19696652701687567, 0.19256744886417732, 0.18752815348567464, 0.19291728572423128, 0.20590628155574664, 0.1949885948870398, 0.1822775477007491, 0.18436403488082753, 0.21218189657304443, 0.19252318469957097, 0.13474197623812856, 0.08482840108365619, 0.07553916779377545, 0.10759435224740688, 0.09422519080225045, 0.08336912691916454, 0.10399134431637447, 0.08551706542118465, 0.08397877315941038]}, "mutation_prompt": null}
{"id": "f106259d-f675-4a22-839b-01f240c29fe5", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.exploration_rate = 0.5\n        self.exploitation_rate = 0.5\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def exploration_exploitation_trade_off(self, position):\n        if np.random.rand() < self.exploration_rate:\n            return position + np.random.uniform(-1, 1, size=self.dim)\n        else:\n            return position + self.exploitation_rate * (self.global_best_position - position)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Exploration-exploitation trade-off\n                self.particles[i] = self.exploration_exploitation_trade_off(self.particles[i])\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and an additional \"Exploration-Exploitation\" trade-off mechanism.", "configspace": "", "generation": 70, "fitness": 0.21502200209659517, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.4748949169239731, 0.4752529632582848, 0.47623121103898935, 0.5062919320427891, 0.4923483362063562, 0.46730174387497647, 0.480334816835599, 0.4567343139310096, 0.4727146175989453, 9.999999999998899e-05, 0.007930795828311799, 0.0031870394221099607, 0.0006213008443520796, 0.01795993821780628, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09246988107765686, 0.08996561697745786, 0.1677949408802777, 0.08754058386189967, 0.08742042275166473, 0.12767633822887514, 0.08879231300762602, 0.11055223213849752, 0.1342516435315685, 0.10465612897342758, 0.10243924995425657, 0.08682410776717175, 0.10414059305889911, 0.10302436826483541, 0.07643668379280355, 0.10315834645422217, 0.08444013379133453, 0.11952019113799017, 0.8939600891045225, 0.9490217024785429, 0.8423530676696842, 0.8487178651841877, 0.8940051604804349, 0.8609969182437259, 0.9363855388354635, 0.9237623676014821, 0.905416451130509, 0.2808672033736652, 0.26466370194011957, 0.2586246673654857, 0.2901805390643022, 0.29208919744713147, 0.28205453096863575, 0.26932061330026946, 0.2848579863734436, 0.2784254689148147, 0.22847121975649676, 0.3545854550863603, 0.29446224933390974, 0.2654236229458684, 0.26725072113878623, 0.2437895917246652, 0.2316129893368376, 0.3212049465287077, 0.2971954585668283, 0.12545555034625444, 0.18910768357108754, 0.11906303848507926, 9.999999999998899e-05, 0.14169196557835928, 0.12317721519553759, 0.1452185175844254, 0.11430257365488272, 0.14930809418791613, 0.16009259405352916, 0.1443774713921675, 0.12580860697192042, 0.14822708612596835, 0.14720157690601532, 0.1712315801664961, 0.19937579850872567, 0.13244581104594344, 0.15037329375864827, 9.999999999998899e-05, 0.022687906137473735, 0.006221223928400965, 0.03041739005297517, 0.01718904422146661, 0.00037922208084895104, 0.00010577551662349638, 9.999999999998899e-05, 0.004938494603149546, 0.078940921662073, 0.0929496093478106, 0.07217716539660379, 0.08372073760104337, 0.07837997180798406, 0.013903430539659034, 0.101132442301614, 0.038130214646207916, 0.10871099274401697, 9.999999999998899e-05, 0.0029025259379572566, 9.999999999998899e-05, 0.0012935506982734157, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032485211130595104, 0.0011582806987094907, 0.006188483102326114, 0.12348353167334425, 0.10930660836243788, 0.10014142167435314, 0.11529091600587438, 0.12337984283466574, 0.11774753225492407, 0.11761466831292289, 0.10318647220628407, 0.08646274616144545, 0.44059126109843216, 0.4461018368756021, 0.4112051101416482, 0.42670520564327685, 0.43744589285099145, 0.4048041575879556, 0.4221662356991809, 0.44806494969217026, 0.4005487909598964, 0.10514755533263542, 0.14446598771711483, 0.12191285532260832, 0.10439435426310195, 0.10081587774761358, 0.09507556403607464, 0.1148093913325603, 0.1253604980649088, 0.07628091791254155, 0.21168407209986884, 0.15492798331288382, 0.15960949726859341, 0.208388538287136, 0.1986892857717636, 0.15700730869275137, 0.2007770719581271, 0.21321678629298735, 0.15248917472799928, 0.277108874266943, 0.2968585226246858, 0.29278347502249236, 0.24909432189491154, 0.3037329074455646, 0.2908915279418939, 0.24183975016911008, 0.2976651630246555, 0.23801265760882195, 0.23022448273238127, 0.22744593550029013, 0.21992111668329495, 0.22483395902325887, 0.2360275831353672, 0.22339757131185356, 0.1772236011748327, 0.22075749274212475, 0.14808133531620693, 0.24077941750531362, 0.26209007279701213, 0.23285423219878276, 0.24440383956471046, 0.2394526610955181, 0.22054376819648014, 0.23744586526593647, 0.22401841703984715, 0.2216151211091919, 0.20679264441490308, 0.1786081695595041, 0.28129823869126025, 0.23864891570265612, 0.17766322336840057, 0.16535447039185858, 0.18901559244884725, 0.20181317061675486, 0.17229314884893177, 0.12892518712055212, 0.18684839367158035, 0.18562012115599402, 0.7052674776469923, 0.19979952791350075, 0.1982825185409467, 0.1415622460316618, 0.14986815819640975, 0.7627375207395242, 0.44921571803900184, 0.21093661870008296, 0.44498276526405767, 0.5169573826247791, 0.35648661591452246, 0.1668485782147231, 0.16919496269896683, 0.3236390249816986, 0.36440011324066335, 0.18901394090352763, 0.19536634258302166, 0.19565428423561548, 0.19423990330566265, 0.18147126593482232, 0.1796115914940145, 0.19741505415605165, 0.17803428319273462, 0.1880016556719568, 0.09391703858206057, 0.09137521997858744, 0.07834824370353066, 0.07884280448103653, 0.09311719356183457, 0.07963667981890088, 0.07369098182404032, 0.07941716512965125, 0.09109333976049094]}, "mutation_prompt": null}
{"id": "c62ba59a-28ef-41d9-9325-d76114da94b7", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.quantum_tunneling_rate = 0.05\n        self.quantum_tunneling_step_size = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def quantum_tunneling(self, position):\n        tunneling_vector = np.random.normal(loc=0, scale=self.quantum_tunneling_step_size, size=self.dim)\n        return position + tunneling_vector\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                # Quantum tunneling for escaping local optima\n                if np.random.rand() < self.quantum_tunneling_rate:\n                    self.particles[i] = self.quantum_tunneling(self.particles[i])\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and a new \"Quantum Tunneling\" strategy to escape local optima.", "configspace": "", "generation": 71, "fitness": 0.20961241114179943, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.4714928292794297, 0.48535798769816074, 0.4666966420999177, 0.44596039784482333, 0.4341369426409436, 0.4522087364180808, 0.4474826909921642, 0.4452766583684128, 0.44672728489543734, 0.024366692092250952, 0.02976133118385693, 0.006254887512568308, 0.0018242822159388883, 0.0003758867565316626, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11859364888926915, 0.12429666556289154, 0.09757143755309605, 0.08825019503451581, 0.09870105975797627, 0.12169985927221283, 0.09513942412908816, 0.13388359615312584, 0.11994709270344106, 0.08132003825571321, 0.10885246633680834, 0.09845746677642042, 0.12635486295165788, 0.0579851496140984, 0.07625879396669133, 0.0863575396184948, 0.08493051358454429, 0.10781212033021925, 0.9017621420546498, 0.9421902875202469, 0.9064524888039914, 0.8444887746956565, 0.9138598228644766, 0.9152566654223537, 0.9061239699954352, 0.9300828110201305, 0.9280206405295838, 0.23434990950012002, 0.2582360200349061, 0.2500172328909236, 0.2503611234744244, 0.2557558203649031, 0.2395704583847612, 0.30363009962834364, 0.23016860848593546, 0.24431080374444414, 0.31703869377252714, 0.3139227149169125, 0.3129275677484561, 0.308052962996366, 0.22039149230094124, 0.20708734868516498, 0.23221426152381153, 0.23321910918625843, 0.27047162190949814, 0.13058099976630655, 0.13399018512672245, 9.999999999998899e-05, 0.10376744064353793, 0.141889279758309, 0.1296641438479964, 0.13931398372534787, 0.20107248215961104, 0.1349300655880563, 0.13184263429868448, 0.15955486926638696, 0.14562345053443548, 0.1334410165344141, 0.1563522005770106, 0.12999646044426905, 0.14607670890162916, 0.1323735868383279, 0.15560930658334582, 9.999999999998899e-05, 9.999999999998899e-05, 0.018350918425152685, 0.003221808916510027, 9.999999999998899e-05, 9.999999999998899e-05, 0.007459402534009341, 9.999999999998899e-05, 0.016573021487357287, 0.09087618611524029, 0.0959499444439218, 0.15266605825390667, 0.07432563668704939, 0.07665976423249543, 0.03608332911743384, 0.09466148375562367, 0.0787245356771431, 0.08977845166848897, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00220134724813692, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11589799590181937, 0.14330701003921564, 0.06483288046247904, 0.11808908119916828, 0.06100775266005787, 0.11082794759453973, 0.07480529429213822, 0.10751157566629976, 0.10955338335457021, 0.4246514350874452, 0.4249417661361815, 0.4100080472874994, 0.43524376059815273, 0.40600830934803367, 0.4057810621966601, 0.43080143661725134, 0.4339367309111334, 0.42613254049776417, 0.10658343940456783, 0.09329477786300722, 0.09958224486046474, 0.13407213042976562, 0.09232076593142535, 0.11329854107936321, 0.12015634071119308, 0.13167801945854152, 0.11358363710374686, 0.15941706355622587, 0.2106414424331644, 0.12911304134962243, 0.21916972677415647, 0.18987289376032157, 0.23105339848802953, 0.13070208124973015, 0.15948086679912266, 0.1761611431799085, 0.2984135846946796, 0.3117959582283535, 0.3095896968131864, 0.21470345383684564, 0.294106500717332, 0.2975207969377861, 0.3049137098188125, 0.27576910308168756, 0.2689752785310212, 0.2184064322110154, 0.24548881057063132, 0.2472591268878147, 0.22612746215821022, 0.2001465833421897, 0.2254222529240032, 0.23990157966391223, 0.2008390318067923, 0.18497884672190246, 0.24748163713632576, 0.21643709977059344, 0.22624946561070636, 0.23580055380087162, 0.2388071860134855, 0.21639300075688506, 0.243667733555053, 0.25145957666800345, 0.23059478031263592, 0.18846695884711584, 0.1779779368715364, 0.17174073326106187, 0.22693643055534984, 0.20395808190644737, 0.18679899072331996, 0.19625004330510787, 0.18646281900509865, 0.18848561388474172, 0.17940982065412392, 0.1845450453818852, 0.18505158744207129, 0.15657382526425212, 0.19851087415131685, 0.16267879839154264, 0.14060653753543606, 0.6587629959629198, 0.561138649004048, 0.5104486209206591, 0.20883788724614138, 0.4165546494521374, 0.45739159020520037, 0.1667836838933595, 0.1674383578854669, 0.16542698569590608, 0.1640787520602467, 0.30776433466040576, 0.18141915562325606, 0.17436407680833166, 0.18206206398533809, 0.19169795006793278, 0.21919784373209927, 0.18934163155728334, 0.18005396779079985, 0.1811949868805136, 0.1843686946421612, 0.081260792069622, 0.09577047602156274, 0.09375206306916262, 0.07779187876565541, 0.0899532095434934, 0.08119540591640595, 0.09201361034910893, 0.08461061053833108, 0.09267364214634799]}, "mutation_prompt": null}
{"id": "9e607ab1-3d45-42ce-9779-136faa328905", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) ** 2:\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget) ** 2:\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate * (1 - evaluations / self.budget) ** 2:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy and \"Archive\" strategy, with refined strategy based on probability 3, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation.", "configspace": "", "generation": 72, "fitness": 0.21040989761289175, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.43193577528880467, 0.5108018417951706, 0.43991746554503464, 0.43336211926912216, 0.42286331411021405, 0.49777654713727437, 0.42112109509105533, 0.44102605638545334, 0.4540290709216068, 0.0018456794340054872, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005728365783194134, 9.999999999998899e-05, 9.999999999998899e-05, 0.003919370676143452, 9.999999999998899e-05, 0.118103656238992, 0.13862666461873396, 0.09817319855586681, 0.07033076706984942, 0.1192617165698121, 0.10086216719334484, 0.09719634080694317, 0.12872479204336162, 0.09408493265033835, 0.08653186825647607, 0.10883799774349368, 0.09495820746593198, 0.08112135817016863, 0.07533574630645579, 0.09119110736171043, 0.10148425036313924, 0.08891058381753614, 0.0713634298253717, 0.9202984617072413, 0.948120163659617, 0.9026150294454423, 0.8595575808797651, 0.9272956884587111, 0.9015676249115322, 0.9294487135524768, 0.9387531192106028, 0.925335372331618, 0.2542585727312373, 0.2314762337744941, 0.22398325976061406, 0.22931220007152886, 0.231900051275983, 0.2118829375278415, 0.22240515747045997, 0.22566788793230408, 0.1981787426330729, 0.2595987290580326, 0.2791993651811083, 0.23978764383120355, 0.2084127832219197, 0.3377045891454451, 0.2596255354186128, 0.2564781336783568, 0.2002440203976329, 0.2785501571374909, 0.12756028745153802, 0.1271361501927034, 0.14270952454299113, 0.13186344673748462, 0.1241553930475946, 0.1492138115605156, 0.11780696088584808, 0.12447860588181847, 0.151914815182302, 0.1706050824082277, 0.12087487367373073, 0.10764296764302583, 0.15832764998573456, 0.13951971077328307, 0.139523889649094, 0.15687752321052506, 0.12527741232942202, 0.14199174093947564, 9.999999999998899e-05, 0.00010538239677593264, 0.014057291805570693, 0.00456043524241434, 9.999999999998899e-05, 0.0011873713301181477, 0.009547538156460922, 9.999999999998899e-05, 9.999999999998899e-05, 0.19431599282461554, 0.05849446462005148, 0.15172130682934637, 0.09263214904838879, 0.08289002224373143, 0.047771316974746125, 0.19713416598261502, 0.11432945826716445, 0.09517185694057351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014954545268513364, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11374008002704106, 0.1039914640020756, 0.09125587250899281, 0.11092309687997626, 0.10519477415116674, 0.061138431916133995, 0.11838120363314975, 0.09776194988699194, 0.11354804642784311, 0.4286941009256515, 0.3911061902384062, 0.3817200128484839, 0.3873220769060044, 0.3908226037948469, 0.3956188923732853, 0.39393065759781665, 0.3970785655001372, 0.42760902432422077, 0.10197278736975857, 0.09210728075623598, 0.07112436258691557, 0.13033546260467044, 0.08760101450795954, 0.11587411351307586, 0.10508382884532219, 0.10704058269039729, 0.0953446454335215, 0.15354109083897782, 0.1858396662070706, 0.16794690992651085, 0.15738717945499137, 0.1952732287678629, 0.16575461415202786, 0.17134322337968277, 0.19778812800405499, 0.20281858565159216, 0.29317880709583743, 0.2891181899074692, 0.2786410160090399, 0.2702097785422798, 0.29177777269429817, 0.2953460215043593, 0.24281497750677195, 0.2568203549253554, 0.23568439782969086, 0.23409402909287036, 0.23587821383318575, 0.2077596551219142, 0.23151424763647188, 0.23575543957588074, 0.21281138864678784, 0.17848637095198194, 0.2274974761872952, 0.16243959398981878, 0.23317417831037845, 0.2279269960462823, 0.25979092706336815, 0.2508156428032584, 0.22460625205628948, 0.22763036338908071, 0.23668335998837842, 0.2184932863524145, 0.2309883440297822, 0.17589303979963733, 0.1896006134016106, 0.18344292732488343, 0.19320729315327478, 0.18922234242379365, 0.17769494366578986, 0.22985339420281303, 0.2024337741377823, 0.1713875403905042, 0.18452016894954992, 0.18652832316044177, 0.1869867600094618, 0.11772302565205861, 0.19723347344330455, 0.18976872691945423, 0.14194502561013456, 0.6461052579909707, 0.7385295571978916, 0.5373898192153518, 0.4692413911344451, 0.36236685645633515, 0.45023592653069255, 0.3270856615629162, 0.16666326595181724, 0.16684620267556527, 0.3330683731528912, 0.3564749527260893, 0.19272652804873946, 0.186937867365514, 0.18516396050241624, 0.18136029441060486, 0.17598242102599637, 0.17845738270941058, 0.18738434945285098, 0.21215771846679388, 0.18472330066558318, 0.09042685944682871, 0.08648696716120907, 0.0896251100024108, 0.08375705402305922, 0.08918704191411908, 0.08519987714827892, 0.09213801288593981, 0.09281669382779634, 0.11452612304374121]}, "mutation_prompt": null}
{"id": "7a4dd1a9-c4e7-4afc-95f8-360da45dbdea", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.simulated_annealing_rate = 0.05\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                # Simulated annealing\n                if np.random.rand() < self.simulated_annealing_rate:\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and a new \"Simulated Annealing\" strategy with adaptive cooling rate.", "configspace": "", "generation": 73, "fitness": 0.213445643988907, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.445052695893577, 0.4548288715797949, 0.4669832215804971, 0.42485706621454655, 0.4115236580590238, 0.4260892998099711, 0.440689130527365, 0.4363144398403628, 0.4681229769137655, 9.999999999998899e-05, 0.06742029491583656, 9.999999999998899e-05, 9.999999999998899e-05, 0.0053502419877761165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10646439372295247, 0.13201458860436321, 0.08809157501734954, 0.09648695753621828, 0.09345160610982528, 0.07631432454837106, 0.1478321104147985, 0.12084258709833373, 0.0952245609746667, 0.09491060381401673, 0.11257923566467776, 0.10248325456178575, 0.12243918662214148, 0.07800766058191244, 0.07001287529266831, 0.1063935499385592, 0.09488912056782706, 0.07885916741723631, 0.9013715937252565, 0.9450935501608888, 0.9037883611498417, 0.8311869499068649, 0.8908482761545732, 0.8669362350132023, 0.9106217079951178, 0.9127471507016213, 0.9245378888941901, 0.2761054157404861, 0.2537095502609379, 0.24387191005599318, 0.2425614678944228, 0.2766533166357673, 0.23622567402053396, 0.23371633433418815, 0.24672553710591294, 0.2150241464543141, 0.2462669238709776, 0.28889815313542544, 0.23360426203844364, 0.2374140553827474, 0.7716374990442514, 0.20273527660253354, 0.6605539789198336, 0.28904806178672393, 0.3087294552354982, 0.16506087372345213, 0.1299779145675105, 0.15733164775045794, 0.1255941553817982, 0.12246920366077951, 0.12892669404526402, 0.12163717522601214, 0.10795529268719184, 0.1355743512877483, 0.1420610357486185, 0.1384404295878341, 0.16115606337886434, 0.16670148577337152, 0.1378436350904907, 0.12427430342030998, 0.1361490710074158, 0.16512156928429467, 0.13867875892984505, 0.03042849762698774, 9.999999999998899e-05, 0.00012412177917486833, 0.01346152599464645, 9.999999999998899e-05, 0.0009589149293546262, 9.999999999998899e-05, 0.0005385688707422176, 0.0029168933218809423, 0.08898918457349259, 0.07734082313274793, 0.1276567038620131, 0.09879449890915326, 0.058709806988012314, 0.04119104567386089, 0.09840638461191886, 0.09470515246892719, 0.069562382882985, 9.999999999998899e-05, 9.999999999998899e-05, 0.019420327354088274, 9.999999999998899e-05, 9.999999999998899e-05, 0.009069175954813158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13801673927145475, 0.10331316215414577, 0.10373922227762, 0.09528439687520462, 0.09173844879861659, 0.06496669173441172, 0.1137340067337318, 0.07684140062431799, 0.07611647170524993, 0.4087452893203486, 0.42903253677184583, 0.4125991243402529, 0.4025711440467691, 0.375566117363202, 0.43207918854593097, 0.40474543117649964, 0.4105830014309153, 0.42834445798168286, 0.09748754404282123, 0.11877085676967092, 0.09706805254940643, 0.1235164463953271, 0.11411115565859875, 0.13693212118596587, 0.13859443624212986, 0.10732297780393474, 0.1431231402001404, 0.19867489146107542, 0.13501925021644712, 0.14273695567198463, 0.18275075745055347, 0.17445152592435154, 0.18934184129125087, 0.1547811776780199, 0.16550769974158697, 0.16487639825016798, 0.2827054477173162, 0.26840901892958624, 0.29467908646444907, 0.28105888990791617, 0.24331166539393623, 0.2980911972974887, 0.2409011906955677, 0.27778106555551774, 0.2706845794334559, 0.21513631906298292, 0.24293539668868103, 0.250384250967854, 0.2440808001994199, 0.2464091308026023, 0.21617684310242213, 0.16561490940913792, 0.21066003704635672, 0.17677257796789758, 0.2593024792260925, 0.25063146645752876, 0.21069058353727865, 0.23278408631178404, 0.209826774792909, 0.25371923916544925, 0.2217913390499392, 0.2234984846426139, 0.2269927375586076, 0.18596545289957556, 0.199612040947314, 0.1897674082321299, 0.18595519546581774, 0.17303597549841143, 0.17471574839878923, 0.17335689482236305, 0.18441500383627962, 0.178317935272005, 0.1299722089948223, 0.1859578874051636, 0.18580220545951687, 0.17144673649024045, 0.19651795555548457, 0.5201421077611827, 0.14062737795036373, 0.6760986449615299, 0.5839546868983456, 0.5295926385182457, 0.20756011602465085, 0.20223225331933414, 0.3625239268937218, 0.1643291445236832, 0.16706950401148024, 0.3579991825173806, 0.36034826467049885, 0.3223519654889666, 0.1925496944199453, 0.1957941875289283, 0.1877225621553078, 0.17612638755696175, 0.19753162764562715, 0.1960391855820678, 0.18379808133969489, 0.182720631628576, 0.18736622008983672, 0.1021128358622796, 0.11092503106035567, 0.09497836056299402, 0.09323371430093097, 0.11552502169072254, 0.08098305056679311, 0.09221305876137742, 0.09896899277430493, 0.08381868067266585]}, "mutation_prompt": null}
{"id": "21868e4f-58ba-4466-b490-9f00736a257f", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.surrogate_model = None\n        self.surrogate_model_update_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def surrogate_model_update(self):\n        if np.random.rand() < self.surrogate_model_update_rate:\n            self.surrogate_model = np.random.uniform(-1, 1, size=(self.dim, self.dim))\n\n    def surrogate_model_evaluation(self, position):\n        if self.surrogate_model is not None:\n            return np.dot(position, np.dot(self.surrogate_model, position))\n        else:\n            return np.inf\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if np.random.rand() < 0.5:\n                    fitness = self.surrogate_model_evaluation(self.particles[i])\n                else:\n                    fitness = func(self.particles[i])\n                    evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                self.surrogate_model_update()\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and an additional \"Surrogate-Assisted\" strategy to reduce the number of function evaluations.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('high <= 0').", "error": "ValueError('high <= 0')", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {}, "mutation_prompt": null}
{"id": "54cb066c-facd-4525-a536-89ce56ece9fa", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.98\n        self.adaptive_cooling_rate = 0.6\n        self.levy_flight_alpha = 1.2\n        self.levy_flight_beta = 1.5\n        self.opposition_based_learning_rate = 0.3\n        self.inertia_weight = 0.8\n        self.inertia_weight_damping_ratio = 0.995\n        self.mutation_rate = 0.15\n        self.mutation_step_size = 0.15\n        self.velocity_clustering_rate = 0.15\n        self.particle_filtering_rate = 0.25\n        self.archive_size = 15\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.15, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(4, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(4):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(4, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(4):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.6 * np.random.uniform(-1, 1, size=self.dim) + 0.6 * (self.best_positions[i] - self.particles[i]) + 0.6 * (self.global_best_position - self.particles[i]) + 0.2 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.15:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.1:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate.", "configspace": "", "generation": 75, "fitness": 0.20710493434786073, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.41030224880251387, 0.44785348954859683, 0.4765549559553589, 0.4840021463016456, 0.43962232793681366, 0.4234327883712211, 0.471661544784299, 0.4390239695167868, 0.42445795060787106, 0.001203725366831887, 0.00851369694331805, 0.053560579365832695, 9.999999999998899e-05, 0.01936779552610346, 0.0045628969107208706, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11804882752109458, 0.11049522130048683, 0.0769980707184077, 0.119754285288595, 0.09888139070880353, 0.0854072924181406, 0.11557082040628797, 0.09520574644898294, 0.1358973375794641, 0.07633128354380792, 0.06355152884352933, 0.0971236797313435, 0.09762861660907851, 0.07874310009652818, 0.10331280023399281, 0.0819220049032261, 0.07239910168865749, 0.07875654521250508, 0.8886250793636781, 0.949422237969009, 0.9193211868180295, 0.8728048092397538, 0.8582715446697857, 0.8644912364215507, 0.9224031527698011, 0.9335429023213375, 0.9049205062114211, 0.2637172636377719, 0.26110677003480476, 0.2190792722286371, 0.23823850080400777, 0.26903412835784934, 0.2387432382836432, 0.2611453508662993, 0.2392603936924591, 0.25007314420013904, 0.3329122820917204, 0.3107220976248587, 0.2618062144926996, 0.20975503064950962, 0.21051340350264847, 0.2559063045669484, 0.23284937617258705, 0.21326868739918148, 0.24703780343082504, 0.11060823510264162, 0.1421958803976342, 0.11329494033631948, 0.14686145173539622, 0.1678426029578035, 0.18216571619617639, 0.12882772119430885, 0.13821939849502518, 0.1217492422097155, 0.14866541728684346, 0.09530913183887002, 0.16599520164989667, 0.14754372055512466, 0.14975829778550265, 0.1386981565841292, 0.13861016640215806, 0.15730075986891168, 0.13358790798712272, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03467946580369918, 9.999999999998899e-05, 9.999999999998899e-05, 0.01102174749314977, 9.999999999998899e-05, 9.999999999998899e-05, 0.1593095869262361, 0.05617174626608068, 0.10948991408910247, 0.07080636602671764, 0.07702920795085444, 0.02892380359488511, 0.128827597592719, 0.07443284241191306, 0.06861033423837448, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10157525319131622, 0.10029055640869888, 0.10284330987702739, 0.1109778462710519, 0.11945541946565486, 0.07078166520659834, 0.09790374814092118, 0.08780471234530973, 0.08012436795890843, 0.4261146934847344, 0.40079806044584454, 0.3983127807371203, 0.3915724871997943, 0.42393113923896086, 0.3945910822783476, 0.42205746284914547, 0.43263421224015497, 0.39934498997594015, 0.07421322929157415, 0.09240833580506291, 0.10230154951909698, 0.110527099412837, 0.10347054508331366, 0.09748800032840332, 0.09098038263052599, 0.11371465239970457, 0.10976865067342101, 0.20309661123539258, 0.16544850333280825, 0.14444194338334004, 0.1737390436769385, 0.16012305135142646, 0.2197063164137426, 0.18031340583049282, 0.1936306876509396, 0.2045121510968715, 0.2737905021533953, 0.26654382544798827, 0.26080505233603324, 0.2136628986245912, 0.2959900776482751, 0.2587953154810809, 0.2680542705002519, 0.2700138857434723, 0.214975876314205, 0.20045239971417161, 0.2275573883749865, 0.21478141052103383, 0.22974799592062922, 0.23457796006522869, 0.2150311730958152, 0.1990760072202864, 0.22965073197107866, 0.17982366113673343, 0.23049488040940103, 0.21857665110812807, 0.24785207382708008, 0.2514524515029165, 0.23231099864930516, 0.21424892321007105, 0.22605564927688804, 0.22988500896007924, 0.2116221644582158, 0.1847621272020945, 0.18961055652328884, 0.17635925133939256, 0.1805963603594415, 0.19574448180265747, 0.1726517556172421, 0.17861165855935046, 0.2009062850410932, 0.17844951634187567, 0.49634164613987497, 0.18635373564661362, 0.18631836479398844, 0.5599487341489883, 0.19706651074739934, 0.19526227035825472, 0.14093415273739407, 0.16470147799256807, 0.6593669924140222, 0.437909446903204, 0.20698867337397409, 0.44298973635173733, 0.3269143101698043, 0.16645047083341158, 0.16635553627265476, 0.16565592110984073, 0.2192254585045611, 0.42256493616229995, 0.18387644129248926, 0.18910165787478161, 0.1904710429744496, 0.1719033517387465, 0.17868223836380726, 0.17349991420336042, 0.18661820789906203, 0.18340938417958264, 0.18729972369608539, 0.09221210059708251, 0.09226784422213363, 0.10785160884495304, 0.08779660606034445, 0.1326959438019576, 0.09647524796944673, 0.08335747292669782, 0.10068570153280454, 0.09293753542122574]}, "mutation_prompt": null}
{"id": "b0e6e168-1f0d-4dc9-8c99-b8b975cfec41", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update with probability 2\n                if np.random.rand() < 0.5:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                else:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i])\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate.", "configspace": "", "generation": 76, "fitness": 0.215789005982464, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.44269035962052006, 0.45387475775673625, 0.4797681562097488, 0.4649551311676712, 0.4614594425309516, 0.47786957064124325, 0.44010885249503584, 0.45945100905810954, 0.46229058581993665, 0.012417565134346886, 0.034686367183130784, 0.005994186871088436, 0.0018178567109927712, 0.002555932647310688, 9.999999999998899e-05, 9.999999999998899e-05, 0.002976950942813694, 9.999999999998899e-05, 0.12701304118646695, 0.0941394141031816, 0.08200724530832137, 0.09762233555764, 0.09763867404412052, 0.0940425169581518, 0.1004128318038423, 0.126389867796864, 0.11861924343099295, 0.0905694695030026, 0.08586650525085548, 0.08384574564696978, 0.10913701473592496, 0.0661311810628753, 0.10529088423389454, 0.09658506624827656, 0.10012983419034993, 0.08491674204391986, 0.9090700692478644, 0.9392461777669154, 0.9040524385566702, 0.8432690163672205, 0.8841523735689157, 0.8555555606397365, 0.9015882625559626, 0.9176290279604545, 0.9189877483323166, 0.28934995787780593, 0.2420772956665338, 0.2680261709031867, 0.2394722913008297, 0.22601848872335217, 0.24690792099957526, 0.2492683858994188, 0.26338098932517096, 0.2573464308362997, 0.5201392419836062, 0.3193986439041343, 0.3235837066635514, 0.25799245220494027, 0.25372565906842226, 0.30971934223729547, 0.29946443568637304, 0.23234852001725104, 0.28672747223604267, 0.18717542393437148, 0.12542674889870542, 0.13708800652795783, 0.12765422945037885, 0.12757500165291114, 0.1233832302486022, 0.12594892222508802, 0.18379355769367256, 0.15701246643001154, 0.13805296273721268, 0.1351251039410688, 0.1678935877965403, 0.1718153988816029, 0.1410409800365816, 0.13931103378157061, 0.13133700309785412, 0.17710569636875584, 0.15631304721488248, 0.004662115120770638, 9.999999999998899e-05, 9.999999999998899e-05, 0.021622378824698307, 0.036670344997539406, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005016986799264433, 0.0025644717106523274, 0.12085571458162359, 0.07493669708130479, 0.11863022612277241, 0.0757676856196482, 0.07240219375077817, 0.014228999238605322, 0.08210296711193588, 0.06337656964473104, 0.10413015669449155, 9.999999999998899e-05, 0.009288156195904729, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01072006942748871, 9.999999999998899e-05, 0.03960697019181281, 9.999999999998899e-05, 0.14464390073877675, 0.11712816641465162, 0.11207233612055478, 0.09944264336787878, 0.1288340542819285, 0.11737300699008812, 0.11057792853166015, 0.08495052305687933, 0.08593709564765728, 0.4228592054525516, 0.42151605300551986, 0.41446698560495965, 0.3776684547949559, 0.39847045614054155, 0.4247311362756302, 0.42043914229743706, 0.43702405734473904, 0.4543531209494417, 0.08253712449932604, 0.11351555948541026, 0.09312808134077821, 0.08702386235284976, 0.11251736710302063, 0.1227826990316706, 0.1123505569560046, 0.10269442588558597, 0.0768905810363485, 0.17556238205875851, 0.14951719902763838, 0.137644113198506, 0.18887762834508726, 0.18253214327607437, 0.1566459126073263, 0.18549395554677672, 0.13218509008157275, 0.2345900125188849, 0.3028165769281641, 0.2821402561599007, 0.2871588160771166, 0.2780531348872164, 0.3010965937933706, 0.2754293416248068, 0.22364407816834608, 0.2608672907502487, 0.300139180968782, 0.20732578559264925, 0.20443493014124814, 0.2593425476569221, 0.23878388463118527, 0.25743383094065053, 0.23020650628297357, 0.17690958614518748, 0.21165153968121653, 0.21441658349960613, 0.22817648190105455, 0.2667329750916275, 0.21850342496629505, 0.2021676789782617, 0.2174303964480485, 0.25484969232166754, 0.27971034108782644, 0.21610614774921844, 0.2482454371434304, 0.18455472890920332, 0.17291654045872673, 0.18928032897918678, 0.1977707793266431, 0.19059461274781864, 0.18048427570186543, 0.21582127373254711, 0.1837089350141462, 0.18172122244786648, 0.18515402826500338, 0.18504524344032292, 0.14617456919170402, 0.6378154520126434, 0.19879471307555463, 0.14558798626529168, 0.15136171486895822, 0.620184481572422, 0.6755079987732098, 0.4432241813676753, 0.6102363873857416, 0.5762579645353936, 0.20732260331648955, 0.16577738729417923, 0.16587556102163103, 0.16675585186714148, 0.34878540776273914, 0.2970462608244686, 0.17038691578397325, 0.18595739804577793, 0.17746668740503813, 0.18797969113441837, 0.18496038544706217, 0.19497084807666576, 0.21317588855405234, 0.17680787689224942, 0.17868536278956804, 0.09722018862699644, 0.07295804910923676, 0.09050059737341676, 0.08886958015118618, 0.11179198068856044, 0.08647999269602291, 0.09358030667659145, 0.08903710263321629, 0.09489371464754115]}, "mutation_prompt": null}
{"id": "c101ffb8-f243-4875-8b7b-81d791091362", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.memory = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.memory_size = 5\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def update_memory(self, position, fitness):\n        if len(self.memory) < self.memory_size:\n            self.memory.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.memory])\n            if fitness < self.memory[worst_index][1]:\n                self.memory[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    self.update_memory(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                        self.update_memory(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                        self.update_memory(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Memory-based position update\n                if np.random.rand() < 0.05:\n                    memory_index = np.random.randint(len(self.memory))\n                    self.particles[i] = self.memory[memory_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                        self.update_memory(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 1, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate, and with the addition of a new \"Memory-Based\" strategy to store and retrieve the best solutions found in previous iterations.", "configspace": "", "generation": 77, "fitness": 0.20864253595716248, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.48612447733371555, 0.46182775071477844, 0.48081057015149753, 0.42977413607512394, 0.444188592378045, 0.46589809250759195, 0.45257153738746825, 0.459084370786235, 0.46011177093182154, 0.008181745010653496, 0.0006507823530668144, 0.004251297280298272, 9.999999999998899e-05, 9.999999999998899e-05, 0.003857173704454153, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13800685750193187, 0.10526155585208397, 0.0919973644722617, 0.07956437357029444, 0.11009413012595493, 0.09063502319501171, 0.1080401459320699, 0.11520637421845659, 0.11288684279326766, 0.1021324229902808, 0.09832742359671098, 0.0960575279523862, 0.0907522719689372, 0.08594838878765398, 0.08500726192640307, 0.09295225996671563, 0.09275749535522448, 0.07230521684794822, 0.9028186132042185, 0.9333184790007536, 0.8865422531947372, 0.8747981735188417, 0.8864513568893069, 0.8377023931276648, 0.9270876075378476, 0.9203935044717116, 0.9268869023557633, 0.251699190062579, 0.26894395491076684, 0.23485300582251212, 0.22252337902304375, 0.24403410828470795, 0.2720537507253642, 0.2471849743225646, 0.2206917071617579, 0.24820933228261732, 0.2736863607171244, 0.353335213951226, 0.31540807280276717, 0.2513408141123685, 0.2640569771481479, 0.20047968890618217, 0.2313453874578698, 0.21211288701956588, 0.2613569739855607, 0.14482575474670356, 0.1273236483186222, 0.17686855958151393, 0.08654118503226615, 0.2373349336054147, 0.21517328102581879, 0.16105115742948017, 0.15464849438772832, 0.1428014249026841, 0.168086871132614, 0.17143774236022213, 0.15562777092041646, 0.1406826213580693, 0.13887789400016592, 0.14388143875226556, 0.1429606744684353, 0.1842944570600885, 0.15825407468421615, 9.999999999998899e-05, 0.0069504397616340086, 9.999999999998899e-05, 9.999999999998899e-05, 0.018402073437023825, 9.999999999998899e-05, 0.017990614405372418, 9.999999999998899e-05, 0.005393668880076752, 0.1221017275286782, 0.06378142789469987, 0.10931320462370409, 0.09371803259500755, 0.08251536884276933, 0.031904693854006516, 0.1565594591937095, 0.12306451108897087, 0.08567819046084879, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014526336149125463, 0.015483833686511406, 0.013486147291847383, 9.999999999998899e-05, 0.11530927571038696, 0.1177034172178032, 0.08698327558098429, 0.10917414656856617, 0.1256422867586372, 0.07604857554478583, 0.07814318972072831, 0.09909810062347646, 0.12176191953719862, 0.42401255240772573, 0.4184016303856035, 0.4154689210479281, 0.3839871952608416, 0.389949408274462, 0.40282236738418453, 0.42322555555872654, 0.414514276233949, 0.39829180545277176, 0.09373165016994423, 0.12398244455351959, 0.12495239629226929, 0.11101354669887309, 0.09210909910512544, 0.09820282687915294, 0.10521194979608117, 0.09311859242999965, 0.10492759579580346, 0.13886413017963495, 0.16907390204542294, 0.13871847844891383, 0.18429147532479284, 0.1705639610027163, 0.1794362860692872, 0.16289406884207747, 0.2338444550689659, 0.15428437335612288, 0.3033964596980038, 0.2904719583034433, 0.29186272800766566, 0.2587194123592712, 0.255916473795346, 0.2965720895695755, 0.30984413961344504, 0.3169766601352464, 0.2749220156446428, 0.20393554077426057, 0.1976712254762898, 0.22553672588295925, 0.24709432537015286, 0.2161757362739508, 0.205498350713327, 0.21948272912839606, 0.22382721372917702, 0.19380539110110373, 0.2385125155478286, 0.21140809380131176, 0.23269879055696263, 0.23063212783896136, 0.21011697603263957, 0.24392796700821762, 0.27113176980966647, 0.24320006372780678, 0.256803478753994, 0.19792650439340587, 0.1742962648217532, 0.19004941433440803, 0.18448112759316415, 0.19378733953311544, 0.1713828602731441, 0.18740527294494547, 0.17298485472530234, 0.1887984219126312, 0.1845626619660714, 0.1863649786965913, 0.18647435725586725, 0.15025835103161955, 0.19858009187955927, 0.19524366879361443, 0.14129285139677816, 0.15711169244202194, 0.16500815046641326, 0.5883921177993715, 0.4336000607810113, 0.45742440442652554, 0.3629255025963368, 0.28032000278314595, 0.16568452306140902, 0.1669227129729397, 0.4478176674062203, 0.35067475805861115, 0.1758675420783029, 0.18154703602001265, 0.17294491406469603, 0.17802956824981242, 0.18000461606854912, 0.1678940203892626, 0.17656024891996025, 0.18052116261709872, 0.17606689037392353, 0.09759275348740903, 0.10500737466750487, 0.09556312062248995, 0.11606765815081266, 0.0797109665080803, 0.08128910821460011, 0.08273442104172013, 0.09871884550355703, 0.09634850884980806]}, "mutation_prompt": null}
{"id": "a621446c-2d39-41c6-b435-60cb0eef5748", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update with probability 2\n                if np.random.rand() < 0.2:\n                    self.velocities[i] = 0.5 * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                else:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate.", "configspace": "", "generation": 78, "fitness": 0.20802796962889702, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.44855662027112, 0.4979161964756563, 0.4712996305537823, 0.44451472634063693, 0.4649418813808116, 0.45018288507916127, 0.44762109766594327, 0.44941203565527854, 0.45241022580981805, 0.0034665111266684034, 0.030685867588758797, 0.022315783666230216, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00026794845258315547, 9.999999999998899e-05, 0.10253796955694872, 0.11113760324781363, 0.10648701367960078, 0.07988413393453431, 0.10386900639346663, 0.10637738364311988, 0.08638062310565531, 0.13592534124050237, 0.10347394298141932, 0.08955296018170922, 0.0838778552127376, 0.11665373165040438, 0.08993928534030382, 0.09450750646934791, 0.09392614829064883, 0.08648433008927836, 0.09657899515346013, 0.08775061419338492, 0.9211756601802514, 0.936702274698799, 0.9014552455218788, 0.8531788921215163, 0.878886727139935, 0.8750221305116709, 0.9264272814443137, 0.9215646042697249, 0.9116271888118437, 0.2637427813887989, 0.26335363262606004, 0.2601341302329615, 0.24349688161396543, 0.24448023593053914, 0.26519445482215953, 0.25393902224168374, 0.21417369315603751, 0.25564631410903416, 0.3490381456592315, 0.33081577746944, 0.3324775252978889, 0.260528191462745, 0.26511400002341357, 0.2296660897218421, 0.281069100962955, 0.3142814382213315, 0.22108210852272792, 0.1375221903339412, 0.1317756976448391, 0.13098222377304047, 0.0898993899025825, 0.17158417206566878, 0.17919578936164848, 0.14991844856135017, 0.1376936458663931, 0.13393866491929962, 0.13412462027890304, 0.17426334279572642, 0.18289384852841706, 0.14919390267856036, 0.1351215085341806, 0.1521828313954222, 0.15436903140541014, 0.14510154415342835, 0.1716873639588744, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000101448711016916, 0.06837437843156713, 0.03230450733046486, 0.0011494227005710567, 9.999999999998899e-05, 0.0003919239079350767, 0.07490160299430082, 0.03330065228700296, 0.14435447964691506, 0.07866048133311665, 0.12525741611517294, 0.02245905574338558, 0.12760588005290652, 0.09754123841970885, 0.190280728499866, 9.999999999998899e-05, 0.00014465220510828658, 0.010704860691488793, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002426307982973941, 0.0016334792497521011, 0.10927893720234838, 0.12608151487747254, 0.1155610647078602, 0.10195723830977443, 0.13648632767874058, 0.08862790587357927, 0.11312283038781057, 0.10216981517632973, 0.07281026012516523, 0.3990088107074382, 0.42757068978378143, 0.4407035750116808, 0.40646839338312646, 0.4054017003606363, 0.38216344342164776, 0.39763718430057693, 0.4368552151569023, 0.3983201798377596, 0.11520976054284293, 0.11910270410452306, 0.089531731975659, 0.10641409447617278, 0.09853135305714167, 0.10112640145131213, 0.10963179956577007, 0.09628848508793963, 0.1298040337489489, 0.14131524663076211, 0.18208993367333737, 0.14083025048220532, 0.16514925028324523, 0.17284340656202424, 0.18826294863377535, 0.20043272932835154, 0.15477299679060874, 0.2148745988655577, 0.30522231726401794, 0.2900866295727176, 0.28221241707213307, 0.2736436826627334, 0.30181179934059543, 0.27966628047749753, 0.24541036573676478, 0.27441488697284777, 0.2672512585260858, 0.22440300207931496, 0.20390420563843492, 0.2346178327098265, 0.2150214011419027, 0.23111008997930182, 0.18831944955012847, 0.19415661340699908, 0.2303783445471973, 0.19898324454830962, 0.25907693142735777, 0.22817438284281677, 0.25062441608160435, 0.2422686771181003, 0.20953367775287468, 0.23494075351396304, 0.2259694545624853, 0.21914253414608142, 0.2253191998908569, 0.1846884000883675, 0.17650844750283956, 0.16976591215981085, 0.17809892606870859, 0.19977541623476347, 0.18509429151651513, 0.1947020962018693, 0.1848097849132011, 0.1738869564133616, 0.1289182738141661, 0.18533757484338897, 0.18633211647660186, 0.1493820267887791, 0.19688143481791565, 0.19534976548957628, 0.1413100228653993, 0.1489087766299575, 0.6122681437154396, 0.45442360252470193, 0.2086072263637877, 0.5251914574741116, 0.3408927743951654, 0.164719061038628, 0.16688845845299438, 0.16659547232920902, 0.28671951145458685, 0.16760466766077298, 0.1975618308299919, 0.19016433277823275, 0.1911520469825796, 0.17876915779475078, 0.18731041607825183, 0.20126989042819166, 0.18293879191056983, 0.17123530757568806, 0.18595012774765496, 0.07693258258401037, 0.1155390318371412, 0.0915056443129173, 0.08629167258613801, 0.08819240323843491, 0.0889930476879548, 0.10172900472618329, 0.08430274937229953, 0.1107920279559137]}, "mutation_prompt": null}
{"id": "09559f99-79f1-4f64-bb38-c2b3b9d9c9d5", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.98\n        self.adaptive_cooling_rate = 0.6\n        self.levy_flight_alpha = 1.2\n        self.levy_flight_beta = 1.5\n        self.opposition_based_learning_rate = 0.3\n        self.inertia_weight = 0.85\n        self.inertia_weight_damping_ratio = 0.995\n        self.mutation_rate = 0.12\n        self.mutation_step_size = 0.12\n        self.velocity_clustering_rate = 0.12\n        self.particle_filtering_rate = 0.25\n        self.archive_size = 12\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.012 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.12, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.55 * np.random.uniform(-1, 1, size=self.dim) + 0.55 * (self.best_positions[i] - self.particles[i]) + 0.55 * (self.global_best_position - self.particles[i]) + 0.12 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.12:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.06:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering (HSO-ACL-OBL-DIW-SAM-VC) that incorporates a new \"Particle Filtering\" strategy to enhance the convergence speed and diversity of the swarm, with refined strategy based on probability 2, including modified velocity updates, adaptive mutation rates, and enhanced opposition-based learning, using Cauchy mutation and Gaussian perturbation, and a new \"Archive\" strategy to store and retrieve the best solutions found so far, with dynamic inertia weight and adaptive cooling rate.", "configspace": "", "generation": 79, "fitness": 0.21254814450412282, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.505548230927561, 0.45148167916662907, 0.4503327760098331, 0.4470306510795754, 0.4126203813404542, 0.4371073290493843, 0.4768868032929994, 0.414058754850141, 0.43863775489093493, 0.06650490370554885, 0.03652727372882236, 0.007903762096664435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020229594989452426, 9.999999999998899e-05, 0.12361926526083467, 0.10358295052166522, 0.07733628896903721, 0.13159208801366562, 0.10714205348814798, 0.11519194514194842, 0.10275789656366996, 0.1221743632283604, 0.11334648043405726, 0.08314367549965485, 0.09850369946490156, 0.10055994831942627, 0.09645258768487908, 0.08037301752334192, 0.09446027490740849, 0.09714751027853197, 0.10686190643986249, 0.10194246531907303, 0.915111273956663, 0.936460151305416, 0.8771557361684609, 0.8670361590881259, 0.8983386483503505, 0.8977958854965525, 0.9324950933848599, 0.8977911048601989, 0.9009523358208896, 0.24784394322135328, 0.2568068091910557, 0.28554173546927863, 0.26475052305785196, 0.2754176139223179, 0.23777631684917255, 0.22586359742943152, 0.254646257315143, 0.22376739830208303, 0.2524166448734325, 0.7094919781497746, 0.25041921985502613, 0.21173997339408357, 0.31692980670161075, 0.21709485442969612, 0.29360475640948036, 0.20352262755731299, 0.2199738087459986, 0.1553207147278386, 0.17813875679191826, 0.108366087638052, 0.10925293616279719, 0.1698768811903627, 0.11961938014516638, 0.17227929839729672, 0.1850879968143524, 0.1380223576812084, 0.13287002736935827, 0.1616040510593526, 0.12179024072813283, 0.14241812850549684, 0.12581380710991708, 0.16767171879940979, 0.14058589816279343, 0.1691832992690685, 0.12345461020661674, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014156916244441708, 0.0037821859514446388, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033654085209194884, 0.07030430445789881, 0.04830731021145962, 0.1223772747554891, 0.07899695971325349, 0.03282833644037342, 0.029084739412505556, 0.1565294662404405, 0.13220608056747385, 0.07551831096966921, 0.00012947822841302692, 0.005714005988169402, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11661253031959151, 0.1071185939364464, 0.09862921301750283, 0.09993427912061392, 0.09102849426178328, 0.06038229524641214, 0.0957598246737782, 0.09688598738551668, 0.0965592491565439, 0.39501667212088076, 0.417348730719567, 0.4038938915226834, 0.433727866549079, 0.40519136369267994, 0.38197149010189846, 0.40562480202387374, 0.4011130175869586, 0.42058996735345355, 0.09265722581411806, 0.143800344505135, 0.08268158207754095, 0.08169653355304873, 0.10507369074172679, 0.08473656596559176, 0.0949453713432249, 0.11386700163137797, 0.12431102315007536, 0.13734003520854454, 0.1440735713583433, 0.12934334999691366, 0.21784942722597256, 0.23770194297901848, 0.1785221355503085, 0.15699534323104103, 0.1466595609264425, 0.14858419228866204, 0.2925082979129213, 0.2990243536176277, 0.3000587772584278, 0.29643603604466695, 0.29753848932283644, 0.2891867788782554, 0.2817661552929419, 0.2546915552622575, 0.24483554908239435, 0.20227214086270828, 0.20931798253492284, 0.21695283500801954, 0.22633655923661355, 0.20786345092786696, 0.23244794865174123, 0.1776230117492803, 0.24038163200595442, 0.17435786099475936, 0.28919628165737743, 0.22777689776155408, 0.222889409393505, 0.23096153590637136, 0.2529720740428878, 0.21302040407170986, 0.2592778281600544, 0.22982990254390046, 0.22215310395001886, 0.17667452068779954, 0.19395977017925703, 0.17687667983374744, 0.2031655013100364, 0.21773269771656045, 0.17403813500964738, 0.1735895380968635, 0.17413805275529926, 0.17683475525656944, 0.5367083416839638, 0.18404405446396954, 0.18639395658063662, 0.6154641589978747, 0.19827442390531647, 0.19549187481044428, 0.17046058600341907, 0.1549460757291945, 0.5979984730050627, 0.5552341000572462, 0.2082579596663925, 0.4029738403158446, 0.3915569983032835, 0.20236601644440977, 0.16641897075211742, 0.16587056136754164, 0.3054442831737876, 0.4467734296225081, 0.18928917257244315, 0.17473559707430164, 0.1871233817365161, 0.1927307450016369, 0.18589582715484287, 0.18095460174404554, 0.19178131599794312, 0.1964459398970414, 0.19689911003026062, 0.09352647604718767, 0.0923320186729708, 0.06452611064438463, 0.10324679483434307, 0.10369289053535591, 0.08898231189771, 0.11079851507974636, 0.08700145889044775, 0.09058563692946175]}, "mutation_prompt": null}
{"id": "d480965b-537b-447f-9eb7-708ad98b7851", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.probability_threshold = 0.45\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def refine_strategy(self, probability):\n        if np.random.rand() < probability:\n            self.inertia_weight = 0.8\n            self.mutation_rate = 0.15\n            self.velocity_clustering_rate = 0.15\n            self.particle_filtering_rate = 0.25\n            self.adaptive_cooling_rate = 0.6\n\n    def __call__(self, func):\n        evaluations = 0\n        self.refine_strategy(self.probability_threshold)\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Archive\" strategy and a modified \"Particle Filtering\" strategy to enhance convergence speed and diversity, using Cauchy mutation and Gaussian perturbation, with refined strategy based on probability 1 and adaptive cooling rate.", "configspace": "", "generation": 80, "fitness": 0.2162389832514928, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.4543980260149836, 0.47284237499781756, 0.46342211553294577, 0.47267516144365096, 0.4601152323386559, 0.4586977272542695, 0.4825483093165648, 0.4807869748543775, 0.44500975861361025, 0.0026421916778089916, 0.009218548363312817, 9.999999999998899e-05, 0.0014585276473604303, 0.0003401599931542876, 9.999999999998899e-05, 9.999999999998899e-05, 0.0026831068425507976, 9.999999999998899e-05, 0.12531322511418042, 0.0805978194627005, 0.10912892203369462, 0.08161634381226845, 0.08134351060684508, 0.10492173090592427, 0.13301244167502901, 0.10578098578805861, 0.10353756375972079, 0.09837595658842857, 0.10059179316168443, 0.06737549044458269, 0.08503314433548748, 0.08223402185519357, 0.08586424299861861, 0.08875235413343585, 0.09197527503402603, 0.08989616067618278, 0.9137280962192874, 0.9315501323527372, 0.9127523176284317, 0.883356699979464, 0.815103083456137, 0.8801713442905237, 0.8993376185832753, 0.8992783968680882, 0.9241438167864621, 0.25918854801535707, 0.28785444438170327, 0.22351020154929668, 0.24524472755202764, 0.27764892413014297, 0.2940762020591253, 0.26938109488563133, 0.239240935023998, 0.24169466675018236, 0.2693468928513517, 0.34688536168324413, 0.21792586307861772, 0.33263029880873063, 0.7666397678054856, 0.25709147845725766, 0.20908770019084844, 0.2201415035782588, 0.26184768854710305, 0.16542855822133984, 0.1344749394240491, 0.13165339974760792, 0.03760800940960285, 0.2045322723224543, 0.12964491679016577, 0.13039415594286163, 0.1814801836499066, 0.13667114640465627, 0.16675170656740756, 0.14443106019548135, 0.15510446722832205, 0.15071881125602526, 0.14177369636590031, 0.15765598303025485, 0.14309818230278393, 0.14431618400742352, 0.14768869175331711, 9.999999999998899e-05, 0.002329690815018659, 9.999999999998899e-05, 0.0009726346473771796, 0.044391440197008136, 9.999999999998899e-05, 0.0005500449031289323, 9.999999999998899e-05, 9.999999999998899e-05, 0.12940136277217806, 0.06670539975643153, 0.16073431348781086, 0.08609366060444412, 0.08130951142863996, 0.02110630951891812, 0.14664125499236236, 0.08334992672725094, 0.061842912932869476, 9.999999999998899e-05, 0.002444728016753439, 9.999999999998899e-05, 0.0009809397425613042, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12543177477442535, 0.14025264374207114, 0.07062310164343366, 0.10956804578041124, 0.1072117001450591, 0.12244420505585663, 0.10257860217721826, 0.06434246998474169, 0.0883587681618877, 0.41531003928372723, 0.4044291563148823, 0.43372861703983423, 0.39581599729507944, 0.4265826936547904, 0.38985864289426364, 0.4359704727841207, 0.39473437459000504, 0.44337751196579134, 0.08942242728713812, 0.18169677474395873, 0.09465592729363803, 0.11621482286279605, 0.11308946632090322, 0.11782923486184449, 0.09722651957769068, 0.13125274507874785, 0.11973563455151348, 0.13000201151246293, 0.24202072079332004, 0.16075126251632066, 0.14713689787030493, 0.1830678922783423, 0.17138985603478019, 0.19059972431522287, 0.15260489979496072, 0.19660767678593094, 0.2645158564348058, 0.30780234000201956, 0.3156447475315285, 0.2799322311386778, 0.3124533514454232, 0.27195434294204457, 0.23182200975324685, 0.298064480910778, 0.23249467921469857, 0.22642301710538482, 0.21551322616828972, 0.2505046529097058, 0.23103778582998158, 0.2169178775844659, 0.2234562480679897, 0.18624853194257562, 0.19919618834114183, 0.20355484899862408, 0.22265424640899378, 0.2554946332523006, 0.2147997307321764, 0.2365892413721491, 0.23250495206681676, 0.28727262906320605, 0.22073672336489158, 0.2722684417411776, 0.24036259384710446, 0.16745560701474604, 0.17352275114928217, 0.1857049707188091, 0.23021904137082605, 0.19046102786236352, 0.17885943783580482, 0.18630445196827294, 0.19579947081959037, 0.17909829036117186, 0.6199608604991178, 0.18546489179133774, 0.1855015316076588, 0.5469101321036249, 0.19884304459391022, 0.6053242214001823, 0.14126380355876522, 0.1640673068006585, 0.6165409055160567, 0.5231439833288983, 0.16814088537888072, 0.4137115550085575, 0.4077826955835625, 0.27435806158900633, 0.16754036332297562, 0.16669399281442987, 0.1670330018054048, 0.3131281063082302, 0.181666054147816, 0.18342805498103565, 0.1777105511867425, 0.1975903663764761, 0.18201390634950876, 0.18669197441970975, 0.18263033368826775, 0.18018989605414681, 0.17087796376119568, 0.10148201992059513, 0.0836285962645481, 0.0958802095518233, 0.09872549241167383, 0.10202021990263255, 0.1105697182344888, 0.08467582297703324, 0.10080302577080724, 0.08313136632193796]}, "mutation_prompt": null}
{"id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm.", "configspace": "", "generation": 81, "fitness": 0.21974542838273242, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "a9cf93c1-3a20-4b80-b8a2-cb8ee44a6533", "metadata": {"aucs": [0.45762677657851114, 0.4547887405068367, 0.4822846416047778, 0.496356293355791, 0.4823600517618082, 0.4443851442460154, 0.4430198494653105, 0.44306575493238254, 0.44219111042527626, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023658774535978977, 0.0035903858081661744, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1313428242566963, 0.10344561101545591, 0.10765560763854443, 0.11205713048186661, 0.10858735361718064, 0.11219359227339532, 0.12047994820146601, 0.10998009248735963, 0.10743021626828231, 0.07566761749043793, 0.09649957820621202, 0.09876313610669862, 0.08305024974709829, 0.07086371013452064, 0.08643638089146066, 0.10786883553004922, 0.09033388844252255, 0.08048507691240414, 0.9149437159038689, 0.9463388479092292, 0.9108893139050334, 0.8969920244089592, 0.8949771266263598, 0.900342531086881, 0.9275784881873064, 0.928751963941111, 0.9156287233669277, 0.22438236162804848, 0.2431545756978628, 0.22867507241762397, 0.24061744014172481, 0.25388890657227237, 0.25040796096427553, 0.2567741197202932, 0.23209236597055027, 0.23208952965423268, 0.35220025270887856, 0.5431046251169309, 0.2744909806375153, 0.2672810022949853, 0.5666546614445589, 0.20291533327205624, 0.3397529295396382, 0.2217348104734025, 0.7338215498872716, 0.12903855152518795, 0.11878137964478575, 0.12235729328988765, 0.152889014791171, 0.1920064912253483, 0.17452918282630603, 0.21746926828872026, 0.19526976092056414, 0.12875292309158792, 0.14592524986545263, 0.149530127114188, 0.1650302860818358, 0.1499739620819044, 0.12502230311497675, 0.14938892553489969, 0.1358438500250495, 0.14993199512664324, 0.17284308519457248, 9.999999999998899e-05, 9.999999999998899e-05, 0.006227293225910535, 0.034226946134634506, 9.999999999998899e-05, 9.999999999998899e-05, 0.02551479754435837, 0.00200281354491727, 9.999999999998899e-05, 0.15443389011826292, 0.04858057310156105, 0.1363355272042076, 0.06358410685854288, 0.07389972404886325, 0.01057869182613791, 0.13378630418479065, 0.08821591730754585, 0.03516416855390181, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004370259529300147, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1100712447522123, 0.1525085474856427, 0.11324935712828266, 0.0809354490299955, 0.10969495609411406, 0.08641511136833069, 0.11393964309511107, 0.10151917829269008, 0.1210082238700605, 0.46989464364462896, 0.4146576662246403, 0.4076458742401563, 0.39703224146252836, 0.404504519782962, 0.40882028672978665, 0.42604438299249026, 0.4332694131160657, 0.39659275766493884, 0.12251509030711605, 0.10515877286410158, 0.07958556353682777, 0.09126477572209846, 0.09709287034802472, 0.09619889138859106, 0.1028133245833387, 0.13811919037950815, 0.10221640256115283, 0.1370695998757563, 0.28574570608833716, 0.14348572969954754, 0.1830707328058373, 0.1986794916396375, 0.16983526522070136, 0.18866695012837187, 0.17817945671646285, 0.21492733117120733, 0.283665951063355, 0.31113569303469013, 0.2948268076252606, 0.28044548082950893, 0.25361517359297747, 0.2815429374949733, 0.25783975022597405, 0.29601561603815263, 0.29034668717738, 0.19679896850791323, 0.22333769663743552, 0.20129704885014055, 0.23140811558683294, 0.2121356932117353, 0.23477336420798767, 0.19660604270320636, 0.21501015105671073, 0.172348628394154, 0.21279250739221867, 0.23764093542256115, 0.2654568633088795, 0.28598625631646246, 0.22004133437555318, 0.26458997328433775, 0.22885048702678146, 0.22048292053973284, 0.21795029950174039, 0.1780415499656901, 0.1882880688450116, 0.1707912286706993, 0.18761942290840694, 0.18596966733833276, 0.18228104036205206, 0.2386527251369075, 0.2710860151370078, 0.17810970558677197, 0.1844135678210278, 0.1863547891406131, 0.1864273195133076, 0.11747197294697531, 0.197784126160095, 0.14536199697789287, 0.14121755871828645, 0.578535267535867, 0.6358375313019075, 0.6051018136645642, 0.46078406269790373, 0.40681201564506053, 0.44829561351191516, 0.417716808821484, 0.1668197672673266, 0.1663360887696106, 0.3299818887894198, 0.3502627118402478, 0.18501739253238614, 0.19779285818412362, 0.19384221685336622, 0.1768534064138716, 0.18430133728088693, 0.17429328662166554, 0.1825879076296817, 0.21214562941366866, 0.17568035762661238, 0.07358422322180591, 0.11591344664429648, 0.08720330103667384, 0.08800443778906142, 0.0959509106311871, 0.0923906643647433, 0.10005525813056626, 0.08687654688567359, 0.09634074959131345]}, "mutation_prompt": null}
{"id": "8e3fd1e9-f742-41d4-bebd-e7da57a298e3", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.convergence_rate = 0.5\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget) * (1 - self.convergence_rate * (evaluations / self.budget)):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget)) * (1 - self.convergence_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with refined strategy to adaptively adjust cooling rate and mutation rate based on the convergence progress.", "configspace": "", "generation": 82, "fitness": 0.21934556969936536, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.4587200087745177, 0.46784936728501836, 0.4730392663245042, 0.42677796297580517, 0.45203129067087977, 0.4624612720889313, 0.47368313630543835, 0.4376593471443956, 0.4586422305049249, 0.002044047311858588, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006674561515600197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14297567647084342, 0.11982108163338157, 0.07369613060906699, 0.08410912279244198, 0.09793825434910175, 0.08540876216401105, 0.14263328087413174, 0.1124601947420435, 0.10270986742118693, 0.08441454338660037, 0.09282037559124168, 0.10610389269737719, 0.08273051300959, 0.07805047150187494, 0.09134012676501913, 0.09909559351439623, 0.08678405523599886, 0.08802528697557754, 0.9224273159740654, 0.9463388479092292, 0.9134706027182163, 0.901257042314677, 0.8861369242513981, 0.8698726047050792, 0.9173669992820395, 0.928754699972948, 0.9238854322089433, 0.26257754546661105, 0.24222923299629506, 0.27874528861959, 0.2491644964524976, 0.26627983538643907, 0.2578844568875952, 0.22327763611669416, 0.25026261632223656, 0.26778707999467566, 0.3009225259308719, 0.37639710576256624, 0.2788061585835233, 0.265762998757189, 0.7212334048396007, 0.23355472950863432, 0.21822159755231085, 0.2966280973899237, 0.2697021688993133, 0.13756349081752484, 0.11958095259711155, 0.12022418161026271, 0.09717346237183233, 0.20268604014086145, 0.18935480211772882, 0.1556555708489732, 0.1841175084694182, 0.12764328140460623, 0.1627577763649708, 0.1455796282018451, 0.1234250384386325, 0.14081114663171468, 0.1285574461511798, 0.13809449923126127, 0.18208166950470162, 0.1315197102195449, 0.14563509117072226, 9.999999999998899e-05, 9.999999999998899e-05, 0.014681623845280045, 0.023119435423395562, 9.999999999998899e-05, 9.999999999998899e-05, 0.0052786705158065494, 9.999999999998899e-05, 0.03481183554536438, 0.12626085653277608, 0.055997166470242665, 0.1085849769015913, 0.06115342549783853, 0.09014329190641568, 0.03654544770901247, 0.1736048964313972, 0.10283248286311697, 0.07221952439516821, 0.0065394037401994565, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033825796976277855, 9.999999999998899e-05, 0.129946090740249, 0.1049969010904862, 0.11916510241163247, 0.0955658867162017, 0.13083356610221342, 0.07037129231841022, 0.10479028233649534, 0.10784130282634474, 0.09143443439732601, 0.4345405667044, 0.4126874603351478, 0.43233732666818014, 0.3836503958438595, 0.3977862508492773, 0.3827508284454474, 0.40771739744257507, 0.41447387820917325, 0.39120392459526176, 0.10788966412374079, 0.10696873112498329, 0.08906563724470795, 0.08032216205532827, 0.08749048696651385, 0.11449167907042013, 0.09742037467400333, 0.1110654733337535, 0.10747935896676297, 0.250478896609318, 0.2823872551932102, 0.14688826857373682, 0.18996988326277808, 0.16456224593016944, 0.1778393220587806, 0.16301398535754819, 0.11641594725560112, 0.19774206906678526, 0.2953141351390406, 0.31440935501169653, 0.28741438373554073, 0.31510592802847737, 0.2899447185572067, 0.28056839291866864, 0.2413565420554421, 0.29059124717995666, 0.2887894936979898, 0.20386751633657085, 0.22047918636001473, 0.21520599986927114, 0.2782886446887828, 0.21897748831661656, 0.1998702451618143, 0.17955178536173722, 0.2170426769673115, 0.16385669145247572, 0.24633618199027385, 0.25568393378604914, 0.2444452426088548, 0.2501215098940892, 0.23279180218428586, 0.2308762984618734, 0.22794542267377937, 0.24893137118777486, 0.21391807636567128, 0.1806623483516574, 0.18367451726126205, 0.18925728036525968, 0.20449596591059638, 0.19992005948667824, 0.18203909362928972, 0.26249258093200534, 0.25370925944372746, 0.17754502597675015, 0.18532151400921126, 0.18634199971244902, 0.631622032742261, 0.15857683721728866, 0.1982205413827972, 0.1929263434894135, 0.14148277304871826, 0.6470262241720945, 0.5656480543351518, 0.5673479449332126, 0.4300097469208094, 0.36846480418711625, 0.4408365814743038, 0.3355610232683923, 0.1657355411420267, 0.36696073515668226, 0.33517333729959886, 0.40925945777655137, 0.1749468720148556, 0.1717188377523542, 0.1866140251446985, 0.18924236698767738, 0.17750578028714992, 0.16992206073174565, 0.19129285529008644, 0.21214562941366866, 0.17389671384485228, 0.07641213668809665, 0.10334197584644822, 0.07929675614944831, 0.0910586096998659, 0.09469927908802966, 0.08515125297047266, 0.08820800929535821, 0.09241949560357499, 0.09602609653009153]}, "mutation_prompt": null}
{"id": "b7bc2bd0-8996-48fc-b940-83d123fe1100", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.quantum_tunneling_rate = 0.05\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def quantum_tunneling(self, position):\n        tunneling_vector = np.random.uniform(-1, 1, size=self.dim)\n        return position + tunneling_vector * np.random.uniform(0, 1, size=self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                # Quantum tunneling effect\n                if np.random.rand() < self.quantum_tunneling_rate:\n                    self.particles[i] = self.quantum_tunneling(self.particles[i])\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, and a novel \"Quantum Tunneling Effect\" to improve exploration.", "configspace": "", "generation": 83, "fitness": 0.21068493718027476, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.44870870493975845, 0.45553874079757317, 0.4517080332714155, 0.4377849502589741, 0.45771342227911804, 0.4346574854837396, 0.4553304470930296, 0.4180754921017442, 0.447448376747025, 9.999999999998899e-05, 0.03281346991654899, 0.04603526998152008, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12297916971322942, 0.08506304375880902, 0.10809289725150506, 0.10151688383369928, 0.11502999020157045, 0.12736404853999062, 0.13081038121160726, 0.10966789430198354, 0.10179781691547596, 0.08359417671615266, 0.0976583773480092, 0.09938086597953644, 0.10118018654903249, 0.06724767446520674, 0.08357167366378837, 0.08948159710538606, 0.10008632593046152, 0.10119672288274029, 0.8951646896190834, 0.9446132984483498, 0.9199091970130329, 0.8663363684334586, 0.9155326236704517, 0.8732714371338465, 0.9223641768269388, 0.8958974520162809, 0.91500388903734, 0.26350422212951374, 0.243874478857675, 0.2339801796447002, 0.26154615573696294, 0.22940385177675637, 0.24055277894664207, 0.23451544549931236, 0.2402404490671065, 0.23861186306487492, 0.2262609223294283, 0.31548493120113386, 0.25355827189676405, 0.20525242813800115, 0.26494603483439993, 0.20336474294091667, 0.25439523494385763, 0.2383108593140002, 0.5813654346070548, 0.2187735077207974, 0.15639955122328664, 0.11865810201282279, 0.13949251176028865, 0.19253052464639964, 0.11736623569219395, 0.1835716064651064, 0.12170605348670083, 0.12326855679518556, 0.1331395219487529, 0.16165882887292626, 0.135312928475953, 0.13567555295641742, 0.1324845260854205, 0.12372532867765351, 0.16509154920596336, 0.13627292989228823, 0.1315338221987129, 9.999999999998899e-05, 0.013957936902144863, 0.02826780448087174, 0.014815731875185922, 9.999999999998899e-05, 9.999999999998899e-05, 0.0064475913336699, 9.999999999998899e-05, 0.00021430241393904925, 0.19057047769858348, 0.05403824632221654, 0.09767888112906709, 0.1260696797853934, 0.042929828087923894, 0.036059543134385974, 0.10927158635972012, 0.06235942293403751, 0.06965487964200634, 0.011238630846740816, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0025384514911820366, 0.11483118663713798, 0.11719193504359593, 0.07308999489943147, 0.10848990797128777, 0.10290209042188359, 0.0955247732158121, 0.08251685246307316, 0.06720067572074273, 0.11014459392837783, 0.4428255040334358, 0.43131836065775453, 0.42506745322924977, 0.4084824191755574, 0.41279890850414325, 0.4162726211413388, 0.41097552011224747, 0.4274010394811697, 0.40225728292451324, 0.10874884583764832, 0.11688586246526012, 0.10104813098181298, 0.13390879758996965, 0.10316072741632965, 0.11321806639718868, 0.09385767917834054, 0.12392240598476978, 0.09243696191967099, 0.1397440292139559, 0.1810396178692335, 0.1907926790103227, 0.19201149788621275, 0.17127151121098128, 0.16068836058712255, 0.14822715673118836, 0.18561072918258836, 0.19558866731733182, 0.25956147918226957, 0.23161551505268652, 0.2863990135189133, 0.2897141922082639, 0.22646112508399263, 0.26265560580615854, 0.324952550101017, 0.28372775043730203, 0.2339408018368485, 0.2587297168725984, 0.19598169506618246, 0.20560538877585022, 0.20628128732369577, 0.19973087415500113, 0.21664805158534417, 0.18683652874820367, 0.23518294649257343, 0.195949677071645, 0.2140843796323093, 0.22634488996780788, 0.2311512381888261, 0.2244427836507762, 0.235946423644657, 0.23692585691305335, 0.25096014905327113, 0.2374590528046454, 0.24077729213196497, 0.1818594211091945, 0.179696458463799, 0.18533718566713664, 0.18197506719654788, 0.20933846357539088, 0.20062808732599302, 0.17302413721093746, 0.18059011434046957, 0.19422703612634207, 0.6454942347076269, 0.18491011942557345, 0.18515410970230972, 0.17123454492859014, 0.19843165144833907, 0.1950352590490303, 0.14056487897294156, 0.4854622601916395, 0.5475423496538694, 0.44075003014631053, 0.21016524627457944, 0.41709555596860726, 0.3638669087059152, 0.16594035430913567, 0.1674826328818303, 0.16525433917695986, 0.3448188015766672, 0.3873826641339727, 0.18980116862550667, 0.19219384120043814, 0.17465209108568291, 0.1804381939780857, 0.18320503692867174, 0.17682125453649677, 0.1794573684804971, 0.18233502531323198, 0.20494772451173005, 0.11814066190430073, 0.08541861912476656, 0.07420266281785026, 0.07852809531815108, 0.1109476870020446, 0.08845618025278978, 0.09841222253237336, 0.10190940667609372, 0.10192799781394024]}, "mutation_prompt": null}
{"id": "6000d32c-aa16-46ed-b804-7e84566c134b", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if np.random.rand() < 0.18:  # Probabilistic refinement\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with probabilistic refinement of individual lines.", "configspace": "", "generation": 84, "fitness": 0.20003596850652047, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.4577592419772837, 0.4113083701812291, 0.4333331962075566, 0.37337689177521527, 0.3840610221065177, 0.35411359454073443, 0.36087706511729634, 0.3586156486948251, 0.3834585194648563, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010855359247375906, 9.999999999998899e-05, 0.0038914922683621622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11491167939361224, 0.0802769282151985, 0.09709505151671527, 0.10218069124721896, 0.09072070428140255, 0.107875274461257, 0.08108792072379134, 0.11378243307711178, 0.07584578672235298, 0.09122014255866684, 0.08182267952381084, 0.055700532905009315, 0.08155285662162226, 0.08256345685919075, 0.09338090679179045, 0.09315611586177752, 0.09298141015993555, 0.09253394173671237, 0.897955439174579, 0.9336614780314114, 0.8713357209209074, 0.9254937177339317, 0.9242737348570456, 0.856380804135387, 0.9264375043553431, 0.9258819490915701, 0.9154433839225208, 0.23307881966223876, 0.21846984040707418, 0.20472570524953848, 0.2219003846485197, 0.24751463401159834, 0.2482148582981949, 0.20816742525672804, 0.20256642574402806, 0.20921046364271256, 0.22066251341310816, 0.2552658526457182, 0.21801787321214983, 0.26336018317617127, 0.2533139361150947, 0.3144278615782421, 0.25176749517841657, 0.23833340479301446, 0.2597917583129331, 0.1458722713653493, 0.10901769068478229, 0.1213178262821002, 0.17348629726942744, 0.12243095741023824, 0.123691743568904, 0.12451698765217223, 0.129455216254999, 0.17511164302124893, 0.12952774837810355, 0.12579074431117465, 0.1308035539403103, 0.14778617937412486, 0.14786871621571973, 0.13555680197522435, 0.15764049657671253, 0.12988766939762986, 0.11840259317209934, 9.999999999998899e-05, 0.006466754647067363, 9.999999999998899e-05, 0.007561672941404085, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0637616501110464, 0.06922266465894589, 0.12912542033530194, 0.06557561255058031, 0.06442801928801922, 0.027327658309845515, 0.09395219223212603, 0.10027060471121096, 0.11136086929680822, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08934605677863039, 0.09927281045166525, 0.07755465989627575, 0.09364406532016578, 0.093444840896584, 0.07240162961640528, 0.0752096418508037, 0.05867432463006628, 0.08198643474829037, 0.38991414309798333, 0.35209757601232683, 0.3504174113816577, 0.34419365110725497, 0.38529762940546153, 0.33217837797152394, 0.39551457807679535, 0.3762188940116603, 0.39200945421582734, 0.09600517663704, 0.11524082567069327, 0.07840976431989133, 0.09079401384615426, 0.07600703978618151, 0.1113431786276986, 0.09898417807716064, 0.10236116585121802, 0.07920273177976067, 0.21057028956965507, 0.1711319263318175, 0.13016059294464843, 0.1484574907374887, 0.14851421838398415, 0.16997043655978727, 0.13636011589960306, 0.2452018843780307, 0.1503223769371409, 0.2870169548180602, 0.2670323407549108, 0.2603305774063799, 0.2503899484605736, 0.2759602464770302, 0.27065132808237635, 0.25444141394312725, 0.2705463203281594, 0.2736181427918448, 0.196738822231586, 0.20651546720271274, 0.199814383828678, 0.22639990266135723, 0.20043856832973195, 0.23383672426499935, 0.18190798478112824, 0.20883606596664772, 0.17552488674749744, 0.22855292624686185, 0.2281054754434424, 0.22450940319224022, 0.25681868279039255, 0.20845051093289935, 0.21307575796575517, 0.20950858241329584, 0.22430852305953086, 0.2488013861102949, 0.17912833626371794, 0.17798703075491407, 0.1718582297371729, 0.17867434982181463, 0.18632699579162704, 0.1743095737767708, 0.17956438050442503, 0.18534756167687427, 0.18791239890949785, 0.6161567748817829, 0.18601507970456244, 0.18633303357248665, 0.5894234414820202, 0.5853237528125195, 0.1964122946988739, 0.1562394223551522, 0.556429223224195, 0.14823884190190384, 0.4340471472128121, 0.20659179162443286, 0.5387582628269867, 0.20229880935299394, 0.2072838832667514, 0.2405371720026177, 0.16638297363350263, 0.12657333724456543, 0.2817751714977137, 0.1977499030986829, 0.18965962588337293, 0.19454229057141437, 0.18350773440267598, 0.1770186727730454, 0.1832583843793414, 0.18602688305717652, 0.18097556005435866, 0.17511031369336183, 0.11037794421480052, 0.0773864088433045, 0.0820420716564566, 0.09874998619029374, 0.07910884392844797, 0.08794297261077921, 0.09992431880113994, 0.08718813252672153, 0.08498445273487198]}, "mutation_prompt": null}
{"id": "8672f871-8ec9-44c8-b401-9aef29b9adcf", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.refine_strategy_rate = 0.05\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def refine_strategy(self, position):\n        if np.random.rand() < self.refine_strategy_rate:\n            return position + np.random.uniform(-1, 1, size=self.dim)\n        else:\n            return position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                # Refine strategy\n                self.particles[i] = self.refine_strategy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with a 5% probability of changing individual lines to refine its strategy.", "configspace": "", "generation": 85, "fitness": 0.20987321484347315, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.47504578802770003, 0.4504723472047827, 0.46845864171288454, 0.44888926690267417, 0.40173587100226704, 0.4458575899303866, 0.4634218939142277, 0.4255297084872677, 0.443140083753332, 9.999999999998899e-05, 0.018632286552067834, 0.0050373117651437704, 9.999999999998899e-05, 0.006162192650262854, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13763401435236933, 0.09216111664007709, 0.11236972776666276, 0.09019240220736613, 0.09754801989304218, 0.07666515482371616, 0.11552767439724632, 0.11777248359331605, 0.10233511341329504, 0.10496574159110983, 0.08789387298528506, 0.0932419326219831, 0.09115268997061465, 0.09834269594678657, 0.09064817638186728, 0.10139216901597159, 0.09880219569264281, 0.08961354350807216, 0.9196190122557217, 0.9363189347916867, 0.9058545478136444, 0.8806760787005959, 0.8569830741707158, 0.90780703624942, 0.8968587918493199, 0.9309868286217662, 0.9063033047064694, 0.24752660556810424, 0.2538575294524339, 0.2554616711570763, 0.2591241984939877, 0.24725751355798753, 0.23131230729176355, 0.22389730529992813, 0.2286081449408317, 0.23009269139315847, 0.34692298842011315, 0.644737919622795, 0.21523252670591342, 0.27120830552942854, 0.2617783485128816, 0.2615792993550642, 0.26728103593158337, 0.2216901643694037, 0.21132540389336907, 0.1618727767264978, 0.13794440199478997, 0.14673012971103128, 0.11490120220261091, 0.1407136727873376, 0.18258555817931466, 0.1516578552484964, 0.12138050658654898, 0.1346266450905248, 0.1776079029504425, 0.12431587380678266, 0.14069520474931452, 0.12731473368887491, 0.15025091933058687, 0.13047521695389264, 0.15843621622291848, 0.13244818100596856, 0.15845298966420562, 0.004726607585075371, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033712412143753756, 9.999999999998899e-05, 9.999999999998899e-05, 0.003011825439623861, 0.012407298686116564, 0.013485341143446572, 0.10132042448107736, 0.06418580510283811, 0.10891401348751406, 0.10435634458152487, 0.053865414206817674, 0.02375531189733171, 0.12166885666352845, 0.053342816675722826, 0.057654609789424494, 9.999999999998899e-05, 0.009833962798487694, 9.999999999998899e-05, 0.0007452838312765886, 9.999999999998899e-05, 9.999999999998899e-05, 0.03037704769148264, 9.999999999998899e-05, 9.999999999998899e-05, 0.09258248321659646, 0.12312580834918374, 0.08470042446344528, 0.10032468059887356, 0.1181754410955882, 0.12207900590629384, 0.10013558543205459, 0.08928144563137308, 0.11391012460984862, 0.40956760330005415, 0.37901319146046175, 0.4002185243526323, 0.45689901805297917, 0.405548863678586, 0.3911166581010411, 0.394347200465055, 0.4099688285039609, 0.3798005358723977, 0.10141988901244114, 0.12554440650936283, 0.09678924220705609, 0.1169061789710708, 0.1063956805520242, 0.134055229574371, 0.09558090640241057, 0.1123591476506497, 0.08989631058427261, 0.184152133743399, 0.24709982671555886, 0.13135274224801574, 0.2153738482452362, 0.17832983620422493, 0.16462750377178303, 0.18419070086418665, 0.19330708071906522, 0.17215359663566399, 0.30771259229507897, 0.3023740773026454, 0.2814220080276757, 0.245572407761378, 0.26485336356813005, 0.27679488669133434, 0.25561923888039895, 0.27776545031587185, 0.24003456515668198, 0.1836126172823177, 0.19169142734964018, 0.22220395844366747, 0.22513661104047822, 0.18229802303302411, 0.2144373235318301, 0.1764959575736691, 0.20586374652311934, 0.1835666087499831, 0.27626522003754506, 0.24880903076768435, 0.24855822882807155, 0.20511436169742192, 0.23105493621178874, 0.22735831403562368, 0.2720014612258732, 0.2825648514217187, 0.2240943247598598, 0.17966995136657293, 0.1795504785864832, 0.17035482463925855, 0.1975883839750895, 0.19095160343284356, 0.17544745859732336, 0.17674711822479494, 0.18048705583816682, 0.17047664493595271, 0.18521890171069977, 0.1756242039833079, 0.18649137777717828, 0.1713200549935071, 0.19788222790207488, 0.2043974603689419, 0.1415588272949344, 0.6538774708703232, 0.6566356010416903, 0.480435497453816, 0.20922986299676105, 0.34555086043955596, 0.2059952352785862, 0.2029593807974056, 0.35481389592788815, 0.16713205962882616, 0.3723972193076368, 0.3933694899086747, 0.17525990219508425, 0.18332554918730792, 0.181824485350372, 0.1841788895070785, 0.1900513720508118, 0.1835308487485977, 0.18699939481173078, 0.18089448202134395, 0.17913800990158923, 0.09476221808937191, 0.10742447233528496, 0.10453372949865958, 0.0873335420879342, 0.0952788915446845, 0.08593015305627083, 0.07825184944016406, 0.08588126424380171, 0.11627146109270037]}, "mutation_prompt": null}
{"id": "16c54e92-71ac-4269-969f-f9aa81892f23", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.probability_change = 0.8  # Probability to change individual lines\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update with probability change\n                if np.random.rand() < self.probability_change:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                else:\n                    self.velocities[i] = self.inertia_weight * self.velocities[i] + np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Novel Metaheuristic Algorithm using Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with modified velocity update, simulated annealing, and dynamic inertia weight.", "configspace": "", "generation": 86, "fitness": 0.20827509114562573, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.43481314980351415, 0.4399781328905241, 0.42228353382295547, 0.43862730485059975, 0.44929224278531577, 0.41557182216532595, 0.4180178836629761, 0.4230317943255558, 0.44370106209135185, 0.010842169653682121, 0.058685002440651224, 0.00990613072133728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08433019011269716, 9.999999999998899e-05, 0.11736103051776459, 0.09822234742738767, 0.09851312534799506, 0.09304096648925841, 0.06145090830403532, 0.09928883139051325, 0.10219814815427175, 0.12396727044685862, 0.12376871810962453, 0.08741682585218391, 0.09743808341692306, 0.087470586853312, 0.10011616250886268, 0.10043816220341373, 0.09032941030962505, 0.09591469029970556, 0.07066226734139869, 0.07695215690243062, 0.8907224169884348, 0.9485402529485305, 0.873888093196985, 0.8305581555196853, 0.8799215811746454, 0.8530474954009112, 0.934131624524784, 0.9365882944375392, 0.926871093935932, 0.2645082338855841, 0.24391589574248984, 0.2850529259234559, 0.25118298323774557, 0.23580316332155538, 0.23435995043058133, 0.2463821642333538, 0.2288005372408276, 0.22054801330191864, 0.3183768019867145, 0.32046092957171834, 0.26514277461480884, 0.26634426131632005, 0.2831050582854293, 0.2528043064689246, 0.32309265466004844, 0.25932026137046615, 0.26187109966948896, 0.12273888690706758, 0.14986697896900514, 0.22388288107643717, 0.1408633897240117, 0.11174207407081738, 0.11534220436570686, 0.1378900740406318, 0.12368914897589678, 0.16011099375410198, 0.13345808262760506, 0.1464559480636901, 0.13255276207880817, 0.14040378652540075, 0.1274857690290817, 0.14167864383473316, 0.12298163189358069, 0.1271924625479025, 0.14874250329539573, 9.999999999998899e-05, 0.0044348627077397396, 0.003615681079166322, 0.008011029214588627, 0.022333754700410324, 9.999999999998899e-05, 0.0027170116262521526, 9.999999999998899e-05, 0.008074354926451033, 0.1453381141203408, 0.07435380556573512, 0.21103824792743786, 0.0636833469278335, 0.04853029205491333, 0.03895113851179499, 0.11198246277781854, 0.06818439365884954, 0.0962862266079455, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02347741909656542, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10001958466353611, 0.11773661197242635, 0.0990373169983686, 0.07587474570354502, 0.0917720035085633, 0.08641680528684115, 0.11942242942695269, 0.09424279856102913, 0.09151577881660433, 0.37827718961342716, 0.3872053120542037, 0.3962541043323533, 0.42586938344507375, 0.36806124640211446, 0.37585675783102623, 0.38716668391771614, 0.4004732177073299, 0.4420712274851001, 0.10318693147671398, 0.08042029332799261, 0.09097508800396714, 0.11083668621354936, 0.08754956732334163, 0.10197665925986843, 0.10085512954795273, 0.1276350521182532, 0.11950550613639954, 0.14902634000941983, 0.18083629877848184, 0.13834719929480377, 0.20071569312458382, 0.17811388123559224, 0.19431985104322802, 0.15797893545229957, 0.1613630568302351, 0.2442675460156064, 0.2834917853615745, 0.29041974911731283, 0.2962673648767433, 0.2993902349736358, 0.2900274891330109, 0.25952008157851947, 0.28128799672694693, 0.29276651490494476, 0.26195977996804265, 0.2066590492651963, 0.21659653836743886, 0.24134775293229482, 0.22738126224600663, 0.20001734890959877, 0.24618685402316653, 0.17042358340749575, 0.1816105752141851, 0.19269456165087806, 0.2207375356832063, 0.22915166241227813, 0.21662189099186513, 0.2544343026717548, 0.23496577918448314, 0.2096250422689695, 0.22186227138047732, 0.21429117425991973, 0.2413651353011984, 0.1927247850364241, 0.18164111153514717, 0.1997200809108154, 0.21267845447385858, 0.19828576178091428, 0.18382574962320863, 0.19322933408084775, 0.19182732837444605, 0.18344631408465062, 0.17799375553943697, 0.1860844954942118, 0.18478285337771394, 0.1698673027840426, 0.19795054586336625, 0.5409771924516755, 0.6376286420092181, 0.5934538224416928, 0.15091268160526983, 0.6561908729336754, 0.16794066820973153, 0.42083302311047954, 0.43063973145723666, 0.1654762698646164, 0.1662255858332654, 0.1662930274109241, 0.16355033610355185, 0.1653083215213894, 0.1774672460629223, 0.18212191985063042, 0.20586968241356451, 0.1817849141575737, 0.18373167498677556, 0.17474121049618785, 0.18306831026211912, 0.18606416397588477, 0.17591064407120538, 0.08532229990970752, 0.09215778685192144, 0.08307044669138974, 0.0917517247836318, 0.080083091952181, 0.07986279977604682, 0.0884945074902771, 0.09087013765524243, 0.07061135055179202]}, "mutation_prompt": null}
{"id": "0bc2eabe-dd76-4e2b-b9d9-02357064e458", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.adaptive_mutation_rate = 0.5\n        self.velocity_reset_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate * (1 - self.adaptive_mutation_rate * np.random.rand())\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                if np.random.rand() < self.velocity_reset_rate:\n                    self.velocities[i] = np.zeros(self.dim)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with adaptive mutation rate, velocity reset, and temperature cooling.", "configspace": "", "generation": 87, "fitness": 0.21481176393181528, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.4915733351109929, 0.4769971789862282, 0.480030953051365, 0.4826237841694788, 0.4698927831516476, 0.502667701571447, 0.46033851479304844, 0.45042511468316615, 0.4515979451566692, 0.001513495746461202, 0.031074781959890996, 9.999999999998899e-05, 0.006177123168290222, 0.003819034120825071, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12434699748488653, 0.12053666049781131, 0.1287418462026766, 0.11283852186365606, 0.0957049061538584, 0.14198730984738162, 0.0950686673921306, 0.12652505585612728, 0.12743302850699312, 0.10345239568695364, 0.09767036807756724, 0.0986065205138138, 0.08126645116375364, 0.07163416519569177, 0.09053758872426465, 0.09598449645022489, 0.09028958751637728, 0.1111588646809869, 0.8911862099033476, 0.9436863341534255, 0.9138741139096601, 0.8602448055524127, 0.8998638934519831, 0.9151004671476534, 0.9187650423386939, 0.9045295453294797, 0.916397649680619, 0.2624219996704945, 0.26959080378387856, 0.2768549849777493, 0.24331693397083376, 0.25441929850265066, 0.2647704090684122, 0.2507417474983439, 0.2506227896317781, 0.23012327036860925, 0.46247065625070716, 0.23330119260058502, 0.4127354368536761, 0.24691982986243877, 0.2537757855984931, 0.20129789163905687, 0.17866226972725596, 0.228102994557687, 0.27849438491509393, 0.13121381416606637, 0.12674211198414254, 0.14503518059052822, 0.08707483374368985, 0.17467137699061264, 0.16211852155190354, 0.15911281962187096, 0.12166717287933593, 0.14096906418125887, 0.14276220654731675, 0.1373465485200791, 0.16114290488495586, 0.12003162310366766, 0.15472524019559064, 0.14147263978633762, 0.17693772688797504, 0.14816671955060445, 0.14553798745213298, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10360971251712636, 0.07449106366286196, 9.999999999998899e-05, 0.00034834985279708075, 9.999999999998899e-05, 9.999999999998899e-05, 0.11023556218079666, 0.053699821424328054, 0.1080549704359548, 0.08492010885345957, 0.09416565718368164, 0.03674833966109714, 0.13915919608117, 0.1005888805596793, 0.1237064008442672, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010630241251461836, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09915801477827368, 0.12801000940410834, 0.10430556086343001, 0.10306416138101815, 0.12209413245940992, 0.09075186812994629, 0.11646144730818209, 0.08402022702301004, 0.08508534802786982, 0.42526396871204264, 0.4027446620691799, 0.42216242002211046, 0.4158169397033946, 0.4129181788484857, 0.4365964506149874, 0.4573930793448586, 0.44195897605251044, 0.4406714471202442, 0.1082110450557382, 0.09967856621733773, 0.10312937679989487, 0.11051387875600505, 0.11576109952941582, 0.1472644750504163, 0.12519095525316093, 0.14112722943775602, 0.11753670221870693, 0.14521696063461553, 0.1496082869483687, 0.1334190607093747, 0.20480819475627154, 0.17859592520928513, 0.2171613210785467, 0.20056862670775555, 0.1464650710410813, 0.17570915476146187, 0.2660724657570407, 0.2846742750931236, 0.3161332648579124, 0.2605328469013988, 0.29898649467156146, 0.3201758198926624, 0.2512110007210038, 0.3095680834878223, 0.29127655125421437, 0.21569349721159792, 0.2303196075881223, 0.2595882781746044, 0.26048136288006585, 0.20452822548047322, 0.22949689506848203, 0.22532998797719106, 0.26028993114457954, 0.2030982426342769, 0.22967924692629826, 0.2596236392816462, 0.23648686891028248, 0.23261684225831591, 0.2630670028791605, 0.24373086244973907, 0.23708342061807663, 0.21570532884620697, 0.23396932773418788, 0.17762156079521718, 0.1750796431906656, 0.17205201633718048, 0.22273479733904888, 0.21293033219096846, 0.1852074858838707, 0.17897500238588604, 0.18908016680496076, 0.17375654673659247, 0.12766963249480145, 0.18464719613258374, 0.18621423575575513, 0.6757161080899823, 0.198974127136332, 0.19679058812609274, 0.14142480971040627, 0.6908169846110046, 0.5453448422908511, 0.4147649333220378, 0.2072815697819358, 0.4322180051560026, 0.164948185696274, 0.16557066771641038, 0.16619608732765045, 0.16747768350020142, 0.16520704813903342, 0.318290849211464, 0.19310137797911942, 0.20959793967656193, 0.16999963698988518, 0.18687130231201354, 0.17085206798650798, 0.17386644341440427, 0.17849047376195015, 0.1910220557029344, 0.1992143470410661, 0.08074135455997289, 0.07913531062022594, 0.10947515531658314, 0.08761477322267597, 0.09604050010449205, 0.09382103423524024, 0.09870492597376046, 0.09317543895553515, 0.09899085725122425]}, "mutation_prompt": null}
{"id": "c68c0085-b46e-4e5f-a1fe-f2220608bbde", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.probability = 0.27\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def refine_strategy(self, line):\n        if np.random.rand() < self.probability:\n            return np.random.uniform(-1, 1, size=self.dim)\n        return line\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.refine_strategy(self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim))\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with refined strategies using probability 27.", "configspace": "", "generation": 88, "fitness": 0.20443632826783437, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.4125966060304006, 0.46658551675220483, 0.4726574758854871, 0.46239493271785637, 0.4138316382884685, 0.44794324938398566, 0.4644133830675432, 0.4275580084940338, 0.4332370638439891, 0.006604973897311184, 0.041278982433605615, 0.02405229213136939, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1321253834832371, 0.12198023597502072, 0.10527475341107873, 0.0957789751793463, 0.09990373067020719, 0.09334903094238689, 0.10071537347922566, 0.1307952845934135, 0.11025315190047136, 0.09373540526953361, 0.08978082032402812, 0.08007668562370895, 0.09772783740226876, 0.08984762610231978, 0.0816916238520804, 0.13363734986267717, 0.0740471446420442, 0.10057940110821295, 0.8990940655904222, 0.9359505492104292, 0.8868793706804093, 0.8147509883677984, 0.835142171423124, 0.8723864967139713, 0.927943982883038, 0.9248916235857868, 0.8934158916157225, 0.2642295516494678, 0.24011381188564518, 0.2506836565672409, 0.23842997408841038, 0.23725840173391988, 0.22164938668766354, 0.23950482816975927, 0.24825278584797805, 0.2523987295112905, 0.23557943601104048, 0.22277326611773374, 0.2123212941955308, 0.2711669012328042, 0.2921035182085818, 0.24565882813004125, 0.23642666163254789, 0.20711481184387348, 0.22537926451107537, 0.13469093865473136, 0.15270690891870986, 0.07769644549619459, 0.11640449694378951, 0.128755350286765, 0.1273972749330593, 0.1264879408512204, 0.13055110073509602, 0.1200491043769698, 0.12364029501365659, 0.14142316828899326, 0.14209625310440965, 0.14544365197701847, 0.1378623680818789, 0.120609997254012, 0.14573679383058258, 0.1490695552691732, 0.14184243422333842, 0.061238969575575175, 9.999999999998899e-05, 9.999999999998899e-05, 0.005865926404424626, 9.999999999998899e-05, 9.999999999998899e-05, 0.004844324940463052, 9.999999999998899e-05, 0.0020028515165063654, 0.11807208092126475, 0.07513057621961583, 0.10050607468530037, 0.08851607414320006, 0.08332445553144752, 0.05282031436182566, 0.09631141533867171, 0.0945897339105739, 0.09585597283392311, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008076085070375383, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1064999680194545, 0.12424579534412916, 0.09371145671641501, 0.12748058875576285, 0.11278579803630873, 0.11823915449091926, 0.09763460880644803, 0.11431715592389824, 0.08783672961336575, 0.3953189132105486, 0.39320651845884325, 0.38577596785020485, 0.43643054388758273, 0.4108420886554349, 0.3674730681854458, 0.394914944247692, 0.4220959747634634, 0.38496760045254486, 0.09277256763856478, 0.0964784782913024, 0.10177086984228967, 0.08751638439043219, 0.09676277792086108, 0.10090856404697457, 0.08646250059607596, 0.12412141380408082, 0.07971604023804868, 0.1446232298052581, 0.14580712811478536, 0.1419185505555799, 0.15322653892146065, 0.18016933521880352, 0.15339872574684832, 0.1647400231770989, 0.2460148264934151, 0.16387515704138078, 0.28669083203342627, 0.28249657199290434, 0.2792782055872808, 0.2533681506832942, 0.2489629796827565, 0.28120741216134915, 0.24974640920243152, 0.26381756424464375, 0.23388142541757373, 0.21388124410052778, 0.2150046095524475, 0.2141776548259663, 0.21035945475617546, 0.23623375556767756, 0.21917552094483694, 0.17547469713531705, 0.1982469977320136, 0.18918343023266948, 0.2073353482869842, 0.2109139171222093, 0.2240250666589102, 0.21615504280565345, 0.21876127131713852, 0.23029249936604512, 0.23725546650587714, 0.22797830843704492, 0.2146952145022809, 0.17445279470476982, 0.18593417575076832, 0.20350969720810907, 0.19806621098524257, 0.19135984485777213, 0.17568375986094742, 0.18505195725797963, 0.17436972778471882, 0.17430479413529065, 0.1812246842744114, 0.18577286402879145, 0.18225381280498754, 0.6130003531223289, 0.1983157725391802, 0.1914232301033909, 0.13924879776103938, 0.5305691056589863, 0.5261401379850845, 0.5109634449553593, 0.16787267808351458, 0.357757808623859, 0.4406110252607326, 0.16621387949649657, 0.2022382881611523, 0.16504650870356874, 0.3172100000911301, 0.32854376821930587, 0.19111217953161608, 0.1731651877212702, 0.19496991393481777, 0.17769760808021806, 0.1824881927274209, 0.1798239416266375, 0.18039445611708338, 0.17304016276658563, 0.18088644901058326, 0.09760495954539361, 0.0842308482299835, 0.0854829134625037, 0.07002606498886976, 0.09523954530463596, 0.09215691135389703, 0.09074563043855555, 0.08623880605932277, 0.10294033244450129]}, "mutation_prompt": null}
{"id": "a7bce3a6-e230-4d41-ad88-d5aa07dd109a", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.dynamic_mutation_rate = 0.5\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Adaptive velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim) * (1 - evaluations / self.budget)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate * (1 - evaluations / self.budget):\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1 * (1 - evaluations / self.budget):\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Dynamic mutation rate\n                self.mutation_rate = self.dynamic_mutation_rate * (1 - evaluations / self.budget)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate:\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate * (1 - evaluations / self.budget):\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with adaptive velocity update, dynamic mutation rate, and simulated annealing.", "configspace": "", "generation": 89, "fitness": 0.20707786792627988, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.45354117785553805, 0.42773730226619955, 0.4120848706408655, 0.45486521850412465, 0.40676288158491547, 0.40177786709123564, 0.47340265722950803, 0.44700543653033054, 0.43424945441274887, 0.006806085571672504, 0.04481878221858138, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12077054461125736, 0.10320172372178682, 0.09914842623421205, 0.07770739815876093, 0.11788215017606851, 0.1080044916692754, 0.1037327856248681, 0.09969801881418283, 0.12545329816681128, 0.1141159855621352, 0.08160844574923776, 0.09411811422696881, 0.09498355105918677, 0.09361998704348584, 0.0813749851867076, 0.08897618820887221, 0.09954281902367224, 0.08336657097337974, 0.9146359326483553, 0.9255001083637899, 0.9186294484817931, 0.9209175699776488, 0.8753233321298888, 0.9055848227519704, 0.9156172852098142, 0.9052852707859753, 0.9290890744136198, 0.23889289510401046, 0.21673622761443534, 0.22112069132943912, 0.21555399279173437, 0.21304129558210894, 0.215125495987175, 0.19753827317903816, 0.19075418931284194, 0.2046553912440524, 0.3062078800897369, 0.3470769698532866, 0.2977627694856584, 0.2629992802769735, 0.5720816696048722, 0.24987759333052928, 0.3050659833536892, 0.22434948317706904, 0.22487946190239294, 0.12587782945451276, 0.13955134692692883, 0.11510603142976883, 0.09716380721600548, 0.1379571933455721, 0.1261109347162861, 0.12129991700470943, 0.12838919603432242, 0.1506771519243859, 0.14423821973780526, 0.16475421598727957, 0.15113554809578256, 0.13340236193644395, 0.13471316655458454, 0.1478816164887521, 0.14083875199807427, 0.1350832806907234, 0.12934976105079754, 0.003896198947462848, 0.013532977158830395, 0.02110650302224748, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010596908960365137, 0.0007795476306681204, 0.007435460967404661, 0.08127746191957685, 0.044369922944775264, 0.13796495012592824, 0.09139706537623404, 0.06832100204516789, 0.10985701326289032, 0.17808439599027936, 0.18816019826754649, 0.1270424698092364, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08556488017409758, 0.1418668852288918, 0.09687675349118641, 0.08188506455284095, 0.09066612121009998, 0.08009646808421544, 0.09422141334099166, 0.07782653281069163, 0.07233709106664077, 0.41411637300523396, 0.36829797201722936, 0.38393598455042344, 0.3865057883431696, 0.3986152861429506, 0.4072289938212169, 0.4085975144350773, 0.3911167259767241, 0.393219755204385, 0.07579783696366393, 0.14152778830161206, 0.09732806754160572, 0.09239546774145424, 0.11532929636641165, 0.12302408744634064, 0.10607056862533515, 0.11030310061093718, 0.09353040800783563, 0.16139941258036028, 0.1475625942997545, 0.137464210337228, 0.18384641386581224, 0.1787916710956431, 0.17212620289725122, 0.16064390466436673, 0.1662124853612078, 0.18393792645399143, 0.2855945474858087, 0.24325240427372663, 0.2695500978362201, 0.292523128546217, 0.293598882757394, 0.25850596639395673, 0.24805782704419388, 0.2809141788571692, 0.28568142834677035, 0.20920363121456154, 0.09549256188387423, 0.21535612442628194, 0.21708345396846784, 0.2183518041992335, 0.20061594063281996, 0.19246711646207126, 0.2317005573322649, 0.1776601787719263, 0.23913900263932175, 0.20503688694720923, 0.22325229839808525, 0.2128663624721101, 0.22120142889218708, 0.23914583917827137, 0.20166142186349523, 0.23529211009422835, 0.22075287579542724, 0.17177068424633923, 0.18363489995872606, 0.17722692019510033, 0.17922183788843393, 0.18722066328020726, 0.1740764344144018, 0.1795563593802192, 0.17535656439175928, 0.18474843447660638, 0.18282111470692963, 0.1840736426796613, 0.18500832196475037, 0.5512499488432829, 0.1964543953961425, 0.19186606723991795, 0.13910904375828104, 0.49475414382149585, 0.5312809207775548, 0.4032779643024681, 0.20940091652766546, 0.39263085395759656, 0.4736935277256501, 0.16587246534390832, 0.17028795257196738, 0.16552193114632496, 0.3502340304061716, 0.4510867688601463, 0.17593027928883676, 0.1996426598223322, 0.18535520022625218, 0.19028592914778053, 0.17468682749273157, 0.18274014505283853, 0.17807317880418216, 0.1949644414267524, 0.18818948640526034, 0.09221816514603831, 0.07202309212230606, 0.08456462413888455, 0.07706598020390631, 0.11063170256538035, 0.09170086835001656, 0.0826163590862734, 0.09494857995345374, 0.09360802813151081]}, "mutation_prompt": null}
{"id": "9b863b20-fafb-4713-a304-c30d94feb201", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.evaluations = 0\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                self.evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - self.evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (self.evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    self.evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - self.evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    self.evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if self.evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    self.evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (self.evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with adaptive cooling rate and dynamic inertia weight adjusted based on evaluations.", "configspace": "", "generation": 90, "fitness": 0.21974542838273242, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.45762677657851114, 0.4547887405068367, 0.4822846416047778, 0.496356293355791, 0.4823600517618082, 0.4443851442460154, 0.4430198494653105, 0.44306575493238254, 0.44219111042527626, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023658774535978977, 0.0035903858081661744, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1313428242566963, 0.10344561101545591, 0.10765560763854443, 0.11205713048186661, 0.10858735361718064, 0.11219359227339532, 0.12047994820146601, 0.10998009248735963, 0.10743021626828231, 0.07566761749043793, 0.09649957820621202, 0.09876313610669862, 0.08305024974709829, 0.07086371013452064, 0.08643638089146066, 0.10786883553004922, 0.09033388844252255, 0.08048507691240414, 0.9149437159038689, 0.9463388479092292, 0.9108893139050334, 0.8969920244089592, 0.8949771266263598, 0.900342531086881, 0.9275784881873064, 0.928751963941111, 0.9156287233669277, 0.22438236162804848, 0.2431545756978628, 0.22867507241762397, 0.24061744014172481, 0.25388890657227237, 0.25040796096427553, 0.2567741197202932, 0.23209236597055027, 0.23208952965423268, 0.35220025270887856, 0.5431046251169309, 0.2744909806375153, 0.2672810022949853, 0.5666546614445589, 0.20291533327205624, 0.3397529295396382, 0.2217348104734025, 0.7338215498872716, 0.12903855152518795, 0.11878137964478575, 0.12235729328988765, 0.152889014791171, 0.1920064912253483, 0.17452918282630603, 0.21746926828872026, 0.19526976092056414, 0.12875292309158792, 0.14592524986545263, 0.149530127114188, 0.1650302860818358, 0.1499739620819044, 0.12502230311497675, 0.14938892553489969, 0.1358438500250495, 0.14993199512664324, 0.17284308519457248, 9.999999999998899e-05, 9.999999999998899e-05, 0.006227293225910535, 0.034226946134634506, 9.999999999998899e-05, 9.999999999998899e-05, 0.02551479754435837, 0.00200281354491727, 9.999999999998899e-05, 0.15443389011826292, 0.04858057310156105, 0.1363355272042076, 0.06358410685854288, 0.07389972404886325, 0.01057869182613791, 0.13378630418479065, 0.08821591730754585, 0.03516416855390181, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004370259529300147, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1100712447522123, 0.1525085474856427, 0.11324935712828266, 0.0809354490299955, 0.10969495609411406, 0.08641511136833069, 0.11393964309511107, 0.10151917829269008, 0.1210082238700605, 0.46989464364462896, 0.4146576662246403, 0.4076458742401563, 0.39703224146252836, 0.404504519782962, 0.40882028672978665, 0.42604438299249026, 0.4332694131160657, 0.39659275766493884, 0.12251509030711605, 0.10515877286410158, 0.07958556353682777, 0.09126477572209846, 0.09709287034802472, 0.09619889138859106, 0.1028133245833387, 0.13811919037950815, 0.10221640256115283, 0.1370695998757563, 0.28574570608833716, 0.14348572969954754, 0.1830707328058373, 0.1986794916396375, 0.16983526522070136, 0.18866695012837187, 0.17817945671646285, 0.21492733117120733, 0.283665951063355, 0.31113569303469013, 0.2948268076252606, 0.28044548082950893, 0.25361517359297747, 0.2815429374949733, 0.25783975022597405, 0.29601561603815263, 0.29034668717738, 0.19679896850791323, 0.22333769663743552, 0.20129704885014055, 0.23140811558683294, 0.2121356932117353, 0.23477336420798767, 0.19660604270320636, 0.21501015105671073, 0.172348628394154, 0.21279250739221867, 0.23764093542256115, 0.2654568633088795, 0.28598625631646246, 0.22004133437555318, 0.26458997328433775, 0.22885048702678146, 0.22048292053973284, 0.21795029950174039, 0.1780415499656901, 0.1882880688450116, 0.1707912286706993, 0.18761942290840694, 0.18596966733833276, 0.18228104036205206, 0.2386527251369075, 0.2710860151370078, 0.17810970558677197, 0.1844135678210278, 0.1863547891406131, 0.1864273195133076, 0.11747197294697531, 0.197784126160095, 0.14536199697789287, 0.14121755871828645, 0.578535267535867, 0.6358375313019075, 0.6051018136645642, 0.46078406269790373, 0.40681201564506053, 0.44829561351191516, 0.417716808821484, 0.1668197672673266, 0.1663360887696106, 0.3299818887894198, 0.3502627118402478, 0.18501739253238614, 0.19779285818412362, 0.19384221685336622, 0.1768534064138716, 0.18430133728088693, 0.17429328662166554, 0.1825879076296817, 0.21214562941366866, 0.17568035762661238, 0.07358422322180591, 0.11591344664429648, 0.08720330103667384, 0.08800443778906142, 0.0959509106311871, 0.0923906643647433, 0.10005525813056626, 0.08687654688567359, 0.09634074959131345]}, "mutation_prompt": null}
{"id": "1b0d0dc4-949f-4e17-9bce-4e2a8fc81dbf", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.cauchy_gaussian_perturbation_rate = 0.05\n        self.simulated_annealing_rate = 0.05\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def cauchy_gaussian_perturbation(self, position):\n        cauchy_perturbation = self.cauchy_mutation(position)\n        gaussian_perturbation = self.gaussian_perturbation(cauchy_perturbation)\n        return gaussian_perturbation\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy-Gaussian perturbation\n                if np.random.rand() < self.cauchy_gaussian_perturbation_rate:\n                    cauchy_gaussian_perturbation_position = self.cauchy_gaussian_perturbation(self.particles[i])\n                    cauchy_gaussian_perturbation_fitness = func(cauchy_gaussian_perturbation_position)\n                    evaluations += 1\n                    if cauchy_gaussian_perturbation_fitness < fitness:\n                        self.particles[i] = cauchy_gaussian_perturbation_position\n                        self.best_fitness[i] = cauchy_gaussian_perturbation_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], cauchy_gaussian_perturbation_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                # Simulated annealing\n                if np.random.rand() < self.simulated_annealing_rate:\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < fitness or np.random.rand() < np.exp((fitness - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with a novel \"Cauchy-Gaussian Perturbation\" and \"Simulated Annealing\" techniques.", "configspace": "", "generation": 91, "fitness": 0.2132467428563564, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.449514024108436, 0.44114470717111054, 0.4539098308264291, 0.43815173089135984, 0.4211892808726524, 0.45107957580046487, 0.4332485508097036, 0.43917503699075855, 0.4458153682904784, 9.999999999998899e-05, 0.03765454649800215, 0.03490231942956523, 9.999999999998899e-05, 0.019939868955376694, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1424806552189155, 0.09345747684782979, 0.10610956338606625, 0.11114779918996465, 0.1275505022113108, 0.0950253531178088, 0.10724565452549484, 0.11752411696091625, 0.1088772511257341, 0.07935093063813514, 0.09899786179662862, 0.0974633167297716, 0.10114911245286262, 0.09206760723445695, 0.06301945262142361, 0.1025140590130964, 0.08268210221249683, 0.1023052310779522, 0.8776741032592402, 0.9430468159608727, 0.8848135507684235, 0.8496502405138722, 0.8950638778871348, 0.8569349993616783, 0.9258367113801158, 0.9233907448796312, 0.9143874653926911, 0.2493378276009358, 0.24036786255877596, 0.24898043945006, 0.2617315107750694, 0.23482514153977208, 0.22632422991573764, 0.22426542224814394, 0.24764079026786145, 0.21914773456486591, 0.22766310197622697, 0.7265816221170807, 0.23440410708823112, 0.24937561998040958, 0.32193813312422315, 0.2057512040773244, 0.2521527083132029, 0.22196956479866958, 0.336235004266055, 0.10113766366054622, 0.1927641948749076, 0.1174747671377907, 0.14340148819434162, 0.1344216897864977, 0.1497252496175865, 0.1267235170986587, 0.12090374974713558, 0.14520131644908219, 0.1606566415282048, 0.15664984546304406, 0.15512897431620964, 0.1304233231914288, 0.15612952084084386, 0.13705263488914787, 0.14768004720095518, 0.15125884864671757, 0.11549416412353752, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017652269462828385, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015123819641493785, 9.999999999998899e-05, 9.999999999998899e-05, 0.06206763547145855, 0.043889619949067704, 0.12862688600940053, 0.07082488371682427, 0.062280555604940835, 0.042871969428770695, 0.2144603220100657, 0.07463411962288047, 0.07060326954029861, 0.0009202297621886402, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0071788467467713835, 9.999999999998899e-05, 0.10282533434313046, 0.10539102694164926, 0.09758015855220259, 0.09023641507902047, 0.11170095339893049, 0.11660978924826326, 0.0807067585565222, 0.07548115230011476, 0.07155301754631327, 0.4161339896764531, 0.42140613588618236, 0.4182624694799263, 0.40540975573562665, 0.4107444659247351, 0.4105931296382067, 0.4438767577488587, 0.41644288384223616, 0.3883878071822744, 0.07181204016884946, 0.11616751443826812, 0.09080339644556246, 0.11332377705447039, 0.09579236219321663, 0.1060479972480014, 0.13405863479592606, 0.10715701733036609, 0.09641750164469809, 0.14862732376602128, 0.18564484721408203, 0.17630734683425453, 0.21192044565084012, 0.1817530978710168, 0.19256168676232688, 0.20925582128906717, 0.1670955187247518, 0.18733216733799662, 0.29213237980578954, 0.2843722509714621, 0.30692776702383284, 0.31305951086563033, 0.3036654130013612, 0.3012784817198497, 0.25684810898329546, 0.3201101077015355, 0.2113809025167569, 0.24286122321121806, 0.21142090937934144, 0.20279412513662276, 0.21719395808384712, 0.22404030200758918, 0.20088598886650466, 0.20510665498907943, 0.22542564573551194, 0.19406574871557858, 0.2562439700095258, 0.2509601879843414, 0.22726156043831625, 0.2538048088290541, 0.23224999953659353, 0.22265096817700802, 0.22913758084227198, 0.2451621637638115, 0.2096948915335396, 0.1719079460480607, 0.18195651079924635, 0.18527929575968427, 0.17965171413217262, 0.18047464880795794, 0.18881130708446758, 0.18709546888601591, 0.22293122940421362, 0.18757432124871998, 0.18469227801626542, 0.1858591537990808, 0.1868980868505935, 0.4718123623493986, 0.19802176584627806, 0.19409122181898852, 0.14086103053810728, 0.6792891480027599, 0.6469721108303472, 0.6322531515579533, 0.16792688053606575, 0.3874441805959117, 0.33426973453157094, 0.4506728757108567, 0.16793016221626744, 0.16774314085656772, 0.304106783268402, 0.2949016978670769, 0.19211881006952214, 0.17530038721856023, 0.17396156080761105, 0.1840785248870188, 0.1850311032103228, 0.1791536673042754, 0.18480836263742362, 0.1897974129347284, 0.17303089371369695, 0.09830880117079555, 0.10052785464940539, 0.10316821008719834, 0.09009105354061153, 0.08927337125166324, 0.09196789385473425, 0.10197222781562543, 0.0992963176694811, 0.11589164197985335]}, "mutation_prompt": null}
{"id": "3be5a82d-6c51-460c-9e79-3127ae90cb18", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.4  # refined adaptive cooling rate\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.15  # refined dynamic opposition-based learning rate\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.12  # refined mutation rate\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with refined adaptive cooling rate, dynamic opposition-based learning rate, and mutation rate.", "configspace": "", "generation": 92, "fitness": 0.2101497623843285, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.4563585712635919, 0.44014605458422396, 0.4552018282487329, 0.4110488822804633, 0.42502548132395646, 0.44971851994397083, 0.4628731342995689, 0.4306684388590345, 0.45667501169537317, 0.0026920659567060135, 0.04768232597315969, 0.000455303761889847, 9.999999999998899e-05, 0.006748425063217156, 9.999999999998899e-05, 9.999999999998899e-05, 0.006087694342401084, 9.999999999998899e-05, 0.13067524231922312, 0.12121087689797383, 0.10491663852132493, 0.09831376633556588, 0.10083375600133548, 0.10881391438647392, 0.11812435447748826, 0.144499834189172, 0.12046637270490301, 0.08365111466312647, 0.10510746582229491, 0.12361032025739294, 0.10088554103481617, 0.09577684226328331, 0.06780694188283432, 0.11172677307451484, 0.09092014828389805, 0.08086516414211198, 0.9146263990346154, 0.9487803089706798, 0.9129488885107008, 0.8814127495988044, 0.8969876444320183, 0.8989917639328254, 0.9344503676385406, 0.9235380075632963, 0.9246946917345482, 0.2649316344965781, 0.23816734808898132, 0.2583154517578712, 0.24045648257615893, 0.246006799162794, 0.2614161804233287, 0.2611559771104711, 0.2558686066950534, 0.2746651007892925, 0.24363961842069515, 0.5953713828248335, 0.3018144307189117, 0.27004379945499946, 0.3315498727866839, 0.29261307149805094, 0.2775165805060896, 0.23389315865437588, 0.23229074268613015, 0.1798246192440789, 0.14201445888967446, 0.1858390464771701, 0.1360566487780277, 0.12482911544293651, 0.12644561208119953, 0.1454738263829115, 0.1391737182943883, 0.15696478454028207, 0.15974735529124773, 0.121503369763023, 0.12434574616436878, 0.1427722131897311, 0.14320405394318936, 0.14946277992104295, 0.14932367411498293, 0.16162208366491326, 0.12422740278993583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035103589094013232, 9.999999999998899e-05, 0.008574763890718318, 0.12001829899289695, 0.04822606105304916, 0.11903264910112243, 0.07697426994164358, 0.06888910975437101, 0.02388798350813326, 0.140500690160002, 0.10532984318852845, 0.06522124846404731, 9.999999999998899e-05, 9.999999999998899e-05, 0.002787019184924744, 9.999999999998899e-05, 9.999999999998899e-05, 0.006327702225824905, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10864246053212723, 0.09153180151454454, 0.13231479553503211, 0.07372781160527098, 0.08946296523131458, 0.05675776195643012, 0.10592344576884882, 0.08032062699747644, 0.12362725133756847, 0.42605637480264, 0.40596905606582323, 0.40632110789379616, 0.44723862647670953, 0.4097477810936654, 0.3697313388274057, 0.4246121424894076, 0.4070035243012591, 0.4145878006070176, 0.10549870027212183, 0.12984873872355507, 0.12568977821242822, 0.11434570356293838, 0.11450194079310749, 0.0966907202466124, 0.1357107417382789, 0.09748641630795518, 0.09535405491567417, 0.18260036813299518, 0.16192252007241936, 0.16696303871825546, 0.1562565119841689, 0.17661842863972999, 0.15928759539293735, 0.18802663217024562, 0.15983755287979862, 0.19083793009081562, 0.23737078373958675, 0.29111892436287257, 0.303968401176804, 0.26453704527992117, 0.305525424886237, 0.3052245472762025, 0.27777725491131855, 0.2835473821347333, 0.25994645755643164, 0.20300197785324914, 0.2048841243178623, 0.20318955074062883, 0.22143716477211184, 0.21032816112416863, 0.23006795228574262, 0.18274474566820342, 0.24050623198337173, 0.20479676366748867, 0.2464884918756507, 0.2432732028282487, 0.20804225438072188, 0.21427624213276808, 0.2421025845174981, 0.23260634571738004, 0.22315469379591057, 0.21258589178935072, 0.2433321442273555, 0.1760348872399503, 0.19530289494810948, 0.18527867822090405, 0.19169153332474953, 0.20034377120573788, 0.17931526718650548, 0.16853423456409888, 0.1895024210352032, 0.17645892936217988, 0.18527785685715625, 0.1856839212485103, 0.18620176692483625, 0.1175360025889639, 0.19827890584277907, 0.1971895839135135, 0.14106577716917168, 0.15500490033072778, 0.5545436598454154, 0.5465163509863065, 0.2098144974357593, 0.337315554232958, 0.44594940819939255, 0.3568387859900176, 0.16673987596005024, 0.16672711492390624, 0.37155450635342324, 0.3249489206749083, 0.2014155669728347, 0.18441356675029452, 0.172222696040767, 0.19232747002081008, 0.1717781754112251, 0.185201159933975, 0.1857303144821315, 0.21896455373111678, 0.1859964683436297, 0.08325228259246287, 0.08540750773787209, 0.09886152991650143, 0.10035751830353123, 0.08751229014250317, 0.11036086117828525, 0.11254203043016309, 0.09360346773958717, 0.10621804556071779]}, "mutation_prompt": null}
{"id": "7800c5df-2b35-4a42-9272-0966de52e9b3", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if np.random.rand() < 0.18:  # 18% chance to refine the individual line\n                    fitness = func(self.particles[i] + np.random.uniform(-1, 1, size=self.dim))  # Add a random perturbation\n                else:\n                    fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with probabilistic refinements.", "configspace": "", "generation": 93, "fitness": 0.20438989943666622, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.4877901918247296, 0.44008232714889595, 0.32309494800331884, 0.3361084630076444, 0.44153508389583274, 0.4760796921370962, 0.4509532912551697, 0.4148616541450567, 0.43424787531113673, 9.999999999998899e-05, 0.012582631451593662, 0.005333455384748276, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10260396992563292, 0.13344763346887778, 0.0883738116261098, 0.09462411926198289, 0.1288592957005612, 0.09775081257054641, 0.09399697590465383, 0.10236881237305129, 0.10631590980108063, 0.11021467205211377, 0.0949572699632879, 0.09184631229679363, 0.12092237489333324, 0.07037519730778186, 0.09665198218506066, 0.08585342803640683, 0.08569178868033667, 0.12464369717164991, 0.9040964407425757, 0.942505694214409, 0.9154902512446571, 0.8658701538233814, 0.9048267771224896, 0.895358184924019, 0.9416566204558551, 0.9236353025419057, 0.906133980534224, 0.2290622293612431, 0.23435268855027003, 0.20112325740741366, 0.27272630247928553, 0.20703663285680463, 0.2368787058250954, 0.23507079455021196, 0.18305456902574202, 0.23047375505015621, 0.25638379332980676, 0.3222418676691672, 0.23188602683121606, 0.2578355039711754, 0.2638262989613527, 0.20520742440977469, 0.29345396322776207, 0.2986311538647618, 0.24467002068710508, 0.13688903912612327, 0.1041616617533011, 0.16023207092129665, 0.13650295044693306, 0.11955403612925675, 0.12185010702783095, 0.16539742446962225, 0.1664932205963663, 0.129279744264731, 0.12465080423109798, 0.14242763065373332, 0.13998156690281593, 0.13631117843970209, 0.13209077264636016, 0.17706880565375138, 0.1480021868150294, 0.136104030690674, 0.10715787626189432, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001036551759140969, 0.00017999391031442435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15728647616098657, 0.04614527455088613, 0.11731508807130286, 0.06214485904115152, 0.04741270881397852, 0.05165018948215094, 0.12078172837413881, 0.09383102024466061, 0.12018983562465602, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0061359662881373955, 9.999999999998899e-05, 9.999999999998899e-05, 0.00023099331385023625, 9.999999999998899e-05, 9.999999999998899e-05, 0.11424730453835819, 0.11097642383513773, 0.0878367734905009, 0.12281910932172846, 0.12320589640345281, 0.11114956274658272, 0.06589743586994012, 0.1193127508534404, 0.10226691373199015, 0.40776601119226197, 0.4199904385903741, 0.4077202053478485, 0.43006199424714364, 0.3810611393380908, 0.39471923048598634, 0.4020776069235288, 0.39108357859939535, 0.4071368260121653, 0.10760345919753567, 0.12484664961790382, 0.10345757321198656, 0.11827702359751424, 0.11368889850427755, 0.10058689460358239, 0.121012855015316, 0.10797605157733448, 0.10350494880194006, 0.18872468372571627, 0.21230378615464662, 0.13983399590382828, 0.18308846592291272, 0.19315460437117038, 0.15219285154206696, 0.16965455217465275, 0.18341508738432533, 0.1705043293579538, 0.29319774689891465, 0.27537045032556307, 0.29498897775645205, 0.26045281572418544, 0.27071237301648265, 0.30484323043727535, 0.2855546955689646, 0.2882761865669823, 0.2710204506741255, 0.20984293482261707, 0.10875776422617078, 0.22178795055123057, 0.22885733949080866, 0.20609001601377708, 0.25494490850258933, 0.21211407804745241, 0.23669899757503032, 0.18508113164058582, 0.22728347714932529, 0.25370354526355743, 0.2344401857027515, 0.23770502569196628, 0.23147862039239964, 0.21485734629882092, 0.25745111979526214, 0.22516918772259464, 0.2175631676874259, 0.17551032040057357, 0.18066210990680975, 0.19825566561840502, 0.1990762875837221, 0.1877928297106105, 0.2002662976798526, 0.17887196765878666, 0.17427439591138316, 0.16957003168828033, 0.4820281808850224, 0.18492568605362203, 0.18696863486128368, 0.15018192331976787, 0.1989214590597096, 0.19282175913643718, 0.2053301574367279, 0.552640135763484, 0.1602542709450938, 0.4591526096663995, 0.208543648963045, 0.4423125435538018, 0.3861446429930421, 0.19860718349117912, 0.16641753701974504, 0.16618221817296142, 0.16397726570389515, 0.2339336561627997, 0.19406996182873482, 0.18186739105542327, 0.18045205933424424, 0.18346256165551345, 0.1870532912100875, 0.19636743600765172, 0.1845481612641996, 0.1771492640516148, 0.18196811614732755, 0.08515797496216748, 0.10483395964706155, 0.10067102048897192, 0.09116122676847427, 0.07891113444361997, 0.08169706039224367, 0.08789991735792646, 0.08672876859539103, 0.09294405491468605]}, "mutation_prompt": null}
{"id": "660e1dde-ad0d-4c4f-a2e0-a86177d5196a", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.4  # Refined adaptive cooling rate\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.995  # Refined dynamic inertia weight\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with refined adaptive cooling rate and dynamic inertia weight.", "configspace": "", "generation": 94, "fitness": 0.21301400868940162, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.4418598648973362, 0.4509998989059256, 0.47887151318225674, 0.4390862413977187, 0.4439188458484027, 0.42590327619100854, 0.41902366717514095, 0.42871297026508026, 0.4218711228089679, 0.00421933074676728, 9.999999999998899e-05, 0.0020537364273662817, 0.0019332572621917343, 0.0023707772714078867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1286061047680661, 0.1040163441738956, 0.08815903290020832, 0.0857630314747645, 0.08935633381180763, 0.10166627700603026, 0.12346324531556474, 0.11722049391253953, 0.12501362877175126, 0.08853660548914466, 0.09878261438921476, 0.09715617121081033, 0.08184021969701427, 0.08549685540887564, 0.0890077690664135, 0.09251469647436739, 0.09458237073747422, 0.11014940058403866, 0.9164306730085428, 0.94645646864565, 0.9109293055736334, 0.9033726011935909, 0.8960693991370119, 0.9003810751967429, 0.9278355628559172, 0.9294762166290511, 0.9158495476700906, 0.2417905131980318, 0.27011923791609893, 0.25152619001688437, 0.24606318775289326, 0.2532088617533609, 0.22538931361213832, 0.2511331277653962, 0.2220392326466556, 0.2595193755294143, 0.36682014379611394, 0.3404131206759714, 0.28893544942646154, 0.24061248875017027, 0.3377946634150546, 0.23140135567877784, 0.31797107524313495, 0.18821592302778156, 0.270588927538538, 0.1325278844890354, 0.11953539488050624, 0.1271601527908819, 0.1446655497512147, 0.1959702153275532, 0.15025930636200568, 0.21624119032924105, 0.12299701409955033, 0.1558170580976157, 0.1386121489284705, 0.15159428622216053, 0.1323653782178511, 0.1635344947194004, 0.1272031847354851, 0.13526637227843696, 0.15371940948214435, 0.12495625657001697, 0.16136952640184177, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007934178188853225, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027800968702266227, 9.999999999998899e-05, 0.021379500515953387, 0.13031753672554824, 0.06089044100655194, 0.14963462470010946, 0.0683241639371539, 0.08190923990022947, 0.03513728299626562, 0.1252264807993655, 0.08793133795041741, 0.11420701564501545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01597865267319798, 9.999999999998899e-05, 9.999999999998899e-05, 0.10363428648941175, 0.11099289062459028, 0.09554789860811708, 0.09599703098558998, 0.0976874138041599, 0.09923230721418475, 0.11940240189913842, 0.09665989572643319, 0.10435856222452566, 0.4402436407316782, 0.3871399447975681, 0.42504138751043463, 0.40336975247655493, 0.3847363637303304, 0.393816148301675, 0.4068497843404958, 0.4075755782853675, 0.407859396367682, 0.12362893278538634, 0.11274103025002713, 0.09718146024626673, 0.1084948256028685, 0.11711385418187314, 0.11623675300826619, 0.10394537610649857, 0.11759690897789243, 0.09608337917816245, 0.1386824072661681, 0.3152903223211758, 0.1221601661934748, 0.2219833034458507, 0.16113650187733497, 0.1856968217291407, 0.16551990838145536, 0.16875971700260284, 0.15581115420042957, 0.29017490142896596, 0.29664355846965196, 0.2949299337123551, 0.27089261290586997, 0.29561694810946826, 0.26395934846503577, 0.2566375655113651, 0.28724965996744567, 0.26288057155394307, 0.1918169999124235, 0.20931532758591942, 0.2191087572188416, 0.21560001221714264, 0.23762468126341463, 0.2227861062000095, 0.20427025615040972, 0.21758503783823369, 0.18133314501121178, 0.22600132671965512, 0.22235273550592305, 0.24349770816263594, 0.22226891114356695, 0.2222910534573742, 0.23309475517669975, 0.2366240432025586, 0.22933032514789664, 0.22373410134701333, 0.18602944590124149, 0.18288857128844194, 0.18743773262982355, 0.1890422122591866, 0.19293232381130132, 0.19742882962920838, 0.2487526891407641, 0.21114997278915348, 0.18398918464720793, 0.18427629934715695, 0.18637276611737408, 0.18616796200682062, 0.11744460920183264, 0.19876172451750662, 0.14526413106498237, 0.14073307502619914, 0.5336021256543526, 0.5532747780982689, 0.5269560500257429, 0.44694755204577674, 0.4623628121607991, 0.43764528081292897, 0.457120947477486, 0.16679880675098102, 0.16649773876831098, 0.3770772846914391, 0.36446963355276274, 0.19837716924557414, 0.18040231059710754, 0.17771653273080534, 0.1738138518898128, 0.1816866484558165, 0.19182817277987496, 0.17795838727285807, 0.21214562941366866, 0.18294422110312347, 0.10636865104147197, 0.08806763694496644, 0.12152292849583723, 0.08180925853292087, 0.08518591450394852, 0.08076395476238107, 0.09062186190696031, 0.08592224897642409, 0.10679395776534162]}, "mutation_prompt": null}
{"id": "2e7ae215-87a8-411a-b4a2-de70292d17ad", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.refine_strategy_probability = 0.19\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def refine_strategy(self, position):\n        if np.random.rand() < self.refine_strategy_probability:\n            # 10% chance to apply a random mutation\n            if np.random.rand() < 0.1:\n                return self.cauchy_mutation(position)\n            # 30% chance to apply a random Gaussian perturbation\n            elif np.random.rand() < 0.3:\n                return self.gaussian_perturbation(position)\n            # 30% chance to apply opposition-based learning\n            elif np.random.rand() < 0.3:\n                return self.opposition_based_learning(position)\n            # 30% chance to apply velocity clustering\n            else:\n                return self.velocity_clustering(np.array([position]))[0]\n        return position\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n                # Refine strategy\n                self.particles[i] = self.refine_strategy(self.particles[i])\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with 19% probability of refining its strategy.", "configspace": "", "generation": 95, "fitness": 0.20143641744793792, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.42824270414296006, 0.4254957924085, 0.4125538559054933, 0.42485769877058965, 0.42163544890223703, 0.4074074030519854, 0.4129561733164885, 0.40539594243205235, 0.41645680561645937, 0.0008122031202174584, 0.0043186000437033245, 9.999999999998899e-05, 0.0005566092415476565, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09283340470515755, 0.09297765037682981, 0.08491383533157915, 0.10670239322707764, 0.09704052002974917, 0.08583357909135081, 0.09293724357665856, 0.09744125467754838, 0.11899694662326488, 0.07702650734966954, 0.07561779571061633, 0.10289525615009476, 0.09930287377674962, 0.0877247365464171, 0.06863012051627504, 0.09914613211811751, 0.10302983080657646, 0.09235484256925319, 0.9038219919938199, 0.9361300539765807, 0.909739055346401, 0.8964251703616838, 0.9045258613911107, 0.8393761314018807, 0.9342639803885642, 0.9340360689693393, 0.919737690119812, 0.24656970644759735, 0.27953012936674715, 0.2283124565576331, 0.23558180258677885, 0.2245091166053239, 0.20090459933439275, 0.22575707202074313, 0.221025961331069, 0.21333950806481483, 0.40036623995978426, 0.22485954516254558, 0.2569046996636579, 0.20897614880683246, 0.2253568826232697, 0.24454682481054746, 0.27843055267864036, 0.17223433099328977, 0.23253349739697238, 0.12240096636201947, 0.1010653246735379, 0.12472948531941819, 0.08554974131680593, 0.1209456892337234, 0.1259502911674466, 0.1265343512784035, 0.12630125772229694, 0.13491816700289783, 0.14256814667065976, 0.13877536911905064, 0.1432328418648533, 0.14649587764364136, 0.14554872294831145, 0.15912052357857542, 0.1480911541309602, 0.15637402740389839, 0.15695838957820418, 9.999999999998899e-05, 9.999999999998899e-05, 0.002551156863777715, 0.007362541628591179, 0.01213619503949992, 9.999999999998899e-05, 9.999999999998899e-05, 0.029160317178788087, 0.024369020689967158, 0.09698415764274981, 0.059569670382905726, 0.07822795935777138, 0.07585632713762902, 0.06596035726813332, 0.06683329855503706, 0.08166837356445011, 0.06343544323615335, 0.11271361389116608, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10528739821036759, 0.11789604574058798, 0.09726782988079197, 0.11721938558047873, 0.11398576903584778, 0.05567088221839056, 0.07894231495807547, 0.10270289666468557, 0.08923416056620592, 0.3915163937892161, 0.3851360232778407, 0.39444838087310974, 0.37489296788305004, 0.3620806705625923, 0.3881257062057101, 0.40389828440215414, 0.40801407546017543, 0.4172698600147011, 0.08215425689036915, 0.11177053866372899, 0.09448082624649667, 0.12268486032097647, 0.08812693125257953, 0.09971735554522543, 0.10043920799184558, 0.10103775455519193, 0.11589077952386251, 0.2426844390489168, 0.16516161275570607, 0.13331680392699308, 0.17611926083682483, 0.17810687170129536, 0.1886791105828931, 0.1880117137927413, 0.16224899469574594, 0.16794385812834933, 0.23172654874449705, 0.25858985539654666, 0.28136405513047413, 0.2665621036237623, 0.2708297461536727, 0.2948167015224996, 0.21544184334418792, 0.2853058418790081, 0.26281345727167116, 0.21808001497204843, 0.1022644312636598, 0.17005399801833787, 0.2113152114886393, 0.20854858782805774, 0.19997933314269245, 0.1595587725482437, 0.21188122290013434, 0.16447298139719713, 0.23303183817879058, 0.23814007381306623, 0.24128191275783428, 0.2244931520786717, 0.23099177287124717, 0.2451051623221071, 0.22599693448045477, 0.24270670789252147, 0.273189839868453, 0.1778934495217076, 0.17825116579484346, 0.19223810879857317, 0.17949375842311543, 0.1876334019261715, 0.1749515537323879, 0.2625689351863091, 0.20116071158364301, 0.18275344728276854, 0.18005028886760954, 0.18576288209065228, 0.18270121761287328, 0.582319697057776, 0.1971707042508405, 0.11347272291333244, 0.1397178988798874, 0.5174200480879292, 0.49849794685828275, 0.42863721763012086, 0.20986445722733893, 0.4476235491443017, 0.4013523319704352, 0.16585871470742475, 0.16616580457280083, 0.16818011834039914, 0.28863518572150004, 0.23032217096213792, 0.1694905249800116, 0.18748987612501455, 0.16959727260088586, 0.17576435896691622, 0.18742507696476385, 0.1845078230562044, 0.18182365431959835, 0.20770773279951305, 0.1947606495723253, 0.09690791100696239, 0.0841766021980751, 0.08628962317828504, 0.08816705007220715, 0.08258038409885649, 0.10048505935088525, 0.09208713266330015, 0.0866661758476468, 0.08475745118940015]}, "mutation_prompt": null}
{"id": "f9b3d160-59a5-4b73-ab59-71f7dcdb623f", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.refine_strategy_rate = 0.2\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def refine_strategy(self, line):\n        if np.random.rand() < self.refine_strategy_rate:\n            return np.random.uniform(-1, 1, size=self.dim)\n        else:\n            return line\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.refine_strategy(self.velocities[i])\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with a probability of 0.2 to change the individual lines of the selected solution to refine its strategy.", "configspace": "", "generation": 96, "fitness": 0.21096676061113623, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.4551164691275954, 0.4672862108322178, 0.5232927396580567, 0.44252391784927436, 0.4355398283885499, 0.45670940360712897, 0.4591803880430697, 0.4345424739043465, 0.42367965931480356, 0.017277948888190786, 0.0168890597371556, 0.01906538454654505, 9.999999999998899e-05, 0.04760832487323319, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10285786457204671, 0.11452584344283878, 0.1002876252527578, 0.09000284058892483, 0.11228155572529597, 0.12222043335993871, 0.09232617655503528, 0.11108350900324426, 0.12078749239650466, 0.09862771184009811, 0.06981925580623716, 0.0808771742837362, 0.10977745205083445, 0.0759743737377212, 0.0883982102316977, 0.08776796795967878, 0.08355782329276118, 0.10373336646211939, 0.9023474566056652, 0.9410142411643303, 0.8968282527968845, 0.8411078064963966, 0.8607742250269576, 0.9051229744791424, 0.925056992396484, 0.9005479914560618, 0.9188991774739764, 0.2563357641667827, 0.2608844833088102, 0.24471593960001825, 0.2429066837622682, 0.22173319402716618, 0.2612872607281186, 0.23098899554119767, 0.2264542393315241, 0.23976851170741997, 0.25305629755204184, 0.26157476776727695, 0.273990463610589, 0.330265982644078, 0.2398267096577923, 0.20816570507371834, 0.670014553639869, 0.33145111684533357, 0.21768757217412116, 0.1672441758838198, 0.14499874053040784, 0.1159152962680059, 0.090208948928167, 0.11955547916935017, 0.13569136535902437, 0.11973845978402131, 0.19668536338431064, 0.14466396884458643, 0.14130260705463749, 0.14935171557943672, 0.1218760449677142, 0.13271668725150176, 0.1600179126813388, 0.14586379393987703, 0.1384331144452834, 0.13536993729285518, 0.12356520252322412, 9.999999999998899e-05, 0.00010546724968441001, 0.0261721332545114, 0.048243768311840185, 0.010190121350223347, 0.0009467407844738762, 9.999999999998899e-05, 9.999999999998899e-05, 0.013263319390576345, 0.13285027977534902, 0.09919859202175174, 0.11221642064336079, 0.09161785452299698, 0.07598703978667132, 0.04983978518829679, 0.23438644644373463, 0.07264599136631911, 0.13359054504673928, 9.999999999998899e-05, 9.999999999998899e-05, 0.00016891526268736357, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012004037985458016, 9.999999999998899e-05, 9.999999999998899e-05, 0.10651333605424684, 0.08214707317400682, 0.08832525501371025, 0.08178324505591994, 0.12082371875685805, 0.07553072318054765, 0.0799702933405031, 0.08418755906427178, 0.08141860878104012, 0.4348401630566715, 0.4130632354687799, 0.3991192294550362, 0.40159160104892466, 0.4022064121168244, 0.4048640247395149, 0.420293540412642, 0.4222918576575445, 0.3783544662777224, 0.10651610578087312, 0.1172562397639122, 0.10133071872431343, 0.07731489397120006, 0.09289896288403088, 0.13192555390893979, 0.12441853216071963, 0.13048445290701327, 0.0925032654897392, 0.1486334333167637, 0.12493073467099824, 0.16081909750134293, 0.14603351913782503, 0.15435420098212072, 0.18623624712437536, 0.13355730597891202, 0.15662458256740286, 0.18467259808765246, 0.2674475679512869, 0.2854402135991385, 0.29624482278219144, 0.291834662675327, 0.24407148353751196, 0.29009676182420474, 0.3046554416920322, 0.296521297271229, 0.26911326927041224, 0.1869426352320217, 0.1473402845608962, 0.23132048580324194, 0.20852919047989937, 0.2330044778932473, 0.2231562832883759, 0.1880541924637168, 0.22351139998366065, 0.20368362938331686, 0.2611871037547887, 0.21690551048088613, 0.22463235427326667, 0.2717209052491414, 0.2275586174636205, 0.21294335835946454, 0.2245470315371163, 0.21958590395332744, 0.23189010658985953, 0.19562144419597305, 0.1782262000930941, 0.16979804809705312, 0.20007426327236189, 0.17211535566266534, 0.18132362874701813, 0.211417228432624, 0.1734180900177389, 0.17879114810157448, 0.5833475740393275, 0.18541885796211866, 0.18584139626893992, 0.6605454560861284, 0.19717116357555076, 0.19726918207362332, 0.1407495350367901, 0.6974398808880684, 0.6277091556999126, 0.32891634737884956, 0.20657033090088706, 0.07322176904097799, 0.20403501636834642, 0.39003984588205554, 0.16506724417359164, 0.16506601982745228, 0.15991588974088933, 0.32764607864781115, 0.1844059766137207, 0.19266179672986483, 0.1869516981825614, 0.1847079662427593, 0.17132850113054066, 0.20035930787769007, 0.17520910922243405, 0.1771028598381239, 0.18257984134876915, 0.10218971387034381, 0.08293288541882216, 0.06706423712309484, 0.11299898636708572, 0.09355155342874355, 0.08444129371834075, 0.07567299707701036, 0.10209293498972205, 0.09337058461600156]}, "mutation_prompt": null}
{"id": "49053dae-eb62-492f-a22d-43d914af14b5", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.probability_refine = 0.39\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if np.random.rand() < self.probability_refine:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with probabilistic refinement of individual lines to adapt to different optimization tasks.", "configspace": "", "generation": 97, "fitness": 0.18521899274478623, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.37788938015156626, 0.3676439214535673, 0.3520388641401475, 0.3268461756047928, 0.3311572455711025, 0.3246102926305314, 0.3233388244893147, 0.3144726841298001, 0.3543019379035022, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08478803621521258, 0.09407182391381608, 0.09039748251864788, 0.08335750807436415, 0.08077736169080729, 0.0973999929563657, 0.1082771483146433, 0.11394359733817816, 0.08659180615640705, 0.0843225041344805, 0.10938448682512114, 0.08677411863211315, 0.09831595777018864, 0.09101494907052843, 0.09473787765001307, 0.08731790210687318, 0.08781614220903289, 0.08055904582012186, 0.8756813073802034, 0.9398791277076747, 0.8921891904131379, 0.8469443629712524, 0.8560239339165514, 0.8797474796884172, 0.911959453503779, 0.9334266523656076, 0.8686784812100219, 0.19743837221870286, 0.19405581321832022, 0.19448884345339545, 0.20757419730573545, 0.21082636066917537, 0.19488807147200515, 0.18662720823571477, 0.19102716956024823, 0.20191928114534408, 0.22726232987710604, 0.22162148069857524, 0.2217590441112386, 0.20718090122222343, 0.19940548983637663, 0.20594044536532896, 0.21580347831614666, 0.2199976549020637, 0.16100245527539647, 0.11951509372761715, 0.126590652301372, 0.118802065052097, 0.12448511655869132, 0.11828769615597579, 0.12424404868993022, 0.10422993766032929, 0.1098009382960996, 0.10682438873989064, 0.12823001434715386, 0.12549506071898975, 0.13004228677476692, 0.1185636132418274, 0.11676242709511664, 0.1174214142188823, 0.13976863131532902, 0.12210359159914042, 0.12071330855439188, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01431490231949395, 0.02602818503452653, 0.16070783046671455, 0.07498295763148632, 0.09535721877822612, 0.1003576499972294, 0.046488842776344574, 0.08430876018915712, 0.12115149188613727, 0.11093053040353373, 0.08306869442394615, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05625362829659464, 0.057394919553226065, 0.06435283463215202, 0.06380603528658235, 0.06772344109449968, 0.026008627418514174, 0.05568947490796983, 0.06096336856207707, 0.04773442120869553, 0.33114398639918574, 0.33750369007595404, 0.3184563379202542, 0.33197083719331655, 0.3238455163148668, 0.3186123097469181, 0.37826157839764074, 0.3429083722016789, 0.33858598912840043, 0.08194299654839177, 0.09446329481502302, 0.06985979443438883, 0.0947285873726249, 0.06697505729942643, 0.09855466230270538, 0.12425413758919435, 0.11683481854875422, 0.09286460462085566, 0.1934677529213199, 0.1527036239984011, 0.13093815247446605, 0.1386629689791753, 0.1514462690545888, 0.15208725624892883, 0.12680447156740915, 0.15035161564275745, 0.13878967956749888, 0.26641733009591384, 0.2321773906003045, 0.23846942730309728, 0.2369340206796996, 0.24301222121813337, 0.26144099369737583, 0.22850831432885932, 0.2603794747804361, 0.2549419327124899, 0.19557955376931901, 0.17871493269452443, 0.18918907307683452, 0.19517155928154306, 0.19493804712530116, 0.20307181466059487, 0.18262598540887953, 0.19667713731842318, 0.1442559952501602, 0.2044129055128059, 0.20389635125605576, 0.2076549680701819, 0.2349382277680424, 0.22310585100980473, 0.2389136749237185, 0.22791793888832346, 0.22662759237949037, 0.232994521934772, 0.1961119064999245, 0.1699988195115082, 0.17497350510976417, 0.182062050298042, 0.20516342154480394, 0.1779002584492695, 0.20319903248320526, 0.17582916197970322, 0.17321728059175878, 0.18174855181148464, 0.18300219704298482, 0.18361979470941847, 0.17008115336942353, 0.3014407145547472, 0.5236093524388842, 0.14386232534124177, 0.2883983032843437, 0.4813003657515976, 0.433920529984126, 0.17156664555533696, 0.2040803523776733, 0.28835668350505916, 0.1665265251980136, 0.29610210660680614, 0.18702526964327304, 0.3035434497562063, 0.2865591583945083, 0.1831239046403702, 0.18562930186837145, 0.1763296086932019, 0.1837158689067787, 0.19219817512011173, 0.176798096868364, 0.19763290016706203, 0.2020694437859787, 0.19748146643834374, 0.09169985961369931, 0.08387646741183852, 0.09388507743621433, 0.07072228237712663, 0.09065238923103547, 0.08225639401968932, 0.07471373431338657, 0.08498601210721013, 0.09884718354704003]}, "mutation_prompt": null}
{"id": "0bde7c93-204f-4bad-b0ab-c1cae6906991", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.cauchy_mutation_rate = 0.05\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = 10\n        self.adaptive_step_size = 0.5\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.cauchy_mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Modified velocity update\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (self.best_positions[i] - self.particles[i]) + 0.5 * (self.global_best_position - self.particles[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n                velocity_centroids = self.velocity_clustering(self.velocities)\n                if np.random.rand() < self.velocity_clustering_rate:\n                    self.velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(self.velocities[i] - velocity_centroids, axis=1))]\n                self.particles[i] += self.adaptive_step_size * self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n            # Adaptive step-size update\n            self.adaptive_step_size *= 0.99\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Hybrid Swarm Optimizer with Adaptive Cooling, Levy Flight, and Opposition-Based Learning with Dynamic Inertia Weight, Self-Adaptive Mutation, and Velocity Clustering, incorporating a new \"Particle Filtering\" strategy, enhanced \"Archive\" strategy, and \"Dynamic Opposition-Based Learning Rate\" to further enhance convergence speed and diversity of the swarm, with adaptive step-size and Cauchy mutation rate.", "configspace": "", "generation": 98, "fitness": 0.20255849975934664, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.463281030262674, 0.47850309002379376, 0.5133951493895983, 0.4964761164598719, 0.44298920374474415, 0.4686773691685081, 0.4353732213650432, 0.42256677289971056, 0.4643369418447425, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017460405154230418, 9.999999999998899e-05, 0.10608134532125535, 0.09082478549566131, 0.11598578898836853, 0.09941395698288558, 0.1112919825160783, 0.11432548652863317, 0.10719959983568084, 0.12731281508635273, 0.1003814372492976, 0.1082237812605028, 0.09195687570851208, 0.0986702709167463, 0.0871981245691994, 0.0709766567801664, 0.07951855231832416, 0.084842249943611, 0.09567292334648048, 0.09450677802716267, 0.8222128863449115, 0.8922145161774978, 0.67916882546241, 0.16219478581931235, 0.7837523326229289, 0.4166287595315509, 0.8418520122889845, 0.8767661721992616, 0.8236063729836389, 0.29587695700891414, 0.26915473758216535, 0.2628797971125625, 0.269456349218968, 0.2645346790694453, 0.2641650534376636, 0.26330667671058194, 0.2558424109435655, 0.2586758145094764, 0.41453423409475376, 0.3146443485792526, 0.16877290952037072, 0.3329880843205235, 0.3943525583320868, 0.24885106322958395, 0.22295033063635505, 0.20822832607457553, 0.339835390240245, 0.12780603866767537, 0.11812055002659616, 0.11449893261584909, 0.14747514431143627, 0.2527998360881364, 0.1656625956050748, 0.24494115968109031, 0.13416976030697747, 0.1312957957165739, 0.16539268047020128, 0.15303678714346114, 0.19360010279565498, 0.15920180012218643, 0.12213814698192837, 0.13427623359298269, 0.15563146493531654, 0.1740059327530551, 0.14136712323056766, 0.0002745374115061816, 0.0021327512717577157, 0.021144464021953024, 0.06884595702145002, 0.02543042780996474, 9.999999999998899e-05, 0.007344194004856419, 9.999999999998899e-05, 0.0009239643929760399, 0.09587304546626751, 0.16455486182156764, 0.11082372199957935, 0.05854627598798001, 0.05769116090431414, 0.04333067919935307, 0.11106411495755586, 0.08105422382081362, 0.07398746356366315, 0.0030900230997192857, 0.04501579467019179, 0.019853509901576083, 0.013343603431724693, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017595628588773837, 9.999999999998899e-05, 0.13159201746087912, 0.07956583056077526, 0.0809141005208932, 0.0733337573082905, 0.1384500082711746, 0.08446878146890413, 0.09759929019931024, 0.13799573012101862, 0.13015975967604032, 0.4306982965485078, 0.4541238111031901, 0.41026217101844187, 0.3910126904540917, 0.401260477515173, 0.4122892512738827, 0.41232873565777495, 0.4488548165014251, 0.4226716743679323, 0.11007948192557637, 0.07001559473579821, 0.06480944616955275, 0.12012531033129858, 0.06358099100882342, 0.1043253021727989, 0.12780678167076642, 0.07293315784319931, 0.10933832717635128, 0.2018725748851341, 0.16003857618809947, 0.15626721067660743, 0.16774862736288998, 0.1760060325907199, 0.19947941753942577, 0.20535408771465813, 0.23835723517869778, 0.12506617738257486, 0.2832009354948054, 0.24404139457646812, 0.28928384951252417, 0.29245693714053433, 0.3179967116971708, 0.32001323496050993, 0.23068894862433764, 0.3016622958052261, 0.2280751025039176, 0.23798758177982338, 0.09000990913598073, 0.254658667241238, 0.23400175192378103, 0.21093749224912606, 0.21735026531186374, 0.20091962476904923, 0.2223118374306572, 0.17688976477649598, 0.24524218707714374, 0.2492063399062, 0.23389592998233832, 0.22216648382809256, 0.24217032244061465, 0.2374462418747304, 0.22156363475036522, 0.25191671112259173, 0.24849826912052497, 0.17800274716733744, 0.1885082543911969, 0.17535522999750897, 0.193098727668507, 0.23009806443828762, 0.17458763596485882, 0.1999925832457149, 0.17005170041625461, 0.18742427259149685, 0.1861741102886424, 0.18597454966129612, 0.1857510117119756, 0.14387657825843803, 0.199056548652364, 0.1474136373417254, 0.12176125548785566, 0.14358651971892045, 0.5747584946215152, 0.5491610173141748, 0.48455906782986136, 0.6160572022386024, 0.16718696545819, 0.20273519101538606, 0.16525845516207793, 0.16661488414748604, 0.3371067477045332, 0.1624356585099782, 0.2022087924286553, 0.19677882728611817, 0.1790463777305773, 0.1770422323382933, 0.18231961362036486, 0.18066800687412943, 0.19381966636276704, 0.17756274994983867, 0.18438276152431177, 0.06703253971832268, 0.09670202075462364, 0.08921794664127447, 0.08540682500705299, 0.08144805122177845, 0.07952045431235588, 0.07197028447224274, 0.0941809933957738, 0.08344751676648976]}, "mutation_prompt": null}
{"id": "87a699d8-87c1-4289-b915-024a5c90ddfc", "solution": "import numpy as np\n\nclass HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = int(np.sqrt(budget))\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.swarm_size, self.dim))\n        self.velocities = np.zeros((self.swarm_size, self.dim))\n        self.best_positions = np.copy(self.particles)\n        self.best_fitness = np.inf * np.ones(self.swarm_size)\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, size=self.dim)\n        self.global_best_fitness = np.inf\n        self.archive = []\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.adaptive_cooling_rate = 0.5\n        self.levy_flight_alpha = 1.5\n        self.levy_flight_beta = 1.8\n        self.opposition_based_learning_rate = 0.2\n        self.dynamic_opposition_based_learning_rate = 0.1\n        self.inertia_weight = 0.9\n        self.inertia_weight_damping_ratio = 0.99\n        self.mutation_rate = 0.1\n        self.mutation_step_size = 0.1\n        self.velocity_clustering_rate = 0.1\n        self.particle_filtering_rate = 0.2\n        self.archive_size = int(0.1 * budget)\n        self.dynamic_velocity_update_rate = 0.1\n\n    def levy_flight(self, size):\n        r1 = np.random.uniform(size=size)\n        r2 = np.random.uniform(size=size)\n        return 0.01 * r1 / (r2 ** (1 / self.levy_flight_beta))\n\n    def cauchy_mutation(self, position):\n        mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n        mutation_vector = np.random.standard_cauchy(size=self.dim)\n        return position + mutation_vector * mutation_mask\n\n    def gaussian_perturbation(self, position):\n        perturbation_vector = np.random.normal(loc=0, scale=0.1, size=self.dim)\n        return position + perturbation_vector\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def velocity_clustering(self, velocities):\n        velocity_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        velocity_clusters = np.argmin(np.linalg.norm(velocities[:, np.newaxis] - velocity_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_velocities = velocities[velocity_clusters == i]\n            if len(cluster_velocities) > 0:\n                velocity_centroids[i] = np.mean(cluster_velocities, axis=0)\n        return velocity_centroids\n\n    def particle_filtering(self, particles):\n        particle_centroids = np.random.uniform(-1, 1, size=(3, self.dim))\n        particle_clusters = np.argmin(np.linalg.norm(particles[:, np.newaxis] - particle_centroids, axis=2), axis=1)\n        for i in range(3):\n            cluster_particles = particles[particle_clusters == i]\n            if len(cluster_particles) > 0:\n                particle_centroids[i] = np.mean(cluster_particles, axis=0)\n        return particle_centroids\n\n    def update_archive(self, position, fitness):\n        if len(self.archive) < self.archive_size:\n            self.archive.append((position, fitness))\n        else:\n            worst_index = np.argmax([f for _, f in self.archive])\n            if fitness < self.archive[worst_index][1]:\n                self.archive[worst_index] = (position, fitness)\n\n    def dynamic_velocity_update(self, velocities, best_positions, global_best_position):\n        velocity_centroids = self.velocity_clustering(velocities)\n        for i in range(self.swarm_size):\n            if np.random.rand() < self.dynamic_velocity_update_rate:\n                velocities[i] = velocity_centroids[np.argmin(np.linalg.norm(velocities[i] - velocity_centroids, axis=1))]\n            velocities[i] = 0.5 * velocities[i] + 0.5 * np.random.uniform(-1, 1, size=self.dim) + 0.5 * (best_positions[i] - velocities[i]) + 0.5 * (global_best_position - velocities[i]) + 0.1 * np.random.uniform(-1, 1, size=self.dim)\n        return velocities\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                fitness = func(self.particles[i])\n                evaluations += 1\n                if fitness < self.best_fitness[i]:\n                    self.best_fitness[i] = fitness\n                    self.best_positions[i] = np.copy(self.particles[i])\n                    self.update_archive(self.particles[i], fitness)\n                    if fitness < self.global_best_fitness:\n                        self.global_best_fitness = fitness\n                        self.global_best_position = np.copy(self.particles[i])\n                # Dynamic velocity update\n                self.velocities = self.dynamic_velocity_update(self.velocities, self.best_positions, self.global_best_position)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                # Levy flight for enhanced global search\n                if np.random.rand() < 0.1:\n                    self.particles[i] += self.levy_flight(self.dim)\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                # Dynamic opposition-based learning with adaptive rate\n                if np.random.rand() < self.opposition_based_learning_rate * (1 - evaluations / self.budget) * (1 + self.dynamic_opposition_based_learning_rate * (evaluations / self.budget)):\n                    opposition_position = self.opposition_based_learning(self.particles[i])\n                    opposition_fitness = func(opposition_position)\n                    evaluations += 1\n                    if opposition_fitness < fitness:\n                        self.particles[i] = opposition_position\n                        self.best_fitness[i] = opposition_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], opposition_fitness)\n                # Cauchy mutation and Gaussian perturbation\n                if np.random.rand() < self.mutation_rate * (1 - evaluations / self.budget):\n                    mutated_position = self.cauchy_mutation(self.particles[i])\n                    mutated_position = self.gaussian_perturbation(mutated_position)\n                    mutated_fitness = func(mutated_position)\n                    evaluations += 1\n                    if mutated_fitness < fitness:\n                        self.particles[i] = mutated_position\n                        self.best_fitness[i] = mutated_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], mutated_fitness)\n                # Particle filtering for enhanced exploration\n                if np.random.rand() < self.particle_filtering_rate:\n                    particle_centroids = self.particle_filtering(self.particles)\n                    self.particles[i] = particle_centroids[np.argmin(np.linalg.norm(self.particles[i] - particle_centroids, axis=1))]\n                # Archive-based position update\n                if np.random.rand() < 0.05:\n                    archive_index = np.random.randint(len(self.archive))\n                    self.particles[i] = self.archive[archive_index][0]\n            # Modified simulated annealing with adaptive cooling\n            if evaluations % (self.swarm_size // 2) == 0:\n                for i in range(self.swarm_size // 2):\n                    new_position = np.copy(self.particles[i])\n                    new_position += np.random.uniform(-1, 1, size=self.dim)\n                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_position)\n                    evaluations += 1\n                    if new_fitness < self.best_fitness[i] or np.random.rand() < np.exp((self.best_fitness[i] - new_fitness) / self.temperature):\n                        self.particles[i] = new_position\n                        self.best_fitness[i] = new_fitness\n                        self.best_positions[i] = np.copy(self.particles[i])\n                        self.update_archive(self.particles[i], new_fitness)\n                    self.temperature *= self.cooling_rate * (1 - self.adaptive_cooling_rate * (evaluations / self.budget))\n            # Dynamic inertia weight\n            self.inertia_weight *= self.inertia_weight_damping_ratio\n        return self.global_best_position\n\n# Example usage:\ndef example_func(x):\n    return np.sum(x**2)\n\noptimizer = HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3(budget=1000, dim=10)\nresult = optimizer(example_func)\nprint(result)", "name": "HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3", "description": "Novel hybrid swarm optimizer with adaptive cooling, levy flight, opposition-based learning, dynamic inertia weight, self-adaptive mutation, velocity clustering, particle filtering, and archive-based position updates, incorporating a new \"Dynamic Velocity Update\" strategy and \"Adaptive Archive Size\" to further enhance convergence speed and diversity of the swarm.", "configspace": "", "generation": 99, "fitness": 0.12325951559058393, "feedback": "The algorithm HybridSwarmOptimizerACLOBLDIWSAMV2PFRefinedV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "4e74979b-a0c6-4e0a-bfe6-5c1604805ce3", "metadata": {"aucs": [0.20848684573525067, 0.19126664186933529, 0.15589085087829657, 0.2268673927764645, 0.20755821632816318, 0.21569024737158293, 0.17194794082857856, 0.15656260575316883, 0.20255164489324728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06728492142226183, 0.03639004572854987, 0.03150932728522271, 0.04752368283383279, 0.03074188693938462, 0.050471652047795024, 0.04684808453240419, 0.03781936359927074, 0.03675523807007253, 0.02109251351585939, 0.02052491467459272, 0.03520702461128078, 0.021627183292734276, 0.030506083668424666, 0.010588666728176377, 0.0461637925515439, 0.02256229622258432, 0.036547758074451986, 0.9648620617142483, 0.9783425260104293, 0.9535479181758939, 0.9563812799383103, 0.9325402065599189, 0.9730873369526328, 0.9692022420111277, 0.9521829441803586, 0.9457099131775374, 0.06267247986442037, 0.07395984280846257, 0.06765867730410247, 0.10992468858613069, 0.07333374466876208, 0.02853093082435676, 0.05577042487907424, 0.05016022783369112, 0.09686099586634389, 0.11638881753028563, 0.14303611158793716, 0.10649993047402329, 0.10968454541568029, 0.154274770311158, 0.08419544327787931, 0.1331930911693573, 0.0899830565458567, 0.11063620490290138, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008960034397826888, 9.999999999998899e-05, 0.015639548340945608, 9.999999999998899e-05, 0.014777303803276687, 0.04592633779757793, 0.002560025650683695, 0.0009546303849637949, 9.999999999998899e-05, 0.0021547634914562686, 9.999999999998899e-05, 0.00958933264965689, 0.005853174418439133, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04571097100496213, 0.0002678401342809389, 0.034528882657043125, 0.048605261703705605, 0.03331098653742082, 9.999999999998899e-05, 0.03191807692298221, 0.005390011622084079, 0.0361688694798169, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19376010288017664, 0.19175173401289158, 0.23378624076957166, 0.1534392303313139, 0.14563994336649067, 0.22418671242005828, 0.18768335937935032, 0.16472124763023333, 0.16980157156825948, 0.10312863852472276, 0.03329771849580898, 0.05361563585656348, 0.047644739096340705, 0.03161192694362802, 0.06345945704621136, 0.04900287905838452, 0.03152247216999182, 0.06083282840048565, 0.14213712598495454, 0.12519313074176475, 0.13177675727429794, 0.15278902444235865, 0.13791826381003558, 0.16531837627780677, 0.15112116295458722, 0.14570293639605547, 0.18736292529275855, 0.14524078431137, 0.1444901812690832, 0.16622841140566125, 0.16512645516845748, 0.1725962485875121, 0.16167952017572773, 0.1640718158758283, 0.17906183552183264, 0.14788656716000037, 0.08821314422549964, 0.06989168002726942, 0.11724818560084316, 0.12265762377884382, 0.11763349275721335, 0.10981631304853978, 0.09288046682509177, 0.1616802027769325, 0.08804709577440517, 0.1553427059356396, 0.16413759581459542, 0.17153755002851379, 0.13383423238714898, 0.14247961119361008, 0.12589809326514845, 0.1316932610860615, 0.17110184192973488, 0.16268301032877774, 0.14231755663624557, 0.15229868263720558, 0.13699315026174919, 0.13163738473082554, 0.13436521607228735, 0.14237914393572249, 0.1353061666640195, 0.12799974929449676, 0.18910043150709133, 0.11780293561932031, 0.16245642657926163, 0.1420129810135874, 0.2251455187087047, 0.1414412934384911, 0.2044647189257628, 0.13615237039138517, 0.16446891961730215, 0.22061986781711973, 0.19062173159853568, 0.13135404004025508, 0.15284607825458518, 0.11785146302712657, 0.10987786508580999, 0.13463601056251195, 0.16250013271957575, 0.18387482618227802, 0.20806194436606207, 0.17895522594383895, 0.19883399010473635, 0.20109879593459146, 0.18598537546057492, 0.1758771646435645, 0.17587581998149815, 0.18101021600999367, 0.2139379322988254, 0.18835940906256254, 0.03648244861678651, 0.07002704963643303, 0.05147748687695508, 0.05056636279311766, 0.05257353499924833, 0.04592033781450422, 0.0587924873803749, 0.04972024583615897, 0.05208752530006555]}, "mutation_prompt": null}
