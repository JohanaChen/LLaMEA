{"id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 75, in evaluateBBOB\n  File \"<string>\", line 84, in evaluate_func\nTypeError: 'Individual' object is not callable\n.", "error": "TypeError(\"'Individual' object is not callable\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 75, in evaluateBBOB\n  File \"<string>\", line 84, in evaluate_func\nTypeError: 'Individual' object is not callable\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "2f399f0b-3f8d-42ae-b7b7-1d6d4d6540b4", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.adaptive_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation and crossover probabilities\n            for _ in range(int(self.budget * self.adaptive_prob)):\n                # Calculate mutation and crossover probabilities\n                mu = np.random.uniform(0, 1)\n                c = np.random.uniform(0, 1)\n\n                # Calculate new solution\n                if mu < 0.5:\n                    # Mutation\n                    new_solution = population[i, :] + np.random.uniform(-1, 1, self.dim)\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n                else:\n                    # Crossover\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "7b4aaa19-2e4c-4fd9-bdd2-fbfad39f8184", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if np.random.rand() < self.mutation_prob:\n                        new_solution = new_solution + np.random.uniform(-0.1, 0.1, self.dim)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "dcbd0a75-68df-4922-bae0-da8c095b0798", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Refine strategy with 0.05 probability\n        for i in range(self.dim):\n            if random.random() < 0.05:\n                # Randomly select two individuals\n                j = random.randint(0, self.dim - 1)\n                k = random.randint(0, self.dim - 1)\n\n                # Calculate crossover point\n                if j < k:\n                    crossover_point = np.random.randint(j + 1, k)\n                else:\n                    crossover_point = np.random.randint(k + 1, j + 1)\n\n                # Calculate new solution\n                new_solution = population[j, :] + (population[k, :] - population[j, :]) * (crossover_point - j) / (k - j)\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with 0.05 probability to refine its strategy", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "93d19ef6-ffe2-47a1-a836-bb2fef7ef4e6", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.adaptive_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation and crossover\n            for _ in range(self.dim):\n                if np.random.rand() < self.adaptive_prob:\n                    # Calculate mutation\n                    mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                    new_solution = population[:, _] + mutation\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Calculate crossover\n                    crossover = np.random.uniform(-1.0, 1.0, self.dim)\n                    new_solution = new_solution + crossover\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[_]:\n                        self.f_best[_] = f_value\n                        self.x_best[_] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation and crossover probability.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "102e3878-fc1b-49fa-ab95-6ebf32e05194", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution with probability 0.05\n                    if random.random() < 0.05:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with probability 0.05 to refine its strategy.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "20a0ef3b-a8c4-4ec4-9e01-2bb5906c3921", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability 0.05\n                    if np.random.rand() < self.mutation_prob:\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        new_solution = new_solution + mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "0d542ec5-b969-4d29-a784-52cbca5e7f3b", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adaptive mutation and crossover probabilities\n        mutation_prob = 0.05\n        crossover_prob = 0.05\n\n        for i in range(self.dim):\n            if np.random.rand() < mutation_prob:\n                # Random mutation\n                mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                new_solution = population[i, :] + mutation\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n            if np.random.rand() < crossover_prob:\n                # Random crossover\n                k = np.random.randint(0, self.dim)\n                new_solution = population[i, :] + population[k, :] - population[k, :] * population[i, :]\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "ba2ca327-a688-43ab-a8d9-f9bffabbfd90", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation probability\n            for _ in range(int(self.budget * 0.05)):\n                # Select a random individual\n                individual = np.random.choice(population, 1)[0]\n\n                # Generate a random mutation\n                mutation = np.random.uniform(-1.0, 1.0, self.dim)\n\n                # Apply mutation to the individual\n                new_individual = individual + mutation\n\n                # Clip the new individual to the bounds\n                new_individual = np.clip(new_individual, -5.0, 5.0)\n\n                # Evaluate the new individual\n                f_value = func(new_individual)\n\n                # Update the best individual if necessary\n                if f_value < self.f_best[np.argmin(self.f_best)]:\n                    self.f_best = self.f_best.copy()\n                    self.x_best = population[np.argmin(self.f_best)]\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "834d498b-e463-4ada-b6b4-4d2081779e62", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adaptive mutation\n        for i in range(self.dim):\n            if np.random.rand() < 0.05:\n                mutation = np.random.uniform(-0.1, 0.1, self.dim)\n                new_solution = population[i, :] + mutation\n                new_solution = new_solution / np.max(np.abs(new_solution))\n                f_value = func(new_solution)\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation and crossover.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "11fb74c6-7b90-4b22-b93c-aa1ff9a5e7bb", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.refine_probability = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Refine individual lines with probability 0.05\n                    if np.random.rand() < self.refine_probability:\n                        # Randomly select two individuals\n                        idx1 = np.random.randint(0, self.dim)\n                        idx2 = np.random.randint(0, self.dim)\n\n                        # Calculate crossover point\n                        k = np.random.randint(idx1 + 1, idx2)\n\n                        # Calculate new solution\n                        new_solution = population[idx1, :] + (population[idx2, :] - population[idx1, :]) * np.random.uniform(0, 1)\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[idx1]:\n                            self.f_best[idx1] = f_value\n                            self.x_best[idx1] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with probability 0.05 to refine individual lines.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "a8689615-7fe7-4c34-8604-9e34ddc0f0de", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n\n                    # Apply mutation\n                    if np.random.rand() < self.mutation_prob:\n                        new_solution += np.random.uniform(-0.1, 0.1, self.dim)\n\n                    # Apply crossover\n                    if np.random.rand() < self.crossover_prob:\n                        k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n                        new_solution = np.concatenate((population[i, :k], population[k, k:]))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "9cf8bad7-8d95-4543-8031-a9a5702ed81a", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adaptive mutation\n        for i in range(self.dim):\n            if random.random() < 0.05:\n                # Calculate mutation vector\n                mutation = np.random.uniform(-1.0, 1.0, (self.dim,))\n                mutation = mutation / np.max(np.abs(mutation))\n\n                # Calculate new solution\n                new_solution = population[i, :] + mutation\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "06d9c2ed-85fb-4322-b902-08695bd3ccf4", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.refine_probability = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Refine strategy\n        if random.random() < self.refine_probability:\n            # Randomly select two individuals\n            i = random.randint(0, self.dim - 1)\n            j = random.randint(0, self.dim - 1)\n\n            # Calculate crossover point\n            k = np.random.randint(i + 1, (i + 2) % self.dim)\n\n            # Calculate differential evolution vector\n            diff = population[k, :] - population[i, :]\n            diff = diff / np.max(np.abs(diff))\n\n            # Calculate new solution\n            new_solution = population[i, :] + diff\n            new_solution = new_solution / np.max(np.abs(new_solution))\n\n            # Evaluate new solution\n            f_value = func(new_solution)\n\n            # Update best solution\n            if f_value < self.f_best[j]:\n                self.f_best[j] = f_value\n                self.x_best[j] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with probability 0.05 to refine its strategy.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "17f7c006-ca6f-404a-a17d-e6d25e77816e", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p = 0.05  # Probability to change individual lines\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Change individual lines with probability p\n                    if np.random.rand() < self.p:\n                        # Randomly change one dimension of the new solution\n                        new_solution[i, np.random.randint(self.dim)] += np.random.uniform(-1, 1)\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "7c1bc263-1923-4ace-81ef-d90fbc4336f5", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p_mut = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation probability\n                    if random.random() < self.p_mut:\n                        # Randomly select a dimension to mutate\n                        mutate_dim = np.random.randint(self.dim)\n                        # Calculate mutation vector\n                        mutate_vector = np.random.uniform(-1.0, 1.0, self.dim)\n                        # Calculate new solution\n                        new_solution = population[i, :] + mutate_vector\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "e53e9763-b59f-4cf5-a173-620f65d7485c", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n        # Initialize adaptive mutation and crossover probabilities\n        self.mut_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with adaptive probability\n                    if np.random.rand() < self.mut_prob:\n                        new_solution += np.random.uniform(-0.1, 0.1, self.dim)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Apply crossover with adaptive probability\n                    if np.random.rand() < self.crossover_prob:\n                        k = np.random.randint(0, self.dim)\n                        new_solution[k] = population[k, :] + np.random.uniform(-0.1, 0.1, self.dim)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "e1b1503b-bfe9-4573-88c7-ad52a7054d5c", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.adaptive_mutation = np.random.uniform(0.05, 0.1, (self.dim, self.budget))\n        self.adaptive_crossover = np.random.uniform(0.05, 0.1, (self.dim, self.budget))\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff * self.adaptive_mutation[i, :]\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply adaptive crossover\n                    new_solution = population[i, :] + diff * self.adaptive_crossover[i, :]\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation and crossover.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "376dfc54-75d2-4c89-a7a2-c37ce8268366", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mut_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with adaptive probability\n                    if np.random.rand() < self.mut_prob:\n                        # Randomly select a dimension to mutate\n                        idx = np.random.randint(self.dim)\n                        # Mutate the selected dimension\n                        new_solution[idx] += np.random.uniform(-0.1, 0.1)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n            # Evaluate the best individual\n            f_value = func(self.x_best)\n            if f_value < self.f_best:\n                self.f_best = f_value\n                self.x_best = self.x_best\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "e4d38c31-4533-4c4a-9f6a-b45b7d11adaf", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Refine strategy with 0.05 probability\n                    if np.random.rand() < 0.05:\n                        # Randomly select two individuals\n                        idx1 = np.random.randint(0, self.dim)\n                        idx2 = np.random.randint(0, self.dim)\n\n                        # Calculate new solution using CR\n                        new_solution = population[idx1, :] + 0.5 * (population[idx2, :] - population[idx1, :])\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[idx1]:\n                            self.f_best[idx1] = f_value\n                            self.x_best[idx1] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization with 0.05 probability to refine strategy.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "8bf6ee0a-a0af-43c4-b434-d0dd90e5880c", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_rate = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation\n                    if np.random.rand() < self.mutation_rate:\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        new_solution = new_solution + mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation strategy.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "692312e2-0ece-49a0-ba21-3dd73b1c27a5", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_probability = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation\n            for i in range(self.dim):\n                if np.random.rand() < self.mutation_probability:\n                    # Generate a random mutation\n                    mutation = np.random.uniform(-1.0, 1.0, self.dim)\n\n                    # Apply mutation to the solution\n                    new_solution = population[i, :] + mutation\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "6681fcac-754a-426f-9daa-ab6331434261", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Refine strategy with probability 0.05\n        refine = np.random.rand(self.dim) < 0.05\n        for i in range(self.dim):\n            if refine[i]:\n                # Randomly select two parents\n                parent1 = np.random.randint(0, self.budget)\n                parent2 = np.random.randint(0, self.budget)\n\n                # Calculate crossover point\n                k = np.random.randint(parent1, parent2)\n\n                # Calculate new solution\n                new_solution = (population[parent1, :] + population[parent2, :]) / 2\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with probability 0.05 to refine its strategy", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "de2ddcb9-3336-405d-82e1-ed4d851d5758", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mut_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if np.random.rand() < self.mut_prob:\n                        # Calculate mutation vector\n                        mut_vec = np.random.uniform(-0.1, 0.1, self.dim)\n                        mut_vec = mut_vec / np.max(np.abs(mut_vec))\n\n                        # Calculate new solution\n                        new_solution = new_solution + mut_vec\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "a9548e7e-efea-48d4-94fd-eed5ba41074e", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if np.random.rand() < self.mutation_prob:\n                        new_solution += np.random.uniform(-0.1, 0.1, self.dim)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Apply crossover with probability\n                    if np.random.rand() < self.crossover_prob:\n                        other_solution = population[np.random.randint(0, self.dim), :]\n                        new_solution = (new_solution + other_solution) / 2\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with adaptive mutation and crossover.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "21916634-bf54-4cce-8cfc-b7bbd87f88c2", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if np.random.rand() < self.mutation_prob:\n                        # Add Gaussian noise to new solution\n                        new_solution += np.random.normal(0, 0.1, self.dim)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "3fe495fb-31aa-4c08-8fc5-2b6dd4636e3c", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adaptive mutation strategy\n        mutation_rate = 0.05\n        for i in range(self.dim):\n            if random.random() < mutation_rate:\n                # Random mutation\n                mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                new_solution = self.x_best[i] + mutation\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation strategy.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "495b596c-7fd8-4ef2-911b-fa82999034ac", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_rate = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if np.random.rand() < self.mutation_rate:\n                        new_solution += np.random.uniform(-0.1, 0.1, self.dim)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "0a289c78-1e74-4cfc-92c5-0288e0b1e196", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability 0.05\n                    if random.random() < self.mutation_prob:\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        new_solution += mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation strategy.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "afd91e08-f299-4313-87ef-e9eb2abd6a39", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation probability\n            mutation_prob = 0.05\n            for _ in range(int(self.budget * mutation_prob)):\n                i = np.random.randint(0, self.dim)\n                j = np.random.randint(0, self.budget)\n                new_solution = population[i, j]\n                new_solution = new_solution + np.random.uniform(-1, 1, self.dim)\n                new_solution = new_solution / np.max(np.abs(new_solution))\n                f_value = func(new_solution)\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "6febc125-16fa-4820-9e51-eb9a3b9319e9", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mut_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability 0.05\n                    if random.random() < self.mut_prob:\n                        # Generate a random mutation vector\n                        mut_vector = np.random.uniform(-1.0, 1.0, (self.dim,))\n\n                        # Apply mutation to new solution\n                        new_solution = new_solution + mut_vector\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "6d634ce2-8cea-4e01-80de-e018de351d8c", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p_crossover = 0.05\n        self.p_mutation = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Crossover with probability p_crossover\n                    if np.random.rand() < self.p_crossover:\n                        crossover_point = np.random.randint(j * self.dim, (j + 1) * self.dim)\n                        new_solution = population[i, :crossover_point] + population[k, crossover_point:]\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n                        f_value = func(new_solution)\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n                    # Mutation with probability p_mutation\n                    if np.random.rand() < self.p_mutation:\n                        mutation_point = np.random.randint(0, self.dim)\n                        new_solution = population[i, :]\n                        new_solution[mutation_point] += np.random.uniform(-1, 1)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n                        f_value = func(new_solution)\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "c6a9376a-d73b-4255-8da5-e53b9c82b78b", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.adapt_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation and crossover probabilities\n                    if np.random.rand() < self.adapt_prob:\n                        # Randomly adjust mutation and crossover probabilities\n                        self.adapt_prob = np.random.uniform(0.01, 0.1)\n                        print(f\"Adaptive mutation and crossover probabilities adjusted to {self.adapt_prob}\")\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "e7fe2a07-643d-432d-afd5-338d5ab15e23", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adaptive mutation probability\n        mutation_prob = 0.05\n        for i in range(self.dim):\n            if np.random.rand() < mutation_prob:\n                # Calculate mutation vector\n                mutation = np.random.uniform(-0.1, 0.1, (self.dim,))\n\n                # Apply mutation\n                new_solution = population[i, :] + mutation\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "a1f8045f-b0ca-43e6-886d-ec8be8d3c957", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation\n                    if np.random.rand() < self.mutation_prob:\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        new_solution += mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "c4f6d10a-fcce-4469-9e0b-b58293b13a7b", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability 0.05\n                    if np.random.rand() < self.mutation_prob:\n                        # Generate a random mutation vector\n                        mutation = np.random.uniform(-0.1, 0.1, (self.dim,))\n\n                        # Apply mutation to the new solution\n                        new_solution += mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation strategy.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "8b678130-40e6-47eb-8d99-c40f8ddaac76", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mut_prob = 0.05  # Adaptive mutation probability\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with adaptive probability\n                    if np.random.rand() < self.mut_prob:\n                        # Generate a random index\n                        idx = np.random.randint(0, self.dim)\n\n                        # Generate a random mutation vector\n                        mut_vector = np.random.uniform(-1.0, 1.0, (self.dim,))\n\n                        # Apply mutation\n                        new_solution[idx, :] += mut_vector * np.max(np.abs(population[idx, :]))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[idx]:\n                            self.f_best[idx] = f_value\n                            self.x_best[idx] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "005246dd-c9f5-4d6e-91f3-b53c9b721b8d", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adaptive mutation\n        mutation_rate = 0.05\n        for i in range(self.dim):\n            if np.random.rand() < mutation_rate:\n                # Generate a random mutation vector\n                mutation_vector = np.random.uniform(-1.0, 1.0, self.dim)\n                mutation_vector = mutation_vector / np.max(np.abs(mutation_vector))\n\n                # Apply mutation to the current solution\n                new_solution = self.x_best[i] + mutation_vector\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "1d2ae319-4376-49a9-8789-ea3a1582838d", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if np.random.rand() < self.mutation_prob:\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        new_solution += mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability for black box optimization.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "043232e3-04ae-4286-b379-d1f55e6c6f60", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mut_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation probability\n                    if np.random.rand() < self.mut_prob:\n                        # Calculate mutation vector\n                        mut_vec = np.random.uniform(-0.1, 0.1, (self.dim,))\n\n                        # Calculate new solution\n                        new_solution += mut_vec\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "e86c3a65-bba1-4a58-b147-63d0d6e0a1b4", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        # With probability 0.05, replace the best solution with the new solution\n                        if np.random.rand() < self.p:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "671a8715-0368-4e69-b7c6-e1f1ca2bad1c", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with adaptive probability\n                    if np.random.rand() < self.mutation_prob:\n                        mutation = np.random.uniform(-1.0, 1.0, (self.dim,))\n                        new_solution += mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        f_value = func(new_solution)\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "379ec878-d32a-4ad1-8000-ec9d782d4558", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_probability = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if random.random() < self.mutation_probability:\n                        mutation_index = np.random.randint(self.dim)\n                        new_solution[mutation_index] += np.random.uniform(-0.1, 0.1)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[mutation_index]:\n                            self.f_best[mutation_index] = f_value\n                            self.x_best[mutation_index] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation strategy.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "9d131e25-8a40-4ec1-9d75-687d18a2a704", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation probability\n                    mutation_prob = np.random.rand()\n                    if mutation_prob < 0.05:\n                        mutation_prob = np.random.uniform(0.0, 1.0)\n                        new_solution += np.random.normal(0.0, 0.1, self.dim)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability for black box optimization.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "779c1725-72cb-4b6e-9b9f-7cb19e094096", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p_mut = 0.05  # Adaptive mutation probability\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation\n                    if np.random.rand() < self.p_mut:\n                        # Calculate mutation vector\n                        mu = np.random.uniform(-1.0, 1.0, self.dim)\n                        mu = mu / np.max(np.abs(mu))\n\n                        # Calculate new solution\n                        new_solution = new_solution + mu\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "a2ee4ef2-414c-4147-a9f3-072db13c4dc3", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mut_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation probability\n                    if np.random.rand() < self.mut_prob:\n                        # Randomly mutate the solution\n                        mutated_solution = new_solution + np.random.uniform(-0.1, 0.1, self.dim)\n                        mutated_solution = mutated_solution / np.max(np.abs(mutated_solution))\n                        f_value = func(mutated_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = mutated_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "ec160341-b70b-4b04-9785-69589f0b1577", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adaptive mutation and crossover probability\n        mutation_prob = 0.05\n        crossover_prob = 0.05\n\n        for i in range(self.dim):\n            for j in range(1, self.budget // self.dim):\n                # Calculate crossover point\n                k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                # Calculate differential evolution vector\n                diff = population[k, :] - population[i, :]\n                diff = diff / np.max(np.abs(diff))\n\n                # Calculate new solution\n                new_solution = population[i, :] + diff\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n                # Apply mutation with probability\n                if np.random.rand() < mutation_prob:\n                    mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                    new_solution = new_solution + mutation\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                # Apply crossover with probability\n                if np.random.rand() < crossover_prob:\n                    new_solution = population[np.random.randint(0, self.dim), :]\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation and crossover probability.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "1aed00a9-2413-41a2-9a7c-6df609bf3321", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if np.random.rand() < self.mutation_prob:\n                        # Randomly select two solutions\n                        idx1, idx2 = np.random.randint(0, self.dim, 2)\n                        # Calculate mutation vector\n                        mutation = new_solution[idx1] - new_solution[idx2]\n                        # Calculate new solution\n                        new_solution[idx1] = new_solution[idx1] + mutation * np.random.uniform(-1, 1)\n                        new_solution[idx1] = new_solution[idx1] / np.max(np.abs(new_solution[idx1]))\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n                        # Update best solution\n                        if f_value < self.f_best[idx1]:\n                            self.f_best[idx1] = f_value\n                            self.x_best[idx1] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with probability-based mutation.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "9000ba3f-5605-43a3-8d70-49a254d36b84", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)\n\n# Refine the strategy by changing individual lines with probability 0.05\nimport random\n\nclass RefinedDEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Refine the strategy by changing individual lines with probability 0.05\n        for i in range(self.dim):\n            if random.random() < 0.05:\n                new_individual = np.random.uniform(-5.0, 5.0, self.dim)\n                new_individual = new_individual / np.max(np.abs(new_individual))\n                self.x_best[i] = new_individual\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\nrefined_deaed = RefinedDEAED(budget, dim)\nf_best, x_best = refined_deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "93292f06-a68b-43ad-bf37-47b9a261fcf9", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adaptive mutation\n        mutation_rate = 0.05\n        for i in range(self.dim):\n            if random.random() < mutation_rate:\n                # Calculate mutation vector\n                mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                mutation = mutation / np.max(np.abs(mutation))\n\n                # Calculate new solution\n                new_solution = self.x_best[i] + mutation\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization with adaptive mutation strategy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "e41637f9-15eb-49b5-b9a9-f9dc4e6f38fa", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution with probability 0.05\n                    if np.random.rand() < 0.05:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with probability 0.05 to change individual lines for black box optimization.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "0c9b8103-a894-4472-aceb-fa3f00916024", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mut_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation probability\n                    if np.random.rand() < self.mut_prob:\n                        # Calculate mutation vector\n                        mut_vector = np.random.uniform(-1.0, 1.0, self.dim)\n                        mut_vector = mut_vector / np.max(np.abs(mut_vector))\n\n                        # Calculate new solution\n                        new_solution = population[i, :] + mut_vector\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "de5083d0-7940-4287-94d1-8bcf30f99040", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p_change = 0.05  # Probability to change individual lines\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Change individual line with probability 0.05\n                    if np.random.rand() < self.p_change:\n                        self.x_best[i] = np.random.uniform(-5.0, 5.0)\n                        self.x_best[i] = self.x_best[i] / np.max(np.abs(self.x_best[i]))\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with probability 0.05 to change individual lines for black box optimization.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "506a8762-aa09-4e09-b2c1-401f7e2cbc1f", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_rate = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation\n                    if random.random() < self.mutation_rate:\n                        mutation = np.random.uniform(-0.5, 0.5, self.dim)\n                        new_solution += mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation strategy for black box optimization.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "23eb1f43-1cc9-41b8-9a11-8b90dff6ec23", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with adaptive probability\n                    if np.random.rand() < self.mutation_prob:\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        new_solution += mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        f_value = func(new_solution)\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with adaptive mutation probability.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "6a02d891-8ed6-4346-bacf-c6287682cacf", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Refine strategy\n        for i in range(self.dim):\n            if random.random() < self.p:\n                # Randomly select an individual\n                individual = random.choice(population[i, :])\n\n                # Randomly change a dimension\n                dimension = random.randint(0, self.dim - 1)\n                new_value = individual[dimension] + np.random.uniform(-0.5, 0.5)\n                new_value = np.clip(new_value, -5.0, 5.0)\n                new_individual = np.copy(individual)\n                new_individual[dimension] = new_value\n\n                # Evaluate new individual\n                f_value = func(new_individual)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_individual\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "19a6bf4e-2972-4369-8e7b-4aab15127ebd", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Probability-based mutation\n        mutation_rate = 0.05\n        for i in range(self.dim):\n            if random.random() < mutation_rate:\n                # Calculate mutation vector\n                mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                mutation = mutation / np.max(np.abs(mutation))\n\n                # Calculate new solution\n                new_solution = self.x_best[i] + mutation\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with probability-based mutation for black box optimization.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "f6723cb7-1bd8-4d62-a71c-b7468110abd6", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.crossover_prob = 0.05\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :]\n                    if np.random.rand() < self.mutation_prob:\n                        new_solution += np.random.uniform(-0.1, 0.1, self.dim)\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Calculate crossover probability\n                    if np.random.rand() < self.crossover_prob:\n                        # Calculate crossover point\n                        crossover_point = np.random.randint(0, self.dim)\n\n                        # Calculate new solution\n                        new_solution = np.concatenate((population[i, :crossover_point], new_solution[crossover_point:]))\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation and crossover probability.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "7aa80f96-e093-46fd-9a24-aaf1ca4fec46", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p = 0.05  # probability of mutation\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation\n            if np.random.rand() < self.p:\n                # Select a random individual\n                idx = np.random.randint(0, self.budget)\n                # Select a random dimension\n                dim_idx = np.random.randint(0, self.dim)\n                # Generate a new solution by adding a random mutation\n                new_solution = population[idx, :]\n                new_solution[dim_idx] += np.random.uniform(-0.1, 0.1)\n                new_solution = new_solution / np.max(np.abs(new_solution))\n                # Evaluate the new solution\n                f_value = func(new_solution)\n                # Update the best solution if necessary\n                if f_value < self.f_best[idx]:\n                    self.f_best[idx] = f_value\n                    self.x_best[idx] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "0edbe7b5-db6e-4a6e-8c89-c81c62a2a1ee", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation strategy\n            mutation_prob = 0.05\n            for i in range(self.dim):\n                if random.random() < mutation_prob:\n                    # Generate a random mutation\n                    mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                    new_solution = population[i, :] + mutation\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation strategy.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "3434f220-cfe5-4628-b74a-48fd076c308e", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n        # Initialize adaptive mutation and crossover probabilities\n        self.mut_prob = 0.05\n        self.cro_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n\n                    # Randomly decide whether to mutate or not\n                    if np.random.rand() < self.mut_prob:\n                        # Randomly decide whether to crossover or not\n                        if np.random.rand() < self.cro_prob:\n                            # Calculate crossover point\n                            l = np.random.randint(j * self.dim, (j + 1) * self.dim)\n                            new_solution = new_solution[:l] + diff[l:]\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "a4802273-1d98-4186-84e1-850cc05d61ba", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mut_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with adaptive probability\n                    if np.random.rand() < self.mut_prob:\n                        # Randomly select a dimension to mutate\n                        mutated_dim = np.random.randint(0, self.dim)\n\n                        # Generate a random mutation vector\n                        mut_vec = np.random.uniform(-0.5, 0.5, (self.dim,))\n\n                        # Apply mutation\n                        new_solution[mutated_dim] += mut_vec\n\n                        # Normalize the new solution\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate the mutated solution\n                        f_value = func(new_solution)\n\n                        # Update the best solution if necessary\n                        if f_value < self.f_best[mutated_dim]:\n                            self.f_best[mutated_dim] = f_value\n                            self.x_best[mutated_dim] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "3a790cfc-f619-4076-990c-7c56d8c25fbf", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mut_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation probability\n                    if random.random() < self.mut_prob:\n                        mutation_index = np.random.randint(0, self.dim)\n                        new_solution[mutation_index] += np.random.uniform(-1, 1)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n                        f_value = func(new_solution)\n                        if f_value < self.f_best[mutation_index]:\n                            self.f_best[mutation_index] = f_value\n                            self.x_best[mutation_index] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "cd940506-6f67-43d0-9485-c3b8d885a880", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        # Adaptive mutation and crossover probabilities\n        mutation_prob = 0.05\n        crossover_prob = 0.05\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation\n                    if np.random.rand() < mutation_prob:\n                        new_solution += np.random.uniform(-0.1, 0.1, self.dim)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Adaptive crossover\n                    if np.random.rand() < crossover_prob:\n                        k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n                        new_solution = population[i, :] + population[k, :] - population[k, :] * population[k, :] * np.random.uniform(0, 1, self.dim)\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "23185100-539b-4894-a12a-540f38b189ce", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation\n            for _ in range(int(self.budget * 0.05)):\n                # Generate a random individual\n                new_individual = np.random.uniform(-5.0, 5.0, self.dim)\n                new_individual = new_individual / np.max(np.abs(new_individual))\n\n                # Evaluate new individual\n                f_value = func(new_individual)\n\n                # Update best solution\n                if self.f_best is None or f_value < self.f_best:\n                    self.f_best = f_value\n                    self.x_best = new_individual\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "5f2fc231-c7d7-4182-a473-d8bdbbe1f280", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff * np.random.uniform(0, 1, self.dim)\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "348c1ddf-fd85-4e05-99f1-cc4a547d4d4b", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with adaptive probability\n                    if np.random.rand() < self.mutation_prob:\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        new_solution = new_solution + mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with adaptive mutation probability.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "64aa6608-7bf8-437f-94e4-a77442c5b4ca", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation probability\n            mutation_prob = np.random.uniform(0.05, 0.95)\n            if np.random.rand() < mutation_prob:\n                # Select a random individual\n                i = np.random.randint(0, self.dim)\n                # Select a random point in the population\n                j = np.random.randint(0, self.budget)\n                # Calculate the mutation vector\n                mutation_vector = population[j, :] - population[i, :]\n                mutation_vector = mutation_vector / np.max(np.abs(mutation_vector))\n                # Apply the mutation\n                new_solution = population[i, :] + mutation_vector\n                new_solution = new_solution / np.max(np.abs(new_solution))\n                # Evaluate the new solution\n                f_value = func(new_solution)\n                # Update the best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "95731649-b8ee-47ca-a023-699e53b2e629", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adaptive mutation probability\n        mutation_prob = np.random.uniform(0.0, 0.05, self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < mutation_prob[i]:\n                # Generate new individual\n                new_individual = np.random.uniform(-5.0, 5.0, (self.dim, 1))\n                new_individual = new_individual / np.max(np.abs(new_individual))\n\n                # Evaluate new individual\n                f_value = func(new_individual)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_individual\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with adaptive mutation probability.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "c8fc3be9-cdac-467e-8a16-4122984193ea", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability 0.05\n                    if np.random.rand() < self.mutation_prob:\n                        new_solution += np.random.uniform(-0.1, 0.1, self.dim)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n            # Apply mutation to x_best with probability 0.05\n            if np.random.rand() < self.mutation_prob:\n                self.x_best += np.random.uniform(-0.1, 0.1, self.dim)\n                self.x_best = self.x_best / np.max(np.abs(self.x_best))\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with adaptive mutation probability.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "dce3fad8-b132-4049-bdbe-35c20296597d", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution with probability 0.05\n                    if random.random() < 0.05:\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "201c2ce1-21af-4a3a-b004-19aa9cfb0df0", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.refine_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Refine strategy with probability 0.05\n                    if np.random.rand() < self.refine_prob:\n                        # Randomly replace one dimension of the new solution\n                        idx = np.random.randint(0, self.dim)\n                        new_solution[idx] = np.random.uniform(-5.0, 5.0)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with probability 0.05 to refine its strategy.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "970f88c1-f751-4bc3-8afb-a9c13b611670", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "13a36321-6114-46ea-aa5c-5de767ae79fb", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p_adjustment = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adjust individual lines with probability\n        adjustment = np.random.rand(self.dim, self.budget) < self.p_adjustment\n        adjusted_population = population.copy()\n        for i in range(self.dim):\n            adjusted_population[i, adjustment[i]] = population[i, adjustment[i]] * np.random.uniform(0.9, 1.1)\n\n        return self.f_best, adjusted_population\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with probability adjustment for black box optimization.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "2b0856fe-959f-4008-8d1e-e3ac55628bda", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_probability = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if np.random.rand() < self.mutation_probability:\n                        # Randomly select dimension to mutate\n                        mutate_dim = np.random.randint(self.dim)\n                        # Generate random mutation\n                        mutation = np.random.uniform(-0.5, 0.5, self.dim)\n                        # Apply mutation\n                        new_solution[mutate_dim] += mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "5786b2b8-7a4b-465c-aa1a-abbb34f9f0fb", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff * np.random.choice([-1, 1], size=self.dim)\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization with probability adjustment.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "30c0ee2e-9ef2-40a4-852c-5c84d8bb2af7", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Refine strategy with probability 0.05\n        for i in range(self.dim):\n            if random.random() < 0.05:\n                # Refine individual\n                individual = population[i, :]\n                refined_individual = individual + np.random.uniform(-0.1, 0.1, self.dim)\n                refined_individual = refined_individual / np.max(np.abs(refined_individual))\n                population[i, :] = refined_individual\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "3c610e3a-67e0-4f6b-ad16-e71bccb48493", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p_crossover = 0.05\n        self.p_mutation = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :]\n                    if np.random.rand() < self.p_crossover:\n                        new_solution = new_solution + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Mutation\n                    if np.random.rand() < self.p_mutation:\n                        new_solution = new_solution + np.random.normal(0, 0.1, self.dim)\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "1e9bfd51-87bc-4596-8ae2-04236783ad9c", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_rate = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if random.random() < self.mutation_rate:\n                        # Introduce a small random perturbation\n                        new_solution += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "6455740c-54f1-42ba-a4b0-73b3a60dfb9b", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation\n                    if np.random.rand() < 0.05:\n                        mutation = np.random.uniform(-0.1, 0.1, (self.dim,))\n                        new_solution += mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "d234b8c2-84bc-412e-971a-8f552fb3eca5", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.probability = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution with 0.05 probability\n                    if np.random.rand() < self.probability:\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization with 0.05 probability to change individual lines.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "8312d3b0-9089-47f6-a00f-0a478efc8de1", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :]\n                    mutate = np.random.rand(self.dim) < self.mutation_prob\n                    if mutate:\n                        new_solution += diff * np.random.rand(self.dim)\n\n                    # Crossover\n                    crossover = np.random.rand(self.dim) < self.crossover_prob\n                    if crossover:\n                        new_solution = np.concatenate((new_solution[:self.dim//2], population[k, self.dim//2:]))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with probabilistic mutation and crossover.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "5e92ffb0-43fb-490f-b82a-592e1605208c", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p = 0.05  # probability to change individual\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if np.random.rand() < self.p and f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "96b1dd3c-7d76-4530-be5c-67d858896501", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation\n            mutation_rate = 0.05\n            for i in range(self.dim):\n                if np.random.rand() < mutation_rate:\n                    # Generate random mutation vector\n                    mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                    mutation = mutation / np.max(np.abs(mutation))\n\n                    # Apply mutation to new solution\n                    new_solution[i, :] += mutation\n\n                    # Ensure bounds\n                    new_solution[i, :] = np.clip(new_solution[i, :], -5.0, 5.0)\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "abc8f6f9-a8bd-47d3-9430-336d2c376036", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation\n            for i in range(self.dim):\n                if np.random.rand() < self.mutation_prob:\n                    # Calculate mutation vector\n                    mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                    mutation = mutation / np.max(np.abs(mutation))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + mutation\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "b58ac012-e6ad-4beb-a211-13fa7d7a3873", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.probability = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution with probability adjustment\n                    if np.random.rand() < self.probability:\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with probability adjustment for adaptive evolutionary distance.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "9c2ccead-5276-46a3-b7af-4cdde08011b0", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_probability = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with adaptive probability\n                    if np.random.rand() < self.mutation_probability:\n                        # Generate random mutation vector\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n\n                        # Apply mutation to new solution\n                        new_solution += mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability for black box optimization.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "ec942b78-72d0-4363-bade-0a3687b12f4e", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mut_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n            # Adaptive mutation probability\n            if np.random.rand() < self.mut_prob:\n                # Randomly select a solution to mutate\n                idx = np.random.randint(0, self.dim)\n                # Mutate the solution\n                mutation = np.random.uniform(-1.0, 1.0, (self.dim,))\n                new_solution = self.x_best[idx] + mutation\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[idx]:\n                    self.f_best[idx] = f_value\n                    self.x_best[idx] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "e5e27fcc-91e4-455a-b202-49618a677542", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p_mut = 0.05  # Adaptive mutation probability\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Adaptive mutation\n                    if np.random.rand() < self.p_mut:\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        new_solution = new_solution + mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with adaptive mutation probability.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "f3d0e464-88a7-45a4-a021-39060ae60938", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.refine_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Refine solution\n        if random.random() < self.refine_prob:\n            # Randomly select two solutions\n            i = random.randint(0, self.dim - 1)\n            j = random.randint(0, self.dim - 1)\n\n            # Calculate crossover point\n            k = np.random.randint(i + 1, self.dim)\n\n            # Calculate differential evolution vector\n            diff = population[k, :] - population[i, :]\n            diff = diff / np.max(np.abs(diff))\n\n            # Calculate new solution\n            new_solution = population[i, :] + diff\n            new_solution = new_solution / np.max(np.abs(new_solution))\n\n            # Evaluate new solution\n            f_value = func(new_solution)\n\n            # Update best solution\n            if f_value < self.f_best[i]:\n                self.f_best[i] = f_value\n                self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "53573a5b-b5c0-4beb-9195-6eb286570443", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p_mut = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply adaptive mutation probability\n                    if np.random.rand() < self.p_mut:\n                        # Randomly select a dimension to mutate\n                        mutate_dim = np.random.randint(0, self.dim)\n                        # Generate a random mutation vector\n                        mutate_vector = np.random.uniform(-1.0, 1.0, self.dim)\n                        # Mutate the solution\n                        new_solution[mutate_dim] += mutate_vector * np.random.uniform(0.0, 1.0)\n\n                # Ensure new solution is within bounds\n                new_solution = np.clip(new_solution, -5.0, 5.0)\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "4f2176b8-b40e-4c87-a490-d2c695cd808a", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        mutation_probability = 0.05\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if np.random.rand() < mutation_probability:\n                        # Calculate mutation vector\n                        mutation = np.random.uniform(-1.0, 1.0, size=self.dim)\n                        mutation = mutation / np.max(np.abs(mutation))\n\n                        # Update new solution\n                        new_solution = new_solution + mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" algorithm with adaptive mutation probability.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "7280f66c-3965-443c-af60-5a7ecc630224", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.p_crossover = 0.05\n        self.p_mutation = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Crossover with probability 0.05\n                    if np.random.rand() < self.p_crossover:\n                        # Calculate crossover point\n                        crossover_point = np.random.randint(1, self.dim)\n\n                        # Calculate new solution\n                        new_solution = np.concatenate((population[i, :crossover_point], population[k, crossover_point:]))\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n                    # Mutation with probability 0.05\n                    if np.random.rand() < self.p_mutation:\n                        # Calculate mutation point\n                        mutation_point = np.random.randint(1, self.dim)\n\n                        # Calculate new solution\n                        new_solution = population[i, :] + np.random.uniform(-0.1, 0.1, self.dim)\n\n                        # Evaluate new solution\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "6d539a90-bdd9-405d-844d-0ed1047d3a90", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "8c352cbc-585a-4880-ae3d-09ecce73116e", "solution": "import numpy as np\nimport random\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.probability = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Refine strategy with probability adjustment\n        if random.random() < self.probability:\n            # Select two random solutions\n            i, j = random.sample(range(self.dim), 2)\n\n            # Calculate crossover point\n            k = np.random.randint(1, self.budget // self.dim)\n\n            # Calculate differential evolution vector\n            diff = population[k, :] - population[i, :]\n            diff = diff / np.max(np.abs(diff))\n\n            # Calculate new solution\n            new_solution = population[i, :] + diff\n            new_solution = new_solution / np.max(np.abs(new_solution))\n\n            # Evaluate new solution\n            f_value = func(new_solution)\n\n            # Update best solution\n            if f_value < self.f_best[i]:\n                self.f_best[i] = f_value\n                self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with probability adjustment.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "d44c99ae-cb1f-41b3-9264-3f1178301fc9", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_probability = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability 0.05\n                    if np.random.rand() < self.mutation_probability:\n                        # Randomly select a dimension to mutate\n                        mutate_dim = np.random.randint(self.dim)\n                        # Generate a random mutation vector\n                        mutation_vector = np.random.uniform(-1.0, 1.0, self.dim)\n                        # Add the mutation vector to the new solution\n                        new_solution[mutate_dim] += mutation_vector\n                        # Normalize the new solution\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n\n                        # Evaluate the mutated new solution\n                        f_value = func(new_solution)\n\n                        # Update the best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation probability.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "25925ef8-04eb-45f4-afa1-a927d3988053", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adaptive mutation probability\n        for i in range(self.dim):\n            if np.random.rand() < 0.05:\n                # Calculate mutation probability\n                mutation_prob = np.random.uniform(0.0, 1.0)\n                if mutation_prob < 0.01:\n                    # Random mutation\n                    mutation = np.random.uniform(-1.0, 1.0)\n                    new_solution = self.x_best[i] + mutation\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n                else:\n                    # Adaptive mutation\n                    if self.f_best[i] < np.mean(self.f_best):\n                        mutation_prob = 0.5\n                    else:\n                        mutation_prob = 1.0\n                    mutation = np.random.uniform(-1.0, 1.0)\n                    new_solution = self.x_best[i] + mutation * mutation_prob\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "7350a99b-b58a-44c9-ae12-3a8920fd6284", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        # Adaptive mutation probability\n        mutation_prob = 0.05\n        for i in range(self.dim):\n            if np.random.rand() < mutation_prob:\n                # Calculate mutation vector\n                mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                mutation = mutation / np.max(np.abs(mutation))\n\n                # Calculate new solution\n                new_solution = population[i, :] + mutation\n                new_solution = new_solution / np.max(np.abs(new_solution))\n\n                # Evaluate new solution\n                f_value = func(new_solution)\n\n                # Update best solution\n                if f_value < self.f_best[i]:\n                    self.f_best[i] = f_value\n                    self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with adaptive mutation probability.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "c10dfcda-0afb-4d23-a71b-d5122357ca1c", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if np.random.rand() < 0.05 and f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm with 0.05 probability to change individual lines.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
{"id": "cf7783ce-6994-4dee-a41c-d8f83c4e42d0", "solution": "import numpy as np\n\nclass DEAED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.f_best = None\n        self.x_best = None\n        self.f_best_history = []\n        self.x_best_history = []\n        self.mutation_prob = 0.05\n        self.crossover_prob = 0.05\n\n    def __call__(self, func):\n        if self.budget <= 0:\n            return self.f_best, self.x_best\n\n        # Initialize population\n        population = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        population = population / np.max(np.abs(population))\n\n        for _ in range(self.budget):\n            # Evaluate population\n            f_values = func(population)\n\n            # Calculate fitness\n            fitness = np.array(f_values) - np.min(f_values, axis=1, keepdims=True)\n            fitness = 1 / (1 + fitness)\n\n            # Update best solution\n            if self.f_best is None or np.mean(fitness) > np.mean(self.f_best):\n                self.f_best = fitness\n                self.x_best = population[np.argmin(fitness, axis=1)]\n\n            # Update history\n            self.f_best_history.append(self.f_best)\n            self.x_best_history.append(self.x_best)\n\n            # Differential evolution\n            for i in range(self.dim):\n                for j in range(1, self.budget // self.dim):\n                    # Calculate crossover point\n                    k = np.random.randint(j * self.dim, (j + 1) * self.dim)\n\n                    # Calculate differential evolution vector\n                    diff = population[k, :] - population[i, :]\n                    diff = diff / np.max(np.abs(diff))\n\n                    # Calculate new solution\n                    new_solution = population[i, :] + diff\n                    new_solution = new_solution / np.max(np.abs(new_solution))\n\n                    # Evaluate new solution\n                    f_value = func(new_solution)\n\n                    # Update best solution\n                    if f_value < self.f_best[i]:\n                        self.f_best[i] = f_value\n                        self.x_best[i] = new_solution\n\n                    # Apply mutation with probability\n                    if np.random.rand() < self.mutation_prob:\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        new_solution = new_solution + mutation\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n                    # Apply crossover with probability\n                    if np.random.rand() < self.crossover_prob:\n                        crossover_point = np.random.randint(1, self.dim)\n                        new_solution = population[i, :] + diff[:, crossover_point:] - diff[:, :crossover_point]\n                        new_solution = new_solution / np.max(np.abs(new_solution))\n                        f_value = func(new_solution)\n\n                        # Update best solution\n                        if f_value < self.f_best[i]:\n                            self.f_best[i] = f_value\n                            self.x_best[i] = new_solution\n\n        return self.f_best, self.x_best\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nbudget = 100\ndim = 10\ndeaed = DEAED(budget, dim)\nf_best, x_best = deaed(func)\nprint(\"Best fitness:\", f_best)\nprint(\"Best solution:\", x_best)", "name": "DEAED", "description": "Novel \"Differential Evolution with Adaptive Evolutionary Distance\" (DEAED) algorithm for black box optimization with adaptive mutation and crossover probability.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'Individual' object is not callable\").", "error": "TypeError(\"'Individual' object is not callable\")", "parent_id": "b4bc2316-7ab6-45ab-a690-f3e601567467", "metadata": {}, "mutation_prompt": null}
