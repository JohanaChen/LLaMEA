{"id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_ESO = HybridEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HybridEvolutionarySwarmOptimization", "description": "Novel \"Hybrid Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 51, in <module>\n  File \"<string>\", line 20, in __call__\n  File \"numpy/random/mtrand.pyx\", line 1001, in numpy.random.mtrand.RandomState.choice\nValueError: Cannot take a larger sample than population when 'replace=False'\n.", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 51, in <module>\n  File \"<string>\", line 20, in __call__\n  File \"numpy/random/mtrand.pyx\", line 1001, in numpy.random.mtrand.RandomState.choice\nValueError: Cannot take a larger sample than population when 'replace=False'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "00480fcb-c19c-4260-88fb-0faea671e97e", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Phase 1: Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Phase 2: Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Phase 3: Selection and Mutation\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine strategy\n            refine_candidates = self.candidates[np.random.choice(self.population_size, size=self.population_size * 0.25, replace=False), :]\n            refine_candidates += np.random.uniform(-0.05, 0.05, size=(self.population_size * 0.25, self.dim))\n            self.candidates = np.concatenate((self.candidates, refine_candidates))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_phase_ESO = MultiPhaseEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = multi_phase_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiPhaseEvolutionarySwarmOptimization", "description": "Novel \"Multi-Phase Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies, swarm intelligence, and multi-phase optimization to tackle black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"expected a sequence of integers or a single integer, got '12.5'\").", "error": "TypeError(\"expected a sequence of integers or a single integer, got '12.5'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "4632ccd9-b099-467f-82a1-599863215947", "solution": "import numpy as np\nimport random\n\nclass HyperHeuristicsForBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.strategies = [np.random.uniform(-0.1, 0.1, size=(10, self.dim)), np.random.uniform(-0.1, 0.1, size=(10, self.dim))]\n        self.fitness_history = np.zeros((self.budget, self.population_size))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Hyper-Heuristics\n            for _ in range(10):\n                new_strategy = np.copy(self.strategies[np.random.choice(len(self.strategies), size=1, replace=False)])\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :] + new_strategy[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Hyper-Evolutionary Strategy\n            for _ in range(10):\n                new_strategy = np.copy(self.strategies[np.random.choice(len(self.strategies), size=1, replace=False)])\n                new_strategy += np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n                new_strategy = self.strategies[np.argmin(np.sum(new_strategy**2, axis=1))]\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :] + new_strategy[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n            # Record fitness history\n            self.fitness_history[_] = self.candidates[:, 0]\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhyper_HHSO = HyperHeuristicsForBBO(budget=100, dim=2)\nbest_candidate, best_fitness = hyper_HHSO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HyperHeuristicsForBBO", "description": "Novel \"Hyper-Heuristics for Black Box Optimization\" algorithm combining hyper-heuristics and hyper-evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('only integer scalar arrays can be converted to a scalar index').", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "9f8c6978-bc12-4b0c-adb4-be2fa26c0a7f", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(fitness), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(fitness), :] = new_candidate\n\n            # Multi-Objective Optimization\n            self.candidates = self.candidates[np.argsort(fitness)]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine strategy\n            self.candidates[np.random.choice(self.population_size, size=25, replace=False), :] += self.candidates[np.random.choice(self.population_size, size=25, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.05, 0.05, size=(25, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(fitness), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_objective_ESO = MultiObjectiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = multi_objective_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiObjectiveEvolutionarySwarmOptimization", "description": "Novel \"Multi-Objective Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies, swarm intelligence, and multi-objective optimization to tackle black box optimization problems.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "bc1ba195-0677-426c-9f4c-541cc02bf61c", "solution": "import numpy as np\nimport random\nimport time\n\nclass MetaBlackBoxOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_model = None\n\n    def __call__(self, func):\n        # Initialize the meta model\n        if self.meta_model is None:\n            self.meta_model = self._initialize_meta_model()\n\n        for _ in range(self.budget):\n            # Sample a subset of candidates\n            subset_candidates = self.candidates[np.random.choice(self.population_size, size=10, replace=False)]\n\n            # Evaluate the subset of candidates\n            fitness_values = func(subset_candidates)\n\n            # Update the meta model\n            self.meta_model.update(fitness_values)\n\n            # Sample a new candidate using the meta model\n            new_candidate = self.meta_model.sample()\n\n            # Evaluate the new candidate\n            new_fitness = func(new_candidate)\n\n            # Update the best candidate and fitness\n            if new_fitness < self.best_fitness:\n                self.best_candidate = new_candidate\n                self.best_fitness = new_fitness\n\n            # Apply a probability of 0.25 to change the individual lines of the selected solution\n            if random.random() < 0.25:\n                self.candidates[np.random.choice(self.population_size, size=1, replace=False), :] = new_candidate\n\n        return self.best_candidate, self.best_fitness\n\n    def _initialize_meta_model(self):\n        # Initialize the meta model using a simple neural network\n        import tensorflow as tf\n        model = tf.keras.models.Sequential([\n            tf.keras.layers.Dense(64, activation='relu', input_shape=(self.dim,)),\n            tf.keras.layers.Dense(64, activation='relu'),\n            tf.keras.layers.Dense(self.dim, activation='linear')\n        ])\n        model.compile(optimizer='adam', loss='mean_squared_error')\n        return model\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_MBO = MetaBlackBoxOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_MBO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaBlackBoxOptimization", "description": "Novel \"Meta-Learning based Black Box Optimization\" algorithm combining meta-learning and black box optimization to tackle optimization problems.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'tensorflow'\").", "error": "ModuleNotFoundError(\"No module named 'tensorflow'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "59642cb8-24e9-4e39-8d48-24f52d3f4161", "solution": "import numpy as np\nimport random\n\nclass MetaAdaptiveESO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.adaptive_mutation_rate = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Adaptive Mutation\n            mutation_mask = np.random.rand(self.population_size, self.dim) < self.adaptive_mutation_rate\n            self.candidates[mutation_mask, :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Meta-Heuristics\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_ESO = MetaAdaptiveESO(budget=100, dim=2)\nbest_candidate, best_fitness = meta_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaAdaptiveESO", "description": "Novel \"Meta-Adaptive Evolutionary Swarm Optimization\" algorithm combining adaptive mutation, meta-heuristics, and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('too many indices for array: array is 2-dimensional, but 3 were indexed').", "error": "IndexError('too many indices for array: array is 2-dimensional, but 3 were indexed')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "e3a570cb-fb4f-40e6-a755-466df0f80db7", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MetaLEHybridEvolutionaryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_learning = True\n        self.meta_model = None\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.meta_learning:\n                # Meta-learning step\n                self.meta_model = self._meta_learn(func, self.candidates)\n                self.meta_learning = False\n\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n            if self.meta_learning:\n                # Update meta-model\n                self.meta_model = self._meta_update(func, self.meta_model, self.candidates)\n\n    def _meta_learn(self, func, candidates):\n        # Simple meta-learning model: average fitness of candidates\n        return np.mean(func(candidates[:, 0]))\n\n    def _meta_update(self, func, meta_model, candidates):\n        # Update meta-model by averaging fitness of new candidates\n        new_candidates = np.random.uniform(-5.0, 5.0, (100, self.dim))\n        new_fitness = func(new_candidates)\n        return np.mean(new_fitness)\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_LE_HESO = MetaLEHybridEvolutionaryOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_LE_HESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaLEHybridEvolutionaryOptimization", "description": "Novel \"Meta-Learning-based Hybrid Evolutionary Optimization\" algorithm that leverages meta-learning to adapt to different optimization tasks and combines evolutionary strategies and swarm intelligence.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "f9eb8caa-6e8b-47db-8ade-b4c633582ccd", "solution": "import numpy as np\nimport random\n\nclass CuckooSearchOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.p = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Cuckoo Search\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            for i in range(self.population_size):\n                if np.random.rand() < self.p:\n                    self.candidates[i, :] += np.random.uniform(-0.1, 0.1, size=(1, self.dim))\n                    self.candidates[i, :] = np.clip(self.candidates[i, :], -5.0, 5.0)\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ncuckoo_SSO = CuckooSearchOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = cuckoo_SSO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "CuckooSearchOptimization", "description": "Novel \"Cuckoo Search Optimization\" algorithm, a metaheuristic inspired by the breeding process of the cuckoo bird.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "ae3cadc1-04be-4c26-9bd5-6b7376904dcd", "solution": "import numpy as np\nimport random\n\nclass HyperNetworkEvolutionaryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.hyper_network = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Hyperparameter Tuning\n            self.hyper_network[np.random.choice(self.population_size, size=10, replace=False), :] = self.hyper_network[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.hyper_network[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Hyperparameter Refinement\n            for _ in range(10):\n                new_hyper_network = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n                new_fitness = func(new_hyper_network[:, 0])\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_hyper_network[np.argmin(new_hyper_network[:, 0]), :]\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_hyper_network[np.argmin(new_hyper_network[:, 0]), :]\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhyperNEO = HyperNetworkEvolutionaryOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = hyperNEO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HyperNetworkEvolutionaryOptimization", "description": "Novel \"HyperNetwork Evolutionary Optimization\" algorithm combining hyperparameter tuning and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "3d12ec43-9f7c-4229-ac39-77a5c3b53088", "solution": "import numpy as np\nimport random\n\nclass DifferentialEvolutionWithSwarmIntelligence:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                j = np.random.randint(0, self.population_size)\n                k = np.random.randint(0, self.population_size)\n                new_candidate = self.candidates[i, :] + \\\n                                self.candidates[j, :] - \\\n                                self.candidates[k, :] + \\\n                                np.random.uniform(-0.1, 0.1, size=self.dim)\n\n                # Adaptive Swarm Intelligence\n                if np.random.rand() < 0.25:\n                    new_candidate += np.random.uniform(-0.05, 0.05, size=self.dim)\n\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ndifferential_DE_SI = DifferentialEvolutionWithSwarmIntelligence(budget=100, dim=2)\nbest_candidate, best_fitness = differential_DE_SI(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "DifferentialEvolutionWithSwarmIntelligence", "description": "Novel \"Differential Evolution with Adaptive Swarm Intelligence\" algorithm combining differential evolution strategies and adaptive swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "951d9e0a-bb33-43cf-b970-9630e2bc4253", "solution": "import numpy as np\nimport random\n\nclass MetaLearningGuidedEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_model = None\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Meta-Learning\n            if self.meta_model is None:\n                self.meta_model = self._meta_learning(func)\n            new_candidate = self.meta_model.predict(self.candidates[:, 0])\n            new_fitness = func(new_candidate)\n            if new_fitness < self.best_fitness:\n                self.best_candidate = new_candidate\n                self.best_fitness = new_fitness\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n    def _meta_learning(self, func):\n        # Initialize meta-model using a simple neural network\n        model = neural_network(input_dim=self.dim, output_dim=1)\n        model.compile(optimizer='adam', loss='mean_squared_error')\n        model.fit(self.candidates[:, 0], func(self.candidates[:, 0]), epochs=10, batch_size=10)\n        return model\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_ESO = MetaLearningGuidedEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaLearningGuidedEvolutionarySwarmOptimization", "description": "Novel \"Meta-Learning Guided Evolutionary Swarm Optimization\" algorithm combining meta-learning and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'neural_network' is not defined\").", "error": "NameError(\"name 'neural_network' is not defined\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "677ef1fd-ba70-45dc-9eae-8561adce64f5", "solution": "import numpy as np\nimport random\n\nclass EvolutionarySwarmOptimizationWithRefinement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.refinement_probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine the strategy with probability 0.25\n            if random.random() < self.refinement_probability:\n                for i in range(self.population_size):\n                    if random.random() < 0.5:\n                        self.candidates[i, :] += np.random.uniform(-0.05, 0.05, size=self.dim)\n                    else:\n                        self.candidates[i, :] -= np.random.uniform(-0.05, 0.05, size=self.dim)\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nesO_with_refinement = EvolutionarySwarmOptimizationWithRefinement(budget=100, dim=2)\nbest_candidate, best_fitness = esO_with_refinement(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "EvolutionarySwarmOptimizationWithRefinement", "description": "Novel \"Evolutionary Swarm Optimization with Probability Refinement\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems with probability refinement.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "ea76d9dd-b034-438a-9a39-7622455afd1e", "solution": "import numpy as np\nimport random\n\nclass CognitiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.cognitive_weights = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Cognitive Strategy\n            for i in range(self.population_size):\n                self.cognitive_weights[i] = np.random.uniform(0, 1)\n                self.candidates[i, :] *= self.cognitive_weights[i]\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Cognitive Update\n            for i in range(self.population_size):\n                self.cognitive_weights[i] = np.random.uniform(0, 1)\n                self.candidates[i, :] *= self.cognitive_weights[i]\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ncognitive_SCO = CognitiveSwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = cognitive_SCO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "CognitiveSwarmOptimization", "description": "Novel \"Cognitive Swarm Optimization\" algorithm combining cognitive strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "ff3b9b7d-6ead-4a66-ad33-0aca15f99ce8", "solution": "import numpy as np\nimport random\n\nclass DiversityBasedEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.diversity_penalty = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection with diversity penalty\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n            diversity_penalty = np.zeros(self.population_size)\n            for i in range(self.population_size):\n                for j in range(i+1, self.population_size):\n                    if np.linalg.norm(self.candidates[i, :] - self.candidates[j, :]) > 0.5:\n                        diversity_penalty[i] += 1\n                        diversity_penalty[j] += 1\n            self.population_size = self.population_size - int(self.diversity_penalty.sum() * self.diversity_penalty.size * self.diversity_penalty.max())\n            self.candidates = self.candidates[:self.population_size, :]\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ndiversity_ESO = DiversityBasedEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = diversity_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "DiversityBasedEvolutionarySwarmOptimization", "description": "Novel \"Diversity-Based Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems with a focus on maintaining diversity.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'float' object has no attribute 'sum'\").", "error": "AttributeError(\"'float' object has no attribute 'sum'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "39f88829-2b3f-41b2-8819-a743f81da53b", "solution": "import numpy as np\nimport random\n\nclass DifferentialEvolutionWithSwarmIntelligence:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.adaptive_swarm_size = 0.25 * self.population_size\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                j = np.random.randint(0, self.population_size)\n                k = np.random.randint(0, self.population_size)\n                new_candidate = self.candidates[i, :] + \\\n                               self.candidates[j, :] - \\\n                               self.candidates[k, :] + \\\n                               np.random.uniform(-0.1, 0.1, size=self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Adaptive Swarm Intelligence\n            for _ in range(int(self.adaptive_swarm_size * self.population_size)):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ndifferential_DE_with_swarm = DifferentialEvolutionWithSwarmIntelligence(budget=100, dim=2)\nbest_candidate, best_fitness = differential_DE_with_swarm(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "DifferentialEvolutionWithSwarmIntelligence", "description": "Novel \"Differential Evolution with Adaptive Swarm Intelligence\" algorithm combining differential evolution strategies and adaptive swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "b9fd4fd4-a86f-4884-8466-84682a6f744f", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidates = self.candidates[np.argmin(fitness), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n                new_fitness = func(new_candidates)\n                new_indices = np.argsort(new_fitness)\n                new_candidates = new_candidates[new_indices]\n\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:\n                        new_candidates[i, :] += np.random.uniform(-0.1, 0.1, size=(1, self.dim))\n\n                new_fitness = func(new_candidates)\n                new_indices = np.argsort(new_fitness)\n                new_candidates = new_candidates[new_indices]\n\n                if np.any(new_fitness < self.best_fitness):\n                    self.best_candidates = new_candidates[np.argmin(new_fitness)]\n                    self.best_fitness = np.min(new_fitness)\n                    self.candidates[np.argmin(fitness), :] = self.best_candidates\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(fitness)]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if np.any(self.best_fitness < func(self.best_candidates)):\n                self.candidates[np.argmin(fitness), :] = self.best_candidates\n\n        return self.best_candidates, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_objective_ESO = MultiObjectiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidates, best_fitness = multi_objective_ESO(func)\nprint(f\"Best candidates: {best_candidates}, Best fitness: {best_fitness}\")", "name": "MultiObjectiveEvolutionarySwarmOptimization", "description": "Novel \"Multi-Objective Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence to tackle multi-objective black box optimization problems.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 4 is out of bounds for axis 0 with size 2').", "error": "IndexError('index 4 is out of bounds for axis 0 with size 2')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "ea72de44-2599-4bf3-a401-7d0df36eb767", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            new_candidates = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :]\n            for i in range(10):\n                new_candidates[i, :] = new_candidates[i, :] + \\\n                                      new_candidates[i, :] * np.random.uniform(-0.1, 0.1, size=(self.dim,))\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidates[i, :]\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Probability Refinement\n            refinement_candidates = self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :]\n            refinement_candidates = refinement_candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :]\n            refinement_candidates = refinement_candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :]\n            for i in range(self.population_size):\n                refinement_candidates[i, :] = refinement_candidates[i, :] + \\\n                                              refinement_candidates[i, :] * np.random.uniform(0.0, 0.25, size=(self.dim,))\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = refinement_candidates[i, :]\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_ESO = HybridEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HybridEvolutionarySwarmOptimization", "description": "Novel \"Hybrid Evolutionary Swarm Optimization with Probability Refinement\" algorithm combining evolutionary strategies, swarm intelligence, and probability refinement to tackle black box optimization problems.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "fa62dc47-aded-4ed7-89df-b5137c76b76d", "solution": "import numpy as np\nimport random\n\nclass SwarmDrivenEvolutionarySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            mutation_rate = 0.25\n            candidates_to_mutate = np.random.choice(self.population_size, size=int(self.population_size * mutation_rate), replace=False)\n            self.candidates[candidates_to_mutate, :] += np.random.uniform(-0.1, 0.1, size=(len(candidates_to_mutate), self.dim))\n\n            # Adaptive mutation\n            for i in range(len(candidates_to_mutate)):\n                if np.random.rand() < 0.25:\n                    self.candidates[candidates_to_mutate[i], :] += np.random.uniform(-0.05, 0.05, size=self.dim)\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nswarm_ES = SwarmDrivenEvolutionarySearch(budget=100, dim=2)\nbest_candidate, best_fitness = swarm_ES(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "SwarmDrivenEvolutionarySearch", "description": "Novel \"Swarm-Driven Evolutionary Search\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "56086c08-e632-473a-83d9-92236393a182", "solution": "import numpy as np\nimport random\n\nclass CognitiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.cognitive_weights = np.random.uniform(0.25, 1.0, size=(self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Cognitive Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Update cognitive weights\n            self.cognitive_weights = self.cognitive_weights * (1 - np.random.uniform(0.0, 0.1, size=(self.population_size, self.dim))) + \\\n                                    self.cognitive_weights * np.random.uniform(0.25, 1.0, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ncognitive_SCO = CognitiveSwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = cognitive_SCO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "CognitiveSwarmOptimization", "description": "Novel \"Cognitive Swarm Optimization with Evolutionary Strategies\" algorithm combining cognitive swarm intelligence and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (100,2) (50,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (100,2) (50,2) ')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "151df6d9-61ec-4075-bd87-a443591116ff", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MetaEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_model = None\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Meta-Learning\n            if self.meta_model is None:\n                self.meta_model = self._meta_learn(func, self.candidates[:, 0])\n            else:\n                self.meta_model = self._meta_update(func, self.meta_model, self.candidates[:, 0])\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      self.meta_model(self.candidates[:, 0])\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n    def _meta_learn(self, func, candidates):\n        # Simple meta-learning model: average of candidates\n        return np.mean(candidates, axis=0)\n\n    def _meta_update(self, func, meta_model, candidates):\n        # Simple meta-learning model: average of candidates\n        return np.mean(candidates, axis=0)\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_ESO = MetaEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaEvolutionarySwarmOptimization", "description": "Novel \"Meta-Learning Based Evolutionary Swarm Optimization\" algorithm combining meta-learning and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'numpy.float64' object is not callable\").", "error": "TypeError(\"'numpy.float64' object is not callable\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "3e67f0ed-0b47-4f60-8e02-d3ad86dd64d3", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.fitness_values = np.inf * np.ones((self.population_size,))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness_values = func(self.candidates)\n            for i in range(self.population_size):\n                self.fitness_values[i] = np.min(fitness_values[i, :])\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness_values = func(new_candidate)\n                for i in range(self.population_size):\n                    new_fitness_values[i] = np.min(new_fitness_values[i, :])\n                    if new_fitness_values[i] < self.fitness_values[i]:\n                        self.fitness_values[i] = new_fitness_values[i]\n                        self.best_candidates[i] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.fitness_values, axis=1)]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            for i in range(self.population_size):\n                if self.fitness_values[i] < np.min(func(self.best_candidates[i, :])):\n                    self.candidates[i, :] = self.best_candidates[i, :]\n\n        return self.best_candidates, np.min(func(self.best_candidates[:, 0])), np.min(func(self.best_candidates[:, 1]))\n\n# Example usage:\ndef func(x):\n    return np.array([x[0]**2 + x[1]**2, x[0]**2 + x[2]**2])\n\nmoe_SSO = MultiObjectiveEvolutionarySwarmOptimization(budget=100, dim=3)\nbest_candidates, best_fitness_1, best_fitness_2 = moe_SSO(func)\nprint(f\"Best candidates: {best_candidates}, Best fitness 1: {best_fitness_1}, Best fitness 2: {best_fitness_2}\")", "name": "MultiObjectiveEvolutionarySwarmOptimization", "description": "Novel \"Multi-Objective Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems with multiple objectives.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 2 is out of bounds for axis 0 with size 2').", "error": "IndexError('index 2 is out of bounds for axis 0 with size 2')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "d3534c32-6014-4d2c-b03b-0feac98aafab", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine strategy\n            for i in range(self.population_size):\n                if random.random() < 0.25:\n                    self.candidates[i, :] += np.random.uniform(-0.05, 0.05, size=self.dim)\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_objective_ESO = MultiObjectiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = multi_objective_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiObjectiveEvolutionarySwarmOptimization", "description": "Novel \"Multi-Objective Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence to tackle multi-objective black box optimization problems.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "02a39186-d6ba-4d49-b56a-366fe8b22220", "solution": "import numpy as np\nimport random\n\nclass CuckooEvolutionaryStrategies:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Cuckoo Optimization\n            new_candidates = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent = self.candidates[i, :]\n                offspring = parent + np.random.uniform(-0.1, 0.1, size=(self.dim,))\n                new_candidates[i, :] = offspring\n                if np.random.rand() < 0.25:\n                    new_candidates[i, :] = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n\n            # Evolutionary Strategy\n            for i in range(self.population_size):\n                new_candidates[i, :] += np.random.uniform(-0.1, 0.1, size=(self.dim,))\n                new_fitness = func(new_candidates[i, :])\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidates[i, :]\n                    self.best_fitness = new_fitness\n\n            # Selection\n            self.candidates = new_candidates\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ncuckoo_ES = CuckooEvolutionaryStrategies(budget=100, dim=2)\nbest_candidate, best_fitness = cuckoo_ES(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "CuckooEvolutionaryStrategies", "description": "Novel \"Cuckoo Search with Evolutionary Strategies\" algorithm combining the principles of cuckoo optimization and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "062948bb-4a60-477e-8617-149540544ea0", "solution": "import numpy as np\nimport random\nfrom scipy.stats import norm\n\nclass QuantumEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.amplitude = 0.5\n        self.beta = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Quantum-inspired Mutation\n            for i in range(self.population_size):\n                if np.random.rand() < self.beta:\n                    alpha = np.random.uniform(-self.amplitude, self.amplitude, self.dim)\n                    new_candidate = self.candidates[i, :] + alpha\n                    new_fitness = func(new_candidate)\n                    if new_fitness < self.best_fitness:\n                        self.best_candidate = new_candidate\n                        self.best_fitness = new_fitness\n                        self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nq_ESO = QuantumEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = q_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "QuantumEvolutionarySwarmOptimization", "description": "Novel \"Quantum-Inspired Evolutionary Swarm Optimization\" algorithm combining quantum computing and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "acfb6f17-f93f-40df-8cbd-2150276875d9", "solution": "import numpy as np\nimport random\n\nclass HybridParticleSwarmEvolutionary:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.particles = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_particle = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.particles[:, 0])\n            self.best_particle = self.particles[np.argmin(self.particles[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.particles[np.random.choice(self.population_size, size=10, replace=False), :] = self.particles[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.particles[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Particle Swarm Optimization\n            for _ in range(10):\n                new_particle = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_particle)\n                if new_fitness < self.best_fitness:\n                    self.best_particle = new_particle\n                    self.best_fitness = new_fitness\n                    self.particles[np.argmin(self.particles[:, 0]), :] = new_particle\n\n            # Selection\n            self.particles = self.particles[np.argsort(self.particles[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.particles[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine the strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.25:\n                    self.particles[i, :] += np.random.uniform(-0.05, 0.05, size=self.dim)\n\n            # Check if the best particle is improved\n            if self.best_fitness < func(self.best_particle):\n                self.particles[np.argmin(self.particles[:, 0]), :] = self.best_particle\n\n        return self.best_particle, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_PSO_E = HybridParticleSwarmEvolutionary(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_PSO_E(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HybridParticleSwarmEvolutionary", "description": "Novel \"Particle Swarm Optimization with Evolutionary Strategies\" algorithm combining particle swarm optimization and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "585ce2c0-fa62-4809-81b6-91b7b60de448", "solution": "import numpy as np\n\nclass ProbabilisticEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            selection_mask = np.random.choice(self.population_size, size=self.population_size, replace=False, p=np.ones(self.population_size)/self.population_size)\n            self.candidates = self.candidates[selection_mask]\n\n            # Mutation\n            mutation_mask = np.random.choice(self.population_size, size=self.population_size, replace=False, p=np.ones(self.population_size)/self.population_size)\n            self.candidates[mutation_mask] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nprobabilistic_ESO = ProbabilisticEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = probabilistic_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilisticEvolutionarySwarmOptimization", "description": "Novel \"Probabilistic Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence with probabilistic mutation and selection.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "d5b61ba5-9d52-4c3f-8b21-8593ffe138bc", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.refinement_probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            mutation_candidates = self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :]\n            for i in range(self.population_size):\n                if random.random() < self.refinement_probability:\n                    mutation_candidates[i] += np.random.uniform(-0.1, 0.1, size=self.dim)\n                mutation_candidates[i] += np.random.uniform(-0.01, 0.01, size=self.dim)\n\n            self.candidates = mutation_candidates\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_ESO = HybridEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HybridEvolutionarySwarmOptimization", "description": "Novel \"Hybrid Evolutionary Swarm Optimization with Probabilistic Refinement\" algorithm combining evolutionary strategies, swarm intelligence, and probabilistic refinement to tackle black box optimization problems.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "eb6c4fa1-fb99-47ca-972b-f82198c54dc8", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            mutated_candidates = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                 self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                 np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = mutated_candidates\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Probabilistic Mutation\n            mutation_probability = 0.25\n            mutated_candidates = self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] + \\\n                                  np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim)) * \\\n                                  np.random.uniform(0, 1, size=(self.population_size, self.dim)) * \\\n                                  mutation_probability\n            self.candidates = mutated_candidates\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nprobabilistic_ESO = ProbabilisticEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = probabilistic_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilisticEvolutionarySwarmOptimization", "description": "Novel \"Probabilistic Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence with probabilistic mutation.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "324f8ade-864d-47ff-aa92-9a85b45a26c5", "solution": "import numpy as np\nimport random\n\nclass CognitiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Cognitive Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Evolutionary Strategy\n            for _ in range(10):\n                # Random selection of 10 individuals\n                selected_indices = np.random.choice(self.population_size, size=10, replace=False)\n                selected_candidates = self.candidates[selected_indices, :]\n                # Mutation with probability 0.25\n                mutated_candidates = selected_candidates.copy()\n                mutated_candidates[np.random.choice(selected_indices, size=int(10*0.25), replace=False), :] += np.random.uniform(-0.1, 0.1, size=(int(10*0.25), self.dim))\n                # Selection\n                mutated_candidates = mutated_candidates[np.argsort(mutated_candidates[:, 0])]\n                # Update the population\n                self.candidates[selected_indices, :] = mutated_candidates[:10]\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ncognitive_SCO = CognitiveSwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = cognitive_SCO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "CognitiveSwarmOptimization", "description": "Novel \"Cognitive Swarm Optimization with Evolutionary Strategies\" algorithm combining cognitive swarm intelligence and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 83 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 83 is out of bounds for axis 0 with size 10')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "45c16191-565d-4db8-97e3-6b47cce8d5be", "solution": "import numpy as np\nimport random\n\nclass EvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            new_candidates = []\n            for _ in range(10):\n                individual = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_individual = individual + individual * np.random.uniform(-0.1, 0.1, size=(1, self.dim))\n                new_candidates.append(new_individual)\n            self.candidates = np.array(new_candidates)\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Probability Refinement\n            refined_candidates = []\n            for i in range(self.population_size):\n                if np.random.rand() < self.probability:\n                    refined_candidates.append(self.candidates[i])\n                else:\n                    refined_candidates.append(self.best_candidate)\n            self.candidates = np.array(refined_candidates)\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nesO = EvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = esO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "EvolutionarySwarmOptimization", "description": "Novel \"Evolutionary Swarm Optimization with Probability Refinement\" algorithm combining evolutionary strategies and swarm intelligence with probability refinement.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 25 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 25 is out of bounds for axis 0 with size 10')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "d8433d50-d0c9-4722-8330-bfea03c2b886", "solution": "import numpy as np\nimport random\n\nclass MetaSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_params = np.random.uniform(-0.5, 0.5, (10, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Meta-heuristics\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Meta-heuristics refinement\n            self.meta_params = self.meta_params * 0.75 + np.random.uniform(-0.25, 0.25, size=(10, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_swarm = MetaSwarm(budget=100, dim=2)\nbest_candidate, best_fitness = meta_swarm(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaSwarm", "description": "Novel \"Meta-Swarm\" algorithm combining meta-heuristics and swarm intelligence to optimize black box functions.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "605a7737-9593-434b-a355-1cf96cd15de3", "solution": "import numpy as np\nimport random\nimport tensorflow as tf\n\nclass MetaEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.model = tf.keras.Sequential([\n            tf.keras.layers.Dense(64, activation='relu', input_shape=(self.dim,)),\n            tf.keras.layers.Dense(64, activation='relu'),\n            tf.keras.layers.Dense(self.dim)\n        ])\n        self.model.compile(optimizer='adam', loss='mean_squared_error')\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Meta-Learning\n            self.model.fit(self.candidates, np.ones((self.population_size,)), epochs=10, verbose=0)\n            new_candidates = self.model.predict(np.random.uniform(-5.0, 5.0, (100, self.dim)))\n            new_candidates = np.clip(new_candidates, -5.0, 5.0)\n            new_fitness = func(new_candidates[:, 0])\n            if new_fitness < self.best_fitness:\n                self.best_candidate = new_candidates[np.argmin(new_fitness), :]\n                self.best_fitness = new_fitness\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidates[np.argmin(new_fitness), :]\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_ESO = MetaEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaEvolutionarySwarmOptimization", "description": "Novel \"Meta-Learning-based Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies, meta-learning, and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'tensorflow'\").", "error": "ModuleNotFoundError(\"No module named 'tensorflow'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "e5347844-04fa-4e82-998b-38b30a0b613f", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.phase = 1\n        self.mutation_prob = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            if self.phase == 1:\n                self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n            elif self.phase == 2:\n                self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-self.mutation_prob, self.mutation_prob, size=(self.population_size, self.dim))\n            elif self.phase == 3:\n                self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-self.mutation_prob, self.mutation_prob, size=(self.population_size, self.dim))\n\n            # Adaptive mutation probability\n            self.mutation_prob = np.min([1, self.mutation_prob + 0.01])\n\n            # Phase update\n            if self.mutation_prob > 0.5:\n                self.phase += 1\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_phase_ESO = MultiPhaseEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = multi_phase_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiPhaseEvolutionarySwarmOptimization", "description": "Novel \"Multi-Phase Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies, swarm intelligence, and adaptive mutation.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "fab92a05-a87b-4b10-b28d-fdab6b4254b3", "solution": "import numpy as np\n\nclass DifferentialEvolutionSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                j = np.random.randint(0, self.population_size)\n                k = np.random.randint(0, self.population_size)\n                new_candidate = self.candidates[i, :] + \\\n                                self.candidates[j, :] - \\\n                                self.candidates[k, :] + \\\n                                np.random.uniform(-0.1, 0.1, size=self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Probabilistic Refinement\n            for i in range(self.population_size):\n                if np.random.rand() < 0.25:\n                    self.candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ndifferential_DESSO = DifferentialEvolutionSwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = differential_DESSO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "DifferentialEvolutionSwarmOptimization", "description": "Novel \"Differential Evolution with Swarm Intelligence and Probabilistic Refinement\" algorithm", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "ecc27329-e0a4-470e-9210-a02232420989", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.objectives = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(fitness), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if np.any(new_fitness < self.best_fitness):\n                    self.best_candidate = new_candidate\n                    self.best_fitness = np.min(new_fitness)\n                    self.candidates[np.argmin(fitness), :] = new_candidate\n\n            # Multi-Objective Optimization\n            for i in range(self.population_size):\n                self.objectives[i] = func(self.candidates[i, :])\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.objectives[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine strategy\n            for _ in range(int(self.budget * 0.25)):\n                self.candidates[np.random.choice(self.population_size, size=1, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :] + \\\n                                                                                             self.candidates[np.random.choice(self.population_size, size=1, replace=False), :] * \\\n                                                                                             np.random.uniform(-0.01, 0.01, size=(1, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < np.min(self.objectives[:, 0]):\n                self.candidates[np.argmin(self.objectives[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_objective_ESO = MultiObjectiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = multi_objective_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiObjectiveEvolutionarySwarmOptimization", "description": "Novel \"Multi-Objective Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies, swarm intelligence, and multi-objective optimization to tackle black box optimization problems.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "11559b2f-1e33-4008-af9d-935a11f68cfa", "solution": "import numpy as np\nimport random\n\nclass BlackBoxOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            new_candidates = []\n            for i in range(self.population_size):\n                if random.random() < self.probability:\n                    new_candidate = self.candidates[i, :] + np.random.uniform(-0.1, 0.1, size=self.dim)\n                else:\n                    new_candidate = self.candidates[i, :]\n                new_candidates.append(new_candidate)\n            self.candidates = np.array(new_candidates)\n\n            # Swarm Intelligence\n            new_candidates = []\n            for i in range(self.population_size):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                new_candidates.append(new_candidate)\n            self.candidates = np.array(new_candidates)\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = BlackBoxOptimizer(budget=100, dim=2)\nbest_candidate, best_fitness = optimizer(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "BlackBoxOptimizer", "description": "Novel \"Black Box Optimizer with Evolutionary Strategies and Swarm Intelligence\"", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "a610c0a5-4c86-4844-9342-148679213a00", "solution": "import numpy as np\nimport random\n\nclass ProbabilityBasedEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            new_candidates = []\n            for _ in range(10):\n                individual = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                mutation = np.random.uniform(-0.1, 0.1, size=(1, self.dim))\n                new_individual = individual + mutation\n                new_candidates.append(new_individual)\n\n            # Swarm Intelligence\n            new_candidates = np.array(new_candidates)\n            new_fitness = func(new_candidates)\n            new_indices = np.argsort(new_fitness)\n            for i in new_indices[:10]:\n                if new_fitness[i] < self.best_fitness:\n                    self.best_candidate = new_candidates[i]\n                    self.best_fitness = new_fitness[i]\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidates[i]\n\n            # Selection\n            new_candidates = new_candidates[np.argsort(new_fitness)]\n            self.candidates = new_candidates[:self.population_size//2]\n\n            # Mutation\n            self.candidates += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\npbeso = ProbabilityBasedEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = pbeso(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilityBasedEvolutionarySwarmOptimization", "description": "Novel \"Probability-Based Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "2e2cb2ad-124f-4b5a-b5ae-908a1e2c6b19", "solution": "import numpy as np\nimport random\n\nclass EvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.adaptation_rate = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Adaptive Mutation\n            mutation_mask = np.random.choice([True, False], size=self.population_size, p=[self.adaptation_rate, 1-self.adaptation_rate])\n            if mutation_mask.any():\n                self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\neso = EvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = eso(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "EvolutionarySwarmOptimization", "description": "Novel \"Evolutionary Swarm Optimization with Adaptive Mutation\" algorithm combining evolutionary strategies and swarm intelligence with adaptive mutation to tackle black box optimization problems.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "a9a1b371-11f4-45bf-ace7-8adbacbf237b", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_ESO = HybridEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HybridEvolutionarySwarmOptimization", "description": "Novel \"Hybrid Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "54cb2f57-584f-415a-9f30-41f625161164", "solution": "import numpy as np\nimport random\n\nclass EvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Probabilistic Mutation\n            mutation_rate = 0.25\n            for i in range(self.population_size):\n                if random.random() < mutation_rate:\n                    self.candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nesO = EvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = esO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "EvolutionarySwarmOptimization", "description": "Novel \"Evolutionary Swarm Optimization with Probabilistic Mutation\" algorithm combining evolutionary strategies and swarm intelligence with probabilistic mutation to tackle black box optimization problems.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "ac1380d7-a91d-4f47-8f26-baf5d322ba48", "solution": "import numpy as np\nimport random\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.swarm_fitness = np.inf\n        self.evolutionary_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Adaptive Swarm Intelligence\n            self.swarm_fitness = np.inf\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.swarm_fitness:\n                    self.swarm_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Evolutionary Strategy\n            self.evolutionary_fitness = np.inf\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.evolutionary_fitness:\n                    self.evolutionary_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine strategy\n            for i in range(self.population_size):\n                if random.random() < 0.25:\n                    self.candidates[i, :] += np.random.uniform(-0.01, 0.01, size=self.dim)\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nadaptive_SOA = AdaptiveSwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = adaptive_SOA(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "AdaptiveSwarmOptimization", "description": "Novel \"Adaptive Swarm Optimization with Evolutionary Strategies\" algorithm combining adaptive swarm intelligence and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "91f1d444-57dd-4895-9765-7d1c24810139", "solution": "import numpy as np\nimport random\n\nclass DifferentialEvolutionSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                j = np.random.randint(0, self.population_size)\n                k = np.random.randint(0, self.population_size)\n                new_candidate = self.candidates[i, :] + \\\n                                self.candidates[j, :] - \\\n                                self.candidates[k, :] + \\\n                                np.random.uniform(-0.1, 0.1, size=self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine strategy with probability 0.25\n            if random.random() < 0.25:\n                for i in range(self.population_size):\n                    self.candidates[i, :] += np.random.uniform(-0.05, 0.05, size=self.dim)\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ndifferential_ESO = DifferentialEvolutionSwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = differential_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "DifferentialEvolutionSwarmOptimization", "description": "Novel \"Differential Evolution with Swarm Intelligence\" algorithm combining differential evolution strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "1b1dfb5c-290e-4f35-9ba5-b3928a626eb5", "solution": "import numpy as np\nimport random\n\nclass SwarmDrivenEvolutionarySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            for i in range(self.population_size):\n                if random.random() < self.probability:\n                    self.candidates[i, :] += np.random.uniform(-0.1, 0.1, size=(self.dim,))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nswarm_ES = SwarmDrivenEvolutionarySearch(budget=100, dim=2)\nbest_candidate, best_fitness = swarm_ES(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "SwarmDrivenEvolutionarySearch", "description": "Novel \"Swarm-Driven Evolutionary Search\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "c6105750-27e5-44ca-9853-9e958eb5666d", "solution": "import numpy as np\nimport random\n\nclass GloballyAdaptiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.adaptation_rate = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = self.best_candidate + np.random.uniform(-0.1, 0.1, size=self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            mutation_mask = np.random.choice(self.population_size, size=self.population_size, replace=False, p=[1-self.adaptation_rate]*self.population_size)\n            self.candidates[mutation_mask, :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nglobally_adaptive_ESO = GloballyAdaptiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = globally_adaptive_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "GloballyAdaptiveEvolutionarySwarmOptimization", "description": "Novel \"Globally-Adaptive Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems with adaptive search space.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "a691d5b9-ef8f-4dad-83ee-5ccaddde961a", "solution": "import numpy as np\n\nclass ParticleSwarmEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.rbest = np.zeros((self.population_size, self.dim))\n        self.pbest_fitness = np.zeros(self.population_size)\n        self.rbest_fitness = np.zeros(self.population_size)\n        self.ps = np.zeros((self.population_size, self.dim))\n        self.rs = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Selection\n            self.pbest_fitness = np.min(self.pbest[:, 0])\n            self.rbest_fitness = np.min(self.rbest[:, 0])\n            self.ps = self.pbest[np.argmin(self.pbest_fitness), :]\n            self.rs = self.rbest[np.argmin(self.rbest_fitness), :]\n\n            # Particle Swarm Optimization\n            for i in range(self.population_size):\n                r = np.random.uniform(0, 1, size=self.dim)\n                self.ps[i] = self.ps[i] + r * (self.rbest[i, :] - self.ps[i])\n                self.rs[i] = self.rs[i] + r * (self.best_candidate - self.rs[i])\n                self.pbest[i, :] = self.ps[i]\n                self.pbest_fitness[i] = func(self.ps[i])\n\n                # Evolutionary Strategy\n                self.candidates[i, :] = self.ps[i] + np.random.uniform(-0.25, 0.25, size=self.dim)\n\n                # Check if the best candidate is improved\n                if self.pbest_fitness[i] < self.best_fitness:\n                    self.best_candidate = self.ps[i]\n                    self.best_fitness = self.pbest_fitness[i]\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nparticle_ESO = ParticleSwarmEvolutionaryStrategy(budget=100, dim=2)\nbest_candidate, best_fitness = particle_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ParticleSwarmEvolutionaryStrategy", "description": "Novel \"Particle Swarm Optimization with Evolutionary Strategy\" algorithm combining particle swarm optimization and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence.').", "error": "ValueError('setting an array element with a sequence.')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "447085a2-07f2-464e-92ff-2786c86ebe94", "solution": "import numpy as np\n\nclass AdaptiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.adaptation_rate = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            mutated_candidates = self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :]\n            mutated_candidates = mutated_candidates + mutated_candidates * np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n            self.candidates = mutated_candidates\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Adaptive Evolutionary Strategies\n            for i in range(self.population_size):\n                if np.random.rand() < self.adaptation_rate:\n                    self.candidates[i, :] = self.candidates[i, :] + np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nadaptive_ESO = AdaptiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = adaptive_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "AdaptiveEvolutionarySwarmOptimization", "description": "Novel \"Black Box Optimization with Adaptive Evolutionary Strategies\" algorithm combining adaptive evolutionary strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "a566e541-3df6-478e-8f65-16d267d11001", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.fitnesses = np.inf * np.ones((self.population_size, 2))\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.fitnesses[:, 0] = fitness\n            self.fitnesses[:, 1] = func(self.candidates[:, 1])\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.fitnesses[np.argmin(self.fitnesses[:, 0]), 0] and new_fitness < self.fitnesses[np.argmin(self.fitnesses[:, 1]), 1]:\n                    self.best_candidates[np.argmin(self.fitnesses[:, 0]), :] = new_candidate\n                    self.fitnesses[np.argmin(self.fitnesses[:, 0]), :] = new_fitness\n                    self.fitnesses[np.argmin(self.fitnesses[:, 1]), 1] = new_fitness\n                    self.best_candidates[np.argmin(self.fitnesses[:, 1]), :] = new_candidate\n                    self.fitnesses[np.argmin(self.fitnesses[:, 1]), 1] = new_fitness\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.fitnesses[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.fitnesses[np.argmin(self.fitnesses[:, 0]), 0] < self.fitnesses[np.argmin(self.fitnesses[:, 1]), 1]:\n                self.candidates[np.argmin(self.fitnesses[:, 0]), :] = self.best_candidates[np.argmin(self.fitnesses[:, 0]), :]\n\n        return self.best_candidates[np.argmin(self.fitnesses[:, 0]), :], self.fitnesses[np.argmin(self.fitnesses[:, 0]), 0]\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_objective_ESO = MultiObjectiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = multi_objective_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiObjectiveEvolutionarySwarmOptimization", "description": "Novel \"Multi-Objective Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence to tackle multi-objective black box optimization problems.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "6d178b2a-ca28-4239-a40f-f1bd91ec3495", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Probabilistic Mutation\n            mutate = np.random.rand(self.population_size) < 0.25\n            self.candidates[mutate, :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nprobabilistic_ESO = ProbabilisticEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = probabilistic_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilisticEvolutionarySwarmOptimization", "description": "Novel \"Probabilistic Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence with probabilistic mutation.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('boolean index did not match indexed array along dimension 0; dimension is 100 but corresponding boolean dimension is 50').", "error": "IndexError('boolean index did not match indexed array along dimension 0; dimension is 100 but corresponding boolean dimension is 50')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "8cdc70e8-a675-4444-82c7-a374142068fd", "solution": "import numpy as np\nimport random\n\nclass HybridDEES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.p = 0.25  # probability of changing individual lines\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Selection\n            self.candidates = self.candidates[np.argsort(func(self.candidates[:, 0]))]\n\n            # Hybrid Evolutionary Strategies\n            for i in range(self.population_size):\n                if random.random() < self.p:\n                    # Change individual lines\n                    self.candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n                    self.candidates[i, :] = np.clip(self.candidates[i, :], -5.0, 5.0)\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                # Generate a random vector\n                F = np.random.uniform(0.0, 2.0, size=self.dim)\n\n                # Generate a random individual\n                r = np.random.uniform(0.0, 1.0, size=self.dim)\n                x1 = self.candidates[i, :]\n                x2 = self.candidates[(i + 1) % self.population_size, :]\n                x3 = self.candidates[(i + 2) % self.population_size, :]\n                x4 = self.candidates[(i + 3) % self.population_size, :]\n\n                # Calculate the new individual\n                new_x = x1 + F * (x2 - x1) + r * (x3 - x1) + (1 - r) * (x4 - x1)\n\n                # Calculate the fitness\n                new_fitness = func(new_x)\n\n                # Update the best candidate\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_x\n                    self.best_fitness = new_fitness\n\n            # Update the best candidate\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(func(self.candidates[:, 0])), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_DEES = HybridDEES(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_DEES(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HybridDEES", "description": "Novel \"Differential Evolution with Hybrid Evolutionary Strategies\" algorithm combining differential evolution with hybrid evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 13 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 13 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "1b58167b-23e2-4d6f-b14f-d2bdc0bdac21", "solution": "import numpy as np\nimport random\n\nclass BlackHoleEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Black Hole Search\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Evolution Strategy\n            for i in range(self.population_size):\n                if random.random() < 0.25:\n                    self.candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nblack_hole_evolution = BlackHoleEvolution(budget=100, dim=2)\nbest_candidate, best_fitness = black_hole_evolution(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "BlackHoleEvolution", "description": "Novel \"Black Hole Evolution\" algorithm combining black hole search and evolution strategies to optimize black box functions.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "65cb3dc4-32b5-4532-8cd2-eef95e2e005b", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Probabilistic Mutation\n            mutated_candidates = np.copy(self.candidates)\n            for i in range(self.population_size):\n                if np.random.rand() < self.probability:\n                    mutated_candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n            self.candidates = mutated_candidates\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nprobabilistic_ESO = ProbabilisticEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = probabilistic_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilisticEvolutionarySwarmOptimization", "description": "Novel \"Probabilistic Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies, swarm intelligence, and probabilistic mutation to tackle black box optimization problems.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "2d0e67b5-f943-49a1-a0a2-ca277ea52aee", "solution": "import numpy as np\n\nclass CrossoverSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Crossover\n            new_candidates = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1 = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                parent2 = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                child = parent1 + parent2 * np.random.uniform(-0.5, 0.5, size=(1, self.dim))\n                new_candidates[i, :] = child[0, :]\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = new_candidates\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ncso = CrossoverSwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = cso(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "CrossoverSwarmOptimization", "description": "Novel \"Crossover Swarm Optimization\" algorithm combining crossover and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "b524b4e5-3202-47ee-a064-fa1294b1491a", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticHybridEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            mutated_candidates = self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :]\n            for i in range(self.population_size):\n                mutated_candidates[i, :] = mutated_candidates[i, :] + \\\n                                          mutated_candidates[i, :] * \\\n                                          np.random.uniform(-0.1, 0.1, size=(self.dim,))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Probabilistic Mutation\n            if np.random.rand() < 0.25:\n                self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nprobabilistic_ESO = ProbabilisticHybridEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = probabilistic_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilisticHybridEvolutionarySwarmOptimization", "description": "Novel \"Probabilistic Hybrid Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence with probabilistic mutation.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "9a4736fa-b14b-48a9-9b7b-a20bdedd2f8a", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass QuantumInspiredHybridEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Quantum Computing\n            quantum_candidates = self.candidates.copy()\n            for i in range(self.population_size):\n                quantum_candidates[i] = quantum_candidates[i] + np.random.normal(0, 0.1, size=self.dim)\n                quantum_candidates[i] = np.clip(quantum_candidates[i], -5.0, 5.0)\n            quantum_fitness = func(quantum_candidates[:, 0])\n            self.candidates[np.argmin(quantum_fitness), :] = quantum_candidates[np.argmin(quantum_fitness), :]\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_ESO = QuantumInspiredHybridEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "QuantumInspiredHybridEvolutionarySwarmOptimization", "description": "Novel \"Quantum-Inspired Hybrid Evolutionary Swarm Optimization\" algorithm combining quantum computing, evolutionary strategies, and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be greater than 0 unless no samples are taken').", "error": "ValueError('a must be greater than 0 unless no samples are taken')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "c8db73b5-0b74-432a-86a8-1e8ba4eb291e", "solution": "import numpy as np\n\nclass EvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Probabilistic Refinement\n            for i in range(self.population_size):\n                if np.random.rand() < 0.25:\n                    self.candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nesO = EvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = esO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "EvolutionarySwarmOptimization", "description": "Novel \"Evolutionary Swarm Optimization with Probabilistic Refinement\" algorithm combining evolutionary strategies and swarm intelligence with probabilistic refinement.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be greater than 0 unless no samples are taken').", "error": "ValueError('a must be greater than 0 unless no samples are taken')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "90e9fb4e-e4fa-4956-ae8e-9508b7d368fb", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Probabilistic Mutation\n            mutation_prob = 0.25\n            for i in range(self.population_size):\n                if random.random() < mutation_prob:\n                    self.candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Particle Swarm Optimization\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmopso = MultiObjectiveParticleSwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = mopso(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiObjectiveParticleSwarmOptimization", "description": "Novel \"Multi-Objective Particle Swarm Optimization\" algorithm with probabilistic mutation.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "f563d861-ff3b-4c21-9674-ef689e4aed1b", "solution": "import numpy as np\nimport random\nimport time\n\nclass MetaLearningBasedEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_model = None\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Meta-Learning\n            if self.meta_model is None:\n                self.meta_model = self._train_meta_model(func, self.candidates)\n            else:\n                new_candidates = self._sample_candidates(func, self.candidates, self.meta_model)\n                new_fitness = func(new_candidates[:, 0])\n                if np.any(new_fitness < self.best_fitness):\n                    self.best_candidate = new_candidates[np.argmin(new_fitness), :]\n                    self.best_fitness = np.min(new_fitness)\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n    def _train_meta_model(self, func, candidates):\n        # Train a meta-model to predict the fitness of new candidates\n        X_train, y_train = self._prepare_data(candidates)\n        model = self._train_model(X_train, y_train)\n        return model\n\n    def _sample_candidates(self, func, candidates, meta_model):\n        # Sample new candidates using the meta-model\n        X_new = self._prepare_data(candidates)\n        y_new = meta_model.predict(X_new)\n        new_candidates = self._generate_candidates(X_new, y_new)\n        return new_candidates\n\n    def _prepare_data(self, candidates):\n        # Prepare the data for training the meta-model\n        X = np.array([candidate for candidate in candidates])\n        y = np.array([func(candidate) for candidate in candidates])\n        return X, y\n\n    def _train_model(self, X, y):\n        # Train a simple neural network to predict the fitness\n        from sklearn.neural_network import MLPRegressor\n        model = MLPRegressor(hidden_layer_sizes=(50,), max_iter=1000)\n        model.fit(X, y)\n        return model\n\n    def _generate_candidates(self, X_new, y_new):\n        # Generate new candidates using the meta-model\n        new_candidates = np.array([X_new[i] + np.random.uniform(-0.1, 0.1, size=self.dim) for i in range(X_new.shape[0])])\n        return new_candidates\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_LESO = MetaLearningBasedEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_LESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaLearningBasedEvolutionarySwarmOptimization", "description": "Novel \"Meta-Learning-based Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies, swarm intelligence, and meta-learning to tackle black box optimization problems.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "e25941ef-7e30-4ae4-aeb8-40ab31eb961c", "solution": "import numpy as np\nimport random\n\nclass MetaLEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_model = self._initialize_meta_model()\n\n    def _initialize_meta_model(self):\n        # Initialize a simple neural network to model the evolutionary strategy\n        model = np.random.uniform(-0.1, 0.1, size=(self.dim, self.dim))\n        return model\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            strategy = self.meta_model.predict(self.candidates[:, 0])\n            new_candidates = self.candidates + strategy * np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine the evolutionary strategy\n            self.meta_model = self._refine_meta_model(self.candidates, self.best_candidate, self.best_fitness)\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n    def _refine_meta_model(self, candidates, best_candidate, best_fitness):\n        # Refine the meta-model using the best candidate and its fitness\n        model = np.random.uniform(-0.1, 0.1, size=(self.dim, self.dim))\n        # Use the best candidate as the input to the meta-model\n        input_data = best_candidate.reshape((1, self.dim))\n        # Use the fitness as the output of the meta-model\n        output_data = best_fitness.reshape((1, 1))\n        # Update the meta-model parameters using the input and output data\n        model = np.array([model + 0.25 * (input_data - model) * (output_data - model) for model in model])\n        return model\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_LES = MetaLEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_LES(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaLEvolutionarySwarmOptimization", "description": "Novel \"Meta-Learning-Based Evolutionary Algorithm\" that adapts evolutionary strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'numpy.ndarray' object has no attribute 'predict'\").", "error": "AttributeError(\"'numpy.ndarray' object has no attribute 'predict'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "bb4f9a40-e9ce-4307-9ac7-e770221c2616", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass MultiObjectiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Differential Evolution\n            candidates_de = differential_evolution(func, [(-5.0, 5.0)] * self.dim, maxiter=10, x0=self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :])\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_objective_ESO = MultiObjectiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = multi_objective_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiObjectiveEvolutionarySwarmOptimization", "description": "Novel \"Multi-Objective Evolutionary Swarm Optimization\" algorithm combining multi-objective evolutionary strategies and swarm intelligence to tackle black box optimization problems with a budget constraint.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (100,2) into shape (2,)').", "error": "ValueError('could not broadcast input array from shape (100,2) into shape (2,)')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "0a2a3b77-a6b5-492a-9b5d-4f042a924de2", "solution": "import numpy as np\nimport random\n\nclass PSO_EvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.rbest = np.zeros((self.population_size, self.dim))\n        self.swarm_intelligence = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Particle Swarm Optimization\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1)\n                r2 = np.random.uniform(0, 1)\n                if r1 < 0.25:\n                    self.candidates[i, :] += self.swarm_intelligence[i, :] * np.random.uniform(-0.1, 0.1, size=self.dim)\n                if r2 < 0.25:\n                    self.candidates[i, :] += self.pbest[i, :] * np.random.uniform(-0.1, 0.1, size=self.dim)\n                self.swarm_intelligence[i, :] = (self.swarm_intelligence[i, :] * 0.9 + self.candidates[i, :] * 0.1)\n                self.pbest[i, :] = self.candidates[i, :]\n                self.rbest[i, :] = self.candidates[i, :]\n\n                # Evolutionary Strategy\n                self.candidates[i, :] += self.candidates[i, :] * np.random.uniform(-0.1, 0.1, size=self.dim)\n\n                # Selection\n                self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n                self.population_size = self.population_size // 2\n\n                # Mutation\n                self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n                # Check if the best candidate is improved\n                if self.best_fitness < func(self.best_candidate):\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\npso_es = PSO_EvolutionaryStrategy(budget=100, dim=2)\nbest_candidate, best_fitness = pso_es(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "PSO_EvolutionaryStrategy", "description": "Novel \"Particle Swarm Optimization with Evolutionary Strategy\" algorithm combining particle swarm optimization and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "225102a8-4e5d-46ca-af92-e71a5be18583", "solution": "import numpy as np\nimport random\n\nclass DifferentialEvolutionWithSwarmIntelligence:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.swarm_size = 10\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                for j in range(self.swarm_size):\n                    rand1, rand2 = np.random.rand(2)\n                    x1, x2 = self.candidates[i, :], self.candidates[np.random.choice(self.population_size, size=1, replace=False)[0], :]\n                    x1, x2 = x1 * (1 - rand1), x2 * (1 - rand2)\n                    self.candidates[i, :] = self.candidates[i, :] + x2 - x1\n\n            # Swarm Intelligence\n            for _ in range(self.swarm_size):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ndifferential_DE_with_swarm = DifferentialEvolutionWithSwarmIntelligence(budget=100, dim=2)\nbest_candidate, best_fitness = differential_DE_with_swarm(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "DifferentialEvolutionWithSwarmIntelligence", "description": "Novel \"Differential Evolution with Swarm Intelligence\" algorithm combining differential evolution and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "4800e3c5-68cb-4586-ba41-6c39abf4a40b", "solution": "import numpy as np\nimport random\n\nclass HybridPSOES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.particle_swarm_coefficient = 0.25\n        self.evolutionary_strategy_coefficient = 0.25\n        self.swarm_intelligence_coefficient = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim)) * self.evolutionary_strategy_coefficient\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness * self.swarm_intelligence_coefficient:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_PSOES = HybridPSOES(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_PSOES(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HybridPSOES", "description": "Novel \"Particle Swarm Optimization with Evolutionary Strategies and Swarm Intelligence\" algorithm.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "4738bf09-2334-4fd5-a8bf-7d2dc6e71fc5", "solution": "import numpy as np\nimport random\n\nclass DifferentialEvolutionWithSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.swarm_size = 10\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                j = np.random.randint(0, self.population_size)\n                k = np.random.randint(0, self.population_size)\n                new_candidate = self.candidates[i, :] + \\\n                                self.candidates[j, :] - \\\n                                self.candidates[k, :] + \\\n                                2 * np.random.uniform(-0.1, 0.1, size=self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Swarm Intelligence\n            for _ in range(self.swarm_size):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine strategy\n            for i in range(self.population_size):\n                if np.random.rand() < 0.25:\n                    self.candidates[i, :] += np.random.uniform(-0.05, 0.05, size=self.dim)\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nde_with_swarm = DifferentialEvolutionWithSwarm(budget=100, dim=2)\nbest_candidate, best_fitness = de_with_swarm(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "DifferentialEvolutionWithSwarm", "description": "Novel \"Differential Evolution with Swarm Intelligence\" algorithm combining differential evolution strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "14a4f453-5e78-4e75-a2bc-1f171e9fc45c", "solution": "import numpy as np\nimport random\n\nclass MultiObjectivePSOES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.objective_functions = []\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(fitness), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(fitness), :] = new_candidate\n\n            # Multi-Objective Optimization\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = np.array([func(new_candidate + np.random.uniform(-0.1, 0.1, size=self.dim)) for _ in range(5)])\n                new_fitness = np.mean(new_fitness)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(fitness), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(fitness)]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < np.mean([func(self.candidates[np.argmin(fitness), :]) for _ in range(5)]):\n                self.candidates[np.argmin(fitness), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_objective_PSOES = MultiObjectivePSOES(budget=100, dim=2)\nbest_candidate, best_fitness = multi_objective_PSOES(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiObjectivePSOES", "description": "Novel \"Multi-Objective Particle Swarm Optimization with Evolutionary Strategies\" algorithm combining swarm intelligence and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 19 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 19 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "b9cf04f1-3243-499b-865e-f9678ef71ec4", "solution": "import numpy as np\nimport random\n\nclass DifferentialEvolutionWithSwarmIntelligence:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.p = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                j = np.random.randint(0, self.population_size)\n                k = np.random.randint(0, self.population_size)\n                new_candidate = self.candidates[i, :] + \\\n                               self.p * (self.candidates[j, :] - self.candidates[k, :])\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += \\\n                         np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine strategy\n            for i in range(self.population_size):\n                if np.random.rand() < self.p:\n                    self.candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nde_with_swarm = DifferentialEvolutionWithSwarmIntelligence(budget=100, dim=2)\nbest_candidate, best_fitness = de_with_swarm(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "DifferentialEvolutionWithSwarmIntelligence", "description": "Novel \"Differential Evolution with Swarm Intelligence\" algorithm combining differential evolution strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "404b2bc5-89c9-4945-85b4-aa8e29fca419", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\nclass MultiObjectiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Multi-Objective Evolutionary Strategy\n            new_candidates = []\n            for _ in range(self.population_size):\n                candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                fitness = func(candidate)\n                new_candidates.append((candidate, fitness))\n            new_candidates = sorted(new_candidates, key=lambda x: x[1])\n            self.candidates = np.array([x[0] for x in new_candidates[:self.population_size//2]])\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_objective_ESO = MultiObjectiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = multi_objective_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiObjectiveEvolutionarySwarmOptimization", "description": "Novel \"Multi-Objective Evolutionary Swarm Optimization\" algorithm combining multi-objective evolutionary strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 65 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 65 is out of bounds for axis 0 with size 50')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "35c34b22-03c5-4a5b-9664-b80af020f1bc", "solution": "import numpy as np\n\nclass ParticleSwarmEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.pbest = np.zeros((self.population_size, self.dim))\n        self.rbest = np.zeros((self.population_size, self.dim))\n        self.ps = np.zeros((self.population_size, self.dim))\n        self.rs = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Particle Swarm Optimization\n            for i in range(self.population_size):\n                self.pbest[i] = self.candidates[i, :]\n                self.rbest[i] = self.candidates[i, :]\n                self.ps[i] = self.rbest[i] + np.random.uniform(-0.1, 0.1, size=self.dim)\n                self.rs[i] = self.pbest[i] + np.random.uniform(-0.1, 0.1, size=self.dim)\n                new_fitness = func(self.ps[i]) + np.random.uniform(-0.1, 0.1, size=self.dim)\n                if new_fitness < self.rbest[i, 0]:\n                    self.rbest[i, :] = self.ps[i, :]\n                    self.rs[i, :] = self.rbest[i, :]\n                    self.candidates[i, :] = self.rs[i, :]\n                    if new_fitness < self.best_fitness:\n                        self.best_candidate = self.candidates[i, :]\n                        self.best_fitness = new_fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nps_es = ParticleSwarmEvolutionaryStrategy(budget=100, dim=2)\nbest_candidate, best_fitness = ps_es(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ParticleSwarmEvolutionaryStrategy", "description": "Novel \"Particle Swarm Optimization with Evolutionary Strategies\" algorithm combining particle swarm optimization and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "2e5d3606-c3f5-4425-9947-2f42ffa0250d", "solution": "import numpy as np\nimport random\n\nclass BlackBoxOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Genetic Strategy\n            mutated_candidates = self.candidates.copy()\n            for i in range(self.population_size):\n                if random.random() < 0.25:\n                    mutated_candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n                mutated_candidates[i, :] = np.clip(mutated_candidates[i, :], -5.0, 5.0)\n            self.candidates = mutated_candidates\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\noptimizer = BlackBoxOptimizer(budget=100, dim=2)\nbest_candidate, best_fitness = optimizer(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "BlackBoxOptimizer", "description": "Novel \"Black Box Optimizer using Genetic Algorithm and Swarm Intelligence\" algorithm combining genetic strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "1d225092-f213-4998-b0a6-a06cd87976fb", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticHybridEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            mutated_candidates = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :]\n            mutated_candidates = mutated_candidates + \\\n                                mutated_candidates * \\\n                                np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False, p=[0.75, 0.25]), :] = mutated_candidates\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False, p=[0.25, 0.75]), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nprobabilistic_ESO = ProbabilisticHybridEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = probabilistic_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilisticHybridEvolutionarySwarmOptimization", "description": "Novel \"Probabilistic Hybrid Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies, swarm intelligence, and probabilistic mutation to tackle black box optimization problems.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "1134496f-ed51-4745-908b-e21f240a98ea", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MetaEvolutionaryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.metalog = []\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Meta-Learning\n            new_metalog = []\n            for i in range(self.population_size):\n                new_individual = copy.deepcopy(self.candidates[i])\n                for j in range(self.dim):\n                    if random.random() < 0.25:\n                        new_individual[j] += np.random.uniform(-0.1, 0.1)\n                new_fitness = func(new_individual)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_individual\n                    self.best_fitness = new_fitness\n                new_metalog.append((new_individual, new_fitness))\n            self.metalog.append(new_metalog)\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_EO = MetaEvolutionaryOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_EO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaEvolutionaryOptimization", "description": "Novel \"Meta-Learning Evolutionary Optimization\" algorithm combining meta-learning and evolutionary strategies to optimize black box functions.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be greater than 0 unless no samples are taken').", "error": "ValueError('a must be greater than 0 unless no samples are taken')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "f82e397c-6e51-4691-ac21-3bde50257690", "solution": "import numpy as np\n\nclass SwarmDrivenEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.swarm_size = 10\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Swarm Intelligence\n            for _ in range(self.swarm_size):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n\n            # Evolutionary Strategy\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine strategy\n            for _ in range(int(self.budget * 0.25)):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nswarm_DEA = SwarmDrivenEvolutionaryAlgorithm(budget=100, dim=2)\nbest_candidate, best_fitness = swarm_DEA(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "SwarmDrivenEvolutionaryAlgorithm", "description": "Novel \"Swarm-Driven Evolutionary Algorithm\" combining swarm intelligence and evolutionary strategies for black box optimization.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "5f1104bb-2fd0-471d-85b1-8bbf2a110922", "solution": "import numpy as np\nimport random\n\nclass CognitiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.memory = []\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Cognitive Strategy\n            self.memory.append((self.candidates[:, 0], fitness))\n            self.memory.sort(key=lambda x: x[1], reverse=True)\n            self.memory = self.memory[:25]\n            new_individuals = []\n            for _ in range(10):\n                individual, fitness = random.choice(self.memory, p=[0.25]*len(self.memory))\n                new_individual = individual + np.random.uniform(-0.1, 0.1, size=self.dim)\n                new_individuals.append(new_individual)\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = np.array(new_individuals)\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ncognitive_ESO = CognitiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = cognitive_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "CognitiveEvolutionarySwarmOptimization", "description": "Novel \"Cognitive Evolutionary Swarm Optimization\" algorithm combining cognitive strategies and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"Random.choice() got an unexpected keyword argument 'p'\").", "error": "TypeError(\"Random.choice() got an unexpected keyword argument 'p'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "0b42d46a-3312-46fb-a82c-47dba1482e9a", "solution": "import numpy as np\nimport random\n\nclass SelfAdaptiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.adaptation_rate = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Self-Adaptive Evolutionary Strategy\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness * (1 + np.random.uniform(-1, 1)):\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine the strategy of the best candidate\n            if self.best_fitness < func(self.best_candidate):\n                refinement_candidates = self.candidates[np.random.choice(self.population_size, size=int(self.population_size * self.adaptation_rate), replace=False), :]\n                self.candidates[np.random.choice(self.population_size, size=int(self.population_size * (1 - self.adaptation_rate)), replace=False), :] = refinement_candidates\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nself_adaptive_ESO = SelfAdaptiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = self_adaptive_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "SelfAdaptiveEvolutionarySwarmOptimization", "description": "Novel \"Black Box Optimization with Self-Adaptive Evolutionary Strategies\" algorithm combining self-adaptive evolutionary strategies with swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "03624be8-5a9c-42ed-af24-3a70074527ba", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Probabilistic Refinement\n            refine_prob = 0.25\n            for i in range(self.population_size):\n                if np.random.rand() < refine_prob:\n                    new_candidate = self.candidates[i, :]\n                    new_candidate += np.random.uniform(-0.1, 0.1, size=self.dim)\n                    new_candidate = np.clip(new_candidate, -5.0, 5.0)\n                    new_fitness = func(new_candidate)\n                    if new_fitness < self.best_fitness:\n                        self.best_candidate = new_candidate\n                        self.best_fitness = new_fitness\n                        self.candidates[i, :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_ESO = HybridEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HybridEvolutionarySwarmOptimization", "description": "Novel \"Hybrid Evolutionary Swarm Optimization with Probabilistic Refinement\" algorithm combining evolutionary strategies, swarm intelligence, and probabilistic refinement to tackle black box optimization problems.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "1cc83e46-fb14-4621-babf-a7d9f5e35c9e", "solution": "import numpy as np\n\nclass EvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.mutation_rate = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Adaptive Mutation\n            mutation_candidates = self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False)]\n            for i in range(self.population_size):\n                if np.random.rand() < self.mutation_rate:\n                    mutation_candidates[i] += np.random.uniform(-0.1, 0.1, size=self.dim)\n            self.candidates = mutation_candidates\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nesO = EvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = esO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "EvolutionarySwarmOptimization", "description": "Novel \"Evolutionary Swarm Optimization with Adaptive Mutation\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "f8751a7c-21e5-46bd-9016-11f5935361e5", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.objectives = []\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(fitness), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(fitness), :] = new_candidate\n\n            # Multi-Objective Evolutionary Strategy\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = np.array([func(new_candidate), func(new_candidate)])\n                if np.all(new_fitness < self.best_fitness):\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(fitness), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(fitness)]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if np.all(self.best_fitness < func(self.best_candidate)):\n                self.candidates[np.argmin(fitness), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2, x[0]**3 + x[1]**3\n\nmulti_objective_ESO = MultiObjectiveEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = multi_objective_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiObjectiveEvolutionarySwarmOptimization", "description": "Novel \"Multi-Objective Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence to tackle multi-objective black box optimization problems.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 41 is out of bounds for axis 0 with size 2').", "error": "IndexError('index 41 is out of bounds for axis 0 with size 2')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "f80d49bb-6999-416d-bd72-d14c8d0935ed", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MetaLearningBasedEvolutionaryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_model = None\n        self.meta_learning_steps = 10\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Meta-Learning\n            if self.meta_model is None:\n                self.meta_model = self._create_meta_model(func, self.budget, self.dim)\n            new_candidates = self._sample_candidates(func, self.meta_model, self.budget, self.dim)\n            new_fitnesses = [func(candidate) for candidate in new_candidates]\n            new_best_candidate = new_candidates[np.argmin(new_fitnesses)]\n            new_best_fitness = new_fitnesses[np.argmin(new_fitnesses)]\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < new_best_fitness:\n                self.best_candidate = new_best_candidate\n                self.best_fitness = new_best_fitness\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n    def _create_meta_model(self, func, budget, dim):\n        # Initialize the meta model with a random set of candidates\n        candidates = np.random.uniform(-5.0, 5.0, (budget, dim))\n        # Define the loss function\n        def loss(model, func, candidates):\n            fitnesses = [func(candidate) for candidate in candidates]\n            return np.mean(np.abs(np.array(fitnesses) - np.array(fitnesses[np.argmin(fitnesses)])))\n        # Define the optimization algorithm for the meta model\n        def optimize(model, func, candidates):\n            # Sample a new set of candidates using the current model\n            new_candidates = self._sample_candidates(func, model, budget, dim)\n            # Evaluate the new candidates\n            new_fitnesses = [func(candidate) for candidate in new_candidates]\n            # Update the model\n            model = model - self.learning_rate * np.array(new_candidates) * np.array(new_fitnesses)\n            return model\n        # Initialize the meta model\n        meta_model = optimize(np.zeros((budget, dim)), func, candidates)\n        return meta_model\n\n    def _sample_candidates(self, func, model, budget, dim):\n        # Sample a new set of candidates using the current model\n        new_candidates = np.random.uniform(-5.0, 5.0, (budget, dim))\n        # Evaluate the new candidates\n        new_fitnesses = [func(candidate) for candidate in new_candidates]\n        # Update the model\n        model = model - self.learning_rate * np.array(new_candidates) * np.array(new_fitnesses)\n        return new_candidates\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_LESO = MetaLearningBasedEvolutionaryOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_LESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaLearningBasedEvolutionaryOptimization", "description": "Novel \"Meta-Learning-Based Evolutionary Optimization\" algorithm that leverages meta-learning techniques to adaptively optimize black box functions.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (100,2) (100,) ').", "error": "ValueError('operands could not be broadcast together with shapes (100,2) (100,) ')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "6af6c9c7-5200-4aeb-b957-bf0bea14e803", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticHybridEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Probabilistic Mutation\n            mutation_candidates = self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :]\n            mutation_mask = np.random.rand(self.population_size) < self.probability\n            mutation_candidates[mutation_mask, :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n            self.candidates = np.minimum(np.maximum(mutation_candidates, -5.0), 5.0)\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nprobabilistic_HESO = ProbabilisticHybridEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = probabilistic_HESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilisticHybridEvolutionarySwarmOptimization", "description": "Novel \"Probabilistic Hybrid Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies, swarm intelligence, and probabilistic mutation to tackle black box optimization problems.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (20,2) (100,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (20,2) (100,2) (20,2) ')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "82161bcb-0809-43d4-8529-abf51dd729ce", "solution": "import numpy as np\nimport random\n\nclass EvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Probabilistic Refinement\n            for i in range(self.population_size):\n                if random.random() < 0.25:\n                    self.candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n                if random.random() < 0.25:\n                    self.candidates[i, :] -= np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nesO = EvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = esO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "EvolutionarySwarmOptimization", "description": "Novel \"Evolutionary Swarm Optimization with Probabilistic Refinement\" algorithm combining evolutionary strategies and swarm intelligence with probabilistic refinement to tackle black box optimization problems.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "c75b99fe-3689-44e9-9e1b-27fba85d9762", "solution": "import numpy as np\nimport random\n\nclass MultiPhaseAdaptiveEvolutionaryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.phase = 0\n        self.adaptive_rate = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Adaptive Mutation\n            if self.phase < self.budget // 4:\n                self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n            else:\n                self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-self.adaptive_rate, self.adaptive_rate, size=(self.population_size, self.dim))\n\n            # Phase Update\n            if _ % (self.budget // 4) == 0:\n                self.phase += 1\n                self.adaptive_rate += 0.01\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_phase_AEO = MultiPhaseAdaptiveEvolutionaryOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = multi_phase_AEO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiPhaseAdaptiveEvolutionaryOptimization", "description": "Novel \"Multi-Phase Adaptive Evolutionary Optimization\" algorithm combining evolutionary strategies, swarm intelligence, and adaptive mutation to tackle black box optimization problems.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "f4c2fec2-c777-43fc-ad35-c76164d71a7a", "solution": "import numpy as np\nimport random\nimport tensorflow as tf\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras.layers import Input, Dense, Concatenate, Reshape\n\nclass MetaLEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_model = self.create_meta_model()\n\n    def create_meta_model(self):\n        input_layer = Input(shape=(self.dim,))\n        hidden_layer = Dense(64, activation='relu')(input_layer)\n        output_layer = Dense(1)(hidden_layer)\n        model = Model(inputs=input_layer, outputs=output_layer)\n        model.compile(optimizer='adam', loss='mean_squared_error')\n        return model\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Meta-learning\n            inputs = self.candidates[:, 0].reshape((-1, self.dim))\n            outputs = np.array([func(x) for x in inputs])\n            self.meta_model.fit(inputs, outputs, epochs=10, verbose=0)\n            meta_weights = self.meta_model.get_weights()\n\n            # Refine evolutionary strategy\n            new_candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n            for i in range(self.population_size):\n                new_candidate = new_candidates[i, :]\n                new_candidate = new_candidate + self.meta_model.predict(new_candidate.reshape(1, self.dim))[0]\n                new_candidate = new_candidate + np.random.uniform(-0.1, 0.1, size=(1, self.dim))[0]\n                new_candidate = new_candidate.flatten()\n                new_candidates[i, :] = new_candidate\n\n            # Selection\n            self.candidates = new_candidates\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_LEA = MetaLEvolutionaryAlgorithm(budget=100, dim=2)\nbest_candidate, best_fitness = meta_LEA(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaLEvolutionaryAlgorithm", "description": "Novel \"Meta-Learning-based Evolutionary Algorithm\" that leverages meta-learning to adapt and refine the evolutionary strategy.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'tensorflow'\").", "error": "ModuleNotFoundError(\"No module named 'tensorflow'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "9230285e-6788-4d37-9352-6a96bf6241e0", "solution": "import numpy as np\nimport random\n\nclass AdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.adaptation_rate = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Adaptive Evolutionary Strategy\n            for i in range(self.population_size):\n                if random.random() < self.adaptation_rate:\n                    self.candidates[i, :] = self.candidates[i, :] + \\\n                                          self.candidates[i, :] * np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nadaptive_SE = AdaptiveSwarmEvolution(budget=100, dim=2)\nbest_candidate, best_fitness = adaptive_SE(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "AdaptiveSwarmEvolution", "description": "Novel \"Adaptive Swarm Evolution\" algorithm combining adaptive strategies and swarm intelligence to optimize black box functions.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "f0b6d516-76f0-4ad4-8f7c-335538e1e1b0", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            new_candidates = []\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                mutation = np.random.uniform(-0.1, 0.1, size=(1, self.dim))\n                new_candidate += mutation\n                new_candidates.append(new_candidate)\n            new_candidates = np.array(new_candidates)\n            self.candidates[np.random.choice(self.population_size, size=len(new_candidates), replace=False), :] = new_candidates\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Refine strategy with probability\n            if np.random.rand() < self.probability:\n                for i in range(self.population_size):\n                    mutation = np.random.uniform(-0.1, 0.1, size=(1, self.dim))\n                    self.candidates[i, :] += mutation\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nprobabilistic_ESO = ProbabilisticEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = probabilistic_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilisticEvolutionarySwarmOptimization", "description": "Novel \"Probabilistic Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems with adaptive probability.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shape mismatch: value array of shape (10,1,2) could not be broadcast to indexing result of shape (10,2)').", "error": "ValueError('shape mismatch: value array of shape (10,1,2) could not be broadcast to indexing result of shape (10,2)')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "660a047c-abcb-4cb4-8cbd-a380cc1b24b7", "solution": "import numpy as np\nimport random\n\nclass EvolutionarySwarmOptimizationWithProbabilisticRefining:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            new_candidates = np.copy(self.candidates)\n            for i in range(self.population_size):\n                new_candidates[i, :] = self.candidates[i, :] + \\\n                                        self.candidates[i, :] * np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            new_candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Probabilistic Refining\n            for i in range(self.population_size):\n                if np.random.rand() < 0.25:\n                    new_candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Mutation\n            self.candidates = new_candidates\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\neso_prr = EvolutionarySwarmOptimizationWithProbabilisticRefining(budget=100, dim=2)\nbest_candidate, best_fitness = eso_prr(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "EvolutionarySwarmOptimizationWithProbabilisticRefining", "description": "Novel \"Evolutionary Swarm Optimization with Probabilistic Refining\" algorithm combining evolutionary strategies and swarm intelligence to tackle black box optimization problems with probabilistic refining.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "36b0be42-6da3-48a2-8fde-241786669a99", "solution": "import numpy as np\nimport random\n\nclass ProbabilityBasedHybridEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False, p=[0.25, 0.75]), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False, p=[0.25, 0.75]), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False, p=[0.25, 0.75]), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            probabilities = np.array([np.min(self.candidates[:, 0]), np.min(self.candidates[:, 1])])\n            indices = np.random.choice(self.population_size, size=self.population_size, replace=False, p=probabilities)\n            self.candidates = self.candidates[indices, :]\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False, p=[0.25, 0.75]), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_ESO = ProbabilityBasedHybridEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilityBasedHybridEvolutionarySwarmOptimization", "description": "Novel \"Probability-Based Hybrid Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence with probability-based selection and mutation.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "f5102618-0508-41f7-9d4d-7850f46762a8", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            mutated_candidates = self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :]\n            for i in range(self.population_size):\n                if random.random() < 0.25:\n                    mutated_candidates[i] += np.random.uniform(-0.1, 0.1, size=self.dim)\n            self.candidates = np.minimum(np.maximum(mutated_candidates, -5.0), 5.0)\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nprobabilistic_ESO = ProbabilisticEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = probabilistic_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilisticEvolutionarySwarmOptimization", "description": "Novel \"Probabilistic Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence with probabilistic mutation.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "0ef1aa7c-8ac2-4eb5-90ac-65bf4f6da3b1", "solution": "import numpy as np\nimport random\n\nclass HybridEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Probabilistic Refinement\n            refine_candidates = self.candidates[np.random.choice(self.population_size, size=int(0.25 * self.population_size), replace=False), :]\n            refined_candidates = refine_candidates + np.random.uniform(-0.1, 0.1, size=(int(0.25 * self.population_size), self.dim))\n            self.candidates = np.concatenate((self.candidates, refined_candidates), axis=0)\n            self.population_size += int(0.25 * self.population_size)\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_ESO = HybridEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HybridEvolutionarySwarmOptimization", "description": "Novel \"Hybrid Evolutionary Swarm Optimization with Probabilistic Refinement\" algorithm combining evolutionary strategies, swarm intelligence, and probabilistic refinement to tackle black box optimization problems.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be greater than 0 unless no samples are taken').", "error": "ValueError('a must be greater than 0 unless no samples are taken')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "9fc9671a-c661-459e-b2d1-70d090320718", "solution": "import numpy as np\nimport random\n\nclass AdaptiveSwarmIntelligenceWithEvolutionaryDrift:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.swarm_intelligence_coefficient = 0.25\n        self.evolutionary_drift_coefficient = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Adaptive Swarm Intelligence\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness * (1 + np.random.uniform(-self.swarm_intelligence_coefficient, self.swarm_intelligence_coefficient)):\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Evolutionary Drift\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness * (1 + np.random.uniform(-self.evolutionary_drift_coefficient, self.evolutionary_drift_coefficient)):\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nadaptive_SiED = AdaptiveSwarmIntelligenceWithEvolutionaryDrift(budget=100, dim=2)\nbest_candidate, best_fitness = adaptive_SiED(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "AdaptiveSwarmIntelligenceWithEvolutionaryDrift", "description": "Novel \"Adaptive Swarm Intelligence with Evolutionary Drift\" algorithm combining adaptive swarm intelligence and evolutionary drift to tackle black box optimization problems.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "eb751dc6-a2aa-49e2-a1d8-39b49a2f22b7", "solution": "import numpy as np\nimport random\n\nclass EvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            mutation_candidates = self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :]\n            for i in range(self.population_size):\n                mutation_candidates[i, :] += np.random.uniform(-0.1, 0.1, size=(self.dim,))\n                if np.random.rand() < 0.25:\n                    mutation_candidates[i, :] = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n\n            self.candidates = mutation_candidates\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nesO = EvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = esO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "EvolutionarySwarmOptimization", "description": "Novel \"Evolutionary Swarm Optimization with Probability Refinement\" algorithm combining evolutionary strategies and swarm intelligence with probability refinement.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "608eab9a-c1ea-4809-8f5d-8efeda4468af", "solution": "import numpy as np\nimport random\n\nclass ProbabilityDrivenEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            mutated_candidates = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :]\n            mutated_candidates += mutated_candidates * np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n            self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] = mutated_candidates\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Probabilistic Mutation\n            mutation_prob = 0.25\n            mutated_candidates = self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :]\n            mutated_candidates += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim)) * (1 - mutation_prob) + \\\n                                  np.random.uniform(-0.5, 0.5, size=(self.population_size, self.dim)) * mutation_prob\n            self.candidates = mutated_candidates\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\npdr_ESO = ProbabilityDrivenEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = pdr_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilityDrivenEvolutionarySwarmOptimization", "description": "Novel \"Probability-Driven Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies, swarm intelligence, and probabilistic mutation to tackle black box optimization problems.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "882d8150-9b1d-4d05-a348-58e78f7ea222", "solution": "import numpy as np\nimport random\nimport time\n\nclass QuantumAnnealingOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.qao_params = {\n            'num_iterations': 100,\n            'num_qubits': self.dim,\n            'cooling_schedule': 'linear',\n            'annealing_schedule': 'linear'\n        }\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Quantum-inspired Optimization\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Quantum Annealing\n            for _ in range(self.qao_params['num_iterations']):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nqao = QuantumAnnealingOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = qao(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "QuantumAnnealingOptimization", "description": "Novel \"Quantum-inspired Quantum Annealing Optimization\" algorithm combining quantum-inspired optimization techniques with quantum annealing to tackle black box optimization problems.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "225cea08-98bd-4b3b-a1fd-c5e919e723eb", "solution": "import numpy as np\nimport random\n\nclass MultiObjectiveEvolutionaryOptimizationWithDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.mutation_probability = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(fitness), :]\n            self.best_fitness = np.min(fitness)\n\n            # Multi-Objective Optimization\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(fitness), :] = new_candidate\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                r1 = np.random.randint(0, self.population_size)\n                r2 = np.random.randint(0, self.population_size)\n                r3 = np.random.randint(0, self.population_size)\n\n                x1, x2, x3 = self.candidates[i], self.candidates[r1], self.candidates[r2]\n                x1, x2, x3 = x1 + np.random.uniform(-0.1, 0.1, size=self.dim), x2 + np.random.uniform(-0.1, 0.1, size=self.dim), x3 + np.random.uniform(-0.1, 0.1, size=self.dim)\n\n                f1, f2, f3 = func(x1), func(x2), func(x3)\n                f1, f2, f3 = f1 + np.random.uniform(-0.1, 0.1, size=self.dim), f2 + np.random.uniform(-0.1, 0.1, size=self.dim), f3 + np.random.uniform(-0.1, 0.1, size=self.dim)\n\n                x1, x2, x3 = x1 - f1 + f2, x2 - f2 + f3, x3 - f3 + f1\n                x1, x2, x3 = x1 / (np.linalg.norm(x1) + np.linalg.norm(x2) + np.linalg.norm(x3)), x2 / (np.linalg.norm(x1) + np.linalg.norm(x2) + np.linalg.norm(x3)), x3 / (np.linalg.norm(x1) + np.linalg.norm(x2) + np.linalg.norm(x3))\n\n                if np.random.rand() < self.mutation_probability:\n                    self.candidates[i] = x1\n                    self.candidates[r1] = x2\n                    self.candidates[r2] = x3\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(fitness)]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(fitness), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_objective_DE = MultiObjectiveEvolutionaryOptimizationWithDifferentialEvolution(budget=100, dim=2)\nbest_candidate, best_fitness = multi_objective_DE(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiObjectiveEvolutionaryOptimizationWithDifferentialEvolution", "description": "Novel \"Multi-Objective Evolutionary Optimization with Differential Evolution\" algorithm combining multi-objective optimization and differential evolution to tackle black box optimization problems.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 44 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 44 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "b1f077ef-e7bf-4508-b0d2-b286fa4c10f0", "solution": "import numpy as np\n\nclass CrossoverSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Crossover\n            for _ in range(10):\n                new_candidate1 = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_candidate2 = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_candidate = (new_candidate1 + new_candidate2) / 2\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=True), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ncso = CrossoverSwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = cso(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "CrossoverSwarmOptimization", "description": "Novel \"Crossover Swarm Optimization\" algorithm combining crossover and swarm intelligence to tackle black box optimization problems.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "5b8f9df4-d911-4496-ac43-cfabec14c1d8", "solution": "import numpy as np\nimport random\n\nclass SwarmInspiredAdaptiveEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.adaptation_rate = 0.25\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Adaptive Strategy\n            for i in range(self.population_size):\n                if random.random() < self.adaptation_rate:\n                    self.candidates[i, :] += np.random.uniform(-0.1, 0.1, size=self.dim)\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nswarm_ESA = SwarmInspiredAdaptiveEvolution(budget=100, dim=2)\nbest_candidate, best_fitness = swarm_ESA(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "SwarmInspiredAdaptiveEvolution", "description": "Novel \"Swarm-Inspired Adaptive Evolution\" algorithm combining adaptive strategies and swarm intelligence to optimize black box functions.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "f0be1dd2-4ddf-485c-8810-5c5affd3e5e4", "solution": "import numpy as np\nimport random\n\nclass ProbabilityWeightedEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=True), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Probability-Weighted Mutation\n            mutation_indices = np.random.choice(self.population_size, size=self.population_size, replace=True, p=np.ones(self.population_size) / self.population_size)\n            self.candidates[mutation_indices, :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nprob_weighted_ESO = ProbabilityWeightedEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = prob_weighted_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "ProbabilityWeightedEvolutionarySwarmOptimization", "description": "Novel \"Probability-Weighted Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies and swarm intelligence with probability-weighted mutation to tackle black box optimization problems.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "ed19d056-6b67-4ff1-a8b6-ba51e2e8cbc2", "solution": "import numpy as np\nimport random\nfrom copy import deepcopy\n\nclass MetaEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_model = None\n        self.meta_learning_rate = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n            # Meta-Learning\n            if self.meta_model is None:\n                self.meta_model = np.random.uniform(-5.0, 5.0, (self.dim,)).reshape((1, self.dim))\n            new_meta_model = self.meta_model + self.meta_learning_rate * (self.candidates[:, 0].reshape((1, self.dim)) - self.meta_model)\n            self.meta_model = new_meta_model\n\n            # Refine the strategy\n            refined_candidates = self.candidates[np.random.choice(self.population_size, size=25, replace=False), :]\n            refined_candidates = refined_candidates + self.meta_model\n            refined_candidates = refined_candidates[np.argsort(refined_candidates[:, 0])]\n            self.candidates = refined_candidates[:self.population_size]\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_ESO = MetaEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaEvolutionarySwarmOptimization", "description": "Novel \"Meta-Learning Guided Evolutionary Swarm Optimization\" algorithm combining evolutionary strategies, swarm intelligence, and meta-learning to tackle black box optimization problems.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('cannot reshape array of size 100 into shape (1,2)').", "error": "ValueError('cannot reshape array of size 100 into shape (1,2)')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "01488486-562c-4c7c-923f-f0391eec210c", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MetaEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_model = None\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Meta-Learning\n            if self.meta_model is None:\n                self.meta_model = self._create_meta_model(func, self.population_size)\n            self.candidates = self.meta_model.predict(self.candidates)\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Swarm Intelligence\n            for _ in range(10):\n                new_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n    def _create_meta_model(self, func, population_size):\n        # Initialize the meta-model\n        model = {}\n        for _ in range(10):\n            # Randomly sample a candidate\n            candidate = np.random.uniform(-5.0, 5.0, self.dim)\n            # Evaluate the fitness of the candidate\n            fitness = func(candidate)\n            # Store the fitness and candidate in the meta-model\n            model[candidate] = fitness\n        # Create a simple neural network to predict the fitness\n        import tensorflow as tf\n        inputs = tf.keras.Input(shape=(self.dim,))\n        x = tf.keras.layers.Dense(1, activation='linear')(inputs)\n        model = tf.keras.Model(inputs=inputs, outputs=x)\n        model.compile(optimizer='adam', loss='mean_squared_error')\n        # Train the meta-model on the stored data\n        model.fit(list(model.input_shape[0]), list(model.output_shape[1]), epochs=10)\n        return model\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_ESO = MetaEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaEvolutionarySwarmOptimization", "description": "Novel \"Meta-Learning-based Evolutionary Swarm Optimization\" algorithm combining meta-learning and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unhashable type: 'numpy.ndarray'\").", "error": "TypeError(\"unhashable type: 'numpy.ndarray'\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "a5a56c4f-1fae-4174-a740-d538c5d18aea", "solution": "import numpy as np\n\nclass MultiObjectiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.objectives = []\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(fitness), :]\n            self.best_fitness = np.min(fitness)\n\n            # Probabilistic Refinement\n            for _ in range(10):\n                new_candidate = self.candidates[np.random.choice(self.population_size, size=1, replace=False), :]\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(fitness), :] = new_candidate\n\n            # Evolutionary Strategy\n            self.candidates[np.random.choice(self.population_size, size=10, p=[0.25, 0.75], replace=False), :] = self.candidates[np.random.choice(self.population_size, size=10, p=[0.25, 0.75], replace=False), :] + \\\n                                                                                      self.candidates[np.random.choice(self.population_size, size=10, p=[0.25, 0.75], replace=False), :] * \\\n                                                                                      np.random.uniform(-0.1, 0.1, size=(10, self.dim))\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(fitness)]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(fitness), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmulti_objective_EA = MultiObjectiveEvolutionaryAlgorithm(budget=100, dim=2)\nbest_candidate, best_fitness = multi_objective_EA(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MultiObjectiveEvolutionaryAlgorithm", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Probabilistic Refinement\" combining multiple objectives and probabilistic refinement for black box optimization problems.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 1 is out of bounds for axis 0 with size 1').", "error": "IndexError('index 1 is out of bounds for axis 0 with size 1')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "0f7cf867-cef2-463a-a844-b0e80188ac49", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MetaEvolutionarySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.meta_model = self.create_meta_model()\n\n    def create_meta_model(self):\n        model = {}\n        for _ in range(10):\n            model['strategy'] = np.random.choice(['add','subtract','multiply', 'divide'])\n            model['param'] = np.random.uniform(-0.1, 0.1)\n        return model\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Evolutionary Strategy\n            for _ in range(10):\n                new_candidate = copy.deepcopy(self.candidates[np.random.choice(self.population_size, size=1, replace=False), :])\n                if np.random.rand() < 0.25:\n                    new_candidate += self.meta_model['strategy'](new_candidate) * self.meta_model['param']\n                else:\n                    new_candidate -= self.meta_model['strategy'](new_candidate) * self.meta_model['param']\n                new_fitness = func(new_candidate)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_candidate\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_candidate\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nmeta_ESO = MetaEvolutionarySwarmOptimization(budget=100, dim=2)\nbest_candidate, best_fitness = meta_ESO(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "MetaEvolutionarySwarmOptimization", "description": "Novel \"Meta-Learning based Evolutionary Swarm Optimization\" algorithm combining meta-learning and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'numpy.str_' object is not callable\").", "error": "TypeError(\"'numpy.str_' object is not callable\")", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
{"id": "dd59402f-5f93-47e6-85be-7f47c82115fd", "solution": "import numpy as np\nimport random\n\nclass HybridPSOES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 100\n        self.candidates = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_candidate = np.random.uniform(-5.0, 5.0, self.dim)\n        self.best_fitness = np.inf\n        self.particles = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        self.w = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            fitness = func(self.candidates[:, 0])\n            self.best_candidate = self.candidates[np.argmin(self.candidates[:, 0]), :]\n            self.best_fitness = fitness\n\n            # Particle Swarm Optimization\n            for i in range(self.population_size):\n                r1 = np.random.uniform(0, 1, self.dim)\n                r2 = np.random.uniform(0, 1, self.dim)\n                new_particle = self.particles[i] + self.velocity[i] + self.c1 * r1 * (self.best_candidate - self.particles[i]) + self.c2 * r2 * (self.candidates[np.argmin(self.candidates[:, 0]), :] - self.particles[i])\n                new_fitness = func(new_particle)\n                if new_fitness < self.best_fitness:\n                    self.best_candidate = new_particle\n                    self.best_fitness = new_fitness\n                    self.candidates[np.argmin(self.candidates[:, 0]), :] = new_particle\n                    self.particles[i] = new_particle\n                    self.velocity[i] = self.w * self.velocity[i] + 0.1 * (self.best_candidate - self.particles[i])\n\n            # Evolutionary Strategy\n            for i in range(self.population_size):\n                if random.random() < 0.25:\n                    self.particles[i] += self.velocity[i]\n                    self.particles[i] = np.clip(self.particles[i], -5.0, 5.0)\n\n            # Selection\n            self.candidates = self.candidates[np.argsort(self.candidates[:, 0])]\n            self.population_size = self.population_size // 2\n\n            # Mutation\n            self.candidates[np.random.choice(self.population_size, size=self.population_size, replace=False), :] += np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n\n            # Check if the best candidate is improved\n            if self.best_fitness < func(self.best_candidate):\n                self.candidates[np.argmin(self.candidates[:, 0]), :] = self.best_candidate\n\n        return self.best_candidate, self.best_fitness\n\n# Example usage:\ndef func(x):\n    return x[0]**2 + x[1]**2\n\nhybrid_PSOES = HybridPSOES(budget=100, dim=2)\nbest_candidate, best_fitness = hybrid_PSOES(func)\nprint(f\"Best candidate: {best_candidate}, Best fitness: {best_fitness}\")", "name": "HybridPSOES", "description": "Novel \"Particle Swarm Optimization with Evolutionary Strategies\" algorithm combining swarm intelligence and evolutionary strategies to tackle black box optimization problems.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "52a3e472-adf0-4fac-a6d6-ed44b292da6b", "metadata": {}, "mutation_prompt": null}
