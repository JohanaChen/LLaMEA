{"id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 79, in <module>\n  File \"<string>\", line 74, in func\nTypeError: unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\n.", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 79, in <module>\n  File \"<string>\", line 74, in func\nTypeError: unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "94d2d554-67a1-42b2-91e9-3942238854ee", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.p = np.zeros((self.dim,))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update p using probability\n            self.p = self.p * 0.35 + np.random.uniform(0, 1, self.dim) * 0.65\n            self.swarm[:, i] = self.swarm[:, i] + self.p\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with adaptive probability", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "4a56ff0c-d88d-40c7-94bc-cf5cc832b759", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refined_swarm = np.zeros((self.dim,))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # refine the solution using probability refinement\n            if np.random.rand() < self.persists:\n                self.refined_swarm = np.copy(self.swarm[:, i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.persists:\n                        self.refined_swarm[j] = self.refined_swarm[j] + np.random.uniform(-0.1, 0.1)\n                self.swarm[:, i] = self.refined_swarm\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "da04dce7-ad27-43f4-a942-e389039dbaa3", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "a14d70b6-4c5a-4a2c-b522-83f5b6499f0e", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # adaptive probability update\n            if i > 0 and np.random.rand() < self.adaptive_prob:\n                # randomly select a solution and perturb it\n                idx = np.random.randint(0, self.budget)\n                self.swarm[:, idx] = self.swarm[:, idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for the perturbed solution\n                fitness = func(self.swarm[:, idx])\n                # update pbest for the perturbed solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, idx])\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "001993f0-556a-47e0-96b8-ebf7c1ed9124", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.p = 0.35  # adaptive probability\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # refine strategy with adaptive probability\n            if np.random.rand() < self.p:\n                # randomly change individual lines of the selected solution\n                idx = np.random.choice(self.dim, size=1, replace=False)\n                self.swarm[:, i] = np.copy(self.swarm[:, i])\n                self.swarm[:, i, idx] = self.swarm[:, i, idx] + np.random.uniform(-0.1, 0.1)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('too many indices for array: array is 2-dimensional, but 3 were indexed').", "error": "IndexError('too many indices for array: array is 2-dimensional, but 3 were indexed')", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "8d4a2ba5-cdf6-48ca-8b57-95e5911799ce", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_prob = np.zeros((self.dim,))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive probability\n                self.adaptive_prob = np.minimum(self.adaptive_prob, self.pbest)\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive probability\n                self.adaptive_prob = np.minimum(self.adaptive_prob, self.pbest)\n            # update swarm using adaptive probability\n            for j in range(self.dim):\n                if random.random() < self.adaptive_prob[j]:\n                    # perturb solution in the swarm\n                    self.swarm[j, i] = self.swarm[j, i] + np.random.uniform(-0.1, 0.1)\n                    # calculate fitness for each solution in the swarm\n                    fitness = func(self.swarm[:, i])\n                    # update pbest for each solution\n                    self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                    # calculate harmony mean\n                    harmony_mean = np.mean(fitness)\n                    # calculate best harmony\n                    best_harmony = np.min(fitness)\n                    # update gbest if best harmony is found\n                    if best_harmony < np.min(self.gbest):\n                        self.gbest = np.copy(self.swarm[:, i])\n                        self.w = self.q\n                    # update adaptive probability\n                    self.adaptive_prob = np.minimum(self.adaptive_prob, self.pbest)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "5256838d-029e-476c-badb-e92de82c3238", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine pbest by perturbing it randomly\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                self.pbest = self.pbest + perturbation\n                # ensure pbest is within the bounds\n                self.pbest = np.clip(self.pbest, -5.0, 5.0)\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "a274df1a-f885-41aa-b432-0fb47494b4c9", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # probability for refinement\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probability-based refinement.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "8e2fa10d-0d89-4114-b5bf-6233ae147958", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "477c9029-339f-423e-9a07-0a36536c0e4d", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "ae5117e5-f4c6-4464-8ed2-88cea43455eb", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.p = 0.35  # adaptive probability\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update swarm using adaptive probability\n            if np.random.rand() < self.p:\n                # randomly select a solution from the swarm\n                idx = np.random.randint(0, self.dim)\n                # perturb the selected solution\n                self.swarm[idx, i] = self.swarm[idx, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for the perturbed solution\n                fitness = func(self.swarm[:, i])\n                # update pbest for the perturbed solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean for the perturbed solution\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony for the perturbed solution\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found for the perturbed solution\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence.').", "error": "ValueError('setting an array element with a sequence.')", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "78a190dd-35d0-40e4-b94e-2aa824770ba5", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probability refinement", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "670c6d34-18ca-48b4-b0f4-dc2abb9d9e36", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = 0.35  # adaptive probability\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.probability:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "a2254534-8d81-4e1f-8563-3a98dc86d122", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine strategy by changing individual lines\n                for j in range(self.dim):\n                    if np.random.rand() < self.persists:\n                        self.swarm[j, i] += np.random.uniform(-0.1, 0.1)\n                        # calculate fitness for each solution in the swarm\n                        fitness = func(self.swarm[:, i])\n                        # update pbest for each solution\n                        self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                        # calculate harmony mean\n                        harmony_mean = np.mean(fitness)\n                        # calculate best harmony\n                        best_harmony = np.min(fitness)\n                        # update gbest if best harmony is found\n                        if best_harmony < np.min(self.gbest):\n                            self.gbest = np.copy(self.swarm[:, i])\n                            self.w = self.q\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "cdd8c312-acc1-4a17-8b75-8178653ca5a1", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "2ac4c6f7-7536-4d8e-b4d1-3aabd01bd59a", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearchProbabilisticRefinement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine pbest with probability 0.35\n                if np.random.rand() < 0.35:\n                    self.pbest = np.copy(self.swarm[:, i])\n                # refine gbest with probability 0.05\n                elif np.random.rand() < 0.05:\n                    self.gbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearchProbabilisticRefinement(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearchProbabilisticRefinement", "description": "Novel \"Multi-Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "849cc1fa-24f6-499a-8aef-be0cbdb25284", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability_refinement = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update probability refinement\n                self.probability_refinement[:, i] = np.random.rand(self.dim)\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update probability refinement\n                self.probability_refinement[:, i] = np.random.rand(self.dim)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probability refinement.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "14b5434b-75ca-4e43-bfca-1e1972124295", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearchAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_probabilities = np.random.uniform(0.0, 1.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n                self.adaptive_probabilities[:, i] = np.random.uniform(0.0, 1.0, self.dim)\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms_adaptive = MultiSwarmHarmonySearchAdaptive(100, 2)\nbest_x = ms_adaptive(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearchAdaptive", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "340bda07-d1bc-40af-8dc2-46be0162711a", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = 0.5\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n                self.probability = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # adaptive probability update\n            if self.w > 0.5:\n                self.probability = 0.4\n            elif self.w < 0.5:\n                self.probability = 0.6\n            else:\n                self.probability = 0.5\n\n            # update swarm using adaptive probability\n            if np.random.rand() < self.probability:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "f94e4806-ff6f-4f7d-b5b0-5ffa22361391", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine pbest with probabilistic refinement\n                refine_prob = np.random.rand()\n                if refine_prob < 0.5:\n                    self.pbest = np.copy(self.swarm[:, i])\n                elif refine_prob < 0.8:\n                    # perturb pbest with a small step\n                    self.pbest = np.minimum(self.pbest, self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim))\n                else:\n                    # reflect pbest\n                    self.pbest = 2 * self.pbest - self.swarm[:, i]\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "f0e46f34-f9ea-4f0d-9965-8574ac25ae52", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine pbest with probabilistic refinement\n                refine_mask = np.random.choice([True, False], size=self.dim, p=[self.persists, 1-self.persists])\n                self.pbest[refine_mask] = self.swarm[refine_mask, i]\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "7829ee9b-d593-456d-9615-e0afb8b93dc7", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine the strategy by changing individual lines with probability 0.35\n                refined_swarm = np.copy(self.swarm[:, i])\n                for j in range(self.dim):\n                    if np.random.rand() < 0.35:\n                        refined_swarm[j] = self.swarm[j, i] + np.random.uniform(-0.1, 0.1)\n                self.swarm[:, i] = refined_swarm\n                # recalculate fitness and update pbest and gbest\n                fitness = func(self.swarm[:, i])\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                best_harmony = np.min(fitness)\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "f47a71c4-9260-4526-a480-e3c81a157036", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = np.ones(self.budget)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.probability[i]:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update probability\n                self.probability[i] = np.random.rand()\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update probability\n                self.probability[i] = np.random.rand()\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "cdbaf366-9f9a-4554-8e00-77d7ad22a6f3", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = 0.5\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update probability\n            if best_harmony < np.min(self.gbest):\n                self.probability = self.q\n            else:\n                self.probability = 0.5\n\n            # update swarm using adaptive probability\n            if np.random.rand() < self.probability:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "6d59d173-cae1-479b-9c68-df4d6e4789b8", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine the strategy of the best individual\n                best_index = np.argmin(self.gbest)\n                self.swarm[best_index, i] = self.swarm[best_index, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence.').", "error": "ValueError('setting an array element with a sequence.')", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "e890bc9f-5cf6-430f-8a87-e7ae98e80838", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # randomly select a solution to refine\n                refine_idx = np.random.choice(self.budget)\n                # perturb the selected solution\n                self.swarm[:, refine_idx] = self.swarm[:, refine_idx] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for the refined solution\n                fitness = func(self.swarm[:, refine_idx])\n                # update pbest for the refined solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, refine_idx])\n                # calculate harmony mean for the refined solution\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony for the refined solution\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found for the refined solution\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, refine_idx])\n                    self.w = self.q\n\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "b733165a-635a-4097-adc1-72b5c0f1d5ef", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability_refinement = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # Refine the strategy of the top 10% of the swarm\n            top_10_percent = np.argsort(fitness)[:int(self.probability_refinement * self.budget)]\n            for j in top_10_percent:\n                # Randomly change the value of the solution\n                idx = np.random.randint(0, self.dim)\n                self.swarm[:, j] = self.swarm[:, j] + np.random.uniform(-0.1, 0.1, self.dim)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "399ce357-5845-45f2-be5d-253b3bacf535", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using adaptive reflection operator\n            elif self.w < 0.5:\n                # calculate reflection coefficient\n                rho = 1 - np.exp(-self.rho * (i / self.budget))\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - rho * self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Reflection\" algorithm", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "ce91df15-7818-44b1-8a63-1853e594b3f8", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine the strategy by changing individual lines\n                indices = np.random.choice(self.dim, size=int(self.budget * self.persists), replace=False)\n                for j in indices:\n                    self.swarm[j, i] = np.random.uniform(-5.0, 5.0)\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "a83bc162-d717-4c55-909c-326c0e461aa1", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refined_swarm = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # refine the swarm using probability refinement\n            if np.random.rand() < self.persists:\n                self.refined_swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                fitness = func(self.refined_swarm[:, i])\n                self.pbest = np.minimum(self.pbest, self.refined_swarm[:, i])\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "16cc628e-0eb5-419c-888f-05ba9c0d02ea", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.reflection_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # apply reflection with probability 35%\n            if np.random.rand() < self.reflection_probability:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Reflection\" algorithm", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "091a156a-fc94-4a7f-9a00-2f6bc4100626", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refine_probability = 0.35  # refine probability\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # refine solution with probability\n            if np.random.rand() < self.refine_probability:\n                self.refine_solution(self.swarm[:, i])\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n    def refine_solution(self, x):\n        # refine solution by changing individual lines with probability\n        refined_x = x.copy()\n        for j in range(self.dim):\n            if np.random.rand() < self.refine_probability:\n                refined_x[j] = x[j] + np.random.uniform(-0.1, 0.1)\n        return refined_x\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probability refinement", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "83e57418-3b32-43cd-8a7c-33da9753e530", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refine_prob = 0.35  # probability of refinement\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # refine the solution with probability 0.35\n                if np.random.rand() < self.refine_prob:\n                    # calculate the probability of refinement\n                    refine_prob = np.random.rand()\n                    # refine the solution\n                    if refine_prob < 0.2:\n                        # perturb the solution\n                        self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.05, 0.05, self.dim)\n                    elif refine_prob < 0.4:\n                        # reflect the solution\n                        self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                    else:\n                        # add noise to the solution\n                        self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "a718eaaa-2e17-47d7-a07a-939aa4a9bbb5", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "d3a9835d-c168-4a4a-a397-d6de884e92ee", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refined_swarm = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # refine the solution with probability 0.35\n            if np.random.rand() < self.persists:\n                self.refined_swarm[i] = self.swarm[i]\n                self.swarm[i] = self.swarm[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                self.refined_swarm[i] = np.minimum(self.refined_swarm[i], self.swarm[i])\n                self.swarm[i] = np.minimum(self.swarm[i], self.gbest)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 2').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 2')", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "216b08c3-f2a1-4fef-801c-d261d33e9688", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "87268071-9f8e-43f5-b472-8b4457a0389a", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refine_prob = 0.1  # probability of refinement\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # refine the solution with probability 0.1\n            if np.random.rand() < self.refine_prob and self.w!= 0.5:\n                # refine the solution using a small perturbation\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.01, 0.01, self.dim)\n                # calculate fitness for the refined solution\n                fitness = func(self.swarm[:, i])\n                # update pbest for the refined solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Refinement\" algorithm", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "b730793a-4db5-45cc-b306-c9d1eb2b8320", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearchAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.probability:\n                # refine strategy by changing individual lines\n                for j in range(self.dim):\n                    if np.random.rand() < self.probability:\n                        self.swarm[j, i] = self.swarm[j, i] + np.random.uniform(-0.1, 0.1)\n                # recalculate fitness\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearchAdaptive(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearchAdaptive", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "80d79d55-5b44-4fcd-9d4f-ec8d450720a5", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "d1c18295-35dd-4eae-a83e-8149cc457b2f", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearchAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = np.ones(self.budget)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n                self.probability[i] = np.random.uniform(0.0, 1.0)\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearchAdaptive(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearchAdaptive", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "5cdbbbe5-779f-4b0e-8c03-3ff78b600fc8", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refined_swarm = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # refine the solution using probability refinement\n            if np.random.rand() < self.persists:\n                # select a solution from the swarm\n                index = np.random.randint(0, self.budget)\n                # refine the solution using perturbation\n                refined_solution = self.swarm[:, index] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for the refined solution\n                fitness = func(refined_solution)\n                # update the refined swarm\n                self.refined_swarm[:, i] = refined_solution\n                # update the pbest for the refined solution\n                self.pbest = np.minimum(self.pbest, refined_solution)\n\n    def get_refined_swarm(self):\n        return self.refined_swarm\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))\nprint(\"Refined Swarm:\", ms.get_refined_swarm())", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "92da2b59-b13c-40fc-aee9-c99cad2a3520", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.probability:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "618994d1-f82b-4bf3-bc99-89f7da795962", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "a892f06f-fc4f-4c9c-93a7-6a800fa687ab", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probabilistic refinement", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "f35b36c7-b8ab-4d94-b747-1bb8bc731849", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refined_swarm = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update refined swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the refined swarm\n                self.refined_swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the refined swarm\n                fitness = func(self.refined_swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.refined_swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.refined_swarm[:, i])\n                    self.w = self.q\n            # update refined swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the refined swarm\n                self.refined_swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the refined swarm\n                fitness = func(self.refined_swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.refined_swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.refined_swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "413d891d-9182-4ebe-8670-40ad8ec7ff9d", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refine_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # refine strategy with probability 0.35\n            if np.random.rand() < self.refine_prob:\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        self.swarm[j, i] += np.random.uniform(-0.1, 0.1)\n                    else:\n                        self.swarm[j, i] -= np.random.uniform(-0.1, 0.1)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "71028048-b5db-4ac9-91ed-75d1f8a53ac3", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "10944802-ce66-4efb-bd86-fa4cd7dcd7d9", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refinement_probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # refine strategy with probability\n            if np.random.rand() < self.refinement_probability:\n                # refine individual\n                for j in range(self.dim):\n                    self.swarm[:, i] = np.clip(self.swarm[:, i] + np.random.uniform(-0.1, 0.1), -5.0, 5.0)\n                    # calculate fitness for each solution in the swarm\n                    fitness = func(self.swarm[:, i])\n                    # update pbest for each solution\n                    self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                    # calculate harmony mean\n                    harmony_mean = np.mean(fitness)\n                    # calculate best harmony\n                    best_harmony = np.min(fitness)\n                    # update gbest if best harmony is found\n                    if best_harmony < np.min(self.gbest):\n                        self.gbest = np.copy(self.swarm[:, i])\n                        self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "86f7c017-8b5d-4294-bdfd-3c970fe47c56", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearchAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_probabilities = np.ones((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n                self.adaptive_probabilities[:, i] = np.random.uniform(0.0, 1.0, self.dim)\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearchAdaptive(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearchAdaptive", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "5079fab1-cc87-4041-8cf9-d292313cbd15", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probability refinement", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "fb1037e0-9ac7-4b59-b200-d665f4246ea5", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_probabilities = [0.35, 0.35, 0.3]\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # adapt probabilities\n            if i % 10 == 0:\n                self.adaptive_probabilities = [0.35 + random.uniform(-0.05, 0.05), 0.35 + random.uniform(-0.05, 0.05), 0.3 + random.uniform(-0.05, 0.05)]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "d13839ba-2de6-44e5-9cfd-a086c6650e14", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_prob = np.zeros((self.dim,))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update adaptive probability\n            for j in range(self.dim):\n                if np.random.rand() < 0.35:\n                    self.adaptive_prob[j] += 1\n                else:\n                    self.adaptive_prob[j] = max(0, self.adaptive_prob[j] - 1)\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "8d93e50d-8e5b-439a-aee7-4dda73f64e18", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_probability = np.zeros((self.dim,))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive probability\n                self.adaptive_probability = np.minimum(self.adaptive_probability, self.pbest)\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive probability\n                self.adaptive_probability = np.minimum(self.adaptive_probability, self.pbest)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "4a9d7590-99d4-48c8-9ab5-3033a400ef3c", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_probabilities = np.ones((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update adaptive probabilities\n            self.adaptive_probabilities[:, i] = self.adaptive_probabilities[:, i] * 0.9 + np.random.rand(self.dim) * 0.1\n\n            # update swarm using adaptive probabilities\n            self.swarm[:, i] = self.swarm[:, i] * (1 - self.adaptive_probabilities[:, i]) + self.swarm[:, i] * self.adaptive_probabilities[:, i]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "d555c59e-2681-48da-9edc-4c751e725a83", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine the strategy by changing individual lines\n                for j in range(self.dim):\n                    if np.random.rand() < self.persists:\n                        self.swarm[j, i] = self.swarm[j, i] + np.random.uniform(-0.1, 0.1)\n                        self.swarm[j, i] = np.clip(self.swarm[j, i], -5.0, 5.0)\n                # recalculate fitness and update pbest and gbest\n                fitness = func(self.swarm[:, i])\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                best_harmony = np.min(fitness)\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probabilistic refinement.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "d17decea-2717-4c70-aa4b-5d91196f03f3", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = 0.5\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n                self.probability = np.random.uniform(0.2, 0.8)\n            else:\n                self.probability = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm with probability\n                if np.random.rand() < self.probability:\n                    self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "1ac5d929-2545-435e-9e60-e3283b6b6785", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adapt_prob = 0.35\n        self.dim_adj = 0.1\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # adjust dimensionality\n            if np.random.rand() < self.adapt_prob:\n                self.dim_adj = np.random.uniform(0.0, 1.0)\n                self.dim = int(self.dim * (1 + self.dim_adj))\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with adaptive probability and dimensionality adjustment", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "5890019b-fa40-4fe2-967f-8088967caed8", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm with adaptive probability\n                perturbation_probability = 0.5 + (0.5 * np.random.rand())\n                if perturbation_probability < 0.1:\n                    # perturb solutions in the swarm\n                    self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Perturbation\" algorithm", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "6d4d156d-f016-418f-80fc-c5d26a2616f0", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.probability:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "464ac7db-4cab-4276-90a5-591b96672210", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.persists_prob = 0.35  # adaptive persistence probability\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists_prob:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "a93c69ea-1f6c-44c9-bffe-f57db0db4d8d", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refine = np.random.uniform(0.0, 1.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # refine the solutions\n                self.refine[:, i] = np.random.uniform(0.0, 1.0, self.dim)\n                self.swarm[:, i] = self.swarm[:, i] + self.refine[:, i]\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # refine the solutions\n                self.refine[:, i] = np.random.uniform(0.0, 1.0, self.dim)\n                self.swarm[:, i] = self.swarm[:, i] + self.refine[:, i]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "1dd7decf-11ca-4c03-9396-1dcc9be32f7a", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probability refinement", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "82aac3bc-442c-499e-ad6a-e7a4aa1061b6", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_prob = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update adaptive probability\n            for j in range(self.dim):\n                if np.random.rand() < 0.1:\n                    self.adaptive_prob[j, i] = np.random.uniform(0.0, 1.0)\n                else:\n                    self.adaptive_prob[j, i] = self.adaptive_prob[j, i] * 0.9\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "503d6380-26e7-4c89-b009-060ef4a406b5", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_perturbation = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive perturbation\n                self.adaptive_perturbation[:, i] = np.random.uniform(-0.1, 0.1, self.dim)\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive perturbation\n                self.adaptive_perturbation[:, i] = np.random.uniform(-0.1, 0.1, self.dim)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Perturbation\" algorithm", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "6554a43b-d632-43f3-82a6-5413cdf2443c", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearchAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_prob = 0.35  # adaptive probability\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update adaptive probability\n            if np.random.rand() < self.adaptive_prob:\n                self.persists += np.random.uniform(-0.1, 0.1)\n                self.persists = max(0, min(1, self.persists))  # ensure persistence probability is between 0 and 1\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearchAdaptive(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearchAdaptive", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "063d534d-b687-4523-b3e9-7584b9ab9820", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "b37d78e8-da3a-4b91-8a32-eebc48bfa321", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.mutation_prob = 0.2  # mutation probability\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # apply mutation with probability\n            if np.random.rand() < self.mutation_prob:\n                # generate a new solution by perturbing the current solution\n                new_solution = self.swarm[:, i] + np.random.uniform(-0.5, 0.5, self.dim)\n                # calculate fitness for the new solution\n                fitness = func(new_solution)\n                # update pbest for the new solution\n                self.pbest = np.minimum(self.pbest, new_solution)\n                # update gbest if the new solution is better\n                if fitness < np.min(fitness):\n                    self.gbest = np.copy(new_solution)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with adaptive mutation strategy and probabilistic line search", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "1835b5b6-eb13-4ea2-89b7-ff19be39d7a9", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # refine strategy with probability\n            if np.random.rand() < self.persists:\n                # select a solution to refine\n                idx = np.random.choice(self.dim)\n                # perturb solution\n                self.swarm[idx, i] = self.swarm[idx, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence.').", "error": "ValueError('setting an array element with a sequence.')", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "73f5266a-7d94-46cd-bcbf-b89a3955abe1", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probability-based strategy refinement", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "18497da5-358e-487e-a3d5-5722a0beea5b", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refine_probability = 0.1  # refine probability\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # refine strategy with probability\n            if np.random.rand() < self.refine_probability:\n                # refine pbest\n                pbest_refined = self.pbest + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for refined pbest\n                fitness_refined = func(pbest_refined)\n                # update pbest if refined fitness is better\n                if np.mean(fitness_refined) < np.mean(fitness):\n                    self.pbest = pbest_refined\n                # refine gbest\n                gbest_refined = self.gbest + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for refined gbest\n                fitness_refined = func(gbest_refined)\n                # update gbest if refined fitness is better\n                if np.mean(fitness_refined) < np.mean(fitness):\n                    self.gbest = gbest_refined\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "20cd583c-7903-43ed-bf93-ef22b69832af", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = 0.5\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n                self.probability = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update probability\n                if best_harmony < np.min(self.gbest):\n                    self.probability = 0.3\n                elif best_harmony < np.min(self.gbest) * 0.9:\n                    self.probability = 0.4\n                else:\n                    self.probability = 0.5\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update probability\n                if best_harmony < np.min(self.gbest):\n                    self.probability = 0.3\n                elif best_harmony < np.min(self.gbest) * 0.9:\n                    self.probability = 0.4\n                else:\n                    self.probability = 0.5\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "18490120-4374-4ec0-90f2-652cb807bc40", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refine_prob = 0.1  # refine probability\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # refine strategy with probability 10%\n            if np.random.rand() < self.refine_prob:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with adaptive probability for refining the strategy", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "7bb5fdac-3f81-4731-866b-18b7712ef8c7", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probabilistic refinement", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "24dcd402-4272-4f06-8df5-95d1b096243d", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refinement_probability = np.random.uniform(0.0, 1.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # Refine the solution with a probability of 0.35\n            if np.random.rand() < self.refinement_probability[i]:\n                # Perturb the solution\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "f22815ca-a189-460c-91cc-e06e99a05251", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "648da952-ffd7-47f1-9fa4-d7cd300df132", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearchAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n                self.probability[:, i] = np.random.uniform(0.0, 1.0, self.dim)\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update swarm using adaptive probability\n            for j in range(self.dim):\n                if self.probability[j, i] > 0.0:\n                    # perturb solution in the swarm\n                    self.swarm[j, i] = self.swarm[j, i] + np.random.uniform(-0.1, 0.1)\n                    # calculate fitness for each solution in the swarm\n                    fitness = func(self.swarm[:, i])\n                    # update pbest for each solution\n                    self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                    # calculate harmony mean\n                    harmony_mean = np.mean(fitness)\n                    # calculate best harmony\n                    best_harmony = np.min(fitness)\n                    # update gbest if best harmony is found\n                    if best_harmony < np.min(self.gbest):\n                        self.gbest = np.copy(self.swarm[:, i])\n                        self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearchAdaptive(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearchAdaptive", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "caf6cf6d-1a49-41a6-9ae4-8603a446f8f1", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine pbest with probability refinement\n                refine_probability = np.random.rand()\n                if refine_probability < 0.5:\n                    self.pbest = np.copy(self.swarm[:, i])\n                else:\n                    # perturb pbest with probability refinement\n                    self.pbest = self.pbest + np.random.uniform(-0.1, 0.1, self.dim)\n                    # calculate fitness for each solution in the swarm\n                    fitness = func(self.swarm[:, i])\n                    # update pbest for each solution\n                    self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                    # calculate harmony mean\n                    harmony_mean = np.mean(fitness)\n                    # calculate best harmony\n                    best_harmony = np.min(fitness)\n                    # update gbest if best harmony is found\n                    if best_harmony < np.min(self.gbest):\n                        self.gbest = np.copy(self.swarm[:, i])\n                        self.w = self.q\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "a12635a3-6282-490a-9fc4-b085608d31d2", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_prob = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.adaptive_prob:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "6910d362-d9f1-41d4-b515-85555093a7ac", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearchAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = np.ones(self.budget)\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update probability of each solution\n            self.probability[i] = np.random.rand()\n            if self.probability[i] < self.persists:\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearchAdaptive(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearchAdaptive", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "f7613aa5-bd34-49d1-bbbb-71900f2706c4", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability_refinement = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # Refine the strategy with probability refinement\n            if np.random.rand() < self.probability_refinement:\n                # Randomly select a solution from the swarm\n                selected_solution = self.swarm[:, i]\n                # Perturb the selected solution\n                selected_solution = selected_solution + np.random.uniform(-0.1, 0.1, self.dim)\n                # Calculate the fitness of the perturbed solution\n                fitness = func(selected_solution)\n                # Update the pbest for the perturbed solution\n                self.pbest = np.minimum(self.pbest, selected_solution)\n                # Update the gbest if the perturbed solution is better\n                if fitness < np.min(self.gbest):\n                    self.gbest = np.copy(selected_solution)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "8d60d2c1-909b-4309-a7e1-0e1afd881d43", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refinement_prob = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n                self.refinement_prob = np.ones((self.dim, self.budget))  # reset refinement probability\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # refine solutions with probability 0.35\n                if np.random.rand() < self.refinement_prob[i]:\n                    self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.05, 0.05, self.dim)\n                    self.refinement_prob[i] = 1.0  # update refinement probability\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # refine solutions with probability 0.35\n                if np.random.rand() < self.refinement_prob[i]:\n                    self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i] + np.random.uniform(-0.05, 0.05, self.dim)\n                    self.refinement_prob[i] = 1.0  # update refinement probability\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "0715c6f1-9b09-41ff-be1b-f98cb40cf101", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine pbest for each solution\n                for j in range(self.dim):\n                    if np.random.rand() < self.persists:\n                        self.pbest[j] = self.swarm[j, i]\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probabilistic refinement", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "4eb82dc6-d896-40a2-8ee5-4d33d827d71e", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probability refinement.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "fb24d721-d31a-497f-8bf6-458e74f6317d", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = 0.35\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.probability:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "af55c46d-bffc-4572-9dcb-58b073a8b943", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with adaptive probability.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "d2ae6b9c-db55-46ed-b250-548f802f65e5", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refine = np.zeros((self.dim,))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                else:\n                    # refine the solution using probabilistic refinement\n                    self.refine = self.swarm[:, i]\n                    self.refine = self.refine + np.random.uniform(-0.05, 0.05, self.dim)\n                    self.swarm[:, i] = np.clip(self.refine, -5.0, 5.0)\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                else:\n                    # refine the solution using probabilistic refinement\n                    self.refine = self.swarm[:, i]\n                    self.refine = self.refine + np.random.uniform(-0.05, 0.05, self.dim)\n                    self.swarm[:, i] = np.clip(self.refine, -5.0, 5.0)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "6a4fa544-6deb-40ce-a36c-3cc34ee7cc3a", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "5ca86467-9397-45c2-8979-2254d372f134", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine strategy by changing individual lines\n                refined_swarm = self.refine_strategy(self.swarm[:, i])\n                self.swarm[:, i] = refined_swarm\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n    def refine_strategy(self, individual):\n        # refine strategy by changing individual lines with probability 0.35\n        if np.random.rand() < 0.35:\n            # change a random line of the individual\n            index = np.random.randint(0, self.dim)\n            individual[index] = np.random.uniform(-5.0, 5.0)\n        return individual\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with probability refinement", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "8c3f57c7-942a-4581-b281-6fc588250b71", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm with adaptive probability\n                perturb_prob = np.random.rand()\n                if perturb_prob < 0.5:\n                    self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Perturbation\" algorithm", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "57ac24f1-fe77-434c-a6a3-51f24d9c94bd", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.probability = np.ones((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update probability of each solution\n                self.probability = np.minimum(self.probability, self.swarm[:, i])\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update probability of each solution\n                self.probability = np.minimum(self.probability, self.swarm[:, i])\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "ed6764ab-8c7f-417d-88ed-af6a26a8e224", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_probabilities = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive probabilities\n                for j in range(self.dim):\n                    if self.swarm[j, i]!= self.gbest[j]:\n                        self.adaptive_probabilities[j, i] += 0.35\n                    else:\n                        self.adaptive_probabilities[j, i] += 0.15\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive probabilities\n                for j in range(self.dim):\n                    if self.swarm[j, i]!= self.gbest[j]:\n                        self.adaptive_probabilities[j, i] += 0.35\n                    else:\n                        self.adaptive_probabilities[j, i] += 0.15\n            # normalize adaptive probabilities\n            self.adaptive_probabilities /= np.sum(self.adaptive_probabilities, axis=1, keepdims=True)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "6399ad7c-2d81-4aa6-92ab-04d9ac1d2f1c", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_mutations = np.zeros((self.dim,))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update adaptive mutation strategy\n            if np.random.rand() < 0.35:\n                self.adaptive_mutations = np.random.uniform(-0.1, 0.1, self.dim)\n                self.swarm[:, i] = self.swarm[:, i] + self.adaptive_mutations\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search\" algorithm with adaptive mutation strategy", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "384533da-4195-4892-8997-412053d85ab4", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_prob = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update adaptive probability\n            self.adaptive_prob[:, i] = np.random.uniform(0.0, 1.0, self.dim)\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive probability\n                self.adaptive_prob[:, i] = np.random.uniform(0.0, 1.0, self.dim)\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive probability\n                self.adaptive_prob[:, i] = np.random.uniform(0.0, 1.0, self.dim)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "ad41e349-e2a3-487c-abf9-460368451005", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                # refine strategy by changing individual lines\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        self.swarm[j, i] += np.random.uniform(-0.1, 0.1)\n                    elif np.random.rand() < 0.5:\n                        self.swarm[j, i] -= np.random.uniform(-0.1, 0.1)\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probability Refinement\" algorithm", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "5243f4f9-6054-4ed5-84bd-f8523e12df07", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Probabilistic Refinement\" algorithm", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "9a236f15-368e-49ff-8420-1e6112dde2dc", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "1e8acd45-7686-43d3-a500-b0136df3f80e", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_probabilities = np.ones((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive probabilities\n                self.adaptive_probabilities[:, i] = np.random.uniform(0.0, 1.0, self.dim)\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n                # update adaptive probabilities\n                self.adaptive_probabilities[:, i] = np.random.uniform(0.0, 1.0, self.dim)\n\n            # update swarm using adaptive probabilities\n            self.swarm[:, i] = self.swarm[:, i] * self.adaptive_probabilities[:, i]\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\").", "error": "TypeError(\"unsupported operand type(s) for ** or pow(): 'NoneType' and 'int'\")", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "0e2e106c-b4d9-4e51-bef0-fc4916aa8713", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 0.35  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.adaptive_probabilities = np.zeros((self.dim, self.budget))\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # update adaptive probability\n            for j in range(self.dim):\n                if fitness[j] == np.min(fitness):\n                    self.adaptive_probabilities[j, i] = 1.0\n                else:\n                    self.adaptive_probabilities[j, i] = 0.0\n\n            # update probabilities\n            for j in range(self.dim):\n                probabilities = np.sum(self.adaptive_probabilities[j, :], axis=0) / np.sum(self.adaptive_probabilities[j, :])\n                self.persists = np.mean(probabilities)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearch(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
{"id": "272acd52-a1ef-4db2-8de0-2b6b141223c3", "solution": "import numpy as np\n\nclass MultiSwarmHarmonySearchAdaptiveRefinement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.persists = 2  # persistence probability\n        self.q = 0.5  # q parameter\n        self.rho = 0.5  # rho parameter\n        self.w = 0.5  # w parameter\n        self.pbest = np.zeros((self.dim,))\n        self.gbest = np.zeros((self.dim,))\n        self.swarm = np.random.uniform(-5.0, 5.0, (self.dim, self.budget))\n        self.refinement_prob = 0.35  # refinement probability\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # calculate fitness for each solution in the swarm\n            fitness = func(self.swarm[:, i])\n\n            # update pbest for each solution\n            self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n\n            # calculate harmony mean\n            harmony_mean = np.mean(fitness)\n\n            # calculate best harmony\n            best_harmony = np.min(fitness)\n\n            # update gbest if best harmony is found\n            if best_harmony < np.min(self.gbest):\n                self.gbest = np.copy(self.swarm[:, i])\n                self.w = self.q\n\n            # update persistence probability\n            if np.random.rand() < self.persists:\n                self.pbest = np.copy(self.swarm[:, i])\n                self.w = 0.5\n\n            # update swarm using harmony search operators\n            if self.w > 0.5:\n                # perturb solutions in the swarm\n                self.swarm[:, i] = self.swarm[:, i] + np.random.uniform(-0.1, 0.1, self.dim)\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n            # update swarm using reflection operator\n            elif self.w < 0.5:\n                # reflect solutions in the swarm\n                self.swarm[:, i] = 2 * self.swarm[:, i] - self.swarm[:, i]\n                # calculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n            # refine the solution with probability 0.35\n            if np.random.rand() < self.refinement_prob:\n                # refine the solution by perturbing a random dimension\n                dim_to_refine = np.random.choice(self.dim)\n                self.swarm[:, i, dim_to_refine] = self.swarm[:, i, dim_to_refine] + np.random.uniform(-0.1, 0.1)\n                # recalculate fitness for each solution in the swarm\n                fitness = func(self.swarm[:, i])\n                # update pbest for each solution\n                self.pbest = np.minimum(self.pbest, self.swarm[:, i])\n                # calculate harmony mean\n                harmony_mean = np.mean(fitness)\n                # calculate best harmony\n                best_harmony = np.min(fitness)\n                # update gbest if best harmony is found\n                if best_harmony < np.min(self.gbest):\n                    self.gbest = np.copy(self.swarm[:, i])\n                    self.w = self.q\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nms = MultiSwarmHarmonySearchAdaptiveRefinement(100, 2)\nbest_x = ms(func)\nprint(\"Best x:\", best_x)\nprint(\"Best f(x):\", func(best_x))", "name": "MultiSwarmHarmonySearchAdaptiveRefinement", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Refinement\" algorithm", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('too many indices for array: array is 2-dimensional, but 3 were indexed').", "error": "IndexError('too many indices for array: array is 2-dimensional, but 3 were indexed')", "parent_id": "bf81ce64-21f8-45aa-97f5-ad1f1cabd5e8", "metadata": {}, "mutation_prompt": null}
